{"sha": "0f1f7b0840885fac83ff3f36053cb04833c1af5a", "node_id": "C_kwDOAAsO6NoAKDBmMWY3YjA4NDA4ODVmYWM4M2ZmM2YzNjA1M2NiMDQ4MzNjMWFmNWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T07:21:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T07:21:54Z"}, "message": "Auto merge of #2808 - saethlin:rustup, r=oli-obk\n\nRustup", "tree": {"sha": "13d070bafb527926160cbdb47a22237471acd71f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13d070bafb527926160cbdb47a22237471acd71f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f1f7b0840885fac83ff3f36053cb04833c1af5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f1f7b0840885fac83ff3f36053cb04833c1af5a", "html_url": "https://github.com/rust-lang/rust/commit/0f1f7b0840885fac83ff3f36053cb04833c1af5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f1f7b0840885fac83ff3f36053cb04833c1af5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "html_url": "https://github.com/rust-lang/rust/commit/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715"}, {"sha": "05f633bdaf11ca3485b7e9fd2af11e9a917af459", "url": "https://api.github.com/repos/rust-lang/rust/commits/05f633bdaf11ca3485b7e9fd2af11e9a917af459", "html_url": "https://github.com/rust-lang/rust/commit/05f633bdaf11ca3485b7e9fd2af11e9a917af459"}], "stats": {"total": 19818, "additions": 16051, "deletions": 3767}, "files": [{"sha": "ce797a7a8371dcb2be3b2666459864e9b16f3b9e", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -41,7 +41,7 @@ no_llvm_build\n /inst/\n /llvm/\n /mingw-build/\n-/build/\n+build/\n /build-rust-analyzer/\n /dist/\n /unicode-downloads"}, {"sha": "e79f2f089c1ed21ce7e360a70d29022e4a7c6203", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,3 @@\n-[submodule \"src/rust-installer\"]\n-\tpath = src/tools/rust-installer\n-\turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/doc/nomicon\"]\n \tpath = src/doc/nomicon\n \turl = https://github.com/rust-lang/nomicon.git"}, {"sha": "7776964adf9ffcbaa98f0964d530bb0ae098c94f", "filename": "Cargo.lock", "status": "modified", "additions": 760, "deletions": 88, "changes": 848, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -42,6 +42,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bf6ccdb167abbf410dcb915cabd428929d7f6a04980b54a11f26a39f1c7f7107\"\n dependencies = [\n  \"cfg-if\",\n+ \"getrandom\",\n  \"once_cell\",\n  \"version_check\",\n ]\n@@ -112,6 +113,12 @@ dependencies = [\n  \"object 0.29.0\",\n ]\n \n+[[package]]\n+name = \"arc-swap\"\n+version = \"1.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bddcadddf5e9015d310179a59bb28c4d4b9920ad0f11e8e14dbadf654890c9a6\"\n+\n [[package]]\n name = \"array_tool\"\n version = \"1.0.3\"\n@@ -132,47 +139,36 @@ checksum = \"5a2f58b0bb10c380af2b26e57212856b8c9a59e0925b4c20f4a174a49734eaf7\"\n \n [[package]]\n name = \"askama\"\n-version = \"0.11.0\"\n+version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d8f355701c672c2ba3d718acbd213f740beea577cc4eae66accdffe15be1882\"\n+checksum = \"47cbc3cf73fa8d9833727bbee4835ba5c421a0d65b72daf9a7b5d0e0f9cfb57e\"\n dependencies = [\n  \"askama_derive\",\n  \"askama_escape\",\n- \"askama_shared\",\n ]\n \n [[package]]\n name = \"askama_derive\"\n-version = \"0.11.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84704cab5b7ae0fd3a9f78ee5eb7b27f3749df445f04623db6633459ae283267\"\n-dependencies = [\n- \"askama_shared\",\n- \"proc-macro2\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"askama_escape\"\n-version = \"0.10.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9a1bb320f97e6edf9f756bf015900038e43c7700e059688e5724a928c8f3b8d5\"\n-\n-[[package]]\n-name = \"askama_shared\"\n version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dae03eebba55a2697a376e58b573a29fe36893157173ac8df312ad85f3c0e012\"\n+checksum = \"e80b5ad1afe82872b7aa3e9de9b206ecb85584aa324f0f60fa4c903ce935936b\"\n dependencies = [\n- \"askama_escape\",\n+ \"basic-toml\",\n+ \"mime\",\n+ \"mime_guess\",\n  \"nom\",\n  \"proc-macro2\",\n  \"quote\",\n  \"serde\",\n  \"syn\",\n- \"toml 0.5.7\",\n ]\n \n+[[package]]\n+name = \"askama_escape\"\n+version = \"0.10.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"619743e34b5ba4e9703bba34deac3427c72507c7159f5fd030aea8cac0cfe341\"\n+\n [[package]]\n name = \"atty\"\n version = \"0.2.14\"\n@@ -213,16 +209,25 @@ checksum = \"349a06037c7bf932dd7e7d1f653678b2038b9ad46a74102f1fc7bd7872678cce\"\n \n [[package]]\n name = \"base64\"\n-version = \"0.13.1\"\n+version = \"0.21.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8\"\n+checksum = \"a4a4ddaa51a5bc52a6948f74c06d20aaaddb71924eab79b8c97a8c556e942d6a\"\n \n [[package]]\n name = \"base64ct\"\n version = \"1.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b645a089122eccb6111b4f81cbc1a49f5900ac4666bb93ac027feaecf15607bf\"\n \n+[[package]]\n+name = \"basic-toml\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c0de75129aa8d0cceaf750b89013f0e08804d6ec61416da787b35ad0d7cddf1\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -260,23 +265,32 @@ dependencies = [\n \n [[package]]\n name = \"bstr\"\n-version = \"1.0.1\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fca0852af221f458706eb0725c03e4ed6c46af9ac98e6a689d5e634215d594dd\"\n+checksum = \"5ffdb39cb703212f3c11973452c2861b972f757b021158f3516ba10f2fa8b2c1\"\n dependencies = [\n  \"memchr\",\n  \"once_cell\",\n  \"regex-automata 0.1.10\",\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"btoi\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9dd6407f73a9b8b6162d8a2ef999fe6afd7cc15902ebf42c5cd296addf17e0ad\"\n+dependencies = [\n+ \"num-traits\",\n+]\n+\n [[package]]\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"flate2\",\n- \"hex 0.4.2\",\n+ \"hex\",\n  \"rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -358,8 +372,10 @@ dependencies = [\n  \"fwdansi\",\n  \"git2\",\n  \"git2-curl\",\n+ \"gix\",\n+ \"gix-features\",\n  \"glob\",\n- \"hex 0.4.2\",\n+ \"hex\",\n  \"hmac\",\n  \"home\",\n  \"http-auth\",\n@@ -498,18 +514,18 @@ dependencies = [\n \n [[package]]\n name = \"cargo-util\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n dependencies = [\n  \"anyhow\",\n  \"core-foundation\",\n- \"crypto-hash\",\n  \"filetime\",\n- \"hex 0.4.2\",\n+ \"hex\",\n  \"jobserver\",\n  \"libc\",\n  \"log\",\n  \"miow 0.5.0\",\n  \"same-file\",\n+ \"sha2\",\n  \"shell-escape\",\n  \"tempfile\",\n  \"walkdir\",\n@@ -796,6 +812,12 @@ dependencies = [\n  \"rustc-semver\",\n ]\n \n+[[package]]\n+name = \"clru\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b8191fa7302e03607ff0e237d4246cc043ff5b3cb9409d995172ba3bea16b807\"\n+\n [[package]]\n name = \"collect-license-metadata\"\n version = \"0.1.0\"\n@@ -844,24 +866,6 @@ dependencies = [\n  \"winapi\",\n ]\n \n-[[package]]\n-name = \"commoncrypto\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n-dependencies = [\n- \"commoncrypto-sys\",\n-]\n-\n-[[package]]\n-name = \"commoncrypto-sys\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fed34f46747aa73dfaa578069fd8279d2818ade2b55f38f22a9401c7f4083e2\"\n-dependencies = [\n- \"libc\",\n-]\n-\n [[package]]\n name = \"compiler_builtins\"\n version = \"0.1.87\"\n@@ -1081,18 +1085,6 @@ dependencies = [\n  \"typenum\",\n ]\n \n-[[package]]\n-name = \"crypto-hash\"\n-version = \"0.3.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8a77162240fd97248d19a564a565eb563a3f592b386e4136fb300909e67dddca\"\n-dependencies = [\n- \"commoncrypto\",\n- \"hex 0.3.2\",\n- \"openssl\",\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"cstr\"\n version = \"0.2.8\"\n@@ -1297,9 +1289,9 @@ dependencies = [\n \n [[package]]\n name = \"dunce\"\n-version = \"1.0.2\"\n+version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"453440c271cf5577fd2a40e4942540cb7d0d2f85e27c8d07dd0023c925a67541\"\n+checksum = \"0bd4b30a6560bbd9b4620f4de34c3f14f60848e58a9b7216801afcb4c7b31c3c\"\n \n [[package]]\n name = \"ecdsa\"\n@@ -1509,14 +1501,14 @@ checksum = \"a214f5bb88731d436478f3ae1f8a277b62124089ba9fb67f4f93fb100ef73c90\"\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.14\"\n+version = \"0.2.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d34cfa13a63ae058bfa601fe9e313bbdb3746427c1459185464ce0fcf62e1e8\"\n+checksum = \"8a3de6e8d11b22ff9edc6d916f890800597d60f8b2da1caf2955c274638d6412\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n- \"winapi\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -1818,6 +1810,559 @@ dependencies = [\n  \"url\",\n ]\n \n+[[package]]\n+name = \"gix\"\n+version = \"0.39.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dabfac58aecb4a38cdd2568de66eb1f0d968fd6726f5a80cb8bea7944ef10cc0\"\n+dependencies = [\n+ \"gix-actor\",\n+ \"gix-attributes\",\n+ \"gix-config\",\n+ \"gix-credentials\",\n+ \"gix-date\",\n+ \"gix-diff\",\n+ \"gix-discover\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-index\",\n+ \"gix-lock\",\n+ \"gix-mailmap\",\n+ \"gix-object\",\n+ \"gix-odb\",\n+ \"gix-pack\",\n+ \"gix-path\",\n+ \"gix-prompt\",\n+ \"gix-protocol\",\n+ \"gix-ref\",\n+ \"gix-refspec\",\n+ \"gix-revision\",\n+ \"gix-sec\",\n+ \"gix-tempfile\",\n+ \"gix-transport\",\n+ \"gix-traverse\",\n+ \"gix-url\",\n+ \"gix-validate\",\n+ \"gix-worktree\",\n+ \"log\",\n+ \"once_cell\",\n+ \"prodash\",\n+ \"signal-hook\",\n+ \"smallvec\",\n+ \"thiserror\",\n+ \"unicode-normalization\",\n+]\n+\n+[[package]]\n+name = \"gix-actor\"\n+version = \"0.19.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dc22b0cdc52237667c301dd7cdc6ead8f8f73c9f824e9942c8ebd6b764f6c0bf\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"gix-date\",\n+ \"itoa\",\n+ \"nom\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-attributes\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2231a25934a240d0a4b6f4478401c73ee81d8be52de0293eedbc172334abf3e1\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-path\",\n+ \"gix-quote\",\n+ \"thiserror\",\n+ \"unicode-bom\",\n+]\n+\n+[[package]]\n+name = \"gix-bitmap\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"024bca0c7187517bda5ea24ab148c9ca8208dd0c3e2bea88cdb2008f91791a6d\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-chunk\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b0d39583cab06464b8bf73b3f1707458270f0e7383cb24c3c9c1a16e6f792978\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-command\"\n+version = \"0.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b2c6f75c1e0f924de39e750880a6e21307194bb1ab773efe3c7d2d787277f8ab\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+]\n+\n+[[package]]\n+name = \"gix-config\"\n+version = \"0.18.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"52c62e26ce11f607712e4f49a0a192ed87675d30187fd61be070abbd607d12f1\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-config-value\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-path\",\n+ \"gix-ref\",\n+ \"gix-sec\",\n+ \"memchr\",\n+ \"nom\",\n+ \"once_cell\",\n+ \"smallvec\",\n+ \"thiserror\",\n+ \"unicode-bom\",\n+]\n+\n+[[package]]\n+name = \"gix-config-value\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"693d4a4ba0531e46fe558459557a5b29fb86c3e4b2666c1c0861d93c7c678331\"\n+dependencies = [\n+ \"bitflags\",\n+ \"bstr 1.3.0\",\n+ \"gix-path\",\n+ \"libc\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-credentials\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5be32b5fe339a31b8e53fa854081dc914c45020dcb64637f3c21baf69c96fc1b\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-command\",\n+ \"gix-config-value\",\n+ \"gix-path\",\n+ \"gix-prompt\",\n+ \"gix-sec\",\n+ \"gix-url\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-date\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b96271912ce39822501616f177dea7218784e6c63be90d5f36322ff3a722aae2\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"itoa\",\n+ \"thiserror\",\n+ \"time 0.3.17\",\n+]\n+\n+[[package]]\n+name = \"gix-diff\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"585b0834d4b6791a848637c4e109545fda9b0f29b591ba55edb33ceda6e7856b\"\n+dependencies = [\n+ \"gix-hash\",\n+ \"gix-object\",\n+ \"imara-diff\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-discover\"\n+version = \"0.15.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"91c204adba5ebd211c74735cbb65817d277e154486bac0dffa3701f163b80350\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"dunce\",\n+ \"gix-hash\",\n+ \"gix-path\",\n+ \"gix-ref\",\n+ \"gix-sec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-features\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5e6a9dfa7b3c1a99315203e8b97f8f99f3bd95731590607abeaa5ca31bc41fe3\"\n+dependencies = [\n+ \"bytes\",\n+ \"crc32fast\",\n+ \"crossbeam-channel\",\n+ \"flate2\",\n+ \"gix-hash\",\n+ \"libc\",\n+ \"once_cell\",\n+ \"parking_lot 0.12.1\",\n+ \"prodash\",\n+ \"sha1_smol\",\n+ \"thiserror\",\n+ \"walkdir\",\n+]\n+\n+[[package]]\n+name = \"gix-glob\"\n+version = \"0.5.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"93e43efd776bc543f46f0fd0ca3d920c37af71a764a16f2aebd89765e9ff2993\"\n+dependencies = [\n+ \"bitflags\",\n+ \"bstr 1.3.0\",\n+]\n+\n+[[package]]\n+name = \"gix-hash\"\n+version = \"0.10.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0c0c5a9f4d621d4f4ea046bb331df5c746ca735b8cae5b234cc2be70ee4dbef0\"\n+dependencies = [\n+ \"hex\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-hashtable\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9609c1b8f36f12968e6a6098f7cdb52004f7d42d570f47a2d6d7c16612f19acb\"\n+dependencies = [\n+ \"gix-hash\",\n+ \"hashbrown 0.13.1\",\n+ \"parking_lot 0.12.1\",\n+]\n+\n+[[package]]\n+name = \"gix-index\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c12caf7886c7ba06f2b28835cdc2be1dca86bd047d00299d2d49e707ce1c2616\"\n+dependencies = [\n+ \"bitflags\",\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"filetime\",\n+ \"gix-bitmap\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-lock\",\n+ \"gix-object\",\n+ \"gix-traverse\",\n+ \"itoa\",\n+ \"memmap2 0.5.10\",\n+ \"smallvec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-lock\"\n+version = \"4.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"66119ff8a4a395d0ea033fef718bc85f8b4f0855874f4ce1e005fc16cfe1f66e\"\n+dependencies = [\n+ \"fastrand\",\n+ \"gix-tempfile\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-mailmap\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2b66aea5e52875cd4915f4957a6f4b75831a36981e2ec3f5fad9e370e444fe1a\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-actor\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-object\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8df068db9180ee935fbb70504848369e270bdcb576b05c0faa8b9fd3b86fc017\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"gix-actor\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-validate\",\n+ \"hex\",\n+ \"itoa\",\n+ \"nom\",\n+ \"smallvec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-odb\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e9a5f9e1afbd509761977a2ea02869cedaaba500b4e783deb2e4de5179a55a80\"\n+dependencies = [\n+ \"arc-swap\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-object\",\n+ \"gix-pack\",\n+ \"gix-path\",\n+ \"gix-quote\",\n+ \"parking_lot 0.12.1\",\n+ \"tempfile\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-pack\"\n+version = \"0.32.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e51db84e1459a8022e518d40a8778028d793dbb28e4d35c9a5eaf92658fb0775\"\n+dependencies = [\n+ \"clru\",\n+ \"gix-chunk\",\n+ \"gix-diff\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-object\",\n+ \"gix-path\",\n+ \"gix-tempfile\",\n+ \"gix-traverse\",\n+ \"memmap2 0.5.10\",\n+ \"parking_lot 0.12.1\",\n+ \"smallvec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-packetline\"\n+version = \"0.14.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d63e5e5a9a92d4fc6b63ff9d94954d25c779ce25c98d5bbe2e4399aa42f7073c\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"hex\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-path\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f6c104a66dec149cb8f7aaafc6ab797654cf82d67f050fd0cb7e7294e328354b\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-prompt\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a20cebf73229debaa82574c4fd20dcaf00fa8d4bfce823a862c4e990d7a0b5b4\"\n+dependencies = [\n+ \"gix-command\",\n+ \"gix-config-value\",\n+ \"nix\",\n+ \"parking_lot 0.12.1\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-protocol\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d372ab11d5d28ac21800e3f1a6603a67c1ead57f6f5fab07e1e73e960f331c1\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"gix-credentials\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-transport\",\n+ \"maybe-async\",\n+ \"nom\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-quote\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a282f5a8d9ee0b09ec47390ac727350c48f2f5c76d803cd8da6b3e7ad56e0bcb\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-ref\"\n+version = \"0.26.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"90a0ed29e581f04b904ecd0c32b11f33b8209b5a0af9c43f415249a4f2fba632\"\n+dependencies = [\n+ \"gix-actor\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-lock\",\n+ \"gix-object\",\n+ \"gix-path\",\n+ \"gix-tempfile\",\n+ \"gix-validate\",\n+ \"memmap2 0.5.10\",\n+ \"nom\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-refspec\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aba332462bda2e8efeae4302b39a6ed01ad56ef772fd5b7ef197cf2798294d65\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-hash\",\n+ \"gix-revision\",\n+ \"gix-validate\",\n+ \"smallvec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-revision\"\n+version = \"0.12.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ed98e4a0254953c64bc913bd23146a1de662067d5cf974cbdde396958b39e5b0\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-date\",\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-object\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-sec\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e8ffa5bf0772f9b01de501c035b6b084cf9b8bb07dec41e3afc6a17336a65f47\"\n+dependencies = [\n+ \"bitflags\",\n+ \"dirs\",\n+ \"gix-path\",\n+ \"libc\",\n+ \"windows\",\n+]\n+\n+[[package]]\n+name = \"gix-tempfile\"\n+version = \"4.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"88751f247234b1f73c8e8056fd835a0999b04e596e052302cb71186005dc4b27\"\n+dependencies = [\n+ \"libc\",\n+ \"once_cell\",\n+ \"parking_lot 0.12.1\",\n+ \"signal-hook\",\n+ \"signal-hook-registry\",\n+ \"tempfile\",\n+]\n+\n+[[package]]\n+name = \"gix-transport\"\n+version = \"0.27.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d633947b36a2fbbc089195bdc71621158f1660c2ff2a6b12b0279c16e2f764bc\"\n+dependencies = [\n+ \"base64\",\n+ \"bstr 1.3.0\",\n+ \"curl\",\n+ \"gix-command\",\n+ \"gix-credentials\",\n+ \"gix-features\",\n+ \"gix-packetline\",\n+ \"gix-quote\",\n+ \"gix-sec\",\n+ \"gix-url\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-traverse\"\n+version = \"0.24.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dd9a4a07bb22168dc79c60e1a6a41919d198187ca83d8a5940ad8d7122a45df3\"\n+dependencies = [\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-object\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-url\"\n+version = \"0.15.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"044072b7ce8601b62dcec841b92129f5cc677072823324121b395d766ac5f528\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-features\",\n+ \"gix-path\",\n+ \"home\",\n+ \"thiserror\",\n+ \"url\",\n+]\n+\n+[[package]]\n+name = \"gix-validate\"\n+version = \"0.7.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b69ddb780ea1465255e66818d75b7098371c58dbc9560da4488a44b9f5c7e443\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-worktree\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b7cb9af6e56152953d8fe113c4f9d7cf60cf7a982362711e9200a255579b49cb\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-attributes\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-hash\",\n+ \"gix-index\",\n+ \"gix-object\",\n+ \"gix-path\",\n+ \"io-close\",\n+ \"thiserror\",\n+]\n+\n [[package]]\n name = \"glob\"\n version = \"0.3.0\"\n@@ -1933,12 +2478,6 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"hex\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n-\n [[package]]\n name = \"hex\"\n version = \"0.4.2\"\n@@ -2132,6 +2671,16 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"imara-diff\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e98c1d0ad70fc91b8b9654b1f33db55e59579d3b3de2bffdced0fdb810570cb8\"\n+dependencies = [\n+ \"ahash 0.8.2\",\n+ \"hashbrown 0.12.3\",\n+]\n+\n [[package]]\n name = \"indenter\"\n version = \"0.3.3\"\n@@ -2201,6 +2750,16 @@ dependencies = [\n  \"unic-langid\",\n ]\n \n+[[package]]\n+name = \"io-close\"\n+version = \"0.3.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9cadcf447f06744f8ce713d2d6239bb5bde2c357a452397a9ed90c625da390bc\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"io-lifetimes\"\n version = \"1.0.3\"\n@@ -2234,9 +2793,9 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"1.0.2\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+checksum = \"453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6\"\n \n [[package]]\n name = \"jemalloc-sys\"\n@@ -2287,6 +2846,7 @@ dependencies = [\n  \"anyhow\",\n  \"clap 4.1.4\",\n  \"fs-err\",\n+ \"rustc-hash\",\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n@@ -2521,6 +3081,17 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \n+[[package]]\n+name = \"maybe-async\"\n+version = \"0.2.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0f1b8c13cb1f814b634a96b2c725449fe7ed464a7b8781de8688be5ffbd3f305\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"md-5\"\n version = \"0.10.0\"\n@@ -2578,7 +3149,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cbdc226fa10994e8f66a4d2f6f000148bc563a1c671b6dcd2135737018033d8a\"\n dependencies = [\n  \"log\",\n- \"memmap2\",\n+ \"memmap2 0.2.1\",\n  \"parking_lot 0.11.2\",\n  \"perf-event-open-sys\",\n  \"rustc-hash\",\n@@ -2604,6 +3175,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"memmap2\"\n+version = \"0.5.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"memoffset\"\n version = \"0.7.1\"\n@@ -2613,6 +3193,22 @@ dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"mime\"\n+version = \"0.3.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2a60c7ce501c71e03a9c9c0d35b861413ae925bd979cc7a4e30d060069aaac8d\"\n+\n+[[package]]\n+name = \"mime_guess\"\n+version = \"2.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4192263c238a5f0d0c6bfd21f336a313a4ce1c450542449ca191bb657b4642ef\"\n+dependencies = [\n+ \"mime\",\n+ \"unicase\",\n+]\n+\n [[package]]\n name = \"minifier\"\n version = \"0.2.2\"\n@@ -2689,6 +3285,18 @@ version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e4a24736216ec316047a1fc4252e27dabb04218aa4a3f37c6e7ddbf1f9782b54\"\n \n+[[package]]\n+name = \"nix\"\n+version = \"0.26.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bfdda3d196821d6af13126e40375cdf7da646a96114af134d5f417a9a1dc8e1a\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"static_assertions\",\n+]\n+\n [[package]]\n name = \"nom\"\n version = \"7.1.0\"\n@@ -2744,6 +3352,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"num_threads\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2819ce041d2ee131036f4fc9d6ae7ae125a3a40e97ba64d04fe799ad9dabbb44\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"object\"\n version = \"0.29.0\"\n@@ -3244,6 +3861,15 @@ dependencies = [\n  \"std\",\n ]\n \n+[[package]]\n+name = \"prodash\"\n+version = \"23.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d73c6b64cb5b99eb63ca97d378685712617ec0172ff5c04cd47a489d3e2c51f8\"\n+dependencies = [\n+ \"parking_lot 0.12.1\",\n+]\n+\n [[package]]\n name = \"profiler_builtins\"\n version = \"0.0.0\"\n@@ -3590,11 +4216,14 @@ dependencies = [\n  \"bstr 0.2.17\",\n  \"clap 3.2.20\",\n  \"getrandom\",\n+ \"hashbrown 0.12.3\",\n  \"libc\",\n  \"libz-sys\",\n+ \"once_cell\",\n  \"rand\",\n  \"regex\",\n  \"serde_json\",\n+ \"smallvec\",\n  \"syn\",\n  \"url\",\n  \"winapi\",\n@@ -3885,7 +4514,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n- \"memmap2\",\n+ \"memmap2 0.2.1\",\n  \"parking_lot 0.11.2\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n@@ -4654,15 +5283,9 @@ dependencies = [\n name = \"rustc_smir\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_borrowck\",\n- \"rustc_driver\",\n- \"rustc_hir\",\n- \"rustc_interface\",\n  \"rustc_middle\",\n- \"rustc_mir_dataflow\",\n- \"rustc_mir_transform\",\n- \"rustc_serialize\",\n- \"rustc_trait_selection\",\n+ \"rustc_span\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -4850,6 +5473,7 @@ dependencies = [\n name = \"rustdoc-json-types\"\n version = \"0.1.0\"\n dependencies = [\n+ \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n ]\n@@ -5098,6 +5722,12 @@ dependencies = [\n  \"digest\",\n ]\n \n+[[package]]\n+name = \"sha1_smol\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ae1a47186c03a32177042e55dbc5fd5aee900b8e0069a8d70fba96a9375cd012\"\n+\n [[package]]\n name = \"sha2\"\n version = \"0.10.6\"\n@@ -5130,6 +5760,25 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"42a568c8f2cd051a4d283bd6eb0343ac214c1b0f1ac19f93e1175b2dee38c73d\"\n \n+[[package]]\n+name = \"signal-hook\"\n+version = \"0.3.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"732768f1176d21d09e076c23a93123d40bba92d50c4058da34d45c8de8e682b9\"\n+dependencies = [\n+ \"libc\",\n+ \"signal-hook-registry\",\n+]\n+\n+[[package]]\n+name = \"signal-hook-registry\"\n+version = \"1.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"signature\"\n version = \"1.6.4\"\n@@ -5170,9 +5819,9 @@ checksum = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.8.1\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc88c725d61fc6c3132893370cac4a0200e3fedf5da8331c570664b1987f5ca2\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"snap\"\n@@ -5595,6 +6244,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a561bf4617eebd33bca6434b988f39ed798e527f51a1e797d0ee4f61c0a38376\"\n dependencies = [\n  \"itoa\",\n+ \"libc\",\n+ \"num_threads\",\n  \"serde\",\n  \"time-core\",\n  \"time-macros\",\n@@ -5835,7 +6486,7 @@ version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"54ddb6f31025943e2f9d59237f433711c461a43d9415974c3eb3a4902edc1c1f\"\n dependencies = [\n- \"bstr 1.0.1\",\n+ \"bstr 1.3.0\",\n  \"cargo_metadata 0.15.3\",\n  \"color-eyre\",\n  \"colored\",\n@@ -5958,6 +6609,12 @@ dependencies = [\n  \"matches\",\n ]\n \n+[[package]]\n+name = \"unicode-bom\"\n+version = \"1.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"63ec69f541d875b783ca40184d655f2927c95f0bffd486faa83cd3ac3529ec32\"\n+\n [[package]]\n name = \"unicode-ident\"\n version = \"1.0.5\"\n@@ -6226,6 +6883,21 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n+[[package]]\n+name = \"windows\"\n+version = \"0.43.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"04662ed0e3e5630dfa9b26e4cb823b817f1a9addda855d973a9458c236556244\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\""}, {"sha": "4e974bbe9747e5f295319a4b90cb5e5a8081eae6", "filename": "RELEASES.md", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,3 +1,99 @@\n+Version 1.68.0 (2023-03-09)\n+==========================\n+\n+<a id=\"1.68.0-Language\"></a>\n+\n+Language\n+--------\n+\n+- [Stabilize default_alloc_error_handler](https://github.com/rust-lang/rust/pull/102318/)\n+  This allows usage of `alloc` on stable without requiring the \n+  definition of a handler for allocation failure. Defining custom handlers is still unstable.\n+- [Stabilize `efiapi` calling convention.](https://github.com/rust-lang/rust/pull/105795/)\n+- [Remove implicit promotion for types with drop glue](https://github.com/rust-lang/rust/pull/105085/)\n+\n+<a id=\"1.68.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+\n+- [Change `bindings_with_variant_name` to deny-by-default](https://github.com/rust-lang/rust/pull/104154/)\n+- [Allow .. to be parsed as let initializer](https://github.com/rust-lang/rust/pull/105701/)\n+- [Add `armv7-sony-vita-newlibeabihf` as a tier 3 target](https://github.com/rust-lang/rust/pull/105712/)\n+- [Always check alignment during compile-time const evaluation](https://github.com/rust-lang/rust/pull/104616/)\n+- [Disable \"split dwarf inlining\" by default.](https://github.com/rust-lang/rust/pull/106709/)\n+- [Add vendor to Fuchsia's target triple](https://github.com/rust-lang/rust/pull/106429/)\n+- [Enable sanitizers for s390x-linux](https://github.com/rust-lang/rust/pull/107127/)\n+\n+<a id=\"1.68.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+\n+- [Loosen the bound on the Debug implementation of Weak.](https://github.com/rust-lang/rust/pull/90291/)\n+- [Make `std::task::Context` !Send and !Sync](https://github.com/rust-lang/rust/pull/95985/)\n+- [PhantomData layout guarantees](https://github.com/rust-lang/rust/pull/104081/)\n+- [Don't derive Debug for `OnceWith` & `RepeatWith`](https://github.com/rust-lang/rust/pull/104163/)\n+- [Implement DerefMut for PathBuf](https://github.com/rust-lang/rust/pull/105018/)\n+- [Add O(1) `Vec -> VecDeque` conversion guarantee](https://github.com/rust-lang/rust/pull/105128/)\n+- [Leak amplification for peek_mut() to ensure BinaryHeap's invariant is always met](https://github.com/rust-lang/rust/pull/105851/)\n+\n+<a id=\"1.68.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`{core,std}::pin::pin!`](https://doc.rust-lang.org/stable/std/pin/macro.pin.html)\n+- [`impl From<bool> for {f32,f64}`](https://doc.rust-lang.org/stable/std/primitive.f32.html#impl-From%3Cbool%3E-for-f32)\n+- [`std::path::MAIN_SEPARATOR_STR`](https://doc.rust-lang.org/stable/std/path/constant.MAIN_SEPARATOR_STR.html)\n+- [`impl DerefMut for PathBuf`](https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#impl-DerefMut-for-PathBuf)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`VecDeque::new`](https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.new)\n+\n+<a id=\"1.68.0-Cargo\"></a>\n+\n+Cargo\n+-----\n+\n+- [Stabilize sparse registry support for crates.io](https://github.com/rust-lang/cargo/pull/11224/)\n+- [`cargo build --verbose` tells you more about why it recompiles.](https://github.com/rust-lang/cargo/pull/11407/)\n+- [Show progress of crates.io index update even `net.git-fetch-with-cli` option enabled](https://github.com/rust-lang/cargo/pull/11579/)\n+\n+<a id=\"1.68.0-Misc\"></a>\n+\n+Misc\n+----\n+\n+<a id=\"1.68.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Add `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` to future-incompat report](https://github.com/rust-lang/rust/pull/103418/)\n+- [Only specify `--target` by default for `-Zgcc-ld=lld` on wasm](https://github.com/rust-lang/rust/pull/101792/)\n+- [Bump `IMPLIED_BOUNDS_ENTAILMENT` to Deny + ReportNow](https://github.com/rust-lang/rust/pull/106465/)\n+- [`std::task::Context` no longer implements Send and Sync](https://github.com/rust-lang/rust/pull/95985)\n+\n+<a id=\"1.68.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Encode spans relative to the enclosing item](https://github.com/rust-lang/rust/pull/84762/)\n+- [Don't normalize in AstConv](https://github.com/rust-lang/rust/pull/101947/)\n+- [Find the right lower bound region in the scenario of partial order relations](https://github.com/rust-lang/rust/pull/104765/)\n+- [Fix impl block in const expr](https://github.com/rust-lang/rust/pull/104889/)\n+- [Check ADT fields for copy implementations considering regions](https://github.com/rust-lang/rust/pull/105102/)\n+- [rustdoc: simplify JS search routine by not messing with lev distance](https://github.com/rust-lang/rust/pull/105796/)\n+- [Enable ThinLTO for rustc on `x86_64-pc-windows-msvc`](https://github.com/rust-lang/rust/pull/103591/)\n+- [Enable ThinLTO for rustc on `x86_64-apple-darwin`](https://github.com/rust-lang/rust/pull/103647/)\n+\n Version 1.67.1 (2023-02-09)\n ===========================\n \n@@ -3765,6 +3861,8 @@ Version 1.41.1 (2020-02-27)\n * [Always check types of static items][69145]\n * [Always check lifetime bounds of `Copy` impls][69145]\n * [Fix miscompilation in callers of `Layout::repeat`][69225]\n+* [Rust 1.41.0 was announced as the last Rust release with tier 1 or tier 2 support for 32-bit Apple targets][apple-32bit-drop].\n+  That announcement did not expect a patch release. 1.41.1 also includes release binaries for these targets.\n \n [69225]: https://github.com/rust-lang/rust/issues/69225\n [69145]: https://github.com/rust-lang/rust/pull/69145\n@@ -3857,7 +3955,7 @@ Misc\n Compatibility Notes\n -------------------\n \n-- [As previously announced 1.41.0 will be the last tier 1 release for 32-bit\n+- [As previously announced 1.41 will be the last tier 1 release for 32-bit\n   Apple targets.][apple-32bit-drop] This means that the source code is still\n   available to build, but the targets are no longer being tested and release\n   binaries for those platforms will no longer be distributed by the Rust project."}, {"sha": "6fed0b660e86efe92c3bcd43b42ddd5ef16af8a3", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -12,7 +12,7 @@ use crate::ptr::P;\n use crate::token::{self, Token};\n use crate::tokenstream::*;\n \n-use rustc_data_structures::map_in_place::MapInPlace;\n+use rustc_data_structures::flat_map_in_place::FlatMapInPlace;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;"}, {"sha": "fa0552e012de1f430a87c060a13a0136ca217f79", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -4,7 +4,7 @@ use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;\n use crate::BorrowIndex;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonUseContext, PlaceContext, Visitor};\n@@ -26,10 +26,10 @@ pub struct BorrowSet<'tcx> {\n     /// NOTE: a given location may activate more than one borrow in the future\n     /// when more general two-phase borrow support is introduced, but for now we\n     /// only need to store one borrow index.\n-    pub activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n+    pub activation_map: FxIndexMap<Location, Vec<BorrowIndex>>,\n \n     /// Map from local to all the borrows on that local.\n-    pub local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+    pub local_map: FxIndexMap<mir::Local, FxIndexSet<BorrowIndex>>,\n \n     pub(crate) locals_state_at_exit: LocalsStateAtExit,\n }\n@@ -175,8 +175,8 @@ struct GatherBorrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     location_map: FxIndexMap<Location, BorrowData<'tcx>>,\n-    activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n-    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+    activation_map: FxIndexMap<Location, Vec<BorrowIndex>>,\n+    local_map: FxIndexMap<mir::Local, FxIndexSet<BorrowIndex>>,\n \n     /// When we encounter a 2-phase borrow statement, it will always\n     /// be assigning into a temporary TEMP:\n@@ -186,7 +186,7 @@ struct GatherBorrows<'a, 'tcx> {\n     /// We add TEMP into this map with `b`, where `b` is the index of\n     /// the borrow. When we find a later use of this activation, we\n     /// remove from the map (and add to the \"tombstone\" set below).\n-    pending_activations: FxHashMap<mir::Local, BorrowIndex>,\n+    pending_activations: FxIndexMap<mir::Local, BorrowIndex>,\n \n     locals_state_at_exit: LocalsStateAtExit,\n }"}, {"sha": "0762987e22961fe15448c2c005fe6ba4dfd56ef8", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, Place};\n use rustc_middle::ty::RegionVid;\n@@ -124,7 +124,7 @@ pub struct Borrows<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n \n     borrow_set: &'a BorrowSet<'tcx>,\n-    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n+    borrows_out_of_scope_at_location: FxIndexMap<Location, Vec<BorrowIndex>>,\n }\n \n struct StackEntry {\n@@ -138,7 +138,7 @@ struct OutOfScopePrecomputer<'a, 'tcx> {\n     visit_stack: Vec<StackEntry>,\n     body: &'a Body<'tcx>,\n     regioncx: &'a RegionInferenceContext<'tcx>,\n-    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n+    borrows_out_of_scope_at_location: FxIndexMap<Location, Vec<BorrowIndex>>,\n }\n \n impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n             visit_stack: vec![],\n             body,\n             regioncx,\n-            borrows_out_of_scope_at_location: FxHashMap::default(),\n+            borrows_out_of_scope_at_location: FxIndexMap::default(),\n         }\n     }\n }\n@@ -390,6 +390,7 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             | mir::StatementKind::Deinit(..)\n             | mir::StatementKind::StorageLive(..)\n             | mir::StatementKind::Retag { .. }\n+            | mir::StatementKind::PlaceMention(..)\n             | mir::StatementKind::AscribeUserType(..)\n             | mir::StatementKind::Coverage(..)\n             | mir::StatementKind::Intrinsic(..)"}, {"sha": "9e9f0b4b4ad0aa1e7181f5c6dd530c02a0e8d542", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -72,6 +72,8 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n             Some(DefUse::Drop),\n \n+        // This statement exists to help unsafeck. It does not require the place to be live.\n+        PlaceContext::NonUse(NonUseContext::PlaceMention) => None,\n         // Debug info is neither def nor use.\n         PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n "}, {"sha": "f43b611f54eda471bad2f8dac848f5b00fd5ca58", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use rustc_const_eval::util::CallKind;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n@@ -173,7 +173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             let mut is_loop_move = false;\n             let mut in_pattern = false;\n-            let mut seen_spans = FxHashSet::default();\n+            let mut seen_spans = FxIndexSet::default();\n \n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n@@ -2223,8 +2223,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        let mut visited = FxHashSet::default();\n-        let mut move_locations = FxHashSet::default();\n+        let mut visited = FxIndexSet::default();\n+        let mut move_locations = FxIndexSet::default();\n         let mut reinits = vec![];\n         let mut result = vec![];\n \n@@ -2351,7 +2351,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let reinits_reachable = reinits\n             .into_iter()\n             .filter(|reinit| {\n-                let mut visited = FxHashSet::default();\n+                let mut visited = FxIndexSet::default();\n                 let mut stack = vec![*reinit];\n                 while let Some(location) = stack.pop() {\n                     if !visited.insert(location) {"}, {"sha": "fd1fda2ee4bd2deb3236c373e584083bf053aed2", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     nll::ToRegionVid,\n     region_infer::{Cause, RegionInferenceContext},\n };\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n@@ -37,7 +37,7 @@ struct UseFinder<'cx, 'tcx> {\n impl<'cx, 'tcx> UseFinder<'cx, 'tcx> {\n     fn find(&mut self) -> Option<Cause> {\n         let mut queue = VecDeque::new();\n-        let mut visited = FxHashSet::default();\n+        let mut visited = FxIndexSet::default();\n \n         queue.push_back(self.start_point);\n         while let Some(p) = queue.pop_front() {"}, {"sha": "d5ece57437e0b7cde8eaf4f7e4c8dfd57dcc9c68", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,7 +1,7 @@\n //! Contains utilities for generating suggestions for borrowck errors related to unsatisfied\n //! outlives constraints.\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_middle::ty::RegionVid;\n use smallvec::SmallVec;\n@@ -87,7 +87,7 @@ impl OutlivesSuggestionBuilder {\n \n         // Keep track of variables that we have already suggested unifying so that we don't print\n         // out silly duplicate messages.\n-        let mut unified_already = FxHashSet::default();\n+        let mut unified_already = FxIndexSet::default();\n \n         for (fr, outlived) in &self.constraints_to_add {\n             let Some(fr_name) = self.region_vid_to_name(mbcx, *fr) else {"}, {"sha": "a71c416328611be7def787a2ea980adabde31e3b", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -79,6 +79,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             // Only relevant for mir typeck\n             StatementKind::AscribeUserType(..)\n+            // Only relevant for unsafeck\n+            | StatementKind::PlaceMention(..)\n             // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n             // Does not actually affect borrowck\n@@ -118,15 +120,6 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n-            TerminatorKind::DropAndReplace {\n-                place: drop_place,\n-                value: new_value,\n-                target: _,\n-                unwind: _,\n-            } => {\n-                self.mutate_place(location, *drop_place, Deep);\n-                self.consume_operand(location, new_value);\n-            }\n             TerminatorKind::Call {\n                 func,\n                 args,"}, {"sha": "f84a4691d32abec4f146aeb305c8cfc894e9dc11", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,5 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-#![allow(rustc::potential_query_instability)]\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n #![feature(let_chains)]\n@@ -18,7 +17,7 @@ extern crate rustc_middle;\n #[macro_use]\n extern crate tracing;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticMessage, SubdiagnosticMessage};\n@@ -404,7 +403,7 @@ fn do_mir_borrowck<'tcx>(\n     // Note that this set is expected to be small - only upvars from closures\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n-    let temporary_used_locals: FxHashSet<Local> = mbcx\n+    let temporary_used_locals: FxIndexSet<Local> = mbcx\n         .used_mut\n         .iter()\n         .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())\n@@ -491,7 +490,7 @@ pub struct BodyWithBorrowckFacts<'tcx> {\n \n pub struct BorrowckInferCtxt<'cx, 'tcx> {\n     pub(crate) infcx: &'cx InferCtxt<'tcx>,\n-    pub(crate) reg_var_to_origin: RefCell<FxHashMap<ty::RegionVid, RegionCtxt>>,\n+    pub(crate) reg_var_to_origin: RefCell<FxIndexMap<ty::RegionVid, RegionCtxt>>,\n }\n \n impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n@@ -588,25 +587,25 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// borrow errors that is handled by the `reservation_error_reported` field as the inclusion\n     /// of the `Span` type (while required to mute some errors) stops the muting of the reservation\n     /// errors.\n-    access_place_error_reported: FxHashSet<(Place<'tcx>, Span)>,\n+    access_place_error_reported: FxIndexSet<(Place<'tcx>, Span)>,\n     /// This field keeps track of when borrow conflict errors are reported\n     /// for reservations, so that we don't report seemingly duplicate\n     /// errors for corresponding activations.\n     //\n     // FIXME: ideally this would be a set of `BorrowIndex`, not `Place`s,\n     // but it is currently inconvenient to track down the `BorrowIndex`\n     // at the time we detect and report a reservation error.\n-    reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    reservation_error_reported: FxIndexSet<Place<'tcx>>,\n     /// This fields keeps track of the `Span`s that we have\n     /// used to report extra information for `FnSelfUse`, to avoid\n     /// unnecessarily verbose errors.\n-    fn_self_span_reported: FxHashSet<Span>,\n+    fn_self_span_reported: FxIndexSet<Span>,\n     /// This field keeps track of errors reported in the checking of uninitialized variables,\n     /// so that we don't report seemingly duplicate errors.\n-    uninitialized_error_reported: FxHashSet<PlaceRef<'tcx>>,\n+    uninitialized_error_reported: FxIndexSet<PlaceRef<'tcx>>,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n     /// Used for the warning issued by an unused mutable local variable.\n-    used_mut: FxHashSet<Local>,\n+    used_mut: FxIndexSet<Local>,\n     /// If the function we're checking is a closure, then we'll need to report back the list of\n     /// mutable upvars that have been used. This field keeps track of them.\n     used_mut_upvars: SmallVec<[Field; 8]>,\n@@ -628,7 +627,7 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Record the region names generated for each region in the given\n     /// MIR def so that we can reuse them later in help/error messages.\n-    region_names: RefCell<FxHashMap<RegionVid, RegionName>>,\n+    region_names: RefCell<FxIndexMap<RegionVid, RegionName>>,\n \n     /// The counter for generating new region names.\n     next_region_name: RefCell<usize>,\n@@ -691,6 +690,8 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             }\n             // Only relevant for mir typeck\n             StatementKind::AscribeUserType(..)\n+            // Only relevant for unsafeck\n+            | StatementKind::PlaceMention(..)\n             // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n             // These do not actually affect borrowck\n@@ -744,15 +745,6 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            TerminatorKind::DropAndReplace {\n-                place: drop_place,\n-                value: new_value,\n-                target: _,\n-                unwind: _,\n-            } => {\n-                self.mutate_place(loc, (*drop_place, span), Deep, flow_state);\n-                self.consume_operand(loc, (new_value, span), flow_state);\n-            }\n             TerminatorKind::Call {\n                 func,\n                 args,\n@@ -867,7 +859,6 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }\n             | TerminatorKind::FalseUnwind { real_target: _, unwind: _ }\n             | TerminatorKind::Goto { .. }\n@@ -2329,7 +2320,7 @@ mod error {\n         /// same primary span come out in a consistent order.\n         buffered_move_errors:\n             BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'tcx, ErrorGuaranteed>)>,\n-        buffered_mut_errors: FxHashMap<Span, (DiagnosticBuilder<'tcx, ErrorGuaranteed>, usize)>,\n+        buffered_mut_errors: FxIndexMap<Span, (DiagnosticBuilder<'tcx, ErrorGuaranteed>, usize)>,\n         /// Diagnostics to be reported buffer.\n         buffered: Vec<Diagnostic>,\n         /// Set to Some if we emit an error during borrowck"}, {"sha": "b6c5d4245d7b48933b855aea9970310c293e8c88", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,7 +1,7 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::infer::MemberConstraint;\n use rustc_middle::ty::{self, Ty};\n@@ -18,7 +18,7 @@ where\n {\n     /// Stores the first \"member\" constraint for a given `R0`. This is an\n     /// index into the `constraints` vector below.\n-    first_constraints: FxHashMap<R, NllMemberConstraintIndex>,\n+    first_constraints: FxIndexMap<R, NllMemberConstraintIndex>,\n \n     /// Stores the data about each `R0 member of [R1..Rn]` constraint.\n     /// These are organized into a linked list, so each constraint\n@@ -132,7 +132,7 @@ where\n \n         let MemberConstraintSet { first_constraints, mut constraints, choice_regions } = self;\n \n-        let mut first_constraints2 = FxHashMap::default();\n+        let mut first_constraints2 = FxIndexMap::default();\n         first_constraints2.reserve(first_constraints.len());\n \n         for (r1, start1) in first_constraints {"}, {"sha": "96228338a4c22191d378e45b2897f99e402d92b5", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -10,10 +10,9 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid};\n+use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid, TyCtxt};\n use rustc_span::symbol::sym;\n use std::env;\n-use std::fmt::Debug;\n use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -325,7 +324,7 @@ pub(super) fn dump_mir_results<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n-    closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n+    closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     if !dump_enabled(infcx.tcx, \"nll\", body.source.def_id()) {\n         return;\n@@ -340,9 +339,11 @@ pub(super) fn dump_mir_results<'tcx>(\n \n                 if let Some(closure_region_requirements) = closure_region_requirements {\n                     writeln!(out, \"| Free Region Constraints\")?;\n-                    for_each_region_constraint(closure_region_requirements, &mut |msg| {\n-                        writeln!(out, \"| {}\", msg)\n-                    })?;\n+                    for_each_region_constraint(\n+                        infcx.tcx,\n+                        closure_region_requirements,\n+                        &mut |msg| writeln!(out, \"| {}\", msg),\n+                    )?;\n                     writeln!(out, \"|\")?;\n                 }\n             }\n@@ -375,7 +376,7 @@ pub(super) fn dump_annotation<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n-    closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n+    closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n     opaque_type_values: &VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     errors: &mut crate::error::BorrowckErrors<'tcx>,\n ) {\n@@ -405,7 +406,7 @@ pub(super) fn dump_annotation<'tcx>(\n \n         // Dump the region constraints we are imposing *between* those\n         // newly created variables.\n-        for_each_region_constraint(closure_region_requirements, &mut |msg| {\n+        for_each_region_constraint(tcx, closure_region_requirements, &mut |msg| {\n             err.note(msg);\n             Ok(())\n         })\n@@ -426,16 +427,19 @@ pub(super) fn dump_annotation<'tcx>(\n     errors.buffer_non_error_diag(err);\n }\n \n-fn for_each_region_constraint(\n-    closure_region_requirements: &ClosureRegionRequirements<'_>,\n+fn for_each_region_constraint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    closure_region_requirements: &ClosureRegionRequirements<'tcx>,\n     with_msg: &mut dyn FnMut(&str) -> io::Result<()>,\n ) -> io::Result<()> {\n     for req in &closure_region_requirements.outlives_requirements {\n-        let subject: &dyn Debug = match &req.subject {\n-            ClosureOutlivesSubject::Region(subject) => subject,\n-            ClosureOutlivesSubject::Ty(ty) => ty,\n+        let subject = match req.subject {\n+            ClosureOutlivesSubject::Region(subject) => format!(\"{:?}\", subject),\n+            ClosureOutlivesSubject::Ty(ty) => {\n+                format!(\"{:?}\", ty.instantiate(tcx, |vid| tcx.mk_re_var(vid)))\n+            }\n         };\n-        with_msg(&format!(\"where {:?}: {:?}\", subject, req.outlived_free_region,))?;\n+        with_msg(&format!(\"where {}: {:?}\", subject, req.outlived_free_region,))?;\n     }\n     Ok(())\n }"}, {"sha": "905d8c42b28bca007d2886eb46c602924f947d66", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 61, "deletions": 93, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -3,7 +3,7 @@ use std::rc::Rc;\n \n use rustc_data_structures::binary_search_util;\n use rustc_data_structures::frozen::Frozen;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::CRATE_DEF_ID;\n@@ -12,8 +12,9 @@ use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n-    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, ReturnConstraint, TerminatorKind,\n+    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n+    ClosureRegionRequirements, ConstraintCategory, Local, Location, ReturnConstraint,\n+    TerminatorKind,\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n@@ -87,7 +88,7 @@ pub struct RegionInferenceContext<'tcx> {\n     member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n     /// Map universe indexes to information on why we created it.\n-    universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+    universe_causes: FxIndexMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n@@ -262,7 +263,7 @@ fn sccs_info<'cx, 'tcx>(\n     debug!(debug_str);\n \n     let num_components = sccs.scc_data().ranges().len();\n-    let mut components = vec![FxHashSet::default(); num_components];\n+    let mut components = vec![FxIndexSet::default(); num_components];\n \n     for (reg_var_idx, scc_idx) in sccs.scc_indices().iter().enumerate() {\n         let reg_var = ty::RegionVid::from_usize(reg_var_idx);\n@@ -294,9 +295,9 @@ fn sccs_info<'cx, 'tcx>(\n \n             (ConstraintSccIndex::from_usize(scc_idx), repr)\n         })\n-        .collect::<FxHashMap<_, _>>();\n+        .collect::<FxIndexMap<_, _>>();\n \n-    let mut scc_node_to_edges = FxHashMap::default();\n+    let mut scc_node_to_edges = FxIndexMap::default();\n     for (scc_idx, repr) in components_representatives.iter() {\n         let edges_range = sccs.scc_data().ranges()[*scc_idx].clone();\n         let edges = &sccs.scc_data().all_successors()[edges_range];\n@@ -324,7 +325,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n         outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n-        universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+        universe_causes: FxIndexMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n@@ -521,6 +522,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// outlives `'a` and hence contains R0 and R1.\n     fn init_free_and_bound_regions(&mut self) {\n         // Update the names (if any)\n+        // This iterator has unstable order but we collect it all into an IndexVec\n         for (external_name, variable) in self.universal_regions.named_universal_regions() {\n             debug!(\n                 \"init_universal_regions: region {:?} has external name {:?}\",\n@@ -917,7 +919,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Sometimes we register equivalent type-tests that would\n         // result in basically the exact same error being reported to\n         // the user. Avoid that.\n-        let mut deduplicate_errors = FxHashSet::default();\n+        let mut deduplicate_errors = FxIndexSet::default();\n \n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n@@ -1084,18 +1086,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         true\n     }\n \n-    /// When we promote a type test `T: 'r`, we have to convert the\n-    /// type `T` into something we can store in a query result (so\n-    /// something allocated for `'tcx`). This is problematic if `ty`\n-    /// contains regions. During the course of NLL region checking, we\n-    /// will have replaced all of those regions with fresh inference\n-    /// variables. To create a test subject, we want to replace those\n-    /// inference variables with some region from the closure\n-    /// signature -- this is not always possible, so this is a\n-    /// fallible process. Presuming we do find a suitable region, we\n-    /// will use it's *external name*, which will be a `RegionKind`\n-    /// variant that can be used in query responses such as\n-    /// `ReEarlyBound`.\n+    /// When we promote a type test `T: 'r`, we have to replace all region\n+    /// variables in the type `T` with an equal universal region from the\n+    /// closure signature.\n+    /// This is not always possible, so this is a fallible process.\n     #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n@@ -1104,91 +1098,63 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n \n+        // Opaque types' substs may include useless lifetimes.\n+        // We will replace them with ReStatic.\n+        struct OpaqueFolder<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n+        }\n+        impl<'tcx> ty::TypeFolder<TyCtxt<'tcx>> for OpaqueFolder<'tcx> {\n+            fn interner(&self) -> TyCtxt<'tcx> {\n+                self.tcx\n+            }\n+            fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+                use ty::TypeSuperFoldable as _;\n+                let tcx = self.tcx;\n+                let &ty::Alias(ty::Opaque, ty::AliasTy { substs, def_id, .. }) = t.kind() else {\n+                    return t.super_fold_with(self);\n+                };\n+                let substs =\n+                    std::iter::zip(substs, tcx.variances_of(def_id)).map(|(arg, v)| {\n+                        match (arg.unpack(), v) {\n+                            (ty::GenericArgKind::Lifetime(_), ty::Bivariant) => {\n+                                tcx.lifetimes.re_static.into()\n+                            }\n+                            _ => arg.fold_with(self),\n+                        }\n+                    });\n+                tcx.mk_opaque(def_id, tcx.mk_substs_from_iter(substs))\n+            }\n+        }\n+\n+        let ty = ty.fold_with(&mut OpaqueFolder { tcx });\n+\n         let ty = tcx.fold_regions(ty, |r, _depth| {\n-            let region_vid = self.to_region_vid(r);\n+            let r_vid = self.to_region_vid(r);\n+            let r_scc = self.constraint_sccs.scc(r_vid);\n \n             // The challenge if this. We have some region variable `r`\n             // whose value is a set of CFG points and universal\n             // regions. We want to find if that set is *equivalent* to\n             // any of the named regions found in the closure.\n-            //\n-            // To do so, we compute the\n-            // `non_local_universal_upper_bound`. This will be a\n-            // non-local, universal region that is greater than `r`.\n-            // However, it might not be *contained* within `r`, so\n-            // then we further check whether this bound is contained\n-            // in `r`. If so, we can say that `r` is equivalent to the\n-            // bound.\n-            //\n-            // Let's work through a few examples. For these, imagine\n-            // that we have 3 non-local regions (I'll denote them as\n-            // `'static`, `'a`, and `'b`, though of course in the code\n-            // they would be represented with indices) where:\n-            //\n-            // - `'static: 'a`\n-            // - `'static: 'b`\n-            //\n-            // First, let's assume that `r` is some existential\n-            // variable with an inferred value `{'a, 'static}` (plus\n-            // some CFG nodes). In this case, the non-local upper\n-            // bound is `'static`, since that outlives `'a`. `'static`\n-            // is also a member of `r` and hence we consider `r`\n-            // equivalent to `'static` (and replace it with\n-            // `'static`).\n-            //\n-            // Now let's consider the inferred value `{'a, 'b}`. This\n-            // means `r` is effectively `'a | 'b`. I'm not sure if\n-            // this can come about, actually, but assuming it did, we\n-            // would get a non-local upper bound of `'static`. Since\n-            // `'static` is not contained in `r`, we would fail to\n-            // find an equivalent.\n-            let upper_bound = self.non_local_universal_upper_bound(region_vid);\n-            if self.region_contains(region_vid, upper_bound) {\n-                self.definitions[upper_bound].external_name.unwrap_or(r)\n-            } else {\n-                // In the case of a failure, use a `ReVar` result. This will\n-                // cause the `needs_infer` later on to return `None`.\n-                r\n-            }\n+            // To do so, we simply check every candidate `u_r` for equality.\n+            self.scc_values\n+                .universal_regions_outlived_by(r_scc)\n+                .filter(|&u_r| !self.universal_regions.is_local_free_region(u_r))\n+                .find(|&u_r| self.eval_equal(u_r, r_vid))\n+                .map(|u_r| tcx.mk_re_var(u_r))\n+                // In the case of a failure, use `ReErased`. We will eventually\n+                // return `None` in this case.\n+                .unwrap_or(tcx.lifetimes.re_erased)\n         });\n \n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `needs_infer` will only be true if we failed to promote some region.\n-        if ty.needs_infer() {\n+        // This will be true if we failed to promote some region.\n+        if ty.has_erased_regions() {\n             return None;\n         }\n \n-        Some(ClosureOutlivesSubject::Ty(ty))\n-    }\n-\n-    /// Given some universal or existential region `r`, finds a\n-    /// non-local, universal region `r+` that outlives `r` at entry to (and\n-    /// exit from) the closure. In the worst case, this will be\n-    /// `'static`.\n-    ///\n-    /// This is used for two purposes. First, if we are propagated\n-    /// some requirement `T: r`, we can use this method to enlarge `r`\n-    /// to something we can encode for our creator (which only knows\n-    /// about non-local, universal regions). It is also used when\n-    /// encoding `T` as part of `try_promote_type_test_subject` (see\n-    /// that fn for details).\n-    ///\n-    /// This is based on the result `'y` of `universal_upper_bound`,\n-    /// except that it converts further takes the non-local upper\n-    /// bound of `'y`, so that the final result is non-local.\n-    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"non_local_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n-\n-        let lub = self.universal_upper_bound(r);\n-\n-        // Grow further to get smallest universal region known to\n-        // creator.\n-        let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n-\n-        debug!(\"non_local_universal_upper_bound: non_local_lub={:?}\", non_local_lub);\n-\n-        non_local_lub\n+        Some(ClosureOutlivesSubject::Ty(ClosureOutlivesSubjectTy::bind(tcx, ty)))\n     }\n \n     /// Returns a universally quantified region that outlives the\n@@ -1539,6 +1505,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // the outlives suggestions or the debug output from `#[rustc_regions]` would be\n         // duplicated. The polonius subset errors are deduplicated here, while keeping the\n         // CFG-location ordering.\n+        // We can iterate the HashMap here because the result is sorted afterwards.\n+        #[allow(rustc::potential_query_instability)]\n         let mut subset_errors: Vec<_> = polonius_output\n             .subset_errors\n             .iter()"}, {"sha": "ec4b2e9d3e44693443bb34d59e405b941832b157", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n@@ -65,7 +65,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n         let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n \n-        let member_constraints: FxHashMap<_, _> = self\n+        let member_constraints: FxIndexMap<_, _> = self\n             .member_constraints\n             .all_indices()\n             .map(|ci| (self.member_constraints[ci].key, ci))\n@@ -364,7 +364,7 @@ fn check_opaque_type_parameter_valid(\n         OpaqueTyOrigin::TyAlias => {}\n     }\n     let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n-    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    let mut seen_params: FxIndexMap<_, Vec<_>> = FxIndexMap::default();\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n         let arg_is_param = match arg.unpack() {\n             GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),"}, {"sha": "23a59c12865b141ca6e1b4486366059d2f748b11", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -3,7 +3,7 @@\n use crate::constraints::ConstraintSccIndex;\n use crate::RegionInferenceContext;\n use itertools::Itertools;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::graph::WithSuccessors;\n use rustc_middle::ty::RegionVid;\n@@ -14,7 +14,7 @@ pub(crate) struct ReverseSccGraph {\n     graph: VecGraph<ConstraintSccIndex>,\n     /// For each SCC, the range of `universal_regions` that use that SCC as\n     /// their value.\n-    scc_regions: FxHashMap<ConstraintSccIndex, Range<usize>>,\n+    scc_regions: FxIndexMap<ConstraintSccIndex, Range<usize>>,\n     /// All of the universal regions, in grouped so that `scc_regions` can\n     /// index into here.\n     universal_regions: Vec<RegionVid>,\n@@ -26,7 +26,7 @@ impl ReverseSccGraph {\n         &'a self,\n         scc0: ConstraintSccIndex,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n-        let mut duplicates = FxHashSet::default();\n+        let mut duplicates = FxIndexSet::default();\n         self.graph\n             .depth_first_search(scc0)\n             .flat_map(move |scc1| {\n@@ -55,7 +55,7 @@ impl RegionInferenceContext<'_> {\n         paired_scc_regions.sort();\n         let universal_regions = paired_scc_regions.iter().map(|&(_, region)| region).collect();\n \n-        let mut scc_regions = FxHashMap::default();\n+        let mut scc_regions = FxIndexMap::default();\n         let mut start = 0;\n         for (scc, group) in &paired_scc_regions.into_iter().group_by(|(scc, _)| *scc) {\n             let group_size = group.count();"}, {"sha": "a93561350062c630b4ed52587175fbada2ad26bf", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -116,7 +116,9 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n             let subject = match outlives_requirement.subject {\n                 ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n-                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+                ClosureOutlivesSubject::Ty(subject_ty) => {\n+                    subject_ty.instantiate(self.tcx, |vid| closure_mapping[vid]).into()\n+                }\n             };\n \n             self.category = outlives_requirement.category;"}, {"sha": "4004966c40a77bc9d561432427b0b25ab7fe5eed", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -93,31 +93,6 @@ impl UniversalRegionRelations<'_> {\n         res\n     }\n \n-    /// Returns the \"postdominating\" bound of the set of\n-    /// `non_local_upper_bounds` for the given region.\n-    pub(crate) fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n-        let upper_bounds = self.non_local_upper_bounds(fr);\n-\n-        // In case we find more than one, reduce to one for\n-        // convenience. This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = self.inverse_outlives.mutual_immediate_postdominator(upper_bounds);\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom\n-            .and_then(|post_dom| {\n-                // If the mutual immediate postdom is not local, then\n-                // there is no non-local result we can return.\n-                if !self.universal_regions.is_local_free_region(post_dom) {\n-                    Some(post_dom)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(self.universal_regions.fr_static)\n-    }\n-\n     /// Finds a \"lower bound\" for `fr` that is not local. In other\n     /// words, returns the largest (*) known region `fr1` that (a) is\n     /// outlived by `fr` and (b) is not local."}, {"sha": "17e702eb8c5282ba78e8cbde781334bb68aa030d", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -19,7 +19,7 @@ use super::{Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// Check explicit closure signature annotation,\n-    /// e.g., `|x: FxHashMap<_, &'static u32>| ...`.\n+    /// e.g., `|x: FxIndexMap<_, &'static u32>| ...`.\n     #[instrument(skip(self, body), level = \"debug\")]\n     pub(super) fn check_signature_annotation(&mut self, body: &Body<'tcx>) {\n         let mir_def_id = body.source.def_id().expect_local();"}, {"sha": "9731b10aa99d9f931edcff1488a4b1e126bd4085", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_index::bit_set::HybridBitSet;\n use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n@@ -56,7 +56,7 @@ pub(super) fn trace<'mir, 'tcx>(\n         elements,\n         local_use_map,\n         move_data,\n-        drop_data: FxHashMap::default(),\n+        drop_data: FxIndexMap::default(),\n     };\n \n     let mut results = LivenessResults::new(cx);\n@@ -85,7 +85,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     move_data: &'me MoveData<'tcx>,\n \n     /// Cache for the results of `dropck_outlives` query.\n-    drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+    drop_data: FxIndexMap<Ty<'tcx>, DropData<'tcx>>,\n \n     /// Results of dataflow tracking which variables (and paths) have been\n     /// initialized.\n@@ -185,7 +185,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n     fn add_extra_drop_facts(\n         &mut self,\n         drop_used: Vec<(Local, Location)>,\n-        relevant_live_locals: FxHashSet<Local>,\n+        relevant_live_locals: FxIndexSet<Local>,\n     ) {\n         let locations = IntervalSet::new(self.cx.elements.num_points());\n \n@@ -435,8 +435,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         //\n         // What we *actually* generate is a store to a temporary\n         // for the call (`TMP = call()...`) and then a\n-        // `DropAndReplace` to swap that with `X`\n-        // (`DropAndReplace` has very particular semantics).\n+        // `Drop(X)` followed by `X = TMP`  to swap that with `X`.\n     }\n }\n "}, {"sha": "3919c4793a06f35a48793494624b3014861e5df4", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -9,7 +9,7 @@ use either::Either;\n \n use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -145,7 +145,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         outlives_constraints: OutlivesConstraintSet::default(),\n         member_constraints: MemberConstraintSet::default(),\n         type_tests: Vec::default(),\n-        universe_causes: FxHashMap::default(),\n+        universe_causes: FxIndexMap::default(),\n     };\n \n     let CreateResult {\n@@ -772,7 +772,9 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         match context {\n             PlaceContext::MutatingUse(_) => ty::Invariant,\n-            PlaceContext::NonUse(StorageDead | StorageLive | VarDebugInfo) => ty::Invariant,\n+            PlaceContext::NonUse(StorageDead | StorageLive | PlaceMention | VarDebugInfo) => {\n+                ty::Invariant\n+            }\n             PlaceContext::NonMutatingUse(\n                 Inspect | Copy | Move | SharedBorrow | ShallowBorrow | UniqueBorrow | AddressOf\n                 | Projection,\n@@ -875,7 +877,7 @@ struct TypeChecker<'a, 'tcx> {\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n-    reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n+    reported_errors: FxIndexSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n }\n \n@@ -925,7 +927,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n \n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+    pub(crate) universe_causes: FxIndexMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n }\n@@ -1282,6 +1284,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | StatementKind::Retag { .. }\n             | StatementKind::Coverage(..)\n             | StatementKind::ConstEvalCounter\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Nop => {}\n             StatementKind::Deinit(..) | StatementKind::SetDiscriminant { .. } => {\n                 bug!(\"Statement not allowed in this MIR phase\")\n@@ -1312,24 +1315,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { place, value, target: _, unwind: _ } => {\n-                let place_ty = place.ty(body, tcx).ty;\n-                let rv_ty = value.ty(body, tcx);\n-\n-                let locations = term_location.to_locations();\n-                if let Err(terr) =\n-                    self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n-                {\n-                    span_mirbug!(\n-                        self,\n-                        term,\n-                        \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                        place_ty,\n-                        rv_ty,\n-                        terr\n-                    );\n-                }\n-            }\n             TerminatorKind::SwitchInt { discr, .. } => {\n                 self.check_operand(discr, term_location);\n \n@@ -1629,7 +1614,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. }\n-            | TerminatorKind::DropAndReplace { target, unwind, .. }\n             | TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 if let Some(unwind) = unwind {"}, {"sha": "68c86051364ed815f29cb98894156a9df9c7bf38", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -312,6 +312,9 @@ impl<'tcx> UniversalRegions<'tcx> {\n     }\n \n     /// Gets an iterator over all the early-bound regions that have names.\n+    /// Iteration order may be unstable, so this should only be used when\n+    /// iteration order doesn't affect anything\n+    #[allow(rustc::potential_query_instability)]\n     pub fn named_universal_regions<'s>(\n         &'s self,\n     ) -> impl Iterator<Item = (ty::Region<'tcx>, ty::RegionVid)> + 's {"}, {"sha": "c5991e0bc254e302714cdedee048b3f641f508e8", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     Local, Location, Place, Statement, StatementKind, Terminator, TerminatorKind,\n@@ -26,8 +26,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///  See #55344 for context.\n     pub(crate) fn gather_used_muts(\n         &mut self,\n-        temporary_used_locals: FxHashSet<Local>,\n-        mut never_initialized_mut_locals: FxHashSet<Local>,\n+        temporary_used_locals: FxIndexSet<Local>,\n+        mut never_initialized_mut_locals: FxIndexSet<Local>,\n     ) {\n         {\n             let mut visitor = GatherUsedMutsVisitor {\n@@ -48,8 +48,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n /// MIR visitor for collecting used mutable variables.\n /// The 'visit lifetime represents the duration of the MIR walk.\n struct GatherUsedMutsVisitor<'visit, 'cx, 'tcx> {\n-    temporary_used_locals: FxHashSet<Local>,\n-    never_initialized_mut_locals: &'visit mut FxHashSet<Local>,\n+    temporary_used_locals: FxIndexSet<Local>,\n+    never_initialized_mut_locals: &'visit mut FxIndexSet<Local>,\n     mbcx: &'visit mut MirBorrowckCtxt<'cx, 'tcx>,\n }\n \n@@ -71,9 +71,6 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n             TerminatorKind::Call { destination, .. } => {\n                 self.remove_never_initialized_mut_locals(*destination);\n             }\n-            TerminatorKind::DropAndReplace { place, .. } => {\n-                self.remove_never_initialized_mut_locals(*place);\n-            }\n             _ => {}\n         }\n "}, {"sha": "230256ba5aa845f3eda5b5201b4ba7771bc17906", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -499,7 +499,6 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             TerminatorKind::Yield { .. }\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n@@ -820,6 +819,7 @@ fn codegen_stmt<'tcx>(\n         | StatementKind::Nop\n         | StatementKind::FakeRead(..)\n         | StatementKind::Retag { .. }\n+        | StatementKind::PlaceMention(..)\n         | StatementKind::AscribeUserType(..) => {}\n \n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),"}, {"sha": "efdf9f6d5bc02e2b78585202f9e0ebc126457b49", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -529,6 +529,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                         | StatementKind::StorageDead(_)\n                         | StatementKind::Retag(_, _)\n                         | StatementKind::AscribeUserType(_, _)\n+                        | StatementKind::PlaceMention(..)\n                         | StatementKind::Coverage(_)\n                         | StatementKind::ConstEvalCounter\n                         | StatementKind::Nop => {}\n@@ -543,8 +544,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                     | TerminatorKind::Unreachable\n                     | TerminatorKind::Drop { .. }\n                     | TerminatorKind::Assert { .. } => {}\n-                    TerminatorKind::DropAndReplace { .. }\n-                    | TerminatorKind::Yield { .. }\n+                    TerminatorKind::Yield { .. }\n                     | TerminatorKind::GeneratorDrop\n                     | TerminatorKind::FalseEdge { .. }\n                     | TerminatorKind::FalseUnwind { .. } => unreachable!(),"}, {"sha": "24f8d5e464e4c19ebea82c258d383243707ca723", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -281,8 +281,12 @@ fn codegen_float_intrinsic_call<'tcx>(\n         sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64),\n         sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32),\n         sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64),\n+        sym::rintf32 => (\"rintf\", 1, fx.tcx.types.f32),\n+        sym::rintf64 => (\"rint\", 1, fx.tcx.types.f64),\n         sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32),\n         sym::roundf64 => (\"round\", 1, fx.tcx.types.f64),\n+        sym::roundevenf32 => (\"roundevenf\", 1, fx.tcx.types.f32),\n+        sym::roundevenf64 => (\"roundeven\", 1, fx.tcx.types.f64),\n         sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32),\n         sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64),\n         sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32),"}, {"sha": "d2b7724a2215fc82381804e3031e7df191707ebb", "filename": "compiler/rustc_codegen_gcc/.github/workflows/ci.yml", "status": "modified", "additions": 66, "deletions": 45, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -4,36 +4,72 @@ on:\n   - push\n   - pull_request\n \n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n jobs:\n   build:\n-    runs-on: ubuntu-latest\n+    runs-on: ubuntu-22.04\n \n     strategy:\n       fail-fast: false\n       matrix:\n-        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\", \"libgccjit12.so\"]\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master\" }\n+          - { gcc: \"libgccjit_without_int128.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master-without-128bit-integers\" }\n+          - { gcc: \"libgccjit12.so\", extra: \"--no-default-features\", env_extra: \"TEST_FLAGS='-Cpanic=abort -Zpanic-abort-tests'\", artifacts_branch: \"gcc12\" }\n+        commands: [\n+          \"--mini-tests\",\n+          \"--std-tests\",\n+          # FIXME: re-enable asm tests when GCC can emit in the right syntax.\n+          # \"--asm-tests\",\n+          \"--test-libcore\",\n+          \"--extended-rand-tests\",\n+          \"--extended-regex-example-tests\",\n+          \"--extended-regex-tests\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+          \"--test-failing-rustc\",\n+        ]\n \n     steps:\n-    - uses: actions/checkout@v2\n+    - uses: actions/checkout@v3\n \n-    - uses: actions/checkout@v2\n+    - uses: actions/checkout@v3\n       with:\n         repository: llvm/llvm-project\n         path: llvm\n \n     - name: Install packages\n-      run: sudo apt-get install ninja-build ripgrep\n+      # `llvm-14-tools` is needed to install the `FileCheck` binary which is used for asm tests.\n+      run: sudo apt-get install ninja-build ripgrep llvm-14-tools\n+\n+    - name: Install libgccjit12\n+      if: matrix.libgccjit_version.gcc == 'libgccjit12.so'\n+      run: sudo apt-get install libgccjit-12-dev\n \n     - name: Download artifact\n+      if: matrix.libgccjit_version.gcc != 'libgccjit12.so'\n       uses: dawidd6/action-download-artifact@v2\n       with:\n           workflow: main.yml\n-          name: ${{ matrix.libgccjit_version }}\n+          name: ${{ matrix.libgccjit_version.gcc }}\n           path: gcc-build\n           repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n           search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n \n     - name: Setup path to libgccjit\n+      if: matrix.libgccjit_version.gcc == 'libgccjit12.so'\n+      run: echo /usr/lib/gcc/x86_64-linux-gnu/12 > gcc_path\n+\n+    - name: Setup path to libgccjit\n+      if: matrix.libgccjit_version.gcc != 'libgccjit12.so'\n       run: |\n           echo $(readlink -f gcc-build) > gcc_path\n           # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n@@ -48,49 +84,44 @@ jobs:\n     - name: Set RUST_COMPILER_RT_ROOT\n       run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n \n-    # https://github.com/actions/cache/issues/133\n-    - name: Fixup owner of ~/.cargo/\n-      # Don't remove the trailing /. It is necessary to follow the symlink.\n-      run: sudo chown -R $(whoami):$(id -ng) ~/.cargo/\n-\n     - name: Cache cargo installed crates\n-      uses: actions/cache@v1.1.2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: cargo-installed-crates2-ubuntu-latest\n \n     - name: Cache cargo registry\n-      uses: actions/cache@v1\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/registry\n         key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo index\n-      uses: actions/cache@v1\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/git\n         key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v1.1.2\n+      uses: actions/cache@v3\n       with:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n \n-    - name: Build\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        ./prepare_build.sh\n-        ./build.sh\n-        cargo test\n-        ./clean_all.sh\n+    #- name: Cache rust repository\n+      ## We only clone the rust repository for rustc tests\n+      #if: ${{ contains(matrix.commands, 'rustc') }}\n+      #uses: actions/cache@v3\n+      #id: cache-rust-repository\n+      #with:\n+        #path: rust\n+        #key: ${{ runner.os }}-packages-${{ hashFiles('rust/.git/HEAD') }}\n \n     - name: Build\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n       run: |\n         ./prepare_build.sh\n-        ./build.sh --no-default-features\n-        cargo test --no-default-features\n+        ${{ matrix.libgccjit_version.env_extra }} ./build.sh ${{ matrix.libgccjit_version.extra }}\n+        ${{ matrix.libgccjit_version.env_extra }} cargo test ${{ matrix.libgccjit_version.extra }}\n         ./clean_all.sh\n \n     - name: Prepare dependencies\n@@ -106,26 +137,16 @@ jobs:\n         command: build\n         args: --release\n \n-    - name: Test\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n+    - name: Add more failing tests for GCC 12\n+      if: ${{ matrix.libgccjit_version.gcc == 'libgccjit12.so' }}\n+      run: cat failing-ui-tests12.txt >> failing-ui-tests.txt\n \n-        ./test.sh --release\n-\n-    - name: Test\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n+    - name: Run tests\n       run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n+        ${{ matrix.libgccjit_version.env_extra }} ./test.sh --release --clean --build-sysroot ${{ matrix.commands }} ${{ matrix.libgccjit_version.extra }}\n \n-        ./test.sh --release --no-default-features\n+  duplicates:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+      - run: python tools/check_intrinsics_duplicates.py"}, {"sha": "c4e99469bc20b4fcf27dc2da43507a728d445555", "filename": "compiler/rustc_codegen_gcc/.github/workflows/release.yml", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,111 @@\n+name: CI with sysroot compiled in release mode\n+\n+on:\n+  - push\n+  - pull_request\n+\n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", artifacts_branch: \"master\" }\n+        commands: [\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+        ]\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - uses: actions/checkout@v3\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n+    - name: Install packages\n+      run: sudo apt-get install ninja-build ripgrep\n+\n+    - name: Download artifact\n+      uses: dawidd6/action-download-artifact@v2\n+      with:\n+          workflow: main.yml\n+          name: ${{ matrix.libgccjit_version.gcc }}\n+          path: gcc-build\n+          repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n+\n+    - name: Setup path to libgccjit\n+      run: |\n+          echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n+          ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n+\n+    - name: Set env\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/bin\n+        key: cargo-installed-crates2-ubuntu-latest\n+\n+    - name: Cache cargo registry\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/registry\n+        key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo index\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n+\n+    - name: Build\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh --release --release-sysroot\n+        cargo test\n+        ./clean_all.sh\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n+    - name: Compile\n+      uses: actions-rs/cargo@v1.0.3\n+      with:\n+        command: build\n+        args: --release\n+\n+    - name: Run tests\n+      run: |\n+        ./test.sh --release --clean --release-sysroot --build-sysroot ${{ matrix.commands }}"}, {"sha": "42fb35e738ffdbe3bfe14baa80287847a4b6531e", "filename": "compiler/rustc_codegen_gcc/.github/workflows/stdarch.yml", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,116 @@\n+name: stdarch tests with sysroot compiled in release mode\n+\n+on:\n+  - push\n+  - pull_request\n+\n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", artifacts_branch: \"master\" }\n+        commands: [\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+        ]\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - uses: actions/checkout@v3\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n+    - name: Install packages\n+      run: sudo apt-get install ninja-build ripgrep\n+\n+    - name: Download artifact\n+      uses: dawidd6/action-download-artifact@v2\n+      with:\n+          workflow: main.yml\n+          name: ${{ matrix.libgccjit_version.gcc }}\n+          path: gcc-build\n+          repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n+\n+    - name: Setup path to libgccjit\n+      run: |\n+          echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n+          ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n+\n+    - name: Set env\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/bin\n+        key: cargo-installed-crates2-ubuntu-latest\n+\n+    - name: Cache cargo registry\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/registry\n+        key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo index\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n+\n+    - name: Build\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh --release --release-sysroot\n+        cargo test\n+        ./clean_all.sh\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n+    - name: Compile\n+      uses: actions-rs/cargo@v1.0.3\n+      with:\n+        command: build\n+        args: --release\n+\n+    - name: Run tests\n+      run: |\n+        ./test.sh --release --clean --release-sysroot --build-sysroot --mini-tests --std-tests --test-libcore\n+\n+    - name: Run stdarch tests\n+      run: |\n+        cd build_sysroot/sysroot_src/library/stdarch/\n+        CHANNEL=release TARGET=x86_64-unknown-linux-gnu ../../../../cargo.sh test"}, {"sha": "80e574189408828204c725279bb9d37cb3785a0c", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -35,15 +35,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -208,6 +208,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"gccjit\",\n  \"lang_tester\",\n+ \"smallvec\",\n  \"tempfile\",\n ]\n \n@@ -220,6 +221,12 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n+\n [[package]]\n name = \"tempfile\"\n version = \"3.2.0\""}, {"sha": "81066d9ce1f0acd9686f452d201db46eee17bc77", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -27,6 +27,8 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n # Local copy.\n #gccjit = { path = \"../gccjit.rs\" }\n \n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n+\n [dev-dependencies]\n lang_tester = \"0.3.9\"\n tempfile = \"3.1.0\""}, {"sha": "bb741943892549aa118f2605ed9f8f2ebe160008", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 86, "deletions": 6, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,7 @@\n # WIP libgccjit codegen backend for rust\n \n+[![Chat on IRC](https://img.shields.io/badge/irc.libera.chat-%23rustc__codegen__gcc-blue.svg)](https://web.libera.chat/#rustc_codegen_gcc)\n+\n This is a GCC codegen for rustc, which means it can be loaded by the existing rustc frontend, but benefits from GCC: more architectures are supported and GCC's optimizations are used.\n \n **Despite its name, libgccjit can be used for ahead-of-time compilation, as is used here.**\n@@ -16,21 +18,61 @@ The patches in [this repository](https://github.com/antoyo/libgccjit-patches) ne\n (Those patches should work when applied on master, but in case it doesn't work, they are known to work when applied on 079c23cfe079f203d5df83fea8e92a60c7d7e878.)\n You can also use my [fork of gcc](https://github.com/antoyo/gcc) which already includes these patches.**\n \n+To build it (most of these instructions come from [here](https://gcc.gnu.org/onlinedocs/jit/internals/index.html), so don't hesitate to take a look there if you encounter an issue):\n+\n+```bash\n+$ git clone https://github.com/antoyo/gcc\n+$ sudo apt install flex libmpfr-dev libgmp-dev libmpc3 libmpc-dev\n+$ mkdir gcc-build gcc-install\n+$ cd gcc-build\n+$ ../gcc/configure \\\n+    --enable-host-shared \\\n+    --enable-languages=jit \\\n+    --enable-checking=release \\ # it enables extra checks which allow to find bugs\n+    --disable-bootstrap \\\n+    --disable-multilib \\\n+    --prefix=$(pwd)/../gcc-install\n+$ make -j4 # You can replace `4` with another number depending on how many cores you have.\n+```\n+\n+If you want to run libgccjit tests, you will need to also enable the C++ language in the `configure`:\n+\n+```bash\n+--enable-languages=jit,c++\n+```\n+\n+Then to run libgccjit tests:\n+\n+```bash\n+$ cd gcc # from the `gcc-build` folder\n+$ make check-jit\n+# To run one specific test:\n+$ make check-jit RUNTESTFLAGS=\"-v -v -v jit.exp=jit.dg/test-asm.cc\"\n+```\n+\n **Put the path to your custom build of libgccjit in the file `gcc_path`.**\n \n ```bash\n-$ git clone https://github.com/rust-lang/rustc_codegen_gcc.git\n-$ cd rustc_codegen_gcc\n+$ dirname $(readlink -f `find . -name libgccjit.so`) > gcc_path\n+```\n+\n+You also need to set RUST_COMPILER_RT_ROOT:\n+\n+```bash\n $ git clone https://github.com/llvm/llvm-project llvm --depth 1 --single-branch\n $ export RUST_COMPILER_RT_ROOT=\"$PWD/llvm/compiler-rt\"\n-$ ./prepare_build.sh # download and patch sysroot src\n-$ ./build.sh --release\n ```\n \n-To run the tests:\n+Then you can run commands like this:\n \n ```bash\n $ ./prepare.sh # download and patch sysroot src and install hyperfine for benchmarking\n+$ LIBRARY_PATH=$(cat gcc_path) LD_LIBRARY_PATH=$(cat gcc_path) ./build.sh --release\n+```\n+\n+To run the tests:\n+\n+```bash\n $ ./test.sh --release\n ```\n \n@@ -120,13 +162,52 @@ To print a debug representation of a tree:\n debug_tree(expr);\n ```\n \n+(defined in print-tree.h)\n+\n+To print a debug reprensentation of a gimple struct:\n+\n+```c\n+debug_gimple_stmt(gimple_struct)\n+```\n+\n To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n \n+To have the correct file paths in `gdb` instead of `/usr/src/debug/gcc/libstdc++-v3/libsupc++/eh_personality.cc`:\n+\n+Maybe by calling the following at the beginning of gdb:\n+\n+```\n+set substitute-path /usr/src/debug/gcc /path/to/gcc-repo/gcc\n+```\n+\n+TODO(antoyo): but that's not what I remember I was doing.\n+\n ### How to use a custom-build rustc\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n \n+### How to install a forked git-subtree\n+\n+Using git-subtree with `rustc` requires a patched git to make it work.\n+The PR that is needed is [here](https://github.com/gitgitgadget/git/pull/493).\n+Use the following instructions to install it:\n+\n+```\n+git clone git@github.com:tqc/git.git\n+cd git\n+git checkout tqc/subtree\n+make\n+make install\n+cd contrib/subtree\n+make\n+cp git-subtree ~/bin\n+```\n+\n+### How to use [mem-trace](https://github.com/antoyo/mem-trace)\n+\n+`rustc` needs to be built without `jemalloc` so that `mem-trace` can overload `malloc` since `jemalloc` is linked statically, so a `LD_PRELOAD`-ed library won't a chance to intercept the calls to `malloc`.\n+\n ### How to build a cross-compiling libgccjit\n \n #### Building libgccjit\n@@ -142,6 +223,5 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Since rustc doesn't support this architecture yet, set it back to `TARGET_TRIPLE=\"mips-unknown-linux-gnu\"` (or another target having the same attributes). Alternatively, create a [target specification file](https://book.avr-rust.com/005.1-the-target-specification-json-file.html) (note that the `arch` specified in this file must be supported by the rust compiler).\n  * Set `linker='-Clinker=m68k-linux-gcc'`.\n  * Set the path to the cross-compiling libgccjit in `gcc_path`.\n- * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n  * Comment the line: `context.add_command_line_option(\"-masm=intel\");` in src/base.rs.\n  * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "9d692d599f6bef19852222ea918d3d942856f48c", "filename": "compiler/rustc_codegen_gcc/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -16,7 +16,7 @@ rm Cargo.lock test_target/Cargo.lock 2>/dev/null || true\n rm -r sysroot/ 2>/dev/null || true\n \n # Build libs\n-export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked -Cpanic=abort\"\n+export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked\"\n if [[ \"$1\" == \"--release\" ]]; then\n     sysroot_channel='release'\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release"}, {"sha": "166e83901c4f956b1d89762126eaa3291a8a936b", "filename": "compiler/rustc_codegen_gcc/config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fconfig.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot $TEST_FLAGS\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "c80348ca549707570b3da827f1209ce65e673bc8", "filename": "compiler/rustc_codegen_gcc/example/alloc_example.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, core_intrinsics, alloc_error_handler)]\n+#![feature(start, box_syntax, core_intrinsics, alloc_error_handler, lang_items)]\n #![no_std]\n \n extern crate alloc;\n@@ -18,16 +18,22 @@ extern \"C\" {\n \n #[panic_handler]\n fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n }\n \n #[alloc_error_handler]\n fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() -> ! {\n+    loop {}\n+}\n+\n+#[no_mangle]\n+unsafe extern \"C\" fn _Unwind_Resume() {\n+    core::intrinsics::unreachable();\n }\n \n #[start]"}, {"sha": "637b8dc53fefd6045253163f4eedde382035def8", "filename": "compiler/rustc_codegen_gcc/example/mini_core.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n #![feature(\n     no_core, lang_items, intrinsics, unboxed_closures, type_ascription, extern_types,\n-    untagged_unions, decl_macro, rustc_attrs, transparent_unions, auto_traits,\n+    decl_macro, rustc_attrs, transparent_unions, auto_traits,\n     thread_local\n )]\n #![no_core]\n@@ -17,6 +17,9 @@ pub trait Sized {}\n #[lang = \"destruct\"]\n pub trait Destruct {}\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -39,14 +42,14 @@ impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut\n impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n // *mut T -> *mut U\n impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U, ()>> for Box<T, ()> {}\n \n #[lang = \"receiver\"]\n pub trait Receiver {}\n \n impl<T: ?Sized> Receiver for &T {}\n impl<T: ?Sized> Receiver for &mut T {}\n-impl<T: ?Sized> Receiver for Box<T> {}\n+impl<T: ?Sized, A: Allocator> Receiver for Box<T, A> {}\n \n #[lang = \"copy\"]\n pub unsafe trait Copy {}\n@@ -396,7 +399,7 @@ pub struct PhantomData<T: ?Sized>;\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -405,13 +408,21 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_cannot_unwind\"]\n+fn panic_cannot_unwind() -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -450,25 +461,40 @@ pub trait Deref {\n pub trait Allocator {\n }\n \n+impl Allocator for () {}\n+\n pub struct Global;\n \n impl Allocator for Global {}\n \n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[rustc_nonnull_optimization_guaranteed]\n+pub struct NonNull<T: ?Sized>(pub *const T);\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n+\n+pub struct Unique<T: ?Sized> {\n+    pub pointer: NonNull<T>,\n+    pub _marker: PhantomData<T>,\n+}\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+\n #[lang = \"owned_box\"]\n-pub struct Box<\n-    T: ?Sized,\n-    A: Allocator = Global,\n->(*mut T, A);\n+pub struct Box<T: ?Sized, A: Allocator = Global>(Unique<T>, A);\n \n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n \n impl<T: ?Sized, A: Allocator> Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // drop is currently performed by compiler.\n     }\n }\n \n-impl<T> Deref for Box<T> {\n+impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &Self::Target {\n@@ -482,8 +508,8 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: *mut T, alloc: A) {\n-    libc::free(ptr as *mut u8);\n+unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n+    libc::free(ptr.pointer.0 as *mut u8);\n }\n \n #[lang = \"drop\"]\n@@ -505,17 +531,25 @@ pub union MaybeUninit<T> {\n }\n \n pub mod intrinsics {\n+    use crate::Sized;\n+\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n+        #[rustc_safe_intrinsic]\n         pub fn size_of<T>() -> usize;\n-        pub fn size_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn size_of_val<T: ?Sized>(val: *const T) -> usize;\n+        #[rustc_safe_intrinsic]\n         pub fn min_align_of<T>() -> usize;\n-        pub fn min_align_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn min_align_of_val<T: ?Sized>(val: *const T) -> usize;\n         pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n         pub fn transmute<T, U>(e: T) -> U;\n         pub fn ctlz_nonzero<T>(x: T) -> T;\n-        pub fn needs_drop<T: ?::Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n+        pub fn needs_drop<T: ?Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n         pub fn bitreverse<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn bswap<T>(x: T) -> T;\n         pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n         pub fn unreachable() -> !;"}, {"sha": "993a31e68eabc1ce647b1177da81474a29670ace", "filename": "compiler/rustc_codegen_gcc/example/mini_core_hello_world.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -85,6 +85,7 @@ fn start<T: Termination + 'static>(\n     main: fn() -> T,\n     argc: isize,\n     argv: *const *const u8,\n+    _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n         unsafe { puts(*argv); }\n@@ -228,6 +229,7 @@ fn main() {\n     } as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n+    #[allow(unreachable_code)]\n     match FUNC_REF {\n         Some(_) => {},\n         None => assert!(false),"}, {"sha": "95bcad2cd173edc5eb963ef39b816086436759a3", "filename": "compiler/rustc_codegen_gcc/example/mod_bench.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -6,9 +6,7 @@ extern {}\n \n #[panic_handler]\n fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n }\n \n #[lang=\"eh_personality\"]\n@@ -32,6 +30,6 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n #[inline(never)]\n fn black_box(i: u32) {\n     if i != 1 {\n-        unsafe { core::intrinsics::abort(); }\n+        core::intrinsics::abort();\n     }\n }"}, {"sha": "5c171c49fd1940c8be7d44f6194a33e62dcef3b2", "filename": "compiler/rustc_codegen_gcc/example/std_example.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,6 @@\n #![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n \n+#[cfg(feature=\"master\")]\n use std::arch::x86_64::*;\n use std::io::Write;\n use std::ops::Generator;"}, {"sha": "8539e27ea6a58352f5dc0f77b3b598051b37c05e", "filename": "compiler/rustc_codegen_gcc/failing-ui-tests.txt", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,68 @@\n+tests/ui/allocator/custom-in-block.rs\n+tests/ui/allocator/custom-in-submodule.rs\n+tests/ui/allocator/custom.rs\n+tests/ui/allocator/hygiene.rs\n+tests/ui/allocator/no_std-alloc-error-handler-custom.rs\n+tests/ui/allocator/no_std-alloc-error-handler-default.rs\n+tests/ui/allocator/xcrate-use.rs\n+tests/ui/allocator/xcrate-use2.rs\n+tests/ui/asm/may_unwind.rs\n+tests/ui/asm/x86_64/multiple-clobber-abi.rs\n+tests/ui/debuginfo/debuginfo-emit-llvm-ir-and-split-debuginfo.rs\n+tests/ui/functions-closures/parallel-codegen-closures.rs\n+tests/ui/linkage-attr/linkage1.rs\n+tests/ui/lto/dylib-works.rs\n+tests/ui/numbers-arithmetic/saturating-float-casts.rs\n+tests/ui/polymorphization/promoted-function.rs\n+tests/ui/process/nofile-limit.rs\n+tests/ui/sepcomp/sepcomp-cci.rs\n+tests/ui/sepcomp/sepcomp-extern.rs\n+tests/ui/sepcomp/sepcomp-fns-backwards.rs\n+tests/ui/sepcomp/sepcomp-fns.rs\n+tests/ui/sepcomp/sepcomp-statics.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-pass.rs\n+tests/ui/sse2.rs\n+tests/ui/target-feature/missing-plusminus.rs\n+tests/ui/asm/x86_64/may_unwind.rs\n+tests/ui/backtrace.rs\n+tests/ui/catch-unwind-bang.rs\n+tests/ui/cfg/cfg-panic-abort.rs\n+tests/ui/drop/dynamic-drop-async.rs\n+tests/ui/drop/repeat-drop.rs\n+tests/ui/fmt/format-args-capture.rs\n+tests/ui/generator/panic-drops-resume.rs\n+tests/ui/generator/panic-drops.rs\n+tests/ui/intrinsics/panic-uninitialized-zeroed.rs\n+tests/ui/iterators/iter-sum-overflow-debug.rs\n+tests/ui/iterators/iter-sum-overflow-overflow-checks.rs\n+tests/ui/mir/mir_calls_to_shims.rs\n+tests/ui/mir/mir_drop_order.rs\n+tests/ui/mir/mir_let_chains_drop_order.rs\n+tests/ui/oom_unwind.rs\n+tests/ui/panic-runtime/abort-link-to-unwinding-crates.rs\n+tests/ui/panic-runtime/abort.rs\n+tests/ui/panic-runtime/link-to-abort.rs\n+tests/ui/unwind-no-uwtable.rs\n+tests/ui/parser/unclosed-delimiter-in-dep.rs\n+tests/ui/runtime/rt-explody-panic-payloads.rs\n+tests/ui/simd/intrinsic/ptr-cast.rs\n+tests/ui/binding/fn-arg-incomplete-pattern-drop-order.rs\n+tests/ui/consts/missing_span_in_backtrace.rs\n+tests/ui/drop/dynamic-drop.rs\n+tests/ui/dyn-star/box.rs\n+tests/ui/issues/issue-40883.rs\n+tests/ui/issues/issue-43853.rs\n+tests/ui/issues/issue-47364.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/assert-without-captures-does-not-create-unnecessary-code.rs\n+tests/ui/rfc-2091-track-caller/std-panic-locations.rs\n+tests/ui/rfcs/rfc1857-drop-order.rs\n+tests/ui/simd/issue-17170.rs\n+tests/ui/simd/issue-39720.rs\n+tests/ui/simd/issue-89193.rs\n+tests/ui/statics/issue-91050-1.rs\n+tests/ui/statics/issue-91050-2.rs\n+tests/ui/alloc-error/default-alloc-error-hook.rs\n+tests/ui/generator/panic-safe.rs\n+tests/ui/issues/issue-14875.rs\n+tests/ui/issues/issue-29948.rs\n+tests/ui/panic-while-printing.rs"}, {"sha": "8c27bd8b8ca89f133210fa477dca33946f3e11e0", "filename": "compiler/rustc_codegen_gcc/failing-ui-tests12.txt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,39 @@\n+tests/ui/asm/x86_64/issue-96797.rs\n+tests/ui/intrinsics/const-eval-select-x86_64.rs\n+tests/ui/packed/packed-struct-drop-aligned.rs\n+tests/ui/packed/packed-struct-generic-layout.rs\n+tests/ui/packed/packed-struct-layout.rs\n+tests/ui/packed/packed-struct-optimized-enum.rs\n+tests/ui/packed/packed-struct-size.rs\n+tests/ui/packed/packed-struct-vec.rs\n+tests/ui/packed/packed-tuple-struct-layout.rs\n+tests/ui/simd/array-type.rs\n+tests/ui/simd/intrinsic/float-minmax-pass.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs\n+tests/ui/simd/intrinsic/generic-as.rs\n+tests/ui/simd/intrinsic/generic-cast-pass.rs\n+tests/ui/simd/intrinsic/generic-cast-pointer-width.rs\n+tests/ui/simd/intrinsic/generic-comparison-pass.rs\n+tests/ui/simd/intrinsic/generic-elements-pass.rs\n+tests/ui/simd/intrinsic/generic-reduction-pass.rs\n+tests/ui/simd/intrinsic/generic-select-pass.rs\n+tests/ui/simd/intrinsic/inlining-issue67557-ice.rs\n+tests/ui/simd/intrinsic/inlining-issue67557.rs\n+tests/ui/simd/monomorphize-shuffle-index.rs\n+tests/ui/simd/shuffle.rs\n+tests/ui/simd/simd-bitmask.rs\n+tests/ui/generator/resume-after-return.rs\n+tests/ui/iterators/iter-step-overflow-debug.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs\n+tests/ui/numbers-arithmetic/next-power-of-two-overflow-debug.rs\n+tests/ui/privacy/reachable-unnameable-items.rs\n+tests/ui/rfc-1937-termination-trait/termination-trait-in-test.rs\n+tests/ui/async-await/async-fn-size-moved-locals.rs\n+tests/ui/async-await/async-fn-size-uninit-locals.rs\n+tests/ui/cfg/cfg-panic.rs\n+tests/ui/generator/size-moved-locals.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs\n+tests/ui/simd/intrinsic/generic-gather-pass.rs\n+tests/ui/simd/issue-85915-simd-ptrs.rs\n+tests/ui/issues/issue-68010-large-zst-consts.rs\n+tests/ui/rust-2018/proc-macro-crate-in-paths.rs"}, {"sha": "0a94a08f8dca86fec574ab0833925d5f9b0df2e0", "filename": "compiler/rustc_codegen_gcc/locales/en-US.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -60,3 +60,9 @@ codegen_gcc_invalid_monomorphization_unsupported_cast =\n \n codegen_gcc_invalid_monomorphization_unsupported_operation =\n     invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_gcc_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}\n+\n+codegen_gcc_tied_target_features = the target features {$features} must all be either enabled or disabled together\n+    .help = add the missing features in a `target_feature` attribute"}, {"sha": "93c63b5dcacfda4c14539665d4a004baeb2ae3c3", "filename": "compiler/rustc_codegen_gcc/patches/0001-Add-stdarch-Cargo.toml-for-testing.patch", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,39 @@\n+From c3821e02fbd6cb5ad6e06d759fccdc9073712375 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Tue, 7 Jun 2022 21:40:13 -0400\n+Subject: [PATCH] Add stdarch Cargo.toml for testing\n+\n+---\n+ library/stdarch/Cargo.toml | 20 ++++++++++++++++++++\n+ 1 file changed, 20 insertions(+)\n+ create mode 100644 library/stdarch/Cargo.toml\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+new file mode 100644\n+index 0000000..fbe0a95\n+--- /dev/null\n++++ b/library/stdarch/Cargo.toml\n+@@ -0,0 +1,20 @@\n++[workspace]\n++members = [\n++  \"crates/core_arch\",\n++  \"crates/std_detect\",\n++  \"crates/stdarch-gen\",\n++  \"examples/\"\n++]\n++exclude = [\n++  \"crates/wasm-assert-instr-tests\"\n++]\n++\n++[profile.release]\n++debug = true\n++opt-level = 3\n++incremental = true\n++\n++[profile.bench]\n++debug = 1\n++opt-level = 3\n++incremental = true\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "1b71df1ca8df2c4ef5eb86cf408c1574f7277d54", "filename": "compiler/rustc_codegen_gcc/patches/0001-Disable-examples.patch", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,25 @@\n+From a2d53a324a02c04b76c0e9d39dc15cd443a3b8b2 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Fri, 25 Nov 2022 11:18:11 -0500\n+Subject: [PATCH] Disable examples\n+\n+---\n+ library/stdarch/Cargo.toml | 2 +-\n+ 1 file changed, 1 insertion(+), 1 deletion(-)\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+index fbe0a95..748d72d 100644\n+--- a/library/stdarch/Cargo.toml\n++++ b/library/stdarch/Cargo.toml\n+@@ -3,7 +3,7 @@ members = [\n+   \"crates/core_arch\",\n+   \"crates/std_detect\",\n+   \"crates/stdarch-gen\",\n+-  \"examples/\"\n++  #\"examples/\"\n+ ]\n+ exclude = [\n+   \"crates/wasm-assert-instr-tests\"\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "4db56fa3bd2c7667f525f8db752ef5c84d75f290", "filename": "compiler/rustc_codegen_gcc/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -18,7 +18,7 @@ new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n +++ b/library/core/tests/Cargo.toml\n-@@ -0,0 +1,8 @@\n+@@ -0,0 +1,12 @@\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n@@ -27,37 +27,18 @@ index 0000000..46fd999\n +[lib]\n +name = \"coretests\"\n +path = \"lib.rs\"\n-diff --git a/library/core/tests/num/flt2dec/mod.rs b/library/core/tests/num/flt2dec/mod.rs\n-index a35897e..f0bf645 100644\n---- a/library/core/tests/num/flt2dec/mod.rs\n-+++ b/library/core/tests/num/flt2dec/mod.rs\n-@@ -13,7 +13,6 @@ mod strategy {\n-     mod dragon;\n-     mod grisu;\n- }\n--mod random;\n- \n- pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n-     match decode(v).1 {\n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n-index 6609bc3..241b497 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n-@@ -1209,6 +1209,7 @@ fn brute_force_rotate_test_1() {\n-     }\n- }\n- \n-+/*\n- #[test]\n- #[cfg(not(target_arch = \"wasm32\"))]\n- fn sort_unstable() {\n-@@ -1394,6 +1395,7 @@ fn partition_at_index() {\n-     v.select_nth_unstable(0);\n-     assert!(v == [0xDEADBEEF]);\n- }\n-+*/\n- \n- #[test]\n- #[should_panic(expected = \"index 0 greater than length of slice\")]\n++\n++[dependencies]\n++rand = { version = \"0.8.5\", default-features = false }\n++rand_xorshift = { version = \"0.3.0\", default-features = false }\n+diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n+index 42a26ae..5ac1042 100644\n+--- a/library/core/tests/lib.rs\n++++ b/library/core/tests/lib.rs\n+@@ -1,3 +1,4 @@\n++#![cfg(test)]\n+ #![feature(alloc_layout_extra)]\n+ #![feature(array_chunks)]\n+ #![feature(array_methods)]\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "c59a40df03988aeec2b908ad36e9e4413793533b", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,28 +0,0 @@\n-From b1ae000f6da1abd3b8e9b80c40bc11c89b8ae93c Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Thu, 30 Dec 2021 16:54:40 +0100\n-Subject: [PATCH] [core] Disable portable-simd test\n-\n----\n- library/core/tests/lib.rs | 1 -\n- 1 file changed, 1 deletion(-)\n-\n-diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n-index 06c7be0..359e2e7 100644\n---- a/library/core/tests/lib.rs\n-+++ b/library/core/tests/lib.rs\n-@@ -75,7 +75,6 @@\n- #![feature(never_type)]\n- #![feature(unwrap_infallible)]\n--#![feature(portable_simd)]\n- #![feature(ptr_metadata)]\n- #![feature(once_cell)]\n- #![feature(option_result_contains)]\n-@@ -127,7 +126,6 @@ mod pin;\n- mod pin_macro;\n- mod ptr;\n- mod result;\n--mod simd;\n- mod slice;\n- mod str;\n- mod str_lossy;"}, {"sha": "933ecd45baadb63632cbd08ba7431e1a9e6ef077", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-06-06\"\n+channel = \"nightly-2023-03-02\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "59143eac37b3f03a23ec3d7538b2a34feec9823c", "filename": "compiler/rustc_codegen_gcc/rustc_patches/compile_test.patch", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,14 +0,0 @@\n-diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n-index 887d27fd6dca4..2c2239f2b83d1 100644\n---- a/src/tools/compiletest/src/header.rs\n-+++ b/src/tools/compiletest/src/header.rs\n-@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n-     cfg: Option<&str>,\n- ) -> test::TestDesc {\n-     let mut ignore = false;\n-     #[cfg(not(bootstrap))]\n--    let ignore_message: Option<String> = None;\n-+    let ignore_message: Option<&str> = None;\n-     let mut should_fail = false;\n-\n-     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();"}, {"sha": "4bad33ee879ee4f1c27ba1c2e1352f98c483d9e1", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,3 +1,5 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n use gccjit::{FunctionType, GlobalKind, ToRValue};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_middle::bug;\n@@ -50,7 +52,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n \n         if tcx.sess.target.options.default_hidden_visibility {\n-            // TODO(antoyo): set visibility.\n+            #[cfg(feature=\"master\")]\n+            func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n             // TODO(antoyo): emit unwind tables.\n@@ -61,7 +64,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n             .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n             .collect();\n         let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n-        // TODO(antoyo): set visibility.\n+        #[cfg(feature=\"master\")]\n+        callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n         let block = func.new_block(\"entry\");\n \n@@ -90,12 +94,18 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n+    if tcx.sess.target.default_hidden_visibility {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+    }\n+\n     let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();\n     let callee = context.new_function(None, FunctionType::Extern, void, &args, callee, false);\n-    //llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+    #[cfg(feature=\"master\")]\n+    callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n     let block = func.new_block(\"entry\");\n "}, {"sha": "41e9d61a10e50b53dd5b280cc7c1a1e236d163a8", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 125, "deletions": 86, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -157,7 +157,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     use ConstraintOrRegister::*;\n \n                     let (constraint, ty) = match (reg_to_gcc(reg), place) {\n-                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n                         // needs to be of a type that's \"compatible\" with the register class, but specific type\n@@ -226,7 +226,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // This decision is also backed by the fact that LLVM needs in and out\n                     // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n-                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let ty = in_value.layout.gcc_type(self.cx);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n@@ -286,7 +286,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             continue\n                         };\n \n-                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let ty = out_place.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -306,7 +306,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `in(\"explicit register\") var`\n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let ty = value.layout.gcc_type(self.cx);\n                         let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n@@ -325,7 +325,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         // See explanation in the first pass.\n-                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let ty = in_value.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -353,8 +353,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     inputs.push(AsmInOperand {\n                         constraint: \"X\".into(),\n                         rust_idx,\n-                        val: self.cx.rvalue_as_function(get_fn(self.cx, instance))\n-                            .get_address(None),\n+                        val: get_fn(self.cx, instance).get_address(None),\n                     });\n                 }\n \n@@ -382,15 +381,19 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    // TODO(@Commeownist): switch to `Iterator::intersperse` once it's stable\n-                    let mut iter = string.split('%');\n-                    if let Some(s) = iter.next() {\n-                        template_str.push_str(s);\n-                    }\n-\n-                    for s in iter {\n-                        template_str.push_str(\"%%\");\n-                        template_str.push_str(s);\n+                    for char in string.chars() {\n+                        // TODO(antoyo): might also need to escape | if rustc doesn't do it.\n+                        let escaped_char =\n+                            match char {\n+                                '%' => \"%%\",\n+                                '{' => \"%{\",\n+                                '}' => \"%}\",\n+                                _ => {\n+                                    template_str.push(char);\n+                                    continue;\n+                                },\n+                            };\n+                        template_str.push_str(escaped_char);\n                     }\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n@@ -565,56 +568,71 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n                 _ => unimplemented!(),\n             }\n         },\n+        // They can be retrieved from https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html\n         InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => \"w\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => \"x\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => {\n+                unreachable!(\"clobber-only\")\n+            }\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => unimplemented!(),\n-            InlineAsmRegClass::Avr(_) => unimplemented!(),\n-            InlineAsmRegClass::Bpf(_) => unimplemented!(),\n-            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => unimplemented!(),\n-            InlineAsmRegClass::Msp430(_) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => unimplemented!(),\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"t\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_upper) => \"d\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw) => \"w\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => \"e\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n+            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => \"d\", // more specific than \"r\"\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n+            // https://github.com/gcc-mirror/gcc/blob/master/gcc/config/nvptx/nvptx.md -> look for\n+            // \"define_constraint\".\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n+\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => \"b\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n             | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n                 unreachable!(\"clobber-only\")\n             },\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => {\n+                unreachable!(\"clobber-only\")\n+            }\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"Yk\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => unimplemented!(),\n-            InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n-                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg,\n+                X86InlineAsmRegClass::kreg0\n+                | X86InlineAsmRegClass::x87_reg\n+                | X86InlineAsmRegClass::mmx_reg\n+                | X86InlineAsmRegClass::tmm_reg,\n             ) => unreachable!(\"clobber-only\"),\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"GCC backend does not support SPIR-V\")\n             }\n-            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => \"r\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Err => unreachable!(),\n         }\n     };\n@@ -692,21 +710,23 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             && options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n         // Build the template string\n-        let mut template_str = String::new();\n+        let mut template_str = \".pushsection .text\\n\".to_owned();\n+        if att_dialect {\n+            template_str.push_str(\".att_syntax\\n\");\n+        }\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    for line in string.lines() {\n+                    let mut index = 0;\n+                    while index < string.len() {\n                         // NOTE: gcc does not allow inline comment, so remove them.\n-                        let line =\n-                            if let Some(index) = line.rfind(\"//\") {\n-                                &line[..index]\n-                            }\n-                            else {\n-                                line\n-                            };\n-                        template_str.push_str(line);\n-                        template_str.push('\\n');\n+                        let comment_index = string[index..].find(\"//\")\n+                            .map(|comment_index| comment_index + index)\n+                            .unwrap_or(string.len());\n+                        template_str.push_str(&string[index..comment_index]);\n+                        index = string[comment_index..].find('\\n')\n+                            .map(|index| index + comment_index)\n+                            .unwrap_or(string.len());\n                     }\n                 },\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier: _, span: _ } => {\n@@ -719,6 +739,8 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymFn { instance } => {\n+                            let function = get_fn(self, instance);\n+                            self.add_used_function(function);\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O)\n                             // or byte count suffixes (x86 Windows).\n@@ -727,6 +749,7 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(antoyo): set the global variable as used.\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O).\n                             let instance = Instance::mono(self.tcx, def_id);\n@@ -738,48 +761,51 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             }\n         }\n \n-        let template_str =\n-            if att_dialect {\n-                format!(\".att_syntax\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n-            }\n-            else {\n-                template_str\n-            };\n+        if att_dialect {\n+            template_str.push_str(\"\\n\\t.intel_syntax noprefix\");\n+        }\n         // NOTE: seems like gcc will put the asm in the wrong section, so set it to .text manually.\n-        let template_str = format!(\".pushsection .text\\n{}\\n.popsection\", template_str);\n+        template_str.push_str(\"\\n.popsection\");\n         self.context.add_top_level_asm(None, &template_str);\n     }\n }\n \n fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option<char>) -> Option<char> {\n+    // The modifiers can be retrieved from\n+    // https://gcc.gnu.org/onlinedocs/gcc/Modifiers.html#Modifiers\n     match reg {\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n-        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => modifier,\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n         | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n-            unimplemented!()\n+            if modifier == Some('v') { None } else { modifier }\n+        }\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => {\n+            unreachable!(\"clobber-only\")\n         }\n-        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)  => unimplemented!(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => None,\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n-        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => unimplemented!(),\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => None,\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n-        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => unimplemented!(),\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => Some('P'),\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n-            unimplemented!()\n+            if modifier.is_none() {\n+                Some('q')\n+            } else {\n+                modifier\n+            }\n         }\n-        InlineAsmRegClass::Avr(_) => unimplemented!(),\n-        InlineAsmRegClass::Bpf(_) => unimplemented!(),\n-        InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n-        InlineAsmRegClass::Mips(_) => unimplemented!(),\n-        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n-        InlineAsmRegClass::Nvptx(_) => unimplemented!(),\n-        InlineAsmRegClass::PowerPC(_) => unimplemented!(),\n+        InlineAsmRegClass::Hexagon(_) => None,\n+        InlineAsmRegClass::Mips(_) => None,\n+        InlineAsmRegClass::Nvptx(_) => None,\n+        InlineAsmRegClass::PowerPC(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n-        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n-        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => {\n+            unreachable!(\"clobber-only\")\n+        }\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n             None => if arch == InlineAsmArch::X86_64 { Some('q') } else { Some('k') },\n@@ -803,16 +829,29 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg) => {\n+        InlineAsmRegClass::X86(\n+            X86InlineAsmRegClass::x87_reg\n+            | X86InlineAsmRegClass::mmx_reg\n+            | X86InlineAsmRegClass::kreg0\n+            | X86InlineAsmRegClass::tmm_reg,\n+        ) => {\n             unreachable!(\"clobber-only\")\n         }\n-        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n+        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => None,\n+        InlineAsmRegClass::Bpf(_) => None,\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => match modifier {\n+            Some('h') => Some('B'),\n+            Some('l') => Some('A'),\n+            _ => None,\n+        },\n+        InlineAsmRegClass::Avr(_) => None,\n+        InlineAsmRegClass::S390x(_) => None,\n+        InlineAsmRegClass::Msp430(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n-        },\n-        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n-        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+        }\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }"}, {"sha": "db841b1b52408ab51d986b042f77ff74046df018", "filename": "compiler/rustc_codegen_gcc/src/attributes.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,113 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n+use gccjit::Function;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_codegen_ssa::target_features::tied_target_features;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty;\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{context::CodegenCx, errors::TiedTargetFeatures};\n+\n+// Given a map from target_features to whether they are enabled or disabled,\n+// ensure only valid combinations are allowed.\n+pub fn check_tied_features(sess: &Session, features: &FxHashMap<&str, bool>) -> Option<&'static [&'static str]> {\n+    for tied in tied_target_features(sess) {\n+        // Tied features must be set to the same value, or not set at all\n+        let mut tied_iter = tied.iter();\n+        let enabled = features.get(tied_iter.next().unwrap());\n+        if tied_iter.any(|feature| enabled != features.get(feature)) {\n+            return Some(tied);\n+        }\n+    }\n+    None\n+}\n+\n+// TODO(antoyo): maybe move to a new module gcc_util.\n+// To find a list of GCC's names, check https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\n+fn to_gcc_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n+    match (arch, s) {\n+        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n+        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n+        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n+        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n+        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n+        (\"x86\", \"avx512vaes\") => smallvec![\"vaes\"],\n+        (\"x86\", \"avx512gfni\") => smallvec![\"gfni\"],\n+        (\"x86\", \"avx512vpclmulqdq\") => smallvec![\"vpclmulqdq\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512vbmi2'.\n+        (\"x86\", \"avx512vbmi2\") => smallvec![\"avx512vbmi2\", \"avx512bw\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512bitalg'.\n+        (\"x86\", \"avx512bitalg\") => smallvec![\"avx512bitalg\", \"avx512bw\"],\n+        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n+        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n+        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n+        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n+        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n+        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n+        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n+        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n+        // Rust ties fp and neon together. In LLVM neon implicitly enables fp,\n+        // but we manually enable neon when a feature only implicitly enables fp\n+        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n+        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n+        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n+        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n+        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n+        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n+        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n+        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n+        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n+        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n+        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n+        (_, s) => smallvec![s],\n+    }\n+}\n+\n+/// Composite function which sets GCC attributes for function depending on its AST (`#[attribute]`)\n+/// attributes.\n+pub fn from_fn_attrs<'gcc, 'tcx>(\n+    cx: &CodegenCx<'gcc, 'tcx>,\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    func: Function<'gcc>,\n+    instance: ty::Instance<'tcx>,\n+) {\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n+\n+    let function_features =\n+        codegen_fn_attrs.target_features.iter().map(|features| features.as_str()).collect::<Vec<&str>>();\n+\n+    if let Some(features) = check_tied_features(cx.tcx.sess, &function_features.iter().map(|features| (*features, true)).collect()) {\n+        let span = cx.tcx\n+            .get_attr(instance.def_id(), sym::target_feature)\n+            .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n+        cx.tcx.sess.create_err(TiedTargetFeatures {\n+            features: features.join(\", \"),\n+            span,\n+        })\n+            .emit();\n+        return;\n+    }\n+\n+    let mut function_features = function_features\n+        .iter()\n+        .flat_map(|feat| to_gcc_features(cx.tcx.sess, feat).into_iter())\n+        .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n+            InstructionSetAttr::ArmA32 => \"-thumb-mode\", // TODO(antoyo): support removing feature.\n+            InstructionSetAttr::ArmT32 => \"thumb-mode\",\n+        }))\n+        .collect::<Vec<_>>();\n+\n+    // TODO(antoyo): check if we really need global backend features. (Maybe they could be applied\n+    // globally?)\n+    let mut global_features = cx.tcx.global_backend_features(()).iter().map(|s| s.as_str());\n+    function_features.extend(&mut global_features);\n+    let target_features = function_features.join(\",\");\n+    if !target_features.is_empty() {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Target(&target_features));\n+    }\n+}"}, {"sha": "5f54ac4ebc69a63c5e372f3b23f73e0587f04901", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -57,6 +57,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 if env::var(\"CG_GCCJIT_DUMP_TO_FILE\").as_deref() == Ok(\"1\") {\n                     let _ = fs::create_dir(\"/tmp/gccjit_dumps\");\n                     let path = &format!(\"/tmp/gccjit_dumps/{}.c\", module.name);\n+                    context.set_debug_info(true);\n                     context.dump_to_file(path, true);\n                 }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));"}, {"sha": "dcd560b3dcd952efe7d81228ac4403d1f8b748ab", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -8,6 +8,8 @@ use gccjit::{\n };\n use rustc_middle::dep_graph;\n use rustc_middle::ty::TyCtxt;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::mir::mono::Visibility;\n use rustc_middle::mir::mono::Linkage;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n@@ -20,6 +22,15 @@ use crate::GccContext;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n+#[cfg(feature=\"master\")]\n+pub fn visibility_to_gcc(linkage: Visibility) -> gccjit::Visibility {\n+    match linkage {\n+        Visibility::Default => gccjit::Visibility::Default,\n+        Visibility::Hidden => gccjit::Visibility::Hidden,\n+        Visibility::Protected => gccjit::Visibility::Protected,\n+    }\n+}\n+\n pub fn global_linkage_to_gcc(linkage: Linkage) -> GlobalKind {\n     match linkage {\n         Linkage::External => GlobalKind::Imported,\n@@ -76,16 +87,34 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n         // Instantiate monomorphizations without filling out definitions yet...\n         //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n         let context = Context::default();\n+\n+        context.add_command_line_option(\"-fexceptions\");\n+        context.add_driver_option(\"-fexceptions\");\n+\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n         context.add_command_line_option(\"-msse2\");\n         context.add_command_line_option(\"-mavx2\");\n-        context.add_command_line_option(\"-msha\");\n-        context.add_command_line_option(\"-mpclmul\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        //context.add_command_line_option(\"-mavx512f\");\n+        context.add_command_line_option(\"-msha\");\n+        context.add_command_line_option(\"-mpclmul\");\n+        context.add_command_line_option(\"-mfma\");\n+        context.add_command_line_option(\"-mfma4\");\n+        context.add_command_line_option(\"-m64\");\n+        context.add_command_line_option(\"-mbmi\");\n+        context.add_command_line_option(\"-mgfni\");\n+        //context.add_command_line_option(\"-mavxvnni\"); // The CI doesn't support this option.\n+        context.add_command_line_option(\"-mf16c\");\n+        context.add_command_line_option(\"-maes\");\n+        context.add_command_line_option(\"-mxsavec\");\n+        context.add_command_line_option(\"-mbmi2\");\n+        context.add_command_line_option(\"-mrtm\");\n+        context.add_command_line_option(\"-mvaes\");\n+        context.add_command_line_option(\"-mvpclmulqdq\");\n+        context.add_command_line_option(\"-mavx\");\n+\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }\n@@ -95,12 +124,20 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n         context.add_command_line_option(\"-fno-semantic-interposition\");\n         // NOTE: Rust relies on LLVM not doing TBAA (https://github.com/rust-lang/unsafe-code-guidelines/issues/292).\n         context.add_command_line_option(\"-fno-strict-aliasing\");\n+        // NOTE: Rust relies on LLVM doing wrapping on overflow.\n+        context.add_command_line_option(\"-fwrapv\");\n \n         if tcx.sess.opts.unstable_opts.function_sections.unwrap_or(tcx.sess.target.function_sections) {\n             context.add_command_line_option(\"-ffunction-sections\");\n             context.add_command_line_option(\"-fdata-sections\");\n         }\n \n+        if env::var(\"CG_GCCJIT_DUMP_RTL\").as_deref() == Ok(\"1\") {\n+            context.add_command_line_option(\"-fdump-rtl-vregs\");\n+        }\n+        if env::var(\"CG_GCCJIT_DUMP_TREE_ALL\").as_deref() == Ok(\"1\") {\n+            context.add_command_line_option(\"-fdump-tree-all\");\n+        }\n         if env::var(\"CG_GCCJIT_DUMP_CODE\").as_deref() == Ok(\"1\") {\n             context.set_dump_code_on_compile(true);\n         }\n@@ -115,7 +152,7 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n             context.set_keep_intermediates(true);\n         }\n \n-        // TODO(bjorn3): Remove once unwinding is properly implemented\n+        // NOTE: The codegen generates unrechable blocks.\n         context.set_allow_unreachable_blocks(true);\n \n         {"}, {"sha": "a3c8142bea2db08c0f669a9112e1878bc723d81b", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 332, "deletions": 81, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && (actual_ty.is_integral() && expected_ty.is_integral()) || (actual_ty.get_pointee().is_some() && expected_ty.get_pointee().is_some()) {\n                         self.context.new_cast(None, actual_val, expected_ty)\n                     }\n                     else if on_stack_param_indices.contains(&index) {\n@@ -226,6 +226,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                     else {\n                         assert!(!((actual_ty.is_vector() && !expected_ty.is_vector()) || (!actual_ty.is_vector() && expected_ty.is_vector())), \"{:?} ({}) -> {:?} ({}), index: {:?}[{}]\", actual_ty, actual_ty.is_vector(), expected_ty, expected_ty.is_vector(), func_ptr, index);\n                         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+                        // TODO: remove bitcast now that vector types can be compared?\n                         self.bitcast(actual_val, expected_ty)\n                     }\n                 }\n@@ -279,21 +280,30 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let args = self.check_ptr_call(\"call\", func_ptr, args);\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n+        let func_name = format!(\"{:?}\", func_ptr);\n+        let previous_arg_count = args.len();\n+        let orig_args = args;\n+        let args = {\n+            let function_address_names = self.function_address_names.borrow();\n+            let original_function_name = function_address_names.get(&func_ptr);\n+            llvm::adjust_intrinsic_arguments(&self, gcc_func, args.into(), &func_name, original_function_name)\n+        };\n+        let args_adjusted = args.len() != previous_arg_count;\n+        let args = self.check_ptr_call(\"call\", func_ptr, &*args);\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let return_type = gcc_func.get_return_type();\n         let void_type = self.context.new_type::<()>();\n         let current_func = self.block.get_function();\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            let func_name = format!(\"{:?}\", func_ptr);\n-            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n-            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            let return_value = self.cx.context.new_call_through_ptr(None, func_ptr, &args);\n+            let return_value = llvm::adjust_intrinsic_return_value(&self, return_value, &func_name, &args, args_adjusted, orig_args);\n+            let result = current_func.new_local(None, return_value.get_type(), &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            self.block.add_assignment(None, result, return_value);\n             result.to_rvalue()\n         }\n         else {\n@@ -366,10 +376,10 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'gcc, 'tcx> Deref for Builder<'_, 'gcc, 'tcx> {\n+impl<'a, 'gcc, 'tcx> Deref for Builder<'a, 'gcc, 'tcx> {\n     type Target = CodegenCx<'gcc, 'tcx>;\n \n-    fn deref(&self) -> &Self::Target {\n+    fn deref<'b>(&'b self) -> &'a Self::Target {\n         self.cx\n     }\n }\n@@ -387,7 +397,7 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n+    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Builder<'a, 'gcc, 'tcx> {\n         Builder::with_cx(cx, block)\n     }\n \n@@ -444,17 +454,36 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(\n-        &mut self,\n-        typ: Type<'gcc>,\n-        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n-        func: RValue<'gcc>,\n-        args: &[RValue<'gcc>],\n-        then: Block<'gcc>,\n-        catch: Block<'gcc>,\n-        _funclet: Option<&Funclet>,\n-    ) -> RValue<'gcc> {\n-        // TODO(bjorn3): Properly implement unwinding.\n+    #[cfg(feature=\"master\")]\n+    fn invoke(&mut self, typ: Type<'gcc>, _fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let try_block = self.current_func().new_block(\"try\");\n+\n+        let current_block = self.block.clone();\n+        self.block = try_block;\n+        let call = self.call(typ, None, func, args, None); // TODO(antoyo): use funclet here?\n+        self.block = current_block;\n+\n+        let return_value = self.current_func()\n+            .new_local(None, call.get_type(), \"invokeResult\");\n+\n+        try_block.add_assignment(None, return_value, call);\n+\n+        try_block.end_with_jump(None, then);\n+\n+        if self.cleanup_blocks.borrow().contains(&catch) {\n+            self.block.add_try_finally(None, try_block, catch);\n+        }\n+        else {\n+            self.block.add_try_catch(None, try_block, catch);\n+        }\n+\n+        self.block.end_with_jump(None, then);\n+\n+        return_value.to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n@@ -542,6 +571,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): add check in libgccjit since using the binary operator % causes the following error:\n+        // during RTL pass: expand\n+        // libgccjit.so: error: in expmed_mode_index, at expmed.h:240\n+        // 0x7f0101d58dc6 expmed_mode_index\n+        //     ../../../gcc/gcc/expmed.h:240\n+        // 0x7f0101d58e35 expmed_op_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:262\n+        // 0x7f0101d594a1 sdiv_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:531\n+        // 0x7f0101d594f3 sdiv_cost\n+        //     ../../../gcc/gcc/expmed.h:549\n+        // 0x7f0101d6af7e expand_divmod(int, tree_code, machine_mode, rtx_def*, rtx_def*, rtx_def*, int, optab_methods)\n+        //     ../../../gcc/gcc/expmed.cc:4356\n+        // 0x7f0101d94f9e expand_expr_divmod\n+        //     ../../../gcc/gcc/expr.cc:8929\n+        // 0x7f0101d97a26 expand_expr_real_2(separate_ops*, rtx_def*, machine_mode, expand_modifier)\n+        //     ../../../gcc/gcc/expr.cc:9566\n+        // 0x7f0101bef6ef expand_gimple_stmt_1\n+        //     ../../../gcc/gcc/cfgexpand.cc:3967\n+        // 0x7f0101bef910 expand_gimple_stmt\n+        //     ../../../gcc/gcc/cfgexpand.cc:4028\n+        // 0x7f0101bf6ee7 expand_gimple_basic_block\n+        //     ../../../gcc/gcc/cfgexpand.cc:6069\n+        // 0x7f0101bf9194 execute\n+        //     ../../../gcc/gcc/cfgexpand.cc:6795\n         if a.get_type().is_compatible_with(self.cx.float_type) {\n             let fmodf = self.context.get_builtin_function(\"fmodf\");\n             // FIXME(antoyo): this seems to produce the wrong result.\n@@ -616,24 +670,29 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         a * b\n     }\n \n-    fn fadd_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fadd_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs + rhs\n     }\n \n-    fn fsub_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fsub_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs - rhs\n     }\n \n-    fn fmul_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fmul_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs * rhs\n     }\n \n-    fn fdiv_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fdiv_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs / rhs\n     }\n \n-    fn frem_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn frem_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        self.frem(lhs, rhs)\n     }\n \n     fn checked_binop(&mut self, oop: OverflowOp, typ: Ty<'_>, lhs: Self::Value, rhs: Self::Value) -> (Self::Value, Self::Value) {\n@@ -722,7 +781,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if place.layout.is_gcc_immediate() {\n                 let load = self.load(\n-                    place.layout.gcc_type(self, false),\n+                    place.layout.gcc_type(self),\n                     place.llval,\n                     place.align,\n                 );\n@@ -733,7 +792,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n                 let b_offset = a.size(self).align_to(b.align(self).abi);\n-                let pair_type = place.layout.gcc_type(self, false);\n+                let pair_type = place.layout.gcc_type(self);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n                     let llptr = self.struct_gep(pair_type, place.llval, i as u64);\n@@ -833,26 +892,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n-        let mut result = ptr;\n+        let ptr_type = ptr.get_type();\n+        let mut pointee_type = ptr.get_type();\n+        // NOTE: we cannot use array indexing here like in inbounds_gep because array indexing is\n+        // always considered in bounds in GCC (TODO(antoyo): to be verified).\n+        // So, we have to cast to a number.\n+        let mut result = self.context.new_bitcast(None, ptr, self.sizet_type);\n+        // FIXME(antoyo): if there were more than 1 index, this code is probably wrong and would\n+        // require dereferencing the pointer.\n         for index in indices {\n-            result = self.context.new_array_access(None, result, *index).get_address(None).to_rvalue();\n+            pointee_type = pointee_type.get_pointee().expect(\"pointee type\");\n+            let pointee_size = self.context.new_rvalue_from_int(index.get_type(), pointee_type.get_size() as i32);\n+            result = result + self.gcc_int_cast(*index * pointee_size, self.sizet_type);\n         }\n-        result\n+        self.context.new_bitcast(None, result, ptr_type)\n     }\n \n     fn inbounds_gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n-        // FIXME(antoyo): would be safer if doing the same thing (loop) as gep.\n-        // TODO(antoyo): specify inbounds somehow.\n-        match indices.len() {\n-            1 => {\n-                self.context.new_array_access(None, ptr, indices[0]).get_address(None)\n-            },\n-            2 => {\n-                let array = ptr.dereference(None); // TODO(antoyo): assert that first index is 0?\n-                self.context.new_array_access(None, array, indices[1]).get_address(None)\n-            },\n-            _ => unimplemented!(),\n+        // NOTE: array indexing is always considered in bounds in GCC (TODO(antoyo): to be verified).\n+        let mut indices = indices.into_iter();\n+        let index = indices.next().expect(\"first index in inbounds_gep\");\n+        let mut result = self.context.new_array_access(None, ptr, *index);\n+        for index in indices {\n+            result = self.context.new_array_access(None, result, *index);\n         }\n+        result.get_address(None)\n     }\n \n     fn struct_gep(&mut self, value_type: Type<'gcc>, ptr: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n@@ -1034,8 +1098,19 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n-    fn extract_element(&mut self, _vec: RValue<'gcc>, _idx: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    #[cfg(feature=\"master\")]\n+    fn extract_element(&mut self, vec: RValue<'gcc>, idx: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_vector_access(None, vec, idx).to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    fn extract_element(&mut self, vec: RValue<'gcc>, idx: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = vec.get_type().unqualified().dyncast_vector().expect(\"Called extract_element on a non-vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let vec_num_units = vector_type.get_num_units();\n+        let array_type = self.context.new_array_type(None, element_type, vec_num_units as u64);\n+        let array = self.context.new_bitcast(None, vec, array_type).to_rvalue();\n+        self.context.new_array_access(None, array, idx).to_rvalue()\n     }\n \n     fn vector_splat(&mut self, _num_elts: usize, _elt: RValue<'gcc>) -> RValue<'gcc> {\n@@ -1116,22 +1191,52 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n-        // TODO(antoyo)\n+        #[cfg(feature=\"master\")]\n+        {\n+            let personality = self.rvalue_as_function(_personality);\n+            self.current_func().set_personality_function(personality);\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn cleanup_landing_pad(&mut self, pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n+        self.set_personality_fn(pers_fn);\n+\n+        // NOTE: insert the current block in a variable so that a later call to invoke knows to\n+        // generate a try/finally instead of a try/catch for this block.\n+        self.cleanup_blocks.borrow_mut().insert(self.block);\n+\n+        let eh_pointer_builtin = self.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = self.cx.context.new_rvalue_zero(self.int_type);\n+        let ptr = self.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+\n+        let value1_type = self.u8_type.make_pointer();\n+        let ptr = self.cx.context.new_cast(None, ptr, value1_type);\n+        let value1 = ptr;\n+        let value2 = zero; // TODO(antoyo): set the proper value here (the type of exception?).\n+\n+        (value1, value2)\n     }\n \n+    #[cfg(not(feature=\"master\"))]\n     fn cleanup_landing_pad(&mut self, _pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n-        (\n-            self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n-                .to_rvalue(),\n-            self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue(),\n-        )\n-        // TODO(antoyo): Properly implement unwinding.\n-        // the above is just to make the compilation work as it seems\n-        // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n+        let value1 = self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n+                .to_rvalue();\n+        let value2 = self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue();\n+        (value1, value2)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn resume(&mut self, exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n+        let exn_type = exn0.get_type();\n+        let exn = self.context.new_cast(None, exn0, exn_type);\n+        let unwind_resume = self.context.get_target_builtin_function(\"__builtin_unwind_resume\");\n+        self.llbb().add_eval(None, self.context.new_call(None, unwind_resume, &[exn]));\n+        self.unreachable();\n     }\n \n+    #[cfg(not(feature=\"master\"))]\n     fn resume(&mut self, _exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n-        // TODO(bjorn3): Properly implement unwinding.\n         self.unreachable();\n     }\n \n@@ -1160,6 +1265,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn atomic_cmpxchg(&mut self, dst: RValue<'gcc>, cmp: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n         let expected = self.current_func().new_local(None, cmp.get_type(), \"expected\");\n         self.llbb().add_assignment(None, expected, cmp);\n+        // NOTE: gcc doesn't support a failure memory model that is stronger than the success\n+        // memory model.\n+        let order =\n+            if failure_order as i32 > order as i32 {\n+                failure_order\n+            }\n+            else {\n+                order\n+            };\n         let success = self.compare_exchange(dst, expected, src, order, failure_order, weak);\n \n         let pair_type = self.cx.type_struct(&[src.get_type(), self.bool_type], false);\n@@ -1469,7 +1583,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n-        let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");\n+        let struct_type = mask.get_type().is_struct().expect(\"mask should be of struct type\");\n \n         // TODO(antoyo): use a recursive unqualified() here.\n         let vector_type = v1.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n@@ -1501,22 +1615,17 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             vector_elements.push(self.context.new_rvalue_zero(mask_element_type));\n         }\n \n-        let array_type = self.context.new_array_type(None, element_type, vec_num_units as i32);\n         let result_type = self.context.new_vector_type(element_type, mask_num_units as u64);\n         let (v1, v2) =\n             if vec_num_units < mask_num_units {\n                 // NOTE: the mask needs to be the same length as the input vectors, so join the 2\n                 // vectors and create a dummy second vector.\n-                // TODO(antoyo): switch to using new_vector_access.\n-                let array = self.context.new_bitcast(None, v1, array_type);\n                 let mut elements = vec![];\n                 for i in 0..vec_num_units {\n-                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                    elements.push(self.context.new_vector_access(None, v1, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n-                // TODO(antoyo): switch to using new_vector_access.\n-                let array = self.context.new_bitcast(None, v2, array_type);\n                 for i in 0..(mask_num_units - vec_num_units) {\n-                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                    elements.push(self.context.new_vector_access(None, v2, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n                 let v1 = self.context.new_rvalue_from_vector(None, result_type, &elements);\n                 let zero = self.context.new_rvalue_zero(element_type);\n@@ -1536,10 +1645,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             // NOTE: if padding was added, only select the number of elements of the masks to\n             // remove that padding in the result.\n             let mut elements = vec![];\n-            // TODO(antoyo): switch to using new_vector_access.\n-            let array = self.context.new_bitcast(None, result, array_type);\n             for i in 0..mask_num_units {\n-                elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                elements.push(self.context.new_vector_access(None, result, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n             }\n             self.context.new_rvalue_from_vector(None, result_type, &elements)\n         }\n@@ -1558,18 +1665,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let mask_element_type = self.type_ix(element_type.get_size() as u64 * 8);\n         let element_count = vector_type.get_num_units();\n         let mut vector_elements = vec![];\n         for i in 0..element_count {\n             vector_elements.push(i);\n         }\n-        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mask_type = self.context.new_vector_type(mask_element_type, element_count as u64);\n         let mut shift = 1;\n         let mut res = src;\n         while shift < element_count {\n             let vector_elements: Vec<_> =\n                 vector_elements.iter()\n-                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .map(|i| self.context.new_rvalue_from_int(mask_element_type, ((i + shift) % element_count) as i32))\n                     .collect();\n             let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n             let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n@@ -1581,7 +1690,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    pub fn vector_reduce<F>(&mut self, _src: RValue<'gcc>, _op: F) -> RValue<'gcc>\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         unimplemented!();\n@@ -1595,54 +1704,196 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fadd(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x + i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fadd(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n     pub fn vector_reduce_fmul_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmul(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x * i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmul(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!()\n+    }\n+\n     // Inspired by Hacker's Delight min implementation.\n     pub fn vector_reduce_min(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n         })\n     }\n \n     // Inspired by Hacker's Delight max implementation.\n     pub fn vector_reduce_max(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n         })\n     }\n \n+    fn vector_extremum(&mut self, a: RValue<'gcc>, b: RValue<'gcc>, direction: ExtremumOperation) -> RValue<'gcc> {\n+        let vector_type = a.get_type();\n+\n+        // mask out the NaNs in b and replace them with the corresponding lane in a, so when a and\n+        // b get compared & spliced together, we get the numeric values instead of NaNs.\n+        let b_nan_mask = self.context.new_comparison(None, ComparisonOp::NotEquals, b, b);\n+        let mask_type = b_nan_mask.get_type();\n+        let b_nan_mask_inverted = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, mask_type, b_nan_mask);\n+        let a_cast = self.context.new_bitcast(None, a, mask_type);\n+        let b_cast = self.context.new_bitcast(None, b, mask_type);\n+        let res = (b_nan_mask & a_cast) | (b_nan_mask_inverted & b_cast);\n+        let b = self.context.new_bitcast(None, res, vector_type);\n+\n+        // now do the actual comparison\n+        let comparison_op = match direction {\n+            ExtremumOperation::Min => ComparisonOp::LessThan,\n+            ExtremumOperation::Max => ComparisonOp::GreaterThan,\n+        };\n+        let cmp = self.context.new_comparison(None, comparison_op, a, b);\n+        let cmp_inverted = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, cmp.get_type(), cmp);\n+        let res = (cmp & a_cast) | (cmp_inverted & res);\n+        self.context.new_bitcast(None, res, vector_type)\n+    }\n+\n+    pub fn vector_fmin(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_extremum(a, b, ExtremumOperation::Min)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmin(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::LessThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmin(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_fmax(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_extremum(a, b, ExtremumOperation::Max)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmax(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::GreaterThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmax(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n     pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n         // cond is a vector of integers, not of bools.\n-        let cond_type = cond.get_type();\n-        let vector_type = cond_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let vector_type = cond.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n         let num_units = vector_type.get_num_units();\n         let element_type = vector_type.get_element_type();\n+\n+        #[cfg(feature=\"master\")]\n+        let (cond, element_type) = {\n+            let then_val_vector_type = then_val.get_type().dyncast_vector().expect(\"vector type\");\n+            let then_val_element_type = then_val_vector_type.get_element_type();\n+            let then_val_element_size = then_val_element_type.get_size();\n+\n+            // NOTE: the mask needs to be of the same size as the other arguments in order for the &\n+            // operation to work.\n+            if then_val_element_size != element_type.get_size() {\n+                let new_element_type = self.type_ix(then_val_element_size as u64 * 8);\n+                let new_vector_type = self.context.new_vector_type(new_element_type, num_units as u64);\n+                let cond = self.context.convert_vector(None, cond, new_vector_type);\n+                (cond, new_element_type)\n+            }\n+            else {\n+                (cond, element_type)\n+            }\n+        };\n+\n+        let cond_type = cond.get_type();\n+\n         let zeros = vec![self.context.new_rvalue_zero(element_type); num_units];\n         let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n \n+        let result_type = then_val.get_type();\n+\n         let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+        // the & operation work.\n+        let then_val = self.bitcast_if_needed(then_val, masks.get_type());\n         let then_vals = masks & then_val;\n \n-        let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n-        let ones = self.context.new_rvalue_from_vector(None, cond_type, &ones);\n-        let inverted_masks = masks + ones;\n+        let minus_ones = vec![self.context.new_rvalue_from_int(element_type, -1); num_units];\n+        let minus_ones = self.context.new_rvalue_from_vector(None, cond_type, &minus_ones);\n+        let inverted_masks = masks ^ minus_ones;\n         // NOTE: sometimes, the type of else_val can be different than the type of then_val in\n         // libgccjit (vector of int vs vector of int32_t), but they should be the same for the AND\n         // operation to work.\n+        // TODO: remove bitcast now that vector types can be compared?\n         let else_val = self.context.new_bitcast(None, else_val, then_val.get_type());\n         let else_vals = inverted_masks & else_val;\n \n-        then_vals | else_vals\n+        let res = then_vals | else_vals;\n+        self.bitcast_if_needed(res, result_type)\n     }\n }\n \n fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n     let difference = a - b;\n     let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+    // the & operation work.\n+    let a_type = a.get_type();\n+    let masks =\n+        if masks.get_type() != a_type {\n+            context.new_bitcast(None, masks, a_type)\n+        }\n+        else {\n+            masks\n+        };\n     difference & masks\n }\n "}, {"sha": "ba1e86562089e756e167d2cbf14990a7560c596f", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 105, "deletions": 8, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,9 +1,10 @@\n-use gccjit::{FunctionType, RValue};\n-use rustc_codegen_ssa::traits::BaseTypeMethods;\n+#[cfg(feature=\"master\")]\n+use gccjit::{FnAttribute, Visibility};\n+use gccjit::{FunctionType, Function};\n use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n-use crate::abi::FnAbiGccExt;\n+use crate::attributes;\n use crate::context::CodegenCx;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -13,22 +14,26 @@ use crate::context::CodegenCx;\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> RValue<'gcc> {\n+pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n+    let sym = tcx.symbol_name(instance).name;\n+\n     if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n         return func;\n     }\n \n-    let sym = tcx.symbol_name(instance).name;\n-\n     let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let func =\n-        if let Some(func) = cx.get_declared_value(&sym) {\n+        if let Some(_func) = cx.get_declared_value(&sym) {\n+            // FIXME(antoyo): we never reach this because get_declared_value only returns global variables\n+            // and here we try to get a function.\n+            unreachable!();\n+            /*\n             // Create a fn pointer with the new signature.\n             let ptrty = fn_abi.ptr_to_gcc_type(cx);\n \n@@ -61,13 +66,105 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             }\n             else {\n                 func\n-            }\n+            }*/\n         }\n         else {\n             cx.linkage.set(FunctionType::Extern);\n             let func = cx.declare_fn(&sym, &fn_abi);\n \n+            attributes::from_fn_attrs(cx, func, instance);\n+\n+            let instance_def_id = instance.def_id();\n+\n             // TODO(antoyo): set linkage and attributes.\n+\n+            // Apply an appropriate linkage/visibility value to our item that we\n+            // just declared.\n+            //\n+            // This is sort of subtle. Inside our codegen unit we started off\n+            // compilation by predefining all our own `MonoItem` instances. That\n+            // is, everything we're codegenning ourselves is already defined. That\n+            // means that anything we're actually codegenning in this codegen unit\n+            // will have hit the above branch in `get_declared_value`. As a result,\n+            // we're guaranteed here that we're declaring a symbol that won't get\n+            // defined, or in other words we're referencing a value from another\n+            // codegen unit or even another crate.\n+            //\n+            // So because this is a foreign value we blanket apply an external\n+            // linkage directive because it's coming from a different object file.\n+            // The visibility here is where it gets tricky. This symbol could be\n+            // referencing some foreign crate or foreign library (an `extern`\n+            // block) in which case we want to leave the default visibility. We may\n+            // also, though, have multiple codegen units. It could be a\n+            // monomorphization, in which case its expected visibility depends on\n+            // whether we are sharing generics or not. The important thing here is\n+            // that the visibility we apply to the declaration is the same one that\n+            // has been applied to the definition (wherever that definition may be).\n+            let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+            if is_generic {\n+                // This is a monomorphization. Its expected visibility depends\n+                // on whether we are in share-generics mode.\n+\n+                if cx.tcx.sess.opts.share_generics() {\n+                    // We are in share_generics mode.\n+\n+                    if let Some(instance_def_id) = instance_def_id.as_local() {\n+                        // This is a definition from the current crate. If the\n+                        // definition is unreachable for downstream crates or\n+                        // the current crate does not re-export generics, the\n+                        // definition of the instance will have been declared\n+                        // as `hidden`.\n+                        if cx.tcx.is_unreachable_local_definition(instance_def_id)\n+                            || !cx.tcx.local_crate_exports_generics()\n+                        {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a monomorphization of a generic function\n+                        // defined in an upstream crate.\n+                        if instance.upstream_monomorphization(tcx).is_some() {\n+                            // This is instantiated in another crate. It cannot\n+                            // be `hidden`.\n+                        } else {\n+                            // This is a local instantiation of an upstream definition.\n+                            // If the current crate does not re-export it\n+                            // (because it is a C library or an executable), it\n+                            // will have been declared `hidden`.\n+                            if !cx.tcx.local_crate_exports_generics() {\n+                                #[cfg(feature=\"master\")]\n+                                func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // When not sharing generics, all instances are in the same\n+                    // crate and have hidden visibility\n+                    #[cfg(feature=\"master\")]\n+                    func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                }\n+            } else {\n+                // This is a non-generic function\n+                if cx.tcx.is_codegened_item(instance_def_id) {\n+                    // This is a function that is instantiated in the local crate\n+\n+                    if instance_def_id.is_local() {\n+                        // This is function that is defined in the local crate.\n+                        // If it is not reachable, it is hidden.\n+                        if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a function from an upstream crate that has\n+                        // been instantiated here. These are always hidden.\n+                        #[cfg(feature=\"master\")]\n+                        func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                    }\n+                }\n+            }\n+\n             func\n         };\n "}, {"sha": "76fc7bd222e1e072e13cd5ebdb2221bf9585bda8", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -36,7 +36,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n     let context = &cx.context;\n     let byte_type = context.new_type::<u8>();\n-    let typ = context.new_array_type(None, byte_type, bytes.len() as i32);\n+    let typ = context.new_array_type(None, byte_type, bytes.len() as u64);\n     let elements: Vec<_> =\n         bytes.iter()\n         .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n@@ -115,8 +115,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.const_uint(self.usize_type, i)\n     }\n \n-    fn const_u8(&self, _i: u8) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn const_u8(&self, i: u8) -> RValue<'gcc> {\n+        self.const_uint(self.type_u8(), i as u64)\n     }\n \n     fn const_real(&self, typ: Type<'gcc>, val: f64) -> RValue<'gcc> {\n@@ -133,7 +133,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             .1;\n         let len = s.len();\n         let cs = self.const_ptrcast(str_global.get_address(None),\n-            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n+            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self)),\n         );\n         (cs, self.const_usize(len as u64))\n     }\n@@ -174,8 +174,18 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 }\n \n                 let value = self.const_uint_big(self.type_ix(bitsize), data);\n-                // TODO(bjorn3): assert size is correct\n-                self.const_bitcast(value, ty)\n+                let bytesize = layout.size(self).bytes();\n+                if bitsize > 1 && ty.is_integral() && bytesize as u32 == ty.get_size() {\n+                    // NOTE: since the intrinsic _xabort is called with a bitcast, which\n+                    // is non-const, but expects a constant, do a normal cast instead of a bitcast.\n+                    // FIXME(antoyo): fix bitcast to work in constant contexts.\n+                    // TODO(antoyo): perhaps only use bitcast for pointers?\n+                    self.context.new_cast(None, value, ty)\n+                }\n+                else {\n+                    // TODO(bjorn3): assert size is correct\n+                    self.const_bitcast(value, ty)\n+                }\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n@@ -227,11 +237,11 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n         assert_eq!(alloc.inner().align, layout.align.abi);\n-        let ty = self.type_ptr_to(layout.gcc_type(self, true));\n+        let ty = self.type_ptr_to(layout.gcc_type(self));\n         let value =\n             if layout.size == Size::ZERO {\n                 let value = self.const_usize(alloc.inner().align.bytes());\n-                self.context.new_cast(None, value, ty)\n+                self.const_bitcast(value, ty)\n             }\n             else {\n                 let init = const_alloc_to_gcc(self, alloc);"}, {"sha": "792ab8f890d8feab0f2c7cabdf30d293c1551c17", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 86, "deletions": 85, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,8 +1,8 @@\n-use gccjit::{GlobalKind, LValue, RValue, ToRValue, Type};\n+#[cfg(feature = \"master\")]\n+use gccjit::FnAttribute;\n+use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n-use rustc_hir as hir;\n-use rustc_hir::Node;\n-use rustc_middle::{bug, span_bug};\n+use rustc_middle::span_bug;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -13,6 +13,7 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMinimumAlignment;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -30,6 +31,21 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n+fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>, mut align: Align) {\n+    // The target may require greater alignment for globals than the type does.\n+    // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n+    // which can force it to be smaller. Rust doesn't support this yet.\n+    if let Some(min) = cx.sess().target.min_global_align {\n+        match Align::from_bits(min) {\n+            Ok(min) => align = align.max(min),\n+            Err(err) => {\n+                cx.sess().emit_err(InvalidMinimumAlignment { err });\n+            }\n+        }\n+    }\n+    gv.set_alignment(align.bytes() as i32);\n+}\n+\n impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn static_addr_of(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n         // TODO(antoyo): implement a proper rvalue comparison in libgccjit instead of doing the\n@@ -79,9 +95,9 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n-        // TODO(antoyo): set alignment.\n+        set_global_alignment(self, global, self.align_of(ty));\n \n         let value = self.bitcast_if_needed(value, gcc_type);\n         global.global_set_initializer_rvalue(value);\n@@ -158,12 +174,19 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn add_compiler_used_global(&self, _global: RValue<'gcc>) {\n-        // TODO(antoyo)\n+    fn add_compiler_used_global(&self, global: RValue<'gcc>) {\n+        // NOTE: seems like GCC does not make the distinction between compiler.used and used.\n+        self.add_used_global(global);\n     }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    pub fn add_used_function(&self, function: Function<'gcc>) {\n+        #[cfg(feature = \"master\")]\n+        function.add_attribute(FnAttribute::Used);\n+    }\n+\n     pub fn static_addr_of_mut(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n         let global =\n             match kind {\n@@ -208,82 +231,59 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let sym = self.tcx.symbol_name(instance).name;\n \n         let global =\n-            if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let llty = self.layout_of(ty).gcc_type(self, true);\n-                // FIXME: refactor this to work without accessing the HIR\n-                let global = match self.tcx.hir().get(id) {\n-                    Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n-                        if let Some(global) = self.get_declared_value(&sym) {\n-                            if self.val_ty(global) != self.type_ptr_to(llty) {\n-                                span_bug!(span, \"Conflicting types for static\");\n-                            }\n-                        }\n-\n-                        let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-                        let global = self.declare_global(\n-                            &sym,\n-                            llty,\n-                            GlobalKind::Exported,\n-                            is_tls,\n-                            fn_attrs.link_section,\n-                        );\n-\n-                        if !self.tcx.is_reachable_non_generic(def_id) {\n-                            // TODO(antoyo): set visibility.\n-                        }\n-\n-                        global\n-                    }\n-\n-                    Node::ForeignItem(&hir::ForeignItem {\n-                        span: _,\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    }) => {\n-                        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n-                    }\n-\n-                    item => bug!(\"get_static: expected static, found {:?}\", item),\n-                };\n+            if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n+            let llty = self.layout_of(ty).gcc_type(self);\n+            if let Some(global) = self.get_declared_value(sym) {\n+                if self.val_ty(global) != self.type_ptr_to(llty) {\n+                    span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n+                }\n+            }\n \n-                global\n+            let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+            let global = self.declare_global(\n+                &sym,\n+                llty,\n+                GlobalKind::Exported,\n+                is_tls,\n+                fn_attrs.link_section,\n+            );\n+\n+            if !self.tcx.is_reachable_non_generic(def_id) {\n+                // TODO(antoyo): set visibility.\n             }\n-            else {\n-                // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-                //debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n-\n-                let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                let global = check_and_apply_linkage(&self, &attrs, ty, sym);\n-\n-                let needs_dll_storage_attr = false; // TODO(antoyo)\n-\n-                // If this assertion triggers, there's something wrong with commandline\n-                // argument validation.\n-                debug_assert!(\n-                    !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                        && self.tcx.sess.target.options.is_like_msvc\n-                        && self.tcx.sess.opts.cg.prefer_dynamic)\n-                );\n-\n-                if needs_dll_storage_attr {\n-                    // This item is external but not foreign, i.e., it originates from an external Rust\n-                    // crate. Since we don't know whether this crate will be linked dynamically or\n-                    // statically in the final application, we always mark such symbols as 'dllimport'.\n-                    // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n-                    // to make things work.\n-                    //\n-                    // However, in some scenarios we defer emission of statics to downstream\n-                    // crates, so there are cases where a static with an upstream DefId\n-                    // is actually present in the current crate. We can find out via the\n-                    // is_codegened_item query.\n-                    if !self.tcx.is_codegened_item(def_id) {\n-                        unimplemented!();\n-                    }\n+\n+            global\n+        } else {\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n+        };\n+\n+        if !def_id.is_local() {\n+            let needs_dll_storage_attr = false; // TODO(antoyo)\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(\n+                !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                    && self.tcx.sess.target.options.is_like_msvc\n+                    && self.tcx.sess.opts.cg.prefer_dynamic)\n+            );\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !self.tcx.is_codegened_item(def_id) {\n+                    unimplemented!();\n                 }\n-                global\n-            };\n+            }\n+        }\n \n         // TODO(antoyo): set dll storage class.\n \n@@ -357,7 +357,7 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n \n fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-    let llty = cx.layout_of(ty).gcc_type(cx, true);\n+    let gcc_type = cx.layout_of(ty).gcc_type(cx);\n     if let Some(linkage) = attrs.import_linkage {\n         // Declare a symbol `foo` with the desired linkage.\n         let global1 = cx.declare_global_with_linkage(&sym, cx.type_i8(), base::global_linkage_to_gcc(linkage));\n@@ -370,9 +370,10 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // zero.\n         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n         real_name.push_str(&sym);\n-        let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n+        let global2 = cx.define_global(&real_name, gcc_type, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        global2.global_set_initializer_rvalue(global1.get_address(None));\n+        let value = cx.const_ptrcast(global1.get_address(None), gcc_type);\n+        global2.global_set_initializer_rvalue(value);\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }\n@@ -386,6 +387,6 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        cx.declare_global(&sym, llty, GlobalKind::Imported, is_tls, attrs.link_section)\n+        cx.declare_global(&sym, gcc_type, GlobalKind::Imported, is_tls, attrs.link_section)\n     }\n }"}, {"sha": "661681bdb50f2f1094b0f18736ad43846110cc64", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,17 +1,18 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Struct, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n+    BaseTypeMethods,\n     MiscMethods,\n };\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOf, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n use rustc_span::{Span, source_map::respan};\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n@@ -33,6 +34,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     // TODO(bjorn3): Can this field be removed?\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n+    pub function_address_names: RefCell<FxHashMap<RValue<'gcc>, String>>,\n \n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n     pub intrinsics: RefCell<FxHashMap<String, Function<'gcc>>>,\n@@ -78,12 +80,10 @@ pub struct CodegenCx<'gcc, 'tcx> {\n \n     pub struct_types: RefCell<FxHashMap<Vec<Type<'gcc>>, Type<'gcc>>>,\n \n-    pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n-\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n     /// Cache function instances of monomorphic and polymorphic items\n-    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, Function<'gcc>>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n@@ -110,6 +110,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     local_gen_sym_counter: Cell<usize>,\n \n     eh_personality: Cell<Option<RValue<'gcc>>>,\n+    pub rust_try_fn: Cell<Option<(Type<'gcc>, Function<'gcc>)>>,\n \n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n \n@@ -119,6 +120,8 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// they can be dereferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n+\n+    pub cleanup_blocks: RefCell<FxHashSet<Block<'gcc>>>,\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -194,6 +197,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             context,\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n+            function_address_names: Default::default(),\n             functions: RefCell::new(functions),\n             intrinsics: RefCell::new(FxHashMap::default()),\n \n@@ -243,11 +247,12 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             types: Default::default(),\n             tcx,\n             struct_types: Default::default(),\n-            types_with_fields_to_set: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n+            rust_try_fn: Cell::new(None),\n             pointee_infos: Default::default(),\n             structs_as_pointer: Default::default(),\n+            cleanup_blocks: Default::default(),\n         }\n     }\n \n@@ -327,8 +332,9 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn get_fn(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n         let func = get_fn(self, instance);\n-        *self.current_func.borrow_mut() = Some(self.rvalue_as_function(func));\n-        func\n+        *self.current_func.borrow_mut() = Some(func);\n+        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+        unsafe { std::mem::transmute(func) }\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n@@ -339,15 +345,15 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 self.intrinsics.borrow()[func_name].clone()\n             }\n             else {\n-                let func = get_fn(self, instance);\n-                self.rvalue_as_function(func)\n+                get_fn(self, instance)\n             };\n         let ptr = func.get_address(None);\n \n         // TODO(antoyo): don't do this twice: i.e. in declare_fn and here.\n         // FIXME(antoyo): the rustc API seems to call get_fn_addr() when not needed (e.g. for FFI).\n \n         self.normal_function_addresses.borrow_mut().insert(ptr);\n+        self.function_address_names.borrow_mut().insert(ptr, func_name.to_string());\n \n         ptr\n     }\n@@ -377,31 +383,40 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             return llpersonality;\n         }\n         let tcx = self.tcx;\n-        let llfn = match tcx.lang_items().eh_personality() {\n-            Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    ty::List::empty(),\n-                )\n-                .unwrap().unwrap(),\n-            ),\n-            _ => {\n-                let _name = if wants_msvc_seh(self.sess()) {\n-                    \"__CxxFrameHandler3\"\n-                } else {\n-                    \"rust_eh_personality\"\n-                };\n-                //let func = self.declare_func(name, self.type_i32(), &[], true);\n-                // FIXME(antoyo): this hack should not be needed. That will probably be removed when\n-                // unwinding support is added.\n-                self.context.new_rvalue_from_int(self.int_type, 0)\n-            }\n-        };\n+        let func =\n+            match tcx.lang_items().eh_personality() {\n+                Some(def_id) if !wants_msvc_seh(self.sess()) => {\n+                    let instance =\n+                        ty::Instance::resolve(\n+                            tcx,\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            ty::List::empty(),\n+                        )\n+                        .unwrap().unwrap();\n+\n+                    let symbol_name = tcx.symbol_name(instance).name;\n+                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n+                    self.linkage.set(FunctionType::Extern);\n+                    let func = self.declare_fn(symbol_name, &fn_abi);\n+                    let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n+                    func\n+                },\n+                _ => {\n+                    let name =\n+                        if wants_msvc_seh(self.sess()) {\n+                            \"__CxxFrameHandler3\"\n+                        }\n+                        else {\n+                            \"rust_eh_personality\"\n+                        };\n+                    let func = self.declare_func(name, self.type_i32(), &[], true);\n+                    unsafe { std::mem::transmute(func) }\n+                }\n+            };\n         // TODO(antoyo): apply target cpu attributes.\n-        self.eh_personality.set(Some(llfn));\n-        llfn\n+        self.eh_personality.set(Some(func));\n+        func\n     }\n \n     fn sess(&self) -> &Session {"}, {"sha": "4748e7e4be2a3afe401ed49886cc7ae9a862c6b3", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -38,12 +38,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n     }\n \n-    /*pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> RValue<'gcc> {\n-        self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n-    }*/\n+    pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n+        self.linkage.set(FunctionType::Extern);\n+        declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic)\n+    }\n \n     pub fn declare_global(&self, name: &str, ty: Type<'gcc>, global_kind: GlobalKind, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         let global = self.context.new_global(None, global_kind, ty, name);\n@@ -79,12 +77,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Function<'gcc> {\n         let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n+        func\n     }\n \n     pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {"}, {"sha": "9305bd1e043d564010bd360c27b92ef4b266e82a", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -221,3 +221,18 @@ pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_minimum_alignment)]\n+pub(crate) struct InvalidMinimumAlignment {\n+    pub err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_tied_target_features)]\n+#[help]\n+pub(crate) struct TiedTargetFeatures {\n+    #[primary_span]\n+    pub span: Span,\n+    pub features: String,\n+}"}, {"sha": "0cf1204791d336c75afe591660e994e7e94fb36a", "filename": "compiler/rustc_codegen_gcc/src/int.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -389,18 +389,22 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 };\n             self.context.new_comparison(None, op, cmp, self.context.new_rvalue_from_int(self.int_type, limit))\n         }\n+        else if a_type.get_pointee().is_some() && b_type.get_pointee().is_some() {\n+            // NOTE: gcc cannot compare pointers to different objects, but rustc does that, so cast them to usize.\n+            lhs = self.context.new_bitcast(None, lhs, self.usize_type);\n+            rhs = self.context.new_bitcast(None, rhs, self.usize_type);\n+            self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+        }\n         else {\n-            let left_type = lhs.get_type();\n-            let right_type = rhs.get_type();\n-            if left_type != right_type {\n+            if a_type != b_type {\n                 // NOTE: because libgccjit cannot compare function pointers.\n-                if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n+                if a_type.dyncast_function_ptr_type().is_some() && b_type.dyncast_function_ptr_type().is_some() {\n                     lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n                     rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n                 }\n                 // NOTE: hack because we try to cast a vector type to the same vector type.\n-                else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n-                    rhs = self.context.new_cast(None, rhs, left_type);\n+                else if format!(\"{:?}\", a_type) != format!(\"{:?}\", b_type) {\n+                    rhs = self.context.new_cast(None, rhs, a_type);\n                 }\n             }\n             self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)"}, {"sha": "8a4559355ea6716877df1b2de076d43e51a6cf38", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/archs.rs", "status": "modified", "additions": 2379, "deletions": 64, "changes": 2443, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a"}, {"sha": "0edec566be309987bac044515be59f69d4ab8c86", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/llvm.rs", "status": "modified", "additions": 663, "deletions": 134, "changes": 797, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,159 +1,387 @@\n use std::borrow::Cow;\n \n-use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue, UnaryOp};\n+use rustc_codegen_ssa::traits::BuilderMethods;\n \n use crate::{context::CodegenCx, builder::Builder};\n \n-pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str) -> Cow<'b, [RValue<'gcc>]> {\n+pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str, original_function_name: Option<&String>) -> Cow<'b, [RValue<'gcc>]> {\n     // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n     // arguments here.\n     if gcc_func.get_param_count() != args.len() {\n         match &*func_name {\n-            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n-                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+            // NOTE: the following intrinsics have a different number of parameters in LLVM and GCC.\n+            \"__builtin_ia32_prold512_mask\" | \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n                 | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n-                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n-                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\"\n                 | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n-                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n-                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\"\n+                | \"__builtin_ia32_prolq512_mask\" | \"__builtin_ia32_prorq512_mask\" | \"__builtin_ia32_pslldi512_mask\"\n+                | \"__builtin_ia32_psrldi512_mask\" | \"__builtin_ia32_psllqi512_mask\" | \"__builtin_ia32_psrlqi512_mask\"\n+                | \"__builtin_ia32_pslld512_mask\" | \"__builtin_ia32_psrld512_mask\" | \"__builtin_ia32_psllq512_mask\"\n+                | \"__builtin_ia32_psrlq512_mask\" | \"__builtin_ia32_psrad512_mask\" | \"__builtin_ia32_psraq512_mask\"\n+                | \"__builtin_ia32_psradi512_mask\" | \"__builtin_ia32_psraqi512_mask\" | \"__builtin_ia32_psrav16si_mask\"\n+                | \"__builtin_ia32_psrav8di_mask\" | \"__builtin_ia32_prolvd512_mask\" | \"__builtin_ia32_prorvd512_mask\"\n+                | \"__builtin_ia32_prolvq512_mask\" | \"__builtin_ia32_prorvq512_mask\" | \"__builtin_ia32_psllv16si_mask\"\n+                | \"__builtin_ia32_psrlv16si_mask\" | \"__builtin_ia32_psllv8di_mask\" | \"__builtin_ia32_psrlv8di_mask\"\n+                | \"__builtin_ia32_permvarsi512_mask\" | \"__builtin_ia32_vpermilvarps512_mask\"\n+                | \"__builtin_ia32_vpermilvarpd512_mask\" | \"__builtin_ia32_permvardi512_mask\"\n+                | \"__builtin_ia32_permvarsf512_mask\" | \"__builtin_ia32_permvarqi512_mask\"\n+                | \"__builtin_ia32_permvarqi256_mask\" | \"__builtin_ia32_permvarqi128_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb512_mask\" | \"__builtin_ia32_vpmultishiftqb256_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb128_mask\"\n                 => {\n-                    // TODO: refactor by separating those intrinsics outside of this branch.\n-                    let add_before_last_arg =\n-                        match &*func_name {\n-                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n-                            _ => false,\n-                        };\n-                    let new_first_arg_is_zero =\n-                        match &*func_name {\n-                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n-                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n-                            _ => false\n-                        };\n-                    let arg3_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n-                            _ => 2,\n-                        };\n-                    let mut new_args = args.to_vec();\n-                    let arg3_type = gcc_func.get_param_type(arg3_index);\n-                    let first_arg =\n-                        if new_first_arg_is_zero {\n-                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n-                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n-                            let num_units = vector_type.get_num_units();\n-                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n-                        }\n-                        else {\n-                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n-                        };\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, first_arg);\n-                    }\n-                    else {\n-                        new_args.push(first_arg);\n-                    }\n-                    let arg4_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n-                            _ => 3,\n-                        };\n-                    let arg4_type = gcc_func.get_param_type(arg4_index);\n-                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, minus_one);\n-                    }\n-                    else {\n-                        new_args.push(minus_one);\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let first_arg = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_prold256_mask\" | \"__builtin_ia32_prold128_mask\"\n+                | \"__builtin_ia32_prord512_mask\" | \"__builtin_ia32_prord256_mask\" | \"__builtin_ia32_prord128_mask\"\n+                | \"__builtin_ia32_prolq256_mask\" | \"__builtin_ia32_prolq128_mask\" | \"__builtin_ia32_prorq256_mask\"\n+                | \"__builtin_ia32_prorq128_mask\" | \"__builtin_ia32_psraq256_mask\" | \"__builtin_ia32_psraq128_mask\"\n+                | \"__builtin_ia32_psraqi256_mask\" | \"__builtin_ia32_psraqi128_mask\" | \"__builtin_ia32_psravq256_mask\"\n+                | \"__builtin_ia32_psravq128_mask\" | \"__builtin_ia32_prolvd256_mask\" | \"__builtin_ia32_prolvd128_mask\"\n+                | \"__builtin_ia32_prorvd256_mask\" | \"__builtin_ia32_prorvd128_mask\" | \"__builtin_ia32_prolvq256_mask\"\n+                | \"__builtin_ia32_prolvq128_mask\" | \"__builtin_ia32_prorvq256_mask\" | \"__builtin_ia32_prorvq128_mask\"\n+                | \"__builtin_ia32_permvardi256_mask\" | \"__builtin_ia32_permvardf512_mask\" | \"__builtin_ia32_permvardf256_mask\"\n+                | \"__builtin_ia32_pmulhuw512_mask\" | \"__builtin_ia32_pmulhw512_mask\" | \"__builtin_ia32_pmulhrsw512_mask\"\n+                | \"__builtin_ia32_pmaxuw512_mask\" | \"__builtin_ia32_pmaxub512_mask\" | \"__builtin_ia32_pmaxsw512_mask\"\n+                | \"__builtin_ia32_pmaxsb512_mask\" | \"__builtin_ia32_pminuw512_mask\" | \"__builtin_ia32_pminub512_mask\"\n+                | \"__builtin_ia32_pminsw512_mask\" | \"__builtin_ia32_pminsb512_mask\"\n+                | \"__builtin_ia32_pmaddwd512_mask\" | \"__builtin_ia32_pmaddubsw512_mask\" | \"__builtin_ia32_packssdw512_mask\"\n+                | \"__builtin_ia32_packsswb512_mask\" | \"__builtin_ia32_packusdw512_mask\" | \"__builtin_ia32_packuswb512_mask\"\n+                | \"__builtin_ia32_pavgw512_mask\" | \"__builtin_ia32_pavgb512_mask\" | \"__builtin_ia32_psllw512_mask\"\n+                | \"__builtin_ia32_psllwi512_mask\" | \"__builtin_ia32_psllv32hi_mask\" | \"__builtin_ia32_psrlw512_mask\"\n+                | \"__builtin_ia32_psrlwi512_mask\" | \"__builtin_ia32_psllv16hi_mask\" | \"__builtin_ia32_psllv8hi_mask\"\n+                | \"__builtin_ia32_psrlv32hi_mask\" | \"__builtin_ia32_psraw512_mask\" | \"__builtin_ia32_psrawi512_mask\"\n+                | \"__builtin_ia32_psrlv16hi_mask\" | \"__builtin_ia32_psrlv8hi_mask\" | \"__builtin_ia32_psrav32hi_mask\"\n+                | \"__builtin_ia32_permvarhi512_mask\" | \"__builtin_ia32_pshufb512_mask\" | \"__builtin_ia32_psrav16hi_mask\"\n+                | \"__builtin_ia32_psrav8hi_mask\" | \"__builtin_ia32_permvarhi256_mask\" | \"__builtin_ia32_permvarhi128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_dbpsadbw512_mask\" | \"__builtin_ia32_dbpsadbw256_mask\" | \"__builtin_ia32_dbpsadbw128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let vector_type = arg4_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg4_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+                | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                // Remove last arg as it doesn't seem to be used in GCC and is always false.\n+                new_args.pop();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpconflictsi_512_mask\" | \"__builtin_ia32_vpconflictsi_256_mask\"\n+                | \"__builtin_ia32_vpconflictsi_128_mask\" | \"__builtin_ia32_vpconflictdi_512_mask\"\n+                | \"__builtin_ia32_vpconflictdi_256_mask\" | \"__builtin_ia32_vpconflictdi_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+\n+                let mut last_arg = None;\n+                if args.len() == 4 {\n+                    last_arg = new_args.pop();\n+                }\n+\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+\n+                if args.len() == 3 {\n+                    // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                    // the same GCC intrinsic, but the former has 3 parameters and the\n+                    // latter has 4 so it doesn't require this additional argument.\n+                    let arg5_type = gcc_func.get_param_type(4);\n+                    new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                }\n+\n+                if let Some(last_arg) = last_arg {\n+                    new_args.push(last_arg);\n+                }\n+\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+                | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+                | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                |  \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermi2vard512_mask\" | \"__builtin_ia32_vpermi2vard256_mask\"\n+                | \"__builtin_ia32_vpermi2vard128_mask\" | \"__builtin_ia32_vpermi2varq512_mask\"\n+                | \"__builtin_ia32_vpermi2varq256_mask\" | \"__builtin_ia32_vpermi2varq128_mask\"\n+                | \"__builtin_ia32_vpermi2varps512_mask\" | \"__builtin_ia32_vpermi2varps256_mask\"\n+                | \"__builtin_ia32_vpermi2varps128_mask\" | \"__builtin_ia32_vpermi2varpd512_mask\"\n+                | \"__builtin_ia32_vpermi2varpd256_mask\" | \"__builtin_ia32_vpermi2varpd128_mask\" | \"__builtin_ia32_vpmadd52huq512_mask\"\n+                | \"__builtin_ia32_vpmadd52luq512_mask\" | \"__builtin_ia32_vpmadd52huq256_mask\" | \"__builtin_ia32_vpmadd52luq256_mask\"\n+                | \"__builtin_ia32_vpmadd52huq128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\"\n+                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let undefined = builder.current_func().new_local(None, arg2_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_stmxcsr\" => {\n+                args = vec![].into();\n+            },\n+            \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let variable = builder.current_func().new_local(None, arg2_type, \"addcarryResult\");\n+                new_args.push(variable.get_address(None));\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermt2varqi512_mask\" | \"__builtin_ia32_vpermt2varqi256_mask\"\n+                | \"__builtin_ia32_vpermt2varqi128_mask\" | \"__builtin_ia32_vpermt2varhi512_mask\"\n+                | \"__builtin_ia32_vpermt2varhi256_mask\" | \"__builtin_ia32_vpermt2varhi128_mask\"\n+                => {\n+                let new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                args = vec![new_args[1], new_args[0], new_args[2], minus_one].into();\n+            },\n+            \"__builtin_ia32_xrstor\" | \"__builtin_ia32_xsavec\" => {\n+                let new_args = args.to_vec();\n+                let thirty_two = builder.context.new_rvalue_from_int(new_args[1].get_type(), 32);\n+                let arg2 = new_args[1] << thirty_two | new_args[2];\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg2 = builder.context.new_cast(None, arg2, arg2_type);\n+                args = vec![new_args[0], arg2].into();\n+            },\n+            \"__builtin_prefetch\" => {\n+                let mut new_args = args.to_vec();\n+                new_args.pop();\n+                args = new_args.into();\n+            },\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match &*func_name {\n+            \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+                let new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let arg3 = builder.context.new_cast(None, new_args[4], arg3_type);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let arg4 = builder.context.new_bitcast(None, new_args[2], arg4_type);\n+                args = vec![new_args[0], new_args[1], arg3, arg4, new_args[3], new_args[5]].into();\n+            },\n+            // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+            // FIXME: the intrinsics like _mm_mask_fmadd_sd should probably directly call the GCC\n+            // instrinsic to avoid this.\n+            \"__builtin_ia32_vfmaddss3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 4]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 4]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 4]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsd3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 2]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 2]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 2]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsubpd256\" | \"__builtin_ia32_vfmaddsubps\" | \"__builtin_ia32_vfmaddsubps256\"\n+                | \"__builtin_ia32_vfmaddsubpd\" => {\n+                if let Some(original_function_name) = original_function_name {\n+                    match &**original_function_name {\n+                        \"llvm.x86.fma.vfmsubadd.pd.256\" | \"llvm.x86.fma.vfmsubadd.ps\" | \"llvm.x86.fma.vfmsubadd.ps.256\"\n+                            | \"llvm.x86.fma.vfmsubadd.pd\" => {\n+                            // NOTE: since both llvm.x86.fma.vfmsubadd.ps and llvm.x86.fma.vfmaddsub.ps maps to\n+                            // __builtin_ia32_vfmaddsubps, only add minus if this comes from a\n+                            // subadd LLVM intrinsic, e.g. _mm256_fmsubadd_pd.\n+                            let mut new_args = args.to_vec();\n+                            let arg3 = &mut new_args[2];\n+                            *arg3 = builder.context.new_unary_op(None, UnaryOp::Minus, arg3.get_type(), *arg3);\n+                            args = new_args.into();\n+                        },\n+                        _ => (),\n                     }\n-                    args = new_args.into();\n-                },\n-                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n-                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n-                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let arg5_type = gcc_func.get_param_type(4);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n-                        new_args.push(minus_one);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-\n-                        let mut last_arg = None;\n-                        if args.len() == 4 {\n-                            last_arg = new_args.pop();\n-                        }\n-\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-\n-                        if args.len() == 3 {\n-                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n-                            // the same GCC intrinsic, but the former has 3 parameters and the\n-                            // latter has 4 so it doesn't require this additional argument.\n-                            let arg5_type = gcc_func.get_param_type(4);\n-                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n-                        }\n-\n-                        if let Some(last_arg) = last_arg {\n-                            new_args.push(last_arg);\n-                        }\n-\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n-                        | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n-                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n-                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg3_type = gcc_func.get_param_type(2);\n-                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n-                        new_args.push(undefined);\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    _ => (),\n+                }\n+            },\n+            \"__builtin_ia32_ldmxcsr\" => {\n+                // The builtin __builtin_ia32_ldmxcsr takes an integer value while llvm.x86.sse.ldmxcsr takes a pointer,\n+                // so dereference the pointer.\n+                let mut new_args = args.to_vec();\n+                let uint_ptr_type = builder.uint_type.make_pointer();\n+                let arg1 = builder.context.new_cast(None, args[0], uint_ptr_type);\n+                new_args[0] = arg1.dereference(None).to_rvalue();\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_rcp14sd_mask\" | \"__builtin_ia32_rcp14ss_mask\" | \"__builtin_ia32_rsqrt14sd_mask\"\n+                | \"__builtin_ia32_rsqrt14ss_mask\" => {\n+                let new_args = args.to_vec();\n+                args = vec![new_args[1], new_args[0], new_args[2], new_args[3]].into();\n+            },\n+            \"__builtin_ia32_sqrtsd_mask_round\" | \"__builtin_ia32_sqrtss_mask_round\" => {\n+                let new_args = args.to_vec();\n+                args = vec![new_args[1], new_args[0], new_args[2], new_args[3], new_args[4]].into();\n+            },\n+            _ => (),\n         }\n     }\n \n     args\n }\n \n+pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, mut return_value: RValue<'gcc>, func_name: &str, args: &[RValue<'gcc>], args_adjusted: bool, orig_args: &[RValue<'gcc>]) -> RValue<'gcc> {\n+    match func_name {\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n+            #[cfg(feature=\"master\")]\n+            {\n+                let zero = builder.context.new_rvalue_zero(builder.int_type);\n+                return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+            }\n+        },\n+        \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+            // Both llvm.x86.addcarry.32 and llvm.x86.addcarryx.u32 points to the same GCC builtin,\n+            // but only the former requires adjusting the return value.\n+            // Those 2 LLVM intrinsics differ by their argument count, that's why we check if the\n+            // arguments were adjusted.\n+            if args_adjusted {\n+                let last_arg = args.last().expect(\"last arg\");\n+                let field1 = builder.context.new_field(None, builder.u8_type, \"carryFlag\");\n+                let field2 = builder.context.new_field(None, args[1].get_type(), \"carryResult\");\n+                let struct_type = builder.context.new_struct_type(None, \"addcarryResult\", &[field1, field2]);\n+                return_value = builder.context.new_struct_constructor(None, struct_type.as_type(), None, &[return_value, last_arg.dereference(None).to_rvalue()]);\n+            }\n+        },\n+        \"__builtin_ia32_stmxcsr\" => {\n+            // The builtin __builtin_ia32_stmxcsr returns a value while llvm.x86.sse.stmxcsr writes\n+            // the result in its pointer argument.\n+            // We removed the argument since __builtin_ia32_stmxcsr takes no arguments, so we need\n+            // to get back the original argument to get the pointer we need to write the result to.\n+            let uint_ptr_type = builder.uint_type.make_pointer();\n+            let ptr = builder.context.new_cast(None, orig_args[0], uint_ptr_type);\n+            builder.llbb().add_assignment(None, ptr.dereference(None), return_value);\n+            // The return value was assigned to the result pointer above. In order to not call the\n+            // builtin twice, we overwrite the return value with a dummy value.\n+            return_value = builder.context.new_rvalue_zero(builder.int_type);\n+        },\n+        _ => (),\n+    }\n+\n+    return_value\n+}\n+\n pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n-    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n-    // last argument type check.\n     // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n     match func_name {\n+        // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+        // last argument type check.\n         \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n             | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n             | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n             | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n             | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n             | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n-            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\"\n+            | \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\" => {\n                 if index == args_len - 1 {\n                     return true;\n                 }\n             },\n+        \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+            if index == 2 || index == 3 {\n+                return true;\n+            }\n+        },\n         \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n             // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n             // one of them has a missing parameter before the last one, we check the number of\n@@ -162,6 +390,14 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n                 return true;\n             }\n         },\n+        // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => return true,\n+        \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+            | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+            if index == args_len - 1 {\n+                return true;\n+            }\n+        },\n         _ => (),\n     }\n \n@@ -171,7 +407,7 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n #[cfg(not(feature=\"master\"))]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n     match name {\n-        \"llvm.x86.xgetbv\" => {\n+        \"llvm.x86.xgetbv\" | \"llvm.x86.sse2.pause\" => {\n             let gcc_name = \"__builtin_trap\";\n             let func = cx.context.get_builtin_function(gcc_name);\n             cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n@@ -183,24 +419,26 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n \n #[cfg(feature=\"master\")]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n+    match name {\n+        \"llvm.prefetch\" => {\n+            let gcc_name = \"__builtin_prefetch\";\n+            let func = cx.context.get_builtin_function(gcc_name);\n+            cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n+            return func\n+        },\n+        _ => (),\n+    }\n+\n     let gcc_name = match name {\n         \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n         // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n         \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n         \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n         \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n         \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n         \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n         \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n         \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n         \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n@@ -221,6 +459,153 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n         \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.sitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtdq2ps512_mask\",\n+        \"llvm.x86.avx512.uitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtudq2ps512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.512\" => \"__builtin_ia32_ucmpd512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.256\" => \"__builtin_ia32_ucmpd256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.128\" => \"__builtin_ia32_ucmpd128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.512\" => \"__builtin_ia32_cmpd512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.256\" => \"__builtin_ia32_cmpd256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.128\" => \"__builtin_ia32_cmpd128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.512\" => \"__builtin_ia32_ucmpq512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.256\" => \"__builtin_ia32_ucmpq256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.128\" => \"__builtin_ia32_ucmpq128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.512\" => \"__builtin_ia32_cmpq512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.256\" => \"__builtin_ia32_cmpq256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.128\" => \"__builtin_ia32_cmpq128_mask\",\n+        \"llvm.x86.avx512.mask.max.ss.round\" => \"__builtin_ia32_maxss_mask_round\",\n+        \"llvm.x86.avx512.mask.max.sd.round\" => \"__builtin_ia32_maxsd_mask_round\",\n+        \"llvm.x86.avx512.mask.min.ss.round\" => \"__builtin_ia32_minss_mask_round\",\n+        \"llvm.x86.avx512.mask.min.sd.round\" => \"__builtin_ia32_minsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.ss\" => \"__builtin_ia32_sqrtss_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.sd\" => \"__builtin_ia32_sqrtsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.ss\" => \"__builtin_ia32_getexpss_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.sd\" => \"__builtin_ia32_getexpsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.ss\" => \"__builtin_ia32_getmantss_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.sd\" => \"__builtin_ia32_getmantsd_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.ss\" => \"__builtin_ia32_rndscaless_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.sd\" => \"__builtin_ia32_rndscalesd_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.ss\" => \"__builtin_ia32_scalefss_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.sd\" => \"__builtin_ia32_scalefsd_mask_round\",\n+        \"llvm.x86.avx512.vfmadd.f32\" => \"__builtin_ia32_vfmaddss3_round\",\n+        \"llvm.x86.avx512.vfmadd.f64\" => \"__builtin_ia32_vfmaddsd3_round\",\n+        \"llvm.ceil.v4f64\" => \"__builtin_ia32_ceilpd256\",\n+        \"llvm.ceil.v8f32\" => \"__builtin_ia32_ceilps256\",\n+        \"llvm.floor.v4f64\" => \"__builtin_ia32_floorpd256\",\n+        \"llvm.floor.v8f32\" => \"__builtin_ia32_floorps256\",\n+        \"llvm.sqrt.v4f64\" => \"__builtin_ia32_sqrtpd256\",\n+        \"llvm.x86.sse.stmxcsr\" => \"__builtin_ia32_stmxcsr\",\n+        \"llvm.x86.sse.ldmxcsr\" => \"__builtin_ia32_ldmxcsr\",\n+        \"llvm.ctpop.v16i32\" => \"__builtin_ia32_vpopcountd_v16si\",\n+        \"llvm.ctpop.v8i32\" => \"__builtin_ia32_vpopcountd_v8si\",\n+        \"llvm.ctpop.v4i32\" => \"__builtin_ia32_vpopcountd_v4si\",\n+        \"llvm.ctpop.v8i64\" => \"__builtin_ia32_vpopcountq_v8di\",\n+        \"llvm.ctpop.v4i64\" => \"__builtin_ia32_vpopcountq_v4di\",\n+        \"llvm.ctpop.v2i64\" => \"__builtin_ia32_vpopcountq_v2di\",\n+        \"llvm.x86.addcarry.64\" => \"__builtin_ia32_addcarryx_u64\",\n+        \"llvm.x86.subborrow.64\" => \"__builtin_ia32_sbb_u64\",\n+        \"llvm.floor.v2f64\" => \"__builtin_ia32_floorpd\",\n+        \"llvm.floor.v4f32\" => \"__builtin_ia32_floorps\",\n+        \"llvm.ceil.v2f64\" => \"__builtin_ia32_ceilpd\",\n+        \"llvm.ceil.v4f32\" => \"__builtin_ia32_ceilps\",\n+        \"llvm.fma.v2f64\" => \"__builtin_ia32_vfmaddpd\",\n+        \"llvm.fma.v4f64\" => \"__builtin_ia32_vfmaddpd256\",\n+        \"llvm.fma.v4f32\" => \"__builtin_ia32_vfmaddps\",\n+        \"llvm.fma.v8f32\" => \"__builtin_ia32_vfmaddps256\",\n+        \"llvm.ctlz.v16i32\" => \"__builtin_ia32_vplzcntd_512_mask\",\n+        \"llvm.ctlz.v8i32\" => \"__builtin_ia32_vplzcntd_256_mask\",\n+        \"llvm.ctlz.v4i32\" => \"__builtin_ia32_vplzcntd_128_mask\",\n+        \"llvm.ctlz.v8i64\" => \"__builtin_ia32_vplzcntq_512_mask\",\n+        \"llvm.ctlz.v4i64\" => \"__builtin_ia32_vplzcntq_256_mask\",\n+        \"llvm.ctlz.v2i64\" => \"__builtin_ia32_vplzcntq_128_mask\",\n+        \"llvm.ctpop.v32i16\" => \"__builtin_ia32_vpopcountw_v32hi\",\n+        \"llvm.x86.fma.vfmsub.sd\" => \"__builtin_ia32_vfmsubsd3\",\n+        \"llvm.x86.fma.vfmsub.ss\" => \"__builtin_ia32_vfmsubss3\",\n+        \"llvm.x86.fma.vfmsubadd.pd\" => \"__builtin_ia32_vfmaddsubpd\",\n+        \"llvm.x86.fma.vfmsubadd.pd.256\" => \"__builtin_ia32_vfmaddsubpd256\",\n+        \"llvm.x86.fma.vfmsubadd.ps\" => \"__builtin_ia32_vfmaddsubps\",\n+        \"llvm.x86.fma.vfmsubadd.ps.256\" => \"__builtin_ia32_vfmaddsubps256\",\n+        \"llvm.x86.fma.vfnmadd.sd\" => \"__builtin_ia32_vfnmaddsd3\",\n+        \"llvm.x86.fma.vfnmadd.ss\" => \"__builtin_ia32_vfnmaddss3\",\n+        \"llvm.x86.fma.vfnmsub.sd\" => \"__builtin_ia32_vfnmsubsd3\",\n+        \"llvm.x86.fma.vfnmsub.ss\" => \"__builtin_ia32_vfnmsubss3\",\n+        \"llvm.x86.avx512.conflict.d.512\" => \"__builtin_ia32_vpconflictsi_512_mask\",\n+        \"llvm.x86.avx512.conflict.d.256\" => \"__builtin_ia32_vpconflictsi_256_mask\",\n+        \"llvm.x86.avx512.conflict.d.128\" => \"__builtin_ia32_vpconflictsi_128_mask\",\n+        \"llvm.x86.avx512.conflict.q.512\" => \"__builtin_ia32_vpconflictdi_512_mask\",\n+        \"llvm.x86.avx512.conflict.q.256\" => \"__builtin_ia32_vpconflictdi_256_mask\",\n+        \"llvm.x86.avx512.conflict.q.128\" => \"__builtin_ia32_vpconflictdi_128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.512\" => \"__builtin_ia32_vpermt2varqi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.256\" => \"__builtin_ia32_vpermt2varqi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.128\" => \"__builtin_ia32_vpermt2varqi128_mask\",\n+        \"llvm.x86.avx512.permvar.qi.512\" => \"__builtin_ia32_permvarqi512_mask\",\n+        \"llvm.x86.avx512.permvar.qi.256\" => \"__builtin_ia32_permvarqi256_mask\",\n+        \"llvm.x86.avx512.permvar.qi.128\" => \"__builtin_ia32_permvarqi128_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.512\" => \"__builtin_ia32_vpmultishiftqb512_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.256\" => \"__builtin_ia32_vpmultishiftqb256_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.128\" => \"__builtin_ia32_vpmultishiftqb128_mask\",\n+        \"llvm.ctpop.v16i16\" => \"__builtin_ia32_vpopcountw_v16hi\",\n+        \"llvm.ctpop.v8i16\" => \"__builtin_ia32_vpopcountw_v8hi\",\n+        \"llvm.ctpop.v64i8\" => \"__builtin_ia32_vpopcountb_v64qi\",\n+        \"llvm.ctpop.v32i8\" => \"__builtin_ia32_vpopcountb_v32qi\",\n+        \"llvm.ctpop.v16i8\" => \"__builtin_ia32_vpopcountb_v16qi\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.512\" => \"__builtin_ia32_vpshufbitqmb512_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.256\" => \"__builtin_ia32_vpshufbitqmb256_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.128\" => \"__builtin_ia32_vpshufbitqmb128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.512\" => \"__builtin_ia32_ucmpw512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.256\" => \"__builtin_ia32_ucmpw256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.128\" => \"__builtin_ia32_ucmpw128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.512\" => \"__builtin_ia32_ucmpb512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.256\" => \"__builtin_ia32_ucmpb256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.128\" => \"__builtin_ia32_ucmpb128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.512\" => \"__builtin_ia32_cmpw512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.256\" => \"__builtin_ia32_cmpw256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.128\" => \"__builtin_ia32_cmpw128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.512\" => \"__builtin_ia32_cmpb512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.256\" => \"__builtin_ia32_cmpb256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.128\" => \"__builtin_ia32_cmpb128_mask\",\n+        \"llvm.x86.xrstor\" => \"__builtin_ia32_xrstor\",\n+        \"llvm.x86.xsavec\" => \"__builtin_ia32_xsavec\",\n+        \"llvm.x86.addcarry.32\" => \"__builtin_ia32_addcarryx_u32\",\n+        \"llvm.x86.subborrow.32\" => \"__builtin_ia32_sbb_u32\",\n+        \"llvm.x86.avx512.mask.compress.store.w.512\" => \"__builtin_ia32_compressstoreuhi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.256\" => \"__builtin_ia32_compressstoreuhi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.128\" => \"__builtin_ia32_compressstoreuhi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.512\" => \"__builtin_ia32_compressstoreuqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.256\" => \"__builtin_ia32_compressstoreuqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.128\" => \"__builtin_ia32_compressstoreuqi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.512\" => \"__builtin_ia32_compresshi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.256\" => \"__builtin_ia32_compresshi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.128\" => \"__builtin_ia32_compresshi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.512\" => \"__builtin_ia32_compressqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.256\" => \"__builtin_ia32_compressqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.128\" => \"__builtin_ia32_compressqi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.512\" => \"__builtin_ia32_expandhi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.256\" => \"__builtin_ia32_expandhi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.128\" => \"__builtin_ia32_expandhi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.512\" => \"__builtin_ia32_expandqi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.256\" => \"__builtin_ia32_expandqi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.128\" => \"__builtin_ia32_expandqi128_mask\",\n+        \"llvm.fshl.v8i64\" => \"__builtin_ia32_vpshldv_v8di\",\n+        \"llvm.fshl.v4i64\" => \"__builtin_ia32_vpshldv_v4di\",\n+        \"llvm.fshl.v2i64\" => \"__builtin_ia32_vpshldv_v2di\",\n+        \"llvm.fshl.v16i32\" => \"__builtin_ia32_vpshldv_v16si\",\n+        \"llvm.fshl.v8i32\" => \"__builtin_ia32_vpshldv_v8si\",\n+        \"llvm.fshl.v4i32\" => \"__builtin_ia32_vpshldv_v4si\",\n+        \"llvm.fshl.v32i16\" => \"__builtin_ia32_vpshldv_v32hi\",\n+        \"llvm.fshl.v16i16\" => \"__builtin_ia32_vpshldv_v16hi\",\n+        \"llvm.fshl.v8i16\" => \"__builtin_ia32_vpshldv_v8hi\",\n+        \"llvm.fshr.v8i64\" => \"__builtin_ia32_vpshrdv_v8di\",\n+        \"llvm.fshr.v4i64\" => \"__builtin_ia32_vpshrdv_v4di\",\n+        \"llvm.fshr.v2i64\" => \"__builtin_ia32_vpshrdv_v2di\",\n+        \"llvm.fshr.v16i32\" => \"__builtin_ia32_vpshrdv_v16si\",\n+        \"llvm.fshr.v8i32\" => \"__builtin_ia32_vpshrdv_v8si\",\n+        \"llvm.fshr.v4i32\" => \"__builtin_ia32_vpshrdv_v4si\",\n+        \"llvm.fshr.v32i16\" => \"__builtin_ia32_vpshrdv_v32hi\",\n+        \"llvm.fshr.v16i16\" => \"__builtin_ia32_vpshrdv_v16hi\",\n+        \"llvm.fshr.v8i16\" => \"__builtin_ia32_vpshrdv_v8hi\",\n+        \"llvm.x86.fma.vfmadd.sd\" => \"__builtin_ia32_vfmaddsd3\",\n+        \"llvm.x86.fma.vfmadd.ss\" => \"__builtin_ia32_vfmaddss3\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n@@ -239,7 +624,151 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n         \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n         \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n-        \"\" => \"\",\n+        \"llvm.x86.avx512.pslli.d.512\" => \"__builtin_ia32_pslldi512_mask\",\n+        \"llvm.x86.avx512.psrli.d.512\" => \"__builtin_ia32_psrldi512_mask\",\n+        \"llvm.x86.avx512.pslli.q.512\" => \"__builtin_ia32_psllqi512_mask\",\n+        \"llvm.x86.avx512.psrli.q.512\" => \"__builtin_ia32_psrlqi512_mask\",\n+        \"llvm.x86.avx512.psll.d.512\" => \"__builtin_ia32_pslld512_mask\",\n+        \"llvm.x86.avx512.psrl.d.512\" => \"__builtin_ia32_psrld512_mask\",\n+        \"llvm.x86.avx512.psll.q.512\" => \"__builtin_ia32_psllq512_mask\",\n+        \"llvm.x86.avx512.psrl.q.512\" => \"__builtin_ia32_psrlq512_mask\",\n+        \"llvm.x86.avx512.psra.d.512\" => \"__builtin_ia32_psrad512_mask\",\n+        \"llvm.x86.avx512.psra.q.512\" => \"__builtin_ia32_psraq512_mask\",\n+        \"llvm.x86.avx512.psra.q.256\" => \"__builtin_ia32_psraq256_mask\",\n+        \"llvm.x86.avx512.psra.q.128\" => \"__builtin_ia32_psraq128_mask\",\n+        \"llvm.x86.avx512.psrai.d.512\" => \"__builtin_ia32_psradi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.512\" => \"__builtin_ia32_psraqi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.256\" => \"__builtin_ia32_psraqi256_mask\",\n+        \"llvm.x86.avx512.psrai.q.128\" => \"__builtin_ia32_psraqi128_mask\",\n+        \"llvm.x86.avx512.psrav.d.512\" => \"__builtin_ia32_psrav16si_mask\",\n+        \"llvm.x86.avx512.psrav.q.512\" => \"__builtin_ia32_psrav8di_mask\",\n+        \"llvm.x86.avx512.psrav.q.256\" => \"__builtin_ia32_psravq256_mask\",\n+        \"llvm.x86.avx512.psrav.q.128\" => \"__builtin_ia32_psravq128_mask\",\n+        \"llvm.x86.avx512.psllv.d.512\" => \"__builtin_ia32_psllv16si_mask\",\n+        \"llvm.x86.avx512.psrlv.d.512\" => \"__builtin_ia32_psrlv16si_mask\",\n+        \"llvm.x86.avx512.psllv.q.512\" => \"__builtin_ia32_psllv8di_mask\",\n+        \"llvm.x86.avx512.psrlv.q.512\" => \"__builtin_ia32_psrlv8di_mask\",\n+        \"llvm.x86.avx512.permvar.si.512\" => \"__builtin_ia32_permvarsi512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.ps.512\" => \"__builtin_ia32_vpermilvarps512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.pd.512\" => \"__builtin_ia32_vpermilvarpd512_mask\",\n+        \"llvm.x86.avx512.permvar.di.512\" => \"__builtin_ia32_permvardi512_mask\",\n+        \"llvm.x86.avx512.permvar.di.256\" => \"__builtin_ia32_permvardi256_mask\",\n+        \"llvm.x86.avx512.permvar.sf.512\" => \"__builtin_ia32_permvarsf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.512\" => \"__builtin_ia32_permvardf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.256\" => \"__builtin_ia32_permvardf256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.512\" => \"__builtin_ia32_vpermi2vard512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.256\" => \"__builtin_ia32_vpermi2vard256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.128\" => \"__builtin_ia32_vpermi2vard128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.512\" => \"__builtin_ia32_vpermi2varq512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.256\" => \"__builtin_ia32_vpermi2varq256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.128\" => \"__builtin_ia32_vpermi2varq128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.512\" => \"__builtin_ia32_vpermi2varps512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.256\" => \"__builtin_ia32_vpermi2varps256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.128\" => \"__builtin_ia32_vpermi2varps128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.512\" => \"__builtin_ia32_vpermi2varpd512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.256\" => \"__builtin_ia32_vpermi2varpd256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.128\" => \"__builtin_ia32_vpermi2varpd128_mask\",\n+        \"llvm.x86.avx512.mask.add.ss.round\" => \"__builtin_ia32_addss_mask_round\",\n+        \"llvm.x86.avx512.mask.add.sd.round\" => \"__builtin_ia32_addsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.ss.round\" => \"__builtin_ia32_subss_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.sd.round\" => \"__builtin_ia32_subsd_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.ss.round\" => \"__builtin_ia32_mulss_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.sd.round\" => \"__builtin_ia32_mulsd_mask_round\",\n+        \"llvm.x86.avx512.mask.div.ss.round\" => \"__builtin_ia32_divss_mask_round\",\n+        \"llvm.x86.avx512.mask.div.sd.round\" => \"__builtin_ia32_divsd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtss2sd.round\" => \"__builtin_ia32_cvtss2sd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtsd2ss.round\" => \"__builtin_ia32_cvtsd2ss_mask_round\",\n+        \"llvm.x86.avx512.mask.range.ss\" => \"__builtin_ia32_rangess128_mask_round\",\n+        \"llvm.x86.avx512.mask.range.sd\" => \"__builtin_ia32_rangesd128_mask_round\",\n+        \"llvm.x86.avx512.rcp28.ss\" => \"__builtin_ia32_rcp28ss_mask_round\",\n+        \"llvm.x86.avx512.rcp28.sd\" => \"__builtin_ia32_rcp28sd_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.ss\" => \"__builtin_ia32_rsqrt28ss_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.sd\" => \"__builtin_ia32_rsqrt28sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.add.sh.round\" => \"__builtin_ia32_addsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.div.sh.round\" => \"__builtin_ia32_divsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.getmant.sh\" => \"__builtin_ia32_getmantsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.max.sh.round\" => \"__builtin_ia32_maxsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.min.sh.round\" => \"__builtin_ia32_minsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.mul.sh.round\" => \"__builtin_ia32_mulsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.rndscale.sh\" => \"__builtin_ia32_rndscalesh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.scalef.sh\" => \"__builtin_ia32_scalefsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.sub.sh.round\" => \"__builtin_ia32_subsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsd2sh.round\" => \"__builtin_ia32_vcvtsd2sh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2sd.round\" => \"__builtin_ia32_vcvtsh2sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2ss.round\" => \"__builtin_ia32_vcvtsh2ss_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtss2sh.round\" => \"__builtin_ia32_vcvtss2sh_mask_round\",\n+        \"llvm.x86.aesni.aesenc.256\" => \"__builtin_ia32_vaesenc_v32qi\",\n+        \"llvm.x86.aesni.aesenclast.256\" => \"__builtin_ia32_vaesenclast_v32qi\",\n+        \"llvm.x86.aesni.aesdec.256\" => \"__builtin_ia32_vaesdec_v32qi\",\n+        \"llvm.x86.aesni.aesdeclast.256\" => \"__builtin_ia32_vaesdeclast_v32qi\",\n+        \"llvm.x86.aesni.aesenc.512\" => \"__builtin_ia32_vaesenc_v64qi\",\n+        \"llvm.x86.aesni.aesenclast.512\" => \"__builtin_ia32_vaesenclast_v64qi\",\n+        \"llvm.x86.aesni.aesdec.512\" => \"__builtin_ia32_vaesdec_v64qi\",\n+        \"llvm.x86.aesni.aesdeclast.512\" => \"__builtin_ia32_vaesdeclast_v64qi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.128\" => \"__builtin_ia32_cvtne2ps2bf16_v8bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.256\" => \"__builtin_ia32_cvtne2ps2bf16_v16bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.512\" => \"__builtin_ia32_cvtne2ps2bf16_v32bf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.256\" => \"__builtin_ia32_cvtneps2bf16_v8sf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.512\" => \"__builtin_ia32_cvtneps2bf16_v16sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.128\" => \"__builtin_ia32_dpbf16ps_v4sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.256\" => \"__builtin_ia32_dpbf16ps_v8sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.512\" => \"__builtin_ia32_dpbf16ps_v16sf\",\n+        \"llvm.x86.pclmulqdq.512\" => \"__builtin_ia32_vpclmulqdq_v8di\",\n+        \"llvm.x86.pclmulqdq.256\" => \"__builtin_ia32_vpclmulqdq_v4di\",\n+        \"llvm.x86.avx512.pmulhu.w.512\" => \"__builtin_ia32_pmulhuw512_mask\",\n+        \"llvm.x86.avx512.pmulh.w.512\" => \"__builtin_ia32_pmulhw512_mask\",\n+        \"llvm.x86.avx512.pmul.hr.sw.512\" => \"__builtin_ia32_pmulhrsw512_mask\",\n+        \"llvm.x86.avx512.pmaddw.d.512\" => \"__builtin_ia32_pmaddwd512_mask\",\n+        \"llvm.x86.avx512.pmaddubs.w.512\" => \"__builtin_ia32_pmaddubsw512_mask\",\n+        \"llvm.x86.avx512.packssdw.512\" => \"__builtin_ia32_packssdw512_mask\",\n+        \"llvm.x86.avx512.packsswb.512\" => \"__builtin_ia32_packsswb512_mask\",\n+        \"llvm.x86.avx512.packusdw.512\" => \"__builtin_ia32_packusdw512_mask\",\n+        \"llvm.x86.avx512.packuswb.512\" => \"__builtin_ia32_packuswb512_mask\",\n+        \"llvm.x86.avx512.pavg.w.512\" => \"__builtin_ia32_pavgw512_mask\",\n+        \"llvm.x86.avx512.pavg.b.512\" => \"__builtin_ia32_pavgb512_mask\",\n+        \"llvm.x86.avx512.psll.w.512\" => \"__builtin_ia32_psllw512_mask\",\n+        \"llvm.x86.avx512.pslli.w.512\" => \"__builtin_ia32_psllwi512_mask\",\n+        \"llvm.x86.avx512.psllv.w.512\" => \"__builtin_ia32_psllv32hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.256\" => \"__builtin_ia32_psllv16hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.128\" => \"__builtin_ia32_psllv8hi_mask\",\n+        \"llvm.x86.avx512.psrl.w.512\" => \"__builtin_ia32_psrlw512_mask\",\n+        \"llvm.x86.avx512.psrli.w.512\" => \"__builtin_ia32_psrlwi512_mask\",\n+        \"llvm.x86.avx512.psrlv.w.512\" => \"__builtin_ia32_psrlv32hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.256\" => \"__builtin_ia32_psrlv16hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.128\" => \"__builtin_ia32_psrlv8hi_mask\",\n+        \"llvm.x86.avx512.psra.w.512\" => \"__builtin_ia32_psraw512_mask\",\n+        \"llvm.x86.avx512.psrai.w.512\" => \"__builtin_ia32_psrawi512_mask\",\n+        \"llvm.x86.avx512.psrav.w.512\" => \"__builtin_ia32_psrav32hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.256\" => \"__builtin_ia32_psrav16hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.128\" => \"__builtin_ia32_psrav8hi_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.512\" => \"__builtin_ia32_vpermt2varhi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.256\" => \"__builtin_ia32_vpermt2varhi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.128\" => \"__builtin_ia32_vpermt2varhi128_mask\",\n+        \"llvm.x86.avx512.permvar.hi.512\" => \"__builtin_ia32_permvarhi512_mask\",\n+        \"llvm.x86.avx512.permvar.hi.256\" => \"__builtin_ia32_permvarhi256_mask\",\n+        \"llvm.x86.avx512.permvar.hi.128\" => \"__builtin_ia32_permvarhi128_mask\",\n+        \"llvm.x86.avx512.pshuf.b.512\" => \"__builtin_ia32_pshufb512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.512\" => \"__builtin_ia32_dbpsadbw512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.256\" => \"__builtin_ia32_dbpsadbw256_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.128\" => \"__builtin_ia32_dbpsadbw128_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.512\" => \"__builtin_ia32_vpmadd52huq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.512\" => \"__builtin_ia32_vpmadd52luq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.256\" => \"__builtin_ia32_vpmadd52huq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.256\" => \"__builtin_ia32_vpmadd52luq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.128\" => \"__builtin_ia32_vpmadd52huq128_mask\",\n+        \"llvm.x86.avx512.vpdpwssd.512\" => \"__builtin_ia32_vpdpwssd_v16si\",\n+        \"llvm.x86.avx512.vpdpwssd.256\" => \"__builtin_ia32_vpdpwssd_v8si\",\n+        \"llvm.x86.avx512.vpdpwssd.128\" => \"__builtin_ia32_vpdpwssd_v4si\",\n+        \"llvm.x86.avx512.vpdpwssds.512\" => \"__builtin_ia32_vpdpwssds_v16si\",\n+        \"llvm.x86.avx512.vpdpwssds.256\" => \"__builtin_ia32_vpdpwssds_v8si\",\n+        \"llvm.x86.avx512.vpdpwssds.128\" => \"__builtin_ia32_vpdpwssds_v4si\",\n+        \"llvm.x86.avx512.vpdpbusd.512\" => \"__builtin_ia32_vpdpbusd_v16si\",\n+        \"llvm.x86.avx512.vpdpbusd.256\" => \"__builtin_ia32_vpdpbusd_v8si\",\n+        \"llvm.x86.avx512.vpdpbusd.128\" => \"__builtin_ia32_vpdpbusd_v4si\",\n+        \"llvm.x86.avx512.vpdpbusds.512\" => \"__builtin_ia32_vpdpbusds_v16si\",\n+        \"llvm.x86.avx512.vpdpbusds.256\" => \"__builtin_ia32_vpdpbusds_v8si\",\n+        \"llvm.x86.avx512.vpdpbusds.128\" => \"__builtin_ia32_vpdpbusds_v4si\",\n+\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "94dc8c9e93b0de1b4ce3145503b4c8b33a7b6c1c", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 152, "deletions": 6, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,22 +1,33 @@\n pub mod llvm;\n mod simd;\n \n+#[cfg(feature=\"master\")]\n+use std::iter;\n+\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::traits::{DerivedTypeMethods, MiscMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n use rustc_span::{Span, Symbol, symbol::kw, sym};\n use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::PanicStrategy;\n+#[cfg(feature=\"master\")]\n+use rustc_target::spec::abi::Abi;\n \n use crate::abi::GccType;\n+#[cfg(feature=\"master\")]\n+use crate::abi::FnAbiGccExt;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n@@ -68,6 +79,8 @@ fn get_simple_intrinsic<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, name: Symbol) ->\n         sym::nearbyintf64 => \"nearbyint\",\n         sym::roundf32 => \"roundf\",\n         sym::roundf64 => \"round\",\n+        sym::roundevenf32 => \"roundevenf\",\n+        sym::roundevenf64 => \"roundeven\",\n         sym::abort => \"abort\",\n         _ => return None,\n     };\n@@ -91,7 +104,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let name = tcx.item_name(def_id);\n         let name_str = name.as_str();\n \n-        let llret_ty = self.layout_of(ret_ty).gcc_type(self, true);\n+        let llret_ty = self.layout_of(ret_ty).gcc_type(self);\n         let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n \n         let simple = get_simple_intrinsic(self, name);\n@@ -404,7 +417,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n-        self.layout.gcc_type(cx, true)\n+        self.layout.gcc_type(cx)\n     }\n \n     /// Stores a direct/indirect value described by this ArgAbi into a\n@@ -1120,10 +1133,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n }\n \n-fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n-    // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n-    if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n-        // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n+fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n@@ -1134,6 +1145,141 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n         unimplemented!();\n     }\n     else {\n+        #[cfg(feature=\"master\")]\n+        codegen_gnu_try(bx, try_func, data, _catch_func, dest);\n+        #[cfg(not(feature=\"master\"))]\n         unimplemented!();\n     }\n }\n+\n+// Definition of the standard `try` function for Rust using the GNU-like model\n+// of exceptions (e.g., the normal semantics of LLVM's `landingpad` and `invoke`\n+// instructions).\n+//\n+// This codegen is a little surprising because we always call a shim\n+// function instead of inlining the call to `invoke` manually here. This is done\n+// because in LLVM we're only allowed to have one personality per function\n+// definition. The call to the `try` intrinsic is being inlined into the\n+// function calling it, and that function may already have other personality\n+// functions in play. By calling a shim we're guaranteed that our shim will have\n+// the right personality function.\n+#[cfg(feature=\"master\")]\n+fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>, data: RValue<'gcc>, catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    let cx: &CodegenCx<'gcc, '_> = bx.cx;\n+    let (llty, func) = get_rust_try_fn(cx, &mut |mut bx| {\n+        // Codegens the shims described above:\n+        //\n+        //   bx:\n+        //      invoke %try_func(%data) normal %normal unwind %catch\n+        //\n+        //   normal:\n+        //      ret 0\n+        //\n+        //   catch:\n+        //      (%ptr, _) = landingpad\n+        //      call %catch_func(%data, %ptr)\n+        //      ret 1\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n+\n+        let func = bx.current_func();\n+        let try_func = func.get_param(0).to_rvalue();\n+        let data = func.get_param(1).to_rvalue();\n+        let catch_func = func.get_param(2).to_rvalue();\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+\n+        let current_block = bx.block.clone();\n+\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n+\n+        // Type indicator for the exception being thrown.\n+        //\n+        // The value is a pointer to the exception object\n+        // being thrown.\n+        bx.switch_to_block(catch);\n+        bx.set_personality_fn(bx.eh_personality());\n+\n+        let eh_pointer_builtin = bx.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n+        let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n+        bx.ret(bx.const_i32(1));\n+\n+        // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n+        // generate a try/catch.\n+        // FIXME(antoyo): add a check in the libgccjit API to prevent this.\n+        bx.switch_to_block(current_block);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n+    });\n+\n+    let func = unsafe { std::mem::transmute(func) };\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = bx.call(llty, None, func, &[try_func, data, catch_func], None);\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n+    bx.store(ret, dest, i32_align);\n+}\n+\n+\n+// Helper function used to get a handle to the `__rust_try` function used to\n+// catch exceptions.\n+//\n+// This function is only generated once and is then cached.\n+#[cfg(feature=\"master\")]\n+fn get_rust_try_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    if let Some(llfn) = cx.rust_try_fn.get() {\n+        return llfn;\n+    }\n+\n+    // Define the type up front for the signature of the rust_try function.\n+    let tcx = cx.tcx;\n+    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        iter::once(i8p),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        [i8p, i8p].iter().cloned(),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        [try_fn_ty, i8p, catch_fn_ty],\n+        tcx.types.i32,\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n+    cx.rust_try_fn.set(Some(rust_try));\n+    rust_try\n+}\n+\n+// Helper function to give a Block to a closure to codegen a shim function.\n+// This is currently primarily used for the `try` intrinsic functions above.\n+#[cfg(feature=\"master\")]\n+fn gen_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, name: &str, rust_fn_sig: ty::PolyFnSig<'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n+    let (typ, _, _, _) = fn_abi.gcc_type(cx);\n+    // FIXME(eddyb) find a nicer way to do this.\n+    cx.linkage.set(FunctionType::Internal);\n+    let func = cx.declare_fn(name, fn_abi);\n+    let func_val = unsafe { std::mem::transmute(func) };\n+    cx.set_frame_pointer_type(func_val);\n+    cx.apply_target_cpu_attr(func_val);\n+    let block = Builder::append_block(cx, func_val, \"entry-block\");\n+    let bx = Builder::build(cx, block);\n+    codegen(bx);\n+    (typ, func)\n+}"}, {"sha": "b59c3a64f5728bdd2ad61fd728ccc64b4e9709b9", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 582, "deletions": 257, "changes": 839, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,8 +1,13 @@\n-use std::cmp::Ordering;\n+#[cfg(feature=\"master\")]\n+use gccjit::{ComparisonOp, UnaryOp};\n+use gccjit::ToRValue;\n+use gccjit::{BinaryOp, RValue, Type};\n \n-use gccjit::{BinaryOp, RValue, ToRValue, Type};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::TypeKind;\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::errors::ExpectedPointerMutability;\n+use rustc_codegen_ssa::errors::InvalidMonomorphization;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -14,18 +19,21 @@ use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+#[cfg(feature=\"master\")]\n+use crate::context::CodegenCx;\n+#[cfg(feature=\"master\")]\n+use crate::errors::{InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationInsertedType};\n use crate::errors::{\n-    InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationExpectedSimd,\n-    InvalidMonomorphizationInsertedType, InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationInvalidBitmask,\n     InvalidMonomorphizationInvalidFloatVector, InvalidMonomorphizationMaskType,\n     InvalidMonomorphizationMismatchedLengths, InvalidMonomorphizationNotFloat,\n     InvalidMonomorphizationReturnElement, InvalidMonomorphizationReturnIntegerType,\n     InvalidMonomorphizationReturnLength, InvalidMonomorphizationReturnLengthInputType,\n     InvalidMonomorphizationReturnType, InvalidMonomorphizationSimdShuffle,\n-    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedCast,\n-    InvalidMonomorphizationUnsupportedElement, InvalidMonomorphizationUnsupportedOperation,\n+    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationUnsupportedOperation,\n };\n-use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n     bx: &mut Builder<'a, 'gcc, 'tcx>,\n@@ -105,14 +113,19 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let arg1_vector_type = arg1_type.unqualified().dyncast_vector().expect(\"vector type\");\n         let arg1_element_type = arg1_vector_type.get_element_type();\n \n+        // NOTE: since the arguments can be vectors of floats, make sure the mask is a vector of\n+        // integer.\n+        let mask_element_type = bx.type_ix(arg1_element_type.get_size() as u64 * 8);\n+        let vector_mask_type = bx.context.new_vector_type(mask_element_type, arg1_vector_type.get_num_units() as u64);\n+\n         let mut elements = vec![];\n         let one = bx.context.new_rvalue_one(mask.get_type());\n         for _ in 0..len {\n-            let element = bx.context.new_cast(None, mask & one, arg1_element_type);\n+            let element = bx.context.new_cast(None, mask & one, mask_element_type);\n             elements.push(element);\n             mask = mask >> one;\n         }\n-        let vector_mask = bx.context.new_rvalue_from_vector(None, arg1_type, &elements);\n+        let vector_mask = bx.context.new_rvalue_from_vector(None, vector_mask_type, &elements);\n \n         return Ok(bx.vector_select(vector_mask, arg1, args[2].immediate()));\n     }\n@@ -210,48 +223,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n         let value = args[2].immediate();\n-        // TODO(antoyo): use a recursive unqualified() here.\n-        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n-        let element_type = vector_type.get_element_type();\n-        // NOTE: we cannot cast to an array and assign to its element here because the value might\n-        // not be an l-value. So, call a builtin to set the element.\n-        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n-        // TODO(antoyo): don't use target specific builtins here.\n-        let func_name = match in_len {\n-            2 => {\n-                if element_type == bx.i64_type {\n-                    \"__builtin_ia32_vec_set_v2di\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            4 => {\n-                if element_type == bx.i32_type {\n-                    \"__builtin_ia32_vec_set_v4si\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            8 => {\n-                if element_type == bx.i16_type {\n-                    \"__builtin_ia32_vec_set_v8hi\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            _ => unimplemented!(\"Len: {}\", in_len),\n-        };\n-        let builtin = bx.context.get_target_builtin_function(func_name);\n-        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n-        let result = bx.context.new_call(\n-            None,\n-            builtin,\n-            &[vector, value, bx.context.new_cast(None, index, bx.int_type)],\n-        );\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+        let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n+        bx.llbb().add_assignment(None, variable, vector);\n+        let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n+        // TODO(antoyo): if simd_insert is constant, use BIT_REF.\n+        bx.llbb().add_assignment(None, lvalue, value);\n+        return Ok(variable.to_rvalue());\n     }\n \n     #[cfg(feature = \"master\")]\n@@ -280,7 +257,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n \n-    if name == sym::simd_cast {\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_cast || name == sym::simd_as {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n@@ -301,125 +279,40 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n \n         enum Style {\n             Float,\n-            Int(/* is signed? */ bool),\n+            Int,\n             Unsupported,\n         }\n \n-        let (in_style, in_width) = match in_elem.kind() {\n-            // vectors of pointer-sized integers should've been\n-            // disallowed before here, so this unwrap is safe.\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-        let (out_style, out_width) = match out_elem.kind() {\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-\n-        let extend = |in_type, out_type| {\n-            let vector_type = bx.context.new_vector_type(out_type, 8);\n-            let vector = args[0].immediate();\n-            let array_type = bx.context.new_array_type(None, in_type, 8);\n-            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n-            let array = bx.context.new_bitcast(None, vector, array_type);\n-\n-            let cast_vec_element = |index| {\n-                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n-                bx.context.new_cast(\n-                    None,\n-                    bx.context.new_array_access(None, array, index).to_rvalue(),\n-                    out_type,\n-                )\n+        let in_style =\n+            match in_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n             };\n \n-            bx.context.new_rvalue_from_vector(\n-                None,\n-                vector_type,\n-                &[\n-                    cast_vec_element(0),\n-                    cast_vec_element(1),\n-                    cast_vec_element(2),\n-                    cast_vec_element(3),\n-                    cast_vec_element(4),\n-                    cast_vec_element(5),\n-                    cast_vec_element(6),\n-                    cast_vec_element(7),\n-                ],\n-            )\n-        };\n+        let out_style =\n+            match out_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n+            };\n \n         match (in_style, out_style) {\n-            (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n-                    Ordering::Equal => args[0].immediate(),\n-                    Ordering::Less => {\n-                        if in_is_signed {\n-                            match (in_width, out_width) {\n-                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n-                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n-                                // we can generate a call to it.\n-                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n-                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n-                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n-                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n-                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n-                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        } else {\n-                            match (in_width, out_width) {\n-                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n-                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n-                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n-                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n-                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n-                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        }\n+            (Style::Unsupported, Style::Unsupported) => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedCast {\n+                        span,\n+                        name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty,\n+                        out_elem\n                     }\n-                });\n-            }\n-            (Style::Int(_), Style::Float) => {\n-                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n-                // doing like __builtin_convertvector?\n-                // Or maybe provide convert_vector as an API since it might not easy to get the\n-                // types of internal functions.\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Int(_)) => {\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Float) => {\n-                unimplemented!();\n-            }\n-            _ => { /* Unsupported. Fallthrough. */ }\n+                );\n+            },\n+            _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n         }\n-        return_error!(InvalidMonomorphizationUnsupportedCast {\n-            span,\n-            name,\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n-        });\n     }\n \n     macro_rules! arith_binary {\n@@ -436,6 +329,71 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         }\n     }\n \n+    if name == sym::simd_bitmask {\n+        // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n+\n+        let vector = args[0].immediate();\n+        let vector_type = vector.get_type().dyncast_vector().expect(\"vector type\");\n+        let elem_type = vector_type.get_element_type();\n+\n+        let expected_int_bits = in_len.max(8);\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+        // FIXME(antoyo): that's not going to work for masks bigger than 128 bits.\n+        let result_type = bx.type_ix(expected_int_bits);\n+        let mut result = bx.context.new_rvalue_zero(result_type);\n+\n+        let elem_size = elem_type.get_size() * 8;\n+        let sign_shift = bx.context.new_rvalue_from_int(elem_type, elem_size as i32 - 1);\n+        let one = bx.context.new_rvalue_one(elem_type);\n+\n+        let mut shift = 0;\n+        for i in 0..in_len {\n+            let elem = bx.extract_element(vector, bx.context.new_rvalue_from_int(bx.int_type, i as i32));\n+            let shifted = elem >> sign_shift;\n+            let masked = shifted & one;\n+            result = result | (bx.context.new_cast(None, masked, result_type) << bx.context.new_rvalue_from_int(result_type, shift));\n+            shift += 1;\n+        }\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(result);\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_target_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array length:\n+                let ze = bx.zext(result, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            }),\n+        }\n+    }\n+\n     fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n         name: Symbol,\n         in_elem: Ty<'_>,\n@@ -451,55 +409,66 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 return Err(());\n             }};\n         }\n-        let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n-            let elem_ty = bx.cx.type_float_from_ty(*f);\n-            match f.bit_width() {\n-                32 => (\"f32\", elem_ty),\n-                64 => (\"f64\", elem_ty),\n-                _ => {\n-                    return_error!(InvalidMonomorphizationInvalidFloatVector {\n-                        span,\n-                        name,\n-                        elem_ty: f.name_str(),\n-                        vec_ty: in_ty\n-                    });\n+        let (elem_ty_str, elem_ty) =\n+            if let ty::Float(f) = in_elem.kind() {\n+                let elem_ty = bx.cx.type_float_from_ty(*f);\n+                match f.bit_width() {\n+                    32 => (\"f\", elem_ty),\n+                    64 => (\"\", elem_ty),\n+                    _ => {\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n+                    }\n                 }\n             }\n-        } else {\n-            return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n-        };\n+            else {\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n+            };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n \n-        let (intr_name, fn_ty) = match name {\n-            sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)), // TODO(antoyo): pand with 170141183420855150465331762880109871103\n-            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n-            sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-            _ => return_error!(InvalidMonomorphizationUnrecognized { span, name }),\n-        };\n-        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n-        let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n-        let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n-        let c = bx.call(\n-            fn_ty,\n-            None,\n-            function,\n-            &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n-            None,\n-        );\n+        let intr_name =\n+            match name {\n+                sym::simd_ceil => \"ceil\",\n+                sym::simd_fabs => \"fabs\", // TODO(antoyo): pand with 170141183420855150465331762880109871103\n+                sym::simd_fcos => \"cos\",\n+                sym::simd_fexp2 => \"exp2\",\n+                sym::simd_fexp => \"exp\",\n+                sym::simd_flog10 => \"log10\",\n+                sym::simd_flog2 => \"log2\",\n+                sym::simd_flog => \"log\",\n+                sym::simd_floor => \"floor\",\n+                sym::simd_fma => \"fma\",\n+                sym::simd_fpowi => \"__builtin_powi\",\n+                sym::simd_fpow => \"pow\",\n+                sym::simd_fsin => \"sin\",\n+                sym::simd_fsqrt => \"sqrt\",\n+                sym::simd_round => \"round\",\n+                sym::simd_trunc => \"trunc\",\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n+            };\n+        let builtin_name = format!(\"{}{}\", intr_name, elem_ty_str);\n+        let funcs = bx.cx.functions.borrow();\n+        let function = funcs.get(&builtin_name).unwrap_or_else(|| panic!(\"unable to find builtin function {}\", builtin_name));\n+\n+        // TODO(antoyo): add platform-specific behavior here for architectures that have these\n+        // intrinsics as instructions (for instance, gpus)\n+        let mut vector_elements = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.ulong_type, i as i64);\n+            // we have to treat fpowi specially, since fpowi's second argument is always an i32\n+            let arguments = if name == sym::simd_fpowi {\n+                vec![\n+                    bx.extract_element(args[0].immediate(), index).to_rvalue(),\n+                    args[1].immediate(),\n+                ]\n+            } else {\n+                args.iter()\n+                    .map(|arg| bx.extract_element(arg.immediate(), index).to_rvalue())\n+                    .collect()\n+            };\n+            vector_elements.push(bx.context.new_call(None, *function, &arguments));\n+        }\n+        let c = bx.context.new_rvalue_from_vector(None, vec_ty, &vector_elements);\n         Ok(c)\n     }\n \n@@ -525,6 +494,297 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn vector_ty<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, elem_ty: Ty<'tcx>, vec_len: u64) -> Type<'gcc> {\n+        // FIXME: use cx.layout_of(ty).llvm_type() ?\n+        let elem_ty = match *elem_ty.kind() {\n+            ty::Int(v) => cx.type_int_from_ty(v),\n+            ty::Uint(v) => cx.type_uint_from_ty(v),\n+            ty::Float(v) => cx.type_float_from_ty(v),\n+            _ => unreachable!(),\n+        };\n+        cx.type_vector(elem_ty, vec_len)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn gather<'a, 'gcc, 'tcx>(default: RValue<'gcc>, pointers: RValue<'gcc>, mask: RValue<'gcc>, pointer_count: usize, bx: &mut Builder<'a, 'gcc, 'tcx>, in_len: u64, underlying_ty: Ty<'tcx>, invert: bool) -> RValue<'gcc> {\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        let mut values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            let value = ptr.dereference(None).to_rvalue();\n+            values.push(value);\n+        }\n+\n+        let vector = bx.context.new_rvalue_from_vector(None, vector_type, &values);\n+\n+        let mut mask_types = vec![];\n+        let mut mask_values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            mask_types.push(bx.context.new_field(None, bx.i32_type, \"m\"));\n+            let mask_value = bx.context.new_vector_access(None, mask, index).to_rvalue();\n+            let masked = bx.context.new_rvalue_from_int(bx.i32_type, in_len as i32) & mask_value;\n+            let value = index + masked;\n+            mask_values.push(value);\n+        }\n+        let mask_type = bx.context.new_struct_type(None, \"mask_type\", &mask_types);\n+        let mask = bx.context.new_struct_constructor(None, mask_type.as_type(), None, &mask_values);\n+\n+        if invert {\n+            bx.shuffle_vector(vector, default, mask)\n+        }\n+        else {\n+            bx.shuffle_vector(default, vector, mask)\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_gather {\n+        // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n+        //             mask: <N x i{M}>) -> <N x T>\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(ret_ty, \"return\");\n+\n+        // Of the same length:\n+        let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n+        );\n+        require!(\n+            in_len == out_len2,\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n+        );\n+\n+        // The return type must match the first argument type\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem => (ptr_count(element_ty1), non_ptr(element_ty1)),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n+                );\n+            }\n+        }\n+\n+        return Ok(gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, false));\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_scatter {\n+        // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n+        //             mask: <N x i{M}>) -> ()\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+\n+        // Of the same length:\n+        let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == element_len1,\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n+        );\n+        require!(\n+            in_len == element_len2,\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+                (ptr_count(element_ty1), non_ptr(element_ty1))\n+            }\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n+                );\n+            }\n+        }\n+\n+        let result = gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, true);\n+\n+        let pointers = args[1].immediate();\n+\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_int(bx.int_type, i as i32);\n+            let value = bx.context.new_vector_access(None, result, index);\n+\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            bx.llbb().add_assignment(None, ptr.dereference(None), value);\n+        }\n+\n+        return Ok(bx.context.new_rvalue_zero(bx.i32_type));\n+    }\n+\n     arith_binary! {\n         simd_add: Uint, Int => add, Float => fadd;\n         simd_sub: Uint, Int => sub, Float => fsub;\n@@ -536,6 +796,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         simd_and: Uint, Int => and;\n         simd_or: Uint, Int => or; // FIXME(antoyo): calling `or` might not work on vectors.\n         simd_xor: Uint, Int => xor;\n+        simd_fmin: Float => vector_fmin;\n+        simd_fmax: Float => vector_fmax;\n     }\n \n     macro_rules! arith_unary {\n@@ -562,10 +824,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let rhs = args[1].immediate();\n         let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n-            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n-            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n-            _ => {\n+        let (signed, elem_width, elem_ty) =\n+            match *in_elem.kind() {\n+                ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n+                ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n+                _ => {\n                 return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n                     span,\n                     name,\n@@ -574,33 +837,78 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 });\n             }\n         };\n-        let builtin_name = match (signed, is_add, in_len, elem_width) {\n-            (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n-            (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n-            (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n-            (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n-            (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n-            (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n-            (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n-            (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n-            _ => unimplemented!(\n-                \"signed: {}, is_add: {}, in_len: {}, elem_width: {}\",\n-                signed,\n-                is_add,\n-                in_len,\n-                elem_width\n-            ),\n-        };\n-        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n-\n-        let func = bx.context.get_target_builtin_function(builtin_name);\n-        let param1_type = func.get_param(0).to_rvalue().get_type();\n-        let param2_type = func.get_param(1).to_rvalue().get_type();\n-        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n-        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n-        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+\n+        let result =\n+            match (signed, is_add) {\n+                (false, true) => {\n+                    let res = lhs + rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n+                    res | cmp\n+                },\n+                (true, true) => {\n+                    // Algorithm from: https://codereview.stackexchange.com/questions/115869/saturated-signed-addition\n+                    // TODO(antoyo): improve using conditional operators if possible.\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                },\n+                (false, false) => {\n+                    let res = lhs - rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n+                    res & cmp\n+                },\n+                (true, false) => {\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): this uses the same algorithm from saturating add, but add the\n+                    // negative of the right operand. Find a proper subtraction algorithm.\n+                    let rhs = bx.context.new_unary_op(None, UnaryOp::Minus, arg_type, rhs);\n+\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                }\n+            };\n+\n+        return Ok(result);\n     }\n \n     macro_rules! arith_red {\n@@ -650,33 +958,50 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         add,\n         0.0 // TODO: Use this argument.\n     );\n-    arith_red!(simd_reduce_mul_unordered: BinaryOp::Mult, vector_reduce_fmul_fast, false, mul, 1.0);\n+    arith_red!(\n+        simd_reduce_mul_unordered: BinaryOp::Mult,\n+        vector_reduce_fmul_fast,\n+        false,\n+        mul,\n+        1.0\n+    );\n+    arith_red!(\n+        simd_reduce_add_ordered: BinaryOp::Plus,\n+        vector_reduce_fadd,\n+        true,\n+        add,\n+        0.0\n+    );\n+    arith_red!(\n+        simd_reduce_mul_ordered: BinaryOp::Mult,\n+        vector_reduce_fmul,\n+        true,\n+        mul,\n+        1.0\n+    );\n+\n \n     macro_rules! minmax_red {\n-        ($name:ident: $reduction:ident) => {\n+        ($name:ident: $int_red:ident, $float_red:ident) => {\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n                     InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n-                    ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n-                        Ok(bx.$reduction(args[0].immediate()))\n-                    }\n-                    _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n-                        span,\n-                        name,\n-                        in_ty,\n-                        elem_ty: in_elem,\n-                        ret_ty\n-                    }),\n+                    ty::Int(_) | ty::Uint(_) => Ok(bx.$int_red(args[0].immediate())),\n+                    ty::Float(_) => Ok(bx.$float_red(args[0].immediate())),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n     }\n \n-    minmax_red!(simd_reduce_min: vector_reduce_min);\n-    minmax_red!(simd_reduce_max: vector_reduce_max);\n+    minmax_red!(simd_reduce_min: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max: vector_reduce_max, vector_reduce_fmax);\n+    // TODO(sadlerap): revisit these intrinsics to generate more optimal reductions\n+    minmax_red!(simd_reduce_min_nanless: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max_nanless: vector_reduce_max, vector_reduce_fmax);\n \n     macro_rules! bitwise_red {\n         ($name:ident : $op:expr, $boolean:expr) => {\n@@ -699,15 +1024,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                         }),\n                     }\n \n-                    // boolean reductions operate on vectors of i1s:\n-                    let i1 = bx.type_i1();\n-                    let i1xn = bx.type_vector(i1, in_len as u64);\n-                    bx.trunc(args[0].immediate(), i1xn)\n+                    args[0].immediate()\n                 };\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.vector_reduce_op(input, $op);\n-                        Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n+                        Ok(if !$boolean { r } else { bx.icmp(IntPredicate::IntNE, r, bx.context.new_rvalue_zero(r.get_type())) })\n                     }\n                     _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n                         span,\n@@ -723,6 +1045,9 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n \n     bitwise_red!(simd_reduce_and: BinaryOp::BitwiseAnd, false);\n     bitwise_red!(simd_reduce_or: BinaryOp::BitwiseOr, false);\n+    bitwise_red!(simd_reduce_xor: BinaryOp::BitwiseXor, false);\n+    bitwise_red!(simd_reduce_all: BinaryOp::BitwiseAnd, true);\n+    bitwise_red!(simd_reduce_any: BinaryOp::BitwiseOr, true);\n \n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "1b7feb5f8a18e77edd9edd8f6c74b5bc619b205b", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,7 +1,7 @@\n /*\n  * TODO(antoyo): implement equality in libgccjit based on https://zpz.github.io/blog/overloading-equality-operator-in-cpp-class-hierarchy/ (for type equality?)\n  * TODO(antoyo): support #[inline] attributes.\n- * TODO(antoyo): support LTO (gcc's equivalent to Thin LTO is enabled by -fwhopr: https://stackoverflow.com/questions/64954525/does-gcc-have-thin-lto).\n+ * TODO(antoyo): support LTO (gcc's equivalent to Full LTO is -flto -flto-partition=one \u2014 https://documentation.suse.com/sbp/all/html/SBP-GCC-10/index.html).\n  *\n  * TODO(antoyo): remove the patches.\n  */\n@@ -23,6 +23,7 @@\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n+extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n@@ -43,6 +44,7 @@ mod abi;\n mod allocator;\n mod archive;\n mod asm;\n+mod attributes;\n mod back;\n mod base;\n mod builder;\n@@ -314,9 +316,12 @@ pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n         .filter(|_feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n             // Probably using the equivalent of __builtin_cpu_supports.\n+            // TODO(antoyo): maybe use whatever outputs the following command:\n+            // gcc -march=native -Q --help=target\n             #[cfg(feature=\"master\")]\n             {\n-                _feature.contains(\"sse\") || _feature.contains(\"avx\")\n+                // NOTE: the CPU in the CI doesn't support sse4a, so disable it to make the stdarch tests pass in the CI.\n+                (_feature.contains(\"sse\") || _feature.contains(\"avx\")) && !_feature.contains(\"avx512\") && !_feature.contains(\"sse4a\")\n             }\n             #[cfg(not(feature=\"master\"))]\n             {"}, {"sha": "c1f6340866cacc5edc6e13276f47f2fa4be140cd", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,38 +1,66 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::{VarAttribute, FnAttribute};\n use rustc_codegen_ssa::traits::PreDefineMethods;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n-use rustc_span::def_id::DefId;\n \n+use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n+        #[cfg(feature=\"master\")]\n+        global.add_attribute(VarAttribute::Visibility(base::visibility_to_gcc(visibility)));\n \n-        // TODO(antoyo): set linkage and visibility.\n+        // TODO(antoyo): set linkage.\n         self.instances.borrow_mut().insert(instance, global);\n     }\n \n-    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         assert!(!instance.substs.needs_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        let _decl = self.declare_fn(symbol_name, &fn_abi);\n+        let decl = self.declare_fn(symbol_name, &fn_abi);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n+        attributes::from_fn_attrs(self, decl, instance);\n+\n+        // If we're compiling the compiler-builtins crate, e.g., the equivalent of\n+        // compiler-rt, then we want to implicitly compile everything with hidden\n+        // visibility as we're going to link this object all over the place but\n+        // don't want the symbols to get exported.\n+        if linkage != Linkage::Internal\n+            && linkage != Linkage::Private\n+            && self.tcx.is_compiler_builtins(LOCAL_CRATE)\n+        {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+        }\n+        else {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(base::visibility_to_gcc(visibility)));\n+        }\n+\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above.\n+\n+        self.functions.borrow_mut().insert(symbol_name.to_string(), decl);\n+        self.function_instances.borrow_mut().insert(instance, unsafe { std::mem::transmute(decl) });\n     }\n }"}, {"sha": "daa661f35c4c108767b9bfde5476544944506b47", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::TryInto;\n-\n use gccjit::{RValue, Struct, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, TypeMembershipMethods};\n use rustc_codegen_ssa::common::TypeKind;\n@@ -202,23 +200,17 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         value.get_type()\n     }\n \n-    fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n-        if let Some(struct_type) = ty.is_struct() {\n+    fn type_array(&self, ty: Type<'gcc>, len: u64) -> Type<'gcc> {\n+        // TODO: remove this as well?\n+        /*if let Some(struct_type) = ty.is_struct() {\n             if struct_type.get_field_count() == 0 {\n                 // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n                 // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n                 // zero for ZSTs.\n                 // FIXME(antoyo): fix gccjit API.\n                 len = 0;\n             }\n-        }\n-\n-        // NOTE: see note above. Some other test uses usize::MAX.\n-        if len == u64::MAX {\n-            len = 0;\n-        }\n-\n-        let len: i32 = len.try_into().expect(\"array len\");\n+        }*/\n \n         self.context.new_array_type(None, ty, len)\n     }\n@@ -247,10 +239,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn type_named_struct(&self, name: &str) -> Struct<'gcc> {\n         self.context.new_opaque_struct_type(None, name)\n     }\n-\n-    pub fn type_bool(&self) -> Type<'gcc> {\n-        self.context.new_type::<bool>()\n-    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {\n@@ -273,7 +261,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n         result.push(cx.type_padding_filler(padding, padding_align));\n \n-        result.push(field.gcc_type(cx, !field.ty.is_any_ptr())); // FIXME(antoyo): might need to check if the type is inside another, like Box<Type>.\n+        result.push(field.gcc_type(cx));\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }"}, {"sha": "5df8c1a209db2e8f9301edb488379200f66832a9", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n+use rustc_target::abi::{self, Abi, Align, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n \n use crate::abi::{FnAbiGccExt, GccType};\n@@ -50,11 +50,25 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n+        self.layout_of(ty).align.abi\n+    }\n+}\n+\n+fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         Abi::Vector { ref element, count } => {\n             let element = layout.scalar_gcc_type_at(cx, element, Size::ZERO);\n+            let element =\n+                // NOTE: gcc doesn't allow pointer types in vectors.\n+                if element.get_pointee().is_some() {\n+                    cx.usize_type\n+                }\n+                else {\n+                    element\n+                };\n             return cx.context.new_vector_type(element, count);\n         },\n         Abi::ScalarPair(..) => {\n@@ -114,7 +128,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n                 },\n             }\n         }\n-        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx, true), count),\n+        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx), count),\n         FieldsShape::Arbitrary { .. } =>\n             match name {\n                 None => {\n@@ -133,7 +147,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n pub trait LayoutGccExt<'tcx> {\n     fn is_gcc_immediate(&self) -> bool;\n     fn is_gcc_scalar_pair(&self) -> bool;\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc>;\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn immediate_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc>;\n     fn scalar_pair_element_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, index: usize, immediate: bool) -> Type<'gcc>;\n@@ -168,8 +182,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    //TODO(antoyo): do we still need the set_fields parameter?\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc> {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n         if let Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -179,10 +192,10 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             let ty =\n                 match *self.ty.kind() {\n                     ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx, set_fields))\n+                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx))\n                     }\n                     ty::Adt(def, _) if def.is_box() => {\n-                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx, true))\n+                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx))\n                     }\n                     ty::FnPtr(sig) => cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty())),\n                     _ => self.scalar_gcc_type_at(cx, scalar, Size::ZERO),\n@@ -199,13 +212,6 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             };\n         let cached_type = cx.types.borrow().get(&(self.ty, variant_index)).cloned();\n         if let Some(ty) = cached_type {\n-            let type_to_set_fields = cx.types_with_fields_to_set.borrow_mut().remove(&ty);\n-            if let Some((struct_type, layout)) = type_to_set_fields {\n-                // Since we might be trying to generate a type containing another type which is not\n-                // completely generated yet, we deferred setting the fields until now.\n-                let (fields, packed) = struct_fields(cx, layout);\n-                cx.set_struct_body(struct_type, &fields, packed);\n-            }\n             return ty;\n         }\n \n@@ -222,17 +228,17 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 if let Some(v) = variant_index {\n                     layout = layout.for_variant(cx, v);\n                 }\n-                layout.gcc_type(cx, true)\n+                layout.gcc_type(cx)\n             }\n             else {\n                 uncached_gcc_type(cx, *self, &mut defer)\n             };\n \n         cx.types.borrow_mut().insert((self.ty, variant_index), ty);\n \n-        if let Some((ty, layout)) = defer {\n+        if let Some((deferred_ty, layout)) = defer {\n             let (fields, packed) = struct_fields(cx, layout);\n-            cx.set_struct_body(ty, &fields, packed);\n+            cx.set_struct_body(deferred_ty, &fields, packed);\n         }\n \n         ty\n@@ -244,7 +250,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 return cx.type_i1();\n             }\n         }\n-        self.gcc_type(cx, true)\n+        self.gcc_type(cx)\n     }\n \n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n@@ -273,7 +279,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n-                return self.field(cx, index).gcc_type(cx, true);\n+                return self.field(cx, index).gcc_type(cx);\n             }\n             // only wide pointer boxes are handled as pointers\n             // thin pointer boxes with scalar allocators are handled by the general logic below\n@@ -343,7 +349,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n \n impl<'gcc, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {\n-        layout.gcc_type(self, true)\n+        layout.gcc_type(self)\n     }\n \n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {"}, {"sha": "6139892aefca7d2d42bf35aad2bb9de2726e7f40", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 184, "deletions": 56, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -17,17 +17,20 @@ export LIBRARY_PATH=\"$GCC_PATH\"\n flags=\n gcc_master_branch=1\n channel=\"debug\"\n-func=all\n+funcs=()\n build_only=0\n+nb_parts=0\n+current_part=0\n \n while [[ $# -gt 0 ]]; do\n     case $1 in\n         --release)\n             codegen_channel=release\n+            channel=\"release\"\n             shift\n             ;;\n         --release-sysroot)\n-            sysroot_channel=release\n+            sysroot_channel=\"--release\"\n             shift\n             ;;\n         --no-default-features)\n@@ -40,43 +43,83 @@ while [[ $# -gt 0 ]]; do\n             flags=\"$flags --features $1\"\n             shift\n             ;;\n-        --release)\n-            channel=\"release\"\n+        \"--test-rustc\")\n+            funcs+=(test_rustc)\n             shift\n             ;;\n-        \"--test-rustc\")\n-            func=test_rustc\n+        \"--test-successful-rustc\")\n+            funcs+=(test_successful_rustc)\n+            shift\n+            ;;\n+        \"--test-failing-rustc\")\n+            funcs+=(test_failing_rustc)\n             shift\n             ;;\n \n         \"--test-libcore\")\n-            func=test_libcore\n+            funcs+=(test_libcore)\n             shift\n             ;;\n \n         \"--clean-ui-tests\")\n-            func=clean_ui_tests\n+            funcs+=(clean_ui_tests)\n+            shift\n+            ;;\n+        \"--clean\")\n+            funcs+=(clean)\n             shift\n             ;;\n \n         \"--std-tests\")\n-            func=std_tests\n+            funcs+=(std_tests)\n+            shift\n+            ;;\n+\n+        \"--asm-tests\")\n+            funcs+=(asm_tests)\n             shift\n             ;;\n \n         \"--extended-tests\")\n-            func=extended_sysroot_tests\n+            funcs+=(extended_sysroot_tests)\n+            shift\n+            ;;\n+        \"--extended-rand-tests\")\n+            funcs+=(extended_rand_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-example-tests\")\n+            funcs+=(extended_regex_example_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-tests\")\n+            funcs+=(extended_regex_tests)\n+            shift\n+            ;;\n+\n+        \"--mini-tests\")\n+            funcs+=(mini_tests)\n             shift\n             ;;\n \n         \"--build-sysroot\")\n-            func=build_sysroot\n+            funcs+=(build_sysroot)\n             shift\n             ;;\n         \"--build\")\n             build_only=1\n             shift\n             ;;\n+        \"--nb-parts\")\n+            shift\n+            nb_parts=$1\n+            shift\n+            ;;\n+        \"--current-part\")\n+            shift\n+            current_part=$1\n+            shift\n+            ;;\n         *)\n             echo \"Unknown option $1\"\n             exit 1\n@@ -87,14 +130,14 @@ done\n if [[ $channel == \"release\" ]]; then\n     export CHANNEL='release'\n     CARGO_INCREMENTAL=1 cargo rustc --release $flags\n-    shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n     cargo rustc $flags\n fi\n \n if (( $build_only == 1 )); then\n+    echo \"Since it's 'build-only', exiting...\"\n     exit\n fi\n \n@@ -119,7 +162,7 @@ function mini_tests() {\n \n function build_sysroot() {\n     echo \"[BUILD] sysroot\"\n-    time ./build_sysroot/build_sysroot.sh\n+    time ./build_sysroot/build_sysroot.sh $sysroot_channel\n }\n \n function std_tests() {\n@@ -148,17 +191,57 @@ function std_tests() {\n     $RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n \n     echo \"[AOT] subslice-patterns-const-eval\"\n-    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n \n     echo \"[AOT] track-caller-attribute\"\n-    $RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/track-caller-attribute.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/track-caller-attribute\n \n     echo \"[BUILD] mod_bench\"\n     $RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n }\n \n+function setup_rustc() {\n+    rust_toolchain=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n+\n+    git clone https://github.com/rust-lang/rust.git || true\n+    cd rust\n+    git fetch\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n+    export RUSTFLAGS=\n+\n+    rm config.toml || true\n+\n+    cat > config.toml <<EOF\n+[rust]\n+codegen-backends = []\n+deny-warnings = false\n+\n+[build]\n+cargo = \"$(which cargo)\"\n+local-rebuild = true\n+rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n+\n+[target.x86_64-unknown-linux-gnu]\n+llvm-filecheck = \"`which FileCheck-10 || which FileCheck-11 || which FileCheck-12 || which FileCheck-13 || which FileCheck-14`\"\n+\n+[llvm]\n+download-ci-llvm = false\n+EOF\n+\n+    rustc -V | cut -d' ' -f3 | tr -d '('\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n+}\n+\n+function asm_tests() {\n+    setup_rustc\n+\n+    echo \"[TEST] rustc test suite\"\n+    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/assembly/asm --rustc-args \"$RUSTC_ARGS\"\n+}\n+\n # FIXME(antoyo): linker gives multiple definitions error on Linux\n #echo \"[BUILD] sysroot in release mode\"\n #./build_sysroot/build_sysroot.sh --release\n@@ -187,7 +270,7 @@ function test_libcore() {\n #echo \"[BENCH RUN] mod_bench\"\n #hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n-function extended_sysroot_tests() {\n+function extended_rand_tests() {\n     if (( $gcc_master_branch == 0 )); then\n         return\n     fi\n@@ -197,17 +280,12 @@ function extended_sysroot_tests() {\n     echo \"[TEST] rust-random/rand\"\n     ../cargo.sh test --workspace\n     popd\n+}\n \n-    #pushd simple-raytracer\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n-    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n-    #\"../cargo.sh build\"\n-\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-    #cp ./target/debug/main ./raytracer_cg_gcc\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n-    #popd\n+function extended_regex_example_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n     pushd regex\n     echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n@@ -219,73 +297,123 @@ function extended_sysroot_tests() {\n         | ../cargo.sh run --example shootout-regex-dna \\\n         | grep -v \"Spawned thread\" > res.txt\n     diff -u res.txt examples/regexdna-output.txt\n+    popd\n+}\n+\n+function extended_regex_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n+    pushd regex\n     echo \"[TEST] rust-lang/regex tests\"\n+    export CG_RUSTFLAGS=\"--cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n     ../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n     popd\n }\n \n-function test_rustc() {\n-    echo\n-    echo \"[TEST] rust-lang/rust\"\n-\n-    rust_toolchain=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n-\n-    git clone https://github.com/rust-lang/rust.git || true\n-    cd rust\n-    git fetch\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n-    export RUSTFLAGS=\n-\n-    git apply ../rustc_patches/compile_test.patch || true\n+function extended_sysroot_tests() {\n+    #pushd simple-raytracer\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n+    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n+    #\"../cargo.sh build\"\n \n-    rm config.toml || true\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    #cp ./target/debug/main ./raytracer_cg_gcc\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n+    #popd\n \n-    cat > config.toml <<EOF\n-[rust]\n-codegen-backends = []\n-deny-warnings = false\n+    extended_rand_tests\n+    extended_regex_example_tests\n+    extended_regex_tests\n+}\n \n-[build]\n-cargo = \"$(which cargo)\"\n-local-rebuild = true\n-rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n-EOF\n+function test_rustc() {\n+    echo\n+    echo \"[TEST] rust-lang/rust\"\n \n-    rustc -V | cut -d' ' -f3 | tr -d '('\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n+    setup_rustc\n \n     for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" tests/ui); do\n       rm $test\n     done\n \n     git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r tests/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n-    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" tests/ui); do\n+    rm -r tests/ui/{abi*,extern/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n+    rm tests/ui/mir/mir_heavy_promoted.rs # this tests is oom-killed in the CI.\n+    for test in $(rg --files-with-matches \"thread|lto\" tests/ui); do\n       rm $test\n     done\n+    git checkout tests/ui/lto/auxiliary/dylib.rs\n     git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n     git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n+    git checkout tests/ui/macros/rfc-2011-nicer-assert-messages/auxiliary/common.rs\n+\n+    RUSTC_ARGS=\"$TEST_FLAGS -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot\"\n+\n+    if [ $# -eq 0 ]; then\n+        # No argument supplied to the function. Doing nothing.\n+        echo \"No argument provided. Keeping all UI tests\"\n+    elif [ $1 = \"0\" ]; then\n+        # Removing the failing tests.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' rm\n+    else\n+        # Removing all tests.\n+        find tests/ui -type f -name '*.rs' -not -path '*/auxiliary/*' -delete\n+        # Putting back only the failing ones.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' git checkout --\n+    fi\n \n-    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    if [ $nb_parts -gt 0 ]; then\n+        echo \"Splitting ui_test into $nb_parts parts (and running part $current_part)\"\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" > ui_tests\n+        # To ensure it'll be always the same sub files, we sort the content.\n+        sort ui_tests -o ui_tests\n+        count=$((`wc -l < ui_tests` / $nb_parts))\n+        # We increment the number of tests by one because if this is an odd number, we would skip\n+        # one test.\n+        count=$((count + 1))\n+        split -d -l $count -a 1 ui_tests ui_tests.split\n+        # Removing all tests.\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" -delete\n+        # Putting back only the ones we want to test.\n+        xargs -a \"ui_tests.split$current_part\" -d'\\n' git checkout --\n+    fi\n \n     echo \"[TEST] rustc test suite\"\n     COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/ui/ --rustc-args \"$RUSTC_ARGS\"\n }\n \n+function test_failing_rustc() {\n+    test_rustc \"1\"\n+}\n+\n+function test_successful_rustc() {\n+    test_rustc \"0\"\n+}\n+\n function clean_ui_tests() {\n-    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -exec rm -rf {} \\;\n+    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -delete\n }\n \n function all() {\n     clean\n     mini_tests\n     build_sysroot\n     std_tests\n+    #asm_tests\n     test_libcore\n     extended_sysroot_tests\n     test_rustc\n }\n \n-$func\n+if [ ${#funcs[@]} -eq 0 ]; then\n+    echo \"No command passed, running '--all'...\"\n+    all\n+else\n+    for t in ${funcs[@]}; do\n+        $t\n+    done\n+fi"}, {"sha": "06de26f7efc9f8c8497e79e4d24e911ed6dbe80c", "filename": "compiler/rustc_codegen_gcc/tests/lang_tests_common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -46,11 +46,15 @@ pub fn main_inner(profile: Profile) {\n                 &format!(\"-Zcodegen-backend={}/target/debug/librustc_codegen_gcc.so\", current_dir),\n                 \"--sysroot\", &format!(\"{}/build_sysroot/sysroot/\", current_dir),\n                 \"-Zno-parallel-llvm\",\n-                \"-C\", \"panic=abort\",\n                 \"-C\", \"link-arg=-lc\",\n                 \"-o\", exe.to_str().expect(\"to_str\"),\n                 path.to_str().expect(\"to_str\"),\n             ]);\n+            if let Some(flags) = option_env!(\"TEST_FLAGS\") {\n+                for flag in flags.split_whitespace() {\n+                    compiler.arg(&flag);\n+                }\n+            }\n             match profile {\n                 Profile::Debug => {}\n                 Profile::Release => {"}, {"sha": "25041d93e748a6feb2acbd7c14aff9011bb1e7a4", "filename": "compiler/rustc_codegen_gcc/tests/run/abort1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "e7443c8dbe5b2f5574784f0b85ea54644904e082", "filename": "compiler/rustc_codegen_gcc/tests/run/abort2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "49b28d98f2fecaa4d0bb0f6935cf460ca441f012", "filename": "compiler/rustc_codegen_gcc/tests/run/array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -79,7 +79,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -105,6 +105,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "427c1a250339749f41627b0d6e7dd40f6886cf7a", "filename": "compiler/rustc_codegen_gcc/tests/run/assign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -57,14 +57,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "8daa681abf7dac19c0838b9717890a8c1119094e", "filename": "compiler/rustc_codegen_gcc/tests/run/closure.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -97,10 +97,14 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -114,7 +118,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -123,7 +127,7 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n@@ -177,7 +181,7 @@ impl Add for isize {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();"}, {"sha": "b7a13081deae0df4babd931ae1f968ff3cbfe05e", "filename": "compiler/rustc_codegen_gcc/tests/run/condition.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -82,7 +82,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -108,6 +108,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "8a196f774c82bcd6cb5930cee4a823124513db07", "filename": "compiler/rustc_codegen_gcc/tests/run/fun_ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -76,7 +76,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "bfe73c38435a31ec68ccdeff5bd861b392cec3d7", "filename": "compiler/rustc_codegen_gcc/tests/run/int.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -3,22 +3,14 @@\n // Run-time:\n //   status: 0\n \n-#![feature(const_black_box, core_intrinsics, start)]\n-\n-#![no_std]\n-\n-#[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    core::intrinsics::abort();\n-}\n+#![feature(const_black_box)]\n \n /*\n  * Code\n  */\n \n-#[start]\n-fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    use core::hint::black_box;\n+fn main() {\n+    use std::hint::black_box;\n \n     macro_rules! check {\n         ($ty:ty, $expr:expr) => {\n@@ -335,6 +327,4 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n         const VAL5: T = 73236519889708027473620326106273939584_i128;\n         check_ops128!();\n     }\n-\n-    0\n }"}, {"sha": "c3fcb3c0a2a069ac97b36066be3f3abe9fab5f0d", "filename": "compiler/rustc_codegen_gcc/tests/run/int_overflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -55,14 +55,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         // Panicking is expected iff overflow checking is enabled.\n         #[cfg(debug_assertions)]"}, {"sha": "2a2ea8b8bf0ab0152cb618ce84fd1f3194292891", "filename": "compiler/rustc_codegen_gcc/tests/run/mut_ref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -59,14 +59,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "67b9f241dbbb3d06bbba2c3571824a56d54de35a", "filename": "compiler/rustc_codegen_gcc/tests/run/operations.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -65,14 +65,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "da8a8295d564cc31012f6baac799d5180ac644a4", "filename": "compiler/rustc_codegen_gcc/tests/run/ptr_cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -76,7 +76,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "96f1c4792e58fa199f794bfd9f6565691bc301da", "filename": "compiler/rustc_codegen_gcc/tests/run/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -102,6 +102,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "19201f1df2667ca9a6e21450690415865b85f63e", "filename": "compiler/rustc_codegen_gcc/tests/run/static.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -45,6 +45,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "c09fb3c759f3b10189ac2780096a6731d43ad974", "filename": "compiler/rustc_codegen_gcc/tools/check_intrinsics_duplicates.py", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,67 @@\n+import sys\n+\n+\n+def check_duplicates():\n+    auto_content = \"\"\n+    manual_content = \"\"\n+\n+    with open(\"src/intrinsic/llvm.rs\", \"r\", encoding=\"utf8\") as f:\n+        manual_content = f.read()\n+    with open(\"src/intrinsic/archs.rs\", \"r\", encoding=\"utf8\") as f:\n+        auto_content = f.read()\n+\n+    intrinsics_map = {}\n+    for line in auto_content.splitlines():\n+        line = line.strip()\n+        if not line.startswith('\"'):\n+            continue\n+        parts = line.split('\"')\n+        if len(parts) != 5:\n+            continue\n+        intrinsics_map[parts[1]] = parts[3]\n+\n+    if len(intrinsics_map) == 0:\n+        print(\"No intrinsics found in auto code... Aborting.\")\n+        return 1\n+    print(\"Found {} intrinsics in auto code\".format(len(intrinsics_map)))\n+    errors = []\n+    lines = manual_content.splitlines()\n+    pos = 0\n+    found = 0\n+    while pos < len(lines):\n+        line = lines[pos].strip()\n+        # This is our marker.\n+        if line == \"let gcc_name = match name {\":\n+            while pos < len(lines):\n+                line = lines[pos].strip()\n+                pos += 1\n+                if line == \"};\":\n+                    # We're done!\n+                    if found == 0:\n+                        print(\"No intrinsics found in manual code even though we found the \"\n+                            \"marker... Aborting...\")\n+                        return 1\n+                    for error in errors:\n+                        print(\"ERROR => {}\".format(error))\n+                    return 1 if len(errors) != 0 else 0\n+                parts = line.split('\"')\n+                if len(parts) != 5:\n+                    continue\n+                found += 1\n+                if parts[1] in intrinsics_map:\n+                    if parts[3] != intrinsics_map[parts[1]]:\n+                        print(\"Same intrinsics (`{}` at line {}) but different GCC \"\n+                            \"translations: `{}` != `{}`\".format(\n+                                parts[1], pos, intrinsics_map[parts[1]], parts[3]))\n+                    else:\n+                        errors.append(\"Duplicated intrinsics: `{}` at line {}. Please remove it \"\n+                            \" from manual code\".format(parts[1], pos))\n+            # Weird but whatever...\n+            return 1 if len(errors) != 0 else 0\n+        pos += 1\n+    print(\"No intrinsics found in manual code... Aborting\")\n+    return 1\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(check_duplicates())"}, {"sha": "6188924b0d50a52ef4ac4ca30ee28ebd02eac216", "filename": "compiler/rustc_codegen_gcc/tools/generate_intrinsics.py", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -13,7 +13,7 @@ def run_command(command, cwd=None):\n         sys.exit(1)\n \n \n-def clone_repository(repo_name, path, repo_url, sub_path=None):\n+def clone_repository(repo_name, path, repo_url, sub_paths=None):\n     if os.path.exists(path):\n         while True:\n             choice = input(\"There is already a `{}` folder, do you want to update it? [y/N]\".format(path))\n@@ -27,69 +27,58 @@ def clone_repository(repo_name, path, repo_url, sub_path=None):\n             else:\n                 print(\"Didn't understand answer...\")\n     print(\"Cloning {} repository...\".format(repo_name))\n-    if sub_path is None:\n+    if sub_paths is None:\n         run_command([\"git\", \"clone\", repo_url, \"--depth\", \"1\", path])\n     else:\n         run_command([\"git\", \"clone\", repo_url, \"--filter=tree:0\", \"--no-checkout\", path])\n         run_command([\"git\", \"sparse-checkout\", \"init\"], cwd=path)\n-        run_command([\"git\", \"sparse-checkout\", \"set\", \"add\", sub_path], cwd=path)\n+        run_command([\"git\", \"sparse-checkout\", \"set\", *sub_paths], cwd=path)\n         run_command([\"git\", \"checkout\"], cwd=path)\n \n \n def append_intrinsic(array, intrinsic_name, translation):\n     array.append((intrinsic_name, translation))\n \n \n-def extract_instrinsics(intrinsics, file):\n-    print(\"Extracting intrinsics from `{}`...\".format(file))\n-    with open(file, \"r\", encoding=\"utf8\") as f:\n-        content = f.read()\n+def convert_to_string(content):\n+    if content.__class__.__name__ == 'bytes':\n+        return content.decode('utf-8')\n+    return content\n \n-    lines = content.splitlines()\n+\n+def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n+    p = subprocess.Popen(\n+        [\"llvm-tblgen\", \"llvm/IR/Intrinsics.td\"],\n+        cwd=os.path.join(llvm_path, \"llvm/include\"),\n+        stdout=subprocess.PIPE)\n+    output, err = p.communicate()\n+    lines = convert_to_string(output).splitlines()\n     pos = 0\n-    current_arch = None\n     while pos < len(lines):\n-        line = lines[pos].strip()\n-        if line.startswith(\"let TargetPrefix =\"):\n-            current_arch = line.split('\"')[1].strip()\n-            if len(current_arch) == 0:\n-                current_arch = None\n-        elif current_arch is None:\n-            pass\n-        elif line == \"}\":\n-            current_arch = None\n-        elif line.startswith(\"def \"):\n-            content = \"\"\n-            while not content.endswith(\";\") and not content.endswith(\"}\") and pos < len(lines):\n-                line = lines[pos].split(\" // \")[0].strip()\n-                content += line\n-                pos += 1\n-            entries = re.findall('GCCBuiltin<\"(\\\\w+)\">', content)\n-            if len(entries) > 0:\n-                intrinsic = content.split(\"def \")[1].strip().split(\":\")[0].strip()\n-                intrinsic = intrinsic.split(\"_\")\n-                if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n-                    continue\n-                intrinsic[0] = \"llvm\"\n-                intrinsic = \".\".join(intrinsic)\n-                if current_arch not in intrinsics:\n-                    intrinsics[current_arch] = []\n-                for entry in entries:\n-                    append_intrinsic(intrinsics[current_arch], intrinsic, entry)\n+        line = lines[pos]\n+        if not line.startswith(\"def \"):\n+            pos += 1\n             continue\n-        pos += 1\n-        continue\n-    print(\"Done!\")\n-\n-\n-def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n-    files = []\n-    intrinsics_path = os.path.join(llvm_path, \"llvm/include/llvm/IR\")\n-    for (dirpath, dirnames, filenames) in walk(intrinsics_path):\n-        files.extend([os.path.join(intrinsics_path, f) for f in filenames if f.endswith(\".td\")])\n-\n-    for file in files:\n-        extract_instrinsics(intrinsics, file)\n+        intrinsic = line.split(\" \")[1].strip()\n+        content = line\n+        while pos < len(lines):\n+            line = lines[pos].split(\" // \")[0].strip()\n+            content += line\n+            pos += 1\n+            if line == \"}\":\n+                break\n+        entries = re.findall('string ClangBuiltinName = \"(\\\\w+)\";', content)\n+        current_arch = re.findall('string TargetPrefix = \"(\\\\w+)\";', content)\n+        if len(entries) == 1 and len(current_arch) == 1:\n+            current_arch = current_arch[0]\n+            intrinsic = intrinsic.split(\"_\")\n+            if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n+                continue\n+            intrinsic[0] = \"llvm\"\n+            intrinsic = \".\".join(intrinsic)\n+            if current_arch not in intrinsics:\n+                intrinsics[current_arch] = []\n+            append_intrinsic(intrinsics[current_arch], intrinsic, entries[0])\n \n \n def append_translation(json_data, p, array):\n@@ -193,6 +182,8 @@ def update_intrinsics(llvm_path, llvmint, llvmint2):\n             for entry in intrinsics[arch]:\n                 if entry[2] == True: # if it is a duplicate\n                     out.write('    // [DUPLICATE]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+                elif \"_round_mask\" in entry[1]:\n+                    out.write('    // [INVALID CONVERSION]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n                 else:\n                     out.write('    \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n         out.write('    _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\\n')\n@@ -219,7 +210,7 @@ def main():\n         \"llvm-project\",\n         llvm_path,\n         \"https://github.com/llvm/llvm-project\",\n-        sub_path=\"llvm/include/llvm/IR\",\n+        sub_paths=[\"llvm/include/llvm/IR\", \"llvm/include/llvm/CodeGen/\"],\n     )\n     clone_repository(\n         \"llvmint\","}, {"sha": "f0d729d4779c6dd5bd6c858327f72313b468d885", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -735,9 +735,13 @@ impl<'ll> CodegenCx<'ll, '_> {\n \n         ifn!(\"llvm.copysign.f32\", fn(t_f32, t_f32) -> t_f32);\n         ifn!(\"llvm.copysign.f64\", fn(t_f64, t_f64) -> t_f64);\n+\n         ifn!(\"llvm.round.f32\", fn(t_f32) -> t_f32);\n         ifn!(\"llvm.round.f64\", fn(t_f64) -> t_f64);\n \n+        ifn!(\"llvm.roundeven.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.roundeven.f64\", fn(t_f64) -> t_f64);\n+\n         ifn!(\"llvm.rint.f32\", fn(t_f32) -> t_f32);\n         ifn!(\"llvm.rint.f64\", fn(t_f64) -> t_f64);\n         ifn!(\"llvm.nearbyint.f32\", fn(t_f32) -> t_f32);"}, {"sha": "9c921989ca9a76b6089acae0513fec75e0d82a1d", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -71,6 +71,8 @@ fn get_simple_intrinsic<'ll>(\n         sym::roundf32 => \"llvm.round.f32\",\n         sym::roundf64 => \"llvm.round.f64\",\n         sym::ptr_mask => \"llvm.ptrmask\",\n+        sym::roundevenf32 => \"llvm.roundeven.f32\",\n+        sym::roundevenf64 => \"llvm.roundeven.f64\",\n         _ => return None,\n     };\n     Some(cx.get_intrinsic(llvm_name))"}, {"sha": "509cb0fef565e167775be25218723d632e960a29", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -640,9 +640,6 @@ extern \"C\" {\n pub struct Builder<'a>(InvariantOpaque<'a>);\n #[repr(C)]\n pub struct PassManager<'a>(InvariantOpaque<'a>);\n-extern \"C\" {\n-    pub type PassManagerBuilder;\n-}\n extern \"C\" {\n     pub type Pass;\n }"}, {"sha": "1a94d4ab8b1d8226c21e8587bc91341a6325d93d", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -58,7 +58,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n \n     let mut reachable_non_generics: DefIdMap<_> = tcx\n         .reachable_set(())\n-        .iter()\n+        .items()\n         .filter_map(|&def_id| {\n             // We want to ignore some FFI functions that are not exposed from\n             // this crate. Reachable FFI functions can be lumped into two\n@@ -136,7 +136,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             };\n             (def_id.to_def_id(), info)\n         })\n-        .collect();\n+        .into();\n \n     if let Some(id) = tcx.proc_macro_decls_static(()) {\n         reachable_non_generics.insert("}, {"sha": "b75ced4a6dd3229133fc25f31e747b9a03b180dc", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -61,25 +61,29 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n \n     let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n \n-    // In some cases, attribute are only valid on functions, but it's the `check_attr`\n-    // pass that check that they aren't used anywhere else, rather this module.\n-    // In these cases, we bail from performing further checks that are only meaningful for\n-    // functions (such as calling `fn_sig`, which ICEs if given a non-function). We also\n-    // report a delayed bug, just in case `check_attr` isn't doing its job.\n-    let validate_fn_only_attr = |attr_sp| -> bool {\n-        let def_kind = tcx.def_kind(did);\n-        if let DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..) = def_kind {\n-            true\n-        } else {\n-            tcx.sess.delay_span_bug(attr_sp, \"this attribute can only be applied to functions\");\n-            false\n-        }\n-    };\n-\n     let mut inline_span = None;\n     let mut link_ordinal_span = None;\n     let mut no_sanitize_span = None;\n+\n     for attr in attrs.iter() {\n+        // In some cases, attribute are only valid on functions, but it's the `check_attr`\n+        // pass that check that they aren't used anywhere else, rather this module.\n+        // In these cases, we bail from performing further checks that are only meaningful for\n+        // functions (such as calling `fn_sig`, which ICEs if given a non-function). We also\n+        // report a delayed bug, just in case `check_attr` isn't doing its job.\n+        let fn_sig = || {\n+            use DefKind::*;\n+\n+            let def_kind = tcx.def_kind(did);\n+            if let Fn | AssocFn | Variant | Ctor(..) = def_kind {\n+                Some(tcx.fn_sig(did))\n+            } else {\n+                tcx.sess\n+                    .delay_span_bug(attr.span, \"this attribute can only be applied to functions\");\n+                None\n+            }\n+        };\n+\n         if attr.has_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n         } else if attr.has_name(sym::rustc_allocator) {\n@@ -169,8 +173,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                 }\n             }\n         } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if validate_fn_only_attr(attr.span)\n-                && !matches!(tcx.fn_sig(did).skip_binder().abi(), abi::Abi::C { .. })\n+            if let Some(fn_sig) = fn_sig()\n+                && !matches!(fn_sig.skip_binder().abi(), abi::Abi::C { .. })\n             {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -189,8 +193,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n         } else if attr.has_name(sym::track_caller) {\n             if !tcx.is_closure(did.to_def_id())\n-                && validate_fn_only_attr(attr.span)\n-                && tcx.fn_sig(did).skip_binder().abi() != abi::Abi::Rust\n+                && let Some(fn_sig) = fn_sig()\n+                && fn_sig.skip_binder().abi() != abi::Abi::Rust\n             {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n@@ -222,7 +226,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             }\n         } else if attr.has_name(sym::target_feature) {\n             if !tcx.is_closure(did.to_def_id())\n-                && tcx.fn_sig(did).skip_binder().unsafety() == hir::Unsafety::Normal\n+                && let Some(fn_sig) = fn_sig()\n+                && fn_sig.skip_binder().unsafety() == hir::Unsafety::Normal\n             {\n                 if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n                     // The `#[target_feature]` attribute is allowed on"}, {"sha": "0ce395e912db319c32386b93b0b1854f16dcc7f9", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -295,7 +295,6 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n                 TerminatorKind::Call { cleanup: unwind, .. }\n                 | TerminatorKind::InlineAsm { cleanup: unwind, .. }\n                 | TerminatorKind::Assert { cleanup: unwind, .. }\n-                | TerminatorKind::DropAndReplace { unwind, .. }\n                 | TerminatorKind::Drop { unwind, .. } => {\n                     if let Some(unwind) = unwind {\n                         debug!("}, {"sha": "71c71d59b7ab9ec5b3b44f03624880eb3b1b6ce0", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1305,10 +1305,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mergeable_succ(),\n                 ),\n \n-            mir::TerminatorKind::DropAndReplace { .. } => {\n-                bug!(\"undesugared DropAndReplace in codegen: {:?}\", terminator);\n-            }\n-\n             mir::TerminatorKind::Call {\n                 ref func,\n                 ref args,"}, {"sha": "41f585f7fccc1613db7492bda5c93108752f463f", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -92,6 +92,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)\n             | mir::StatementKind::ConstEvalCounter\n+            | mir::StatementKind::PlaceMention(..)\n             | mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "576e90ae66b76c470244843c264b689a07eb985c", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast::ast;\n use rustc_attr::InstructionSetAttr;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Applicability;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -418,7 +418,7 @@ pub fn from_target_feature(\n \n /// Computes the set of target features used in a function for the purposes of\n /// inline assembly.\n-fn asm_target_features(tcx: TyCtxt<'_>, did: DefId) -> &FxHashSet<Symbol> {\n+fn asm_target_features(tcx: TyCtxt<'_>, did: DefId) -> &FxIndexSet<Symbol> {\n     let mut target_features = tcx.sess.unstable_target_features.clone();\n     if tcx.def_kind(did).has_codegen_attrs() {\n         let attrs = tcx.codegen_fn_attrs(did);"}, {"sha": "6dcfdc14790886a9fb82bbdd893af6ded76e9c86", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,15 +1,22 @@\n+use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n \n-/// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n-pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n+/// Whether the `def_id` is an unstable const fn and what feature gate(s) are necessary to enable\n+/// it.\n+pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<(Symbol, Option<Symbol>)> {\n     if tcx.is_const_fn_raw(def_id) {\n         let const_stab = tcx.lookup_const_stability(def_id)?;\n-        if const_stab.is_const_unstable() { Some(const_stab.feature) } else { None }\n+        match const_stab.level {\n+            attr::StabilityLevel::Unstable { implied_by, .. } => {\n+                Some((const_stab.feature, implied_by))\n+            }\n+            attr::StabilityLevel::Stable { .. } => None,\n+        }\n     } else {\n         None\n     }"}, {"sha": "c14152a916a2937d8cf7c9e484f2ecffe6e3f449", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -67,12 +67,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Pointer(PointerCast::ReifyFnPointer) => {\n+                // All reifications must be monomorphic, bail out otherwise.\n+                ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n+\n                 // The src operand does not matter, just its type\n                 match *src.layout.ty.kind() {\n                     ty::FnDef(def_id, substs) => {\n-                        // All reifications must be monomorphic, bail out otherwise.\n-                        ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n-\n                         let instance = ty::Instance::resolve_for_fn_ptr(\n                             *self.tcx,\n                             self.param_env,\n@@ -100,12 +100,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Pointer(PointerCast::ClosureFnPointer(_)) => {\n+                // All reifications must be monomorphic, bail out otherwise.\n+                ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n+\n                 // The src operand does not matter, just its type\n                 match *src.layout.ty.kind() {\n                     ty::Closure(def_id, substs) => {\n-                        // All reifications must be monomorphic, bail out otherwise.\n-                        ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n-\n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,\n                             def_id,\n@@ -359,8 +359,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n                 self.write_immediate(val, dest)\n             }\n-\n             _ => {\n+                // Do not ICE if we are not monomorphic enough.\n+                ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n+                ensure_monomorphic_enough(*self.tcx, cast_ty)?;\n+\n                 span_bug!(\n                     self.cur_span(),\n                     \"invalid pointer unsizing {:?} -> {:?}\",\n@@ -404,12 +407,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 Ok(())\n             }\n-            _ => span_bug!(\n-                self.cur_span(),\n-                \"unsize_into: invalid conversion: {:?} -> {:?}\",\n-                src.layout,\n-                dest.layout\n-            ),\n+            _ => {\n+                // Do not ICE if we are not monomorphic enough.\n+                ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n+                ensure_monomorphic_enough(*self.tcx, cast_ty.ty)?;\n+\n+                span_bug!(\n+                    self.cur_span(),\n+                    \"unsize_into: invalid conversion: {:?} -> {:?}\",\n+                    src.layout,\n+                    dest.layout\n+                )\n+            }\n         }\n     }\n }"}, {"sha": "39c74191258295dc90a81a80f40994e03de9b55f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -7,7 +7,7 @@ use either::{Either, Left, Right};\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ErrorHandled, InterpError, InvalidProgramInfo};\n+use rustc_middle::mir::interpret::{ErrorHandled, InterpError};\n use rustc_middle::ty::layout::{\n     self, FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOf, LayoutOfHelpers,\n     TyAndLayout,\n@@ -508,14 +508,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         frame\n             .instance\n             .try_subst_mir_and_normalize_erasing_regions(*self.tcx, self.param_env, value)\n-            .map_err(|e| {\n-                self.tcx.sess.delay_span_bug(\n-                    self.cur_span(),\n-                    format!(\"failed to normalize {}\", e.get_type_for_failure()).as_str(),\n-                );\n-\n-                InterpError::InvalidProgram(InvalidProgramInfo::TooGeneric)\n-            })\n+            .map_err(|_| err_inval!(TooGeneric))\n     }\n \n     /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env)."}, {"sha": "9a366364e769eb6639f599897cc7dbcd443b337f", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -114,7 +114,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Intrinsic(box intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n \n             // Statements we do not track.\n-            AscribeUserType(..) => {}\n+            PlaceMention(..) | AscribeUserType(..) => {}\n \n             // Currently, Miri discards Coverage statements. Coverage statements are only injected\n             // via an optional compile time MIR pass and have no side effects. Since Coverage"}, {"sha": "685a5599cdedf5496b6a537ea236a883c901e9ed", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -171,11 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Unreachable => throw_ub!(Unreachable),\n \n             // These should never occur for MIR we actually run.\n-            DropAndReplace { .. }\n-            | FalseEdge { .. }\n-            | FalseUnwind { .. }\n-            | Yield { .. }\n-            | GeneratorDrop => span_bug!(\n+            FalseEdge { .. } | FalseUnwind { .. } | Yield { .. } | GeneratorDrop => span_bug!(\n                 terminator.source_info.span,\n                 \"{:#?} should have been eliminated by MIR pass\",\n                 terminator.kind"}, {"sha": "081d9dc8700a4174e403324a29dcb818979545fc", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -690,6 +690,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | StatementKind::StorageLive(_)\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag { .. }\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n@@ -926,15 +927,24 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                 // If the `const fn` we are trying to call is not const-stable, ensure that we have\n                 // the proper feature gate enabled.\n-                if let Some(gate) = is_unstable_const_fn(tcx, callee) {\n+                if let Some((gate, implied_by)) = is_unstable_const_fn(tcx, callee) {\n                     trace!(?gate, \"calling unstable const fn\");\n                     if self.span.allows_unstable(gate) {\n                         return;\n                     }\n+                    if let Some(implied_by_gate) = implied_by && self.span.allows_unstable(implied_by_gate) {\n+                        return;\n+                    }\n \n                     // Calling an unstable function *always* requires that the corresponding gate\n-                    // be enabled, even if the function has `#[rustc_allow_const_fn_unstable(the_gate)]`.\n-                    if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == gate) {\n+                    // (or implied gate) be enabled, even if the function has\n+                    // `#[rustc_allow_const_fn_unstable(the_gate)]`.\n+                    let gate_declared = |gate| {\n+                        tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == gate)\n+                    };\n+                    let feature_gate_declared = gate_declared(gate);\n+                    let implied_gate_declared = implied_by.map(gate_declared).unwrap_or(false);\n+                    if !feature_gate_declared && !implied_gate_declared {\n                         self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n                         return;\n                     }\n@@ -947,7 +957,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     }\n \n                     // Otherwise, we are something const-stable calling a const-unstable fn.\n-\n                     if super::rustc_allow_const_fn_unstable(tcx, caller, gate) {\n                         trace!(\"rustc_allow_const_fn_unstable gate active\");\n                         return;\n@@ -977,8 +986,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n             // Forbid all `Drop` terminators unless the place being dropped is a local with no\n             // projections that cannot be `NeedsNonConstDrop`.\n-            TerminatorKind::Drop { place: dropped_place, .. }\n-            | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n+            TerminatorKind::Drop { place: dropped_place, .. } => {\n                 // If we are checking live drops after drop-elaboration, don't emit duplicate\n                 // errors here.\n                 if super::post_drop_elaboration::checking_enabled(self.ccx) {"}, {"sha": "43806035a44a04fbd958b63d6c97b4dab7bfdfa7", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -80,8 +80,7 @@ impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n         trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n \n         match &terminator.kind {\n-            mir::TerminatorKind::Drop { place: dropped_place, .. }\n-            | mir::TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n+            mir::TerminatorKind::Drop { place: dropped_place, .. } => {\n                 let dropped_ty = dropped_place.ty(self.body, self.tcx).ty;\n                 if !NeedsNonConstDrop::in_any_value_of_ty(self.ccx, dropped_ty) {\n                     // Instead of throwing a bug, we just return here. This is because we have to"}, {"sha": "78c74e1892dc51baa3d17b32872a13c00125a960", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -222,23 +222,8 @@ where\n         // The effect of assignment to the return place in `TerminatorKind::Call` is not applied\n         // here; that occurs in `apply_call_return_effect`.\n \n-        if let mir::TerminatorKind::DropAndReplace { value, place, .. } = &terminator.kind {\n-            let qualif = qualifs::in_operand::<Q, _>(\n-                self.ccx,\n-                &mut |l| self.state.qualif.contains(l),\n-                value,\n-            );\n-\n-            if !place.is_indirect() {\n-                self.assign_qualif_direct(place, qualif);\n-            }\n-        }\n-\n         // We ignore borrow on drop because custom drop impls are not allowed in consts.\n         // FIXME: Reconsider if accounting for borrows in drops is necessary for const drop.\n-\n-        // We need to assign qualifs to the dropped location before visiting the operand that\n-        // replaces it since qualifs can be cleared on move.\n         self.super_terminator(terminator, location);\n     }\n }"}, {"sha": "49b1e6d967c700840e6986322ec6b1cb0bc956b5", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -72,6 +72,17 @@ impl<'tcx> MirPass<'tcx> for Validator {\n         };\n         checker.visit_body(body);\n         checker.check_cleanup_control_flow();\n+\n+        if let MirPhase::Runtime(_) = body.phase {\n+            if let ty::InstanceDef::Item(_) = body.source.instance {\n+                if body.has_free_regions() {\n+                    checker.fail(\n+                        Location::START,\n+                        format!(\"Free regions in optimized {} MIR\", body.phase.name()),\n+                    );\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -668,6 +679,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n+            StatementKind::PlaceMention(..) => {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n+                    self.fail(\n+                        location,\n+                        \"`PlaceMention` should have been removed after drop lowering phase\",\n+                    );\n+                }\n+            }\n             StatementKind::AscribeUserType(..) => {\n                 if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n@@ -835,18 +854,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.check_edge(location, *unwind, EdgeKind::Unwind);\n                 }\n             }\n-            TerminatorKind::DropAndReplace { target, unwind, .. } => {\n-                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n-                    self.fail(\n-                        location,\n-                        \"`DropAndReplace` should have been removed during drop elaboration\",\n-                    );\n-                }\n-                self.check_edge(location, *target, EdgeKind::Normal);\n-                if let Some(unwind) = unwind {\n-                    self.check_edge(location, *unwind, EdgeKind::Unwind);\n-                }\n-            }\n             TerminatorKind::Call { func, args, destination, target, cleanup, .. } => {\n                 let func_ty = func.ty(&self.body.local_decls, self.tcx);\n                 match func_ty.kind() {"}, {"sha": "f58844f281794ba9ce48b089702036e83d340071", "filename": "compiler/rustc_data_structures/src/flat_map_in_place.rs", "status": "renamed", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Fflat_map_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Fflat_map_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflat_map_in_place.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,14 +2,7 @@ use smallvec::{Array, SmallVec};\n use std::ptr;\n use thin_vec::ThinVec;\n \n-pub trait MapInPlace<T>: Sized {\n-    fn map_in_place<F>(&mut self, mut f: F)\n-    where\n-        F: FnMut(T) -> T,\n-    {\n-        self.flat_map_in_place(|e| Some(f(e)))\n-    }\n-\n+pub trait FlatMapInPlace<T>: Sized {\n     fn flat_map_in_place<F, I>(&mut self, f: F)\n     where\n         F: FnMut(T) -> I,\n@@ -66,14 +59,14 @@ macro_rules! flat_map_in_place {\n     };\n }\n \n-impl<T> MapInPlace<T> for Vec<T> {\n+impl<T> FlatMapInPlace<T> for Vec<T> {\n     flat_map_in_place!();\n }\n \n-impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n+impl<T, A: Array<Item = T>> FlatMapInPlace<T> for SmallVec<A> {\n     flat_map_in_place!();\n }\n \n-impl<T> MapInPlace<T> for ThinVec<T> {\n+impl<T> FlatMapInPlace<T> for ThinVec<T> {\n     flat_map_in_place!();\n }", "previous_filename": "compiler/rustc_data_structures/src/map_in_place.rs"}, {"sha": "c595bf830a3dccca47e97455fb960f42394f16ce", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -50,14 +50,14 @@ pub fn cold_path<F: FnOnce() -> R, R>(f: F) -> R {\n pub mod base_n;\n pub mod binary_search_util;\n pub mod captures;\n+pub mod flat_map_in_place;\n pub mod flock;\n pub mod functor;\n pub mod fx;\n pub mod graph;\n pub mod intern;\n pub mod jobserver;\n pub mod macros;\n-pub mod map_in_place;\n pub mod obligation_forest;\n pub mod owning_ref;\n pub mod sip128;"}, {"sha": "de9842156d61f4588598c60f7d849437d83158cd", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -617,18 +617,10 @@ where\n     }\n }\n \n-impl<K, R, HCX> HashStable<HCX> for ::std::collections::HashSet<K, R>\n-where\n-    K: ToStableHashKey<HCX> + Eq,\n-    R: BuildHasher,\n-{\n-    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n-        stable_hash_reduce(hcx, hasher, self.iter(), self.len(), |hasher, hcx, key| {\n-            let key = key.to_stable_hash_key(hcx);\n-            key.hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n+// It is not safe to implement HashStable for HashSet or any other collection type\n+// with unstable but observable iteration order.\n+// See https://github.com/rust-lang/compiler-team/issues/533 for further information.\n+impl<V, HCX> !HashStable<HCX> for std::collections::HashSet<V> {}\n \n impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n where"}, {"sha": "5c2435a0122ebeb161cf75f2ff8636a224b4f09c", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -109,6 +109,12 @@ impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n     }\n }\n \n+impl<T> UnordItems<T, std::iter::Empty<T>> {\n+    pub fn empty() -> Self {\n+        UnordItems(std::iter::empty())\n+    }\n+}\n+\n impl<'a, T: Clone + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n     #[inline]\n     pub fn cloned(self) -> UnordItems<T, impl Iterator<Item = T>> {\n@@ -133,6 +139,20 @@ impl<T: Ord, I: Iterator<Item = T>> UnordItems<T, I> {\n         items\n     }\n \n+    #[inline]\n+    pub fn into_sorted_stable_ord(self, use_stable_sort: bool) -> Vec<T>\n+    where\n+        T: Ord + StableOrd,\n+    {\n+        let mut items: Vec<T> = self.0.collect();\n+        if use_stable_sort {\n+            items.sort();\n+        } else {\n+            items.sort_unstable()\n+        }\n+        items\n+    }\n+\n     pub fn into_sorted_small_vec<HCX, const LEN: usize>(self, hcx: &HCX) -> SmallVec<[T; LEN]>\n     where\n         T: ToStableHashKey<HCX>,\n@@ -175,6 +195,11 @@ impl<V: Eq + Hash> UnordSet<V> {\n         self.inner.len()\n     }\n \n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+\n     #[inline]\n     pub fn insert(&mut self, v: V) -> bool {\n         self.inner.insert(v)\n@@ -253,7 +278,7 @@ impl<V: Eq + Hash> UnordSet<V> {\n     // We can safely extend this UnordSet from a set of unordered values because that\n     // won't expose the internal ordering anywhere.\n     #[inline]\n-    pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n+    pub fn extend_unord<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n         self.inner.extend(items.0)\n     }\n \n@@ -277,6 +302,12 @@ impl<V: Hash + Eq> FromIterator<V> for UnordSet<V> {\n     }\n }\n \n+impl<V: Hash + Eq> From<FxHashSet<V>> for UnordSet<V> {\n+    fn from(value: FxHashSet<V>) -> Self {\n+        UnordSet { inner: value }\n+    }\n+}\n+\n impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordSet<V> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {"}, {"sha": "d6cb173ba9ba0fc1e2a09b0e470eeea2c61320c9", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -12,8 +12,8 @@ use rustc_ast::tokenstream::{LazyAttrTokenStream, TokenTree};\n use rustc_ast::NodeId;\n use rustc_ast::{self as ast, AttrStyle, Attribute, HasAttrs, HasTokens, MetaItem};\n use rustc_attr as attr;\n+use rustc_data_structures::flat_map_in_place::FlatMapInPlace;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_feature::{Feature, Features, State as FeatureState};\n use rustc_feature::{\n     ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,"}, {"sha": "4092a192e0c34ad5385e87717129edb6df95b584", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -20,7 +20,7 @@ use rustc_ast::{ForeignItemKind, HasAttrs, HasNodeId};\n use rustc_ast::{Inline, ItemKind, MacStmtStyle, MetaItemKind, ModKind};\n use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n-use rustc_data_structures::map_in_place::MapInPlace;\n+use rustc_data_structures::flat_map_in_place::FlatMapInPlace;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::PResult;\n use rustc_feature::Features;"}, {"sha": "df42881644487b59c99e39d435dac2dcbb887d9e", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -89,14 +89,14 @@ hir_analysis_missing_type_params =\n     .note = because of the default `Self` reference, type parameters must be specified on object types\n \n hir_analysis_copy_impl_on_type_with_dtor =\n-    the trait `Copy` may not be implemented for this type; the type has a destructor\n+    the trait `Copy` cannot be implemented for this type; the type has a destructor\n     .label = `Copy` not allowed on types with destructors\n \n hir_analysis_multiple_relaxed_default_bounds =\n     type parameter has more than one relaxed default bound, only one is supported\n \n hir_analysis_copy_impl_on_non_adt =\n-    the trait `Copy` may not be implemented for this type\n+    the trait `Copy` cannot be implemented for this type\n     .label = type is not a structure or enumeration\n \n hir_analysis_const_impl_for_non_const_trait =\n@@ -155,3 +155,18 @@ hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n     cannot capture late-bound const parameter in a constant\n     .label = parameter defined here\n+\n+hir_analysis_variances_of = {$variances_of}\n+\n+hir_analysis_pass_to_variadic_function = can't pass `{$ty}` to variadic function\n+    .suggestion = cast the value to `{$cast_ty}`\n+    .help = cast the value to `{$cast_ty}`\n+\n+hir_analysis_cast_thin_pointer_to_fat_pointer = cannot cast thin pointer `{$expr_ty}` to fat pointer `{$cast_ty}`\n+\n+hir_analysis_invalid_union_field =\n+    field must implement `Copy` or be wrapped in `ManuallyDrop<...>` to be used in a union\n+    .note = union fields must not have drop side-effects, which is currently enforced via either `Copy` or `ManuallyDrop<...>`\n+\n+hir_analysis_invalid_union_field_sugg =\n+    wrap the field type in `ManuallyDrop<...>`"}, {"sha": "be0ae4ce2ef694e632f58cfe23afd44840ec6b95", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,5 @@\n use crate::check::intrinsicck::InlineAsmCtxt;\n-use crate::errors::LinkageType;\n+use crate::errors::{self, LinkageType};\n \n use super::compare_impl_item::check_type_bounds;\n use super::compare_impl_item::{compare_impl_method, compare_impl_ty};\n@@ -114,9 +114,11 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n                     allowed_union_field(*elem, tcx, param_env)\n                 }\n                 _ => {\n-                    // Fallback case: allow `ManuallyDrop` and things that are `Copy`.\n+                    // Fallback case: allow `ManuallyDrop` and things that are `Copy`,\n+                    // also no need to report an error if the type is unresolved.\n                     ty.ty_adt_def().is_some_and(|adt_def| adt_def.is_manually_drop())\n                         || ty.is_copy_modulo_regions(tcx, param_env)\n+                        || ty.references_error()\n                 }\n             }\n         }\n@@ -131,26 +133,14 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n                     Some(Node::Field(field)) => (field.span, field.ty.span),\n                     _ => unreachable!(\"mir field has to correspond to hir field\"),\n                 };\n-                struct_span_err!(\n-                    tcx.sess,\n+                tcx.sess.emit_err(errors::InvalidUnionField {\n                     field_span,\n-                    E0740,\n-                    \"unions cannot contain fields that may need dropping\"\n-                )\n-                .note(\n-                    \"a type is guaranteed not to need dropping \\\n-                    when it implements `Copy`, or when it is the special `ManuallyDrop<_>` type\",\n-                )\n-                .multipart_suggestion_verbose(\n-                    \"when the type does not implement `Copy`, \\\n-                    wrap it inside a `ManuallyDrop<_>` and ensure it is manually dropped\",\n-                    vec![\n-                        (ty_span.shrink_to_lo(), \"std::mem::ManuallyDrop<\".into()),\n-                        (ty_span.shrink_to_hi(), \">\".into()),\n-                    ],\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+                    sugg: errors::InvalidUnionFieldSuggestion {\n+                        lo: ty_span.shrink_to_lo(),\n+                        hi: ty_span.shrink_to_hi(),\n+                    },\n+                    note: (),\n+                });\n                 return false;\n             } else if field_ty.needs_drop(tcx, param_env) {\n                 // This should never happen. But we can get here e.g. in case of name resolution errors.\n@@ -1510,6 +1500,14 @@ fn opaque_type_cycle_error(\n                     {\n                         label_match(interior_ty.ty, interior_ty.span);\n                     }\n+                    if tcx.sess.opts.unstable_opts.drop_tracking_mir\n+                        && let DefKind::Generator = tcx.def_kind(closure_def_id)\n+                    {\n+                        let generator_layout = tcx.mir_generator_witnesses(closure_def_id);\n+                        for interior_ty in &generator_layout.field_tys {\n+                            label_match(interior_ty.ty, interior_ty.source_info.span);\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "20b6561f8b256fe9a668e3db4a9e87a9cf41bdfc", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -300,6 +300,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::nearbyintf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n             sym::roundf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n             sym::roundf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::roundevenf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::roundevenf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n \n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 (1, vec![tcx.mk_imm_ptr(param(0))], param(0))"}, {"sha": "172b84bafb2157aa757c263354267a603fbbd005", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast::InlineAsmTemplatePiece;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitableExt, UintTy};\n use rustc_session::lint;\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n         tied_input: Option<(&'tcx hir::Expr<'tcx>, Option<InlineAsmType>)>,\n-        target_features: &FxHashSet<Symbol>,\n+        target_features: &FxIndexSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n         let ty = (self.get_operand_ty)(expr);\n         if ty.has_non_region_infer() {\n@@ -201,7 +201,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         // (!). In that case we still need the earlier check to verify that the\n         // register class is usable at all.\n         if let Some(feature) = feature {\n-            if !target_features.contains(&feature) {\n+            if !target_features.contains(feature) {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n                 err.note(&format!("}, {"sha": "268b9ac530f189f1999acedd0acf7c16137020b0", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -10,7 +10,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     for item_def_id in tcx.hir().body_owners() {\n         let imports = tcx.used_trait_imports(item_def_id);\n         debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n-        used_trait_imports.extend(imports.items().copied());\n+        used_trait_imports.extend_unord(imports.items().copied());\n     }\n \n     for &id in tcx.maybe_unused_trait_imports(()) {"}, {"sha": "8294d92c9364e170403b2beada30b71fd8a00793", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,6 +2,7 @@\n //! up data structures required by type-checking/codegen.\n \n use crate::errors::{CopyImplOnNonAdt, CopyImplOnTypeWithDtor, DropImplOnWrongItem};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -86,15 +87,22 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 tcx.sess,\n                 span,\n                 E0204,\n-                \"the trait `Copy` may not be implemented for this type\"\n+                \"the trait `Copy` cannot be implemented for this type\"\n             );\n \n             // We'll try to suggest constraining type parameters to fulfill the requirements of\n             // their `Copy` implementation.\n             let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n             let mut bounds = vec![];\n \n+            let mut seen_tys = FxHashSet::default();\n+\n             for (field, ty, reason) in fields {\n+                // Only report an error once per type.\n+                if !seen_tys.insert(ty) {\n+                    continue;\n+                }\n+\n                 let field_span = tcx.def_span(field.did);\n                 err.span_label(field_span, \"this field does not implement `Copy`\");\n "}, {"sha": "47c47de8cedbaa3515e9b8fb8ddde220d8faebd1", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -478,10 +478,6 @@ fn lint_auto_trait_impl<'tcx>(\n     trait_ref: ty::TraitRef<'tcx>,\n     impl_def_id: LocalDefId,\n ) {\n-    if tcx.impl_polarity(impl_def_id) != ImplPolarity::Positive {\n-        return;\n-    }\n-\n     assert_eq!(trait_ref.substs.len(), 1);\n     let self_ty = trait_ref.self_ty();\n     let (self_type_did, substs) = match self_ty.kind() {"}, {"sha": "7fc0711a155c1f795fbd585295179e94894348b7", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -344,8 +344,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     in_trait,\n                     ..\n                 }) => {\n-                    if in_trait {\n-                        assert!(tcx.impl_defaultness(owner).has_value());\n+                    if in_trait && !tcx.impl_defaultness(owner).has_value() {\n+                        span_bug!(tcx.def_span(def_id), \"tried to get type of this RPITIT with no definition\");\n                     }\n                     find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n                 }"}, {"sha": "dd40706f1d34580884bd8e6f598d3b36974b9c65", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -5,7 +5,7 @@ use rustc_errors::{\n     error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n     MultiSpan,\n };\n-use rustc_macros::Diagnostic;\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n@@ -399,3 +399,54 @@ pub(crate) enum CannotCaptureLateBoundInAnonConst {\n         def_span: Span,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_variances_of)]\n+pub(crate) struct VariancesOf {\n+    #[primary_span]\n+    pub span: Span,\n+    pub variances_of: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_pass_to_variadic_function, code = \"E0617\")]\n+pub(crate) struct PassToVariadicFunction<'tcx, 'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub cast_ty: &'a str,\n+    #[suggestion(code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Option<Span>,\n+    pub replace: String,\n+    #[help]\n+    pub help: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_cast_thin_pointer_to_fat_pointer, code = \"E0607\")]\n+pub(crate) struct CastThinPointerToFatPointer<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub expr_ty: Ty<'tcx>,\n+    pub cast_ty: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_invalid_union_field, code = \"E0740\")]\n+pub(crate) struct InvalidUnionField {\n+    #[primary_span]\n+    pub field_span: Span,\n+    #[subdiagnostic]\n+    pub sugg: InvalidUnionFieldSuggestion,\n+    #[note]\n+    pub note: (),\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(hir_analysis_invalid_union_field_sugg, applicability = \"machine-applicable\")]\n+pub(crate) struct InvalidUnionFieldSuggestion {\n+    #[suggestion_part(code = \"std::mem::ManuallyDrop<\")]\n+    pub lo: Span,\n+    #[suggestion_part(code = \">\")]\n+    pub hi: Span,\n+}"}, {"sha": "0bfbf99cb0b588b9ebb51acd0f1ba69b13fe58f4", "filename": "compiler/rustc_hir_analysis/src/structured_errors/missing_cast_for_variadic_arg.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,5 @@\n-use crate::structured_errors::StructuredDiagnostic;\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n+use crate::{errors, structured_errors::StructuredDiagnostic};\n+use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n use rustc_middle::ty::{Ty, TypeVisitableExt};\n use rustc_session::Session;\n use rustc_span::Span;\n@@ -21,27 +21,26 @@ impl<'tcx> StructuredDiagnostic<'tcx> for MissingCastForVariadicArg<'tcx, '_> {\n     }\n \n     fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = self.sess.struct_span_err_with_code(\n-            self.span,\n-            &format!(\"can't pass `{}` to variadic function\", self.ty),\n-            self.code(),\n-        );\n+        let (sugg_span, replace, help) =\n+            if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n+                (Some(self.span), format!(\"{} as {}\", snippet, self.cast_ty), None)\n+            } else {\n+                (None, \"\".to_string(), Some(()))\n+            };\n+\n+        let mut err = self.sess.create_err(errors::PassToVariadicFunction {\n+            span: self.span,\n+            ty: self.ty,\n+            cast_ty: self.cast_ty,\n+            help,\n+            replace,\n+            sugg_span,\n+        });\n \n         if self.ty.references_error() {\n             err.downgrade_to_delayed_bug();\n         }\n \n-        if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n-            err.span_suggestion(\n-                self.span,\n-                &format!(\"cast the value to `{}`\", self.cast_ty),\n-                format!(\"{} as {}\", snippet, self.cast_ty),\n-                Applicability::MachineApplicable,\n-            );\n-        } else {\n-            err.help(&format!(\"cast the value to `{}`\", self.cast_ty));\n-        }\n-\n         err\n     }\n "}, {"sha": "910417abe6e7c670c9b6b5e51f3d017eab041f4a", "filename": "compiler/rustc_hir_analysis/src/structured_errors/sized_unsized_cast.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,4 +1,4 @@\n-use crate::structured_errors::StructuredDiagnostic;\n+use crate::{errors, structured_errors::StructuredDiagnostic};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n use rustc_middle::ty::{Ty, TypeVisitableExt};\n use rustc_session::Session;\n@@ -21,14 +21,11 @@ impl<'tcx> StructuredDiagnostic<'tcx> for SizedUnsizedCast<'tcx> {\n     }\n \n     fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = self.sess.struct_span_err_with_code(\n-            self.span,\n-            &format!(\n-                \"cannot cast thin pointer `{}` to fat pointer `{}`\",\n-                self.expr_ty, self.cast_ty\n-            ),\n-            self.code(),\n-        );\n+        let mut err = self.sess.create_err(errors::CastThinPointerToFatPointer {\n+            span: self.span,\n+            expr_ty: self.expr_ty,\n+            cast_ty: self.cast_ty.to_owned(),\n+        });\n \n         if self.expr_ty.references_error() {\n             err.downgrade_to_delayed_bug();"}, {"sha": "64614831f560f99bef2f2f83c08fab2c99366f66", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,14 +1,19 @@\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n+use crate::errors;\n+\n pub fn test_variance(tcx: TyCtxt<'_>) {\n     // For unit testing: check for a special \"rustc_variance\"\n     // attribute and report an error with various results if found.\n     for id in tcx.hir().items() {\n         if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_variance) {\n             let variances_of = tcx.variances_of(id.owner_id);\n \n-            tcx.sess.struct_span_err(tcx.def_span(id.owner_id), format!(\"{variances_of:?}\")).emit();\n+            tcx.sess.emit_err(errors::VariancesOf {\n+                span: tcx.def_span(id.owner_id),\n+                variances_of: format!(\"{variances_of:?}\"),\n+            });\n         }\n     }\n }"}, {"sha": "2c537bf4064ae9b7c5645423c879ca0f091fc893", "filename": "compiler/rustc_hir_typeck/locales/en-US.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Flocales%2Fen-US.ftl?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -4,14 +4,14 @@ hir_typeck_field_multiply_specified_in_initializer =\n     .previous_use_label = first use of `{$ident}`\n \n hir_typeck_copy_impl_on_type_with_dtor =\n-    the trait `Copy` may not be implemented for this type; the type has a destructor\n+    the trait `Copy` cannot be implemented for this type; the type has a destructor\n     .label = `Copy` not allowed on types with destructors\n \n hir_typeck_multiple_relaxed_default_bounds =\n     type parameter has more than one relaxed default bound, only one is supported\n \n hir_typeck_copy_impl_on_non_adt =\n-    the trait `Copy` may not be implemented for this type\n+    the trait `Copy` cannot be implemented for this type\n     .label = type is not a structure or enumeration\n \n hir_typeck_trait_object_declared_with_no_traits ="}, {"sha": "ac7d984c1618dc9a35e7ba9cbd51f7565290ced1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -301,16 +301,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n-    ) -> (ty::InstantiatedPredicates<'tcx>, Vec<Span>) {\n+    ) -> ty::InstantiatedPredicates<'tcx> {\n         let bounds = self.tcx.predicates_of(def_id);\n-        let spans: Vec<Span> = bounds.predicates.iter().map(|(_, span)| *span).collect();\n         let result = bounds.instantiate(self.tcx, substs);\n         let result = self.normalize(span, result);\n-        debug!(\n-            \"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}, {:?}\",\n-            bounds, substs, result, spans,\n-        );\n-        (result, spans)\n+        debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\", bounds, substs, result);\n+        result\n     }\n \n     pub(in super::super) fn normalize<T>(&self, span: Span, value: T) -> T\n@@ -1389,7 +1385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        let (bounds, _) = self.instantiate_bounds(span, def_id, &substs);\n+        let bounds = self.instantiate_bounds(span, def_id, &substs);\n \n         for mut obligation in traits::predicates_for_generics(\n             |idx, predicate_span| {"}, {"sha": "690d8a238261aeef2848f43d24b0b9d9f144d67e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -669,6 +669,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// This routine checks if the return type is left as default, the method is not part of an\n     /// `impl` block and that it isn't the `main` method. If so, it suggests setting the return\n     /// type.\n+    #[instrument(level = \"trace\", skip(self, err))]\n     pub(in super::super) fn suggest_missing_return_type(\n         &self,\n         err: &mut Diagnostic,\n@@ -705,28 +706,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return true\n                 }\n             }\n-            hir::FnRetTy::Return(ty) => {\n-                let span = ty.span;\n-\n-                if let hir::TyKind::OpaqueDef(item_id, ..) = ty.kind\n-                && let hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::OpaqueTy(op_ty),\n-                    ..\n-                }) = self.tcx.hir().get(item_id.hir_id())\n-                && let hir::OpaqueTy {\n-                    bounds: [bound], ..\n-                } = op_ty\n-                && let hir::GenericBound::LangItemTrait(\n-                    hir::LangItem::Future, _, _, generic_args) = bound\n-                && let hir::GenericArgs { bindings: [ty_binding], .. } = generic_args\n-                && let hir::TypeBinding { kind, .. } = ty_binding\n-                && let hir::TypeBindingKind::Equality { term } = kind\n-                && let hir::Term::Ty(term_ty) = term {\n+            hir::FnRetTy::Return(hir_ty) => {\n+                let span = hir_ty.span;\n+\n+                if let hir::TyKind::OpaqueDef(item_id, ..) = hir_ty.kind\n+                    && let hir::Node::Item(hir::Item {\n+                        kind: hir::ItemKind::OpaqueTy(op_ty),\n+                        ..\n+                    }) = self.tcx.hir().get(item_id.hir_id())\n+                    && let [hir::GenericBound::LangItemTrait(\n+                        hir::LangItem::Future, _, _, generic_args)] = op_ty.bounds\n+                    && let hir::GenericArgs { bindings: [ty_binding], .. } = generic_args\n+                    && let hir::TypeBindingKind::Equality { term: hir::Term::Ty(term) } = ty_binding.kind\n+                {\n                     // Check if async function's return type was omitted.\n                     // Don't emit suggestions if the found type is `impl Future<...>`.\n-                    debug!(\"suggest_missing_return_type: found = {:?}\", found);\n+                    debug!(?found);\n                     if found.is_suggestable(self.tcx, false) {\n-                        if term_ty.span.is_empty() {\n+                        if term.span.is_empty() {\n                             err.subdiagnostic(AddReturnTypeSuggestion::Add { span, found: found.to_string() });\n                             return true;\n                         } else {\n@@ -737,11 +734,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n-                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n-                let ty = self.astconv().ast_ty_to_ty(ty);\n-                debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n-                debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n-                let bound_vars = self.tcx.late_bound_vars(fn_id);\n+                debug!(\"return type {:?}\", hir_ty);\n+                let ty = self.astconv().ast_ty_to_ty(hir_ty);\n+                debug!(\"return type {:?}\", ty);\n+                debug!(\"expected type {:?}\", expected);\n+                let bound_vars = self.tcx.late_bound_vars(hir_ty.hir_id.owner.into());\n                 let ty = Binder::bind_with_vars(ty, bound_vars);\n                 let ty = self.normalize(span, ty);\n                 let ty = self.tcx.erase_late_bound_regions(ty);"}, {"sha": "57805f7c800536d1a4353f3020dd1c1773ae6914", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1031,7 +1031,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             .collect();\n \n         // Sort them by the name so we have a stable result.\n-        names.sort_by(|a, b| a.as_str().partial_cmp(b.as_str()).unwrap());\n+        names.sort_by(|a, b| a.as_str().cmp(b.as_str()));\n         names\n     }\n "}, {"sha": "4b15e48bd278ebd4591809d05bb569716a430039", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -42,7 +42,7 @@ use rustc_trait_selection::traits::{\n use super::probe::{AutorefOrPtrAdjustment, IsSuggestion, Mode, ProbeScope};\n use super::{CandidateSource, MethodError, NoMatchData};\n use rustc_hir::intravisit::Visitor;\n-use std::cmp::Ordering;\n+use std::cmp::{self, Ordering};\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -348,6 +348,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.downgrade_to_delayed_bug();\n         }\n \n+        if tcx.ty_is_opaque_future(rcvr_ty) && item_name.name == sym::poll {\n+            err.help(&format!(\n+                \"method `poll` found on `Pin<&mut {ty_str}>`, \\\n+                see documentation for `std::pin::Pin`\"\n+            ));\n+            err.help(\"self type must be pinned to call `Future::poll`, \\\n+                see https://rust-lang.github.io/async-book/04_pinning/01_chapter.html#pinning-in-practice\"\n+            );\n+        }\n+\n         if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n             self.suggest_await_before_method(\n                 &mut err, item_name, rcvr_ty, cal, span, expected.only_has_type(self),\n@@ -2517,7 +2527,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !candidates.is_empty() {\n             // Sort from most relevant to least relevant.\n-            candidates.sort_by(|a, b| a.cmp(b).reverse());\n+            candidates.sort_by_key(|&info| cmp::Reverse(info));\n             candidates.dedup();\n \n             let param_type = match rcvr_ty.kind() {"}, {"sha": "a43330e2d4ea5db44b9a1392a0d814b464a755f1", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -352,19 +352,17 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n             }\n \n             ty::ReVar(vid) => {\n-                let resolved_vid = self\n+                let resolved = self\n                     .infcx\n                     .inner\n                     .borrow_mut()\n                     .unwrap_region_constraints()\n-                    .opportunistic_resolve_var(vid);\n+                    .opportunistic_resolve_var(self.tcx, vid);\n                 debug!(\n-                    \"canonical: region var found with vid {:?}, \\\n-                     opportunistically resolved to {:?}\",\n-                    vid, resolved_vid\n+                    \"canonical: region var found with vid {vid:?}, \\\n+                     opportunistically resolved to {resolved:?}\",\n                 );\n-                let r = self.tcx.mk_re_var(resolved_vid);\n-                self.canonicalize_mode.canonicalize_free_region(self, r)\n+                self.canonicalize_mode.canonicalize_free_region(self, resolved)\n             }\n \n             ty::ReStatic\n@@ -376,9 +374,18 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, mut t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n-            ty::Infer(ty::TyVar(vid)) => {\n+            ty::Infer(ty::TyVar(mut vid)) => {\n+                // We need to canonicalize the *root* of our ty var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_var(vid);\n+                if root_vid != vid {\n+                    t = self.infcx.tcx.mk_ty_var(root_vid);\n+                    vid = root_vid;\n+                }\n+\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n                 match self.infcx.probe_ty_var(vid) {\n                     // `t` could be a float / int variable; canonicalize that instead.\n@@ -469,9 +476,18 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+    fn fold_const(&mut self, mut ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         match ct.kind() {\n-            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n+            ty::ConstKind::Infer(InferConst::Var(mut vid)) => {\n+                // We need to canonicalize the *root* of our const var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_const_var(vid);\n+                if root_vid != vid {\n+                    ct = self.infcx.tcx.mk_const(ty::InferConst::Var(root_vid), ct.ty());\n+                    vid = root_vid;\n+                }\n+\n                 debug!(\"canonical: const var found with vid {:?}\", vid);\n                 match self.infcx.probe_const_var(vid) {\n                     Ok(c) => {"}, {"sha": "4a2a55573131aa92c091ccf6f4fd2d376e06a334", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -114,24 +114,26 @@ pub struct InferCtxtInner<'tcx> {\n     float_unification_storage: ut::UnificationTableStorage<ty::FloatVid>,\n \n     /// Tracks the set of region variables and the constraints between them.\n+    ///\n     /// This is initially `Some(_)` but when\n     /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n     /// -- further attempts to perform unification, etc., may fail if new\n     /// region constraints would've been added.\n     region_constraint_storage: Option<RegionConstraintStorage<'tcx>>,\n \n-    /// A set of constraints that regionck must validate. Each\n-    /// constraint has the form `T:'a`, meaning \"some type `T` must\n+    /// A set of constraints that regionck must validate.\n+    ///\n+    /// Each constraint has the form `T:'a`, meaning \"some type `T` must\n     /// outlive the lifetime 'a\". These constraints derive from\n     /// instantiated type parameters. So if you had a struct defined\n-    /// like\n+    /// like the following:\n     /// ```ignore (illustrative)\n-    ///     struct Foo<T:'static> { ... }\n+    /// struct Foo<T: 'static> { ... }\n     /// ```\n-    /// then in some expression `let x = Foo { ... }` it will\n+    /// In some expression `let x = Foo { ... }`, it will\n     /// instantiate the type parameter `T` with a fresh type `$0`. At\n     /// the same time, it will record a region obligation of\n-    /// `$0:'static`. This will get checked later by regionck. (We\n+    /// `$0: 'static`. This will get checked later by regionck. (We\n     /// can't generally check these things right away because we have\n     /// to wait until types are resolved.)\n     ///\n@@ -268,7 +270,7 @@ pub struct InferCtxt<'tcx> {\n     /// Caches the results of trait evaluation.\n     pub evaluation_cache: select::EvaluationCache<'tcx>,\n \n-    /// the set of predicates on which errors have been reported, to\n+    /// The set of predicates on which errors have been reported, to\n     /// avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FxIndexMap<Span, Vec<ty::Predicate<'tcx>>>>,\n \n@@ -291,7 +293,7 @@ pub struct InferCtxt<'tcx> {\n     tainted_by_errors: Cell<Option<ErrorGuaranteed>>,\n \n     /// Track how many errors were reported when this infcx is created.\n-    /// If the number of errors increases, that's also a sign (line\n+    /// If the number of errors increases, that's also a sign (like\n     /// `tainted_by_errors`) to avoid reporting certain kinds of errors.\n     // FIXME(matthewjasper) Merge into `tainted_by_errors`\n     err_count_on_creation: usize,\n@@ -313,7 +315,7 @@ pub struct InferCtxt<'tcx> {\n     /// During coherence we have to assume that other crates may add\n     /// additional impls which we currently don't know about.\n     ///\n-    /// To deal with this evaluation should be conservative\n+    /// To deal with this evaluation, we should be conservative\n     /// and consider the possibility of impls from outside this crate.\n     /// This comes up primarily when resolving ambiguity. Imagine\n     /// there is some trait reference `$0: Bar` where `$0` is an\n@@ -323,7 +325,7 @@ pub struct InferCtxt<'tcx> {\n     /// bound to some type that in a downstream crate that implements\n     /// `Bar`.\n     ///\n-    /// Outside of coherence we set this to false because we are only\n+    /// Outside of coherence, we set this to false because we are only\n     /// interested in types that the user could actually have written.\n     /// In other words, we consider `$0: Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n@@ -373,7 +375,7 @@ pub enum SubregionOrigin<'tcx> {\n     Subtype(Box<TypeTrace<'tcx>>),\n \n     /// When casting `&'a T` to an `&'b Trait` object,\n-    /// relating `'a` to `'b`\n+    /// relating `'a` to `'b`.\n     RelateObjectBound(Span),\n \n     /// Some type parameter was instantiated with the given type,\n@@ -384,7 +386,7 @@ pub enum SubregionOrigin<'tcx> {\n     /// that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n-    /// Creating a pointer `b` to contents of another reference\n+    /// Creating a pointer `b` to contents of another reference.\n     Reborrow(Span),\n \n     /// (&'a &'b T) where a >= b\n@@ -398,7 +400,7 @@ pub enum SubregionOrigin<'tcx> {\n         trait_item_def_id: DefId,\n     },\n \n-    /// Checking that the bounds of a trait's associated type hold for a given impl\n+    /// Checking that the bounds of a trait's associated type hold for a given impl.\n     CheckAssociatedTypeBounds {\n         parent: Box<SubregionOrigin<'tcx>>,\n         impl_item_def_id: LocalDefId,\n@@ -435,32 +437,33 @@ pub enum LateBoundRegionConversionTime {\n     AssocTypeProjection(DefId),\n }\n \n-/// Reasons to create a region inference variable\n+/// Reasons to create a region inference variable.\n ///\n-/// See `error_reporting` module for more details\n+/// See `error_reporting` module for more details.\n #[derive(Copy, Clone, Debug)]\n pub enum RegionVariableOrigin {\n-    /// Region variables created for ill-categorized reasons,\n-    /// mostly indicates places in need of refactoring\n+    /// Region variables created for ill-categorized reasons.\n+    ///\n+    /// They mostly indicate places in need of refactoring.\n     MiscVariable(Span),\n \n-    /// Regions created by a `&P` or `[...]` pattern\n+    /// Regions created by a `&P` or `[...]` pattern.\n     PatternRegion(Span),\n \n-    /// Regions created by `&` operator\n+    /// Regions created by `&` operator.\n+    ///\n     AddrOfRegion(Span),\n-\n-    /// Regions created as part of an autoref of a method receiver\n+    /// Regions created as part of an autoref of a method receiver.\n     Autoref(Span),\n \n-    /// Regions created as part of an automatic coercion\n+    /// Regions created as part of an automatic coercion.\n     Coercion(Span),\n \n-    /// Region variables created as the values for early-bound regions\n+    /// Region variables created as the values for early-bound regions.\n     EarlyBoundRegion(Span, Symbol),\n \n     /// Region variables created for bound regions\n-    /// in a function or method that is called\n+    /// in a function or method that is called.\n     LateBoundRegion(Span, ty::BoundRegionKind, LateBoundRegionConversionTime),\n \n     UpvarRegion(ty::UpvarId, Span),\n@@ -534,7 +537,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n     }\n }\n \n-/// Used to configure inference contexts before their creation\n+/// Used to configure inference contexts before their creation.\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n@@ -835,9 +838,9 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     /// Scan the constraints produced since `snapshot` began and returns:\n     ///\n-    /// - `None` -- if none of them involve \"region outlives\" constraints\n-    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder\n-    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders\n+    /// - `None` -- if none of them involves \"region outlives\" constraints.\n+    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder.\n+    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders.\n     pub fn region_constraints_added_in_snapshot(\n         &self,\n         snapshot: &CombinedSnapshot<'tcx>,\n@@ -1356,6 +1359,10 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().type_variables().root_var(var)\n     }\n \n+    pub fn root_const_var(&self, var: ty::ConstVid<'tcx>) -> ty::ConstVid<'tcx> {\n+        self.inner.borrow_mut().const_unification_table().find(var)\n+    }\n+\n     /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n     /// are unaffected. If a type/const variable has not been unified, it\n@@ -1770,7 +1777,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     }\n }\n \n-/// Helper for `ty_or_const_infer_var_changed` (see comment on that), currently\n+/// Helper for [InferCtxt::ty_or_const_infer_var_changed] (see comment on that), currently\n /// used only for `traits::fulfill`'s list of `stalled_on` inference variables.\n #[derive(Copy, Clone, Debug)]\n pub enum TyOrConstInferVar<'tcx> {"}, {"sha": "0b86d9c1fb82729a9d8ba444e0b9dcf8841a7b40", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -420,7 +420,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         // `RegionConstraintData` contains the relationship here.\n         if *any_unifications {\n             *any_unifications = false;\n-            self.unification_table().reset_unifications(|_| UnifiedRegion(None));\n+            self.unification_table_mut().reset_unifications(|_| UnifiedRegion::new(None));\n         }\n \n         data\n@@ -447,7 +447,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     ) -> RegionVid {\n         let vid = self.var_infos.push(RegionVariableInfo { origin, universe });\n \n-        let u_vid = self.unification_table().new_key(UnifiedRegion(None));\n+        let u_vid = self.unification_table_mut().new_key(UnifiedRegion::new(None));\n         assert_eq!(vid, u_vid.vid);\n         self.undo_log.push(AddVar(vid));\n         debug!(\"created new region variable {:?} in {:?} with origin {:?}\", vid, universe, origin);\n@@ -516,13 +516,13 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n             match (sub, sup) {\n                 (Region(Interned(ReVar(sub), _)), Region(Interned(ReVar(sup), _))) => {\n                     debug!(\"make_eqregion: unifying {:?} with {:?}\", sub, sup);\n-                    self.unification_table().union(*sub, *sup);\n+                    self.unification_table_mut().union(*sub, *sup);\n                     self.any_unifications = true;\n                 }\n                 (Region(Interned(ReVar(vid), _)), value)\n                 | (value, Region(Interned(ReVar(vid), _))) => {\n                     debug!(\"make_eqregion: unifying {:?} with {:?}\", vid, value);\n-                    self.unification_table().union_value(*vid, UnifiedRegion(Some(value)));\n+                    self.unification_table_mut().union_value(*vid, UnifiedRegion::new(Some(value)));\n                     self.any_unifications = true;\n                 }\n                 (_, _) => {}\n@@ -633,28 +633,25 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         }\n     }\n \n-    /// Resolves the passed RegionVid to the root RegionVid in the unification table\n-    pub(super) fn opportunistic_resolve_var(&mut self, rid: ty::RegionVid) -> ty::RegionVid {\n-        self.unification_table().find(rid).vid\n-    }\n-\n-    /// If the Region is a `ReVar`, then resolves it either to the root value in\n-    /// the unification table, if it exists, or to the root `ReVar` in the table.\n-    /// If the Region is not a `ReVar`, just returns the Region itself.\n-    pub fn opportunistic_resolve_region(\n+    /// Resolves a region var to its value in the unification table, if it exists.\n+    /// Otherwise, it is resolved to the root `ReVar` in the table.\n+    pub fn opportunistic_resolve_var(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        region: ty::Region<'tcx>,\n+        vid: ty::RegionVid,\n     ) -> ty::Region<'tcx> {\n-        match *region {\n-            ty::ReVar(rid) => {\n-                let unified_region = self.unification_table().probe_value(rid);\n-                unified_region.0.unwrap_or_else(|| {\n-                    let root = self.unification_table().find(rid).vid;\n-                    tcx.mk_re_var(root)\n-                })\n-            }\n-            _ => region,\n+        let mut ut = self.unification_table_mut(); // FIXME(rust-lang/ena#42): unnecessary mut\n+        let root_vid = ut.find(vid).vid;\n+        let resolved = ut\n+            .probe_value(root_vid)\n+            .get_value_ignoring_universes()\n+            .unwrap_or_else(|| tcx.mk_re_var(root_vid));\n+\n+        // Don't resolve a variable to a region that it cannot name.\n+        if self.var_universe(vid).can_name(self.universe(resolved)) {\n+            resolved\n+        } else {\n+            tcx.mk_re_var(vid)\n         }\n     }\n \n@@ -733,7 +730,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     }\n \n     #[inline]\n-    fn unification_table(&mut self) -> super::UnificationTable<'_, 'tcx, RegionVidKey<'tcx>> {\n+    fn unification_table_mut(&mut self) -> super::UnificationTable<'_, 'tcx, RegionVidKey<'tcx>> {\n         ut::UnificationTable::with_log(&mut self.storage.unification_table, self.undo_log)\n     }\n }"}, {"sha": "4f49f4165074fd673c44a94ebdd05fb32f50eb4c", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -85,15 +85,12 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for OpportunisticRegionResolver<'a, 'tcx\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => {\n-                let resolved = self\n-                    .infcx\n-                    .inner\n-                    .borrow_mut()\n-                    .unwrap_region_constraints()\n-                    .opportunistic_resolve_var(rid);\n-                TypeFolder::interner(self).mk_re_var(resolved)\n-            }\n+            ty::ReVar(vid) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n+                .opportunistic_resolve_var(TypeFolder::interner(self), vid),\n             _ => r,\n         }\n     }"}, {"sha": "e604e44a7157b8876180aa57810a5808fb842c0f", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -26,7 +26,6 @@\n #endif\n #include \"llvm/Support/Host.h\"\n #include \"llvm/Target/TargetMachine.h\"\n-#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n #include \"llvm/Transforms/IPO/FunctionImport.h\"\n #include \"llvm/Transforms/IPO/Internalize.h\"\n@@ -35,7 +34,6 @@\n #include \"llvm/Transforms/Utils/FunctionImportUtils.h\"\n #include \"llvm/LTO/LTO.h\"\n #include \"llvm/Bitcode/BitcodeWriter.h\"\n-#include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n #include \"llvm/Transforms/Instrumentation.h\"\n #include \"llvm/Transforms/Instrumentation/AddressSanitizer.h\""}, {"sha": "7fbe3bc2888c3ca768699c44f7a6f9f549ef4b81", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -6,8 +6,8 @@ use crate::diagnostics::error::{\n };\n use crate::diagnostics::utils::{\n     build_field_mapping, is_doc_comment, report_error_if_not_applied_to_span, report_type_error,\n-    should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo, FieldInnerTy, FieldMap,\n-    HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n+    should_generate_set_arg, type_is_bool, type_is_unit, type_matches_path, FieldInfo,\n+    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n@@ -414,12 +414,15 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n             }\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n-                if type_matches_path(info.ty.inner_type(), &[\"rustc_span\", \"Span\"]) {\n+                let inner = info.ty.inner_type();\n+                if type_matches_path(inner, &[\"rustc_span\", \"Span\"]) {\n                     Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n-                } else if type_is_unit(info.ty.inner_type()) {\n+                } else if type_is_unit(inner)\n+                    || (matches!(info.ty, FieldInnerTy::Plain(_)) && type_is_bool(inner))\n+                {\n                     Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n-                    report_type_error(attr, \"`Span` or `()`\")?\n+                    report_type_error(attr, \"`Span`, `bool` or `()`\")?\n                 }\n             }\n             SubdiagnosticKind::Suggestion {"}, {"sha": "65bb154d7f39d396a0e23bc611c043b9b9f891e1", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -50,6 +50,11 @@ pub(crate) fn type_is_unit(ty: &Type) -> bool {\n     if let Type::Tuple(TypeTuple { elems, .. }) = ty { elems.is_empty() } else { false }\n }\n \n+/// Checks whether the type `ty` is `bool`.\n+pub(crate) fn type_is_bool(ty: &Type) -> bool {\n+    type_matches_path(ty, &[\"bool\"])\n+}\n+\n /// Reports a type error for field with `attr`.\n pub(crate) fn report_type_error(\n     attr: &Attribute,\n@@ -192,6 +197,11 @@ impl<'ty> FieldInnerTy<'ty> {\n                     #inner\n                 }\n             },\n+            FieldInnerTy::Plain(t) if type_is_bool(t) => quote! {\n+                if #binding {\n+                    #inner\n+                }\n+            },\n             FieldInnerTy::Plain(..) => quote! { #inner },\n         }\n     }"}, {"sha": "55ea78c0474e092c80c37de940db95c3f4b99c62", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -94,7 +94,8 @@ macro_rules! arena_types {\n             [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n             [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<'tcx>,\n             [decode] attribute: rustc_ast::Attribute,\n-            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>,\n+            [] name_set: rustc_data_structures::unord::UnordSet<rustc_span::symbol::Symbol>,\n+            [] ordered_name_set: rustc_data_structures::fx::FxIndexSet<rustc_span::symbol::Symbol>,\n             [] hir_id_set: rustc_hir::HirIdSet,\n \n             // Interned types"}, {"sha": "d83a587a86ae6f4b8f22cfb17f084d59e55981c0", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Region, Ty, TyCtxt};\n use rustc_data_structures::unify::{NoError, UnifyKey, UnifyValue};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::Symbol;\n@@ -11,7 +11,20 @@ pub trait ToType {\n }\n \n #[derive(PartialEq, Copy, Clone, Debug)]\n-pub struct UnifiedRegion<'tcx>(pub Option<ty::Region<'tcx>>);\n+pub struct UnifiedRegion<'tcx> {\n+    value: Option<ty::Region<'tcx>>,\n+}\n+\n+impl<'tcx> UnifiedRegion<'tcx> {\n+    pub fn new(value: Option<Region<'tcx>>) -> Self {\n+        Self { value }\n+    }\n+\n+    /// The caller is responsible for checking universe compatibility before using this value.\n+    pub fn get_value_ignoring_universes(self) -> Option<Region<'tcx>> {\n+        self.value\n+    }\n+}\n \n #[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RegionVidKey<'tcx> {\n@@ -44,11 +57,27 @@ impl<'tcx> UnifyValue for UnifiedRegion<'tcx> {\n     type Error = NoError;\n \n     fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n-        Ok(match (value1.0, value2.0) {\n+        // We pick the value of the least universe because it is compatible with more variables.\n+        // This is *not* neccessary for soundness, but it allows more region variables to be\n+        // resolved to the said value.\n+        #[cold]\n+        fn min_universe<'tcx>(r1: Region<'tcx>, r2: Region<'tcx>) -> Region<'tcx> {\n+            cmp::min_by_key(r1, r2, |r| match r.kind() {\n+                ty::ReStatic\n+                | ty::ReErased\n+                | ty::ReFree(..)\n+                | ty::ReEarlyBound(..)\n+                | ty::ReError(_) => ty::UniverseIndex::ROOT,\n+                ty::RePlaceholder(placeholder) => placeholder.universe,\n+                ty::ReVar(..) | ty::ReLateBound(..) => bug!(\"not a universal region\"),\n+            })\n+        }\n+\n+        Ok(match (value1.value, value2.value) {\n             // Here we can just pick one value, because the full constraints graph\n             // will be handled later. Ideally, we might want a `MultipleValues`\n             // variant or something. For now though, this is fine.\n-            (Some(_), Some(_)) => *value1,\n+            (Some(val1), Some(val2)) => Self { value: Some(min_universe(val1, val2)) },\n \n             (Some(_), _) => *value1,\n             (_, Some(_)) => *value2,"}, {"sha": "5215e3db798a228bd71d8ae5e1ca1d0b8f36b93d", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1453,6 +1453,9 @@ impl Debug for Statement<'_> {\n                 write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index)\n             }\n             Deinit(ref place) => write!(fmt, \"Deinit({:?})\", place),\n+            PlaceMention(ref place) => {\n+                write!(fmt, \"PlaceMention({:?})\", place)\n+            }\n             AscribeUserType(box (ref place, ref c_ty), ref variance) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }"}, {"sha": "d85d68870d7d81e123b45b1a30366e7e2a75cd71", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,13 +2,13 @@\n \n use crate::mir::{Body, ConstantKind, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n@@ -123,7 +123,7 @@ pub struct UnsafetyCheckResult {\n     pub violations: Vec<UnsafetyViolation>,\n \n     /// Used `unsafe` blocks in this function. This is used for the \"unused_unsafe\" lint.\n-    pub used_unsafe_blocks: FxHashSet<hir::HirId>,\n+    pub used_unsafe_blocks: UnordSet<hir::HirId>,\n \n     /// This is `Some` iff the item is not a closure.\n     pub unused_unsafes: Option<Vec<(hir::HirId, UnusedUnsafe)>>,\n@@ -289,13 +289,6 @@ pub struct ConstQualifs {\n /// instance of the closure is created, the corresponding free regions\n /// can be extracted from its type and constrained to have the given\n /// outlives relationship.\n-///\n-/// In some cases, we have to record outlives requirements between types and\n-/// regions as well. In that case, if those types include any regions, those\n-/// regions are recorded using their external names (`ReStatic`,\n-/// `ReEarlyBound`, `ReFree`). We use these because in a query response we\n-/// cannot use `ReVar` (which is what we use internally within the rest of the\n-/// NLL code).\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n     /// The number of external regions defined on the closure. In our\n@@ -392,16 +385,59 @@ pub enum ClosureOutlivesSubject<'tcx> {\n     /// Subject is a type, typically a type parameter, but could also\n     /// be a projection. Indicates a requirement like `T: 'a` being\n     /// passed to the caller, where the type here is `T`.\n-    ///\n-    /// The type here is guaranteed not to contain any free regions at\n-    /// present.\n-    Ty(Ty<'tcx>),\n+    Ty(ClosureOutlivesSubjectTy<'tcx>),\n \n     /// Subject is a free region from the closure. Indicates a requirement\n     /// like `'a: 'b` being passed to the caller; the region here is `'a`.\n     Region(ty::RegionVid),\n }\n \n+/// Represents a `ty::Ty` for use in [`ClosureOutlivesSubject`].\n+///\n+/// This abstraction is necessary because the type may include `ReVar` regions,\n+/// which is what we use internally within NLL code, and they can't be used in\n+/// a query response.\n+///\n+/// DO NOT implement `TypeVisitable` or `TypeFoldable` traits, because this\n+/// type is not recognized as a binder for late-bound region.\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct ClosureOutlivesSubjectTy<'tcx> {\n+    inner: Ty<'tcx>,\n+}\n+\n+impl<'tcx> ClosureOutlivesSubjectTy<'tcx> {\n+    /// All regions of `ty` must be of kind `ReVar` and must represent\n+    /// universal regions *external* to the closure.\n+    pub fn bind(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n+        let inner = tcx.fold_regions(ty, |r, depth| match r.kind() {\n+            ty::ReVar(vid) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::new(vid.index()),\n+                    kind: ty::BrAnon(vid.as_u32(), None),\n+                };\n+                tcx.mk_re_late_bound(depth, br)\n+            }\n+            _ => bug!(\"unexpected region in ClosureOutlivesSubjectTy: {r:?}\"),\n+        });\n+\n+        Self { inner }\n+    }\n+\n+    pub fn instantiate(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        mut map: impl FnMut(ty::RegionVid) -> ty::Region<'tcx>,\n+    ) -> Ty<'tcx> {\n+        tcx.fold_regions(self.inner, |r, depth| match r.kind() {\n+            ty::ReLateBound(debruijn, br) => {\n+                debug_assert_eq!(debruijn, depth);\n+                map(ty::RegionVid::new(br.var.index()))\n+            }\n+            _ => bug!(\"unexpected region {r:?}\"),\n+        })\n+    }\n+}\n+\n /// The constituent parts of a mir constant of kind ADT or array.\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct DestructuredConstant<'tcx> {"}, {"sha": "1a23f9dadd4f4922bd70df0a3e93a497229af96c", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -247,6 +247,7 @@ pub fn statement_kind_name(statement: &Statement<'_>) -> &'static str {\n         StorageLive(..) => \"StorageLive\",\n         StorageDead(..) => \"StorageDead\",\n         Retag(..) => \"Retag\",\n+        PlaceMention(..) => \"PlaceMention\",\n         AscribeUserType(..) => \"AscribeUserType\",\n         Coverage(..) => \"Coverage\",\n         Intrinsic(..) => \"Intrinsic\",\n@@ -265,7 +266,6 @@ pub fn terminator_kind_name(term: &Terminator<'_>) -> &'static str {\n         Return => \"Return\",\n         Unreachable => \"Unreachable\",\n         Drop { .. } => \"Drop\",\n-        DropAndReplace { .. } => \"DropAndReplace\",\n         Call { .. } => \"Call\",\n         Assert { .. } => \"Assert\",\n         Yield { .. } => \"Yield\","}, {"sha": "9312e27df378a422831c571cd89ffed8c2ad0725", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 9, "deletions": 38, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -133,7 +133,6 @@ pub enum AnalysisPhase {\n pub enum RuntimePhase {\n     /// In addition to the semantic changes, beginning with this phase, the following variants are\n     /// disallowed:\n-    /// * [`TerminatorKind::DropAndReplace`]\n     /// * [`TerminatorKind::Yield`]\n     /// * [`TerminatorKind::GeneratorDrop`]\n     /// * [`Rvalue::Aggregate`] for any `AggregateKind` except `Array`\n@@ -326,6 +325,15 @@ pub enum StatementKind<'tcx> {\n     /// Only `RetagKind::Default` and `RetagKind::FnEntry` are permitted.\n     Retag(RetagKind, Box<Place<'tcx>>),\n \n+    /// This statement exists to preserve a trace of a scrutinee matched against a wildcard binding.\n+    /// This is especially useful for `let _ = PLACE;` bindings that desugar to a single\n+    /// `PlaceMention(PLACE)`.\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    PlaceMention(Box<Place<'tcx>>),\n+\n     /// Encodes a user's type ascription. These need to be preserved\n     /// intact so that NLL can respect them. For example:\n     /// ```ignore (illustrative)\n@@ -596,43 +604,6 @@ pub enum TerminatorKind<'tcx> {\n     /// > consider indirect assignments.\n     Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n-    /// Drops the place and assigns a new value to it.\n-    ///\n-    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n-    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n-    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n-    /// explained by the elaboration:\n-    ///\n-    /// ```ignore (MIR)\n-    /// BB0 {\n-    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n-    /// }\n-    /// ```\n-    ///\n-    /// becomes\n-    ///\n-    /// ```ignore (MIR)\n-    /// BB0 {\n-    ///   Drop(P, goto BB1, unwind BB2)\n-    /// }\n-    /// BB1 {\n-    ///   // P is now uninitialized\n-    ///   P <- V\n-    /// }\n-    /// BB2 {\n-    ///   // P is now uninitialized -- its dtor panicked\n-    ///   P <- V\n-    /// }\n-    /// ```\n-    ///\n-    /// Disallowed after drop elaboration.\n-    DropAndReplace {\n-        place: Place<'tcx>,\n-        value: Operand<'tcx>,\n-        target: BasicBlock,\n-        unwind: Option<BasicBlock>,\n-    },\n-\n     /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n     /// the referred to function. The operand types must match the argument types of the function.\n     /// The return place type must match the return type. The type of the `func` operand must be"}, {"sha": "cd970270727f973f94ec95f1a183b6e6c81eaf42", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -148,7 +148,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | Call { target: None, cleanup: Some(t), .. }\n             | Call { target: Some(t), cleanup: None, .. }\n             | Yield { resume: t, drop: None, .. }\n-            | DropAndReplace { target: t, unwind: None, .. }\n             | Drop { target: t, unwind: None, .. }\n             | Assert { target: t, cleanup: None, .. }\n             | FalseUnwind { real_target: t, unwind: None }\n@@ -158,7 +157,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n             }\n             Call { target: Some(t), cleanup: Some(ref u), .. }\n             | Yield { resume: t, drop: Some(ref u), .. }\n-            | DropAndReplace { target: t, unwind: Some(ref u), .. }\n             | Drop { target: t, unwind: Some(ref u), .. }\n             | Assert { target: t, cleanup: Some(ref u), .. }\n             | FalseUnwind { real_target: t, unwind: Some(ref u) }\n@@ -188,7 +186,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | Call { target: None, cleanup: Some(ref mut t), .. }\n             | Call { target: Some(ref mut t), cleanup: None, .. }\n             | Yield { resume: ref mut t, drop: None, .. }\n-            | DropAndReplace { target: ref mut t, unwind: None, .. }\n             | Drop { target: ref mut t, unwind: None, .. }\n             | Assert { target: ref mut t, cleanup: None, .. }\n             | FalseUnwind { real_target: ref mut t, unwind: None }\n@@ -198,7 +195,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n             }\n             Call { target: Some(ref mut t), cleanup: Some(ref mut u), .. }\n             | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n-            | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n             | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n             | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n             | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) }\n@@ -225,7 +221,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::FalseEdge { .. } => None,\n             TerminatorKind::Call { cleanup: ref unwind, .. }\n             | TerminatorKind::Assert { cleanup: ref unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref unwind, .. }\n             | TerminatorKind::Drop { ref unwind, .. }\n             | TerminatorKind::FalseUnwind { ref unwind, .. }\n             | TerminatorKind::InlineAsm { cleanup: ref unwind, .. } => Some(unwind),\n@@ -245,7 +240,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::FalseEdge { .. } => None,\n             TerminatorKind::Call { cleanup: ref mut unwind, .. }\n             | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n             | TerminatorKind::Drop { ref mut unwind, .. }\n             | TerminatorKind::FalseUnwind { ref mut unwind, .. }\n             | TerminatorKind::InlineAsm { cleanup: ref mut unwind, .. } => Some(unwind),\n@@ -309,9 +303,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n             Unreachable => write!(fmt, \"unreachable\"),\n             Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n-            DropAndReplace { place, value, .. } => {\n-                write!(fmt, \"replace({:?} <- {:?})\", place, value)\n-            }\n             Call { func, args, destination, .. } => {\n                 write!(fmt, \"{:?} = \", destination)?;\n                 write!(fmt, \"{:?}(\", func)?;\n@@ -403,10 +394,10 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Call { target: None, cleanup: None, .. } => vec![],\n             Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n             Yield { drop: None, .. } => vec![\"resume\".into()],\n-            DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n+            Drop { unwind: None, .. } => {\n                 vec![\"return\".into()]\n             }\n-            DropAndReplace { unwind: Some(_), .. } | Drop { unwind: Some(_), .. } => {\n+            Drop { unwind: Some(_), .. } => {\n                 vec![\"return\".into(), \"unwind\".into()]\n             }\n             Assert { cleanup: None, .. } => vec![\"\".into()],"}, {"sha": "cbeacf21c19f0c12a055578cada6ba94d6947c90", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -405,6 +405,13 @@ macro_rules! make_mir_visitor {\n                     StatementKind::Retag(kind, place) => {\n                         self.visit_retag($(& $mutability)? *kind, place, location);\n                     }\n+                    StatementKind::PlaceMention(place) => {\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::NonUse(NonUseContext::PlaceMention),\n+                            location\n+                        );\n+                    }\n                     StatementKind::AscribeUserType(\n                         box (place, user_ty),\n                         variance\n@@ -495,20 +502,6 @@ macro_rules! make_mir_visitor {\n                         );\n                     }\n \n-                    TerminatorKind::DropAndReplace {\n-                        place,\n-                        value,\n-                        target: _,\n-                        unwind: _,\n-                    } => {\n-                        self.visit_place(\n-                            place,\n-                            PlaceContext::MutatingUse(MutatingUseContext::Drop),\n-                            location\n-                        );\n-                        self.visit_operand(value, location);\n-                    }\n-\n                     TerminatorKind::Call {\n                         func,\n                         args,\n@@ -1302,6 +1295,8 @@ pub enum NonUseContext {\n     AscribeUserTy,\n     /// The data of a user variable, for debug info.\n     VarDebugInfo,\n+    /// PlaceMention statement.\n+    PlaceMention,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "f15d71ba7943069642ae97f610d4f6305ed42e69", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -764,7 +764,7 @@ rustc_queries! {\n     ///\n     /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n-    query impl_item_implementor_ids(impl_id: DefId) -> &'tcx FxHashMap<DefId, DefId> {\n+    query impl_item_implementor_ids(impl_id: DefId) -> &'tcx DefIdMap<DefId> {\n         arena_cache\n         desc { |tcx| \"comparing impl items against trait for `{}`\", tcx.def_path_str(impl_id) }\n     }\n@@ -906,8 +906,8 @@ rustc_queries! {\n     /// The second return value maps from ADTs to ignored derived traits (e.g. Debug and Clone) and\n     /// their respective impl (i.e., part of the derive macro)\n     query live_symbols_and_ignored_derived_traits(_: ()) -> &'tcx (\n-        FxHashSet<LocalDefId>,\n-        FxHashMap<LocalDefId, Vec<(DefId, DefId)>>\n+        LocalDefIdSet,\n+        LocalDefIdMap<Vec<(DefId, DefId)>>\n     ) {\n         arena_cache\n         desc { \"finding live symbols in crate\" }\n@@ -1120,7 +1120,7 @@ rustc_queries! {\n         desc { \"checking for private elements in public interfaces\" }\n     }\n \n-    query reachable_set(_: ()) -> &'tcx FxHashSet<LocalDefId> {\n+    query reachable_set(_: ()) -> &'tcx LocalDefIdSet {\n         arena_cache\n         desc { \"reachability\" }\n     }\n@@ -1229,7 +1229,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query asm_target_features(def_id: DefId) -> &'tcx FxHashSet<Symbol> {\n+    query asm_target_features(def_id: DefId) -> &'tcx FxIndexSet<Symbol> {\n         desc { |tcx| \"computing target features for inline asm of `{}`\", tcx.def_path_str(def_id) }\n     }\n \n@@ -1845,7 +1845,7 @@ rustc_queries! {\n     query maybe_unused_trait_imports(_: ()) -> &'tcx FxIndexSet<LocalDefId> {\n         desc { \"fetching potentially unused trait imports\" }\n     }\n-    query names_imported_by_glob_use(def_id: LocalDefId) -> &'tcx FxHashSet<Symbol> {\n+    query names_imported_by_glob_use(def_id: LocalDefId) -> &'tcx UnordSet<Symbol> {\n         desc { |tcx| \"finding names imported by glob use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n "}, {"sha": "82da846ea68a5044921690ca739cdd53a1e26a67", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -36,6 +36,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, MappedReadGuard, ReadGuard, WorkerLocal};\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n };\n@@ -2486,7 +2487,9 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     providers.maybe_unused_trait_imports =\n         |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;\n     providers.names_imported_by_glob_use = |tcx, id| {\n-        tcx.arena.alloc(tcx.resolutions(()).glob_map.get(&id).cloned().unwrap_or_default())\n+        tcx.arena.alloc(UnordSet::from(\n+            tcx.resolutions(()).glob_map.get(&id).cloned().unwrap_or_default(),\n+        ))\n     };\n \n     providers.extern_mod_stmt_cnum ="}, {"sha": "ae0bb4949c743d608b69a0a522d5c271248cffe5", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -117,7 +117,7 @@ pub fn suggest_arbitrary_trait_bound<'tcx>(\n     }\n \n     let param_name = trait_pred.skip_binder().self_ty().to_string();\n-    let mut constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n+    let mut constraint = trait_pred.to_string();\n \n     if let Some((name, term)) = associated_ty {\n         // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n@@ -144,7 +144,7 @@ pub fn suggest_arbitrary_trait_bound<'tcx>(\n              this requirement\",\n             if generics.where_clause_span.is_empty() { \"introducing a\" } else { \"extending the\" },\n         ),\n-        format!(\"{} {}: {}\", generics.add_where_or_trailing_comma(), param_name, constraint),\n+        format!(\"{} {constraint}\", generics.add_where_or_trailing_comma()),\n         Applicability::MaybeIncorrect,\n     );\n     true"}, {"sha": "9548be4c1382feae5bba9667982c806e903802fa", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -41,7 +41,7 @@ use rustc_arena::TypedArena;\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n@@ -50,7 +50,9 @@ use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, DocLinkResMap};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n+use rustc_hir::def_id::{\n+    CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LocalDefIdMap, LocalDefIdSet,\n+};\n use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};"}, {"sha": "649a58c9170731896aa16dcda2ef1ae9156c9a38", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -100,8 +100,9 @@ impl<'tcx> TraitDef {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn for_each_impl<F: FnMut(DefId)>(self, def_id: DefId, mut f: F) {\n-        let impls = self.trait_impls_of(def_id);\n+    /// `trait_def_id` MUST BE the `DefId` of a trait.\n+    pub fn for_each_impl<F: FnMut(DefId)>(self, trait_def_id: DefId, mut f: F) {\n+        let impls = self.trait_impls_of(trait_def_id);\n \n         for &impl_def_id in impls.blanket_impls.iter() {\n             f(impl_def_id);\n@@ -114,26 +115,28 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Iterate over every impl that could possibly match the\n-    /// self type `self_ty`.\n+    /// Iterate over every impl that could possibly match the self type `self_ty`.\n+    ///\n+    /// `trait_def_id` MUST BE the `DefId` of a trait.\n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(\n         self,\n-        def_id: DefId,\n+        trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         mut f: F,\n     ) {\n-        let _: Option<()> = self.find_map_relevant_impl(def_id, self_ty, |did| {\n+        let _: Option<()> = self.find_map_relevant_impl(trait_def_id, self_ty, |did| {\n             f(did);\n             None\n         });\n     }\n \n+    /// `trait_def_id` MUST BE the `DefId` of a trait.\n     pub fn non_blanket_impls_for_ty(\n         self,\n-        def_id: DefId,\n+        trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n-        let impls = self.trait_impls_of(def_id);\n+        let impls = self.trait_impls_of(trait_def_id);\n         if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsInfer) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n@@ -145,9 +148,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Applies function to every impl that could possibly match the self type `self_ty` and returns\n     /// the first non-none value.\n+    ///\n+    /// `trait_def_id` MUST BE the `DefId` of a trait.\n     pub fn find_map_relevant_impl<T, F: FnMut(DefId) -> Option<T>>(\n         self,\n-        def_id: DefId,\n+        trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         mut f: F,\n     ) -> Option<T> {\n@@ -156,7 +161,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         //\n         // If we want to be faster, we could have separate queries for\n         // blanket and non-blanket impls, and compare them separately.\n-        let impls = self.trait_impls_of(def_id);\n+        let impls = self.trait_impls_of(trait_def_id);\n \n         for &impl_def_id in impls.blanket_impls.iter() {\n             if let result @ Some(_) = f(impl_def_id) {\n@@ -190,9 +195,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         None\n     }\n \n-    /// Returns an iterator containing all impls\n-    pub fn all_impls(self, def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n-        let TraitImpls { blanket_impls, non_blanket_impls } = self.trait_impls_of(def_id);\n+    /// Returns an iterator containing all impls for `trait_def_id`.\n+    ///\n+    /// `trait_def_id` MUST BE the `DefId` of a trait.\n+    pub fn all_impls(self, trait_def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n+        let TraitImpls { blanket_impls, non_blanket_impls } = self.trait_impls_of(trait_def_id);\n \n         blanket_impls.iter().chain(non_blanket_impls.iter().flat_map(|(_, v)| v)).cloned()\n     }"}, {"sha": "4f1623b4c6a7c543f0004317316b5e265ee08733", "filename": "compiler/rustc_mir_build/src/build/cfg.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -90,6 +90,17 @@ impl<'tcx> CFG<'tcx> {\n         self.push(block, stmt);\n     }\n \n+    pub(crate) fn push_place_mention(\n+        &mut self,\n+        block: BasicBlock,\n+        source_info: SourceInfo,\n+        place: Place<'tcx>,\n+    ) {\n+        let kind = StatementKind::PlaceMention(Box::new(place));\n+        let stmt = Statement { source_info, kind };\n+        self.push(block, stmt);\n+    }\n+\n     pub(crate) fn terminate(\n         &mut self,\n         block: BasicBlock,"}, {"sha": "5e77f2dc1268dbe16fdad7ef2d756392f7b0de61", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,6 @@\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::mir::tcx::PlaceTy;\n+use rustc_middle::ty::cast::mir_cast_kind;\n use rustc_middle::{mir::*, thir::*, ty};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n@@ -58,14 +59,6 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                     unwind: None,\n                 })\n             },\n-            @call(\"mir_drop_and_replace\", args) => {\n-                Ok(TerminatorKind::DropAndReplace {\n-                    place: self.parse_place(args[0])?,\n-                    value: self.parse_operand(args[1])?,\n-                    target: self.parse_block(args[2])?,\n-                    unwind: None,\n-                })\n-            },\n             @call(\"mir_call\", args) => {\n                 let destination = self.parse_place(args[0])?;\n                 let target = self.parse_block(args[1])?;\n@@ -142,7 +135,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n-        parse_by_kind!(self, expr_id, _, \"rvalue\",\n+        parse_by_kind!(self, expr_id, expr, \"rvalue\",\n             @call(\"mir_discriminant\", args) => self.parse_place(args[0]).map(Rvalue::Discriminant),\n             @call(\"mir_checked\", args) => {\n                 parse_by_kind!(self, args[0], _, \"binary op\",\n@@ -167,6 +160,12 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             ExprKind::Repeat { value, count } => Ok(\n                 Rvalue::Repeat(self.parse_operand(*value)?, *count)\n             ),\n+            ExprKind::Cast { source } => {\n+                let source = self.parse_operand(*source)?;\n+                let source_ty = source.ty(self.body.local_decls(), self.tcx);\n+                let cast_kind = mir_cast_kind(source_ty, expr.ty);\n+                Ok(Rvalue::Cast(cast_kind, source, expr.ty))\n+            },\n             _ => self.parse_operand(expr_id).map(Rvalue::Use),\n         )\n     }"}, {"sha": "32892e0ae119cb8ec29a842bb888e54f4643b806", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -556,6 +556,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             _ => {\n                 let place_builder = unpack!(block = self.as_place_builder(block, initializer));\n+\n+                if let Some(place) = place_builder.try_to_place(self) {\n+                    let source_info = self.source_info(initializer.span);\n+                    self.cfg.push_place_mention(block, source_info, place);\n+                }\n+\n                 self.place_into_pattern(block, &irrefutable_pat, place_builder, true)\n             }\n         }\n@@ -576,6 +582,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             false,\n             &mut [&mut candidate],\n         );\n+\n         // For matches and function arguments, the place that is being matched\n         // can be set when creating the variables. But the place for\n         // let PATTERN = ... might not even exist until we do the assignment."}, {"sha": "4bc2c0ca791e6a305744ce47d866110538b30644", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1072,7 +1072,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 TerminatorKind::Assert { .. }\n                     | TerminatorKind::Call { .. }\n                     | TerminatorKind::Drop { .. }\n-                    | TerminatorKind::DropAndReplace { .. }\n                     | TerminatorKind::FalseUnwind { .. }\n                     | TerminatorKind::InlineAsm { .. }\n             ),\n@@ -1432,8 +1431,7 @@ impl<'tcx> DropTreeBuilder<'tcx> for Unwind {\n                     *unwind = Some(to);\n                 }\n             }\n-            TerminatorKind::DropAndReplace { unwind, .. }\n-            | TerminatorKind::FalseUnwind { unwind, .. }\n+            TerminatorKind::FalseUnwind { unwind, .. }\n             | TerminatorKind::Call { cleanup: unwind, .. }\n             | TerminatorKind::Assert { cleanup: unwind, .. }\n             | TerminatorKind::InlineAsm { cleanup: unwind, .. } => {"}, {"sha": "f6db329fd7cfe9820f220bf5cd79337e8a62b20a", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -128,7 +128,6 @@ impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n             TerminatorKind::Assert { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::Goto { .. }"}, {"sha": "a40c38aa4c3334ed9e721cacbb6802c005f81030", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -480,7 +480,6 @@ impl Direction for Forward {\n \n             Assert { target, cleanup: unwind, expected: _, msg: _, cond: _ }\n             | Drop { target, unwind, place: _ }\n-            | DropAndReplace { target, unwind, value: _, place: _ }\n             | FalseUnwind { real_target: target, unwind } => {\n                 if let Some(unwind) = unwind {\n                     propagate(unwind, exit_state);"}, {"sha": "08fadfe68a17a2ad848cb81a6b11df415b0ab13a", "filename": "compiler/rustc_mir_dataflow/src/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -111,8 +111,7 @@ where\n         self.super_terminator(terminator, location);\n \n         match terminator.kind {\n-            mir::TerminatorKind::Drop { place: dropped_place, .. }\n-            | mir::TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n+            mir::TerminatorKind::Drop { place: dropped_place, .. } => {\n                 // Drop terminators may call custom drop glue (`Drop::drop`), which takes `&mut\n                 // self` as a parameter. In the general case, a drop impl could launder that\n                 // reference into the surrounding environment through a raw pointer, thus creating"}, {"sha": "bc67aa476f1af3459a8e396e76425bb2435413f7", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -263,6 +263,7 @@ impl<'a, 'tcx> Analysis<'tcx> for MaybeTransitiveLiveLocals<'a> {\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag(..)\n             | StatementKind::AscribeUserType(..)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n             | StatementKind::ConstEvalCounter"}, {"sha": "99988b29e8a576b5a6fc46fbdaa3c437c67306ca", "filename": "compiler/rustc_mir_dataflow/src/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -139,6 +139,7 @@ impl<'mir, 'tcx> crate::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tc\n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added.\n             StatementKind::AscribeUserType(..)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::FakeRead(..)\n             | StatementKind::ConstEvalCounter\n@@ -202,7 +203,6 @@ impl<'mir, 'tcx> crate::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tc\n             TerminatorKind::Abort\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::GeneratorDrop\n@@ -240,7 +240,6 @@ impl<'mir, 'tcx> crate::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tc\n             | TerminatorKind::Abort\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::GeneratorDrop"}, {"sha": "d9ceac1154f4a4e0ab5dbd12e6b8579d1e3d552c", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -329,6 +329,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             }\n             StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n             | StatementKind::ConstEvalCounter\n@@ -392,11 +393,6 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.create_move_path(place);\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n-            TerminatorKind::DropAndReplace { place, ref value, .. } => {\n-                self.create_move_path(place);\n-                self.gather_operand(value);\n-                self.gather_init(place.as_ref(), InitKind::Deep);\n-            }\n             TerminatorKind::Call {\n                 ref func,\n                 ref args,"}, {"sha": "7f560d6119428dad7a1be4467d45dd2663387133", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -86,6 +86,7 @@ pub trait ValueAnalysis<'tcx> {\n             StatementKind::ConstEvalCounter\n             | StatementKind::Nop\n             | StatementKind::FakeRead(..)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::AscribeUserType(..) => (),\n         }\n@@ -230,7 +231,7 @@ pub trait ValueAnalysis<'tcx> {\n             TerminatorKind::Drop { place, .. } => {\n                 state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n             }\n-            TerminatorKind::DropAndReplace { .. } | TerminatorKind::Yield { .. } => {\n+            TerminatorKind::Yield { .. } => {\n                 // They would have an effect, but are not allowed in this phase.\n                 bug!(\"encountered disallowed terminator\");\n             }\n@@ -690,7 +691,7 @@ impl Map {\n         }\n \n         // Recurse with all fields of this place.\n-        iter_fields(ty, tcx, |variant, field, ty| {\n+        iter_fields(ty, tcx, ty::ParamEnv::reveal_all(), |variant, field, ty| {\n             if let Some(variant) = variant {\n                 projection.push(PlaceElem::Downcast(None, variant));\n                 let _ = self.make_place(local, projection);\n@@ -939,6 +940,7 @@ impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n pub fn iter_fields<'tcx>(\n     ty: Ty<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     mut f: impl FnMut(Option<VariantIdx>, Field, Ty<'tcx>),\n ) {\n     match ty.kind() {\n@@ -956,14 +958,14 @@ pub fn iter_fields<'tcx>(\n                 for (f_index, f_def) in v_def.fields.iter().enumerate() {\n                     let field_ty = f_def.ty(tcx, substs);\n                     let field_ty = tcx\n-                        .try_normalize_erasing_regions(ty::ParamEnv::reveal_all(), field_ty)\n-                        .unwrap_or(field_ty);\n+                        .try_normalize_erasing_regions(param_env, field_ty)\n+                        .unwrap_or_else(|_| tcx.erase_regions(field_ty));\n                     f(variant, f_index.into(), field_ty);\n                 }\n             }\n         }\n         ty::Closure(_, substs) => {\n-            iter_fields(substs.as_closure().tupled_upvars_ty(), tcx, f);\n+            iter_fields(substs.as_closure().tupled_upvars_ty(), tcx, param_env, f);\n         }\n         _ => (),\n     }"}, {"sha": "893018e0d8e7370751e8da6155976339eaa02b85", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n                     };\n                     layout::fn_can_unwind(tcx, fn_def_id, sig.abi())\n                 }\n-                TerminatorKind::Drop { .. } | TerminatorKind::DropAndReplace { .. } => {\n+                TerminatorKind::Drop { .. } => {\n                     tcx.sess.opts.unstable_opts.panic_in_drop == PanicStrategy::Unwind\n                         && layout::fn_can_unwind(tcx, None, Abi::Rust)\n                 }"}, {"sha": "896fcd9cdd6086a9aae2b3e1964e22f76b974c30", "filename": "compiler/rustc_mir_transform/src/add_moves_for_packed_drops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -64,9 +64,6 @@ fn add_moves_for_packed_drops_patch<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>)\n             {\n                 add_move_for_packed_drop(tcx, body, &mut patch, terminator, loc, data.is_cleanup);\n             }\n-            TerminatorKind::DropAndReplace { .. } => {\n-                span_bug!(terminator.source_info.span, \"replace in AddMovesForPackedDrops\");\n-            }\n             _ => {}\n         }\n     }"}, {"sha": "916f2904dda809e40a5eaf6c6249c09669e61d70", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n                     }\n \n                     // `Drop` is also a call, but it doesn't return anything so we are good.\n-                    TerminatorKind::Drop { .. } | TerminatorKind::DropAndReplace { .. } => None,\n+                    TerminatorKind::Drop { .. } => None,\n                     // Not a block ending in a Call -> ignore.\n                     _ => None,\n                 }"}, {"sha": "a8ec568eb0d76f2223d14514bcf6bf45979b7516", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::unord::{UnordItems, UnordSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -24,7 +24,7 @@ pub struct UnsafetyChecker<'a, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n \n     /// Used `unsafe` blocks in this function. This is used for the \"unused_unsafe\" lint.\n-    used_unsafe_blocks: FxHashSet<HirId>,\n+    used_unsafe_blocks: UnordSet<HirId>,\n }\n \n impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n@@ -55,7 +55,6 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::Assert { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n@@ -101,13 +100,16 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             | StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n             | StatementKind::Retag { .. }\n-            | StatementKind::AscribeUserType(..)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n             | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }\n+            // `AscribeUserType` just exists to help MIR borrowck.\n+            // It has no semantics, and everything is already reported by `PlaceMention`.\n+            StatementKind::AscribeUserType(..) => return,\n         }\n         self.super_statement(statement, location);\n     }\n@@ -129,7 +131,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n                     let def_id = def_id.expect_local();\n                     let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n                         self.tcx.unsafety_check_result(def_id);\n-                    self.register_violations(violations, used_unsafe_blocks.iter().copied());\n+                    self.register_violations(violations, used_unsafe_blocks.items().copied());\n                 }\n             },\n             _ => {}\n@@ -151,7 +153,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n                         let local_def_id = def_id.expect_local();\n                         let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n                             self.tcx.unsafety_check_result(local_def_id);\n-                        self.register_violations(violations, used_unsafe_blocks.iter().copied());\n+                        self.register_violations(violations, used_unsafe_blocks.items().copied());\n                     }\n                 }\n             }\n@@ -268,14 +270,14 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n             .lint_root;\n         self.register_violations(\n             [&UnsafetyViolation { source_info, lint_root, kind, details }],\n-            [],\n+            UnordItems::empty(),\n         );\n     }\n \n     fn register_violations<'a>(\n         &mut self,\n         violations: impl IntoIterator<Item = &'a UnsafetyViolation>,\n-        new_used_unsafe_blocks: impl IntoIterator<Item = HirId>,\n+        new_used_unsafe_blocks: UnordItems<HirId, impl Iterator<Item = HirId>>,\n     ) {\n         let safety = self.body.source_scopes[self.source_info.scope]\n             .local_data\n@@ -308,9 +310,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n             }),\n         };\n \n-        new_used_unsafe_blocks.into_iter().for_each(|hir_id| {\n-            self.used_unsafe_blocks.insert(hir_id);\n-        });\n+        self.used_unsafe_blocks.extend_unord(new_used_unsafe_blocks);\n     }\n     fn check_mut_borrowing_layout_constrained_field(\n         &mut self,\n@@ -407,7 +407,7 @@ enum Context {\n \n struct UnusedUnsafeVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    used_unsafe_blocks: &'a FxHashSet<HirId>,\n+    used_unsafe_blocks: &'a UnordSet<HirId>,\n     context: Context,\n     unused_unsafes: &'a mut Vec<(HirId, UnusedUnsafe)>,\n }\n@@ -458,7 +458,7 @@ impl<'tcx> intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'_, 'tcx> {\n fn check_unused_unsafe(\n     tcx: TyCtxt<'_>,\n     def_id: LocalDefId,\n-    used_unsafe_blocks: &FxHashSet<HirId>,\n+    used_unsafe_blocks: &UnordSet<HirId>,\n ) -> Vec<(HirId, UnusedUnsafe)> {\n     let body_id = tcx.hir().maybe_body_owned_by(def_id);\n \n@@ -505,7 +505,7 @@ fn unsafety_check_result(\n     if body.is_custom_mir() {\n         return tcx.arena.alloc(UnsafetyCheckResult {\n             violations: Vec::new(),\n-            used_unsafe_blocks: FxHashSet::default(),\n+            used_unsafe_blocks: Default::default(),\n             unused_unsafes: Some(Vec::new()),\n         });\n     }"}, {"sha": "0923824db4888a0aebb7126e3c8f2e7fda53cde5", "filename": "compiler/rustc_mir_transform/src/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -24,6 +24,7 @@ impl<'tcx> MirPass<'tcx> for CleanupPostBorrowck {\n             for statement in basic_block.statements.iter_mut() {\n                 match statement.kind {\n                     StatementKind::AscribeUserType(..)\n+                    | StatementKind::PlaceMention(..)\n                     | StatementKind::Assign(box (_, Rvalue::Ref(_, BorrowKind::Shallow, _)))\n                     | StatementKind::FakeRead(..) => statement.make_nop(),\n                     _ => (),"}, {"sha": "9bc4b26db92ebd34a5fd6c4406cf5281479de17d", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1007,7 +1007,6 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }"}, {"sha": "77402b8737e24141149c55716448b0039b90ed78", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -686,7 +686,6 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }"}, {"sha": "0e7dc171a5d0c456a64869012875d89e16e71f16", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -822,7 +822,6 @@ pub(super) fn term_type(kind: &TerminatorKind<'_>) -> &'static str {\n         TerminatorKind::Return => \"Return\",\n         TerminatorKind::Unreachable => \"Unreachable\",\n         TerminatorKind::Drop { .. } => \"Drop\",\n-        TerminatorKind::DropAndReplace { .. } => \"DropAndReplace\",\n         TerminatorKind::Call { .. } => \"Call\",\n         TerminatorKind::Assert { .. } => \"Assert\",\n         TerminatorKind::Yield { .. } => \"Yield\","}, {"sha": "c03cacd8615e397a7f1550c69e339119ed88ea79", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -156,7 +156,6 @@ impl CoverageGraph {\n                 | TerminatorKind::Resume\n                 | TerminatorKind::Unreachable\n                 | TerminatorKind::Drop { .. }\n-                | TerminatorKind::DropAndReplace { .. }\n                 | TerminatorKind::Call { .. }\n                 | TerminatorKind::GeneratorDrop\n                 | TerminatorKind::Assert { .. }"}, {"sha": "2f1202586594a4b8af259c9f9acf2dda2effb7ba", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -832,6 +832,7 @@ pub(super) fn filtered_statement_span(statement: &Statement<'_>) -> Option<Span>\n         | StatementKind::SetDiscriminant { .. }\n         | StatementKind::Deinit(..)\n         | StatementKind::Retag(_, _)\n+        | StatementKind::PlaceMention(..)\n         | StatementKind::AscribeUserType(_, _) => {\n             Some(statement.source_info.span)\n         }\n@@ -850,7 +851,6 @@ pub(super) fn filtered_terminator_span(terminator: &Terminator<'_>) -> Option<Sp\n         TerminatorKind::Unreachable // Unreachable blocks are not connected to the MIR CFG\n         | TerminatorKind::Assert { .. }\n         | TerminatorKind::Drop { .. }\n-        | TerminatorKind::DropAndReplace { .. }\n         | TerminatorKind::SwitchInt { .. }\n         // For `FalseEdge`, only the `real` branch is taken, so it is similar to a `Goto`.\n         | TerminatorKind::FalseEdge { .. }"}, {"sha": "aded8039dc313522ca86f91b13aae7a1904c9857", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -86,7 +86,6 @@ impl<'tcx> MockBlocks<'tcx> {\n             TerminatorKind::Assert { ref mut target, .. }\n             | TerminatorKind::Call { target: Some(ref mut target), .. }\n             | TerminatorKind::Drop { ref mut target, .. }\n-            | TerminatorKind::DropAndReplace { ref mut target, .. }\n             | TerminatorKind::FalseEdge { real_target: ref mut target, .. }\n             | TerminatorKind::FalseUnwind { real_target: ref mut target, .. }\n             | TerminatorKind::Goto { ref mut target }\n@@ -184,7 +183,6 @@ fn debug_basic_blocks(mir_body: &Body<'_>) -> String {\n                     TerminatorKind::Assert { target, .. }\n                     | TerminatorKind::Call { target: Some(target), .. }\n                     | TerminatorKind::Drop { target, .. }\n-                    | TerminatorKind::DropAndReplace { target, .. }\n                     | TerminatorKind::FalseEdge { real_target: target, .. }\n                     | TerminatorKind::FalseUnwind { real_target: target, .. }\n                     | TerminatorKind::Goto { target }"}, {"sha": "18c407b42d373f1079a49b8b3ca3b0af25a484e3", "filename": "compiler/rustc_mir_transform/src/dead_store_elimination.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -56,7 +56,9 @@ pub fn eliminate<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, borrowed: &BitS\n                 | StatementKind::ConstEvalCounter\n                 | StatementKind::Nop => (),\n \n-                StatementKind::FakeRead(_) | StatementKind::AscribeUserType(_, _) => {\n+                StatementKind::FakeRead(_)\n+                | StatementKind::PlaceMention(_)\n+                | StatementKind::AscribeUserType(_, _) => {\n                     bug!(\"{:?} not found in this MIR phase!\", &statement.kind)\n                 }\n             }"}, {"sha": "7344ec793ea6a572dcaaf45f6ad996237e2af99d", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -583,7 +583,9 @@ impl WriteInfo {\n             | StatementKind::Coverage(_)\n             | StatementKind::StorageLive(_)\n             | StatementKind::StorageDead(_) => (),\n-            StatementKind::FakeRead(_) | StatementKind::AscribeUserType(_, _) => {\n+            StatementKind::FakeRead(_)\n+            | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::PlaceMention(_) => {\n                 bug!(\"{:?} not found in this MIR phase\", statement)\n             }\n         }\n@@ -650,8 +652,7 @@ impl WriteInfo {\n             TerminatorKind::Drop { .. } => {\n                 // `Drop`s create a `&mut` and so are not considered\n             }\n-            TerminatorKind::DropAndReplace { .. }\n-            | TerminatorKind::Yield { .. }\n+            TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. } => {"}, {"sha": "3faccca823a576fd22a1512626d8c83ec1f0dc27", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 114, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -18,15 +18,14 @@ use rustc_span::{DesugaringKind, Span};\n use rustc_target::abi::VariantIdx;\n use std::fmt;\n \n-/// During MIR building, Drop and DropAndReplace terminators are inserted in every place where a drop may occur.\n+/// During MIR building, Drop terminators are inserted in every place where a drop may occur.\n /// However, in this phase, the presence of these terminators does not guarantee that a destructor will run,\n /// as the target of the drop may be uninitialized.\n /// In general, the compiler cannot determine at compile time whether a destructor will run or not.\n ///\n-/// At a high level, this pass refines Drop and DropAndReplace to only run the destructor if the\n+/// At a high level, this pass refines Drop to only run the destructor if the\n /// target is initialized. The way this is achievied is by inserting drop flags for every variable\n /// that may be dropped, and then using those flags to determine whether a destructor should run.\n-/// This pass also removes DropAndReplace, replacing it with a Drop paired with an assign statement.\n /// Once this is complete, Drop terminators in the MIR correspond to a call to the \"drop glue\" or\n /// \"drop shim\" for the type of the dropped place.\n ///\n@@ -121,8 +120,7 @@ fn remove_dead_unwinds<'tcx>(\n         .into_results_cursor(body);\n     for (bb, bb_data) in body.basic_blocks.iter_enumerated() {\n         let place = match bb_data.terminator().kind {\n-            TerminatorKind::Drop { ref place, unwind: Some(_), .. }\n-            | TerminatorKind::DropAndReplace { ref place, unwind: Some(_), .. } => {\n+            TerminatorKind::Drop { ref place, unwind: Some(_), .. } => {\n                 und.derefer(place.as_ref(), body).unwrap_or(*place)\n             }\n             _ => continue,\n@@ -343,8 +341,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             }\n             let terminator = data.terminator();\n             let place = match terminator.kind {\n-                TerminatorKind::Drop { ref place, .. }\n-                | TerminatorKind::DropAndReplace { ref place, .. } => {\n+                TerminatorKind::Drop { ref place, .. } => {\n                     self.un_derefer.derefer(place.as_ref(), self.body).unwrap_or(*place)\n                 }\n                 _ => continue,\n@@ -441,103 +438,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         }\n                     }\n                 }\n-                TerminatorKind::DropAndReplace { mut place, ref value, target, unwind } => {\n-                    assert!(!data.is_cleanup);\n-\n-                    if let Some(new_place) = self.un_derefer.derefer(place.as_ref(), self.body) {\n-                        place = new_place;\n-                    }\n-                    self.elaborate_replace(loc, place, value, target, unwind);\n-                }\n                 _ => continue,\n             }\n         }\n     }\n \n-    /// Elaborate a MIR `replace` terminator. This instruction\n-    /// is not directly handled by codegen, and therefore\n-    /// must be desugared.\n-    ///\n-    /// The desugaring drops the location if needed, and then writes\n-    /// the value (including setting the drop flag) over it in *both* arms.\n-    ///\n-    /// The `replace` terminator can also be called on places that\n-    /// are not tracked by elaboration (for example,\n-    /// `replace x[i] <- tmp0`). The borrow checker requires that\n-    /// these locations are initialized before the assignment,\n-    /// so we just generate an unconditional drop.\n-    fn elaborate_replace(\n-        &mut self,\n-        loc: Location,\n-        place: Place<'tcx>,\n-        value: &Operand<'tcx>,\n-        target: BasicBlock,\n-        unwind: Option<BasicBlock>,\n-    ) {\n-        let bb = loc.block;\n-        let data = &self.body[bb];\n-        let terminator = data.terminator();\n-        assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n-\n-        let assign = Statement {\n-            kind: StatementKind::Assign(Box::new((place, Rvalue::Use(value.clone())))),\n-            source_info: terminator.source_info,\n-        };\n-\n-        let unwind = unwind.unwrap_or_else(|| self.patch.resume_block());\n-        let unwind = self.patch.new_block(BasicBlockData {\n-            statements: vec![assign.clone()],\n-            terminator: Some(Terminator {\n-                kind: TerminatorKind::Goto { target: unwind },\n-                ..*terminator\n-            }),\n-            is_cleanup: true,\n-        });\n-\n-        let target = self.patch.new_block(BasicBlockData {\n-            statements: vec![assign],\n-            terminator: Some(Terminator { kind: TerminatorKind::Goto { target }, ..*terminator }),\n-            is_cleanup: false,\n-        });\n-\n-        match self.move_data().rev_lookup.find(place.as_ref()) {\n-            LookupResult::Exact(path) => {\n-                debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n-                self.init_data.seek_before(loc);\n-                elaborate_drop(\n-                    &mut Elaborator { ctxt: self },\n-                    terminator.source_info,\n-                    place,\n-                    path,\n-                    target,\n-                    Unwind::To(unwind),\n-                    bb,\n-                );\n-                on_all_children_bits(self.tcx, self.body, self.move_data(), path, |child| {\n-                    self.set_drop_flag(\n-                        Location { block: target, statement_index: 0 },\n-                        child,\n-                        DropFlagState::Present,\n-                    );\n-                    self.set_drop_flag(\n-                        Location { block: unwind, statement_index: 0 },\n-                        child,\n-                        DropFlagState::Present,\n-                    );\n-                });\n-            }\n-            LookupResult::Parent(parent) => {\n-                // drop and replace behind a pointer/array/whatever. The location\n-                // must be initialized.\n-                debug!(\"elaborate_drop_and_replace({:?}) - untracked {:?}\", terminator, parent);\n-                self.patch.patch_terminator(\n-                    bb,\n-                    TerminatorKind::Drop { place, target, unwind: Some(unwind) },\n-                );\n-            }\n-        }\n-    }\n-\n     fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n@@ -609,22 +514,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             debug!(\"drop_flags_for_locs({:?})\", data);\n             for i in 0..(data.statements.len() + 1) {\n                 debug!(\"drop_flag_for_locs: stmt {}\", i);\n-                let mut allow_initializations = true;\n                 if i == data.statements.len() {\n                     match data.terminator().kind {\n                         TerminatorKind::Drop { .. } => {\n                             // drop elaboration should handle that by itself\n                             continue;\n                         }\n-                        TerminatorKind::DropAndReplace { .. } => {\n-                            // this contains the move of the source and\n-                            // the initialization of the destination. We\n-                            // only want the former - the latter is handled\n-                            // by the elaboration code and must be done\n-                            // *after* the destination is dropped.\n-                            assert!(self.patch.is_patched(bb));\n-                            allow_initializations = false;\n-                        }\n                         TerminatorKind::Resume => {\n                             // It is possible for `Resume` to be patched\n                             // (in particular it can be patched to be replaced with\n@@ -641,11 +536,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     self.body,\n                     self.env,\n                     loc,\n-                    |path, ds| {\n-                        if ds == DropFlagState::Absent || allow_initializations {\n-                            self.set_drop_flag(loc, path, ds)\n-                        }\n-                    },\n+                    |path, ds| self.set_drop_flag(loc, path, ds),\n                 )\n             }\n "}, {"sha": "b7f1cdfc7f2197df0a10a7d228113b4cfb141579", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1199,7 +1199,6 @@ fn can_unwind<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n \n             // These may unwind.\n             TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::InlineAsm { .. }\n             | TerminatorKind::Assert { .. } => return true,\n@@ -1648,6 +1647,7 @@ impl<'tcx> Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag(..)\n             | StatementKind::AscribeUserType(..)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n             | StatementKind::ConstEvalCounter\n@@ -1691,7 +1691,6 @@ impl<'tcx> Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }\n@@ -1872,12 +1871,14 @@ fn check_must_not_suspend_def(\n     data: SuspendCheckData<'_>,\n ) -> bool {\n     if let Some(attr) = tcx.get_attr(def_id, sym::must_not_suspend) {\n-        let msg = format!(\n-            \"{}`{}`{} held across a suspend point, but should not be\",\n-            data.descr_pre,\n-            tcx.def_path_str(def_id),\n-            data.descr_post,\n-        );\n+        let msg = rustc_errors::DelayDm(|| {\n+            format!(\n+                \"{}`{}`{} held across a suspend point, but should not be\",\n+                data.descr_pre,\n+                tcx.def_path_str(def_id),\n+                data.descr_post,\n+            )\n+        });\n         tcx.struct_span_lint_hir(\n             rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n             hir_id,"}, {"sha": "9cba8870f2377a6482a742f2930163c11818f4f4", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -453,9 +453,7 @@ impl<'tcx> Inliner<'tcx> {\n             checker.visit_basic_block_data(bb, blk);\n \n             let term = blk.terminator();\n-            if let TerminatorKind::Drop { ref place, target, unwind }\n-            | TerminatorKind::DropAndReplace { ref place, target, unwind, .. } = term.kind\n-            {\n+            if let TerminatorKind::Drop { ref place, target, unwind } = term.kind {\n                 work_list.push(target);\n \n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n@@ -815,8 +813,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         let tcx = self.tcx;\n         match terminator.kind {\n-            TerminatorKind::Drop { ref place, unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref place, unwind, .. } => {\n+            TerminatorKind::Drop { ref place, unwind, .. } => {\n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n                 let ty = self.instance.subst_mir(tcx, &place.ty(self.callee_body, tcx).ty);\n                 if ty.needs_drop(tcx, self.param_env) {\n@@ -1120,8 +1117,7 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n                     *tgt = self.map_block(*tgt);\n                 }\n             }\n-            TerminatorKind::Drop { ref mut target, ref mut unwind, .. }\n-            | TerminatorKind::DropAndReplace { ref mut target, ref mut unwind, .. } => {\n+            TerminatorKind::Drop { ref mut target, ref mut unwind, .. } => {\n                 *target = self.map_block(*target);\n                 *unwind = self.map_unwind(*unwind);\n             }"}, {"sha": "5fd923190ef591e72a5770a427c7ef0b4ca02b89", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -416,8 +416,6 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n \n     pm::run_passes(tcx, &mut body, &[&ctfe_limit::CtfeLimit], None);\n \n-    debug_assert!(!body.has_free_regions(), \"Free regions in MIR for CTFE\");\n-\n     body\n }\n \n@@ -626,8 +624,6 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n     debug!(\"body: {:#?}\", body);\n     run_optimization_passes(tcx, &mut body);\n \n-    debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n-\n     body\n }\n \n@@ -651,7 +647,5 @@ fn promoted_mir(\n         run_analysis_to_runtime_passes(tcx, body);\n     }\n \n-    debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");\n-\n     tcx.arena.alloc(promoted)\n }"}, {"sha": "e962819b6917711344f4aef10dbcaef58be31b91", "filename": "compiler/rustc_mir_transform/src/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -33,6 +33,7 @@ impl RemoveNoopLandingPads {\n                 StatementKind::FakeRead(..)\n                 | StatementKind::StorageLive(_)\n                 | StatementKind::StorageDead(_)\n+                | StatementKind::PlaceMention(..)\n                 | StatementKind::AscribeUserType(..)\n                 | StatementKind::Coverage(..)\n                 | StatementKind::ConstEvalCounter\n@@ -75,7 +76,6 @@ impl RemoveNoopLandingPads {\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Assert { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::InlineAsm { .. } => false,\n         }"}, {"sha": "e72729b152e69b2214c3348492efa4130d96969a", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::bit_set::ChunkedBitSet;\n-use rustc_middle::mir::{Body, Field, Rvalue, Statement, StatementKind, TerminatorKind};\n+use rustc_middle::mir::{Body, Field, TerminatorKind};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, VariantDef};\n use rustc_mir_dataflow::impls::MaybeInitializedPlaces;\n@@ -8,7 +8,7 @@ use rustc_mir_dataflow::{self, move_path_children_matching, Analysis, MoveDataPa\n \n use crate::MirPass;\n \n-/// Removes `Drop` and `DropAndReplace` terminators whose target is known to be uninitialized at\n+/// Removes `Drop` terminators whose target is known to be uninitialized at\n /// that point.\n ///\n /// This is redundant with drop elaboration, but we need to do it prior to const-checking, and\n@@ -37,8 +37,7 @@ impl<'tcx> MirPass<'tcx> for RemoveUninitDrops {\n         let mut to_remove = vec![];\n         for (bb, block) in body.basic_blocks.iter_enumerated() {\n             let terminator = block.terminator();\n-            let (TerminatorKind::Drop { place, .. } | TerminatorKind::DropAndReplace { place, .. })\n-                = &terminator.kind\n+            let TerminatorKind::Drop { place, .. } = &terminator.kind\n             else { continue };\n \n             maybe_inits.seek_before_primary_effect(body.terminator_loc(bb));\n@@ -64,24 +63,12 @@ impl<'tcx> MirPass<'tcx> for RemoveUninitDrops {\n         for bb in to_remove {\n             let block = &mut body.basic_blocks_mut()[bb];\n \n-            let (TerminatorKind::Drop { target, .. } | TerminatorKind::DropAndReplace { target, .. })\n+            let TerminatorKind::Drop { target, .. }\n                 = &block.terminator().kind\n             else { unreachable!() };\n \n             // Replace block terminator with `Goto`.\n-            let target = *target;\n-            let old_terminator_kind = std::mem::replace(\n-                &mut block.terminator_mut().kind,\n-                TerminatorKind::Goto { target },\n-            );\n-\n-            // If this is a `DropAndReplace`, we need to emulate the assignment to the return place.\n-            if let TerminatorKind::DropAndReplace { place, value, .. } = old_terminator_kind {\n-                block.statements.push(Statement {\n-                    source_info: block.terminator().source_info,\n-                    kind: StatementKind::Assign(Box::new((place, Rvalue::Use(value)))),\n-                });\n-            }\n+            block.terminator_mut().kind = TerminatorKind::Goto { target: *target };\n         }\n     }\n }"}, {"sha": "d76ab95faba96ebde0274b29a492c6e1f81fdaf9", "filename": "compiler/rustc_mir_transform/src/separate_const_switch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -108,7 +108,6 @@ pub fn separate_const_switch(body: &mut Body<'_>) -> usize {\n                         // The following terminators are not allowed\n                         TerminatorKind::Resume\n                         | TerminatorKind::Drop { .. }\n-                        | TerminatorKind::DropAndReplace { .. }\n                         | TerminatorKind::Call { .. }\n                         | TerminatorKind::Assert { .. }\n                         | TerminatorKind::FalseUnwind { .. }\n@@ -170,7 +169,6 @@ pub fn separate_const_switch(body: &mut Body<'_>) -> usize {\n             | TerminatorKind::Unreachable\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Assert { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::Call { .. }\n@@ -247,6 +245,7 @@ fn is_likely_const<'tcx>(mut tracked_place: Place<'tcx>, block: &BasicBlockData<\n             | StatementKind::StorageLive(_)\n             | StatementKind::Retag(_, _)\n             | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(_)\n             | StatementKind::StorageDead(_)\n             | StatementKind::Intrinsic(_)\n@@ -317,6 +316,7 @@ fn find_determining_place<'tcx>(\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag(_, _)\n             | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Coverage(_)\n             | StatementKind::Intrinsic(_)\n             | StatementKind::ConstEvalCounter"}, {"sha": "929d229dcdf8d7625374dead75343e9eaa23febe", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -525,6 +525,7 @@ impl<'tcx> Visitor<'tcx> for UsedLocals {\n             | StatementKind::Retag(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::FakeRead(..)\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::AscribeUserType(..) => {\n                 self.super_statement(statement, location);\n             }"}, {"sha": "ca2221520c82562bc8b6462e572d8f0bb9911f5c", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -4,7 +4,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::mir::patch::MirPatch;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{excluded_locals, iter_fields};\n \n pub struct ScalarReplacementOfAggregates;\n@@ -18,11 +18,12 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(def_id = ?body.source.def_id());\n         let mut excluded = excluded_locals(body);\n+        let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n         loop {\n             debug!(?excluded);\n             let escaping = escaping_locals(&excluded, body);\n             debug!(?escaping);\n-            let replacements = compute_flattening(tcx, body, escaping);\n+            let replacements = compute_flattening(tcx, param_env, body, escaping);\n             debug!(?replacements);\n             let all_dead_locals = replace_flattened_locals(tcx, body, replacements);\n             if !all_dead_locals.is_empty() {\n@@ -144,6 +145,7 @@ impl<'tcx> ReplacementMap<'tcx> {\n /// The replacement will be done later in `ReplacementVisitor`.\n fn compute_flattening<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     escaping: BitSet<Local>,\n ) -> ReplacementMap<'tcx> {\n@@ -155,7 +157,7 @@ fn compute_flattening<'tcx>(\n         }\n         let decl = body.local_decls[local].clone();\n         let ty = decl.ty;\n-        iter_fields(ty, tcx, |variant, field, field_ty| {\n+        iter_fields(ty, tcx, param_env, |variant, field, field_ty| {\n             if variant.is_some() {\n                 // Downcasts are currently not supported.\n                 return;"}, {"sha": "73168652f8fa2b330b2d1d7202a2af529a2e0e7e", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -53,7 +53,7 @@ impl SsaLocals {\n         body: &Body<'tcx>,\n         borrowed_locals: &BitSet<Local>,\n     ) -> SsaLocals {\n-        let assignment_order = Vec::new();\n+        let assignment_order = Vec::with_capacity(body.local_decls.len());\n \n         let assignments = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n         let dominators =\n@@ -179,37 +179,61 @@ struct SsaVisitor {\n     assignment_order: Vec<Local>,\n }\n \n+impl SsaVisitor {\n+    fn check_assignment_dominates(&mut self, local: Local, loc: Location) {\n+        let set = &mut self.assignments[local];\n+        let assign_dominates = match *set {\n+            Set1::Empty | Set1::Many => false,\n+            Set1::One(LocationExtended::Arg) => true,\n+            Set1::One(LocationExtended::Plain(assign)) => {\n+                assign.successor_within_block().dominates(loc, &self.dominators)\n+            }\n+        };\n+        // We are visiting a use that is not dominated by an assignment.\n+        // Either there is a cycle involved, or we are reading for uninitialized local.\n+        // Bail out.\n+        if !assign_dominates {\n+            *set = Set1::Many;\n+        }\n+    }\n+}\n+\n impl<'tcx> Visitor<'tcx> for SsaVisitor {\n     fn visit_local(&mut self, local: Local, ctxt: PlaceContext, loc: Location) {\n         match ctxt {\n             PlaceContext::MutatingUse(MutatingUseContext::Store) => {\n                 self.assignments[local].insert(LocationExtended::Plain(loc));\n-                self.assignment_order.push(local);\n+                if let Set1::One(_) = self.assignments[local] {\n+                    // Only record if SSA-like, to avoid growing the vector needlessly.\n+                    self.assignment_order.push(local);\n+                }\n             }\n             // Anything can happen with raw pointers, so remove them.\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf)\n             | PlaceContext::MutatingUse(_) => self.assignments[local] = Set1::Many,\n             // Immutable borrows are taken into account in `SsaLocals::new` by\n             // removing non-freeze locals.\n             PlaceContext::NonMutatingUse(_) => {\n-                let set = &mut self.assignments[local];\n-                let assign_dominates = match *set {\n-                    Set1::Empty | Set1::Many => false,\n-                    Set1::One(LocationExtended::Arg) => true,\n-                    Set1::One(LocationExtended::Plain(assign)) => {\n-                        assign.successor_within_block().dominates(loc, &self.dominators)\n-                    }\n-                };\n-                // We are visiting a use that is not dominated by an assignment.\n-                // Either there is a cycle involved, or we are reading for uninitialized local.\n-                // Bail out.\n-                if !assign_dominates {\n-                    *set = Set1::Many;\n-                }\n+                self.check_assignment_dominates(local, loc);\n             }\n             PlaceContext::NonUse(_) => {}\n         }\n     }\n+\n+    fn visit_place(&mut self, place: &Place<'tcx>, ctxt: PlaceContext, loc: Location) {\n+        if place.projection.first() == Some(&PlaceElem::Deref) {\n+            // Do not do anything for storage statements and debuginfo.\n+            if ctxt.is_use() {\n+                // A use through a `deref` only reads from the local, and cannot write to it.\n+                let new_ctxt = PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection);\n+\n+                self.visit_projection(place.as_ref(), new_ctxt, loc);\n+                self.check_assignment_dominates(place.local, loc);\n+            }\n+            return;\n+        }\n+        self.super_place(place, ctxt, loc);\n+    }\n }\n \n #[instrument(level = \"trace\", skip(ssa, body))]"}, {"sha": "f529944acce63a7b142b5009f3dbf08f2815e7a6", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -808,8 +808,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let callee_ty = self.monomorphize(callee_ty);\n                 visit_fn_use(self.tcx, callee_ty, true, source, &mut self.output)\n             }\n-            mir::TerminatorKind::Drop { ref place, .. }\n-            | mir::TerminatorKind::DropAndReplace { ref place, .. } => {\n+            mir::TerminatorKind::Drop { ref place, .. } => {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let ty = self.monomorphize(ty);\n                 visit_drop_use(self.tcx, ty, true, source, self.output);"}, {"sha": "5c524a18454ec515026c68537cf84d1b0cccd5c8", "filename": "compiler/rustc_monomorphize/src/partitioning/merging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -24,7 +24,7 @@ pub fn merge_codegen_units<'tcx>(\n     // smallest into each other) we're sure to start off with a deterministic\n     // order (sorted by name). This'll mean that if two cgus have the same size\n     // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by(|a, b| a.name().as_str().partial_cmp(b.name().as_str()).unwrap());\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n     // This map keeps track of what got merged into what.\n     let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> ="}, {"sha": "7ac1c9e057e8f8fd69dbb6593ba20da9697e5603", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -252,7 +252,7 @@ pub fn partition<'tcx>(\n         internalization_candidates: _,\n     } = post_inlining;\n \n-    result.sort_by(|a, b| a.name().as_str().partial_cmp(b.name().as_str()).unwrap());\n+    result.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n     result\n }"}, {"sha": "5c7dc1e2abf91f67f9df2a96fe9d9c14b8046013", "filename": "compiler/rustc_parse/locales/en-US.ftl", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -412,8 +412,7 @@ parse_fn_ptr_with_generics = function pointer types may not have generic paramet\n         *[false] a\n     } `for` parameter list\n \n-parse_invalid_identifier_with_leading_number = expected identifier, found number literal\n-    .label = identifiers cannot start with a number\n+parse_invalid_identifier_with_leading_number = identifiers cannot start with a number\n \n parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n     .suggestion = replace `fn` with `impl` here"}, {"sha": "63e5bc5051326fdab2ec67486d052ff24c8f6af5", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -939,6 +939,7 @@ pub(crate) struct ExpectedIdentifier {\n     pub token: Token,\n     pub suggest_raw: Option<SuggEscapeToUseAsIdentifier>,\n     pub suggest_remove_comma: Option<SuggRemoveComma>,\n+    pub help_cannot_start_number: Option<HelpIdentifierStartsWithNumber>,\n }\n \n impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n@@ -975,10 +976,18 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n             sugg.add_to_diagnostic(&mut diag);\n         }\n \n+        if let Some(help) = self.help_cannot_start_number {\n+            help.add_to_diagnostic(&mut diag);\n+        }\n+\n         diag\n     }\n }\n \n+#[derive(Subdiagnostic)]\n+#[help(parse_invalid_identifier_with_leading_number)]\n+pub(crate) struct HelpIdentifierStartsWithNumber;\n+\n pub(crate) struct ExpectedSemi {\n     pub span: Span,\n     pub token: Token,\n@@ -1207,14 +1216,6 @@ pub(crate) struct SelfParamNotFirst {\n     pub span: Span,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(parse_invalid_identifier_with_leading_number)]\n-pub(crate) struct InvalidIdentiferStartsWithNumber {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(parse_const_generic_without_braces)]\n pub(crate) struct ConstGenericWithoutBraces {"}, {"sha": "c4b9fdc81c5eb3f52b98debe891b97e4173a000b", "filename": "compiler/rustc_parse/src/lexer/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -71,7 +71,7 @@ pub fn report_suspicious_mismatch_block(\n         .collect();\n \n     // sort by `lo`, so the large block spans in the front\n-    matched_spans.sort_by(|a, b| a.0.lo().cmp(&b.0.lo()));\n+    matched_spans.sort_by_key(|(span, _)| span.lo());\n \n     // We use larger block whose identation is well to cover those inner mismatched blocks\n     // O(N^2) here, but we are on error reporting path, so it is fine"}, {"sha": "5b12bcc182222dd735b890faf67b4133f19f6030", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -8,14 +8,14 @@ use crate::errors::{\n     ComparisonOperatorsCannotBeChained, ComparisonOperatorsCannotBeChainedSugg,\n     ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentOnParamType,\n     DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n-    GenericParamsWithoutAngleBrackets, GenericParamsWithoutAngleBracketsSugg, InInTypo,\n-    IncorrectAwait, IncorrectSemicolon, IncorrectUseOfAwait, ParenthesesInForHead,\n-    ParenthesesInForHeadSugg, PatternMethodParamWithoutBody, QuestionMarkInType,\n-    QuestionMarkInTypeSugg, SelfParamNotFirst, StructLiteralBodyWithoutPath,\n-    StructLiteralBodyWithoutPathSugg, StructLiteralNeedingParens, StructLiteralNeedingParensSugg,\n-    SuggEscapeToUseAsIdentifier, SuggRemoveComma, UnexpectedConstInGenericParam,\n-    UnexpectedConstParamDeclaration, UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets,\n-    UseEqInstead,\n+    GenericParamsWithoutAngleBrackets, GenericParamsWithoutAngleBracketsSugg,\n+    HelpIdentifierStartsWithNumber, InInTypo, IncorrectAwait, IncorrectSemicolon,\n+    IncorrectUseOfAwait, ParenthesesInForHead, ParenthesesInForHeadSugg,\n+    PatternMethodParamWithoutBody, QuestionMarkInType, QuestionMarkInTypeSugg, SelfParamNotFirst,\n+    StructLiteralBodyWithoutPath, StructLiteralBodyWithoutPathSugg, StructLiteralNeedingParens,\n+    StructLiteralNeedingParensSugg, SuggEscapeToUseAsIdentifier, SuggRemoveComma,\n+    UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n+    UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n };\n \n use crate::fluent_generated as fluent;\n@@ -280,6 +280,7 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(Delimiter::Brace),\n             TokenKind::CloseDelim(Delimiter::Parenthesis),\n         ];\n+\n         let suggest_raw = match self.token.ident() {\n             Some((ident, false))\n                 if ident.is_raw_guess()\n@@ -295,18 +296,19 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        let suggest_remove_comma =\n-            if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n-                Some(SuggRemoveComma { span: self.token.span })\n-            } else {\n-                None\n-            };\n+        let suggest_remove_comma = (self.token == token::Comma\n+            && self.look_ahead(1, |t| t.is_ident()))\n+        .then_some(SuggRemoveComma { span: self.token.span });\n+\n+        let help_cannot_start_number =\n+            self.is_lit_bad_ident().then_some(HelpIdentifierStartsWithNumber);\n \n         let err = ExpectedIdentifier {\n             span: self.token.span,\n             token: self.token.clone(),\n             suggest_raw,\n             suggest_remove_comma,\n+            help_cannot_start_number,\n         };\n         let mut err = err.into_diagnostic(&self.sess.span_diagnostic);\n \n@@ -365,6 +367,17 @@ impl<'a> Parser<'a> {\n         err\n     }\n \n+    /// Checks if the current token is a integer or float literal and looks like\n+    /// it could be a invalid identifier with digits at the start.\n+    pub(super) fn is_lit_bad_ident(&mut self) -> bool {\n+        matches!(self.token.uninterpolate().kind, token::Literal(Lit { kind: token::LitKind::Integer | token::LitKind::Float, .. })\n+            // ensure that the integer literal is followed by a *invalid*\n+            // suffix: this is how we know that it is a identifier with an\n+            // invalid beginning.\n+            if rustc_ast::MetaItemLit::from_token(&self.token).is_none()\n+        )\n+    }\n+\n     pub(super) fn expected_one_of_not_found(\n         &mut self,\n         edible: &[TokenKind],"}, {"sha": "fc9f1d1330a72038bc81a031740119d5ba9a6a23", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -348,6 +348,10 @@ impl<'a> Parser<'a> {\n             lo = self.token.span;\n         }\n \n+        if self.is_lit_bad_ident() {\n+            return Err(self.expected_ident_found());\n+        }\n+\n         let pat = if self.check(&token::BinOp(token::And)) || self.token.kind == token::AndAnd {\n             self.parse_pat_deref(expected)?\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {"}, {"sha": "fbe5b88c49eaa42ddaa5001031cbc3e832ea12f4", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -273,7 +273,6 @@ impl<'a> Parser<'a> {\n             self.bump();\n         }\n \n-        self.report_invalid_identifier_error()?;\n         let (pat, colon) =\n             self.parse_pat_before_ty(None, RecoverComma::Yes, PatternLocation::LetBinding)?;\n \n@@ -366,17 +365,6 @@ impl<'a> Parser<'a> {\n         Ok(P(ast::Local { ty, pat, kind, id: DUMMY_NODE_ID, span: lo.to(hi), attrs, tokens: None }))\n     }\n \n-    /// report error for `let 1x = 123`\n-    pub fn report_invalid_identifier_error(&mut self) -> PResult<'a, ()> {\n-        if let token::Literal(lit) = self.token.uninterpolate().kind &&\n-            rustc_ast::MetaItemLit::from_token(&self.token).is_none() &&\n-            (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n-            self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n-                return Err(self.sess.create_err(errors::InvalidIdentiferStartsWithNumber { span: self.token.span }));\n-        }\n-        Ok(())\n-    }\n-\n     fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n         if let ast::ExprKind::Binary(op, ..) = init.kind {\n             if op.node.lazy() {"}, {"sha": "59877ebb26b703f148d05f34bdccdd0bb1df829b", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,8 +2,8 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n+use hir::def_id::{LocalDefIdMap, LocalDefIdSet};\n use itertools::Itertools;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::MultiSpan;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n@@ -45,17 +45,17 @@ struct MarkSymbolVisitor<'tcx> {\n     worklist: Vec<LocalDefId>,\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    live_symbols: FxHashSet<LocalDefId>,\n+    live_symbols: LocalDefIdSet,\n     repr_has_repr_c: bool,\n     repr_has_repr_simd: bool,\n     in_pat: bool,\n     ignore_variant_stack: Vec<DefId>,\n     // maps from tuple struct constructors to tuple struct items\n-    struct_constructors: FxHashMap<LocalDefId, LocalDefId>,\n+    struct_constructors: LocalDefIdMap<LocalDefId>,\n     // maps from ADTs to ignored derived traits (e.g. Debug and Clone)\n     // and the span of their respective impl (i.e., part of the derive\n     // macro)\n-    ignored_derived_traits: FxHashMap<LocalDefId, Vec<(DefId, DefId)>>,\n+    ignored_derived_traits: LocalDefIdMap<Vec<(DefId, DefId)>>,\n }\n \n impl<'tcx> MarkSymbolVisitor<'tcx> {\n@@ -237,7 +237,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     }\n \n     fn mark_live_symbols(&mut self) {\n-        let mut scanned = FxHashSet::default();\n+        let mut scanned = LocalDefIdSet::default();\n         while let Some(id) = self.worklist.pop() {\n             if !scanned.insert(id) {\n                 continue;\n@@ -506,7 +506,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool\n fn check_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     worklist: &mut Vec<LocalDefId>,\n-    struct_constructors: &mut FxHashMap<LocalDefId, LocalDefId>,\n+    struct_constructors: &mut LocalDefIdMap<LocalDefId>,\n     id: hir::ItemId,\n ) {\n     let allow_dead_code = has_allow_dead_code_or_lang_attr(tcx, id.owner_id.def_id);\n@@ -583,9 +583,7 @@ fn check_foreign_item(tcx: TyCtxt<'_>, worklist: &mut Vec<LocalDefId>, id: hir::\n     }\n }\n \n-fn create_and_seed_worklist(\n-    tcx: TyCtxt<'_>,\n-) -> (Vec<LocalDefId>, FxHashMap<LocalDefId, LocalDefId>) {\n+fn create_and_seed_worklist(tcx: TyCtxt<'_>) -> (Vec<LocalDefId>, LocalDefIdMap<LocalDefId>) {\n     let effective_visibilities = &tcx.effective_visibilities(());\n     // see `MarkSymbolVisitor::struct_constructors`\n     let mut struct_constructors = Default::default();\n@@ -617,7 +615,7 @@ fn create_and_seed_worklist(\n fn live_symbols_and_ignored_derived_traits(\n     tcx: TyCtxt<'_>,\n     (): (),\n-) -> (FxHashSet<LocalDefId>, FxHashMap<LocalDefId, Vec<(DefId, DefId)>>) {\n+) -> (LocalDefIdSet, LocalDefIdMap<Vec<(DefId, DefId)>>) {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n@@ -629,7 +627,7 @@ fn live_symbols_and_ignored_derived_traits(\n         in_pat: false,\n         ignore_variant_stack: vec![],\n         struct_constructors,\n-        ignored_derived_traits: FxHashMap::default(),\n+        ignored_derived_traits: Default::default(),\n     };\n     symbol_visitor.mark_live_symbols();\n     (symbol_visitor.live_symbols, symbol_visitor.ignored_derived_traits)\n@@ -643,8 +641,8 @@ struct DeadVariant {\n \n struct DeadVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    live_symbols: &'tcx FxHashSet<LocalDefId>,\n-    ignored_derived_traits: &'tcx FxHashMap<LocalDefId, Vec<(DefId, DefId)>>,\n+    live_symbols: &'tcx LocalDefIdSet,\n+    ignored_derived_traits: &'tcx LocalDefIdMap<Vec<(DefId, DefId)>>,\n }\n \n enum ShouldWarnAboutField {"}, {"sha": "a5f7b07fe5211f30fed800073ded29c38a5c09b2", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -5,7 +5,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use rustc_data_structures::fx::FxHashSet;\n+use hir::def_id::LocalDefIdSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -63,7 +63,7 @@ struct ReachableContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: FxHashSet<LocalDefId>,\n+    reachable_symbols: LocalDefIdSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n     // FIXME(eddyb) benchmark if this would be faster as a `VecDeque`.\n@@ -175,7 +175,7 @@ impl<'tcx> ReachableContext<'tcx> {\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&mut self) {\n-        let mut scanned = FxHashSet::default();\n+        let mut scanned = LocalDefIdSet::default();\n         while let Some(search_item) = self.worklist.pop() {\n             if !scanned.insert(search_item) {\n                 continue;\n@@ -361,7 +361,7 @@ fn has_custom_linkage(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n         || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n }\n \n-fn reachable_set(tcx: TyCtxt<'_>, (): ()) -> FxHashSet<LocalDefId> {\n+fn reachable_set(tcx: TyCtxt<'_>, (): ()) -> LocalDefIdSet {\n     let effective_visibilities = &tcx.effective_visibilities(());\n \n     let any_library ="}, {"sha": "d5cc64a54029a1353d9913d342f5c4ea6e8c410a", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -265,6 +265,15 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 self.index.implications.insert(implied_by, feature);\n             }\n \n+            if let Some(ConstStability {\n+                level: Unstable { implied_by: Some(implied_by), .. },\n+                feature,\n+                ..\n+            }) = const_stab\n+            {\n+                self.index.implications.insert(implied_by, feature);\n+            }\n+\n             self.index.stab_map.insert(def_id, stab);\n             stab\n         });"}, {"sha": "6522b1406beefb9e29dd4ca925e874ba3bd9c2dd", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{self, interpret};\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n-use rustc_query_system::query::{QueryCache, QueryContext, QuerySideEffects};\n+use rustc_query_system::query::{QueryCache, QuerySideEffects};\n use rustc_serialize::{\n     opaque::{FileEncodeResult, FileEncoder, IntEncodedWithFixedSize, MemDecoder},\n     Decodable, Decoder, Encodable, Encoder,\n@@ -1056,24 +1056,24 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for [u8] {\n     }\n }\n \n-pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n-    tcx: CTX,\n+pub fn encode_query_results<'a, 'tcx, Q>(\n+    query: Q,\n+    qcx: QueryCtxt<'tcx>,\n     encoder: &mut CacheEncoder<'a, 'tcx>,\n     query_result_index: &mut EncodedDepNodeIndex,\n ) where\n-    CTX: QueryContext + 'tcx,\n-    Q: super::QueryConfig<CTX>,\n+    Q: super::QueryConfig<QueryCtxt<'tcx>>,\n     Q::Value: Encodable<CacheEncoder<'a, 'tcx>>,\n {\n-    let _timer = tcx\n-        .dep_context()\n+    let _timer = qcx\n+        .tcx\n         .profiler()\n-        .verbose_generic_activity_with_arg(\"encode_query_results_for\", std::any::type_name::<Q>());\n+        .verbose_generic_activity_with_arg(\"encode_query_results_for\", query.name());\n \n-    assert!(Q::query_state(tcx).all_inactive());\n-    let cache = Q::query_cache(tcx);\n+    assert!(query.query_state(qcx).all_inactive());\n+    let cache = query.query_cache(qcx);\n     cache.iter(&mut |key, value, dep_node| {\n-        if Q::cache_on_disk(*tcx.dep_context(), &key) {\n+        if query.cache_on_disk(qcx.tcx, &key) {\n             let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n \n             // Record position of the cache entry."}, {"sha": "005ce16dbb9b404a94771370e79c8b205d62bf64", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 79, "deletions": 33, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -19,7 +19,7 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_query_system::query::{\n     force_query, QueryConfig, QueryContext, QueryJobId, QueryMap, QuerySideEffects, QueryStackFrame,\n };\n-use rustc_query_system::{LayoutOfDepth, QueryOverflow, Value};\n+use rustc_query_system::{LayoutOfDepth, QueryOverflow};\n use rustc_serialize::Decodable;\n use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n@@ -350,18 +350,17 @@ pub(crate) fn create_query_frame<\n     QueryStackFrame::new(description, span, def_id, def_kind, kind, ty_adt_id, hash)\n }\n \n-fn try_load_from_on_disk_cache<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode)\n+fn try_load_from_on_disk_cache<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode)\n where\n     Q: QueryConfig<QueryCtxt<'tcx>>,\n-    Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n {\n     debug_assert!(tcx.dep_graph.is_green(&dep_node));\n \n     let key = Q::Key::recover(tcx, &dep_node).unwrap_or_else(|| {\n         panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash)\n     });\n-    if Q::cache_on_disk(tcx, &key) {\n-        let _ = Q::execute_query(tcx, key);\n+    if query.cache_on_disk(tcx, &key) {\n+        let _ = query.execute_query(tcx, key);\n     }\n }\n \n@@ -375,11 +374,9 @@ where\n     tcx.on_disk_cache().as_ref()?.try_load_query_result(*tcx, id)\n }\n \n-fn force_from_dep_node<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n+fn force_from_dep_node<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n where\n     Q: QueryConfig<QueryCtxt<'tcx>>,\n-    Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n-    Q::Value: Value<TyCtxt<'tcx>, DepKind>,\n {\n     // We must avoid ever having to call `force_from_dep_node()` for a\n     // `DepNode::codegen_unit`:\n@@ -403,7 +400,7 @@ where\n         #[cfg(debug_assertions)]\n         let _guard = tracing::span!(tracing::Level::TRACE, stringify!($name), ?key).entered();\n         let tcx = QueryCtxt::from_tcx(tcx);\n-        force_query::<Q, _, DepKind>(tcx, key, dep_node);\n+        force_query(query, tcx, key, dep_node);\n         true\n     } else {\n         false\n@@ -412,7 +409,7 @@ where\n \n pub(crate) fn query_callback<'tcx, Q>(is_anon: bool, is_eval_always: bool) -> DepKindStruct<'tcx>\n where\n-    Q: QueryConfig<QueryCtxt<'tcx>>,\n+    Q: QueryConfig<QueryCtxt<'tcx>> + Default,\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n {\n     let fingerprint_style = Q::Key::fingerprint_style();\n@@ -431,8 +428,10 @@ where\n         is_anon,\n         is_eval_always,\n         fingerprint_style,\n-        force_from_dep_node: Some(force_from_dep_node::<Q>),\n-        try_load_from_on_disk_cache: Some(try_load_from_on_disk_cache::<Q>),\n+        force_from_dep_node: Some(|tcx, dep_node| force_from_dep_node(Q::default(), tcx, dep_node)),\n+        try_load_from_on_disk_cache: Some(|tcx, dep_node| {\n+            try_load_from_on_disk_cache(Q::default(), tcx, dep_node)\n+        }),\n     }\n }\n \n@@ -462,54 +461,65 @@ macro_rules! define_queries {\n         mod queries {\n             use std::marker::PhantomData;\n \n-            $(pub struct $name<'tcx> {\n-                data: PhantomData<&'tcx ()>\n-            })*\n+            $(\n+                #[derive(Copy, Clone, Default)]\n+                pub struct $name<'tcx> {\n+                    data: PhantomData<&'tcx ()>\n+                }\n+            )*\n         }\n \n         $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n             type Value = query_values::$name<'tcx>;\n-            const NAME: &'static str = stringify!($name);\n+\n+            #[inline(always)]\n+            fn name(self) -> &'static str {\n+                stringify!($name)\n+            }\n \n             #[inline]\n-            fn cache_on_disk(tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n+            fn cache_on_disk(self, tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n                 ::rustc_middle::query::cached::$name(tcx, key)\n             }\n \n             type Cache = query_storage::$name<'tcx>;\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n+            fn query_state<'a>(self, tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n                 where QueryCtxt<'tcx>: 'a\n             {\n                 &tcx.queries.$name\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n+            fn query_cache<'a>(self, tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n                 where 'tcx:'a\n             {\n                 &tcx.query_system.caches.$name\n             }\n \n-            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+            fn execute_query(self, tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 tcx.$name(key)\n             }\n \n             #[inline]\n             #[allow(unused_variables)]\n-            fn compute(qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+            fn compute(self, qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 query_provided_to_value::$name(\n                     qcx.tcx,\n                     get_provider!([$($modifiers)*][qcx, $name, key])(qcx.tcx, key)\n                 )\n             }\n \n             #[inline]\n-            fn try_load_from_disk(_qcx: QueryCtxt<'tcx>, _key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n+            fn try_load_from_disk(\n+                self,\n+                _qcx: QueryCtxt<'tcx>,\n+                _key: &Self::Key\n+            ) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self::Value> {\n                 should_ever_cache_on_disk!([$($modifiers)*] {\n-                    if Self::cache_on_disk(_qcx.tcx, _key) {\n+                    if ::rustc_middle::query::cached::$name(_qcx.tcx, _key) {\n                         Some(|qcx: QueryCtxt<'tcx>, dep_node| {\n                             let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n                                 qcx,\n@@ -525,15 +535,40 @@ macro_rules! define_queries {\n                 })\n             }\n \n-            const ANON: bool = is_anon!([$($modifiers)*]);\n-            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n-            const DEPTH_LIMIT: bool = depth_limit!([$($modifiers)*]);\n-            const FEEDABLE: bool = feedable!([$($modifiers)*]);\n+            #[inline(always)]\n+            fn anon(self) -> bool {\n+                is_anon!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn eval_always(self) -> bool {\n+                is_eval_always!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn depth_limit(self) -> bool {\n+                depth_limit!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn feedable(self) -> bool {\n+                feedable!([$($modifiers)*])\n+            }\n \n-            const DEP_KIND: rustc_middle::dep_graph::DepKind = dep_graph::DepKind::$name;\n-            const HANDLE_CYCLE_ERROR: rustc_query_system::HandleCycleError = handle_cycle_error!([$($modifiers)*]);\n+            #[inline(always)]\n+            fn dep_kind(self) -> rustc_middle::dep_graph::DepKind {\n+                dep_graph::DepKind::$name\n+            }\n \n-            const HASH_RESULT: rustc_query_system::query::HashResult<QueryCtxt<'tcx>, Self> = hash_result!([$($modifiers)*]);\n+            #[inline(always)]\n+            fn handle_cycle_error(self) -> rustc_query_system::HandleCycleError {\n+                handle_cycle_error!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn hash_result(self) -> rustc_query_system::query::HashResult<Self::Value> {\n+                hash_result!([$($modifiers)*])\n+            }\n         })*\n \n         #[allow(nonstandard_style)]\n@@ -649,8 +684,13 @@ macro_rules! define_queries {\n                         string_cache,\n                     )\n                 },\n-                encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n-                    $crate::on_disk_cache::encode_query_results::<_, super::queries::$name<'_>>(tcx, encoder, query_result_index)\n+                encode_query_results: expand_if_cached!([$($modifiers)*], |qcx, encoder, query_result_index|\n+                    $crate::on_disk_cache::encode_query_results(\n+                        super::queries::$name::default(),\n+                        qcx,\n+                        encoder,\n+                        query_result_index,\n+                    )\n                 ),\n             }})*\n         }\n@@ -739,7 +779,13 @@ macro_rules! define_queries_struct {\n                 mode: QueryMode,\n             ) -> Option<query_values::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n-                get_query::<queries::$name<'tcx>, _, rustc_middle::dep_graph::DepKind>(qcx, span, key, mode)\n+                get_query(\n+                    queries::$name::default(),\n+                    qcx,\n+                    span,\n+                    key,\n+                    mode\n+                )\n             })*\n         }\n     };"}, {"sha": "ba83b775631651aa414f04d0d5df845f5256d9df", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -88,6 +88,15 @@ impl<T: DepContext> HasDepContext for T {\n     }\n }\n \n+impl<T: HasDepContext, Q: Copy> HasDepContext for (T, Q) {\n+    type DepKind = T::DepKind;\n+    type DepContext = T::DepContext;\n+\n+    fn dep_context(&self) -> &Self::DepContext {\n+        self.0.dep_context()\n+    }\n+}\n+\n /// Describes the contents of the fingerprint generated by a given query.\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum FingerprintStyle {"}, {"sha": "5f554a54deac1963f3ad1cb6cba5c73d3a412e23", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -16,12 +16,9 @@ pub trait CacheSelector<'tcx, V> {\n         V: Copy;\n }\n \n-pub trait QueryStorage {\n-    type Value: Copy;\n-}\n-\n-pub trait QueryCache: QueryStorage + Sized {\n+pub trait QueryCache: Sized {\n     type Key: Hash + Eq + Copy + Debug;\n+    type Value: Copy + Debug;\n \n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n@@ -55,16 +52,13 @@ impl<K, V> Default for DefaultCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n-    type Value = V;\n-}\n-\n impl<K, V> QueryCache for DefaultCache<K, V>\n where\n     K: Eq + Hash + Copy + Debug,\n     V: Copy + Debug,\n {\n     type Key = K;\n+    type Value = V;\n \n     #[inline(always)]\n     fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {\n@@ -127,15 +121,12 @@ impl<V> Default for SingleCache<V> {\n     }\n }\n \n-impl<V: Copy + Debug> QueryStorage for SingleCache<V> {\n-    type Value = V;\n-}\n-\n impl<V> QueryCache for SingleCache<V>\n where\n     V: Copy + Debug,\n {\n     type Key = ();\n+    type Value = V;\n \n     #[inline(always)]\n     fn lookup(&self, _key: &()) -> Option<(V, DepNodeIndex)> {\n@@ -173,16 +164,13 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n-    type Value = V;\n-}\n-\n impl<K, V> QueryCache for VecCache<K, V>\n where\n     K: Eq + Idx + Copy + Debug,\n     V: Copy + Debug,\n {\n     type Key = K;\n+    type Value = V;\n \n     #[inline(always)]\n     fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {"}, {"sha": "e44a00ca6cb5952c77a63c299b7d9412b7b25cf0", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -10,14 +10,12 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n-pub type HashResult<Qcx, Q> =\n-    Option<fn(&mut StableHashingContext<'_>, &<Q as QueryConfig<Qcx>>::Value) -> Fingerprint>;\n+pub type HashResult<V> = Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>;\n \n-pub type TryLoadFromDisk<Qcx, Q> =\n-    Option<fn(Qcx, SerializedDepNodeIndex) -> Option<<Q as QueryConfig<Qcx>>::Value>>;\n+pub type TryLoadFromDisk<Qcx, V> = Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>;\n \n-pub trait QueryConfig<Qcx: QueryContext> {\n-    const NAME: &'static str;\n+pub trait QueryConfig<Qcx: QueryContext>: Copy {\n+    fn name(self) -> &'static str;\n \n     // `Key` and `Value` are `Copy` instead of `Clone` to ensure copying them stays cheap,\n     // but it isn't necessary.\n@@ -27,36 +25,35 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n+    fn query_state<'a>(self, tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n     where\n         Qcx: 'a;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: Qcx) -> &'a Self::Cache\n+    fn query_cache<'a>(self, tcx: Qcx) -> &'a Self::Cache\n     where\n         Qcx: 'a;\n \n-    fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n+    fn cache_on_disk(self, tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Value;\n+    fn execute_query(self, tcx: Qcx::DepContext, k: Self::Key) -> Self::Value;\n \n-    fn compute(tcx: Qcx, key: Self::Key) -> Self::Value;\n+    fn compute(self, tcx: Qcx, key: Self::Key) -> Self::Value;\n \n-    fn try_load_from_disk(qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self>;\n+    fn try_load_from_disk(self, qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self::Value>;\n \n-    const ANON: bool;\n-    const EVAL_ALWAYS: bool;\n-    const DEPTH_LIMIT: bool;\n-    const FEEDABLE: bool;\n+    fn anon(self) -> bool;\n+    fn eval_always(self) -> bool;\n+    fn depth_limit(self) -> bool;\n+    fn feedable(self) -> bool;\n \n-    const DEP_KIND: Qcx::DepKind;\n-    const HANDLE_CYCLE_ERROR: HandleCycleError;\n-\n-    const HASH_RESULT: HashResult<Qcx, Self>;\n+    fn dep_kind(self) -> Qcx::DepKind;\n+    fn handle_cycle_error(self) -> HandleCycleError;\n+    fn hash_result(self) -> HashResult<Self::Value>;\n \n     // Just here for convernience and checking that the key matches the kind, don't override this.\n-    fn construct_dep_node(tcx: Qcx::DepContext, key: &Self::Key) -> DepNode<Qcx::DepKind> {\n-        DepNode::construct(tcx, Self::DEP_KIND, key)\n+    fn construct_dep_node(self, tcx: Qcx::DepContext, key: &Self::Key) -> DepNode<Qcx::DepKind> {\n+        DepNode::construct(tcx, self.dep_kind(), key)\n     }\n }"}, {"sha": "312b0e1688dc9c8b7dde54c584176d43d5904bc2", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -8,8 +8,7 @@ pub use self::job::{print_query_stack, QueryInfo, QueryJob, QueryJobId, QueryJob\n \n mod caches;\n pub use self::caches::{\n-    CacheSelector, DefaultCacheSelector, QueryCache, QueryStorage, SingleCacheSelector,\n-    VecCacheSelector,\n+    CacheSelector, DefaultCacheSelector, QueryCache, SingleCacheSelector, VecCacheSelector,\n };\n \n mod config;"}, {"sha": "005fcd8c4cc9d9f6d1f9951417d5f0537d278a1b", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,6 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n+use crate::dep_graph::HasDepContext;\n use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n@@ -126,7 +127,7 @@ fn mk_cycle<Qcx, R, D: DepKind>(\n     handler: HandleCycleError,\n ) -> R\n where\n-    Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n+    Qcx: QueryContext + HasDepContext<DepKind = D>,\n     R: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n@@ -181,7 +182,7 @@ where\n         key: K,\n     ) -> TryGetJob<'b, K, D>\n     where\n-        Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n+        Qcx: QueryContext + HasDepContext<DepKind = D>,\n     {\n         #[cfg(parallel_compiler)]\n         let mut state_lock = state.active.get_shard_by_value(&key).lock();\n@@ -350,6 +351,7 @@ where\n \n #[inline(never)]\n fn try_execute_query<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n     span: Span,\n     key: Q::Key,\n@@ -359,12 +361,12 @@ where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    let state = Q::query_state(qcx);\n+    let state = query.query_state(qcx);\n     match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job::<Q, Qcx>(qcx, key, dep_node, job.id);\n-            let cache = Q::query_cache(qcx);\n-            if Q::FEEDABLE {\n+            let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n+            let cache = query.query_cache(qcx);\n+            if query.feedable() {\n                 // We should not compute queries that also got a value via feeding.\n                 // This can't happen, as query feeding adds the very dependencies to the fed query\n                 // as its feeding query had. So if the fed query is red, so is its feeder, which will\n@@ -379,12 +381,12 @@ where\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(qcx, error, Q::HANDLE_CYCLE_ERROR);\n+            let result = mk_cycle(qcx, error, query.handle_cycle_error());\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted(query_blocked_prof_timer) => {\n-            let Some((v, index)) = Q::query_cache(qcx).lookup(&key) else {\n+            let Some((v, index)) = query.query_cache(qcx).lookup(&key) else {\n                 panic!(\"value must be in cache after waiting\")\n             };\n \n@@ -398,6 +400,7 @@ where\n \n #[inline(always)]\n fn execute_job<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n     key: Q::Key,\n     mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n@@ -418,14 +421,14 @@ where\n         }\n \n         let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || Q::compute(qcx, key));\n+        let result = qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         // Similarly, fingerprint the result to assert that\n         // it doesn't have anything not considered hashable.\n         if cfg!(debug_assertions)\n-            && let Some(hash_result) = Q::HASH_RESULT\n+            && let Some(hash_result) = query.hash_result()\n         {\n             qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n                 hash_result(&mut hcx, &result);\n@@ -435,15 +438,15 @@ where\n         return (result, dep_node_index);\n     }\n \n-    if !Q::ANON && !Q::EVAL_ALWAYS {\n+    if !query.anon() && !query.eval_always() {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node =\n-            dep_node_opt.get_or_insert_with(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n+            dep_node_opt.get_or_insert_with(|| query.construct_dep_node(*qcx.dep_context(), &key));\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = qcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory::<Q, Qcx>(qcx, &key, &dep_node)\n+            try_load_from_disk_and_cache_in_memory(query, qcx, &key, &dep_node)\n         }) {\n             return ret;\n         }\n@@ -453,17 +456,24 @@ where\n     let diagnostics = Lock::new(ThinVec::new());\n \n     let (result, dep_node_index) =\n-        qcx.start_query(job_id, Q::DEPTH_LIMIT, Some(&diagnostics), || {\n-            if Q::ANON {\n-                return dep_graph\n-                    .with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || Q::compute(qcx, key));\n+        qcx.start_query(job_id, query.depth_limit(), Some(&diagnostics), || {\n+            if query.anon() {\n+                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind(), || {\n+                    query.compute(qcx, key)\n+                });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n-                dep_node_opt.unwrap_or_else(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n-\n-            dep_graph.with_task(dep_node, qcx, key, Q::compute, Q::HASH_RESULT)\n+                dep_node_opt.unwrap_or_else(|| query.construct_dep_node(*qcx.dep_context(), &key));\n+\n+            dep_graph.with_task(\n+                dep_node,\n+                (qcx, query),\n+                key,\n+                |(qcx, query), key| query.compute(qcx, key),\n+                query.hash_result(),\n+            )\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -472,7 +482,7 @@ where\n     let side_effects = QuerySideEffects { diagnostics };\n \n     if std::intrinsics::unlikely(!side_effects.is_empty()) {\n-        if Q::ANON {\n+        if query.anon() {\n             qcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n             qcx.store_side_effects(dep_node_index, side_effects);\n@@ -484,6 +494,7 @@ where\n \n #[inline(always)]\n fn try_load_from_disk_and_cache_in_memory<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n     key: &Q::Key,\n     dep_node: &DepNode<Qcx::DepKind>,\n@@ -502,7 +513,7 @@ where\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n-    if let Some(try_load_from_disk) = Q::try_load_from_disk(qcx, &key) {\n+    if let Some(try_load_from_disk) = query.try_load_from_disk(qcx, &key) {\n         let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n@@ -536,7 +547,7 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n             }\n \n             return Some((result, dep_node_index));\n@@ -555,7 +566,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| Q::compute(qcx, *key));\n+    let result = dep_graph.with_ignore(|| query.compute(qcx, *key));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -568,7 +579,7 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n \n     Some((result, dep_node_index))\n }\n@@ -689,19 +700,23 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<Q, Qcx>(qcx: Qcx, key: &Q::Key) -> (bool, Option<DepNode<Qcx::DepKind>>)\n+fn ensure_must_run<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    key: &Q::Key,\n+) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    if Q::EVAL_ALWAYS {\n+    if query.eval_always() {\n         return (true, None);\n     }\n \n     // Ensuring an anonymous query makes no sense\n-    assert!(!Q::ANON);\n+    assert!(!query.anon());\n \n-    let dep_node = Q::construct_dep_node(*qcx.dep_context(), key);\n+    let dep_node = query.construct_dep_node(*qcx.dep_context(), key);\n \n     let dep_graph = qcx.dep_context().dep_graph();\n     match dep_graph.try_mark_green(qcx, &dep_node) {\n@@ -729,15 +744,19 @@ pub enum QueryMode {\n }\n \n #[inline(always)]\n-pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Value>\n+pub fn get_query<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    span: Span,\n+    key: Q::Key,\n+    mode: QueryMode,\n+) -> Option<Q::Value>\n where\n-    D: DepKind,\n     Q: QueryConfig<Qcx>,\n-    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run::<Q, _>(qcx, &key);\n+        let (must_run, dep_node) = ensure_must_run(query, qcx, &key);\n         if !must_run {\n             return None;\n         }\n@@ -747,28 +766,30 @@ where\n     };\n \n     let (result, dep_node_index) =\n-        ensure_sufficient_stack(|| try_execute_query::<Q, Qcx>(qcx, span, key, dep_node));\n+        ensure_sufficient_stack(|| try_execute_query(query, qcx, span, key, dep_node));\n     if let Some(dep_node_index) = dep_node_index {\n         qcx.dep_context().dep_graph().read_index(dep_node_index)\n     }\n     Some(result)\n }\n \n-pub fn force_query<Q, Qcx, D>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n-where\n-    D: DepKind,\n+pub fn force_query<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    key: Q::Key,\n+    dep_node: DepNode<<Qcx as HasDepContext>::DepKind>,\n+) where\n     Q: QueryConfig<Qcx>,\n-    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n-    if let Some((_, index)) = Q::query_cache(qcx).lookup(&key) {\n+    if let Some((_, index)) = query.query_cache(qcx).lookup(&key) {\n         qcx.dep_context().profiler().query_cache_hit(index.into());\n         return;\n     }\n \n-    debug_assert!(!Q::ANON);\n+    debug_assert!(!query.anon());\n \n-    ensure_sufficient_stack(|| try_execute_query::<Q, _>(qcx, DUMMY_SP, key, Some(dep_node)));\n+    ensure_sufficient_stack(|| try_execute_query(query, qcx, DUMMY_SP, key, Some(dep_node)));\n }"}, {"sha": "6133e75a78fff07826454de25cbd7b9f2f96a4ba", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1736,7 +1736,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n         let name = path[path.len() - 1].ident.name;\n         // Make sure error reporting is deterministic.\n-        names.sort_by(|a, b| a.candidate.as_str().partial_cmp(b.candidate.as_str()).unwrap());\n+        names.sort_by(|a, b| a.candidate.as_str().cmp(b.candidate.as_str()));\n \n         match find_best_match_for_name(\n             &names.iter().map(|suggestion| suggestion.candidate).collect::<Vec<Symbol>>(),"}, {"sha": "0dfee92f404345ffcf2538db6296844fb1fc6e55", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lock;\n use rustc_span::Symbol;\n use rustc_target::abi::{Align, Size};\n-use std::cmp::{self, Ordering};\n+use std::cmp;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct VariantInfo {\n@@ -87,7 +87,7 @@ impl CodeStats {\n         // Except for Generators, whose variants are already sorted according to\n         // their yield points in `variant_info_for_generator`.\n         if kind != DataTypeKind::Generator {\n-            variants.sort_by(|info1, info2| info2.size.cmp(&info1.size));\n+            variants.sort_by_key(|info| cmp::Reverse(info.size));\n         }\n         let info = TypeSizeInfo {\n             kind,\n@@ -107,13 +107,7 @@ impl CodeStats {\n \n         // Primary sort: large-to-small.\n         // Secondary sort: description (dictionary order)\n-        sorted.sort_by(|info1, info2| {\n-            // (reversing cmp order to get large-to-small ordering)\n-            match info2.overall_size.cmp(&info1.overall_size) {\n-                Ordering::Equal => info1.type_description.cmp(&info2.type_description),\n-                other => other,\n-            }\n-        });\n+        sorted.sort_by_key(|info| (cmp::Reverse(info.overall_size), &info.type_description));\n \n         for info in sorted {\n             let TypeSizeInfo { type_description, overall_size, align, kind, variants, .. } = info;"}, {"sha": "2cc25e977a901a2d9d352b6d26c3db9d59a86e77", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -11,7 +11,7 @@ use crate::{filesearch, lint};\n pub use rustc_ast::attr::MarkedAttrs;\n pub use rustc_ast::Attribute;\n use rustc_data_structures::flock;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::jobserver::{self, Client};\n use rustc_data_structures::profiling::{duration_to_secs_str, SelfProfiler, SelfProfilerRef};\n use rustc_data_structures::sync::{\n@@ -207,10 +207,10 @@ pub struct Session {\n     pub asm_arch: Option<InlineAsmArch>,\n \n     /// Set of enabled features for the current target.\n-    pub target_features: FxHashSet<Symbol>,\n+    pub target_features: FxIndexSet<Symbol>,\n \n     /// Set of enabled features for the current target, including unstable ones.\n-    pub unstable_target_features: FxHashSet<Symbol>,\n+    pub unstable_target_features: FxIndexSet<Symbol>,\n }\n \n pub struct PerfStats {\n@@ -1488,8 +1488,8 @@ pub fn build_session(\n         ctfe_backtrace,\n         miri_unleashed_features: Lock::new(Default::default()),\n         asm_arch,\n-        target_features: FxHashSet::default(),\n-        unstable_target_features: FxHashSet::default(),\n+        target_features: Default::default(),\n+        unstable_target_features: Default::default(),\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "fb97ee5bebe6ef0657529f838b898e7e3578305c", "filename": "compiler/rustc_smir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2FCargo.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -4,25 +4,12 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n-rustc_borrowck = { path = \"../rustc_borrowck\", optional = true }\n-rustc_driver = { path = \"../rustc_driver\", optional = true }\n-rustc_hir = { path = \"../rustc_hir\", optional = true }\n-rustc_interface = { path = \"../rustc_interface\", optional = true }\n rustc_middle = { path = \"../rustc_middle\", optional = true }\n-rustc_mir_dataflow = { path = \"../rustc_mir_dataflow\", optional = true }\n-rustc_mir_transform = { path = \"../rustc_mir_transform\", optional = true }\n-rustc_serialize = { path = \"../rustc_serialize\", optional = true }\n-rustc_trait_selection = { path = \"../rustc_trait_selection\", optional = true }\n+rustc_span = { path = \"../rustc_span\", optional = true }\n+tracing = \"0.1\"\n \n [features]\n default = [\n-    \"rustc_borrowck\",\n-    \"rustc_driver\",\n-    \"rustc_hir\",\n-    \"rustc_interface\",\n     \"rustc_middle\",\n-    \"rustc_mir_dataflow\",\n-    \"rustc_mir_transform\",\n-    \"rustc_serialize\",\n-    \"rustc_trait_selection\",\n+    \"rustc_span\",\n ]"}, {"sha": "31dee955f491fee6321b13ed2041566414da483e", "filename": "compiler/rustc_smir/README.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2FREADME.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -73,3 +73,40 @@ git subtree pull --prefix=compiler/rustc_smir https://github.com/rust-lang/proje\n Note: only ever sync to rustc from the project-stable-mir's `smir` branch. Do not sync with your own forks.\n \n Then open a PR against rustc just like a regular PR.\n+\n+## Stable MIR Design\n+\n+The stable-mir will follow a similar approach to proc-macro2. It\u2019s\n+implementation will eventually be broken down into two main crates:\n+\n+- `stable_mir`: Public crate, to be published on crates.io, which will contain\n+the stable data structure as well as proxy APIs to make calls to the\n+compiler.\n+- `rustc_smir`: The compiler crate that will translate from internal MIR to\n+SMIR. This crate will also implement APIs that will be invoked by\n+stable-mir to query the compiler for more information.\n+\n+This will help tools to communicate with the rust compiler via stable APIs. Tools will depend on\n+`stable_mir` crate, which will invoke the compiler using APIs defined in `rustc_smir`. I.e.:\n+\n+```\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502   External Tool     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502           \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   Rust Compiler     \u2502\n+    \u2502                     \u2502          \u2502 \u2502           \u2502 \u2502          \u2502                     \u2502\n+    \u2502                     \u2502stable_mir| \u2502           \u2502 \u2502rustc_smir\u2502                     \u2502\n+    \u2502                     \u2502          \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba| \u2502          \u2502                     \u2502\n+    \u2502                     \u2502          \u2502 \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502          \u2502                     \u2502\n+    \u2502                     \u2502          \u2502 \u2502           \u2502 \u2502          \u2502                     \u2502\n+    \u2502                     \u2502          \u2502 \u2502           \u2502 \u2502          \u2502                     \u2502\n+    \u2502                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502           \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+More details can be found here:\n+https://hackmd.io/XhnYHKKuR6-LChhobvlT-g?view\n+\n+For now, the code for these two crates are in separate modules of this crate.\n+The modules have the same name for simplicity. We also have a third module,\n+`rustc_internal` which will expose APIs and definitions that allow users to\n+gather information from internal MIR constructs that haven't been exposed in\n+the `stable_mir` module."}, {"sha": "157dfd620ee1bda6d9c5295659944752a3ab5edb", "filename": "compiler/rustc_smir/rust-toolchain.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Frust-toolchain.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Frust-toolchain.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Frust-toolchain.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-06-01\"\n+channel = \"nightly-2023-02-28\"\n components = [ \"rustfmt\", \"rustc-dev\" ]"}, {"sha": "54d474db038e9ddd9ee1b90acc8e459523a49e91", "filename": "compiler/rustc_smir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -11,9 +11,9 @@\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![cfg_attr(not(feature = \"default\"), feature(rustc_private))]\n-#![deny(rustc::untranslatable_diagnostic)]\n-#![deny(rustc::diagnostic_outside_of_impl)]\n \n-pub mod mir;\n+pub mod rustc_internal;\n+pub mod stable_mir;\n \n-pub mod very_unstable;\n+// Make this module private for now since external users should not call these directly.\n+mod rustc_smir;"}, {"sha": "887e6572930669053b7d5de98996d47255f8c0ed", "filename": "compiler/rustc_smir/src/mir.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_smir%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_smir%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fmir.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,10 +0,0 @@\n-pub use crate::very_unstable::hir::ImplicitSelfKind;\n-pub use crate::very_unstable::middle::mir::{\n-    visit::MutVisitor, AggregateKind, AssertKind, BasicBlock, BasicBlockData, BinOp, BindingForm,\n-    BlockTailInfo, Body, BorrowKind, CastKind, ClearCrossCrate, Constant, ConstantKind,\n-    CopyNonOverlapping, Coverage, FakeReadCause, Field, GeneratorInfo, InlineAsmOperand, Local,\n-    LocalDecl, LocalInfo, LocalKind, Location, MirPhase, MirSource, NullOp, Operand, Place,\n-    PlaceRef, ProjectionElem, ProjectionKind, Promoted, RetagKind, Rvalue, Safety, SourceInfo,\n-    SourceScope, SourceScopeData, SourceScopeLocalData, Statement, StatementKind, UnOp,\n-    UserTypeProjection, UserTypeProjections, VarBindingForm, VarDebugInfo, VarDebugInfoContents,\n-};"}, {"sha": "3eaff9c051f1c8f098f8939427a664990f67431c", "filename": "compiler/rustc_smir/src/rustc_internal/mod.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,15 @@\n+//! Module that implements the bridge between Stable MIR and internal compiler MIR.\n+//!\n+//! For that, we define APIs that will temporarily be public to 3P that exposes rustc internal APIs\n+//! until stable MIR is complete.\n+\n+use crate::stable_mir;\n+pub use rustc_span::def_id::{CrateNum, DefId};\n+\n+pub fn item_def_id(item: &stable_mir::CrateItem) -> DefId {\n+    item.0\n+}\n+\n+pub fn crate_num(item: &stable_mir::Crate) -> CrateNum {\n+    item.id.into()\n+}"}, {"sha": "d956f0ac802134baf8b79250ab3a5bc71396ab69", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,48 @@\n+//! Module that implements what will become the rustc side of Stable MIR.\n+//!\n+//! This module is responsible for building Stable MIR components from internal components.\n+//!\n+//! This module is not intended to be invoked directly by users. It will eventually\n+//! become the public API of rustc that will be invoked by the `stable_mir` crate.\n+//!\n+//! For now, we are developing everything inside `rustc`, thus, we keep this module private.\n+\n+use crate::stable_mir::{self};\n+use rustc_middle::ty::{tls::with, TyCtxt};\n+use rustc_span::def_id::{CrateNum, LOCAL_CRATE};\n+use tracing::debug;\n+\n+/// Get information about the local crate.\n+pub fn local_crate() -> stable_mir::Crate {\n+    with(|tcx| smir_crate(tcx, LOCAL_CRATE))\n+}\n+\n+/// Retrieve a list of all external crates.\n+pub fn external_crates() -> Vec<stable_mir::Crate> {\n+    with(|tcx| tcx.crates(()).iter().map(|crate_num| smir_crate(tcx, *crate_num)).collect())\n+}\n+\n+/// Find a crate with the given name.\n+pub fn find_crate(name: &str) -> Option<stable_mir::Crate> {\n+    with(|tcx| {\n+        [LOCAL_CRATE].iter().chain(tcx.crates(()).iter()).find_map(|crate_num| {\n+            let crate_name = tcx.crate_name(*crate_num).to_string();\n+            (name == crate_name).then(|| smir_crate(tcx, *crate_num))\n+        })\n+    })\n+}\n+\n+/// Retrieve all items of the local crate that have a MIR associated with them.\n+pub fn all_local_items() -> stable_mir::CrateItems {\n+    with(|tcx| {\n+        tcx.mir_keys(()).iter().map(|item| stable_mir::CrateItem(item.to_def_id())).collect()\n+    })\n+}\n+\n+/// Build a stable mir crate from a given crate number.\n+fn smir_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> stable_mir::Crate {\n+    let crate_name = tcx.crate_name(crate_num).to_string();\n+    let is_local = crate_num == LOCAL_CRATE;\n+    debug!(?crate_name, ?crate_num, \"smir_crate\");\n+    stable_mir::Crate { id: crate_num.into(), name: crate_name, is_local }\n+}"}, {"sha": "cbf52e691fb475f00dd39696dd4ad447ac5b296f", "filename": "compiler/rustc_smir/src/stable_mir/mod.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,60 @@\n+//! Module that implements the public interface to the Stable MIR.\n+//!\n+//! This module shall contain all type definitions and APIs that we expect 3P tools to invoke to\n+//! interact with the compiler.\n+//!\n+//! The goal is to eventually move this module to its own crate which shall be published on\n+//! [crates.io](https://crates.io).\n+//!\n+//! ## Note:\n+//!\n+//! There shouldn't be any direct references to internal compiler constructs in this module.\n+//! If you need an internal construct, consider using `rustc_internal` or `rustc_smir`.\n+\n+use crate::rustc_internal;\n+\n+/// Use String for now but we should replace it.\n+pub type Symbol = String;\n+\n+/// The number that identifies a crate.\n+pub type CrateNum = usize;\n+\n+/// A unique identification number for each item accessible for the current compilation unit.\n+pub type DefId = usize;\n+\n+/// A list of crate items.\n+pub type CrateItems = Vec<CrateItem>;\n+\n+/// Holds information about a crate.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct Crate {\n+    pub(crate) id: CrateNum,\n+    pub name: Symbol,\n+    pub is_local: bool,\n+}\n+\n+/// Holds information about an item in the crate.\n+/// For now, it only stores the item DefId. Use functions inside `rustc_internal` module to\n+/// use this item.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct CrateItem(pub(crate) rustc_internal::DefId);\n+\n+/// Access to the local crate.\n+pub fn local_crate() -> Crate {\n+    crate::rustc_smir::local_crate()\n+}\n+\n+/// Try to find a crate with the given name.\n+pub fn find_crate(name: &str) -> Option<Crate> {\n+    crate::rustc_smir::find_crate(name)\n+}\n+\n+/// Try to find a crate with the given name.\n+pub fn external_crates() -> Vec<Crate> {\n+    crate::rustc_smir::external_crates()\n+}\n+\n+/// Retrieve all items in the local crate that have a MIR associated with them.\n+pub fn all_local_items() -> CrateItems {\n+    crate::rustc_smir::all_local_items()\n+}"}, {"sha": "12ba133dbb169403305825f59f39eba7cff394a6", "filename": "compiler/rustc_smir/src/very_unstable.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_smir%2Fsrc%2Fvery_unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_smir%2Fsrc%2Fvery_unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fvery_unstable.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,27 +0,0 @@\n-//! This module reexports various crates and modules from unstable rustc APIs.\n-//! Add anything you need here and it will get slowly transferred to a stable API.\n-//! Only use rustc_smir in your dependencies and use the reexports here instead of\n-//! directly referring to the unstable crates.\n-\n-macro_rules! crates {\n-    ($($rustc_name:ident -> $name:ident,)*) => {\n-        $(\n-            #[cfg(not(feature = \"default\"))]\n-            pub extern crate $rustc_name as $name;\n-            #[cfg(feature = \"default\")]\n-            pub use $rustc_name as $name;\n-        )*\n-    }\n-}\n-\n-crates! {\n-    rustc_borrowck -> borrowck,\n-    rustc_driver -> driver,\n-    rustc_hir -> hir,\n-    rustc_interface -> interface,\n-    rustc_middle -> middle,\n-    rustc_mir_dataflow -> dataflow,\n-    rustc_mir_transform -> transform,\n-    rustc_serialize -> serialize,\n-    rustc_trait_selection -> trait_selection,\n-}"}, {"sha": "4e626fd9f30c01920dfa27e1b31cf8665c6bcefa", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1197,6 +1197,8 @@ symbols! {\n         rlib,\n         rotate_left,\n         rotate_right,\n+        roundevenf32,\n+        roundevenf64,\n         roundf32,\n         roundf64,\n         rt,"}, {"sha": "97132311a5c9ad9f56e755089174f21ea6055393", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::{RelocModel, Target};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n use std::fmt;\n@@ -80,7 +80,7 @@ pub fn target_reserves_x18(target: &Target) -> bool {\n fn reserved_x18(\n     _arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    _target_features: &FxHashSet<Symbol>,\n+    _target_features: &FxIndexSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {"}, {"sha": "514e30ae0204da2860f371f5d8b4409bdd15705b", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::{RelocModel, Target};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n use std::fmt;\n@@ -64,14 +64,14 @@ impl ArmInlineAsmRegClass {\n }\n \n // This uses the same logic as useR7AsFramePointer in LLVM\n-fn frame_pointer_is_r7(target_features: &FxHashSet<Symbol>, target: &Target) -> bool {\n+fn frame_pointer_is_r7(target_features: &FxIndexSet<Symbol>, target: &Target) -> bool {\n     target.is_like_osx || (!target.is_like_windows && target_features.contains(&sym::thumb_mode))\n }\n \n fn frame_pointer_r11(\n     arch: InlineAsmArch,\n     reloc_model: RelocModel,\n-    target_features: &FxHashSet<Symbol>,\n+    target_features: &FxIndexSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n@@ -87,7 +87,7 @@ fn frame_pointer_r11(\n fn frame_pointer_r7(\n     _arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    target_features: &FxHashSet<Symbol>,\n+    target_features: &FxIndexSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {\n@@ -101,7 +101,7 @@ fn frame_pointer_r7(\n fn not_thumb1(\n     _arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    target_features: &FxHashSet<Symbol>,\n+    target_features: &FxIndexSet<Symbol>,\n     _target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n@@ -118,7 +118,7 @@ fn not_thumb1(\n fn reserved_r9(\n     arch: InlineAsmArch,\n     reloc_model: RelocModel,\n-    target_features: &FxHashSet<Symbol>,\n+    target_features: &FxIndexSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {"}, {"sha": "0dbfd4267818b6fae1da27367fdecd8f2097c0a1", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n use crate::spec::Target;\n use crate::{abi::Size, spec::RelocModel};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n use std::fmt;\n@@ -37,13 +37,14 @@ macro_rules! def_reg_class {\n \n         pub(super) fn regclass_map() -> rustc_data_structures::fx::FxHashMap<\n             super::InlineAsmRegClass,\n-            rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n+            rustc_data_structures::fx::FxIndexSet<super::InlineAsmReg>,\n         > {\n-            use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+            use rustc_data_structures::fx::FxHashMap;\n+            use rustc_data_structures::fx::FxIndexSet;\n             use super::InlineAsmRegClass;\n             let mut map = FxHashMap::default();\n             $(\n-                map.insert(InlineAsmRegClass::$arch($arch_regclass::$class), FxHashSet::default());\n+                map.insert(InlineAsmRegClass::$arch($arch_regclass::$class), FxIndexSet::default());\n             )*\n             map\n         }\n@@ -94,7 +95,7 @@ macro_rules! def_regs {\n             pub fn validate(self,\n                 _arch: super::InlineAsmArch,\n                 _reloc_model: crate::spec::RelocModel,\n-                _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n+                _target_features: &rustc_data_structures::fx::FxIndexSet<Symbol>,\n                 _target: &crate::spec::Target,\n                 _is_clobber: bool,\n             ) -> Result<(), &'static str> {\n@@ -118,11 +119,11 @@ macro_rules! def_regs {\n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n             _reloc_model: crate::spec::RelocModel,\n-            _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n+            _target_features: &rustc_data_structures::fx::FxIndexSet<Symbol>,\n             _target: &crate::spec::Target,\n             _map: &mut rustc_data_structures::fx::FxHashMap<\n                 super::InlineAsmRegClass,\n-                rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n+                rustc_data_structures::fx::FxIndexSet<super::InlineAsmReg>,\n             >,\n         ) {\n             #[allow(unused_imports)]\n@@ -334,7 +335,7 @@ impl InlineAsmReg {\n         self,\n         arch: InlineAsmArch,\n         reloc_model: RelocModel,\n-        target_features: &FxHashSet<Symbol>,\n+        target_features: &FxIndexSet<Symbol>,\n         target: &Target,\n         is_clobber: bool,\n     ) -> Result<(), &'static str> {\n@@ -701,9 +702,9 @@ impl fmt::Display for InlineAsmType {\n pub fn allocatable_registers(\n     arch: InlineAsmArch,\n     reloc_model: RelocModel,\n-    target_features: &FxHashSet<Symbol>,\n+    target_features: &FxIndexSet<Symbol>,\n     target: &crate::spec::Target,\n-) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n+) -> FxHashMap<InlineAsmRegClass, FxIndexSet<InlineAsmReg>> {\n     match arch {\n         InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n             let mut map = x86::regclass_map();"}, {"sha": "dea6d50fe2ba83239bf1139fad0beb661e0bf67a", "filename": "compiler/rustc_target/src/asm/riscv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::{RelocModel, Target};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n use std::fmt;\n@@ -55,7 +55,7 @@ impl RiscVInlineAsmRegClass {\n fn not_e(\n     _arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    target_features: &FxHashSet<Symbol>,\n+    target_features: &FxIndexSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {"}, {"sha": "3902dac7ff654acf5d41e0f025c3c83f0f29dd61", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::{RelocModel, Target};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n use std::fmt;\n@@ -147,7 +147,7 @@ impl X86InlineAsmRegClass {\n fn x86_64_only(\n     arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    _target_features: &FxHashSet<Symbol>,\n+    _target_features: &FxIndexSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {\n@@ -161,7 +161,7 @@ fn x86_64_only(\n fn high_byte(\n     arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    _target_features: &FxHashSet<Symbol>,\n+    _target_features: &FxIndexSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {\n@@ -174,7 +174,7 @@ fn high_byte(\n fn rbx_reserved(\n     arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    _target_features: &FxHashSet<Symbol>,\n+    _target_features: &FxIndexSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {\n@@ -190,7 +190,7 @@ fn rbx_reserved(\n fn esi_reserved(\n     arch: InlineAsmArch,\n     _reloc_model: RelocModel,\n-    _target_features: &FxHashSet<Symbol>,\n+    _target_features: &FxIndexSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {"}, {"sha": "981a8f45e4542f8f7b78cfdb704a7dcdf8151dba", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -261,12 +261,23 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n         self.interner().mk_re_late_bound(self.binder_index, br)\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, mut t: Ty<'tcx>) -> Ty<'tcx> {\n         let kind = match *t.kind() {\n-            ty::Infer(ty::TyVar(vid)) => match self.infcx.probe_ty_var(vid) {\n-                Ok(t) => return self.fold_ty(t),\n-                Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n-            },\n+            ty::Infer(ty::TyVar(mut vid)) => {\n+                // We need to canonicalize the *root* of our ty var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_var(vid);\n+                if root_vid != vid {\n+                    t = self.infcx.tcx.mk_ty_var(root_vid);\n+                    vid = root_vid;\n+                }\n+\n+                match self.infcx.probe_ty_var(vid) {\n+                    Ok(t) => return self.fold_ty(t),\n+                    Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n+                }\n+            }\n             ty::Infer(ty::IntVar(_)) => {\n                 let nt = self.infcx.shallow_resolve(t);\n                 if nt != t {\n@@ -338,13 +349,23 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n         self.interner().mk_bound(self.binder_index, bt)\n     }\n \n-    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+    fn fold_const(&mut self, mut c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         let kind = match c.kind() {\n-            ty::ConstKind::Infer(ty::InferConst::Var(vid)) => match self.infcx.probe_const_var(vid)\n-            {\n-                Ok(c) => return self.fold_const(c),\n-                Err(universe) => CanonicalVarKind::Const(universe, c.ty()),\n-            },\n+            ty::ConstKind::Infer(ty::InferConst::Var(mut vid)) => {\n+                // We need to canonicalize the *root* of our const var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_const_var(vid);\n+                if root_vid != vid {\n+                    c = self.infcx.tcx.mk_const(ty::InferConst::Var(root_vid), c.ty());\n+                    vid = root_vid;\n+                }\n+\n+                match self.infcx.probe_const_var(vid) {\n+                    Ok(c) => return self.fold_const(c),\n+                    Err(universe) => CanonicalVarKind::Const(universe, c.ty()),\n+                }\n+            }\n             ty::ConstKind::Infer(ty::InferConst::Fresh(_)) => {\n                 bug!(\"fresh var during canonicalization: {c:?}\")\n             }"}, {"sha": "38120b9760f3d46d300224f61b986449deb072fb", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -149,6 +149,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n         &mut self,\n         _: &InferCtxt<'tcx>,\n     ) -> Vec<PredicateObligation<'tcx>> {\n-        unimplemented!()\n+        std::mem::take(&mut self.obligations)\n     }\n }"}, {"sha": "43fd415e871e18dcdd2ba31c647bb27d66596323", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -238,6 +238,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             && has_changed\n             && !self.in_projection_eq_hack\n             && !self.search_graph.in_cycle()\n+            && false\n         {\n             let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let canonical_response ="}, {"sha": "62d5e50dbc5484e916bb7e5b1adcdd5a61320f65", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         self.infcx\n             .at(cause, param_env)\n             .define_opaque_types(true)\n-            .sup(expected, actual)\n+            .sub(expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n "}, {"sha": "336db4fee6ced7e4981a31b6eb5b6e1dc43cb039", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -87,7 +87,12 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             };\n             let ty = ocx.normalize(&normalization_cause, param_env, unnormalized_ty);\n             let normalization_errors = ocx.select_where_possible();\n-            if !normalization_errors.is_empty() {\n+\n+            // NOTE: The post-normalization type may also reference errors,\n+            // such as when we project to a missing type or we have a mismatch\n+            // between expected and found const-generic types. Don't report an\n+            // additional copy error here, since it's not typically useful.\n+            if !normalization_errors.is_empty() || ty.references_error() {\n                 tcx.sess.delay_span_bug(field_span, format!(\"couldn't normalize struct field `{unnormalized_ty}` when checking Copy implementation\"));\n                 continue;\n             }"}, {"sha": "62bad5b49b4607090469034824897562a948f9bd", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -155,10 +155,12 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n         predicate: pred.to_predicate(infcx.tcx),\n     };\n \n-    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n+    let result = infcx.evaluate_obligation_no_overflow(&obligation);\n     debug!(?result);\n \n-    if result && has_non_region_infer {\n+    if result.must_apply_modulo_regions() && !has_non_region_infer {\n+        true\n+    } else if result.may_apply() {\n         // Because of inference \"guessing\", selection can sometimes claim\n         // to succeed while the success requires a guess. To ensure\n         // this function's result remains infallible, we must confirm\n@@ -179,7 +181,7 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n             }\n         }\n     } else {\n-        result\n+        false\n     }\n }\n "}, {"sha": "01075d7c55aee4dae8b1e8a355b93b86a0b5ceb0", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -870,12 +870,12 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for PlaceholderReplacer<'_, 'tcx> {\n \n     fn fold_region(&mut self, r0: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         let r1 = match *r0 {\n-            ty::ReVar(_) => self\n+            ty::ReVar(vid) => self\n                 .infcx\n                 .inner\n                 .borrow_mut()\n                 .unwrap_region_constraints()\n-                .opportunistic_resolve_region(self.infcx.tcx, r0),\n+                .opportunistic_resolve_var(self.infcx.tcx, vid),\n             _ => r0,\n         };\n \n@@ -2199,7 +2199,8 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         Err(guar) => return Progress::error(tcx, guar),\n     };\n     // We don't support specialization for RPITITs anyways... yet.\n-    if !leaf_def.is_final() {\n+    // Also don't try to project to an RPITIT that has no value\n+    if !leaf_def.is_final() || !leaf_def.item.defaultness(tcx).has_value() {\n         return Progress { term: tcx.ty_error_misc().into(), obligations };\n     }\n "}, {"sha": "48c3b3601b4d3ce5e0a05cedfe11dc5ab1af2333", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1083,7 +1083,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let mut nested_result = EvaluationResult::EvaluatedToOk;\n                     for obligation in nested_obligations {\n                         nested_result = cmp::max(\n-                            this.evaluate_predicate_recursively(stack.list(), obligation)?,\n+                            this.evaluate_predicate_recursively(previous_stack, obligation)?,\n                             nested_result,\n                         );\n                     }\n@@ -1092,7 +1092,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let obligation = obligation.with(this.tcx(), predicate);\n                         result = cmp::max(\n                             nested_result,\n-                            this.evaluate_trait_predicate_recursively(stack.list(), obligation)?,\n+                            this.evaluate_trait_predicate_recursively(previous_stack, obligation)?,\n                         );\n                     }\n                 }\n@@ -2149,7 +2149,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(..) => None,\n             ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n-            // We can make this an ICE if/once we actually instantiate the trait obligation.\n+            // We can make this an ICE if/once we actually instantiate the trait obligation eagerly.\n             ty::Bound(..) => None,\n \n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n@@ -2257,7 +2257,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Adt(..) | ty::Alias(..) | ty::Param(..) => {\n+            ty::Adt(..) | ty::Alias(..) | ty::Param(..) | ty::Placeholder(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -2269,9 +2269,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ambiguous\n             }\n \n-            ty::Placeholder(..)\n-            | ty::Bound(..)\n-            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+            // We can make this an ICE if/once we actually instantiate the trait obligation eagerly.\n+            ty::Bound(..) => None,\n+\n+            ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\", self_ty);\n             }\n         }"}, {"sha": "cae7f36a2081f9f88158d9f15f000fc1b87a486f", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,7 +1,6 @@\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::ty::{self, ImplTraitInTraitData, InternalSubsts, TyCtxt};\n@@ -97,7 +96,7 @@ fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems {\n     }\n }\n \n-fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> FxHashMap<DefId, DefId> {\n+fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> DefIdMap<DefId> {\n     tcx.associated_items(impl_id)\n         .in_definition_order()\n         .filter_map(|item| item.trait_item_def_id.map(|trait_item| (trait_item, item.def_id)))"}, {"sha": "70c9de91fbfef62a4d50b04cb488dd07a833005c", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -142,12 +142,14 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n         && tcx.associated_item(def_id).container == ty::AssocItemContainer::TraitContainer\n     {\n         let sig = tcx.fn_sig(def_id).subst_identity();\n-        sig.visit_with(&mut ImplTraitInTraitFinder {\n+        // We accounted for the binder of the fn sig, so skip the binder.\n+        sig.skip_binder().visit_with(&mut ImplTraitInTraitFinder {\n             tcx,\n             fn_def_id: def_id,\n             bound_vars: sig.bound_vars(),\n             predicates: &mut predicates,\n             seen: FxHashSet::default(),\n+            depth: ty::INNERMOST,\n         });\n     }\n \n@@ -244,15 +246,36 @@ struct ImplTraitInTraitFinder<'a, 'tcx> {\n     fn_def_id: DefId,\n     bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n     seen: FxHashSet<DefId>,\n+    depth: ty::DebruijnIndex,\n }\n \n impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n+    fn visit_binder<T: TypeVisitable<TyCtxt<'tcx>>>(\n+        &mut self,\n+        binder: &ty::Binder<'tcx, T>,\n+    ) -> std::ops::ControlFlow<Self::BreakTy> {\n+        self.depth.shift_in(1);\n+        let binder = binder.super_visit_with(self);\n+        self.depth.shift_out(1);\n+        binder\n+    }\n+\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n         if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n             && self.tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n             && self.tcx.impl_trait_in_trait_parent(alias_ty.def_id) == self.fn_def_id\n             && self.seen.insert(alias_ty.def_id)\n         {\n+            // We have entered some binders as we've walked into the\n+            // bounds of the RPITIT. Shift these binders back out when\n+            // constructing the top-level projection predicate.\n+            let alias_ty = self.tcx.fold_regions(alias_ty, |re, _| {\n+                if let ty::ReLateBound(index, bv) = re.kind() {\n+                    self.tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n+                } else {\n+                    re\n+                }\n+            });\n             self.predicates.push(\n                 ty::Binder::bind_with_vars(\n                     ty::ProjectionPredicate {"}, {"sha": "dee0d8f254b63596dfded6caf64c7c197dbcb9ab", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -46,12 +46,6 @@ changelog-seen = 2\n # Defaults to \"if-available\" when `channel = \"dev\"` and \"false\" otherwise.\n #download-ci-llvm = \"if-available\"\n \n-# Indicates whether LLVM rebuild should be skipped when running bootstrap. If\n-# this is `false` then the compiler's LLVM will be rebuilt whenever the built\n-# version doesn't have the correct hash. If it is `true` then LLVM will never\n-# be rebuilt. The default value is `false`.\n-#skip-rebuild = false\n-\n # Indicates whether the LLVM build is a Release or Debug build\n #optimize = true\n \n@@ -81,11 +75,6 @@ changelog-seen = 2\n # or alternatively ...\n #ccache = \"/path/to/ccache\"\n \n-# If an external LLVM root is specified, we automatically check the version by\n-# default to make sure it's within the range that we're expecting, but setting\n-# this flag will indicate that this version check should not be done.\n-#version-check = true\n-\n # When true, link libstdc++ statically into the rustc_llvm.\n # This is useful if you don't want to use the dynamic version of that\n # library provided by LLVM.\n@@ -670,6 +659,10 @@ changelog-seen = 2\n # Build compiler with the optimization enabled and -Zvalidate-mir, currently only for `std`\n #validate-mir-opts = 3\n \n+# Copy the linker, DLLs, and various libraries from MinGW into the rustc toolchain.\n+# Only applies when the host or target is pc-windows-gnu.\n+#include-mingw-linker = true\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "74ef0949b8af27da959bc62ab3751dfa7c34e1f3", "filename": "library/core/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -20,6 +20,7 @@ mod ops;\n mod pattern;\n mod slice;\n mod str;\n+mod tuple;\n \n /// Returns a `rand::Rng` seeded with a consistent seed.\n ///"}, {"sha": "d9ff9d0dd9378feb4a21f5994e467e28c22a984f", "filename": "library/core/benches/tuple.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fbenches%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fbenches%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Ftuple.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,22 @@\n+use rand::prelude::*;\n+use test::{black_box, Bencher};\n+\n+#[bench]\n+fn bench_tuple_comparison(b: &mut Bencher) {\n+    let mut rng = black_box(super::bench_rng());\n+\n+    let data = black_box([\n+        (\"core::iter::adapters::Chain\", 123_usize),\n+        (\"core::iter::adapters::Clone\", 456_usize),\n+        (\"core::iter::adapters::Copie\", 789_usize),\n+        (\"core::iter::adapters::Cycle\", 123_usize),\n+        (\"core::iter::adapters::Flatt\", 456_usize),\n+        (\"core::iter::adapters::TakeN\", 789_usize),\n+    ]);\n+\n+    b.iter(|| {\n+        let x = data.choose(&mut rng).unwrap();\n+        let y = data.choose(&mut rng).unwrap();\n+        [x < y, x <= y, x > y, x >= y]\n+    });\n+}"}, {"sha": "c6321587adc6227cafdb9a5b3791090486f201c6", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1585,9 +1585,15 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`f32::round_ties_even`](../../std/primitive.f32.html#method.round_ties_even)\n     pub fn rintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`f64::round_ties_even`](../../std/primitive.f64.html#method.round_ties_even)\n     pub fn rintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`.\n@@ -1610,6 +1616,19 @@ extern \"rust-intrinsic\" {\n     /// [`f64::round`](../../std/primitive.f64.html#method.round)\n     pub fn roundf64(x: f64) -> f64;\n \n+    /// Returns the nearest integer to an `f32`. Rounds half-way cases to the number\n+    /// with an even least significant digit.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    #[cfg(not(bootstrap))]\n+    pub fn roundevenf32(x: f32) -> f32;\n+    /// Returns the nearest integer to an `f64`. Rounds half-way cases to the number\n+    /// with an even least significant digit.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    #[cfg(not(bootstrap))]\n+    pub fn roundevenf64(x: f64) -> f64;\n+\n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///"}, {"sha": "d2d9771bdce2eee6e85bcc70c8db11de97cf084a", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -227,7 +227,7 @@\n //! are no resume and abort terminators, and terminators that might unwind do not have any way to\n //! indicate the unwind block.\n //!\n-//!  - [`Goto`], [`Return`], [`Unreachable`], [`Drop`](Drop()), and [`DropAndReplace`] have associated functions.\n+//!  - [`Goto`], [`Return`], [`Unreachable`] and [`Drop`](Drop()) have associated functions.\n //!  - `match some_int_operand` becomes a `SwitchInt`. Each arm should be `literal => basic_block`\n //!     - The exception is the last arm, which must be `_ => basic_block` and corresponds to the\n //!       otherwise branch.\n@@ -259,7 +259,6 @@ define!(\"mir_return\", fn Return() -> BasicBlock);\n define!(\"mir_goto\", fn Goto(destination: BasicBlock) -> BasicBlock);\n define!(\"mir_unreachable\", fn Unreachable() -> BasicBlock);\n define!(\"mir_drop\", fn Drop<T>(place: T, goto: BasicBlock));\n-define!(\"mir_drop_and_replace\", fn DropAndReplace<T>(place: T, value: T, goto: BasicBlock));\n define!(\"mir_call\", fn Call<T>(place: T, goto: BasicBlock, call: T));\n define!(\"mir_storage_live\", fn StorageLive<T>(local: T));\n define!(\"mir_storage_dead\", fn StorageDead<T>(local: T));"}, {"sha": "427146941ade87e5ce86130fd71c9976eabb2611", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -324,7 +324,7 @@ pub trait StructuralEq {\n /// attempt to derive a `Copy` implementation, we'll get an error:\n ///\n /// ```text\n-/// the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n+/// the trait `Copy` cannot be implemented for this type; field `points` does not implement `Copy`\n /// ```\n ///\n /// Shared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds"}, {"sha": "3539353240a9baa81333defbe312d76e445549b4", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,6 +2,7 @@\n \n use crate::intrinsics::assert_unsafe_precondition;\n use crate::intrinsics::const_eval_select;\n+use crate::intrinsics::unchecked_sub;\n use crate::ops;\n use crate::ptr;\n \n@@ -371,33 +372,34 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        let this = ops::Range { start: self.start, end: self.end };\n+        let this = ops::Range { ..self };\n         // SAFETY: the caller guarantees that `slice` is not dangling, so it\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n-        // so the call to `add` is safe.\n-\n+        // so the call to `add` is safe and the length calculation cannot overflow.\n         unsafe {\n             assert_unsafe_precondition!(\n                 \"slice::get_unchecked requires that the range is within the slice\",\n                 [T](this: ops::Range<usize>, slice: *const [T]) =>\n                 this.end >= this.start && this.end <= slice.len()\n             );\n-            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n+            let new_len = unchecked_sub(self.end, self.start);\n+            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len)\n         }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        let this = ops::Range { start: self.start, end: self.end };\n+        let this = ops::Range { ..self };\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n             assert_unsafe_precondition!(\n                 \"slice::get_unchecked_mut requires that the range is within the slice\",\n                 [T](this: ops::Range<usize>, slice: *mut [T]) =>\n                 this.end >= this.start && this.end <= slice.len()\n             );\n-            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+            let new_len = unchecked_sub(self.end, self.start);\n+            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), new_len)\n         }\n     }\n "}, {"sha": "d319b2bc37fddfd6ee2c78fb900e5dc3c07206c3", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1695,7 +1695,13 @@ impl<T> [T] {\n         let ptr = self.as_ptr();\n \n         // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n-        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid)) }\n+        unsafe {\n+            assert_unsafe_precondition!(\n+                \"slice::split_at_unchecked requires the index to be within the slice\",\n+                (mid: usize, len: usize) => mid <= len\n+            );\n+            (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid))\n+        }\n     }\n \n     /// Divides one mutable slice into two at an index, without doing bounds checking."}, {"sha": "41c097b55eefb343c8fdea99264972b57af5af9e", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,6 +1,7 @@\n //! Trait implementations for `str`.\n \n use crate::cmp::Ordering;\n+use crate::intrinsics::assert_unsafe_precondition;\n use crate::ops;\n use crate::ptr;\n use crate::slice::SliceIndex;\n@@ -194,15 +195,37 @@ unsafe impl const SliceIndex<str> for ops::Range<usize> {\n         let slice = slice as *const [u8];\n         // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n         // which satisfies all the conditions for `add`.\n-        let ptr = unsafe { slice.as_ptr().add(self.start) };\n+        let ptr = unsafe {\n+            let this = ops::Range { ..self };\n+            assert_unsafe_precondition!(\n+                \"str::get_unchecked requires that the range is within the string slice\",\n+                (this: ops::Range<usize>, slice: *const [u8]) =>\n+                // We'd like to check that the bounds are on char boundaries,\n+                // but there's not really a way to do so without reading\n+                // behind the pointer, which has aliasing implications.\n+                // It's also not possible to move this check up to\n+                // `str::get_unchecked` without adding a special function\n+                // to `SliceIndex` just for this.\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n+            slice.as_ptr().add(self.start)\n+        };\n         let len = self.end - self.start;\n         ptr::slice_from_raw_parts(ptr, len) as *const str\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         let slice = slice as *mut [u8];\n         // SAFETY: see comments for `get_unchecked`.\n-        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n+        let ptr = unsafe {\n+            let this = ops::Range { ..self };\n+            assert_unsafe_precondition!(\n+                \"str::get_unchecked_mut requires that the range is within the string slice\",\n+                (this: ops::Range<usize>, slice: *mut [u8]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n+            slice.as_mut_ptr().add(self.start)\n+        };\n         let len = self.end - self.start;\n         ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n     }\n@@ -272,15 +295,13 @@ unsafe impl const SliceIndex<str> for ops::RangeTo<usize> {\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-        let slice = slice as *const [u8];\n-        let ptr = slice.as_ptr();\n-        ptr::slice_from_raw_parts(ptr, self.end) as *const str\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..self.end).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-        let slice = slice as *mut [u8];\n-        let ptr = slice.as_mut_ptr();\n-        ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n@@ -343,20 +364,15 @@ unsafe impl const SliceIndex<str> for ops::RangeFrom<usize> {\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-        let slice = slice as *const [u8];\n-        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n-        // which satisfies all the conditions for `add`.\n-        let ptr = unsafe { slice.as_ptr().add(self.start) };\n-        let len = slice.len() - self.start;\n-        ptr::slice_from_raw_parts(ptr, len) as *const str\n+        let len = (slice as *const [u8]).len();\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (self.start..len).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-        let slice = slice as *mut [u8];\n-        // SAFETY: identical to `get_unchecked`.\n-        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n-        let len = slice.len() - self.start;\n-        ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n+        let len = (slice as *mut [u8]).len();\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (self.start..len).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n@@ -452,35 +468,29 @@ unsafe impl const SliceIndex<str> for ops::RangeToInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n-        if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n+        (0..=self.end).get(slice)\n     }\n     #[inline]\n     fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-        if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n+        (0..=self.end).get_mut(slice)\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (..self.end + 1).get_unchecked(slice) }\n+        unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n+        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n-        if self.end == usize::MAX {\n-            str_index_overflow_fail();\n-        }\n-        (..self.end + 1).index(slice)\n+        (0..=self.end).index(slice)\n     }\n     #[inline]\n     fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-        if self.end == usize::MAX {\n-            str_index_overflow_fail();\n-        }\n-        (..self.end + 1).index_mut(slice)\n+        (0..=self.end).index_mut(slice)\n     }\n }\n "}, {"sha": "0620e7173bc1779dc818f2e80afa5aa6bb1b0fac", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,7 +1,7 @@\n // See src/libstd/primitive_docs.rs for documentation.\n \n-use crate::cmp::Ordering::*;\n-use crate::cmp::*;\n+use crate::cmp::Ordering::{self, *};\n+use crate::mem::transmute;\n \n // Recursive macro for implementing n-ary tuple functions and operations\n //\n@@ -61,19 +61,19 @@ macro_rules! tuple_impls {\n                 }\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                    lexical_ord!(lt, Less, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                 }\n                 #[inline]\n                 fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                    lexical_ord!(le, Less, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                 }\n                 #[inline]\n                 fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                    lexical_ord!(ge, Greater, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                 }\n                 #[inline]\n                 fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+                    lexical_ord!(gt, Greater, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                 }\n             }\n         }\n@@ -123,16 +123,38 @@ macro_rules! maybe_tuple_doc {\n     };\n }\n \n-// Constructs an expression that performs a lexical ordering using method $rel.\n+#[inline]\n+const fn ordering_is_some(c: Option<Ordering>, x: Ordering) -> bool {\n+    // FIXME: Just use `==` once that's const-stable on `Option`s.\n+    // This isn't using `match` because that optimizes worse due to\n+    // making a two-step check (`Some` *then* the inner value).\n+\n+    // SAFETY: There's no public guarantee for `Option<Ordering>`,\n+    // but we're core so we know that it's definitely a byte.\n+    unsafe {\n+        let c: i8 = transmute(c);\n+        let x: i8 = transmute(Some(x));\n+        c == x\n+    }\n+}\n+\n+// Constructs an expression that performs a lexical ordering using method `$rel`.\n // The values are interleaved, so the macro invocation for\n-// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, a1, b1, a2, b2,\n-// a3, b3)` (and similarly for `lexical_cmp`)\n+// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, opt_is_lt, a1, b1,\n+// a2, b2, a3, b3)` (and similarly for `lexical_cmp`)\n+//\n+// `$ne_rel` is only used to determine the result after checking that they're\n+// not equal, so `lt` and `le` can both just use `Less`.\n macro_rules! lexical_ord {\n-    ($rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        if $a != $b { lexical_ord!($rel, $a, $b) }\n-        else { lexical_ord!($rel, $($rest_a, $rest_b),+) }\n+    ($rel: ident, $ne_rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {{\n+        let c = PartialOrd::partial_cmp(&$a, &$b);\n+        if !ordering_is_some(c, Equal) { ordering_is_some(c, $ne_rel) }\n+        else { lexical_ord!($rel, $ne_rel, $($rest_a, $rest_b),+) }\n+    }};\n+    ($rel: ident, $ne_rel: ident, $a:expr, $b:expr) => {\n+        // Use the specific method for the last element\n+        PartialOrd::$rel(&$a, &$b)\n     };\n-    ($rel: ident, $a:expr, $b:expr) => { ($a) . $rel (& $b) };\n }\n \n macro_rules! lexical_partial_cmp {"}, {"sha": "c7c33678fd34c1e3dbdeb9af3f249c333ac93735", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -78,10 +78,14 @@ impl f32 {\n     /// let f = 3.3_f32;\n     /// let g = -3.3_f32;\n     /// let h = -3.7_f32;\n+    /// let i = 3.5_f32;\n+    /// let j = 4.5_f32;\n     ///\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n     /// assert_eq!(h.round(), -4.0);\n+    /// assert_eq!(i.round(), 4.0);\n+    /// assert_eq!(j.round(), 5.0);\n     /// ```\n     #[rustc_allow_incoherent_impl]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n@@ -91,6 +95,32 @@ impl f32 {\n         unsafe { intrinsics::roundf32(self) }\n     }\n \n+    /// Returns the nearest integer to a number. Rounds half-way cases to the number\n+    /// with an even least significant digit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_ties_even)]\n+    ///\n+    /// let f = 3.3_f32;\n+    /// let g = -3.3_f32;\n+    /// let h = 3.5_f32;\n+    /// let i = 4.5_f32;\n+    ///\n+    /// assert_eq!(f.round_ties_even(), 3.0);\n+    /// assert_eq!(g.round_ties_even(), -3.0);\n+    /// assert_eq!(h.round_ties_even(), 4.0);\n+    /// assert_eq!(i.round_ties_even(), 4.0);\n+    /// ```\n+    #[rustc_allow_incoherent_impl]\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"round_ties_even\", issue = \"96710\")]\n+    #[inline]\n+    pub fn round_ties_even(self) -> f32 {\n+        unsafe { intrinsics::rintf32(self) }\n+    }\n+\n     /// Returns the integer part of `self`.\n     /// This means that non-integer numbers are always truncated towards zero.\n     ///"}, {"sha": "e949def00bb1fe9b36f08954b1291a5f304ac20f", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -209,6 +209,7 @@ fn test_ceil() {\n \n #[test]\n fn test_round() {\n+    assert_approx_eq!(2.5f32.round(), 3.0f32);\n     assert_approx_eq!(1.0f32.round(), 1.0f32);\n     assert_approx_eq!(1.3f32.round(), 1.0f32);\n     assert_approx_eq!(1.5f32.round(), 2.0f32);\n@@ -221,6 +222,21 @@ fn test_round() {\n     assert_approx_eq!((-1.7f32).round(), -2.0f32);\n }\n \n+#[test]\n+fn test_round_ties_even() {\n+    assert_approx_eq!(2.5f32.round_ties_even(), 2.0f32);\n+    assert_approx_eq!(1.0f32.round_ties_even(), 1.0f32);\n+    assert_approx_eq!(1.3f32.round_ties_even(), 1.0f32);\n+    assert_approx_eq!(1.5f32.round_ties_even(), 2.0f32);\n+    assert_approx_eq!(1.7f32.round_ties_even(), 2.0f32);\n+    assert_approx_eq!(0.0f32.round_ties_even(), 0.0f32);\n+    assert_approx_eq!((-0.0f32).round_ties_even(), -0.0f32);\n+    assert_approx_eq!((-1.0f32).round_ties_even(), -1.0f32);\n+    assert_approx_eq!((-1.3f32).round_ties_even(), -1.0f32);\n+    assert_approx_eq!((-1.5f32).round_ties_even(), -2.0f32);\n+    assert_approx_eq!((-1.7f32).round_ties_even(), -2.0f32);\n+}\n+\n #[test]\n fn test_trunc() {\n     assert_approx_eq!(1.0f32.trunc(), 1.0f32);"}, {"sha": "b1faa670307d6f2c95d197ecd0755bb923dd8914", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -78,10 +78,14 @@ impl f64 {\n     /// let f = 3.3_f64;\n     /// let g = -3.3_f64;\n     /// let h = -3.7_f64;\n+    /// let i = 3.5_f64;\n+    /// let j = 4.5_f64;\n     ///\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n     /// assert_eq!(h.round(), -4.0);\n+    /// assert_eq!(i.round(), 4.0);\n+    /// assert_eq!(j.round(), 5.0);\n     /// ```\n     #[rustc_allow_incoherent_impl]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n@@ -91,6 +95,32 @@ impl f64 {\n         unsafe { intrinsics::roundf64(self) }\n     }\n \n+    /// Returns the nearest integer to a number. Rounds half-way cases to the number\n+    /// with an even least significant digit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_ties_even)]\n+    ///\n+    /// let f = 3.3_f64;\n+    /// let g = -3.3_f64;\n+    /// let h = 3.5_f64;\n+    /// let i = 4.5_f64;\n+    ///\n+    /// assert_eq!(f.round_ties_even(), 3.0);\n+    /// assert_eq!(g.round_ties_even(), -3.0);\n+    /// assert_eq!(h.round_ties_even(), 4.0);\n+    /// assert_eq!(i.round_ties_even(), 4.0);\n+    /// ```\n+    #[rustc_allow_incoherent_impl]\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"round_ties_even\", issue = \"96710\")]\n+    #[inline]\n+    pub fn round_ties_even(self) -> f64 {\n+        unsafe { intrinsics::rintf64(self) }\n+    }\n+\n     /// Returns the integer part of `self`.\n     /// This means that non-integer numbers are always truncated towards zero.\n     ///"}, {"sha": "53d351cceef5c4441a76d3fb0354d2bca2a5a674", "filename": "library/std/src/f64/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -199,6 +199,7 @@ fn test_ceil() {\n \n #[test]\n fn test_round() {\n+    assert_approx_eq!(2.5f64.round(), 3.0f64);\n     assert_approx_eq!(1.0f64.round(), 1.0f64);\n     assert_approx_eq!(1.3f64.round(), 1.0f64);\n     assert_approx_eq!(1.5f64.round(), 2.0f64);\n@@ -211,6 +212,21 @@ fn test_round() {\n     assert_approx_eq!((-1.7f64).round(), -2.0f64);\n }\n \n+#[test]\n+fn test_round_ties_even() {\n+    assert_approx_eq!(2.5f64.round_ties_even(), 2.0f64);\n+    assert_approx_eq!(1.0f64.round_ties_even(), 1.0f64);\n+    assert_approx_eq!(1.3f64.round_ties_even(), 1.0f64);\n+    assert_approx_eq!(1.5f64.round_ties_even(), 2.0f64);\n+    assert_approx_eq!(1.7f64.round_ties_even(), 2.0f64);\n+    assert_approx_eq!(0.0f64.round_ties_even(), 0.0f64);\n+    assert_approx_eq!((-0.0f64).round_ties_even(), -0.0f64);\n+    assert_approx_eq!((-1.0f64).round_ties_even(), -1.0f64);\n+    assert_approx_eq!((-1.3f64).round_ties_even(), -1.0f64);\n+    assert_approx_eq!((-1.5f64).round_ties_even(), -2.0f64);\n+    assert_approx_eq!((-1.7f64).round_ties_even(), -2.0f64);\n+}\n+\n #[test]\n fn test_trunc() {\n     assert_approx_eq!(1.0f64.trunc(), 1.0f64);"}, {"sha": "7837dd276d269702c10807b11486bae67c7122fc", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -304,6 +304,7 @@\n #![feature(provide_any)]\n #![feature(ptr_as_uninit)]\n #![feature(raw_os_nonzero)]\n+#![feature(round_ties_even)]\n #![feature(slice_internals)]\n #![feature(slice_ptr_get)]\n #![feature(std_internals)]"}, {"sha": "648eb553c78c181d84e606f278ace06f55347ccb", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -16,6 +16,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n - `remote-test-server`'s `verbose` argument has been removed in favor of the `--verbose` flag\n - `remote-test-server`'s `remote` argument has been removed in favor of the `--bind` flag. Use `--bind 0.0.0.0:12345` to replicate the behavior of the `remote` argument.\n - `x.py fmt` now formats only files modified between the merge-base of HEAD and the last commit in the master branch of the rust-lang repository and the current working directory. To restore old behaviour, use `x.py fmt .`. The check mode is not affected by this change. [#105702](https://github.com/rust-lang/rust/pull/105702)\n+- The `llvm.version-check` config option has been removed. Older versions were never supported. If you still need to support older versions (e.g. you are applying custom patches), patch `check_llvm_version` in bootstrap to change the minimum version. [#108619](https://github.com/rust-lang/rust/pull/108619)\n \n ### Non-breaking changes\n "}, {"sha": "47d742ef7964d06f4bb02a952808f6a3ad77f3a6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -711,6 +711,7 @@ impl<'a> Builder<'a> {\n                 test::RustdocUi,\n                 test::RustdocJson,\n                 test::HtmlCheck,\n+                test::RustInstaller,\n                 // Run bootstrap close to the end as it's unlikely to fail\n                 test::Bootstrap,\n                 // Run run-make last, since these won't pass without make on Windows\n@@ -1720,6 +1721,15 @@ impl<'a> Builder<'a> {\n \n         cargo.env(\"RUSTC_VERBOSE\", self.verbosity.to_string());\n \n+        // Downstream forks of the Rust compiler might want to use a custom libc to add support for\n+        // targets that are not yet available upstream. Adding a patch to replace libc with a\n+        // custom one would cause compilation errors though, because Cargo would interpret the\n+        // custom libc as part of the workspace, and apply the check-cfg lints on it.\n+        //\n+        // The libc build script emits check-cfg flags only when this environment variable is set,\n+        // so this line allows the use of custom libcs.\n+        cargo.env(\"LIBC_CHECK_CFG\", \"1\");\n+\n         if source_type == SourceType::InTree {\n             let mut lint_flags = Vec::new();\n             // When extending this list, add the new lints to the RUSTFLAGS of the"}, {"sha": "4f417d36511ba6af6bffcae40a1e29b61711d0f8", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -112,14 +112,12 @@ pub struct Config {\n     pub backtrace_on_ice: bool,\n \n     // llvm codegen options\n-    pub llvm_skip_rebuild: bool,\n     pub llvm_assertions: bool,\n     pub llvm_tests: bool,\n     pub llvm_plugins: bool,\n     pub llvm_optimize: bool,\n     pub llvm_thin_lto: bool,\n     pub llvm_release_debuginfo: bool,\n-    pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n     /// `None` if `llvm_from_ci` is true and we haven't yet downloaded llvm.\n     #[cfg(not(test))]\n@@ -192,6 +190,7 @@ pub struct Config {\n     pub dist_sign_folder: Option<PathBuf>,\n     pub dist_upload_addr: Option<String>,\n     pub dist_compression_formats: Option<Vec<String>>,\n+    pub dist_include_mingw_linker: bool,\n \n     // libstd features\n     pub backtrace: bool, // support for RUST_BACKTRACE\n@@ -666,15 +665,13 @@ define_config! {\n define_config! {\n     /// TOML representation of how the LLVM build is configured.\n     struct Llvm {\n-        skip_rebuild: Option<bool> = \"skip-rebuild\",\n         optimize: Option<bool> = \"optimize\",\n         thin_lto: Option<bool> = \"thin-lto\",\n         release_debuginfo: Option<bool> = \"release-debuginfo\",\n         assertions: Option<bool> = \"assertions\",\n         tests: Option<bool> = \"tests\",\n         plugins: Option<bool> = \"plugins\",\n         ccache: Option<StringOrBool> = \"ccache\",\n-        version_check: Option<bool> = \"version-check\",\n         static_libstdcpp: Option<bool> = \"static-libstdcpp\",\n         ninja: Option<bool> = \"ninja\",\n         targets: Option<String> = \"targets\",\n@@ -704,6 +701,7 @@ define_config! {\n         src_tarball: Option<bool> = \"src-tarball\",\n         missing_tools: Option<bool> = \"missing-tools\",\n         compression_formats: Option<Vec<String>> = \"compression-formats\",\n+        include_mingw_linker: Option<bool> = \"include-mingw-linker\",\n     }\n }\n \n@@ -806,7 +804,6 @@ impl Config {\n         let mut config = Config::default();\n         config.llvm_optimize = true;\n         config.ninja_in_file = true;\n-        config.llvm_version_check = true;\n         config.llvm_static_stdcpp = false;\n         config.backtrace = true;\n         config.rust_optimize = true;\n@@ -821,6 +818,7 @@ impl Config {\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n         config.deny_warnings = true;\n         config.bindir = \"bin\".into();\n+        config.dist_include_mingw_linker = true;\n \n         // set by build.rs\n         config.build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n@@ -1060,11 +1058,6 @@ impl Config {\n             config.mandir = install.mandir.map(PathBuf::from);\n         }\n \n-        // We want the llvm-skip-rebuild flag to take precedence over the\n-        // skip-rebuild config.toml option so we store it separately\n-        // so that we can infer the right value\n-        let mut llvm_skip_rebuild = flags.llvm_skip_rebuild;\n-\n         // Store off these values as options because if they're not provided\n         // we'll infer default values for them later\n         let mut llvm_assertions = None;\n@@ -1170,11 +1163,9 @@ impl Config {\n             llvm_assertions = llvm.assertions;\n             llvm_tests = llvm.tests;\n             llvm_plugins = llvm.plugins;\n-            llvm_skip_rebuild = llvm_skip_rebuild.or(llvm.skip_rebuild);\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_thin_lto, llvm.thin_lto);\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n-            set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n             if let Some(v) = llvm.link_shared {\n                 config.llvm_link_shared.set(Some(v));\n@@ -1311,6 +1302,7 @@ impl Config {\n             config.dist_compression_formats = t.compression_formats;\n             set(&mut config.rust_dist_src, t.src_tarball);\n             set(&mut config.missing_tools, t.missing_tools);\n+            set(&mut config.dist_include_mingw_linker, t.include_mingw_linker)\n         }\n \n         if let Some(r) = build.rustfmt {\n@@ -1324,7 +1316,6 @@ impl Config {\n         // Now that we've reached the end of our configuration, infer the\n         // default values for all options that we haven't otherwise stored yet.\n \n-        config.llvm_skip_rebuild = llvm_skip_rebuild.unwrap_or(false);\n         config.llvm_assertions = llvm_assertions.unwrap_or(false);\n         config.llvm_tests = llvm_tests.unwrap_or(false);\n         config.llvm_plugins = llvm_plugins.unwrap_or(false);"}, {"sha": "5278f0c10b3d20a1ba8f104ed4be73948b748fb5", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -44,7 +44,6 @@ def v(*args):\n o(\"llvm-static-stdcpp\", \"llvm.static-libstdcpp\", \"statically link to libstdc++ for LLVM\")\n o(\"llvm-link-shared\", \"llvm.link-shared\", \"prefer shared linking to LLVM (llvm-config --link-shared)\")\n o(\"rpath\", \"rust.rpath\", \"build rpaths into rustc itself\")\n-o(\"llvm-version-check\", \"llvm.version-check\", \"check if the LLVM version is supported, build anyway\")\n o(\"codegen-tests\", \"rust.codegen-tests\", \"run the tests/codegen tests\")\n o(\"option-checking\", None, \"complain about unrecognized options in this configure script\")\n o(\"ninja\", \"llvm.ninja\", \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\")"}, {"sha": "eb2afa555f18312b3fd95245f3462abcf985fb20", "filename": "src/bootstrap/defaults/config.codegen.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fdefaults%2Fconfig.codegen.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fdefaults%2Fconfig.codegen.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.codegen.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -17,3 +17,5 @@ debug-logging = true\n incremental = true\n # Print backtrace on internal compiler errors during bootstrap\n backtrace-on-ice = true\n+# Make the compiler and standard library faster to build, at the expense of a ~20% runtime slowdown.\n+lto = \"off\""}, {"sha": "c9384004100b20ea77f09d60cf710d3a0891f080", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -324,7 +324,7 @@ impl Step for Mingw {\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n-        if !host.ends_with(\"pc-windows-gnu\") {\n+        if !host.ends_with(\"pc-windows-gnu\") || !builder.config.dist_include_mingw_linker {\n             return None;\n         }\n \n@@ -380,7 +380,7 @@ impl Step for Rustc {\n         // anything requiring us to distribute a license, but it's likely the\n         // install will *also* include the rust-mingw package, which also needs\n         // licenses, so to be safe we just include it here in all MinGW packages.\n-        if host.ends_with(\"pc-windows-gnu\") {\n+        if host.ends_with(\"pc-windows-gnu\") && builder.config.dist_include_mingw_linker {\n             make_win_dist(tarball.image_dir(), &tmpdir(builder), host, builder);\n             tarball.add_dir(builder.src.join(\"src/etc/third-party\"), \"share/doc\");\n         }"}, {"sha": "2b0b772a61817bd5504ca220e19dbca1b4158f99", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -67,8 +67,6 @@ pub struct Flags {\n     // true => deny, false => warn\n     pub deny_warnings: Option<bool>,\n \n-    pub llvm_skip_rebuild: Option<bool>,\n-\n     pub rust_profile_use: Option<String>,\n     pub rust_profile_generate: Option<String>,\n \n@@ -249,14 +247,6 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n         opts.optflag(\"\", \"json-output\", \"use message-format=json\");\n         opts.optopt(\"\", \"color\", \"whether to use color in cargo and rustc output\", \"STYLE\");\n-        opts.optopt(\n-            \"\",\n-            \"llvm-skip-rebuild\",\n-            \"whether rebuilding llvm should be skipped \\\n-             a VALUE of TRUE indicates that llvm will not be rebuilt \\\n-             VALUE overrides the skip-rebuild option in config.toml.\",\n-            \"VALUE\",\n-        );\n         opts.optopt(\n             \"\",\n             \"rust-profile-generate\",\n@@ -714,9 +704,6 @@ Arguments:\n                 .collect::<Vec<_>>(),\n             include_default_paths: matches.opt_present(\"include-default-paths\"),\n             deny_warnings: parse_deny_warnings(&matches),\n-            llvm_skip_rebuild: matches.opt_str(\"llvm-skip-rebuild\").map(|s| s.to_lowercase()).map(\n-                |s| s.parse::<bool>().expect(\"`llvm-skip-rebuild` should be either true or false\"),\n-            ),\n             color: matches\n                 .opt_get_default(\"color\", Color::Auto)\n                 .expect(\"`color` should be `always`, `never`, or `auto`\"),"}, {"sha": "b79969663ca2e1d5140129c55b2f9c5af7d7e567", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2,6 +2,7 @@\n \n use crate::builder::Builder;\n use crate::util::{output, program_out_of_date, t};\n+use build_helper::ci::CiEnv;\n use build_helper::git::get_git_modified_files;\n use ignore::WalkBuilder;\n use std::collections::VecDeque;\n@@ -144,8 +145,10 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n             let untracked_paths = untracked_paths_output\n                 .lines()\n                 .filter(|entry| entry.starts_with(\"??\"))\n-                .map(|entry| {\n-                    entry.split(' ').nth(1).expect(\"every git status entry should list a path\")\n+                .filter_map(|entry| {\n+                    let path =\n+                        entry.split(' ').nth(1).expect(\"every git status entry should list a path\");\n+                    path.ends_with(\".rs\").then_some(path)\n                 });\n             for untracked_path in untracked_paths {\n                 println!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n@@ -156,11 +159,20 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n                 // preventing the latter from being formatted.\n                 ignore_fmt.add(&format!(\"!/{}\", untracked_path)).expect(&untracked_path);\n             }\n-            if !check && paths.is_empty() {\n+            // Only check modified files locally to speed up runtime.\n+            // We still check all files in CI to avoid bugs in `get_modified_rs_files` letting regressions slip through;\n+            // we also care about CI time less since this is still very fast compared to building the compiler.\n+            if !CiEnv::is_ci() && paths.is_empty() {\n                 match get_modified_rs_files(build) {\n                     Ok(Some(files)) => {\n+                        if files.len() <= 10 {\n+                            for file in &files {\n+                                println!(\"formatting modified file {file}\");\n+                            }\n+                        } else {\n+                            println!(\"formatting {} modified files\", files.len());\n+                        }\n                         for file in files {\n-                            println!(\"formatting modified file {file}\");\n                             ignore_fmt.add(&format!(\"/{file}\")).expect(&file);\n                         }\n                     }"}, {"sha": "22ddf8722159575844e3d87d24ca537fe41f8c86", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -482,12 +482,7 @@ impl Build {\n \n             // Make sure we update these before gathering metadata so we don't get an error about missing\n             // Cargo.toml files.\n-            let rust_submodules = [\n-                \"src/tools/rust-installer\",\n-                \"src/tools/cargo\",\n-                \"library/backtrace\",\n-                \"library/stdarch\",\n-            ];\n+            let rust_submodules = [\"src/tools/cargo\", \"library/backtrace\", \"library/stdarch\"];\n             for s in rust_submodules {\n                 build.update_submodule(Path::new(s));\n             }"}, {"sha": "909e7d83a1599ef1e26c68ee1d54ea4929ae8c80", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -108,15 +108,6 @@ pub fn prebuilt_llvm_config(\n     let stamp = out_dir.join(\"llvm-finished-building\");\n     let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n \n-    if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n-        builder.info(\n-            \"Warning: \\\n-                Using a potentially stale build of LLVM; \\\n-                This may not behave well.\",\n-        );\n-        return Ok(res);\n-    }\n-\n     if stamp.is_done() {\n         if stamp.hash.is_none() {\n             builder.info(\n@@ -529,10 +520,6 @@ impl Step for Llvm {\n }\n \n fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n-    if !builder.config.llvm_version_check {\n-        return;\n-    }\n-\n     if builder.config.dry_run() {\n         return;\n     }"}, {"sha": "09f26862b4ab29520bfb43168a9f754b2f6b62b8", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -24,15 +24,15 @@ pub enum Profile {\n     None,\n }\n \n-/// A list of historical hashes of `src/etc/vscode_settings.json`.\n+/// A list of historical hashes of `src/etc/rust_analyzer_settings.json`.\n /// New entries should be appended whenever this is updated so we can detect\n /// outdated vs. user-modified settings files.\n static SETTINGS_HASHES: &[&str] = &[\n     \"ea67e259dedf60d4429b6c349a564ffcd1563cf41c920a856d1f5b16b4701ac8\",\n     \"56e7bf011c71c5d81e0bf42e84938111847a810eee69d906bba494ea90b51922\",\n     \"af1b5efe196aed007577899db9dae15d6dbc923d6fa42fa0934e68617ba9bbe0\",\n ];\n-static VSCODE_SETTINGS: &str = include_str!(\"../etc/vscode_settings.json\");\n+static RUST_ANALYZER_SETTINGS: &str = include_str!(\"../etc/rust_analyzer_settings.json\");\n \n impl Profile {\n     fn include_path(&self, src_path: &Path) -> PathBuf {\n@@ -489,7 +489,7 @@ undesirable, simply delete the `pre-push` file from .git/hooks.\"\n     Ok(())\n }\n \n-/// Sets up or displays `src/etc/vscode_settings.json`\n+/// Sets up or displays `src/etc/rust_analyzer_settings.json`\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n pub struct Vscode;\n \n@@ -580,10 +580,10 @@ fn create_vscode_settings_maybe(config: &Config) -> io::Result<()> {\n             }\n             _ => \"Created\",\n         };\n-        fs::write(&vscode_settings, &VSCODE_SETTINGS)?;\n+        fs::write(&vscode_settings, &RUST_ANALYZER_SETTINGS)?;\n         println!(\"{verb} `.vscode/settings.json`\");\n     } else {\n-        println!(\"\\n{VSCODE_SETTINGS}\");\n+        println!(\"\\n{RUST_ANALYZER_SETTINGS}\");\n     }\n     Ok(())\n }"}, {"sha": "0fe6e4a464463e121c5c527a96da7887843e7c2a", "filename": "src/bootstrap/setup/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fsetup%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Fsetup%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup%2Ftests.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,14 +1,14 @@\n-use super::{SETTINGS_HASHES, VSCODE_SETTINGS};\n+use super::{RUST_ANALYZER_SETTINGS, SETTINGS_HASHES};\n use sha2::Digest;\n \n #[test]\n fn check_matching_settings_hash() {\n     let mut hasher = sha2::Sha256::new();\n-    hasher.update(&VSCODE_SETTINGS);\n+    hasher.update(&RUST_ANALYZER_SETTINGS);\n     let hash = hex::encode(hasher.finalize().as_slice());\n     assert_eq!(\n         &hash,\n         SETTINGS_HASHES.last().unwrap(),\n-        \"Update `SETTINGS_HASHES` with the new hash of `src/etc/vscode_settings.json`\"\n+        \"Update `SETTINGS_HASHES` with the new hash of `src/etc/rust_analyzer_settings.json`\"\n     );\n }"}, {"sha": "f5d680df1133b3f238bab20227491f5307b53b34", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2695,3 +2695,58 @@ impl Step for LintDocs {\n         });\n     }\n }\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RustInstaller;\n+\n+impl Step for RustInstaller {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    /// Ensure the version placeholder replacement tool builds\n+    fn run(self, builder: &Builder<'_>) {\n+        builder.info(\"test rust-installer\");\n+\n+        let bootstrap_host = builder.config.build;\n+        let compiler = builder.compiler(0, bootstrap_host);\n+        let cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolBootstrap,\n+            bootstrap_host,\n+            \"test\",\n+            \"src/tools/rust-installer\",\n+            SourceType::InTree,\n+            &[],\n+        );\n+        try_run(builder, &mut cargo.into());\n+\n+        // We currently don't support running the test.sh script outside linux(?) environments.\n+        // Eventually this should likely migrate to #[test]s in rust-installer proper rather than a\n+        // set of scripts, which will likely allow dropping this if.\n+        if bootstrap_host != \"x86_64-unknown-linux-gnu\" {\n+            return;\n+        }\n+\n+        let mut cmd =\n+            std::process::Command::new(builder.src.join(\"src/tools/rust-installer/test.sh\"));\n+        let tmpdir = testdir(builder, compiler.host).join(\"rust-installer\");\n+        let _ = std::fs::remove_dir_all(&tmpdir);\n+        let _ = std::fs::create_dir_all(&tmpdir);\n+        cmd.current_dir(&tmpdir);\n+        cmd.env(\"CARGO_TARGET_DIR\", tmpdir.join(\"cargo-target\"));\n+        cmd.env(\"CARGO\", &builder.initial_cargo);\n+        cmd.env(\"RUSTC\", &builder.initial_rustc);\n+        cmd.env(\"TMP_DIR\", &tmpdir);\n+        try_run(builder, &mut cmd);\n+    }\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/rust-installer\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(Self);\n+    }\n+}"}, {"sha": "3939b4b7c41c15f0f75ecfca6854e7dbfe7c58b9", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-solaris-toolchain.sh", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-solaris-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-solaris-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-solaris-toolchain.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -32,24 +32,22 @@ cd solaris\n \n dpkg --add-architecture $APT_ARCH\n apt-get update\n-apt-get download $(apt-cache depends --recurse --no-replaces \\\n+apt-get install -y --download-only                           \\\n   libc:$APT_ARCH                                             \\\n-  liblgrp-dev:$APT_ARCH                                      \\\n   liblgrp:$APT_ARCH                                          \\\n   libm-dev:$APT_ARCH                                         \\\n   libpthread:$APT_ARCH                                       \\\n   libresolv:$APT_ARCH                                        \\\n   librt:$APT_ARCH                                            \\\n-  libsendfile-dev:$APT_ARCH                                  \\\n   libsendfile:$APT_ARCH                                      \\\n   libsocket:$APT_ARCH                                        \\\n   system-crt:$APT_ARCH                                       \\\n-  system-header:$APT_ARCH                                    \\\n-  | grep \"^\\w\")\n+  system-header:$APT_ARCH\n \n-for deb in *$APT_ARCH.deb; do\n+for deb in /var/cache/apt/archives/*$APT_ARCH.deb; do\n   dpkg -x $deb .\n done\n+apt-get clean\n \n # The -dev packages are not available from the apt repository we're using.\n # However, those packages are just symlinks from *.so to *.so.<version>."}, {"sha": "32d3440f1dc989f8bde6ad5a895a2c38f26c91da", "filename": "src/doc/rustc/src/platform-support/armeb-unknown-linux-gnueabi.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmeb-unknown-linux-gnueabi.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmeb-unknown-linux-gnueabi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmeb-unknown-linux-gnueabi.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -26,7 +26,6 @@ Therefore, you can build Rust with support for the target by adding it to the ta\n ```toml\n [llvm]\n download-ci-llvm = false\n-skip-rebuild = true\n optimize = true\n ninja = true\n targets = \"ARM;X86\""}, {"sha": "efe5f5642b8af5de2d58fc2731e4fa467dffb6f6", "filename": "src/doc/unstable-book/src/compiler-flags/cf-protection.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcf-protection.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcf-protection.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcf-protection.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,9 @@\n # `cf-protection`\n \n+The tracking issue for this feature is: [#93754](https://github.com/rust-lang/rust/issues/93754).\n+\n+------------------------\n+\n This option enables control-flow enforcement technology (CET) on x86; a more detailed description of\n CET is available [here]. Similar to `clang`, this flag takes one of the following values:\n "}, {"sha": "dd01bfaa7252d77022b423ce858ea1951147accf", "filename": "src/etc/rust_analyzer_settings.json", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fetc%2Frust_analyzer_settings.json", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Fetc%2Frust_analyzer_settings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust_analyzer_settings.json?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "previous_filename": "src/etc/vscode_settings.json"}, {"sha": "6ca6edfd3c9fed181e88b7fef03e8f3aeb66bf5c", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -8,7 +8,7 @@ path = \"lib.rs\"\n \n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }\n-askama = { version = \"0.11\", default-features = false, features = [\"config\"] }\n+askama = { version = \"0.12\", default-features = false, features = [\"config\"] }\n itertools = \"0.10.1\"\n minifier = \"0.2.2\"\n once_cell = \"1.10.0\""}, {"sha": "2732c4bc61ef698dfefe1c6ebadf3e32f99a7cf1", "filename": "src/librustdoc/askama.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Faskama.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Faskama.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Faskama.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,2 +1,3 @@\n [general]\n dirs = [\"html/templates\"]\n+whitespace = \"suppress\""}, {"sha": "29c3afe0d9560d06b363c5846566c5fbc34fd2f4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 66, "deletions": 42, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -2065,23 +2065,81 @@ fn clean_bare_fn_ty<'tcx>(\n     BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }\n }\n \n-/// This visitor is used to go through only the \"top level\" of a item and not enter any sub\n-/// item while looking for a given `Ident` which is stored into `item` if found.\n-struct OneLevelVisitor<'hir> {\n+/// Get DefId of of an item's user-visible parent.\n+///\n+/// \"User-visible\" should account for re-exporting and inlining, which is why this function isn't\n+/// just `tcx.parent(def_id)`. If the provided `path` has more than one path element, the `DefId`\n+/// of the second-to-last will be given.\n+///\n+/// ```text\n+/// use crate::foo::Bar;\n+///            ^^^ DefId of this item will be returned\n+/// ```\n+///\n+/// If the provided path has only one item, `tcx.parent(def_id)` will be returned instead.\n+fn get_path_parent_def_id(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    path: &hir::UsePath<'_>,\n+) -> Option<DefId> {\n+    if let [.., parent_segment, _] = &path.segments {\n+        match parent_segment.res {\n+            hir::def::Res::Def(_, parent_def_id) => Some(parent_def_id),\n+            _ if parent_segment.ident.name == kw::Crate => {\n+                // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n+                // circumvent it this way.\n+                Some(tcx.parent(def_id))\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        // If the path doesn't have a parent, then the parent is the current module.\n+        Some(tcx.parent(def_id))\n+    }\n+}\n+\n+/// This visitor is used to find an HIR Item based on its `use` path. This doesn't use the ordinary\n+/// name resolver because it does not walk all the way through a chain of re-exports.\n+pub(crate) struct OneLevelVisitor<'hir> {\n     map: rustc_middle::hir::map::Map<'hir>,\n-    item: Option<&'hir hir::Item<'hir>>,\n+    pub(crate) item: Option<&'hir hir::Item<'hir>>,\n     looking_for: Ident,\n     target_def_id: LocalDefId,\n }\n \n impl<'hir> OneLevelVisitor<'hir> {\n-    fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n+    pub(crate) fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n         Self { map, item: None, looking_for: Ident::empty(), target_def_id }\n     }\n \n-    fn reset(&mut self, looking_for: Ident) {\n-        self.looking_for = looking_for;\n+    pub(crate) fn find_target(\n+        &mut self,\n+        tcx: TyCtxt<'_>,\n+        def_id: DefId,\n+        path: &hir::UsePath<'_>,\n+    ) -> Option<&'hir hir::Item<'hir>> {\n+        let parent_def_id = get_path_parent_def_id(tcx, def_id, path)?;\n+        let parent = self.map.get_if_local(parent_def_id)?;\n+\n+        // We get the `Ident` we will be looking for into `item`.\n+        self.looking_for = path.segments[path.segments.len() - 1].ident;\n+        // We reset the `item`.\n         self.item = None;\n+\n+        match parent {\n+            hir::Node::Item(parent_item) => {\n+                hir::intravisit::walk_item(self, parent_item);\n+            }\n+            hir::Node::Crate(m) => {\n+                hir::intravisit::walk_mod(\n+                    self,\n+                    m,\n+                    tcx.local_def_id_to_hir_id(parent_def_id.as_local().unwrap()),\n+                );\n+            }\n+            _ => return None,\n+        }\n+        self.item\n     }\n }\n \n@@ -2129,41 +2187,7 @@ fn get_all_import_attributes<'hir>(\n             add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n         }\n \n-        let def_id = if let [.., parent_segment, _] = &path.segments {\n-            match parent_segment.res {\n-                hir::def::Res::Def(_, def_id) => def_id,\n-                _ if parent_segment.ident.name == kw::Crate => {\n-                    // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n-                    // circumvent it this way.\n-                    tcx.parent(item.owner_id.def_id.to_def_id())\n-                }\n-                _ => break,\n-            }\n-        } else {\n-            // If the path doesn't have a parent, then the parent is the current module.\n-            tcx.parent(item.owner_id.def_id.to_def_id())\n-        };\n-\n-        let Some(parent) = hir_map.get_if_local(def_id) else { break };\n-\n-        // We get the `Ident` we will be looking for into `item`.\n-        let looking_for = path.segments[path.segments.len() - 1].ident;\n-        visitor.reset(looking_for);\n-\n-        match parent {\n-            hir::Node::Item(parent_item) => {\n-                hir::intravisit::walk_item(&mut visitor, parent_item);\n-            }\n-            hir::Node::Crate(m) => {\n-                hir::intravisit::walk_mod(\n-                    &mut visitor,\n-                    m,\n-                    tcx.local_def_id_to_hir_id(def_id.as_local().unwrap()),\n-                );\n-            }\n-            _ => break,\n-        }\n-        if let Some(i) = visitor.item {\n+        if let Some(i) = visitor.find_target(tcx, item.owner_id.def_id.to_def_id(), path) {\n             item = i;\n         } else {\n             break;"}, {"sha": "ed1eb66b97c36f9235a18dc8b4877e01290c6193", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -600,9 +600,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         };\n         let all = shared.all.replace(AllTypes::new());\n         let mut sidebar = Buffer::html();\n-        if shared.cache.crate_version.is_some() {\n-            write!(sidebar, \"<h2 class=\\\"location\\\">Crate {}</h2>\", crate_name)\n-        };\n+        write!(sidebar, \"<h2 class=\\\"location\\\"><a href=\\\"#\\\">Crate {}</a></h2>\", crate_name);\n \n         let mut items = Buffer::html();\n         sidebar_module_like(&mut items, all.item_sections());\n@@ -649,11 +647,35 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                      </noscript>\\\n                      <link rel=\\\"stylesheet\\\" \\\n                          href=\\\"{static_root_path}{settings_css}\\\">\\\n-                     <script defer src=\\\"{static_root_path}{settings_js}\\\"></script>\",\n+                     <script defer src=\\\"{static_root_path}{settings_js}\\\"></script>\\\n+                     <link rel=\\\"preload\\\" href=\\\"{static_root_path}{theme_light_css}\\\" \\\n+                         as=\\\"style\\\">\\\n+                     <link rel=\\\"preload\\\" href=\\\"{static_root_path}{theme_dark_css}\\\" \\\n+                         as=\\\"style\\\">\\\n+                     <link rel=\\\"preload\\\" href=\\\"{static_root_path}{theme_ayu_css}\\\" \\\n+                         as=\\\"style\\\">\",\n                     static_root_path = page.get_static_root_path(),\n                     settings_css = static_files::STATIC_FILES.settings_css,\n                     settings_js = static_files::STATIC_FILES.settings_js,\n-                )\n+                    theme_light_css = static_files::STATIC_FILES.theme_light_css,\n+                    theme_dark_css = static_files::STATIC_FILES.theme_dark_css,\n+                    theme_ayu_css = static_files::STATIC_FILES.theme_ayu_css,\n+                );\n+                // Pre-load all theme CSS files, so that switching feels seamless.\n+                //\n+                // When loading settings.html as a popover, the equivalent HTML is\n+                // generated in main.js.\n+                for file in &shared.style_files {\n+                    if let Ok(theme) = file.basename() {\n+                        write!(\n+                            buf,\n+                            \"<link rel=\\\"preload\\\" href=\\\"{root_path}{theme}{suffix}.css\\\" \\\n+                                as=\\\"style\\\">\",\n+                            root_path = page.static_root_path.unwrap_or(\"\"),\n+                            suffix = page.resource_suffix,\n+                        );\n+                    }\n+                }\n             },\n             &shared.style_files,\n         );"}, {"sha": "eb9262f472b67bcc032d855bfd9533d9bf07270e", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -29,12 +29,12 @@ pub(crate) enum LinkFromSrc {\n \n /// This function will do at most two things:\n ///\n-/// 1. Generate a `span` correspondance map which links an item `span` to its definition `span`.\n+/// 1. Generate a `span` correspondence map which links an item `span` to its definition `span`.\n /// 2. Collect the source code files.\n ///\n-/// It returns the `krate`, the source code files and the `span` correspondance map.\n+/// It returns the `krate`, the source code files and the `span` correspondence map.\n ///\n-/// Note about the `span` correspondance map: the keys are actually `(lo, hi)` of `span`s. We don't\n+/// Note about the `span` correspondence map: the keys are actually `(lo, hi)` of `span`s. We don't\n /// need the `span` context later on, only their position, so instead of keep a whole `Span`, we\n /// only keep the `lo` and `hi`.\n pub(crate) fn collect_spans_and_sources("}, {"sha": "403b5004d6558a46f522bc442ad149701efc524c", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,20 +1,9 @@\n // Local js definitions:\n /* global addClass, getSettingValue, hasClass, searchState */\n-/* global onEach, onEachLazy, removeClass */\n+/* global onEach, onEachLazy, removeClass, getVar */\n \n \"use strict\";\n \n-// Get a value from the rustdoc-vars div, which is used to convey data from\n-// Rust to the JS. If there is no such element, return null.\n-function getVar(name) {\n-    const el = document.getElementById(\"rustdoc-vars\");\n-    if (el) {\n-        return el.attributes[\"data-\" + name].value;\n-    } else {\n-        return null;\n-    }\n-}\n-\n // Given a basename (e.g. \"storage\") and an extension (e.g. \".js\"), return a URL\n // for a resource under the root-path, with the resource-suffix.\n function resourcePath(basename, extension) {\n@@ -187,6 +176,15 @@ function loadCss(cssUrl) {\n     document.getElementsByTagName(\"head\")[0].appendChild(link);\n }\n \n+function preLoadCss(cssUrl) {\n+    // https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload\n+    const link = document.createElement(\"link\");\n+    link.href = cssUrl;\n+    link.rel = \"preload\";\n+    link.as = \"style\";\n+    document.getElementsByTagName(\"head\")[0].appendChild(link);\n+}\n+\n (function() {\n     const isHelpPage = window.location.pathname.endsWith(\"/help.html\");\n \n@@ -207,6 +205,23 @@ function loadCss(cssUrl) {\n         // hopefully be loaded when the JS will generate the settings content.\n         loadCss(getVar(\"static-root-path\") + getVar(\"settings-css\"));\n         loadScript(getVar(\"static-root-path\") + getVar(\"settings-js\"));\n+        preLoadCss(getVar(\"static-root-path\") + getVar(\"theme-light-css\"));\n+        preLoadCss(getVar(\"static-root-path\") + getVar(\"theme-dark-css\"));\n+        preLoadCss(getVar(\"static-root-path\") + getVar(\"theme-ayu-css\"));\n+        // Pre-load all theme CSS files, so that switching feels seamless.\n+        //\n+        // When loading settings.html as a standalone page, the equivalent HTML is\n+        // generated in context.rs.\n+        setTimeout(() => {\n+            const themes = getVar(\"themes\").split(\",\");\n+            for (const theme of themes) {\n+                // if there are no themes, do nothing\n+                // \"\".split(\",\") == [\"\"]\n+                if (theme !== \"\") {\n+                    preLoadCss(getVar(\"root-path\") + theme + \".css\");\n+                }\n+            }\n+        }, 0);\n     };\n \n     window.searchState = {"}, {"sha": "c3fed9a72d4e23fc470ea65857b9a7328b75118d", "filename": "src/librustdoc/html/static/js/storage.js", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -7,7 +7,6 @@\n \n const darkThemes = [\"dark\", \"ayu\"];\n window.currentTheme = document.getElementById(\"themeStyle\");\n-window.mainTheme = document.getElementById(\"mainThemeStyle\");\n \n // WARNING: RUSTDOC_MOBILE_BREAKPOINT MEDIA QUERY\n // If you update this line, then you also need to update the media query with the same\n@@ -44,8 +43,6 @@ function getSettingValue(settingName) {\n \n const localStoredTheme = getSettingValue(\"theme\");\n \n-const savedHref = [];\n-\n // eslint-disable-next-line no-unused-vars\n function hasClass(elem, className) {\n     return elem && elem.classList && elem.classList.contains(className);\n@@ -102,6 +99,7 @@ function onEach(arr, func, reversed) {\n  * @param {function(?)}                   func       - The callback\n  * @param {boolean}                       [reversed] - Whether to iterate in reverse\n  */\n+// eslint-disable-next-line no-unused-vars\n function onEachLazy(lazyArray, func, reversed) {\n     return onEach(\n         Array.prototype.slice.call(lazyArray),\n@@ -125,30 +123,37 @@ function getCurrentValue(name) {\n     }\n }\n \n-function switchTheme(styleElem, mainStyleElem, newThemeName, saveTheme) {\n+// Get a value from the rustdoc-vars div, which is used to convey data from\n+// Rust to the JS. If there is no such element, return null.\n+const getVar = (function getVar(name) {\n+    const el = document.getElementById(\"rustdoc-vars\");\n+    if (el) {\n+        return el.attributes[\"data-\" + name].value;\n+    } else {\n+        return null;\n+    }\n+});\n+\n+function switchTheme(newThemeName, saveTheme) {\n     // If this new value comes from a system setting or from the previously\n     // saved theme, no need to save it.\n     if (saveTheme) {\n         updateLocalStorage(\"theme\", newThemeName);\n     }\n \n-    if (savedHref.length === 0) {\n-        onEachLazy(document.getElementsByTagName(\"link\"), el => {\n-            savedHref.push(el.href);\n-        });\n+    let newHref;\n+\n+    if (newThemeName === \"light\" || newThemeName === \"dark\" || newThemeName === \"ayu\") {\n+        newHref = getVar(\"static-root-path\") + getVar(\"theme-\" + newThemeName + \"-css\");\n+    } else {\n+        newHref = getVar(\"root-path\") + newThemeName + getVar(\"resource-suffix\") + \".css\";\n     }\n-    const newHref = savedHref.find(url => {\n-        const m = url.match(/static\\.files\\/(.*)-[a-f0-9]{16}\\.css$/);\n-        if (m && m[1] === newThemeName) {\n-            return true;\n-        }\n-        const m2 = url.match(/\\/([^/]*)\\.css$/);\n-        if (m2 && m2[1].startsWith(newThemeName)) {\n-            return true;\n-        }\n-    });\n-    if (newHref && newHref !== styleElem.href) {\n-        styleElem.href = newHref;\n+\n+    if (!window.currentTheme) {\n+        document.write(`<link rel=\"stylesheet\" id=\"themeStyle\" href=\"${newHref}\">`);\n+        window.currentTheme = document.getElementById(\"themeStyle\");\n+    } else if (newHref !== window.currentTheme.href) {\n+        window.currentTheme.href = newHref;\n     }\n }\n \n@@ -164,7 +169,7 @@ const updateTheme = (function() {\n      */\n     function updateTheme() {\n         const use = (theme, saveTheme) => {\n-            switchTheme(window.currentTheme, window.mainTheme, theme, saveTheme);\n+            switchTheme(theme, saveTheme);\n         };\n \n         // maybe the user has disabled the setting in the meantime!"}, {"sha": "72c516c93eb7fa6a9886ffaedb2c4bc356560576", "filename": "src/librustdoc/html/templates/STYLE.md", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2FSTYLE.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2FSTYLE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2FSTYLE.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -10,28 +10,29 @@ similar to [Jinja2](jinjadoc) and [Django](djangodoc) templates, and also to [As\n \n We want our rendered output to have as little unnecessary whitespace as\n possible, so that pages load quickly. To achieve that we use Tera's\n-[whitespace control] features. At the end of most lines, we put an empty comment\n-tag with the whitespace control characters: `{#- -#}`. This causes all\n-whitespace between the end of the line and the beginning of the next, including\n-indentation, to be omitted on render. Sometimes we want to preserve a single\n-space. In those cases we put the space at the end of the line, followed by\n-`{# -#}`, which is a directive to remove following whitespace but not preceding.\n-We also use the whitespace control characters in most instances of tags with\n-control flow, for example `{%- if foo -%}`.\n+[whitespace control] features. By default, whitespace characters are removed\n+around jinja tags (`{% %}` for example). At the end of most lines, we put an\n+empty comment tag: `{# #}`. This causes all whitespace between the end of the\n+line and the beginning of the next, including indentation, to be omitted on\n+render. Sometimes we want to preserve a single space. In those cases we put the\n+space at the end of the line, followed by `{#+ #}`, which is a directive to\n+remove following whitespace but not preceding. We also use the whitespace\n+control characters in most instances of tags with control flow, for example\n+`{% if foo %}`.\n \n [whitespace control]: https://tera.netlify.app/docs/#whitespace-control\n \n We want our templates to be readable, so we use indentation and newlines\n-liberally. We indent by four spaces after opening an HTML tag _or_ a Tera\n+liberally. We indent by four spaces after opening an HTML tag _or_ a Jinja\n tag. In most cases an HTML tag should be followed by a newline, but if the\n tag has simple contents and fits with its close tag on a single line, the\n contents don't necessarily need a new line.\n \n-Tera templates support quite sophisticated control flow. To keep our templates\n+Askama templates support quite sophisticated control flow. To keep our templates\n simple and understandable, we use only a subset: `if` and `for`. In particular\n-we avoid [assignments in the template logic](assignments) and [Tera\n+we avoid [assignments in the template logic](assignments) and [Askama\n macros](macros). This also may make things easier if we switch to a different\n Jinja-style template system, like Askama, in the future.\n \n-[assignments]: https://tera.netlify.app/docs/#assignments\n-[macros]: https://tera.netlify.app/docs/#macros\n+[assignments]: https://djc.github.io/askama/template_syntax.html#assignments\n+[macros]: https://djc.github.io/askama/template_syntax.html#macros"}, {"sha": "532660e3d33c73bf200b6a4b4af0cd060ab07466", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 150, "deletions": 147, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,148 +1,151 @@\n-<!DOCTYPE html> {#- -#}\n-<html lang=\"en\"> {#- -#}\n-<head> {#- -#}\n-    <meta charset=\"utf-8\"> {#- -#}\n-    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> {#- -#}\n-    <meta name=\"generator\" content=\"rustdoc\"> {#- -#}\n-    <meta name=\"description\" content=\"{{page.description}}\"> {#- -#}\n-    <title>{{page.title}}</title> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_serif_4_regular}}\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.fira_sans_regular}}\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.fira_sans_medium}}\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_code_pro_regular}}\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_serif_4_bold}}\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_code_pro_semibold}}\"> {#- -#}\n-    <link rel=\"stylesheet\" {# -#}\n-          href=\"{{static_root_path|safe}}{{files.normalize_css}}\"> {#- -#}\n-    <link rel=\"stylesheet\" {# -#}\n-          href=\"{{static_root_path|safe}}{{files.rustdoc_css}}\" {# -#}\n-          id=\"mainThemeStyle\"> {#- -#}\n-    <link rel=\"stylesheet\" id=\"themeStyle\" href=\"{{static_root_path|safe}}{{files.theme_light_css}}\"> {#- -#}\n-    <link rel=\"stylesheet\" disabled href=\"{{static_root_path|safe}}{{files.theme_dark_css}}\"> {#- -#}\n-    <link rel=\"stylesheet\" disabled href=\"{{static_root_path|safe}}{{files.theme_ayu_css}}\"> {#- -#}\n-    {%- for theme in themes -%}\n-        <link rel=\"stylesheet\" disabled href=\"{{page.root_path|safe}}{{theme}}{{page.resource_suffix}}.css\"> {#- -#}\n-    {%- endfor -%}\n-    {%- if !layout.default_settings.is_empty() -%}\n-    <script id=\"default-settings\" {# -#}\n-      {% for (k, v) in layout.default_settings %}\n+<!DOCTYPE html> {# #}\n+<html lang=\"en\"> {# #}\n+<head> {# #}\n+    <meta charset=\"utf-8\"> {# #}\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> {# #}\n+    <meta name=\"generator\" content=\"rustdoc\"> {# #}\n+    <meta name=\"description\" content=\"{{page.description}}\"> {# #}\n+    <title>{{page.title}}</title> {# #}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_serif_4_regular}}\"> {# #}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.fira_sans_regular}}\"> {# #}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.fira_sans_medium}}\"> {# #}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_code_pro_regular}}\"> {# #}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_serif_4_bold}}\"> {# #}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_code_pro_semibold}}\"> {# #}\n+    <link rel=\"stylesheet\" {#+ #}\n+          href=\"{{static_root_path|safe}}{{files.normalize_css}}\"> {# #}\n+    <link rel=\"stylesheet\" {#+ #}\n+          href=\"{{static_root_path|safe}}{{files.rustdoc_css}}\" {#+ #}\n+          id=\"mainThemeStyle\"> {# #}\n+    {% if !layout.default_settings.is_empty() %}\n+    <script id=\"default-settings\" {#+ #}\n+      {%~ for (k, v) in layout.default_settings ~%}\n         data-{{k}}=\"{{v}}\"\n-      {%- endfor -%}\n-    ></script> {#- -#}\n-    {%- endif -%}\n-    <script src=\"{{static_root_path|safe}}{{files.storage_js}}\"></script> {#- -#}\n-    {%- if page.css_class.contains(\"crate\") -%}\n-    <script defer src=\"{{page.root_path|safe}}crates{{page.resource_suffix}}.js\"></script> {#- -#}\n-    {%- else if page.css_class == \"source\" -%}\n-    <script defer src=\"{{static_root_path|safe}}{{files.source_script_js}}\"></script> {#- -#}\n-    <script defer src=\"{{page.root_path|safe}}source-files{{page.resource_suffix}}.js\"></script> {#- -#}\n-    {%- else if !page.css_class.contains(\"mod\") -%}\n-    <script defer src=\"sidebar-items{{page.resource_suffix}}.js\"></script> {#- -#}\n-    {%- endif -%}\n-    <script defer src=\"{{static_root_path|safe}}{{files.main_js}}\"></script> {#- -#}\n-    {%- if layout.scrape_examples_extension -%}\n-    <script defer src=\"{{static_root_path|safe}}{{files.scrape_examples_js}}\"></script> {#- -#}\n-    {%- endif -%}\n-    <noscript> {#- -#}\n-        <link rel=\"stylesheet\" {# -#}\n-           href=\"{{static_root_path|safe}}{{files.noscript_css}}\"> {#- -#}\n-    </noscript> {#- -#}\n-    {%- if layout.css_file_extension.is_some() -%}\n-        <link rel=\"stylesheet\" {# -#}\n-            href=\"{{static_root_path|safe}}theme{{page.resource_suffix}}.css\"> {#- -#}\n-    {%- endif -%}\n-    {%- if !layout.favicon.is_empty() -%}\n-        <link rel=\"icon\" href=\"{{layout.favicon}}\"> {#- -#}\n-    {%- else -%}\n-        <link rel=\"alternate icon\" type=\"image/png\" {# -#}\n-            href=\"{{static_root_path|safe}}{{files.rust_favicon_png_16}}\"> {#- -#}\n-        <link rel=\"alternate icon\" type=\"image/png\" {# -#}\n-            href=\"{{static_root_path|safe}}{{files.rust_favicon_png_32}}\"> {#- -#}\n-        <link rel=\"icon\" type=\"image/svg+xml\" {# -#}\n-            href=\"{{static_root_path|safe}}{{files.rust_favicon_svg}}\"> {#- -#}\n-    {%- endif -%}\n-    {{- layout.external_html.in_header|safe -}}\n-</head> {#- -#}\n-<body class=\"rustdoc {{page.css_class}}\"> {#- -#}\n-    <!--[if lte IE 11]> {#- -#}\n-    <div class=\"warning\"> {#- -#}\n-        This old browser is unsupported and will most likely display funky things. {#- -#}\n-    </div> {#- -#}\n-    <![endif]--> {#- -#}\n-    {{- layout.external_html.before_content|safe -}}\n-    {%- if page.css_class != \"source\" -%}\n-    <nav class=\"mobile-topbar\"> {#- -#}\n-        <button class=\"sidebar-menu-toggle\">&#9776;</button> {#- -#}\n-        <a class=\"logo-container\" href=\"{{page.root_path|safe}}{{krate_with_trailing_slash|safe}}index.html\"> {#- -#}\n-        {%- if !layout.logo.is_empty() -%}\n-            <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n-        {%- else -%}\n-            <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {#- -#}\n-        {%- endif -%}\n-        </a> {#- -#}\n-        <h2></h2> {#- -#}\n-    </nav> {#- -#}\n-    {%- endif -%}\n-    <nav class=\"sidebar\"> {#- -#}\n-        {%- if page.css_class != \"source\" -%}\n-        <a class=\"logo-container\" href=\"{{page.root_path|safe}}{{krate_with_trailing_slash|safe}}index.html\"> {#- -#}\n-            {%- if !layout.logo.is_empty()  %}\n-                <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n-            {%- else -%}\n-                <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {#- -#}\n-            {%- endif -%}\n-        </a> {#- -#}\n-        {%- endif -%}\n-        {{- sidebar|safe -}}\n-    </nav> {#- -#}\n-    <main> {#- -#}\n-        {%- if page.css_class != \"source\" -%}<div class=\"width-limiter\">{%- endif -%}\n-            <nav class=\"sub\"> {#- -#}\n-                {%- if page.css_class == \"source\" -%}\n-                <a class=\"sub-logo-container\" href=\"{{page.root_path|safe}}{{krate_with_trailing_slash|safe}}index.html\"> {#- -#}\n-                    {%- if !layout.logo.is_empty()  %}\n-                        <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n-                    {%- else -%}\n-                        <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {#- -#}\n-                    {%- endif -%}\n-                </a> {#- -#}\n-                {%- endif -%}\n-                <form class=\"search-form\"> {#- -#}\n-                    <span></span> {#- This empty span is a hacky fix for Safari - See #93184 -#}\n-                    <input {# -#}\n-                        class=\"search-input\" {# -#}\n-                        name=\"search\" {# -#}\n-                        aria-label=\"Run search in the documentation\" {# -#}\n-                        autocomplete=\"off\" {# -#}\n-                        spellcheck=\"false\" {# -#}\n-                        placeholder=\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\" {# -#}\n-                        type=\"search\"> {#- -#}\n-                    <div id=\"help-button\" title=\"help\" tabindex=\"-1\"> {#- -#}\n-                        <a href=\"{{page.root_path|safe}}help.html\">?</a> {#- -#}\n-                    </div> {#- -#}\n-                    <div id=\"settings-menu\" tabindex=\"-1\"> {#- -#}\n-                        <a href=\"{{page.root_path|safe}}settings.html\" title=\"settings\"> {#- -#}\n-                            <img width=\"22\" height=\"22\" alt=\"Change settings\" {# -#}\n-                            src=\"{{static_root_path|safe}}{{files.wheel_svg}}\"> {#- -#}\n-                        </a> {#- -#}\n-                    </div> {#- -#}\n-                </form> {#- -#}\n-            </nav> {#- -#}\n-            <section id=\"main-content\" class=\"content\">{{- content|safe -}}</section> {#- -#}\n-        {%- if page.css_class != \"source\" -%}</div>{%- endif -%}\n-    </main> {#- -#}\n-    {{- layout.external_html.after_content|safe -}}\n-    <div id=\"rustdoc-vars\" {# -#}\n-         data-root-path=\"{{page.root_path|safe}}\" {# -#}\n-         data-static-root-path=\"{{static_root_path|safe}}\" {# -#}\n-         data-current-crate=\"{{layout.krate}}\" {# -#}\n-         data-themes=\"{{themes|join(\",\") }}\" {# -#}\n-         data-resource-suffix=\"{{page.resource_suffix}}\" {# -#}\n-         data-rustdoc-version=\"{{rustdoc_version}}\" {# -#}\n-         data-search-js=\"{{files.search_js}}\" {# -#}\n-         data-settings-js=\"{{files.settings_js}}\" {# -#}\n-         data-settings-css=\"{{files.settings_css}}\" {# -#}\n-    > {#- -#}\n-    </div> {#- -#}\n-</body> {#- -#}\n-</html> {#- -#}\n+      {% endfor %}\n+    ></script> {# #}\n+    {% endif %}\n+    <div id=\"rustdoc-vars\" {#+ #}\n+         data-root-path=\"{{page.root_path|safe}}\" {#+ #}\n+         data-static-root-path=\"{{static_root_path|safe}}\" {#+ #}\n+         data-current-crate=\"{{layout.krate}}\" {#+ #}\n+         data-themes=\"{{themes|join(\",\") }}\" {#+ #}\n+         data-resource-suffix=\"{{page.resource_suffix}}\" {#+ #}\n+         data-rustdoc-version=\"{{rustdoc_version}}\" {#+ #}\n+         data-search-js=\"{{files.search_js}}\" {#+ #}\n+         data-settings-js=\"{{files.settings_js}}\" {#+ #}\n+         data-settings-css=\"{{files.settings_css}}\" {#+ #}\n+         data-theme-light-css=\"{{files.theme_light_css}}\" {#+ #}\n+         data-theme-dark-css=\"{{files.theme_dark_css}}\" {#+ #}\n+         data-theme-ayu-css=\"{{files.theme_ayu_css}}\" {#+ #}\n+    > {# #}\n+    </div> {# #}\n+    <script src=\"{{static_root_path|safe}}{{files.storage_js}}\"></script> {# #}\n+    {% if page.css_class.contains(\"crate\") %}\n+    <script defer src=\"{{page.root_path|safe}}crates{{page.resource_suffix}}.js\"></script> {# #}\n+    {% else if page.css_class == \"source\" %}\n+    <script defer src=\"{{static_root_path|safe}}{{files.source_script_js}}\"></script> {# #}\n+    <script defer src=\"{{page.root_path|safe}}source-files{{page.resource_suffix}}.js\"></script> {# #}\n+    {% else if !page.css_class.contains(\"mod\") %}\n+    <script defer src=\"sidebar-items{{page.resource_suffix}}.js\"></script> {# #}\n+    {% endif %}\n+    <script defer src=\"{{static_root_path|safe}}{{files.main_js}}\"></script> {# #}\n+    {% if layout.scrape_examples_extension %}\n+    <script defer src=\"{{static_root_path|safe}}{{files.scrape_examples_js}}\"></script> {# #}\n+    {% endif %}\n+    <noscript> {# #}\n+        <link rel=\"stylesheet\" {#+ #}\n+           media=\"(prefers-color-scheme:light)\" {#+ #}\n+           href=\"{{static_root_path|safe}}{{files.theme_light_css}}\"> {# #}\n+        <link rel=\"stylesheet\" {#+ #}\n+           media=\"(prefers-color-scheme:dark)\" {#+ #}\n+           href=\"{{static_root_path|safe}}{{files.theme_dark_css}}\"> {# #}\n+        <link rel=\"stylesheet\" {#+ #}\n+           href=\"{{static_root_path|safe}}{{files.noscript_css}}\"> {# #}\n+    </noscript> {# #}\n+    {% if layout.css_file_extension.is_some() %}\n+        <link rel=\"stylesheet\" {#+ #}\n+            href=\"{{static_root_path|safe}}theme{{page.resource_suffix}}.css\"> {# #}\n+    {% endif %}\n+    {% if !layout.favicon.is_empty() %}\n+        <link rel=\"icon\" href=\"{{layout.favicon}}\"> {# #}\n+    {% else %}\n+        <link rel=\"alternate icon\" type=\"image/png\" {#+ #}\n+            href=\"{{static_root_path|safe}}{{files.rust_favicon_png_16}}\"> {# #}\n+        <link rel=\"alternate icon\" type=\"image/png\" {#+ #}\n+            href=\"{{static_root_path|safe}}{{files.rust_favicon_png_32}}\"> {# #}\n+        <link rel=\"icon\" type=\"image/svg+xml\" {#+ #}\n+            href=\"{{static_root_path|safe}}{{files.rust_favicon_svg}}\"> {# #}\n+    {% endif %}\n+    {{ layout.external_html.in_header|safe }}\n+</head> {# #}\n+<body class=\"rustdoc {{+page.css_class}}\"> {# #}\n+    <!--[if lte IE 11]> {# #}\n+    <div class=\"warning\"> {# #}\n+        This old browser is unsupported and will most likely display funky things. {# #}\n+    </div> {# #}\n+    <![endif]--> {# #}\n+    {{ layout.external_html.before_content|safe }}\n+    {% if page.css_class != \"source\" %}\n+    <nav class=\"mobile-topbar\"> {# #}\n+        <button class=\"sidebar-menu-toggle\">&#9776;</button> {# #}\n+        <a class=\"logo-container\" href=\"{{page.root_path|safe}}{{krate_with_trailing_slash|safe}}index.html\"> {# #}\n+        {% if !layout.logo.is_empty() %}\n+            <img src=\"{{layout.logo}}\" alt=\"logo\"> {# #}\n+        {% else %}\n+            <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {# #}\n+        {% endif %}\n+        </a> {# #}\n+        <h2></h2> {# #}\n+    </nav> {# #}\n+    {% endif %}\n+    <nav class=\"sidebar\"> {# #}\n+        {% if page.css_class != \"source\" %}\n+        <a class=\"logo-container\" href=\"{{page.root_path|safe}}{{krate_with_trailing_slash|safe}}index.html\"> {# #}\n+            {% if !layout.logo.is_empty() %}\n+                <img src=\"{{layout.logo}}\" alt=\"logo\"> {# #}\n+            {% else %}\n+                <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {# #}\n+            {% endif %}\n+        </a> {# #}\n+        {% endif %}\n+        {{ sidebar|safe }}\n+    </nav> {# #}\n+    <main> {# #}\n+        {% if page.css_class != \"source\" %}<div class=\"width-limiter\">{% endif %}\n+            <nav class=\"sub\"> {# #}\n+                {% if page.css_class == \"source\" %}\n+                <a class=\"sub-logo-container\" href=\"{{page.root_path|safe}}{{krate_with_trailing_slash|safe}}index.html\"> {# #}\n+                    {% if !layout.logo.is_empty() %}\n+                        <img src=\"{{layout.logo}}\" alt=\"logo\"> {# #}\n+                    {% else %}\n+                        <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {# #}\n+                    {% endif %}\n+                </a> {# #}\n+                {% endif %}\n+                <form class=\"search-form\"> {# #}\n+                    <span></span> {# This empty span is a hacky fix for Safari - See #93184 #}\n+                    <input {#+ #}\n+                        class=\"search-input\" {#+ #}\n+                        name=\"search\" {#+ #}\n+                        aria-label=\"Run search in the documentation\" {#+ #}\n+                        autocomplete=\"off\" {#+ #}\n+                        spellcheck=\"false\" {#+ #}\n+                        placeholder=\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\" {#+ #}\n+                        type=\"search\"> {# #}\n+                    <div id=\"help-button\" title=\"help\" tabindex=\"-1\"> {# #}\n+                        <a href=\"{{page.root_path|safe}}help.html\">?</a> {# #}\n+                    </div> {# #}\n+                    <div id=\"settings-menu\" tabindex=\"-1\"> {# #}\n+                        <a href=\"{{page.root_path|safe}}settings.html\" title=\"settings\"> {# #}\n+                            <img width=\"22\" height=\"22\" alt=\"Change settings\" {#+ #}\n+                            src=\"{{static_root_path|safe}}{{files.wheel_svg}}\"> {# #}\n+                        </a> {# #}\n+                    </div> {# #}\n+                </form> {# #}\n+            </nav> {# #}\n+            <section id=\"main-content\" class=\"content\">{{ content|safe }}</section> {# #}\n+        {% if page.css_class != \"source\" %}</div>{% endif %}\n+    </main> {# #}\n+    {{ layout.external_html.after_content|safe }}\n+</body> {# #}\n+</html> {# #}"}, {"sha": "edabac9a08231b055bfe95216d7c4a7b8f266d07", "filename": "src/librustdoc/html/templates/print_item.html", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,28 +1,28 @@\n-<div class=\"main-heading\"> {#- -#}\n-    <h1> {#- -#}\n-        {{-typ-}}\n-        {#- The breadcrumbs of the item path, like std::string -#}\n-        {%- for component in path_components -%}\n-        <a href=\"{{component.path|safe}}index.html\">{{component.name}}</a>::<wbr>\n-        {%- endfor -%}\n-        <a class=\"{{item_type}}\" href=\"#\">{{name}}</a> {#- -#}\n-        <button id=\"copy-path\" title=\"Copy item path to clipboard\"> {#- -#}\n-        <img src=\"{{static_root_path|safe}}{{clipboard_svg}}\" {# -#}\n-                width=\"19\" height=\"18\" {# -#}\n-                alt=\"Copy item path\"> {#- -#}\n-        </button> {#- -#}\n-    </h1> {#- -#}\n-    <span class=\"out-of-band\"> {#- -#}\n+<div class=\"main-heading\"> {# #}\n+    <h1> {# #}\n+        {{typ}}\n+        {# The breadcrumbs of the item path, like std::string #}\n+        {% for component in path_components %}\n+            <a href=\"{{component.path|safe}}index.html\">{{component.name}}</a>::<wbr>\n+        {% endfor %}\n+        <a class=\"{{item_type}}\" href=\"#\">{{name}}</a> {# #}\n+        <button id=\"copy-path\" title=\"Copy item path to clipboard\"> {# #}\n+        <img src=\"{{static_root_path|safe}}{{clipboard_svg}}\" {#+ #}\n+                width=\"19\" height=\"18\" {#+ #}\n+                alt=\"Copy item path\"> {# #}\n+        </button> {# #}\n+    </h1> {# #}\n+    <span class=\"out-of-band\"> {# #}\n         {% if !stability_since_raw.is_empty() %}\n-        {{- stability_since_raw|safe }} \u00b7 {# -#}\n+        {{ stability_since_raw|safe +}} \u00b7 {#+ #}\n         {% endif %}\n-        {%- match src_href -%}\n-            {%- when Some with (href) -%}\n-                <a class=\"srclink\" href=\"{{href|safe}}\">source</a> \u00b7 {# -#}\n-            {%- else -%}\n-        {%- endmatch -%}\n-        <button id=\"toggle-all-docs\" title=\"collapse all docs\"> {#- -#}\n-            [<span>&#x2212;</span>] {#- -#}\n-        </button> {#- -#}\n-    </span> {#- -#}\n-</div> {#- -#}\n+        {% match src_href %}\n+            {% when Some with (href) %}\n+                <a class=\"srclink\" href=\"{{href|safe}}\">source</a> \u00b7 {#+ #}\n+            {% else %}\n+        {% endmatch %}\n+        <button id=\"toggle-all-docs\" title=\"collapse all docs\"> {# #}\n+            [<span>&#x2212;</span>] {# #}\n+        </button> {# #}\n+    </span> {# #}\n+</div> {# #}"}, {"sha": "44e9b49f82afd5382ac3124fe09526894ed32b96", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -15,7 +15,7 @@ use rustc_span::Span;\n \n use std::mem;\n \n-use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt};\n+use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt, OneLevelVisitor};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -220,6 +220,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         renamed: Option<Symbol>,\n         glob: bool,\n         please_inline: bool,\n+        path: &hir::UsePath<'_>,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n \n@@ -263,6 +264,22 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n+        if !please_inline &&\n+            let mut visitor = OneLevelVisitor::new(self.cx.tcx.hir(), res_did) &&\n+            let Some(item) = visitor.find_target(self.cx.tcx, def_id.to_def_id(), path) &&\n+            let item_def_id = item.owner_id.def_id &&\n+            item_def_id != def_id &&\n+            self\n+                .cx\n+                .cache\n+                .effective_visibilities\n+                .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n+            !inherits_doc_hidden(self.cx.tcx, item_def_id)\n+        {\n+            // The imported item is public and not `doc(hidden)` so no need to inline it.\n+            return false;\n+        }\n+\n         let ret = match tcx.hir().get_by_def_id(res_did) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n@@ -361,6 +378,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             ident,\n                             is_glob,\n                             please_inline,\n+                            path,\n                         ) {\n                             continue;\n                         }"}, {"sha": "d63caa7ad70109b9c74acdaf19264f2d709ef44b", "filename": "src/rustdoc-json-types/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Frustdoc-json-types%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Frustdoc-json-types%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2FCargo.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -8,6 +8,7 @@ path = \"lib.rs\"\n \n [dependencies]\n serde = { version = \"1.0\", features = [\"derive\"] }\n+rustc-hash = \"1.1.0\"\n \n [dev-dependencies]\n serde_json = \"1.0\""}, {"sha": "4c210291b113b1bd2cde6c4a5d4d91882b190032", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -3,10 +3,9 @@\n //! These types are the public API exposed through the `--output-format json` flag. The [`Crate`]\n //! struct is the root of the JSON blob and all other items are contained within.\n \n-use std::collections::HashMap;\n-use std::path::PathBuf;\n-\n+use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n+use std::path::PathBuf;\n \n /// rustdoc format-version.\n pub const FORMAT_VERSION: u32 = 24;\n@@ -24,11 +23,11 @@ pub struct Crate {\n     pub includes_private: bool,\n     /// A collection of all items in the local crate as well as some external traits and their\n     /// items that are referenced locally.\n-    pub index: HashMap<Id, Item>,\n+    pub index: FxHashMap<Id, Item>,\n     /// Maps IDs to fully qualified paths and other info helpful for generating links.\n-    pub paths: HashMap<Id, ItemSummary>,\n+    pub paths: FxHashMap<Id, ItemSummary>,\n     /// Maps `crate_id` of items to a crate name and html_root_url if it exists.\n-    pub external_crates: HashMap<u32, ExternalCrate>,\n+    pub external_crates: FxHashMap<u32, ExternalCrate>,\n     /// A single version number to be used in the future when making backwards incompatible changes\n     /// to the JSON output.\n     pub format_version: u32,\n@@ -54,8 +53,8 @@ pub struct ItemSummary {\n     ///\n     /// Note that items can appear in multiple paths, and the one chosen is implementation\n     /// defined. Currently, this is the full path to where the item was defined. Eg\n-    /// [`String`] is currently `[\"alloc\", \"string\", \"String\"]` and [`HashMap`] is\n-    /// `[\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"]`, but this is subject to change.\n+    /// [`String`] is currently `[\"alloc\", \"string\", \"String\"]` and [`HashMap`][`std::collections::HashMap`]\n+    /// is `[\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"]`, but this is subject to change.\n     pub path: Vec<String>,\n     /// Whether this item is a struct, trait, macro, etc.\n     pub kind: ItemKind,\n@@ -80,7 +79,7 @@ pub struct Item {\n     /// Some(\"\") if there is some documentation but it is empty (EG `#[doc = \"\"]`).\n     pub docs: Option<String>,\n     /// This mapping resolves [intra-doc links](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md) from the docstring to their IDs\n-    pub links: HashMap<String, Id>,\n+    pub links: FxHashMap<String, Id>,\n     /// Stringified versions of the attributes on this item (e.g. `\"#[inline]\"`)\n     pub attrs: Vec<String>,\n     pub deprecation: Option<Deprecation>,"}, {"sha": "7d3033d2e59383fd76193daf9423c3d141972a7d", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1 +1 @@\n-Subproject commit 9880b408a3af50c08fab3dbf4aa2a972df71e951\n+Subproject commit 7d3033d2e59383fd76193daf9423c3d141972a7d"}, {"sha": "e105452e1c5f3a3bc0c95f3b05e01a1e07f13dcc", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -155,14 +155,10 @@ impl LateLintPass<'_> for WildcardImports {\n                     )\n                 };\n \n-                let imports_string = if used_imports.len() == 1 {\n-                    used_imports.iter().next().unwrap().to_string()\n+                let mut imports = used_imports.items().map(ToString::to_string).into_sorted_stable_ord(false);\n+                let imports_string = if imports.len() == 1 {\n+                    imports.pop().unwrap()\n                 } else {\n-                    let mut imports = used_imports\n-                        .iter()\n-                        .map(ToString::to_string)\n-                        .collect::<Vec<_>>();\n-                    imports.sort();\n                     if braced_glob {\n                         imports.join(\", \")\n                     } else {"}, {"sha": "24403e8b6f347059370529bf482e00283ef46b34", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -241,6 +241,7 @@ fn check_statement<'tcx>(\n         | StatementKind::StorageDead(_)\n         | StatementKind::Retag { .. }\n         | StatementKind::AscribeUserType(..)\n+        | StatementKind::PlaceMention(..)\n         | StatementKind::Coverage(..)\n         | StatementKind::ConstEvalCounter\n         | StatementKind::Nop => Ok(()),\n@@ -299,10 +300,6 @@ fn check_terminator<'tcx>(\n         | TerminatorKind::Unreachable => Ok(()),\n \n         TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, body),\n-        TerminatorKind::DropAndReplace { place, value, .. } => {\n-            check_place(tcx, *place, span, body)?;\n-            check_operand(tcx, value, span, body)\n-        },\n \n         TerminatorKind::SwitchInt { discr, targets: _ } => check_operand(tcx, discr, span, body),\n "}, {"sha": "7f623c7a9ec5499242a63ea705e06a09c1e77c71", "filename": "src/tools/clippy/tests/ui-toml/array_size_threshold/array_size_threshold.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "previous_filename": "tests/ui-toml/array_size_threshold/array_size_threshold.rs"}, {"sha": "ac017b20916dea2b7b6876b53bba0fe7bc1a5c83", "filename": "src/tools/clippy/tests/ui-toml/array_size_threshold/array_size_threshold.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.stderr?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "previous_filename": "tests/ui-toml/array_size_threshold/array_size_threshold.stderr"}, {"sha": "3f1fe9a12099fa9a060a50c00d1d8cf66cba1d7d", "filename": "src/tools/clippy/tests/ui-toml/array_size_threshold/clippy.toml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Farray_size_threshold%2Fclippy.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "previous_filename": "tests/ui-toml/array_size_threshold/clippy.toml"}, {"sha": "a127875b55d5ffc3eba277ee330e427bc4133a8e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -983,7 +983,12 @@ impl<'test> TestCx<'test> {\n                 &[\"-quiet\".as_ref(), \"-batch\".as_ref(), \"-nx\".as_ref(), &debugger_script];\n \n             let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n-            gdb.args(debugger_opts).env(\"PYTHONPATH\", rust_pp_module_abs_path);\n+            let pythonpath = if let Ok(pp) = std::env::var(\"PYTHONPATH\") {\n+                format!(\"{pp}:{rust_pp_module_abs_path}\")\n+            } else {\n+                rust_pp_module_abs_path\n+            };\n+            gdb.args(debugger_opts).env(\"PYTHONPATH\", pythonpath);\n \n             debugger_run_result =\n                 self.compose_and_run(gdb, self.config.run_lib_path.to_str().unwrap(), None, None);\n@@ -1149,13 +1154,18 @@ impl<'test> TestCx<'test> {\n     ) -> ProcRes {\n         // Prepare the lldb_batchmode which executes the debugger script\n         let lldb_script_path = rust_src_root.join(\"src/etc/lldb_batchmode.py\");\n+        let pythonpath = if let Ok(pp) = std::env::var(\"PYTHONPATH\") {\n+            format!(\"{pp}:{}\", self.config.lldb_python_dir.as_ref().unwrap())\n+        } else {\n+            self.config.lldb_python_dir.as_ref().unwrap().to_string()\n+        };\n         self.cmd2procres(\n             Command::new(&self.config.python)\n                 .arg(&lldb_script_path)\n                 .arg(test_executable)\n                 .arg(debugger_script)\n                 .env(\"PYTHONUNBUFFERED\", \"1\") // Help debugging #78665\n-                .env(\"PYTHONPATH\", self.config.lldb_python_dir.as_ref().unwrap()),\n+                .env(\"PYTHONPATH\", pythonpath),\n         )\n     }\n "}, {"sha": "1318a1f447620b17e9ab1901cb68a6291c376dac", "filename": "src/tools/jsondoclint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fjsondoclint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fjsondoclint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2FCargo.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -9,6 +9,7 @@ edition = \"2021\"\n anyhow = \"1.0.62\"\n clap = { version = \"4.0.15\", features = [\"derive\"] }\n fs-err = \"2.8.1\"\n+rustc-hash = \"1.1.0\"\n rustdoc-json-types = { version = \"0.1.0\", path = \"../../rustdoc-json-types\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0.85\""}, {"sha": "95a56a9dfac457a0ed78bfe162cfe670c20ee086", "filename": "src/tools/jsondoclint/src/validator/tests.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1,5 +1,4 @@\n-use std::collections::HashMap;\n-\n+use rustc_hash::FxHashMap;\n use rustdoc_json_types::{Crate, Item, ItemKind, ItemSummary, Visibility, FORMAT_VERSION};\n \n use crate::json_find::SelectorPart;\n@@ -27,7 +26,7 @@ fn errors_on_missing_links() {\n         root: id(\"0\"),\n         crate_version: None,\n         includes_private: false,\n-        index: HashMap::from_iter([(\n+        index: FxHashMap::from_iter([(\n             id(\"0\"),\n             Item {\n                 name: Some(\"root\".to_owned()),\n@@ -36,7 +35,7 @@ fn errors_on_missing_links() {\n                 span: None,\n                 visibility: Visibility::Public,\n                 docs: None,\n-                links: HashMap::from_iter([(\"Not Found\".to_owned(), id(\"1\"))]),\n+                links: FxHashMap::from_iter([(\"Not Found\".to_owned(), id(\"1\"))]),\n                 attrs: vec![],\n                 deprecation: None,\n                 inner: ItemEnum::Module(Module {\n@@ -46,8 +45,8 @@ fn errors_on_missing_links() {\n                 }),\n             },\n         )]),\n-        paths: HashMap::new(),\n-        external_crates: HashMap::new(),\n+        paths: FxHashMap::default(),\n+        external_crates: FxHashMap::default(),\n         format_version: rustdoc_json_types::FORMAT_VERSION,\n     };\n \n@@ -73,7 +72,7 @@ fn errors_on_local_in_paths_and_not_index() {\n         root: id(\"0:0:1572\"),\n         crate_version: None,\n         includes_private: false,\n-        index: HashMap::from_iter([\n+        index: FxHashMap::from_iter([\n             (\n                 id(\"0:0:1572\"),\n                 Item {\n@@ -83,7 +82,7 @@ fn errors_on_local_in_paths_and_not_index() {\n                     span: None,\n                     visibility: Visibility::Public,\n                     docs: None,\n-                    links: HashMap::from_iter([((\"prim@i32\".to_owned(), id(\"0:1:1571\")))]),\n+                    links: FxHashMap::from_iter([((\"prim@i32\".to_owned(), id(\"0:1:1571\")))]),\n                     attrs: Vec::new(),\n                     deprecation: None,\n                     inner: ItemEnum::Module(Module {\n@@ -102,22 +101,22 @@ fn errors_on_local_in_paths_and_not_index() {\n                     span: None,\n                     visibility: Visibility::Public,\n                     docs: None,\n-                    links: HashMap::default(),\n+                    links: FxHashMap::default(),\n                     attrs: Vec::new(),\n                     deprecation: None,\n                     inner: ItemEnum::Primitive(Primitive { name: \"i32\".to_owned(), impls: vec![] }),\n                 },\n             ),\n         ]),\n-        paths: HashMap::from_iter([(\n+        paths: FxHashMap::from_iter([(\n             id(\"0:1:1571\"),\n             ItemSummary {\n                 crate_id: 0,\n                 path: vec![\"microcore\".to_owned(), \"i32\".to_owned()],\n                 kind: ItemKind::Primitive,\n             },\n         )]),\n-        external_crates: HashMap::default(),\n+        external_crates: FxHashMap::default(),\n         format_version: rustdoc_json_types::FORMAT_VERSION,\n     };\n \n@@ -137,7 +136,7 @@ fn checks_local_crate_id_is_correct() {\n         root: id(\"root\"),\n         crate_version: None,\n         includes_private: false,\n-        index: HashMap::from_iter([(\n+        index: FxHashMap::from_iter([(\n             id(\"root\"),\n             Item {\n                 id: id(\"root\"),\n@@ -146,7 +145,7 @@ fn checks_local_crate_id_is_correct() {\n                 span: None,\n                 visibility: Visibility::Public,\n                 docs: None,\n-                links: HashMap::default(),\n+                links: FxHashMap::default(),\n                 attrs: Vec::new(),\n                 deprecation: None,\n                 inner: ItemEnum::Module(Module {\n@@ -156,8 +155,8 @@ fn checks_local_crate_id_is_correct() {\n                 }),\n             },\n         )]),\n-        paths: HashMap::default(),\n-        external_crates: HashMap::default(),\n+        paths: FxHashMap::default(),\n+        external_crates: FxHashMap::default(),\n         format_version: FORMAT_VERSION,\n     };\n     check(&krate, &[]);"}, {"sha": "301b322b285a4a6ac58aadd8fb8001b22db01f67", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -1 +1 @@\n-04e957578c77c95a0505f5818d0068b459f673e3\n+ff4b772f805ec1e1c1bd7e189ab8d5a4e3a6ef13"}, {"sha": "a2caeb972973db358fd360a1b4cc680e4d381b50", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -109,11 +109,14 @@ impl rustc_driver::Callbacks for MiriBeRustCompilerCalls {\n                 // an empty result if `tcx.sess.opts.output_types.should_codegen()` is false.\n                 local_providers.exported_symbols = |tcx, cnum| {\n                     assert_eq!(cnum, LOCAL_CRATE);\n+                    let reachable_set = tcx.with_stable_hashing_context(|hcx| {\n+                        tcx.reachable_set(()).to_sorted(&hcx, true)\n+                    });\n                     tcx.arena.alloc_from_iter(\n                         // This is based on:\n                         // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L62-L63\n                         // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L174\n-                        tcx.reachable_set(()).iter().filter_map(|&local_def_id| {\n+                        reachable_set.into_iter().filter_map(|&local_def_id| {\n                             // Do the same filtering that rustc does:\n                             // https://github.com/rust-lang/rust/blob/2962e7c0089d5c136f4e9600b7abccfbbde4973d/compiler/rustc_codegen_ssa/src/back/symbol_export.rs#L84-L102\n                             // Otherwise it may cause unexpected behaviours and ICEs"}, {"sha": "864e68de55dedbd7fb68815edcf250d247e72840", "filename": "src/tools/replace-version-placeholder/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Freplace-version-placeholder%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Freplace-version-placeholder%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Freplace-version-placeholder%2Fsrc%2Fmain.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     let version_str = version_str.trim();\n     walk::walk(\n         &root_path,\n-        &mut |path| {\n+        |path| {\n             walk::filter_dirs(path)\n                 // We exempt these as they require the placeholder\n                 // for their operation"}, {"sha": "9981e4d1ea6ac0992ff21be5514d4230dc77548b", "filename": "src/tools/rust-installer", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1 +0,0 @@\n-Subproject commit 9981e4d1ea6ac0992ff21be5514d4230dc77548b"}, {"sha": "fb017f484b15975123cd34d7e32e46289212037c", "filename": "src/tools/rust-installer/.gitignore", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2F.gitignore?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,5 @@\n+*~\n+tmp\n+target/\n+**/*.rs.bk\n+Cargo.lock"}, {"sha": "38b81a1baacd809ec96ae95b489d5ca94709b625", "filename": "src/tools/rust-installer/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2FCargo.toml?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"installer\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[[bin]]\n+doc = false\n+name = \"rust-installer\"\n+path = \"src/main.rs\"\n+\n+[dependencies]\n+anyhow = \"1.0.19\"\n+flate2 = \"1.0.1\"\n+rayon = \"1.0\"\n+tar = \"0.4.13\"\n+walkdir = \"2\"\n+xz2 = \"0.1.4\"\n+num_cpus = \"1\"\n+remove_dir_all = \"0.5\"\n+\n+[dependencies.clap]\n+features = [\"derive\"]\n+version = \"3.1\"\n+\n+[target.\"cfg(windows)\".dependencies]\n+lazy_static = \"1\"\n+winapi = { version = \"0.3\", features = [\"errhandlingapi\", \"handleapi\", \"ioapiset\", \"winerror\", \"winioctl\", \"winnt\"] }"}, {"sha": "99d8e5ca4cf1c13f7d24248475ee7bd24567c1a6", "filename": "src/tools/rust-installer/README.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2FREADME.md?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,71 @@\n+[![Build Status](https://travis-ci.org/rust-lang/rust-installer.svg?branch=master)](https://travis-ci.org/rust-lang/rust-installer)\n+\n+A generator for the install.sh script commonly used to install Rust in\n+Unix environments. It is used By Rust, Cargo, and is intended to be\n+used by a future combined installer of Rust + Cargo.\n+\n+# Usage\n+\n+```\n+./gen-installer.sh --product-name=Rust \\\n+                   --rel-manifest-dir=rustlib \\\n+                   --success-message=Rust-is-ready-to-roll. \\\n+                   --image-dir=./install-image \\\n+                   --work-dir=./temp \\\n+                   --output-dir=./dist \\\n+                   --non-installed-overlay=./overlay \\\n+                   --package-name=rustc-nightly-i686-apple-darwin \\\n+                   --component-name=rustc \\\n+                   --legacy-manifest-dirs=rustlib \\\n+                   --bulk-dirs=share/doc\n+```\n+\n+Or, to just generate the script.\n+\n+```\n+./gen-install-script.sh --product-name=Rust \\\n+                        --rel-manifest-dir=rustlib \\\n+                        --success-message=Rust-is-ready-to-roll. \\\n+                        --output-script=install.sh \\\n+                        --legacy-manifest-dirs=rustlib\n+```\n+\n+*Note: the dashes in `success-message` are converted to spaces. The\n+script's argument handling is broken with spaces.*\n+\n+To combine installers.\n+\n+```\n+./combine-installers.sh --product-name=Rust \\\n+                        --rel-manifest-dir=rustlib \\\n+                        --success-message=Rust-is-ready-to-roll. \\\n+                        --work-dir=./temp \\\n+                        --output-dir=./dist \\\n+                        --non-installed-overlay=./overlay \\\n+                        --package-name=rustc-nightly-i686-apple-darwin \\\n+                        --legacy-manifest-dirs=rustlib \\\n+                        --input-tarballs=./rustc.tar.gz,cargo.tar.gz\n+```\n+\n+# Future work\n+\n+* Make install.sh not have to be customized, pull it's data from a\n+  config file.\n+* Be more resiliant to installation failures, particularly if the disk\n+  is full.\n+* Pre-install and post-uninstall scripts.\n+* Allow components to depend on or contradict other components.\n+* Sanity check that expected destination dirs (bin, lib, share exist)?\n+* Add --docdir flag. Is there a standard name for this?\n+* Remove empty directories on uninstall.\n+* Detect mismatches in --prefix, --mandir, etc. in follow-on\n+  installs/uninstalls.\n+* Fix argument handling for spaces.\n+* Add --bindir.\n+\n+# License\n+\n+This software is distributed under the terms of both the MIT license\n+and/or the Apache License (Version 2.0), at your option.\n+\n+See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT) for details."}, {"sha": "bdbaab711394fde3dfaa3b8214935a0c9ba3181d", "filename": "src/tools/rust-installer/combine-installers.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fcombine-installers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fcombine-installers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fcombine-installers.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+$CARGO run --manifest-path=\"$src_dir/Cargo.toml\" -- combine \"$@\""}, {"sha": "b4559d147addd61de2ffe5d5a6b58541cfdfa3ce", "filename": "src/tools/rust-installer/gen-install-script.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fgen-install-script.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fgen-install-script.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fgen-install-script.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+cargo run --manifest-path=\"$src_dir/Cargo.toml\" -- script \"$@\""}, {"sha": "9a2c3016fee44be08e38efec6f5db091afff1098", "filename": "src/tools/rust-installer/gen-installer.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fgen-installer.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fgen-installer.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fgen-installer.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+$CARGO run --manifest-path=\"$src_dir/Cargo.toml\" -- generate \"$@\""}, {"sha": "7790541a4201ad7cccc599f0caa8ef852b938974", "filename": "src/tools/rust-installer/install-template.sh", "status": "added", "additions": 1005, "deletions": 0, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Finstall-template.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Finstall-template.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Finstall-template.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,1005 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# No undefined variables\n+set -u\n+\n+init_logging() {\n+    local _abs_libdir=\"$1\"\n+    local _logfile=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/install.log\"\n+    rm -f \"$_logfile\"\n+    need_ok \"failed to remove old installation log\"\n+    touch \"$_logfile\"\n+    need_ok \"failed to create installation log\"\n+    LOGFILE=\"$_logfile\"\n+}\n+\n+log_line() {\n+    local _line=\"$1\"\n+\n+    if [ -n \"${LOGFILE-}\" -a -e \"${LOGFILE-}\" ]; then\n+\techo \"$_line\" >> \"$LOGFILE\"\n+\t# Ignore errors, which may happen e.g. after the manifest dir is deleted\n+    fi\n+}\n+\n+msg() {\n+    local _line=\"install: ${1-}\"\n+    echo \"$_line\"\n+    log_line \"$_line\"\n+}\n+\n+verbose_msg() {\n+    if [ -n \"${CFG_VERBOSE-}\" ]; then\n+\tmsg \"${1-}\"\n+    else\n+\tlog_line \"install: ${1-}\"\n+    fi\n+}\n+\n+step_msg() {\n+    msg\n+    msg \"$1\"\n+    msg\n+}\n+\n+verbose_step_msg() {\n+    if [ -n \"${CFG_VERBOSE-}\" ]; then\n+\tmsg\n+\tmsg \"$1\"\n+\tmsg\n+    else\n+\tlog_line \"\"\n+\tlog_line \"install: $1\"\n+\tlog_line \"\"\n+    fi\n+}\n+\n+warn() {\n+    local _line=\"install: WARNING: $1\"\n+    echo \"$_line\" >&2\n+    log_line \"$_line\"\n+}\n+\n+err() {\n+    local _line=\"install: error: $1\"\n+    echo \"$_line\" >&2\n+    log_line \"$_line\"\n+    exit 1\n+}\n+\n+# A non-user error that is likely to result in a corrupted install\n+critical_err() {\n+    local _line=\"install: error: $1. see logs at '${LOGFILE-}'\"\n+    echo \"$_line\" >&2\n+    log_line \"$_line\"\n+    exit 1\n+}\n+\n+need_ok() {\n+    if [ $? -ne 0 ]\n+    then\n+        err \"$1\"\n+    fi\n+}\n+\n+critical_need_ok() {\n+    if [ $? -ne 0 ]\n+    then\n+        critical_err \"$1\"\n+    fi\n+}\n+\n+want_ok() {\n+    if [ $? -ne 0 ]; then\n+\twarn \"$1\"\n+    fi\n+}\n+\n+assert_nz() {\n+    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\n+}\n+\n+need_cmd() {\n+    if command -v $1 >/dev/null 2>&1\n+    then verbose_msg \"found $1\"\n+    else err \"need $1\"\n+    fi\n+}\n+\n+run() {\n+    local _line=\"\\$ $*\"\n+    \"$@\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+write_to_file() {\n+    local _msg=\"$1\"\n+    local _file=\"$2\"\n+    local _line=\"$ echo \\\"$_msg\\\" > \\\"$_file\\\"\"\n+    echo \"$_msg\" > \"$_file\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+append_to_file() {\n+    local _msg=\"$1\"\n+    local _file=\"$2\"\n+    local _line=\"$ echo \\\"$_msg\\\" >> \\\"$_file\\\"\"\n+    echo \"$_msg\" >> \"$_file\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+make_dir_recursive() {\n+    local _dir=\"$1\"\n+    local _line=\"$ umask 022 && mkdir -p \\\"$_dir\\\"\"\n+    umask 022 && mkdir -p \"$_dir\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+putvar() {\n+    local t\n+    local tlen\n+    eval t=\\$$1\n+    eval tlen=\\${#$1}\n+}\n+\n+valopt() {\n+    VAL_OPTIONS=\"$VAL_OPTIONS $1\"\n+\n+    local op=$1\n+    local default=$2\n+    shift\n+    shift\n+    local doc=\"$*\"\n+    if [ $HELP -eq 0 ]\n+    then\n+        local uop=$(echo $op | tr 'a-z-' 'A-Z_')\n+        local v=\"CFG_${uop}\"\n+        eval $v=\"$default\"\n+        for arg in $CFG_ARGS\n+        do\n+            if echo \"$arg\" | grep -q -- \"--$op=\"\n+            then\n+                local val=$(echo \"$arg\" | cut -f2 -d=)\n+                eval $v=$val\n+            fi\n+        done\n+        putvar $v\n+    else\n+        if [ -z \"$default\" ]\n+        then\n+            default=\"<none>\"\n+        fi\n+        op=\"${op}=[${default}]\"\n+        printf \"    --%-30s %s\\n\" \"$op\" \"$doc\"\n+    fi\n+}\n+\n+opt() {\n+    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n+\n+    local op=$1\n+    local default=$2\n+    shift\n+    shift\n+    local doc=\"$*\"\n+    local flag=\"\"\n+\n+    if [ $default -eq 0 ]\n+    then\n+        flag=\"enable\"\n+    else\n+        flag=\"disable\"\n+        doc=\"don't $doc\"\n+    fi\n+\n+    if [ $HELP -eq 0 ]\n+    then\n+        for arg in $CFG_ARGS\n+        do\n+            if [ \"$arg\" = \"--${flag}-${op}\" ]\n+            then\n+                op=$(echo $op | tr 'a-z-' 'A-Z_')\n+                flag=$(echo $flag | tr 'a-z' 'A-Z')\n+                local v=\"CFG_${flag}_${op}\"\n+                eval $v=1\n+                putvar $v\n+            fi\n+        done\n+    else\n+        if [ ! -z \"${META-}\" ]\n+        then\n+            op=\"$op=<$META>\"\n+        fi\n+        printf \"    --%-30s %s\\n\" \"$flag-$op\" \"$doc\"\n+     fi\n+}\n+\n+flag() {\n+    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n+\n+    local op=$1\n+    shift\n+    local doc=\"$*\"\n+\n+    if [ $HELP -eq 0 ]\n+    then\n+        for arg in $CFG_ARGS\n+        do\n+            if [ \"$arg\" = \"--${op}\" ]\n+            then\n+                op=$(echo $op | tr 'a-z-' 'A-Z_')\n+                local v=\"CFG_${op}\"\n+                eval $v=1\n+                putvar $v\n+            fi\n+        done\n+    else\n+        if [ ! -z \"${META-}\" ]\n+        then\n+            op=\"$op=<$META>\"\n+        fi\n+        printf \"    --%-30s %s\\n\" \"$op\" \"$doc\"\n+     fi\n+}\n+\n+validate_opt () {\n+    for arg in $CFG_ARGS\n+    do\n+        local is_arg_valid=0\n+        for option in $BOOL_OPTIONS\n+        do\n+            if test --disable-$option = $arg\n+            then\n+                is_arg_valid=1\n+            fi\n+            if test --enable-$option = $arg\n+            then\n+                is_arg_valid=1\n+            fi\n+            if test --$option = $arg\n+            then\n+                is_arg_valid=1\n+            fi\n+        done\n+        for option in $VAL_OPTIONS\n+        do\n+            if echo \"$arg\" | grep -q -- \"--$option=\"\n+            then\n+                is_arg_valid=1\n+            fi\n+        done\n+        if [ \"$arg\" = \"--help\" ]\n+        then\n+            echo\n+            echo \"No more help available for Configure options,\"\n+            echo \"check the Wiki or join our IRC channel\"\n+            break\n+        else\n+            if test $is_arg_valid -eq 0\n+            then\n+                err \"Option '$arg' is not recognized\"\n+            fi\n+        fi\n+    done\n+}\n+\n+absolutify() {\n+    local file_path=\"$1\"\n+    local file_path_dirname=\"$(dirname \"$file_path\")\"\n+    local file_path_basename=\"$(basename \"$file_path\")\"\n+    local file_abs_path=\"$(abs_path \"$file_path_dirname\")\"\n+    local file_path=\"$file_abs_path/$file_path_basename\"\n+    # This is the return value\n+    RETVAL=\"$file_path\"\n+}\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+uninstall_legacy() {\n+    local _abs_libdir=\"$1\"\n+\n+    local _uninstalled_something=false\n+\n+    # Replace commas in legacy manifest list with spaces\n+    _legacy_manifest_dirs=`echo \"$TEMPLATE_LEGACY_MANIFEST_DIRS\" | sed \"s/,/ /g\"`\n+\n+    # Uninstall from legacy manifests\n+    local _md\n+    for _md in $_legacy_manifest_dirs; do\n+\t# First, uninstall from the installation prefix.\n+\t# Errors are warnings - try to rm everything in the manifest even if some fail.\n+\tif [ -f \"$_abs_libdir/$_md/manifest\" ]\n+\tthen\n+\n+\t    # iterate through installed manifest and remove files\n+\t    local _p;\n+\t    while read _p; do\n+\t\t# the installed manifest contains absolute paths\n+\t\tmsg \"removing legacy file $_p\"\n+\t\tif [ -f \"$_p\" ]\n+\t\tthen\n+\t\t    run rm -f \"$_p\"\n+\t\t    want_ok \"failed to remove $_p\"\n+\t\telse\n+\t\t    warn \"supposedly installed file $_p does not exist!\"\n+\t\tfi\n+\t    done < \"$_abs_libdir/$_md/manifest\"\n+\n+\t    # If we fail to remove $md below, then the\n+\t    # installed manifest will still be full; the installed manifest\n+\t    # needs to be empty before install.\n+\t    msg \"removing legacy manifest $_abs_libdir/$_md/manifest\"\n+\t    run rm -f \"$_abs_libdir/$_md/manifest\"\n+\t    # For the above reason, this is a hard error\n+\t    need_ok \"failed to remove installed manifest\"\n+\n+\t    # Remove $template_rel_manifest_dir directory\n+\t    msg \"removing legacy manifest dir $_abs_libdir/$_md\"\n+\t    run rm -R \"$_abs_libdir/$_md\"\n+\t    want_ok \"failed to remove $_md\"\n+\n+\t    _uninstalled_something=true\n+\tfi\n+    done\n+\n+    RETVAL=\"$_uninstalled_something\"\n+}\n+\n+uninstall_components() {\n+    local _abs_libdir=\"$1\"\n+    local _dest_prefix=\"$2\"\n+    local _components=\"$3\"\n+\n+    # We're going to start by uninstalling existing components. This\n+    local _uninstalled_something=false\n+\n+    # First, try removing any 'legacy' manifests from before\n+    # rust-installer\n+    uninstall_legacy \"$_abs_libdir\"\n+    assert_nz \"$RETVAL\", \"RETVAL\"\n+    if [ \"$RETVAL\" = true ]; then\n+\t_uninstalled_something=true;\n+    fi\n+\n+    # Load the version of the installed installer\n+    local _installed_version=\n+    if [ -f \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/rust-installer-version\" ]; then\n+\t_installed_version=`cat \"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/rust-installer-version\"`\n+\n+\t# Sanity check\n+\tif [ ! -n \"$_installed_version\" ]; then critical_err \"rust installer version is empty\"; fi\n+    fi\n+\n+    # If there's something installed, then uninstall\n+    if [ -n \"$_installed_version\" ]; then\n+\t# Check the version of the installed installer\n+\tcase \"$_installed_version\" in\n+\n+\t    # If this is a previous version, then upgrade in place to the\n+\t    # current version before uninstalling.\n+\t    2 )\n+\t\t# The only change between version 2 -> 3 is that components are placed\n+\t\t# in subdirectories of the installer tarball. There are no changes\n+\t\t# to the installed data format, so nothing to do.\n+\t\t;;\n+\n+\t    # This is the current version. Nothing need to be done except uninstall.\n+\t    \"$TEMPLATE_RUST_INSTALLER_VERSION\")\n+\t\t;;\n+\n+\t    # If this is an unknown (future) version then bail.\n+\t    * )\n+\t\techo \"The copy of $TEMPLATE_PRODUCT_NAME at $_dest_prefix was installed using an\"\n+\t\techo \"unknown version ($_installed_version) of rust-installer.\"\n+\t\techo \"Uninstall it first with the installer used for the original installation\"\n+\t\techo \"before continuing.\"\n+\t\texit 1\n+\t\t;;\n+\tesac\n+\n+\tlocal _md=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+\tlocal _installed_components=\"$(cat \"$_md/components\")\"\n+\n+\t# Uninstall (our components only) before reinstalling\n+\tlocal _available_component\n+\tfor _available_component in $_components; do\n+\t    local _installed_component\n+\t    for _installed_component in $_installed_components; do\n+\t\tif [ \"$_available_component\" = \"$_installed_component\" ]; then\n+\t\t    msg \"uninstalling component '$_available_component'\"\n+\t\t    local _component_manifest=\"$_md/manifest-$_installed_component\"\n+\n+\t\t    # Sanity check: there should be a component manifest\n+\t\t    if [ ! -f \"$_component_manifest\" ]; then\n+\t\t\tcritical_err \"installed component '$_installed_component' has no manifest\"\n+\t\t    fi\n+\n+\t\t    # Iterate through installed component manifest and remove files\n+\t\t    local _directive\n+\t\t    while read _directive; do\n+\n+\t\t\tlocal _command=`echo $_directive | cut -f1 -d:`\n+\t\t\tlocal _file=`echo $_directive | cut -f2 -d:`\n+\n+\t\t\t# Sanity checks\n+\t\t\tif [ ! -n \"$_command\" ]; then critical_err \"malformed installation directive\"; fi\n+\t\t\tif [ ! -n \"$_file\" ]; then critical_err \"malformed installation directive\"; fi\n+\n+\t\t\tcase \"$_command\" in\n+\t\t\t    file)\n+\t\t\t\tverbose_msg \"removing file $_file\"\n+\t\t\t\tif [ -f \"$_file\" ]; then\n+\t\t\t\t    run rm -f \"$_file\"\n+\t\t\t\t    want_ok \"failed to remove $_file\"\n+\t\t\t\telse\n+\t\t\t\t    warn \"supposedly installed file $_file does not exist!\"\n+\t\t\t\tfi\n+\t\t\t\t;;\n+\n+\t\t\t    dir)\n+\t\t\t\tverbose_msg \"removing directory $_file\"\n+\t\t\t\trun rm -r \"$_file\"\n+\t\t\t\twant_ok \"unable to remove directory $_file\"\n+\t\t\t\t;;\n+\n+\t\t\t    *)\n+\t\t\t\tcritical_err \"unknown installation directive\"\n+\t\t\t\t;;\n+\t\t\tesac\n+\n+\t\t    done < \"$_component_manifest\"\n+\n+\t\t    # Remove the installed component manifest\n+\t\t    verbose_msg \"removing component manifest $_component_manifest\"\n+\t\t    run rm \"$_component_manifest\"\n+\t\t    # This is a hard error because the installation is unrecoverable\n+\t\t    critical_need_ok \"failed to remove installed manifest for component '$_installed_component'\"\n+\n+\t\t    # Update the installed component list\n+\t\t    local _modified_components=\"$(sed \"/^$_installed_component\\$/d\" \"$_md/components\")\"\n+\t\t    write_to_file \"$_modified_components\" \"$_md/components\"\n+\t\t    critical_need_ok \"failed to update installed component list\"\n+\t\tfi\n+\t    done\n+\tdone\n+\n+\t# If there are no remaining components delete the manifest directory,\n+\t# but only if we're doing an uninstall - if we're doing an install,\n+\t# then leave the manifest directory around to hang onto the logs,\n+\t# and any files not managed by the installer.\n+\tif [ -n \"${CFG_UNINSTALL-}\" ]; then\n+\t    local _remaining_components=\"$(cat \"$_md/components\")\"\n+\t    if [ ! -n \"$_remaining_components\" ]; then\n+\t\tverbose_msg \"removing manifest directory $_md\"\n+\t\trun rm -r \"$_md\"\n+\t\twant_ok \"failed to remove $_md\"\n+\n+\t\tmaybe_unconfigure_ld\n+\t    fi\n+\tfi\n+\n+\t_uninstalled_something=true\n+    fi\n+\n+    # There's no installed version. If we were asked to uninstall, then that's a problem.\n+    if [ -n \"${CFG_UNINSTALL-}\" -a \"$_uninstalled_something\" = false ]\n+    then\n+\terr \"unable to find installation manifest at $CFG_LIBDIR/$TEMPLATE_REL_MANIFEST_DIR\"\n+    fi\n+}\n+\n+install_components() {\n+    local _src_dir=\"$1\"\n+    local _abs_libdir=\"$2\"\n+    local _dest_prefix=\"$3\"\n+    local _components=\"$4\"\n+\n+    local _component\n+    for _component in $_components; do\n+\n+\tmsg \"installing component '$_component'\"\n+\n+\t# The file name of the manifest we're installing from\n+\tlocal _input_manifest=\"$_src_dir/$_component/manifest.in\"\n+\n+\t# Sanity check: do we have our input manifests?\n+\tif [ ! -f \"$_input_manifest\" ]; then\n+\t    critical_err \"manifest for $_component does not exist at $_input_manifest\"\n+\tfi\n+\n+\t# The installed manifest directory\n+\tlocal _md=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+\n+\t# The file name of the manifest we're going to create during install\n+\tlocal _installed_manifest=\"$_md/manifest-$_component\"\n+\n+\t# Create the installed manifest, which we will fill in with absolute file paths\n+\ttouch \"$_installed_manifest\"\n+\tcritical_need_ok \"failed to create installed manifest\"\n+\n+\t# Add this component to the installed component list\n+\tappend_to_file \"$_component\" \"$_md/components\"\n+\tcritical_need_ok \"failed to update components list for $_component\"\n+\n+\t# Now install, iterate through the new manifest and copy files\n+\tlocal _directive\n+\twhile read _directive; do\n+\n+\t    local _command=`echo $_directive | cut -f1 -d:`\n+\t    local _file=`echo $_directive | cut -f2 -d:`\n+\n+\t    # Sanity checks\n+\t    if [ ! -n \"$_command\" ]; then critical_err \"malformed installation directive\"; fi\n+\t    if [ ! -n \"$_file\" ]; then critical_err \"malformed installation directive\"; fi\n+\n+\t    # Decide the destination of the file\n+\t    local _file_install_path=\"$_dest_prefix/$_file\"\n+\n+\t    if echo \"$_file\" | grep \"^etc/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^etc\\///')\"\n+\t\t_file_install_path=\"$CFG_SYSCONFDIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^bin/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^bin\\///')\"\n+\t\t_file_install_path=\"$CFG_BINDIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^lib/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^lib\\///')\"\n+\t\t_file_install_path=\"$CFG_LIBDIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^share\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^share\\///')\"\n+\t\t_file_install_path=\"$CFG_DATADIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^share/man/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^share\\/man\\///')\"\n+\t\t_file_install_path=\"$CFG_MANDIR/$_f\"\n+\t    fi\n+\n+            # HACK: Try to support overriding --docdir.  Paths with the form\n+            # \"share/doc/$product/\" can be redirected to a single --docdir\n+            # path. If the following detects that --docdir has been specified\n+            # then it will replace everything preceeding the \"$product\" path\n+            # component. The problem here is that the combined rust installer\n+            # contains two \"products\": rust and cargo; so the contents of those\n+            # directories will both be dumped into the same directory; and the\n+            # contents of those directories are _not_ disjoint. Since this feature\n+            # is almost entirely to support 'make install' anyway I don't expect\n+            # this problem to be a big deal in practice.\n+            if [ \"$CFG_DOCDIR\" != \"<default>\" ]\n+            then\n+\t        if echo \"$_file\" | grep \"^share/doc/\" > /dev/null\n+\t        then\n+\t\t    local _f=\"$(echo \"$_file\" | sed 's/^share\\/doc\\/[^/]*\\///')\"\n+\t\t    _file_install_path=\"$CFG_DOCDIR/$_f\"\n+\t        fi\n+            fi\n+\n+\t    # Make sure there's a directory for it\n+\t    make_dir_recursive \"$(dirname \"$_file_install_path\")\"\n+\t    critical_need_ok \"directory creation failed\"\n+\n+\t    # Make the path absolute so we can uninstall it later without\n+\t    # starting from the installation cwd\n+\t    absolutify \"$_file_install_path\"\n+\t    _file_install_path=\"$RETVAL\"\n+\t    assert_nz \"$_file_install_path\" \"file_install_path\"\n+\n+\t    case \"$_command\" in\n+\t\tfile )\n+\n+\t\t    verbose_msg \"copying file $_file_install_path\"\n+\n+\t\t    maybe_backup_path \"$_file_install_path\"\n+\n+\t\t    if echo \"$_file\" | grep \"^bin/\" > /dev/null || test -x \"$_src_dir/$_component/$_file\"\n+\t\t    then\n+\t\t\trun cp \"$_src_dir/$_component/$_file\" \"$_file_install_path\"\n+\t\t\trun chmod 755 \"$_file_install_path\"\n+\t\t    else\n+\t\t\trun cp \"$_src_dir/$_component/$_file\" \"$_file_install_path\"\n+\t\t\trun chmod 644 \"$_file_install_path\"\n+\t\t    fi\n+\t\t    critical_need_ok \"file creation failed\"\n+\n+\t\t    # Update the manifest\n+\t\t    append_to_file \"file:$_file_install_path\" \"$_installed_manifest\"\n+\t\t    critical_need_ok \"failed to update manifest\"\n+\n+\t\t    ;;\n+\n+\t\tdir )\n+\n+\t\t    verbose_msg \"copying directory $_file_install_path\"\n+\n+\t\t    maybe_backup_path \"$_file_install_path\"\n+\n+\t\t    run cp -R \"$_src_dir/$_component/$_file\" \"$_file_install_path\"\n+\t\t    critical_need_ok \"failed to copy directory\"\n+\n+                    # Set permissions. 0755 for dirs, 644 for files\n+                    run chmod -R u+rwX,go+rX,go-w \"$_file_install_path\"\n+                    critical_need_ok \"failed to set permissions on directory\"\n+\n+\t\t    # Update the manifest\n+\t\t    append_to_file \"dir:$_file_install_path\" \"$_installed_manifest\"\n+\t\t    critical_need_ok \"failed to update manifest\"\n+\t\t    ;;\n+\n+\t\t*)\n+\t\t    critical_err \"unknown installation directive\"\n+\t\t    ;;\n+\t    esac\n+\tdone < \"$_input_manifest\"\n+\n+    done\n+}\n+\n+maybe_configure_ld() {\n+    local _abs_libdir=\"$1\"\n+\n+    local _ostype=\"$(uname -s)\"\n+    assert_nz \"$_ostype\"  \"ostype\"\n+\n+    if [ \"$_ostype\" = \"Linux\" -a ! -n \"${CFG_DISABLE_LDCONFIG-}\" ]; then\n+\n+\t# Fedora-based systems do not configure the dynamic linker to look\n+\t# /usr/local/lib, which is our default installation directory. To\n+\t# make things just work, try to put that directory in\n+\t# /etc/ld.so.conf.d/rust-installer-v1 so ldconfig picks it up.\n+\t# Issue #30.\n+\t#\n+\t# This will get rm'd when the last component is uninstalled in\n+\t# maybe_unconfigure_ld.\n+\tif [ \"$_abs_libdir\" = \"/usr/local/lib\" -a -d \"/etc/ld.so.conf.d\" ]; then\n+\t    echo \"$_abs_libdir\" > \"/etc/ld.so.conf.d/rust-installer-v1-$TEMPLATE_REL_MANIFEST_DIR.conf\"\n+\t    if [ $? -ne 0 ]; then\n+\t\t# This shouldn't happen if we've gotten this far\n+\t\t# installing to /usr/local\n+\t\twarn \"failed to update /etc/ld.so.conf.d. this is unexpected\"\n+\t    fi\n+\tfi\n+\n+\tverbose_msg \"running ldconfig\"\n+\tif [ -n \"${CFG_VERBOSE-}\" ]; then\n+\t    ldconfig\n+\telse\n+\t    ldconfig 2> /dev/null\n+\tfi\n+\tif [ $? -ne 0 ]\n+\tthen\n+            warn \"failed to run ldconfig. this may happen when not installing as root. run with --verbose to see the error\"\n+\tfi\n+    fi\n+}\n+\n+maybe_unconfigure_ld() {\n+    local _ostype=\"$(uname -s)\"\n+    assert_nz \"$_ostype\"  \"ostype\"\n+\n+    if [ \"$_ostype\" != \"Linux\" ]; then\n+\treturn 0\n+    fi\n+\n+    rm \"/etc/ld.so.conf.d/rust-installer-v1-$TEMPLATE_REL_MANIFEST_DIR.conf\" 2> /dev/null\n+    # Above may fail since that file may not have been created on install\n+}\n+\n+# Doing our own 'install'-like backup that is consistent across platforms\n+maybe_backup_path() {\n+    local _file_install_path=\"$1\"\n+\n+    if [ -e \"$_file_install_path\" ]; then\n+\tmsg \"backing up existing file at $_file_install_path\"\n+\trun mv -f \"$_file_install_path\" \"$_file_install_path.old\"\n+\tcritical_need_ok \"failed to back up $_file_install_path\"\n+    fi\n+}\n+\n+install_uninstaller() {\n+    local _src_dir=\"$1\"\n+    local _src_basename=\"$2\"\n+    local _abs_libdir=\"$3\"\n+\n+    local _uninstaller=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/uninstall.sh\"\n+    msg \"creating uninstall script at $_uninstaller\"\n+    run cp \"$_src_dir/$_src_basename\" \"$_uninstaller\"\n+    critical_need_ok \"unable to install uninstaller\"\n+}\n+\n+do_preflight_sanity_checks() {\n+    local _src_dir=\"$1\"\n+    local _dest_prefix=\"$2\"\n+\n+    # Sanity check: can we can write to the destination?\n+    verbose_msg \"verifying destination is writable\"\n+    make_dir_recursive \"$CFG_LIBDIR\"\n+    need_ok \"can't write to destination. consider \\`sudo\\`.\"\n+    touch \"$CFG_LIBDIR/rust-install-probe\" > /dev/null\n+    if [ $? -ne 0 ]\n+    then\n+\terr \"can't write to destination. consider \\`sudo\\`.\"\n+    fi\n+    rm \"$CFG_LIBDIR/rust-install-probe\"\n+    need_ok \"failed to remove install probe\"\n+\n+    # Sanity check: don't install to the directory containing the installer.\n+    # That would surely cause chaos.\n+    verbose_msg \"verifying destination is not the same as source\"\n+    local _prefix_dir=\"$(abs_path \"$dest_prefix\")\"\n+    if [ \"$_src_dir\" = \"$_dest_prefix\" -a \"${CFG_UNINSTALL-}\" != 1 ]; then\n+\terr \"cannot install to same directory as installer\"\n+    fi\n+}\n+\n+verbose_msg \"looking for install programs\"\n+verbose_msg\n+\n+need_cmd mkdir\n+need_cmd printf\n+need_cmd cut\n+need_cmd grep\n+need_cmd uname\n+need_cmd tr\n+need_cmd sed\n+need_cmd chmod\n+need_cmd env\n+need_cmd pwd\n+\n+CFG_ARGS=\"${@:-}\"\n+\n+HELP=0\n+if [ \"${1-}\" = \"--help\" ]\n+then\n+    HELP=1\n+    shift\n+    echo\n+    echo \"Usage: $0 [options]\"\n+    echo\n+    echo \"Options:\"\n+    echo\n+else\n+    verbose_step_msg \"processing arguments\"\n+fi\n+\n+OPTIONS=\"\"\n+BOOL_OPTIONS=\"\"\n+VAL_OPTIONS=\"\"\n+\n+flag uninstall \"only uninstall from the installation prefix\"\n+valopt destdir \"\" \"set installation root\"\n+valopt prefix \"/usr/local\" \"set installation prefix\"\n+\n+# Avoid prepending an extra / to the prefix path if there's no destdir\n+# NB: CFG vars here are undefined when passing --help\n+if [ -z \"${CFG_DESTDIR-}\" ]; then\n+    CFG_DESTDIR_PREFIX=\"${CFG_PREFIX-}\"\n+else\n+    CFG_DESTDIR_PREFIX=\"$CFG_DESTDIR/$CFG_PREFIX\"\n+fi\n+\n+# NB This isn't quite the same definition as in `configure`.\n+# just using 'lib' instead of configure's CFG_LIBDIR_RELATIVE\n+valopt without \"\" \"comma-separated list of components to not install\"\n+valopt components \"\" \"comma-separated list of components to install\"\n+flag list-components \"list available components\"\n+valopt sysconfdir \"$CFG_DESTDIR_PREFIX/etc\" \"install system configuration files\"\n+valopt bindir \"$CFG_DESTDIR_PREFIX/bin\" \"install binaries\"\n+valopt libdir \"$CFG_DESTDIR_PREFIX/lib\" \"install libraries\"\n+valopt datadir \"$CFG_DESTDIR_PREFIX/share\" \"install data\"\n+# NB We repeat datadir default value because we don't set CFG_DATADIR in --help\n+valopt mandir \"${CFG_DATADIR-\"$CFG_DESTDIR_PREFIX/share\"}/man\" \"install man pages in PATH\"\n+# NB See the docdir handling in install_components for an explanation of this\n+# weird <default> string\n+valopt docdir \"\\<default\\>\" \"install documentation in PATH\"\n+opt ldconfig 1 \"run ldconfig after installation (Linux only)\"\n+opt verify 1 \"obsolete\"\n+flag verbose \"run with verbose output\"\n+\n+if [ $HELP -eq 1 ]\n+then\n+    echo\n+    exit 0\n+fi\n+\n+verbose_step_msg \"validating arguments\"\n+validate_opt\n+\n+# Template configuration.\n+# These names surrounded by '%%` are replaced by sed when generating install.sh\n+# FIXME: Might want to consider loading this from a file and not generating install.sh\n+\n+# Rust or Cargo\n+TEMPLATE_PRODUCT_NAME=%%TEMPLATE_PRODUCT_NAME%%\n+# rustlib or cargo\n+TEMPLATE_REL_MANIFEST_DIR=%%TEMPLATE_REL_MANIFEST_DIR%%\n+# 'Rust is ready to roll.' or 'Cargo is cool to cruise.'\n+TEMPLATE_SUCCESS_MESSAGE=%%TEMPLATE_SUCCESS_MESSAGE%%\n+# Locations to look for directories containing legacy, pre-versioned manifests\n+TEMPLATE_LEGACY_MANIFEST_DIRS=%%TEMPLATE_LEGACY_MANIFEST_DIRS%%\n+# The installer version\n+TEMPLATE_RUST_INSTALLER_VERSION=%%TEMPLATE_RUST_INSTALLER_VERSION%%\n+\n+# OK, let's get installing ...\n+\n+# This is where we are installing from\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+\n+# The name of the script\n+src_basename=\"$(basename \"$0\")\"\n+\n+# If we've been run as 'uninstall.sh' (from the existing installation)\n+# then we're doing a full uninstall, as opposed to the --uninstall flag\n+# which just means 'uninstall my components'.\n+if [ \"$src_basename\" = \"uninstall.sh\" ]; then\n+    if [ \"${*:-}\" != \"\" ]; then\n+\t# Currently don't know what to do with arguments in this mode\n+\terr \"uninstall.sh does not take any arguments\"\n+    fi\n+    CFG_UNINSTALL=1\n+    CFG_DESTDIR_PREFIX=\"$(abs_path \"$src_dir/../../\")\"\n+    CFG_LIBDIR=\"$(abs_path \"$src_dir/../\")\"\n+fi\n+\n+# This is where we are installing to\n+dest_prefix=\"$CFG_DESTDIR_PREFIX\"\n+\n+# Open the components file to get the list of components to install.\n+# NB: During install this components file is read from the installer's\n+# source dir, during a full uninstall it's read from the manifest dir,\n+# and thus contains all installed components.\n+components=`cat \"$src_dir/components\"`\n+\n+# Sanity check: do we have components?\n+if [ ! -n \"$components\" ]; then\n+    err \"unable to find installation components\"\n+fi\n+\n+# If the user asked for a component list, do that and exit\n+if [ -n \"${CFG_LIST_COMPONENTS-}\" ]; then\n+    echo\n+    echo \"# Available components\"\n+    echo\n+    for component in $components; do\n+\techo \"* $component\"\n+    done\n+    echo\n+    exit 0\n+fi\n+\n+# If the user specified which components to install/uninstall,\n+# then validate that they exist and select them for installation\n+if [ -n \"$CFG_COMPONENTS\" ]; then\n+    # Remove commas\n+    user_components=\"$(echo \"$CFG_COMPONENTS\" | sed \"s/,/ /g\")\"\n+    for user_component in $user_components; do\n+\tfound=false\n+\tfor my_component in $components; do\n+\t    if [ \"$user_component\" = \"$my_component\" ]; then\n+\t\tfound=true\n+\t    fi\n+\tdone\n+\tif [ \"$found\" = false ]; then\n+\t    err \"unknown component: $user_component\"\n+\tfi\n+    done\n+    components=\"$user_components\"\n+fi\n+\n+if [ -n \"$CFG_WITHOUT\" ]; then\n+    without_components=\"$(echo \"$CFG_WITHOUT\" | sed \"s/,/ /g\")\"\n+\n+    # This does **not** check that all components in without_components are\n+    # actually present in the list of available components.\n+    #\n+    # Currently that's considered good as it makes it easier to be compatible\n+    # with multiple Rust versions (which may change the exact list of\n+    # components) when writing install scripts.\n+    new_comp=\"\"\n+    for component in $components; do\n+        found=false\n+        for my_component in $without_components; do\n+            if [ \"$component\" = \"$my_component\" ]; then\n+                found=true\n+            fi\n+        done\n+        if [ \"$found\" = false ]; then\n+            # If we didn't find the component in without, then add it to new list.\n+            new_comp=\"$new_comp $component\"\n+        fi\n+    done\n+    components=\"$new_comp\"\n+fi\n+\n+if [ -z \"$components\" ]; then\n+    if [ -z \"${CFG_UNINSTALL-}\" ]; then\n+\terr \"no components selected for installation\"\n+    else\n+\terr \"no components selected for uninstallation\"\n+    fi\n+fi\n+\n+do_preflight_sanity_checks \"$src_dir\" \"$dest_prefix\"\n+\n+# Using an absolute path to libdir in a few places so that the status\n+# messages are consistently using absolute paths.\n+absolutify \"$CFG_LIBDIR\"\n+abs_libdir=\"$RETVAL\"\n+assert_nz \"$abs_libdir\" \"abs_libdir\"\n+\n+# Create the manifest directory, where we will put our logs\n+make_dir_recursive \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+need_ok \"failed to create $TEMPLATE_REL_MANIFEST_DIR\"\n+\n+# Log messages and commands\n+init_logging \"$abs_libdir\"\n+\n+# First do any uninstallation, including from legacy manifests. This\n+# will also upgrade the metadata of existing installs.\n+uninstall_components \"$abs_libdir\" \"$dest_prefix\" \"$components\"\n+\n+# If we're only uninstalling then exit\n+if [ -n \"${CFG_UNINSTALL-}\" ]\n+then\n+    echo\n+    echo \"    $TEMPLATE_PRODUCT_NAME is uninstalled.\"\n+    echo\n+    exit 0\n+fi\n+\n+# Create the manifest directory again! uninstall_legacy\n+# may have deleted it.\n+make_dir_recursive \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+need_ok \"failed to create $TEMPLATE_REL_MANIFEST_DIR\"\n+\n+# Drop the version number into the manifest dir\n+write_to_file \"$TEMPLATE_RUST_INSTALLER_VERSION\" \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/rust-installer-version\"\n+critical_need_ok \"failed to write installer version\"\n+\n+# Install the uninstaller\n+install_uninstaller \"$src_dir\" \"$src_basename\" \"$abs_libdir\"\n+\n+# Install each component\n+install_components \"$src_dir\" \"$abs_libdir\" \"$dest_prefix\" \"$components\"\n+\n+# Make dynamic libraries available to the linker\n+maybe_configure_ld \"$abs_libdir\"\n+\n+echo\n+echo \"    $TEMPLATE_SUCCESS_MESSAGE\"\n+echo\n+\n+"}, {"sha": "6fc823666f14ba5199d576d813551f377505bbaa", "filename": "src/tools/rust-installer/make-tarballs.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/sh\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+$CARGO run --manifest-path=\"$src_dir/Cargo.toml\" -- tarball \"$@\""}, {"sha": "e440e5c842586965a7fb77deda2eca68612b1f53", "filename": "src/tools/rust-installer/rust-installer-version", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Frust-installer-version", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Frust-installer-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Frust-installer-version?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1 @@\n+3\n\\ No newline at end of file"}, {"sha": "2ec09d67e3e62acca475575e88962fc42870f5d5", "filename": "src/tools/rust-installer/src/combiner.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,161 @@\n+use super::Scripter;\n+use super::Tarballer;\n+use crate::{\n+    compression::{CompressionFormat, CompressionFormats},\n+    util::*,\n+};\n+use anyhow::{bail, Context, Result};\n+use std::io::{Read, Write};\n+use std::path::Path;\n+use tar::Archive;\n+\n+actor! {\n+    #[derive(Debug)]\n+    pub struct Combiner {\n+        /// The name of the product, for display.\n+        #[clap(value_name = \"NAME\")]\n+        product_name: String = \"Product\",\n+\n+        /// The name of the package  tarball.\n+        #[clap(value_name = \"NAME\")]\n+        package_name: String = \"package\",\n+\n+        /// The directory under lib/ where the manifest lives.\n+        #[clap(value_name = \"DIR\")]\n+        rel_manifest_dir: String = \"packagelib\",\n+\n+        /// The string to print after successful installation.\n+        #[clap(value_name = \"MESSAGE\")]\n+        success_message: String = \"Installed.\",\n+\n+        /// Places to look for legacy manifests to uninstall.\n+        #[clap(value_name = \"DIRS\")]\n+        legacy_manifest_dirs: String = \"\",\n+\n+        /// Installers to combine.\n+        #[clap(value_name = \"FILE,FILE\")]\n+        input_tarballs: String = \"\",\n+\n+        /// Directory containing files that should not be installed.\n+        #[clap(value_name = \"DIR\")]\n+        non_installed_overlay: String = \"\",\n+\n+        /// The directory to do temporary work.\n+        #[clap(value_name = \"DIR\")]\n+        work_dir: String = \"./workdir\",\n+\n+        /// The location to put the final image and tarball.\n+        #[clap(value_name = \"DIR\")]\n+        output_dir: String = \"./dist\",\n+\n+        /// The formats used to compress the tarball\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_formats: CompressionFormats,\n+    }\n+}\n+\n+impl Combiner {\n+    /// Combines the installer tarballs.\n+    pub fn run(self) -> Result<()> {\n+        create_dir_all(&self.work_dir)?;\n+\n+        let package_dir = Path::new(&self.work_dir).join(&self.package_name);\n+        if package_dir.exists() {\n+            remove_dir_all(&package_dir)?;\n+        }\n+        create_dir_all(&package_dir)?;\n+\n+        // Merge each installer into the work directory of the new installer.\n+        let components = create_new_file(package_dir.join(\"components\"))?;\n+        for input_tarball in self\n+            .input_tarballs\n+            .split(',')\n+            .map(str::trim)\n+            .filter(|s| !s.is_empty())\n+        {\n+            // Extract the input tarballs\n+            let compression =\n+                CompressionFormat::detect_from_path(input_tarball).ok_or_else(|| {\n+                    anyhow::anyhow!(\"couldn't figure out the format of {}\", input_tarball)\n+                })?;\n+            Archive::new(compression.decode(input_tarball)?)\n+                .unpack(&self.work_dir)\n+                .with_context(|| {\n+                    format!(\n+                        \"unable to extract '{}' into '{}'\",\n+                        &input_tarball, self.work_dir\n+                    )\n+                })?;\n+\n+            let pkg_name =\n+                input_tarball.trim_end_matches(&format!(\".tar.{}\", compression.extension()));\n+            let pkg_name = Path::new(pkg_name).file_name().unwrap();\n+            let pkg_dir = Path::new(&self.work_dir).join(&pkg_name);\n+\n+            // Verify the version number.\n+            let mut version = String::new();\n+            open_file(pkg_dir.join(\"rust-installer-version\"))\n+                .and_then(|mut file| Ok(file.read_to_string(&mut version)?))\n+                .with_context(|| format!(\"failed to read version in '{}'\", input_tarball))?;\n+            if version.trim().parse() != Ok(crate::RUST_INSTALLER_VERSION) {\n+                bail!(\"incorrect installer version in {}\", input_tarball);\n+            }\n+\n+            // Copy components to the new combined installer.\n+            let mut pkg_components = String::new();\n+            open_file(pkg_dir.join(\"components\"))\n+                .and_then(|mut file| Ok(file.read_to_string(&mut pkg_components)?))\n+                .with_context(|| format!(\"failed to read components in '{}'\", input_tarball))?;\n+            for component in pkg_components.split_whitespace() {\n+                // All we need to do is copy the component directory. We could\n+                // move it, but rustbuild wants to reuse the unpacked package\n+                // dir for OS-specific installers on macOS and Windows.\n+                let component_dir = package_dir.join(&component);\n+                create_dir(&component_dir)?;\n+                copy_recursive(&pkg_dir.join(&component), &component_dir)?;\n+\n+                // Merge the component name.\n+                writeln!(&components, \"{}\", component).context(\"failed to write new components\")?;\n+            }\n+        }\n+        drop(components);\n+\n+        // Write the installer version.\n+        let version = package_dir.join(\"rust-installer-version\");\n+        writeln!(\n+            create_new_file(version)?,\n+            \"{}\",\n+            crate::RUST_INSTALLER_VERSION\n+        )\n+        .context(\"failed to write new installer version\")?;\n+\n+        // Copy the overlay.\n+        if !self.non_installed_overlay.is_empty() {\n+            copy_recursive(self.non_installed_overlay.as_ref(), &package_dir)?;\n+        }\n+\n+        // Generate the install script.\n+        let output_script = package_dir.join(\"install.sh\");\n+        let mut scripter = Scripter::default();\n+        scripter\n+            .product_name(self.product_name)\n+            .rel_manifest_dir(self.rel_manifest_dir)\n+            .success_message(self.success_message)\n+            .legacy_manifest_dirs(self.legacy_manifest_dirs)\n+            .output_script(path_to_str(&output_script)?.into());\n+        scripter.run()?;\n+\n+        // Make the tarballs.\n+        create_dir_all(&self.output_dir)?;\n+        let output = Path::new(&self.output_dir).join(&self.package_name);\n+        let mut tarballer = Tarballer::default();\n+        tarballer\n+            .work_dir(self.work_dir)\n+            .input(self.package_name)\n+            .output(path_to_str(&output)?.into())\n+            .compression_formats(self.compression_formats.clone());\n+        tarballer.run()?;\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "013e05fda581905b1a40cd38d17ad9656443ca3e", "filename": "src/tools/rust-installer/src/compression.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1f7b0840885fac83ff3f36053cb04833c1af5a/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs?ref=0f1f7b0840885fac83ff3f36053cb04833c1af5a", "patch": "@@ -0,0 +1,214 @@\n+use anyhow::{Context, Error};\n+use flate2::{read::GzDecoder, write::GzEncoder};\n+use rayon::prelude::*;\n+use std::{convert::TryFrom, fmt, io::Read, io::Write, path::Path, str::FromStr};\n+use xz2::{read::XzDecoder, write::XzEncoder};\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum CompressionFormat {\n+    Gz,\n+    Xz,\n+}\n+\n+impl CompressionFormat {\n+    pub(crate) fn detect_from_path(path: impl AsRef<Path>) -> Option<Self> {\n+        match path.as_ref().extension().and_then(|e| e.to_str()) {\n+            Some(\"gz\") => Some(CompressionFormat::Gz),\n+            Some(\"xz\") => Some(CompressionFormat::Xz),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(crate) fn extension(&self) -> &'static str {\n+        match self {\n+            CompressionFormat::Gz => \"gz\",\n+            CompressionFormat::Xz => \"xz\",\n+        }\n+    }\n+\n+    pub(crate) fn encode(&self, path: impl AsRef<Path>) -> Result<Box<dyn Encoder>, Error> {\n+        let mut os = path.as_ref().as_os_str().to_os_string();\n+        os.push(format!(\".{}\", self.extension()));\n+        let path = Path::new(&os);\n+\n+        if path.exists() {\n+            crate::util::remove_file(path)?;\n+        }\n+        let file = crate::util::create_new_file(path)?;\n+\n+        Ok(match self {\n+            CompressionFormat::Gz => Box::new(GzEncoder::new(file, flate2::Compression::best())),\n+            CompressionFormat::Xz => {\n+                let mut filters = xz2::stream::Filters::new();\n+                // the preset is overridden by the other options so it doesn't matter\n+                let mut lzma_ops = xz2::stream::LzmaOptions::new_preset(9).unwrap();\n+                // This sets the overall dictionary size, which is also how much memory (baseline)\n+                // is needed for decompression.\n+                lzma_ops.dict_size(64 * 1024 * 1024);\n+                // Use the best match finder for compression ratio.\n+                lzma_ops.match_finder(xz2::stream::MatchFinder::BinaryTree4);\n+                lzma_ops.mode(xz2::stream::Mode::Normal);\n+                // Set nice len to the maximum for best compression ratio\n+                lzma_ops.nice_len(273);\n+                // Set depth to a reasonable value, 0 means auto, 1000 is somwhat high but gives\n+                // good results.\n+                lzma_ops.depth(1000);\n+                // 2 is the default and does well for most files\n+                lzma_ops.position_bits(2);\n+                // 0 is the default and does well for most files\n+                lzma_ops.literal_position_bits(0);\n+                // 3 is the default and does well for most files\n+                lzma_ops.literal_context_bits(3);\n+\n+                filters.lzma2(&lzma_ops);\n+\n+                let mut builder = xz2::stream::MtStreamBuilder::new();\n+                builder.filters(filters);\n+\n+                // On 32-bit platforms limit ourselves to 3 threads, otherwise we exceed memory\n+                // usage this process can take. In the future we'll likely only do super-fast\n+                // compression in CI and move this heavyweight processing to promote-release (which\n+                // is always 64-bit and can run on big-memory machines) but for now this lets us\n+                // move forward.\n+                if std::mem::size_of::<usize>() == 4 {\n+                    builder.threads(3);\n+                } else {\n+                    builder.threads(6);\n+                }\n+\n+                let compressor = XzEncoder::new_stream(\n+                    std::io::BufWriter::new(file),\n+                    builder.encoder().unwrap(),\n+                );\n+                Box::new(compressor)\n+            }\n+        })\n+    }\n+\n+    pub(crate) fn decode(&self, path: impl AsRef<Path>) -> Result<Box<dyn Read>, Error> {\n+        let file = crate::util::open_file(path.as_ref())?;\n+        Ok(match self {\n+            CompressionFormat::Gz => Box::new(GzDecoder::new(file)),\n+            CompressionFormat::Xz => Box::new(XzDecoder::new(file)),\n+        })\n+    }\n+}\n+\n+/// This struct wraps Vec<CompressionFormat> in order to parse the value from the command line.\n+#[derive(Debug, Clone)]\n+pub struct CompressionFormats(Vec<CompressionFormat>);\n+\n+impl TryFrom<&'_ str> for CompressionFormats {\n+    type Error = Error;\n+\n+    fn try_from(value: &str) -> Result<Self, Self::Error> {\n+        let mut parsed = Vec::new();\n+        for format in value.split(',') {\n+            match format.trim() {\n+                \"gz\" => parsed.push(CompressionFormat::Gz),\n+                \"xz\" => parsed.push(CompressionFormat::Xz),\n+                other => anyhow::bail!(\"unknown compression format: {}\", other),\n+            }\n+        }\n+        Ok(CompressionFormats(parsed))\n+    }\n+}\n+\n+impl FromStr for CompressionFormats {\n+    type Err = Error;\n+\n+    fn from_str(value: &str) -> Result<Self, Self::Err> {\n+        Self::try_from(value)\n+    }\n+}\n+\n+impl fmt::Display for CompressionFormats {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        for (i, format) in self.iter().enumerate() {\n+            if i != 0 {\n+                write!(f, \",\")?;\n+            }\n+            fmt::Display::fmt(\n+                match format {\n+                    CompressionFormat::Xz => \"xz\",\n+                    CompressionFormat::Gz => \"gz\",\n+                },\n+                f,\n+            )?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Default for CompressionFormats {\n+    fn default() -> Self {\n+        Self(vec![CompressionFormat::Gz, CompressionFormat::Xz])\n+    }\n+}\n+\n+impl CompressionFormats {\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = CompressionFormat> + '_ {\n+        self.0.iter().map(|i| *i)\n+    }\n+}\n+\n+pub(crate) trait Encoder: Send + Write {\n+    fn finish(self: Box<Self>) -> Result<(), Error>;\n+}\n+\n+impl<W: Send + Write> Encoder for GzEncoder<W> {\n+    fn finish(self: Box<Self>) -> Result<(), Error> {\n+        GzEncoder::finish(*self).context(\"failed to finish .gz file\")?;\n+        Ok(())\n+    }\n+}\n+\n+impl<W: Send + Write> Encoder for XzEncoder<W> {\n+    fn finish(self: Box<Self>) -> Result<(), Error> {\n+        XzEncoder::finish(*self).context(\"failed to finish .xz file\")?;\n+        Ok(())\n+    }\n+}\n+\n+pub(crate) struct CombinedEncoder {\n+    encoders: Vec<Box<dyn Encoder>>,\n+}\n+\n+impl CombinedEncoder {\n+    pub(crate) fn new(encoders: Vec<Box<dyn Encoder>>) -> Box<dyn Encoder> {\n+        Box::new(Self { encoders })\n+    }\n+}\n+\n+impl Write for CombinedEncoder {\n+    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n+        self.write_all(buf)?;\n+        Ok(buf.len())\n+    }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> std::io::Result<()> {\n+        self.encoders\n+            .par_iter_mut()\n+            .map(|w| w.write_all(buf))\n+            .collect::<std::io::Result<Vec<()>>>()?;\n+        Ok(())\n+    }\n+\n+    fn flush(&mut self) -> std::io::Result<()> {\n+        self.encoders\n+            .par_iter_mut()\n+            .map(|w| w.flush())\n+            .collect::<std::io::Result<Vec<()>>>()?;\n+        Ok(())\n+    }\n+}\n+\n+impl Encoder for CombinedEncoder {\n+    fn finish(self: Box<Self>) -> Result<(), Error> {\n+        self.encoders\n+            .into_par_iter()\n+            .map(|e| e.finish())\n+            .collect::<Result<Vec<()>, Error>>()?;\n+        Ok(())\n+    }\n+}"}]}