{"sha": "c54b77ca2da2584608a74eacdc78739e5e168456", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NGI3N2NhMmRhMjU4NDYwOGE3NGVhY2RjNzg3MzllNWUxNjg0NTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-30T01:28:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-30T01:28:35Z"}, "message": "Rollup merge of #59869 - jethrogb:jb/sgx-iovec, r=sfackler\n\nSGX target: implemented vectored I/O\n\nr? @sfackler\n\nIncludes #59857", "tree": {"sha": "48659169d808b9e5b7f8d95829466c790f46de68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48659169d808b9e5b7f8d95829466c790f46de68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c54b77ca2da2584608a74eacdc78739e5e168456", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcx6TECRBK7hj4Ov3rIwAAdHIIAGqL/+XlKMoh7L39VNNKBPah\nNwSjMmuxGXVvtJt5vAX75puFYIi7WTPTP+7dDOjzqk3fdby+Jips8PhQrywHjvkU\nj95SVcrHFrGiAlspZLuHVkzF0ZbuphTrSAcCiPdJUZYalXwvQfZsX8VSrr48FS45\n3/6UmUXP23+zyHTXsHZKvTv5hUBhs8Ly3CjQ+yUaRsPS8DvYMwbTLZPlURNiAbT3\nnOn49kcaLUxK1Z2lW/Brx0UQyQ0SC3ci5gObdAezEsNwIadRnPAGoTEc23yXqM6n\nMazFam7uOvu9fQnn8YpK6lIIxlG2g7T2yCitu5NPYamW35o5qutK30cdw6H98l8=\n=mvIA\n-----END PGP SIGNATURE-----\n", "payload": "tree 48659169d808b9e5b7f8d95829466c790f46de68\nparent 00859e3e653973120006aaf3227823062dde1ba7\nparent 09f4008da5ecee74fe06d8fd78ac39064e300512\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556587715 +0200\ncommitter GitHub <noreply@github.com> 1556587715 +0200\n\nRollup merge of #59869 - jethrogb:jb/sgx-iovec, r=sfackler\n\nSGX target: implemented vectored I/O\n\nr? @sfackler\n\nIncludes #59857\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c54b77ca2da2584608a74eacdc78739e5e168456", "html_url": "https://github.com/rust-lang/rust/commit/c54b77ca2da2584608a74eacdc78739e5e168456", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c54b77ca2da2584608a74eacdc78739e5e168456/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00859e3e653973120006aaf3227823062dde1ba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/00859e3e653973120006aaf3227823062dde1ba7", "html_url": "https://github.com/rust-lang/rust/commit/00859e3e653973120006aaf3227823062dde1ba7"}, {"sha": "09f4008da5ecee74fe06d8fd78ac39064e300512", "url": "https://api.github.com/repos/rust-lang/rust/commits/09f4008da5ecee74fe06d8fd78ac39064e300512", "html_url": "https://github.com/rust-lang/rust/commit/09f4008da5ecee74fe06d8fd78ac39064e300512"}], "stats": {"total": 75, "additions": 60, "deletions": 15}, "files": [{"sha": "38e05f6fd2757a4816eb083ed8277835176bdfa9", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=c54b77ca2da2584608a74eacdc78739e5e168456", "patch": "@@ -523,7 +523,11 @@ impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Ou\n     #[inline]\n     fn index(&self, index: I) -> &UserRef<I::Output> {\n         unsafe {\n-            UserRef::from_ptr(index.index(&*self.as_raw_ptr()))\n+            if let Some(slice) = index.get(&*self.as_raw_ptr()) {\n+                UserRef::from_ptr(slice)\n+            } else {\n+                rtabort!(\"index out of range for user slice\");\n+            }\n         }\n     }\n }\n@@ -533,7 +537,11 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I:\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n         unsafe {\n-            UserRef::from_mut_ptr(index.index_mut(&mut*self.as_raw_mut_ptr()))\n+            if let Some(slice) = index.get_mut(&mut*self.as_raw_mut_ptr()) {\n+                UserRef::from_mut_ptr(slice)\n+            } else {\n+                rtabort!(\"index out of range for user slice\");\n+            }\n         }\n     }\n }"}, {"sha": "fca62e028deab9a91e779caa4f42b6b5497d6ca2", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=c54b77ca2da2584608a74eacdc78739e5e168456", "patch": "@@ -1,4 +1,5 @@\n-use crate::io::{Error as IoError, Result as IoResult};\n+use crate::cmp;\n+use crate::io::{Error as IoError, Result as IoResult, IoSlice, IoSliceMut};\n use crate::time::Duration;\n \n pub(crate) mod alloc;\n@@ -8,13 +9,27 @@ pub(crate) mod raw;\n use self::raw::*;\n \n /// Usercall `read`. See the ABI documentation for more information.\n+///\n+/// This will do a single `read` usercall and scatter the read data among\n+/// `bufs`. To read to a single buffer, just pass a slice of length one.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n+pub fn read(fd: Fd, bufs: &mut [IoSliceMut<'_>]) -> IoResult<usize> {\n     unsafe {\n-        let mut userbuf = alloc::User::<[u8]>::uninitialized(buf.len());\n-        let len = raw::read(fd, userbuf.as_mut_ptr(), userbuf.len()).from_sgx_result()?;\n-        userbuf[..len].copy_to_enclave(&mut buf[..len]);\n-        Ok(len)\n+        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n+        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n+        let ret_len = raw::read(fd, userbuf.as_mut_ptr(), userbuf.len()).from_sgx_result()?;\n+        let userbuf = &userbuf[..ret_len];\n+        let mut index = 0;\n+        for buf in bufs {\n+            let end = cmp::min(index + buf.len(), userbuf.len());\n+            if let Some(buflen) = end.checked_sub(index) {\n+                userbuf[index..end].copy_to_enclave(&mut buf[..buflen]);\n+                index += buf.len();\n+            } else {\n+                break\n+            }\n+        }\n+        Ok(userbuf.len())\n     }\n }\n \n@@ -30,10 +45,24 @@ pub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n }\n \n /// Usercall `write`. See the ABI documentation for more information.\n+///\n+/// This will do a single `write` usercall and gather the written data from\n+/// `bufs`. To write from a single buffer, just pass a slice of length one.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub fn write(fd: Fd, buf: &[u8]) -> IoResult<usize> {\n+pub fn write(fd: Fd, bufs: &[IoSlice<'_>]) -> IoResult<usize> {\n     unsafe {\n-        let userbuf = alloc::User::new_from_enclave(buf);\n+        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n+        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n+        let mut index = 0;\n+        for buf in bufs {\n+            let end = cmp::min(index + buf.len(), userbuf.len());\n+            if let Some(buflen) = end.checked_sub(index) {\n+                userbuf[index..end].copy_from_enclave(&buf[..buflen]);\n+                index += buf.len();\n+            } else {\n+                break\n+            }\n+        }\n         raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n     }\n }"}, {"sha": "a1c4af81966b23c0d2daabda5d71d9a2cf92fd3d", "filename": "src/libstd/sys/sgx/fd.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=c54b77ca2da2584608a74eacdc78739e5e168456", "patch": "@@ -1,6 +1,6 @@\n use fortanix_sgx_abi::Fd;\n \n-use crate::io;\n+use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::sys::{AsInner, FromInner, IntoInner};\n use super::abi::usercalls;\n@@ -25,11 +25,19 @@ impl FileDesc {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        usercalls::read(self.fd, buf)\n+        usercalls::read(self.fd, &mut [IoSliceMut::new(buf)])\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        usercalls::read(self.fd, bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        usercalls::write(self.fd, buf)\n+        usercalls::write(self.fd, &[IoSlice::new(buf)])\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        usercalls::write(self.fd, bufs)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {"}, {"sha": "f9eca9f4cb3c1db7b1ecb58f29d906b8b9f6f58f", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54b77ca2da2584608a74eacdc78739e5e168456/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=c54b77ca2da2584608a74eacdc78739e5e168456", "patch": "@@ -137,15 +137,15 @@ impl TcpStream {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::default_read_vectored(|b| self.read(b), bufs)\n+        self.inner.inner.read_vectored(bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.write(buf)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::default_write_vectored(|b| self.write(b), bufs)\n+        self.inner.inner.write_vectored(bufs)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {"}]}