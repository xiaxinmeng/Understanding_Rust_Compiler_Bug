{"sha": "bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYWJjZjUzY2ZlMmE4NmViZjAyYWE3NjJiOGFiNzI3ODA2MGNlMTA=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-01-18T06:30:36Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-18T20:03:38Z"}, "message": "Make bytes!() return 'static\n\nChange `bytes!()` to return\n\n    {\n        static BYTES: &'static [u8] = &[...];\n        BYTES\n    }\n\nThis gives it the `'static` lifetime, whereas before it had an rvalue\nlifetime. Until recently this would have prevented assigning `bytes!()`\nto a static, as in\n\n    static FOO: &'static [u8] = bytes!(1,2,3);\n\nbut #14183 fixed it so blocks are now allowed in constant expressions\n(with restrictions).\n\nFixes #11641.", "tree": {"sha": "5a0ce4fec2100f41123572573abfde840bc1b2f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a0ce4fec2100f41123572573abfde840bc1b2f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "html_url": "https://github.com/rust-lang/rust/commit/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "134f797a6309e8f284372c745689bcde17829c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/134f797a6309e8f284372c745689bcde17829c30", "html_url": "https://github.com/rust-lang/rust/commit/134f797a6309e8f284372c745689bcde17829c30"}], "stats": {"total": 54, "additions": 48, "deletions": 6}, "files": [{"sha": "b2088d2bc82f636fbe008f80533d3174daf027f0", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "patch": "@@ -25,6 +25,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(e) => e,\n     };\n     let mut bytes = Vec::new();\n+    let mut err = false;\n \n     for expr in exprs.iter() {\n         match expr.node {\n@@ -40,7 +41,8 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 // u8 literal, push to vector expression\n                 ast::LitUint(v, ast::TyU8) => {\n                     if v > 0xFF {\n-                        cx.span_err(expr.span, \"too large u8 literal in bytes!\")\n+                        cx.span_err(expr.span, \"too large u8 literal in bytes!\");\n+                        err = true;\n                     } else {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     }\n@@ -49,9 +51,11 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 // integer literal, push to vector expression\n                 ast::LitIntUnsuffixed(v) => {\n                     if v > 0xFF {\n-                        cx.span_err(expr.span, \"too large integer literal in bytes!\")\n+                        cx.span_err(expr.span, \"too large integer literal in bytes!\");\n+                        err = true;\n                     } else if v < 0 {\n-                        cx.span_err(expr.span, \"negative integer literal in bytes!\")\n+                        cx.span_err(expr.span, \"negative integer literal in bytes!\");\n+                        err = true;\n                     } else {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     }\n@@ -62,17 +66,34 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     if v.is_ascii() {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     } else {\n-                        cx.span_err(expr.span, \"non-ascii char literal in bytes!\")\n+                        cx.span_err(expr.span, \"non-ascii char literal in bytes!\");\n+                        err = true;\n                     }\n                 }\n \n-                _ => cx.span_err(expr.span, \"unsupported literal in bytes!\")\n+                _ => {\n+                    cx.span_err(expr.span, \"unsupported literal in bytes!\");\n+                    err = true;\n+                }\n             },\n \n-            _ => cx.span_err(expr.span, \"non-literal in bytes!\")\n+            _ => {\n+                cx.span_err(expr.span, \"non-literal in bytes!\");\n+                err = true;\n+            }\n         }\n     }\n \n+    // For some reason using quote_expr!() here aborts if we threw an error.\n+    // I'm assuming that the end of the recursive parse tricks the compiler\n+    // into thinking this is a good time to stop. But we'd rather keep going.\n+    if err {\n+        // Since the compiler will stop after the macro expansion phase anyway, we\n+        // don't need type info, so we can just return a DummyResult\n+        return DummyResult::expr(sp);\n+    }\n+\n     let e = cx.expr_vec_slice(sp, bytes);\n+    let e = quote_expr!(cx, { static BYTES: &'static [u8] = $e; BYTES});\n     MacExpr::new(e)\n }"}, {"sha": "7f4bbda8e30d818422fdad3bc95141e857ecb5de", "filename": "src/test/run-pass/bytes-macro-static.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcabcf53cfe2a86ebf02aa762b8ab7278060ce10/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbytes-macro-static.rs?ref=bcabcf53cfe2a86ebf02aa762b8ab7278060ce10", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static FOO: &'static [u8] = bytes!(\"hello, world\");\n+\n+pub fn main() {\n+    let b = match true {\n+        true => bytes!(\"test\"),\n+        false => unreachable!()\n+    };\n+\n+    assert_eq!(b, \"test\".as_bytes());\n+    assert_eq!(FOO, \"hello, world\".as_bytes());\n+}"}]}