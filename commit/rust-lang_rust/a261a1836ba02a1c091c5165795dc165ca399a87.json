{"sha": "a261a1836ba02a1c091c5165795dc165ca399a87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjFhMTgzNmJhMDJhMWMwOTFjNTE2NTc5NWRjMTY1Y2EzOTlhODc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-02T14:07:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-02T14:09:23Z"}, "message": "Move to rowan for syntax tree impl", "tree": {"sha": "e8bab3ea497a8e7207a24e481361bdd56ed81eaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8bab3ea497a8e7207a24e481361bdd56ed81eaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a261a1836ba02a1c091c5165795dc165ca399a87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a261a1836ba02a1c091c5165795dc165ca399a87", "html_url": "https://github.com/rust-lang/rust/commit/a261a1836ba02a1c091c5165795dc165ca399a87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a261a1836ba02a1c091c5165795dc165ca399a87/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd9c5f4ab205e092b87be6affe6d7e78d877dbf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0", "html_url": "https://github.com/rust-lang/rust/commit/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0"}], "stats": {"total": 682, "additions": 150, "deletions": 532}, "files": [{"sha": "fb1609e44fcc20e98000a6b67c67ca8b35c2acdd", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -602,9 +602,8 @@ dependencies = [\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smol_str 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n- \"text_unit 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -713,6 +712,16 @@ dependencies = [\n  \"serde 1.0.79 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rowan\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smol_str 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"text_unit 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc-demangle\"\n version = \"0.1.9\"\n@@ -1230,6 +1239,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e614f96449605730b4f7ad2c019e88c1652d730634b4eba07b810801856635e3\"\n \"checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5\"\n \"checksum ron 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9fa11b7a38511d46ff1959ae46ebb60bd8a746f17bdd0206b4c8de7559ac47b\"\n+\"checksum rowan 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a1a7366ece9deee5e7df8316a136d585d5c5042854c2297f7f1aee3014c9130\"\n \"checksum rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcfe5b13211b4d78e5c2cadfebd7769197d95c639c35a50057eb4c05de811395\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n \"checksum ryu 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7153dd96dade874ab973e098cb62fcdbb89a03682e46b144fd09550998d4a4a7\""}, {"sha": "8e4e84729a51d29a43294260778f1b172dc8be49", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -1,5 +1,6 @@\n [workspace]\n members = [ \"crates/*\" ]\n+exclude = [ \"crates/rowan\"]\n \n [profile.release]\n debug = true"}, {"sha": "6345e4725a5f0770983834b8c197fce7fd002bac", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -6,11 +6,10 @@ license = \"MIT OR Apache-2.0\"\n \n [dependencies]\n unicode-xid = \"0.1.0\"\n-text_unit = \"0.1.4\"\n itertools = \"0.7.8\"\n drop_bomb = \"0.1.4\"\n parking_lot = \"0.6.0\"\n-smol_str = \"0.1.6\"\n+rowan = \"0.1.0\"\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "c1570b868f0ef4b025e96ee7a701134c70a73142", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -3,10 +3,9 @@ mod generated;\n use std::marker::PhantomData;\n \n use itertools::Itertools;\n-use smol_str::SmolStr;\n \n use {\n-    SyntaxNodeRef, SyntaxKind::*,\n+    SmolStr, SyntaxNodeRef, SyntaxKind::*,\n     yellow::{RefRoot, SyntaxNodeChildren},\n };\n pub use self::generated::*;\n@@ -76,7 +75,7 @@ impl<'a> Attr<'a> {\n         let tt = self.value()?;\n         let (_bra, attr, _ket) = tt.syntax().children().collect_tuple()?;\n         if attr.kind() == IDENT {\n-            Some(attr.leaf_text().unwrap())\n+            Some(attr.leaf_text().unwrap().clone())\n         } else {\n             None\n         }\n@@ -87,7 +86,7 @@ impl<'a> Attr<'a> {\n         let (_bra, attr, args, _ket) = tt.syntax().children().collect_tuple()?;\n         let args = TokenTree::cast(args)?;\n         if attr.kind() == IDENT {\n-            Some((attr.leaf_text().unwrap(), args))\n+            Some((attr.leaf_text().unwrap().clone(), args))\n         } else {\n             None\n         }\n@@ -96,23 +95,23 @@ impl<'a> Attr<'a> {\n \n impl<'a> Lifetime<'a> {\n     pub fn text(&self) -> SmolStr {\n-        self.syntax().leaf_text().unwrap()\n+        self.syntax().leaf_text().unwrap().clone()\n     }\n }\n \n impl<'a> Name<'a> {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child()\n             .unwrap();\n-        ident.leaf_text().unwrap()\n+        ident.leaf_text().unwrap().clone()\n     }\n }\n \n impl<'a> NameRef<'a> {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child()\n             .unwrap();\n-        ident.leaf_text().unwrap()\n+        ident.leaf_text().unwrap().clone()\n     }\n }\n "}, {"sha": "c7eda45636ecaf2b5ae59578a83080f4d7640f96", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -24,8 +24,7 @@ extern crate itertools;\n extern crate unicode_xid;\n extern crate drop_bomb;\n extern crate parking_lot;\n-extern crate smol_str;\n-extern crate text_unit;\n+extern crate rowan;\n \n #[cfg(test)]\n #[macro_use]\n@@ -48,8 +47,7 @@ pub mod utils;\n pub mod text_utils;\n \n pub use {\n-    text_unit::{TextRange, TextUnit},\n-    smol_str::SmolStr,\n+    rowan::{SmolStr, TextRange, TextUnit},\n     ast::AstNode,\n     lexer::{tokenize, Token},\n     syntax_kinds::SyntaxKind,\n@@ -58,7 +56,7 @@ pub use {\n };\n \n use {\n-    yellow::{GreenNode, SyntaxRoot},\n+    yellow::{GreenNode},\n };\n \n #[derive(Clone, Debug, Hash)]\n@@ -68,8 +66,7 @@ pub struct File {\n \n impl File {\n     fn new(green: GreenNode, errors: Vec<SyntaxError>) -> File {\n-        let root = SyntaxRoot::new(green, errors);\n-        let root = SyntaxNode::new_owned(root);\n+        let root = SyntaxNode::new(green, errors);\n         if cfg!(debug_assertions) {\n             utils::validate_block_structure(root.borrowed());\n         }\n@@ -100,6 +97,6 @@ impl File {\n         self.root.borrowed()\n     }\n     pub fn errors(&self) -> Vec<SyntaxError> {\n-        self.syntax().root.syntax_root().errors.clone()\n+        self.root.root_data().clone()\n     }\n }"}, {"sha": "e3c200d1e13dc926ee3b4fd0e358aca6d0b90c55", "filename": "crates/ra_syntax/src/reparsing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Freparsing.rs?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -1,11 +1,11 @@\n use algo;\n use grammar;\n use lexer::{tokenize, Token};\n-use text_unit::{TextRange, TextUnit};\n-use yellow::{self, SyntaxNodeRef, GreenNode, SyntaxError};\n+use yellow::{self, GreenNode, SyntaxNodeRef, SyntaxError};\n use parser_impl;\n use parser_api::Parser;\n use {\n+    TextUnit, TextRange,\n     SyntaxKind::*,\n };\n use text_utils::replace_range;\n@@ -65,7 +65,7 @@ fn reparse_leaf<'node>(\n                 return None;\n             }\n \n-            let green = GreenNode::new_leaf(node.kind(), &text);\n+            let green = GreenNode::new_leaf(node.kind(), text.into());\n             let new_errors = vec![];\n             Some((node, green, new_errors))\n         }\n@@ -340,4 +340,4 @@ enum Foo {\n }\n \", \"Clone\");\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8bc5f0e24cc7ff098998fdcab79af73de84a0943", "filename": "crates/ra_syntax/src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Futils.rs?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -1,12 +1,12 @@\n use std::fmt::Write;\n use {\n     algo::walk::{preorder, walk, WalkEvent},\n-    SyntaxKind, File, SyntaxNodeRef, TreeRoot,\n+    SyntaxKind, File, SyntaxNodeRef\n };\n \n /// Parse a file and create a string representation of the resulting parse tree.\n pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n-    let mut errors: Vec<_> = syntax.root.syntax_root().errors.iter().cloned().collect();\n+    let mut errors: Vec<_> = syntax.root_data().iter().cloned().collect();\n     errors.sort_by_key(|e| e.offset);\n     let mut err_pos = 0;\n     let mut level = 0;"}, {"sha": "35dbaec05bd563df381ff048fbb7511372166dba", "filename": "crates/ra_syntax/src/yellow/builder.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -1,15 +1,15 @@\n+use rowan::GreenNodeBuilder;\n use {\n     parser_impl::Sink,\n-    yellow::{GreenNode, SyntaxError},\n+    yellow::{GreenNode, SyntaxError, RaTypes},\n     SyntaxKind, TextRange, TextUnit,\n };\n \n pub(crate) struct GreenBuilder<'a> {\n     text: &'a str,\n-    parents: Vec<(SyntaxKind, usize)>,\n-    children: Vec<GreenNode>,\n     pos: TextUnit,\n     errors: Vec<SyntaxError>,\n+    inner: GreenNodeBuilder<RaTypes>,\n }\n \n impl<'a> Sink<'a> for GreenBuilder<'a> {\n@@ -18,35 +18,25 @@ impl<'a> Sink<'a> for GreenBuilder<'a> {\n     fn new(text: &'a str) -> Self {\n         GreenBuilder {\n             text,\n-            parents: Vec::new(),\n-            children: Vec::new(),\n             pos: 0.into(),\n             errors: Vec::new(),\n+            inner: GreenNodeBuilder::new(),\n         }\n     }\n \n     fn leaf(&mut self, kind: SyntaxKind, len: TextUnit) {\n         let range = TextRange::offset_len(self.pos, len);\n         self.pos += len;\n-        let text = &self.text[range];\n-        self.children.push(\n-            GreenNode::new_leaf(kind, text)\n-        );\n+        let text = self.text[range].into();\n+        self.inner.leaf(kind, text);\n     }\n \n     fn start_internal(&mut self, kind: SyntaxKind) {\n-        let len = self.children.len();\n-        self.parents.push((kind, len));\n+        self.inner.start_internal(kind)\n     }\n \n     fn finish_internal(&mut self) {\n-        let (kind, first_child) = self.parents.pop().unwrap();\n-        let children: Vec<_> = self.children\n-            .drain(first_child..)\n-            .collect();\n-        self.children.push(\n-            GreenNode::new_branch(kind, children.into_boxed_slice())\n-        );\n+        self.inner.finish_internal();\n     }\n \n     fn error(&mut self, message: String) {\n@@ -56,9 +46,7 @@ impl<'a> Sink<'a> for GreenBuilder<'a> {\n         })\n     }\n \n-    fn finish(mut self) -> (GreenNode, Vec<SyntaxError>) {\n-        assert_eq!(self.children.len(), 1);\n-        let root = self.children.pop().unwrap();\n-        (root, self.errors)\n+    fn finish(self) -> (GreenNode, Vec<SyntaxError>) {\n+        (self.inner.finish(), self.errors)\n     }\n }"}, {"sha": "8fb69164394b4cc4132a7d753aa30290ec6b57be", "filename": "crates/ra_syntax/src/yellow/green.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fgreen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fgreen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fgreen.rs?ref=cd9c5f4ab205e092b87be6affe6d7e78d877dbf0", "patch": "@@ -1,90 +0,0 @@\n-use std::sync::Arc;\n-\n-use smol_str::SmolStr;\n-\n-use {SyntaxKind, TextUnit};\n-\n-#[derive(Clone, Debug)]\n-pub(crate) enum GreenNode {\n-    Leaf {\n-        kind: SyntaxKind,\n-        text: SmolStr,\n-    },\n-    Branch(Arc<GreenBranch>),\n-}\n-\n-impl GreenNode {\n-    pub(crate) fn new_leaf(kind: SyntaxKind, text: &str) -> GreenNode {\n-        GreenNode::Leaf { kind, text: SmolStr::new(text) }\n-    }\n-\n-    pub(crate) fn new_branch(kind: SyntaxKind, children: Box<[GreenNode]>) -> GreenNode {\n-        GreenNode::Branch(Arc::new(GreenBranch::new(kind, children)))\n-    }\n-\n-    pub fn kind(&self) -> SyntaxKind {\n-        match self {\n-            GreenNode::Leaf { kind, .. } => *kind,\n-            GreenNode::Branch(b) => b.kind(),\n-        }\n-    }\n-\n-    pub fn text_len(&self) -> TextUnit {\n-        match self {\n-            GreenNode::Leaf { text, .. } => TextUnit::from(text.len() as u32),\n-            GreenNode::Branch(b) => b.text_len(),\n-        }\n-    }\n-\n-    pub fn children(&self) -> &[GreenNode] {\n-        match self {\n-            GreenNode::Leaf { .. } => &[],\n-            GreenNode::Branch(b) => b.children(),\n-        }\n-    }\n-\n-    pub fn leaf_text_ref(&self) -> Option<&SmolStr> {\n-        match self {\n-            GreenNode::Leaf { text, .. } => Some(text),\n-            GreenNode::Branch(_) => None,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct GreenBranch {\n-    text_len: TextUnit,\n-    kind: SyntaxKind,\n-    children: Box<[GreenNode]>,\n-}\n-\n-impl GreenBranch {\n-    fn new(kind: SyntaxKind, children: Box<[GreenNode]>) -> GreenBranch {\n-        let text_len = children.iter().map(|x| x.text_len()).sum::<TextUnit>();\n-        GreenBranch {\n-            text_len,\n-            kind,\n-            children,\n-        }\n-    }\n-\n-    pub fn kind(&self) -> SyntaxKind {\n-        self.kind\n-    }\n-\n-    pub fn text_len(&self) -> TextUnit {\n-        self.text_len\n-    }\n-\n-    pub fn children(&self) -> &[GreenNode] {\n-        &*self.children\n-    }\n-}\n-\n-#[test]\n-fn test_sizes() {\n-    use std::mem::size_of;\n-    println!(\"GreenBranch = {}\", size_of::<GreenBranch>());\n-    println!(\"GreenNode   = {}\", size_of::<GreenNode>());\n-    println!(\"SmolStr     = {}\", size_of::<SmolStr>());\n-}"}, {"sha": "c621b1d6a3a9536c122d885aa51fed6b85b9f280", "filename": "crates/ra_syntax/src/yellow/mod.rs", "status": "modified", "additions": 108, "deletions": 66, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fmod.rs?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -1,100 +1,142 @@\n mod builder;\n-mod green;\n-mod red;\n-mod syntax;\n mod syntax_text;\n \n use std::{\n-    sync::Arc,\n-    ptr,\n-};\n-pub use self::syntax::{SyntaxNode, SyntaxNodeRef, SyntaxError, SyntaxNodeChildren};\n-pub(crate) use self::{\n-    builder::GreenBuilder,\n-    green::GreenNode,\n-    red::RedNode,\n-    syntax_text::SyntaxText,\n+    fmt,\n+    hash::{Hash, Hasher},\n };\n+use rowan::Types;\n+use {SyntaxKind, TextUnit, TextRange, SmolStr};\n+use self::syntax_text::SyntaxText;\n \n-#[derive(Debug)]\n-pub struct SyntaxRoot {\n-    red: RedNode,\n-    pub(crate) errors: Vec<SyntaxError>,\n+pub use rowan::{TreeRoot};\n+pub(crate) use self::builder::GreenBuilder;\n+\n+#[derive(Debug, Clone, Copy)]\n+pub enum RaTypes {}\n+impl Types for RaTypes {\n+    type Kind = SyntaxKind;\n+    type RootData = Vec<SyntaxError>;\n }\n \n-pub trait TreeRoot: Clone + Send + Sync {\n-    fn borrowed(&self) -> RefRoot;\n-    fn owned(&self) -> OwnedRoot;\n+pub type OwnedRoot = ::rowan::OwnedRoot<RaTypes>;\n+pub type RefRoot<'a> = ::rowan::RefRoot<'a, RaTypes>;\n+\n+pub type GreenNode = ::rowan::GreenNode<RaTypes>;\n \n-    #[doc(hidden)]\n-    fn syntax_root(&self) -> &SyntaxRoot;\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub struct SyntaxError {\n+    pub msg: String,\n+    pub offset: TextUnit,\n }\n-#[derive(Clone, Debug)]\n-pub struct OwnedRoot(Arc<SyntaxRoot>);\n-#[derive(Clone, Copy, Debug)]\n-pub struct RefRoot<'a>(&'a OwnedRoot); // TODO: shared_from_this instead of double indirection\n \n-impl<'a> RefRoot<'a> {\n-    fn syntax_root(&self) -> &'a SyntaxRoot {\n-        self.0.syntax_root()\n+#[derive(Clone, Copy)]\n+pub struct SyntaxNode<R: TreeRoot<RaTypes> = OwnedRoot>(\n+    ::rowan::SyntaxNode<RaTypes, R>,\n+);\n+pub type SyntaxNodeRef<'a> = SyntaxNode<RefRoot<'a>>;\n+\n+impl<R1, R2> PartialEq<SyntaxNode<R1>> for SyntaxNode<R2>\n+where\n+    R1: TreeRoot<RaTypes>,\n+    R2: TreeRoot<RaTypes>,\n+{\n+    fn eq(&self, other: &SyntaxNode<R1>) -> bool {\n+        self.0 == other.0\n     }\n }\n \n-impl TreeRoot for OwnedRoot {\n-    fn borrowed(&self) -> RefRoot {\n-        RefRoot(&self)\n-    }\n-    fn owned(&self) -> OwnedRoot {\n-        self.clone()\n+impl<R: TreeRoot<RaTypes>> Eq for SyntaxNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for SyntaxNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.0.hash(state)\n     }\n+}\n \n-    fn syntax_root(&self) -> &SyntaxRoot {\n-        &*self.0\n+impl SyntaxNode<OwnedRoot> {\n+    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> SyntaxNode {\n+        SyntaxNode(::rowan::SyntaxNode::new(green, errors))\n+    }\n+}\n+impl<'a> SyntaxNode<RefRoot<'a>> {\n+    pub fn leaf_text(self) -> Option<&'a SmolStr> {\n+        self.0.leaf_text()\n     }\n }\n \n-impl<'a> TreeRoot for RefRoot<'a> {\n-    fn borrowed(&self) -> RefRoot {\n-        *self\n+impl<R: TreeRoot<RaTypes>> SyntaxNode<R> {\n+    pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n+        self.0.root_data()\n+    }\n+    pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n+        self.0.replace_with(replacement)\n+    }\n+    pub fn borrowed<'a>(&'a self) -> SyntaxNode<RefRoot<'a>> {\n+        SyntaxNode(self.0.borrowed())\n+    }\n+    pub fn owned(&self) -> SyntaxNode<OwnedRoot> {\n+        SyntaxNode(self.0.owned())\n+    }\n+    pub fn kind(&self) -> SyntaxKind {\n+        self.0.kind()\n     }\n-    fn owned(&self) -> OwnedRoot {\n-        self.0.clone()\n+    pub fn range(&self) -> TextRange {\n+        self.0.range()\n     }\n-    fn syntax_root(&self) -> &SyntaxRoot {\n-        self.0.syntax_root()\n+    pub fn text(&self) -> SyntaxText {\n+        SyntaxText::new(self.borrowed())\n+    }\n+    pub fn is_leaf(&self) -> bool {\n+        self.0.is_leaf()\n+    }\n+    pub fn parent(&self) -> Option<SyntaxNode<R>> {\n+        self.0.parent().map(SyntaxNode)\n+    }\n+    pub fn first_child(&self) -> Option<SyntaxNode<R>> {\n+        self.0.first_child().map(SyntaxNode)\n+    }\n+    pub fn last_child(&self) -> Option<SyntaxNode<R>> {\n+        self.0.last_child().map(SyntaxNode)\n+    }\n+    pub fn next_sibling(&self) -> Option<SyntaxNode<R>> {\n+        self.0.next_sibling().map(SyntaxNode)\n+    }\n+    pub fn prev_sibling(&self) -> Option<SyntaxNode<R>> {\n+        self.0.prev_sibling().map(SyntaxNode)\n+    }\n+    pub fn children(&self) -> SyntaxNodeChildren<R> {\n+        SyntaxNodeChildren(self.0.children())\n     }\n }\n \n-impl SyntaxRoot {\n-    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> SyntaxRoot {\n-        SyntaxRoot {\n-            red: RedNode::new_root(green),\n-            errors,\n+impl<R: TreeRoot<RaTypes>> fmt::Debug for SyntaxNode<R> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n+        if has_short_text(self.kind()) {\n+            write!(fmt, \" \\\"{}\\\"\", self.text())?;\n         }\n+        Ok(())\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub(crate) struct RedPtr(ptr::NonNull<RedNode>);\n-\n-unsafe impl Send for RedPtr {}\n-\n-unsafe impl Sync for RedPtr {}\n+#[derive(Debug)]\n+pub struct SyntaxNodeChildren<R: TreeRoot<RaTypes>>(\n+    ::rowan::SyntaxNodeChildren<RaTypes, R>\n+);\n \n-impl RedPtr {\n-    fn new(red: &RedNode) -> RedPtr {\n-        RedPtr(red.into())\n-    }\n+impl<R: TreeRoot<RaTypes>> Iterator for SyntaxNodeChildren<R> {\n+    type Item = SyntaxNode<R>;\n \n-    unsafe fn get<'a>(self, _root: &'a SyntaxRoot) -> &'a RedNode {\n-        &*self.0.as_ptr()\n+    fn next(&mut self) -> Option<SyntaxNode<R>> {\n+        self.0.next().map(SyntaxNode)\n     }\n }\n \n-#[test]\n-fn assert_send_sync() {\n-    fn f<T: Send + Sync>() {}\n-    f::<GreenNode>();\n-    f::<RedNode>();\n-    f::<SyntaxNode>();\n+\n+fn has_short_text(kind: SyntaxKind) -> bool {\n+    use SyntaxKind::*;\n+    match kind {\n+        IDENT | LIFETIME | INT_NUMBER | FLOAT_NUMBER => true,\n+        _ => false,\n+    }\n }"}, {"sha": "84cfe4fba2b442e72e89d24a211afb363f54de90", "filename": "crates/ra_syntax/src/yellow/red.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fred.rs?ref=cd9c5f4ab205e092b87be6affe6d7e78d877dbf0", "patch": "@@ -1,113 +0,0 @@\n-use parking_lot::RwLock;\n-use {yellow::{GreenNode, RedPtr}, TextUnit};\n-\n-#[derive(Debug)]\n-pub(crate) struct RedNode {\n-    green: GreenNode,\n-    parent: Option<ParentData>,\n-    children: RwLock<Box<[RedChild]>>,\n-}\n-\n-#[derive(Debug)]\n-enum RedChild {\n-    Zigot(TextUnit),\n-    Child(RedNode)\n-}\n-\n-impl RedChild {\n-    fn set(&mut self, node: RedNode) -> &RedNode {\n-        match self {\n-            RedChild::Child(node) => return node,\n-            RedChild::Zigot(_) => {\n-                *self = RedChild::Child(node);\n-                match self {\n-                    RedChild::Child(node) => return node,\n-                    RedChild::Zigot(_) => unreachable!()\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct ParentData {\n-    parent: RedPtr,\n-    start_offset: TextUnit,\n-    index_in_parent: usize,\n-}\n-\n-impl RedNode {\n-    pub fn new_root(green: GreenNode) -> RedNode {\n-        RedNode::new(green, None)\n-    }\n-\n-    fn new_child(\n-        green: GreenNode,\n-        parent: RedPtr,\n-        start_offset: TextUnit,\n-        index_in_parent: usize,\n-    ) -> RedNode {\n-        let parent_data = ParentData {\n-            parent,\n-            start_offset,\n-            index_in_parent,\n-        };\n-        RedNode::new(green, Some(parent_data))\n-    }\n-\n-    fn new(green: GreenNode, parent: Option<ParentData>) -> RedNode {\n-        let mut start_offset = parent.as_ref().map(|it| it.start_offset).unwrap_or(0.into());\n-        let children = green.children()\n-            .iter()\n-            .map(|child| {\n-                let off = start_offset;\n-                start_offset += child.text_len();\n-                RedChild::Zigot(off)\n-            })\n-            .collect::<Vec<_>>()\n-            .into_boxed_slice();\n-        RedNode {\n-            green,\n-            parent,\n-            children: RwLock::new(children),\n-        }\n-    }\n-\n-    pub(crate) fn green(&self) -> &GreenNode {\n-        &self.green\n-    }\n-\n-    pub(crate) fn start_offset(&self) -> TextUnit {\n-        match &self.parent {\n-            None => 0.into(),\n-            Some(p) => p.start_offset,\n-        }\n-    }\n-\n-    pub(crate) fn n_children(&self) -> usize {\n-        self.green.children().len()\n-    }\n-\n-    pub(crate) fn get_child(&self, idx: usize) -> Option<RedPtr> {\n-        if idx >= self.n_children() {\n-            return None;\n-        }\n-        let start_offset = match &self.children.read()[idx] {\n-            RedChild::Child(child) => return Some(RedPtr::new(child)),\n-            RedChild::Zigot(start_offset) => *start_offset,\n-        };\n-        let green_children = self.green.children();\n-        let child =\n-            RedNode::new_child(green_children[idx].clone(), RedPtr::new(self), start_offset, idx);\n-        let mut children = self.children.write();\n-        let child = children[idx].set(child);\n-        Some(RedPtr::new(child))\n-    }\n-\n-    pub(crate) fn parent(&self) -> Option<RedPtr> {\n-        Some(self.parent.as_ref()?.parent)\n-    }\n-    pub(crate) fn index_in_parent(&self) -> Option<usize> {\n-        Some(self.parent.as_ref()?.index_in_parent)\n-    }\n-}"}, {"sha": "1d99cab4a94520a034e15bfd40db8a9274ac932b", "filename": "crates/ra_syntax/src/yellow/syntax.rs", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9c5f4ab205e092b87be6affe6d7e78d877dbf0/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax.rs?ref=cd9c5f4ab205e092b87be6affe6d7e78d877dbf0", "patch": "@@ -1,215 +0,0 @@\n-use std::{\n-    fmt, sync::Arc,\n-    hash::{Hasher, Hash},\n-    ops::Range,\n-};\n-\n-use smol_str::SmolStr;\n-\n-use {\n-    yellow::{GreenNode, RedNode, TreeRoot, SyntaxRoot, RedPtr, RefRoot, OwnedRoot, SyntaxText},\n-    SyntaxKind::{self, *},\n-    TextRange, TextUnit,\n-};\n-\n-\n-#[derive(Clone, Copy)]\n-pub struct SyntaxNode<R: TreeRoot = OwnedRoot> {\n-    pub(crate) root: R,\n-    // Guaranteed to not dangle, because `root` holds a\n-    // strong reference to red's ancestor\n-    red: RedPtr,\n-}\n-\n-unsafe impl<R: TreeRoot> Send for SyntaxNode<R> {}\n-unsafe impl<R: TreeRoot> Sync for SyntaxNode<R> {}\n-\n-impl<R1: TreeRoot, R2: TreeRoot> PartialEq<SyntaxNode<R1>> for SyntaxNode<R2> {\n-    fn eq(&self, other: &SyntaxNode<R1>) -> bool {\n-        self.red == other.red\n-    }\n-}\n-\n-impl<R: TreeRoot> Eq for SyntaxNode<R> {}\n-impl<R: TreeRoot> Hash for SyntaxNode<R> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.red.hash(state)\n-    }\n-}\n-\n-pub type SyntaxNodeRef<'a> = SyntaxNode<RefRoot<'a>>;\n-\n-#[test]\n-fn syntax_node_ref_is_copy() {\n-    fn assert_copy<T: Copy>(){}\n-    assert_copy::<SyntaxNodeRef>()\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n-pub struct SyntaxError {\n-    pub msg: String,\n-    pub offset: TextUnit,\n-}\n-\n-impl SyntaxNode<OwnedRoot> {\n-    pub(crate) fn new_owned(root: SyntaxRoot) -> Self {\n-        let root = OwnedRoot(Arc::new(root));\n-        let red = RedPtr::new(&root.syntax_root().red);\n-        SyntaxNode { root, red }\n-    }\n-}\n-\n-impl<'a> SyntaxNode<RefRoot<'a>> {\n-    pub(crate) fn leaf_text_ref(self) -> Option<&'a SmolStr> {\n-        let red = unsafe { self.red.get(self.root.syntax_root()) };\n-        red.green().leaf_text_ref()\n-    }\n-}\n-\n-impl<R: TreeRoot> SyntaxNode<R> {\n-    pub fn borrowed<'a>(&'a self) -> SyntaxNodeRef<'a> {\n-        SyntaxNode {\n-            root: self.root.borrowed(),\n-            red: self.red,\n-        }\n-    }\n-\n-    pub fn owned(&self) -> SyntaxNode {\n-        SyntaxNode {\n-            root: self.root.owned(),\n-            red: self.red,\n-        }\n-    }\n-\n-    pub fn kind(&self) -> SyntaxKind {\n-        self.red().green().kind()\n-    }\n-\n-    pub fn range(&self) -> TextRange {\n-        let red = self.red();\n-        TextRange::offset_len(red.start_offset(), red.green().text_len())\n-    }\n-\n-    pub fn text(&self) -> SyntaxText {\n-        SyntaxText::new(self.borrowed())\n-    }\n-\n-    pub fn children(&self) -> SyntaxNodeChildren<R> {\n-        SyntaxNodeChildren {\n-            parent: self.clone(),\n-            iter: (0..self.red().n_children())\n-        }\n-    }\n-\n-    pub fn parent(&self) -> Option<SyntaxNode<R>> {\n-        let parent = self.red().parent()?;\n-        Some(SyntaxNode {\n-            root: self.root.clone(),\n-            red: parent,\n-        })\n-    }\n-\n-    pub fn first_child(&self) -> Option<SyntaxNode<R>> {\n-        let red = self.red().get_child(0)?;\n-        Some(SyntaxNode { root: self.root.clone(), red })\n-    }\n-\n-    pub fn last_child(&self) -> Option<SyntaxNode<R>> {\n-        let n = self.red().n_children();\n-        let n = n.checked_sub(1)?;\n-        let red = self.red().get_child(n)?;\n-        Some(SyntaxNode { root: self.root.clone(), red })\n-    }\n-\n-    pub fn next_sibling(&self) -> Option<SyntaxNode<R>> {\n-        let red = self.red();\n-        let parent = self.parent()?;\n-        let next_sibling_idx = red.index_in_parent()? + 1;\n-        let sibling_red = parent.red().get_child(next_sibling_idx)?;\n-        Some(SyntaxNode {\n-            root: self.root.clone(),\n-            red: sibling_red,\n-        })\n-    }\n-\n-    pub fn prev_sibling(&self) -> Option<SyntaxNode<R>> {\n-        let red = self.red();\n-        let parent = self.parent()?;\n-        let prev_sibling_idx = red.index_in_parent()?.checked_sub(1)?;\n-        let sibling_red = parent.red().get_child(prev_sibling_idx)?;\n-        Some(SyntaxNode {\n-            root: self.root.clone(),\n-            red: sibling_red,\n-        })\n-    }\n-\n-    pub fn is_leaf(&self) -> bool {\n-        self.first_child().is_none()\n-    }\n-\n-    pub fn leaf_text(&self) -> Option<SmolStr> {\n-        self.borrowed().leaf_text_ref().map(|it| it.clone())\n-    }\n-\n-    pub(crate) fn replace_with(&self, green: GreenNode) -> GreenNode {\n-        assert_eq!(self.kind(), green.kind());\n-        match self.parent() {\n-            None => green,\n-            Some(parent) => {\n-                let children: Vec<_> = parent.children().map(|child| {\n-                    if child == *self {\n-                        green.clone()\n-                    } else {\n-                        child.red().green().clone()\n-                    }\n-                }).collect();\n-                let new_parent = GreenNode::new_branch(\n-                    parent.kind(),\n-                    children.into_boxed_slice(),\n-                );\n-                parent.replace_with(new_parent)\n-            },\n-        }\n-    }\n-\n-    fn red(&self) -> &RedNode {\n-        unsafe { self.red.get(self.root.syntax_root()) }\n-    }\n-}\n-\n-impl<R: TreeRoot> fmt::Debug for SyntaxNode<R> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n-        if has_short_text(self.kind()) {\n-            write!(fmt, \" \\\"{}\\\"\", self.text())?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct SyntaxNodeChildren<R: TreeRoot> {\n-    parent: SyntaxNode<R>,\n-    iter: Range<usize>,\n-}\n-\n-impl<R: TreeRoot> Iterator for SyntaxNodeChildren<R> {\n-    type Item = SyntaxNode<R>;\n-\n-    fn next(&mut self) -> Option<SyntaxNode<R>> {\n-        self.iter.next().map(|i| {\n-            let red = self.parent.red();\n-            SyntaxNode {\n-                root: self.parent.root.clone(),\n-                red: red.get_child(i).unwrap(),\n-            }\n-        })\n-    }\n-}\n-\n-fn has_short_text(kind: SyntaxKind) -> bool {\n-    match kind {\n-        IDENT | LIFETIME | INT_NUMBER | FLOAT_NUMBER => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "affd7f9c7d4d8ca70c335e64a341d115bb80a422", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261a1836ba02a1c091c5165795dc165ca399a87/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=a261a1836ba02a1c091c5165795dc165ca399a87", "patch": "@@ -25,7 +25,7 @@ impl<'a> SyntaxText<'a> {\n         let range = self.range;\n         preorder(self.node)\n             .filter_map(move |node| {\n-                let text = node.leaf_text_ref()?;\n+                let text = node.leaf_text()?;\n                 let range = intersect(range, node.range())?;\n                 let range = range - node.range().start();\n                 Some(&text[range])"}]}