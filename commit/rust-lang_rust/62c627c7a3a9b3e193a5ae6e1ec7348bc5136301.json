{"sha": "62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "node_id": "C_kwDOAAsO6NoAKDYyYzYyN2M3YTNhOWIzZTE5M2E1YWU2ZTFlYzczNDhiYzUxMzYzMDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T12:44:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T12:44:57Z"}, "message": "Auto merge of #104571 - clubby789:remove-vec-rc-opt, r=the8472\n\nRevert Vec/Rc storage reuse opt\n\nRemove the optimization for using storage added by #104205.\nThe perf wins were pretty small, and it relies on non-guarenteed behaviour. On platforms that don't implement shrinking in place, the performance will be significantly worse.\n\nWhile it could be gated to platforms that do this (such as GNU), I don't think it's worth the overhead of maintaining it for very small gains. (#104565, #104563)\n\ncc `@RalfJung` `@matthiaskrgr`\n\nFixes #104565\nFixes #104563", "tree": {"sha": "607e978504d66bb613ebfcf8a33a7f30551087b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/607e978504d66bb613ebfcf8a33a7f30551087b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "html_url": "https://github.com/rust-lang/rust/commit/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6de2369c82ed0b36e6b651b041bad5cb5e1ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6de2369c82ed0b36e6b651b041bad5cb5e1ef8", "html_url": "https://github.com/rust-lang/rust/commit/5e6de2369c82ed0b36e6b651b041bad5cb5e1ef8"}, {"sha": "27019f10ae18d0a839648d05e422d9b0337908c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/27019f10ae18d0a839648d05e422d9b0337908c2", "html_url": "https://github.com/rust-lang/rust/commit/27019f10ae18d0a839648d05e422d9b0337908c2"}], "stats": {"total": 149, "additions": 12, "deletions": 137}, "files": [{"sha": "5f307069d8076d81778d6db3dadc6e9a3757370c", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "patch": "@@ -1441,48 +1441,6 @@ impl<T> Rc<[T]> {\n         }\n     }\n \n-    /// Create an `Rc<[T]>` by reusing the underlying memory\n-    /// of a `Vec<T>`. This will return the vector if the existing allocation\n-    /// is not large enough.\n-    #[cfg(not(no_global_oom_handling))]\n-    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Rc<[T]>, Vec<T>> {\n-        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n-        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n-        let layout_rcbox = rcbox_layout_for_value_layout(layout_elements);\n-        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n-        if layout_rcbox.size() > layout_allocation.size()\n-            || layout_rcbox.align() > layout_allocation.align()\n-        {\n-            // Can't fit - calling `grow` would involve `realloc`\n-            // (which copies the elements), followed by copying again.\n-            return Err(v);\n-        }\n-        if layout_rcbox.size() < layout_allocation.size()\n-            || layout_rcbox.align() < layout_allocation.align()\n-        {\n-            // We need to shrink the allocation so that it fits\n-            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n-            // SAFETY:\n-            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n-            // - `layout_rcbox` is smaller\n-            // If this fails, the ownership has not been transferred\n-            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_rcbox) } {\n-                ptr = p.cast();\n-            } else {\n-                return Err(v);\n-            }\n-        }\n-        // Make sure the vec's memory isn't deallocated now\n-        let v = mem::ManuallyDrop::new(v);\n-        let ptr: *mut RcBox<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n-        unsafe {\n-            ptr::copy(ptr.cast::<T>(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n-            ptr::write(&mut (*ptr).strong, Cell::new(1));\n-            ptr::write(&mut (*ptr).weak, Cell::new(1));\n-            Ok(Self::from_ptr(ptr))\n-        }\n-    }\n-\n     /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -2008,17 +1966,12 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     /// assert_eq!(vec![1, 2, 3], *shared);\n     /// ```\n     #[inline]\n-    fn from(v: Vec<T>) -> Rc<[T]> {\n-        match Rc::try_from_vec_in_place(v) {\n-            Ok(rc) => rc,\n-            Err(mut v) => {\n-                unsafe {\n-                    let rc = Rc::copy_from_slice(&v);\n-                    // Allow the Vec to free its memory, but not destroy its contents\n-                    v.set_len(0);\n-                    rc\n-                }\n-            }\n+    fn from(mut v: Vec<T>) -> Rc<[T]> {\n+        unsafe {\n+            let rc = Rc::copy_from_slice(&v);\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+            rc\n         }\n     }\n }"}, {"sha": "b69f6b0311234c37b9532d1fc6b128c24045d3cf", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 6, "deletions": 54, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "patch": "@@ -1261,49 +1261,6 @@ impl<T> Arc<[T]> {\n         }\n     }\n \n-    /// Create an `Arc<[T]>` by reusing the underlying memory\n-    /// of a `Vec<T>`. This will return the vector if the existing allocation\n-    /// is not large enough.\n-    #[cfg(not(no_global_oom_handling))]\n-    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Arc<[T]>, Vec<T>> {\n-        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n-        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n-        let layout_arcinner = arcinner_layout_for_value_layout(layout_elements);\n-        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n-        if layout_arcinner.size() > layout_allocation.size()\n-            || layout_arcinner.align() > layout_allocation.align()\n-        {\n-            // Can't fit - calling `grow` would involve `realloc`\n-            // (which copies the elements), followed by copying again.\n-            return Err(v);\n-        }\n-        if layout_arcinner.size() < layout_allocation.size()\n-            || layout_arcinner.align() < layout_allocation.align()\n-        {\n-            // We need to shrink the allocation so that it fits\n-            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n-            // SAFETY:\n-            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n-            // - `layout_arcinner` is smaller\n-            // If this fails, the ownership has not been transferred\n-            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_arcinner) }\n-            {\n-                ptr = p.cast();\n-            } else {\n-                return Err(v);\n-            }\n-        }\n-        // Make sure the vec's memory isn't deallocated now\n-        let v = mem::ManuallyDrop::new(v);\n-        let ptr: *mut ArcInner<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n-        unsafe {\n-            ptr::copy(ptr.cast::<T>(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n-            ptr::write(&mut (*ptr).strong, atomic::AtomicUsize::new(1));\n-            ptr::write(&mut (*ptr).weak, atomic::AtomicUsize::new(1));\n-            Ok(Self::from_ptr(ptr))\n-        }\n-    }\n-\n     /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -2615,17 +2572,12 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     /// assert_eq!(&[1, 2, 3], &shared[..]);\n     /// ```\n     #[inline]\n-    fn from(v: Vec<T>) -> Arc<[T]> {\n-        match Arc::try_from_vec_in_place(v) {\n-            Ok(rc) => rc,\n-            Err(mut v) => {\n-                unsafe {\n-                    let rc = Arc::copy_from_slice(&v);\n-                    // Allow the Vec to free its memory, but not destroy its contents\n-                    v.set_len(0);\n-                    rc\n-                }\n-            }\n+    fn from(mut v: Vec<T>) -> Arc<[T]> {\n+        unsafe {\n+            let rc = Arc::copy_from_slice(&v);\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+            rc\n         }\n     }\n }"}, {"sha": "ce40b5c9b0a0d3a5948635c131dc1b353adbbcfb", "filename": "library/alloc/tests/arc.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Farc.rs?ref=62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "patch": "@@ -210,18 +210,3 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::sync::Weak`\n }\n-\n-#[test]\n-fn arc_from_vec_opt() {\n-    let mut v = Vec::with_capacity(64);\n-    v.push(0usize);\n-    let addr = v.as_ptr().cast::<u8>();\n-    let arc: Arc<[_]> = v.into();\n-    unsafe {\n-        assert_eq!(\n-            arc.as_ptr().cast::<u8>().offset_from(addr),\n-            (std::mem::size_of::<usize>() * 2) as isize,\n-            \"Vector allocation not reused\"\n-        );\n-    }\n-}"}, {"sha": "efb39a609665b33ad2e6b9b43a75533a98f1feb5", "filename": "library/alloc/tests/rc.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301/library%2Falloc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Frc.rs?ref=62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "patch": "@@ -206,18 +206,3 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::rc::Weak`\n }\n-\n-#[test]\n-fn rc_from_vec_opt() {\n-    let mut v = Vec::with_capacity(64);\n-    v.push(0usize);\n-    let addr = v.as_ptr().cast::<u8>();\n-    let rc: Rc<[_]> = v.into();\n-    unsafe {\n-        assert_eq!(\n-            rc.as_ptr().cast::<u8>().offset_from(addr),\n-            (std::mem::size_of::<usize>() * 2) as isize,\n-            \"Vector allocation not reused\"\n-        );\n-    }\n-}"}]}