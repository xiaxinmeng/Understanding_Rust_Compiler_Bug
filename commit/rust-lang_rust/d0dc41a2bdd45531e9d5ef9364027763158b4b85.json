{"sha": "d0dc41a2bdd45531e9d5ef9364027763158b4b85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZGM0MWEyYmRkNDU1MzFlOWQ1ZWY5MzY0MDI3NzYzMTU4YjRiODU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-01T09:20:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-01T09:20:54Z"}, "message": "Address review comments", "tree": {"sha": "53966020b93a5de7397b617d79ef53955fba2910", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53966020b93a5de7397b617d79ef53955fba2910"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0dc41a2bdd45531e9d5ef9364027763158b4b85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0dc41a2bdd45531e9d5ef9364027763158b4b85", "html_url": "https://github.com/rust-lang/rust/commit/d0dc41a2bdd45531e9d5ef9364027763158b4b85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0dc41a2bdd45531e9d5ef9364027763158b4b85/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f39dc1b9095bf3808e45a8ff9afc6b9a4d8e9a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f39dc1b9095bf3808e45a8ff9afc6b9a4d8e9a3", "html_url": "https://github.com/rust-lang/rust/commit/3f39dc1b9095bf3808e45a8ff9afc6b9a4d8e9a3"}], "stats": {"total": 93, "additions": 45, "deletions": 48}, "files": [{"sha": "01b642fc96f7e52d71accfd8f053d64034dedf7a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc41a2bdd45531e9d5ef9364027763158b4b85/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc41a2bdd45531e9d5ef9364027763158b4b85/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d0dc41a2bdd45531e9d5ef9364027763158b4b85", "patch": "@@ -4324,52 +4324,49 @@ impl<'a> Parser<'a> {\n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n                      -> PResult<'a, Option<P<Item>>> {\n         let token_lo = self.token.span;\n-        let (ident, def) = match self.token.kind {\n-            token::Ident(name, false) if name == kw::Macro => {\n-                self.bump();\n-                let ident = self.parse_ident()?;\n-                let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n-                    match self.parse_token_tree() {\n-                        TokenTree::Delimited(_, _, tts) => tts,\n-                        _ => unreachable!(),\n-                    }\n-                } else if self.check(&token::OpenDelim(token::Paren)) {\n-                    let args = self.parse_token_tree();\n-                    let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                        self.parse_token_tree()\n-                    } else {\n-                        self.unexpected()?;\n-                        unreachable!()\n-                    };\n-                    TokenStream::new(vec![\n-                        args.into(),\n-                        TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n-                        body.into(),\n-                    ])\n+        let (ident, def) = if self.eat_keyword(kw::Macro) {\n+            let ident = self.parse_ident()?;\n+            let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n+                match self.parse_token_tree() {\n+                    TokenTree::Delimited(_, _, tts) => tts,\n+                    _ => unreachable!(),\n+                }\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n+                let args = self.parse_token_tree();\n+                let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_token_tree()\n                 } else {\n                     self.unexpected()?;\n                     unreachable!()\n                 };\n+                TokenStream::new(vec![\n+                    args.into(),\n+                    TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n+                    body.into(),\n+                ])\n+            } else {\n+                self.unexpected()?;\n+                unreachable!()\n+            };\n \n-                (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n-            }\n-            token::Ident(name, false) if name == sym::macro_rules &&\n-                                         self.look_ahead(1, |t| *t == token::Not) &&\n-                                         self.look_ahead(2, |t| t.is_ident()) => {\n-                let prev_span = self.prev_span;\n-                self.complain_if_pub_macro(&vis.node, prev_span);\n-                self.bump();\n-                self.bump();\n-\n-                let ident = self.parse_ident()?;\n-                let (delim, tokens) = self.expect_delimited_token_tree()?;\n-                if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n-                    self.report_invalid_macro_expansion_item();\n-                }\n+            (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+        } else if self.check_keyword(sym::macro_rules) &&\n+                  self.look_ahead(1, |t| *t == token::Not) &&\n+                  self.look_ahead(2, |t| t.is_ident()) {\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&vis.node, prev_span);\n+            self.bump();\n+            self.bump();\n \n-                (ident, ast::MacroDef { tokens, legacy: true })\n+            let ident = self.parse_ident()?;\n+            let (delim, tokens) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n             }\n-            _ => return Ok(None),\n+\n+            (ident, ast::MacroDef { tokens, legacy: true })\n+        } else {\n+            return Ok(None);\n         };\n \n         let span = lo.to(self.prev_span);\n@@ -4413,14 +4410,14 @@ impl<'a> Parser<'a> {\n                   !self.is_existential_type_decl() &&\n                   !self.is_auto_trait_item() &&\n                   !self.is_async_fn() {\n-            let pth = self.parse_path(PathStyle::Expr)?;\n+            let path = self.parse_path(PathStyle::Expr)?;\n \n             if !self.eat(&token::Not) {\n                 let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_struct_expr(lo, pth, ThinVec::new())?\n+                    self.parse_struct_expr(lo, path, ThinVec::new())?\n                 } else {\n                     let hi = self.prev_span;\n-                    self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n+                    self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new())\n                 };\n \n                 let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n@@ -4444,7 +4441,7 @@ impl<'a> Parser<'a> {\n                 MacStmtStyle::NoBraces\n             };\n \n-            let mac = respan(lo.to(hi), Mac_ { path: pth, tts, delim });\n+            let mac = respan(lo.to(hi), Mac_ { path, tts, delim });\n             let node = if delim == MacDelimiter::Brace ||\n                           self.token == token::Semi || self.token == token::Eof {\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n@@ -7561,15 +7558,15 @@ impl<'a> Parser<'a> {\n             let mac_lo = self.token.span;\n \n             // item macro.\n-            let pth = self.parse_path(PathStyle::Mod)?;\n+            let path = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n             if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n                 self.report_invalid_macro_expansion_item();\n             }\n \n             let hi = self.prev_span;\n-            let mac = respan(mac_lo.to(hi), Mac_ { path: pth, tts, delim });\n+            let mac = respan(mac_lo.to(hi), Mac_ { path, tts, delim });\n             let item =\n                 self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n@@ -7597,9 +7594,9 @@ impl<'a> Parser<'a> {\n                 !(self.is_async_fn() && self.token.span.rust_2015()) {\n             let prev_span = self.prev_span;\n             let lo = self.token.span;\n-            let pth = self.parse_path(PathStyle::Mod)?;\n+            let path = self.parse_path(PathStyle::Mod)?;\n \n-            if pth.segments.len() == 1 {\n+            if path.segments.len() == 1 {\n                 if !self.eat(&token::Not) {\n                     return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n                 }\n@@ -7619,7 +7616,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?;\n             }\n \n-            Ok(Some(respan(lo.to(self.prev_span), Mac_ { path: pth, tts, delim })))\n+            Ok(Some(respan(lo.to(self.prev_span), Mac_ { path, tts, delim })))\n         } else {\n             Ok(None)\n         }"}]}