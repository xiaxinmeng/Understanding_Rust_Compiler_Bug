{"sha": "8d2fd59cfb00211573419b0a59cf91d92d636f5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMmZkNTljZmIwMDIxMTU3MzQxOWIwYTU5Y2Y5MWQ5MmQ2MzZmNWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-25T08:19:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-25T08:30:46Z"}, "message": "make typing infra slightly more extensible", "tree": {"sha": "feafe88a932c70aa9e25a6b87323094e2b40b750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/feafe88a932c70aa9e25a6b87323094e2b40b750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d2fd59cfb00211573419b0a59cf91d92d636f5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2fd59cfb00211573419b0a59cf91d92d636f5a", "html_url": "https://github.com/rust-lang/rust/commit/8d2fd59cfb00211573419b0a59cf91d92d636f5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d2fd59cfb00211573419b0a59cf91d92d636f5a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "518f99e16b993e3414a81181c8bad7a89e590ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/518f99e16b993e3414a81181c8bad7a89e590ece", "html_url": "https://github.com/rust-lang/rust/commit/518f99e16b993e3414a81181c8bad7a89e590ece"}], "stats": {"total": 128, "additions": 74, "deletions": 54}, "files": [{"sha": "b2a1d185b6c7f0cc042dcf9c8ad9a99bee2e72e7", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8d2fd59cfb00211573419b0a59cf91d92d636f5a/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2fd59cfb00211573419b0a59cf91d92d636f5a/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=8d2fd59cfb00211573419b0a59cf91d92d636f5a", "patch": "@@ -407,24 +407,16 @@ impl Analysis {\n         self.with_db(|db| typing::on_enter(&db, position))\n     }\n \n-    /// Returns an edit which should be applied after `=` was typed. Primarily,\n-    /// this works when adding `let =`.\n-    // FIXME: use a snippet completion instead of this hack here.\n-    pub fn on_eq_typed(&self, position: FilePosition) -> Cancelable<Option<SourceChange>> {\n-        self.with_db(|db| {\n-            let parse = db.parse(position.file_id);\n-            let file = parse.tree();\n-            let edit = typing::on_eq_typed(&file, position.offset)?;\n-            Some(SourceChange::source_file_edit(\n-                \"add semicolon\",\n-                SourceFileEdit { edit, file_id: position.file_id },\n-            ))\n-        })\n-    }\n-\n-    /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n-    pub fn on_dot_typed(&self, position: FilePosition) -> Cancelable<Option<SourceChange>> {\n-        self.with_db(|db| typing::on_dot_typed(&db, position))\n+    /// Returns an edit which should be applied after a character was typed.\n+    ///\n+    /// This is useful for some on-the-fly fixups, like adding `;` to `let =`\n+    /// automatically.\n+    pub fn on_char_typed(\n+        &self,\n+        position: FilePosition,\n+        char_typed: char,\n+    ) -> Cancelable<Option<SourceChange>> {\n+        self.with_db(|db| typing::on_char_typed(&db, position, char_typed))\n     }\n \n     /// Returns a tree representation of symbols in the file. Useful to draw a"}, {"sha": "44cc461471bf631283881344a0e929a9a10e516d", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8d2fd59cfb00211573419b0a59cf91d92d636f5a/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2fd59cfb00211573419b0a59cf91d92d636f5a/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=8d2fd59cfb00211573419b0a59cf91d92d636f5a", "patch": "@@ -1,4 +1,17 @@\n-//! FIXME: write short doc here\n+//! This module handles auto-magic editing actions applied together with users\n+//! edits. For example, if the user typed\n+//!\n+//! ```text\n+//!     foo\n+//!         .bar()\n+//!         .baz()\n+//!     |   // <- cursor is here\n+//! ```\n+//!\n+//! and types `.` next, we want to indent the dot.\n+//!\n+//! Language server executes such typing assists synchronously. That is, they\n+//! block user's typing and should be pretty fast for this reason!\n \n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n@@ -68,18 +81,50 @@ fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n     Some(text[pos..].into())\n }\n \n-pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<TextEdit> {\n-    assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n-    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n+pub(crate) fn on_char_typed(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    char_typed: char,\n+) -> Option<SourceChange> {\n+    let file = &db.parse(position.file_id).tree();\n+    assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n+    match char_typed {\n+        '=' => {\n+            let edit = on_eq_typed(file, position.offset)?;\n+            Some(SourceChange::source_file_edit(\n+                \"add semicolon\",\n+                SourceFileEdit { edit, file_id: position.file_id },\n+            ))\n+        }\n+        '.' => {\n+            let (edit, cursor_offset) = on_dot_typed(file, position.offset)?;\n+            Some(\n+                SourceChange::source_file_edit(\n+                    \"reindent dot\",\n+                    SourceFileEdit { edit, file_id: position.file_id },\n+                )\n+                .with_cursor(FilePosition { file_id: position.file_id, offset: cursor_offset }),\n+            )\n+        }\n+        _ => None,\n+    }\n+}\n+\n+/// Returns an edit which should be applied after `=` was typed. Primarily,\n+/// this works when adding `let =`.\n+// FIXME: use a snippet completion instead of this hack here.\n+fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<TextEdit> {\n+    assert_eq!(file.syntax().text().char_at(offset), Some('='));\n+    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n     if let Some(expr) = let_stmt.initializer() {\n         let expr_range = expr.syntax().text_range();\n-        if expr_range.contains(eq_offset) && eq_offset != expr_range.start() {\n+        if expr_range.contains(offset) && offset != expr_range.start() {\n             return None;\n         }\n-        if file.syntax().text().slice(eq_offset..expr_range.start()).contains_char('\\n') {\n+        if file.syntax().text().slice(offset..expr_range.start()).contains_char('\\n') {\n             return None;\n         }\n     } else {\n@@ -91,16 +136,11 @@ pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<TextEdit> {\n     Some(edit.finish())\n }\n \n-pub(crate) fn on_dot_typed(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n-    let parse = db.parse(position.file_id);\n-    assert_eq!(parse.tree().syntax().text().char_at(position.offset), Some('.'));\n-\n-    let whitespace = parse\n-        .tree()\n-        .syntax()\n-        .token_at_offset(position.offset)\n-        .left_biased()\n-        .and_then(ast::Whitespace::cast)?;\n+/// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n+fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<(TextEdit, TextUnit)> {\n+    assert_eq!(file.syntax().text().char_at(offset), Some('.'));\n+    let whitespace =\n+        file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;\n \n     let current_indent = {\n         let text = whitespace.text();\n@@ -118,19 +158,11 @@ pub(crate) fn on_dot_typed(db: &RootDatabase, position: FilePosition) -> Option<\n         return None;\n     }\n     let mut edit = TextEditBuilder::default();\n-    edit.replace(\n-        TextRange::from_to(position.offset - current_indent_len, position.offset),\n-        target_indent,\n-    );\n+    edit.replace(TextRange::from_to(offset - current_indent_len, offset), target_indent);\n \n-    let res = SourceChange::source_file_edit_from(\"reindent dot\", position.file_id, edit.finish())\n-        .with_cursor(FilePosition {\n-            offset: position.offset + target_indent_len - current_indent_len\n-                + TextUnit::of_char('.'),\n-            file_id: position.file_id,\n-        });\n+    let cursor_offset = offset + target_indent_len - current_indent_len + TextUnit::of_char('.');\n \n-    Some(res)\n+    Some((edit.finish(), cursor_offset))\n }\n \n #[cfg(test)]\n@@ -197,9 +229,9 @@ fn foo() {\n         edit.insert(offset, \".\".to_string());\n         let before = edit.finish().apply(&before);\n         let (analysis, file_id) = single_file(&before);\n-        if let Some(result) = analysis.on_dot_typed(FilePosition { offset, file_id }).unwrap() {\n-            assert_eq!(result.source_file_edits.len(), 1);\n-            let actual = result.source_file_edits[0].edit.apply(&before);\n+        let file = analysis.parse(file_id).unwrap();\n+        if let Some((edit, _cursor_offset)) = on_dot_typed(&file, offset) {\n+            let actual = edit.apply(&before);\n             assert_eq_text!(after, &actual);\n         } else {\n             assert_eq_text!(&before, after)"}, {"sha": "530c4d8b60869d34c522742eed18c349bdb6eb66", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2fd59cfb00211573419b0a59cf91d92d636f5a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2fd59cfb00211573419b0a59cf91d92d636f5a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=8d2fd59cfb00211573419b0a59cf91d92d636f5a", "patch": "@@ -144,12 +144,8 @@ pub fn handle_on_type_formatting(\n     // in `ra_ide_api`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset = position.offset - TextUnit::of_char('.');\n-\n-    let edit = match params.ch.as_str() {\n-        \"=\" => world.analysis().on_eq_typed(position),\n-        \".\" => world.analysis().on_dot_typed(position),\n-        _ => return Ok(None),\n-    }?;\n+    let char_typed = params.ch.chars().next().unwrap_or('\\0');\n+    let edit = world.analysis().on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),"}]}