{"sha": "71d3dac4a86d192c2c80948621859da3b363fa50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZDNkYWM0YTg2ZDE5MmMyYzgwOTQ4NjIxODU5ZGEzYjM2M2ZhNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T12:24:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T12:24:17Z"}, "message": "Auto merge of #50097 - glandium:box_free, r=nikomatsakis\n\nPartial future-proofing for Box<T, A>\n\nIn some ways, this is similar to @eddyb's PR #47043 that went stale, but doesn't cover everything. Notably, this still leaves Box internalized as a pointer in places, so practically speaking, only ZSTs can be practically added to the Box type with the changes here (the compiler ICEs otherwise).\n\nThe Box type is not changed here, that's left for the future because I want to test that further first, but this puts things in place in a way that hopefully will make things easier.", "tree": {"sha": "4dd89c80c24cfe5f9aa0e1de1e46ed295be22e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dd89c80c24cfe5f9aa0e1de1e46ed295be22e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71d3dac4a86d192c2c80948621859da3b363fa50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71d3dac4a86d192c2c80948621859da3b363fa50", "html_url": "https://github.com/rust-lang/rust/commit/71d3dac4a86d192c2c80948621859da3b363fa50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71d3dac4a86d192c2c80948621859da3b363fa50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ada45fd49a2dfcf2a163e1f4641ac34f2803eb9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada45fd49a2dfcf2a163e1f4641ac34f2803eb9b", "html_url": "https://github.com/rust-lang/rust/commit/ada45fd49a2dfcf2a163e1f4641ac34f2803eb9b"}, {"sha": "bd8c177d49c95d94f163e9bb3c3397f38ab72640", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8c177d49c95d94f163e9bb3c3397f38ab72640", "html_url": "https://github.com/rust-lang/rust/commit/bd8c177d49c95d94f163e9bb3c3397f38ab72640"}], "stats": {"total": 205, "additions": 51, "deletions": 154}, "files": [{"sha": "f59c9f7fd61cb586dc472b9938949aa761819884", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=71d3dac4a86d192c2c80948621859da3b363fa50", "patch": "@@ -16,7 +16,7 @@\n             issue = \"32838\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n-use core::ptr::NonNull;\n+use core::ptr::{NonNull, Unique};\n use core::usize;\n \n #[doc(inline)]\n@@ -152,9 +152,17 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n-#[cfg_attr(not(test), lang = \"box_free\")]\n+#[cfg(stage0)]\n+#[lang = \"box_free\"]\n+#[inline]\n+unsafe fn old_box_free<T: ?Sized>(ptr: *mut T) {\n+    box_free(Unique::new_unchecked(ptr))\n+}\n+\n+#[cfg_attr(not(any(test, stage0)), lang = \"box_free\")]\n #[inline]\n-pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n+    let ptr = ptr.as_ptr();\n     let size = size_of_val(&*ptr);\n     let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary."}, {"sha": "d0950bff9ce8092a38b5c53616f86c0dfaad83bc", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=71d3dac4a86d192c2c80948621859da3b363fa50", "patch": "@@ -566,7 +566,8 @@ impl<T: ?Sized> Arc<T> {\n \n     fn from_box(v: Box<T>) -> Arc<T> {\n         unsafe {\n-            let bptr = Box::into_raw(v);\n+            let box_unique = Box::into_unique(v);\n+            let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n             let ptr = Self::allocate_for_ptr(bptr);\n@@ -578,7 +579,7 @@ impl<T: ?Sized> Arc<T> {\n                 value_size);\n \n             // Free the allocation without dropping its contents\n-            box_free(bptr);\n+            box_free(box_unique);\n \n             Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }"}, {"sha": "d0188c6e8285800193380dfd6a138e9c3535dead", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=71d3dac4a86d192c2c80948621859da3b363fa50", "patch": "@@ -681,7 +681,8 @@ impl<T: ?Sized> Rc<T> {\n \n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n-            let bptr = Box::into_raw(v);\n+            let box_unique = Box::into_unique(v);\n+            let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n             let ptr = Self::allocate_for_ptr(bptr);\n@@ -693,7 +694,7 @@ impl<T: ?Sized> Rc<T> {\n                 value_size);\n \n             // Free the allocation without dropping its contents\n-            box_free(bptr);\n+            box_free(box_unique);\n \n             Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }"}, {"sha": "c28fcfe88059f2dfcc03d55b08f855be12dfeac5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=71d3dac4a86d192c2c80948621859da3b363fa50", "patch": "@@ -34,7 +34,7 @@ use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret};\n use mir::interpret::{Value, PrimVal};\n-use ty::subst::{Kind, Substs};\n+use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n use ty::Instance;\n use traits;\n@@ -2328,7 +2328,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n         let adt_def = self.adt_def(def_id);\n-        let substs = self.mk_substs(iter::once(Kind::from(ty)));\n+        let generics = self.generics_of(def_id);\n+        let mut substs = vec![Kind::from(ty)];\n+        // Add defaults for other generic params if there are some.\n+        for def in generics.types.iter().skip(1) {\n+            assert!(def.has_default);\n+            let ty = self.type_of(def.def_id).subst(self, &substs);\n+            substs.push(ty.into());\n+        }\n+        let substs = self.mk_substs(substs.into_iter());\n         self.mk_ty(TyAdt(adt_def, substs))\n     }\n "}, {"sha": "0ed95a319f7de0fb0fae8cb5ae60267cb3fb3fcc", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=71d3dac4a86d192c2c80948621859da3b363fa50", "patch": "@@ -918,11 +918,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     ));\n                 }\n \n-                if self.is_box_free(func) {\n-                    self.check_box_free_inputs(mir, term, &sig, args, term_location);\n-                } else {\n-                    self.check_call_inputs(mir, term, &sig, args, term_location);\n-                }\n+                self.check_call_inputs(mir, term, &sig, args, term_location);\n             }\n             TerminatorKind::Assert {\n                 ref cond, ref msg, ..\n@@ -1026,70 +1022,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn is_box_free(&self, operand: &Operand<'tcx>) -> bool {\n-        match *operand {\n-            Operand::Constant(ref c) => match c.ty.sty {\n-                ty::TyFnDef(ty_def_id, _) => {\n-                    Some(ty_def_id) == self.tcx().lang_items().box_free_fn()\n-                }\n-                _ => false,\n-            },\n-            _ => false,\n-        }\n-    }\n-\n-    fn check_box_free_inputs(\n-        &mut self,\n-        mir: &Mir<'tcx>,\n-        term: &Terminator<'tcx>,\n-        sig: &ty::FnSig<'tcx>,\n-        args: &[Operand<'tcx>],\n-        term_location: Location,\n-    ) {\n-        debug!(\"check_box_free_inputs\");\n-\n-        // box_free takes a Box as a pointer. Allow for that.\n-\n-        if sig.inputs().len() != 1 {\n-            span_mirbug!(self, term, \"box_free should take 1 argument\");\n-            return;\n-        }\n-\n-        let pointee_ty = match sig.inputs()[0].sty {\n-            ty::TyRawPtr(mt) => mt.ty,\n-            _ => {\n-                span_mirbug!(self, term, \"box_free should take a raw ptr\");\n-                return;\n-            }\n-        };\n-\n-        if args.len() != 1 {\n-            span_mirbug!(self, term, \"box_free called with wrong # of args\");\n-            return;\n-        }\n-\n-        let ty = args[0].ty(mir, self.tcx());\n-        let arg_ty = match ty.sty {\n-            ty::TyRawPtr(mt) => mt.ty,\n-            ty::TyAdt(def, _) if def.is_box() => ty.boxed_ty(),\n-            _ => {\n-                span_mirbug!(self, term, \"box_free called with bad arg ty\");\n-                return;\n-            }\n-        };\n-\n-        if let Err(terr) = self.sub_types(arg_ty, pointee_ty, term_location.at_self()) {\n-            span_mirbug!(\n-                self,\n-                term,\n-                \"bad box_free arg ({:?} <- {:?}): {:?}\",\n-                pointee_ty,\n-                arg_ty,\n-                terr\n-            );\n-        }\n-    }\n-\n     fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block_data: &BasicBlockData<'tcx>) {\n         let is_cleanup = block_data.is_cleanup;\n         self.last_span = block_data.terminator().source_info.span;"}, {"sha": "b743cccd36c5ab3985e13094a00139ba648b5712", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 63, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=71d3dac4a86d192c2c80948621859da3b363fa50", "patch": "@@ -379,8 +379,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let is_box_free = Some(callsite.callee) == self.tcx.lang_items().box_free_fn();\n-\n                 let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_mir.visibility_scopes.len());\n                 let mut promoted_map = IndexVec::with_capacity(callee_mir.promoted.len());\n@@ -460,24 +458,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 let return_block = destination.1;\n \n-                let args : Vec<_> = if is_box_free {\n-                    assert!(args.len() == 1);\n-                    // box_free takes a Box, but is defined with a *mut T, inlining\n-                    // needs to generate the cast.\n-                    // FIXME: we should probably just generate correct MIR in the first place...\n-\n-                    let arg = if let Operand::Move(ref place) = args[0] {\n-                        place.clone()\n-                    } else {\n-                        bug!(\"Constant arg to \\\"box_free\\\"\");\n-                    };\n-\n-                    let ptr_ty = args[0].ty(caller_mir, self.tcx);\n-                    vec![self.cast_box_free_arg(arg, ptr_ty, &callsite, caller_mir)]\n-                } else {\n-                    // Copy the arguments if needed.\n-                    self.make_call_args(args, &callsite, caller_mir)\n-                };\n+                // Copy the arguments if needed.\n+                let args: Vec<_> = self.make_call_args(args, &callsite, caller_mir);\n \n                 let bb_len = caller_mir.basic_blocks().len();\n                 let mut integrator = Integrator {\n@@ -518,49 +500,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n-    fn cast_box_free_arg(&self, arg: Place<'tcx>, ptr_ty: Ty<'tcx>,\n-                         callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Local {\n-        let arg = Rvalue::Ref(\n-            self.tcx.types.re_erased,\n-            BorrowKind::Mut { allow_two_phase_borrow: false },\n-            arg.deref());\n-\n-        let ty = arg.ty(caller_mir, self.tcx);\n-        let ref_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n-        let ref_tmp = caller_mir.local_decls.push(ref_tmp);\n-        let ref_tmp = Place::Local(ref_tmp);\n-\n-        let ref_stmt = Statement {\n-            source_info: callsite.location,\n-            kind: StatementKind::Assign(ref_tmp.clone(), arg)\n-        };\n-\n-        caller_mir[callsite.bb]\n-            .statements.push(ref_stmt);\n-\n-        let pointee_ty = match ptr_ty.sty {\n-            ty::TyRawPtr(tm) | ty::TyRef(_, tm) => tm.ty,\n-            _ if ptr_ty.is_box() => ptr_ty.boxed_ty(),\n-            _ => bug!(\"Invalid type `{:?}` for call to box_free\", ptr_ty)\n-        };\n-        let ptr_ty = self.tcx.mk_mut_ptr(pointee_ty);\n-\n-        let raw_ptr = Rvalue::Cast(CastKind::Misc, Operand::Move(ref_tmp), ptr_ty);\n-\n-        let cast_tmp = LocalDecl::new_temp(ptr_ty, callsite.location.span);\n-        let cast_tmp = caller_mir.local_decls.push(cast_tmp);\n-\n-        let cast_stmt = Statement {\n-            source_info: callsite.location,\n-            kind: StatementKind::Assign(Place::Local(cast_tmp), raw_ptr)\n-        };\n-\n-        caller_mir[callsite.bb]\n-            .statements.push(cast_stmt);\n-\n-        cast_tmp\n-    }\n-\n     fn make_call_args(\n         &self,\n         args: Vec<Operand<'tcx>>,"}, {"sha": "4b7c581d3c8ff3404a640f3c2c8ea2d40b0cf81f", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3dac4a86d192c2c80948621859da3b363fa50/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=71d3dac4a86d192c2c80948621859da3b363fa50", "patch": "@@ -339,18 +339,19 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.drop_ladder(fields, succ, unwind).0\n     }\n \n-    fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n+    fn open_drop_for_box<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n+                             -> BasicBlock\n     {\n-        debug!(\"open_drop_for_box({:?}, {:?})\", self, ty);\n+        debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n         let interior = self.place.clone().deref();\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#43234)\n         let unwind = self.unwind;\n-        let succ = self.box_free_block(ty, succ, unwind);\n+        let succ = self.box_free_block(adt, substs, succ, unwind);\n         let unwind_succ = self.unwind.map(|unwind| {\n-            self.box_free_block(ty, unwind, Unwind::InCleanup)\n+            self.box_free_block(adt, substs, unwind, Unwind::InCleanup)\n         });\n \n         self.drop_subpath(&interior, interior_path, succ, unwind_succ)\n@@ -793,11 +794,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty::TyTuple(tys) => {\n                 self.open_drop_for_tuple(tys)\n             }\n-            ty::TyAdt(def, _) if def.is_box() => {\n-                self.open_drop_for_box(ty.boxed_ty())\n-            }\n             ty::TyAdt(def, substs) => {\n-                self.open_drop_for_adt(def, substs)\n+                if def.is_box() {\n+                    self.open_drop_for_box(def, substs)\n+                } else {\n+                    self.open_drop_for_adt(def, substs)\n+                }\n             }\n             ty::TyDynamic(..) => {\n                 let unwind = self.unwind; // FIXME(#43234)\n@@ -860,28 +862,34 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n     fn box_free_block<'a>(\n         &mut self,\n-        ty: Ty<'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind,\n     ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(ty, target, unwind);\n+        let block = self.unelaborated_free_block(adt, substs, target, unwind);\n         self.drop_flag_test_block(block, target, unwind)\n     }\n \n     fn unelaborated_free_block<'a>(\n         &mut self,\n-        ty: Ty<'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n+        let args = adt.variants[0].fields.iter().enumerate().map(|(i, f)| {\n+            let field = Field::new(i);\n+            let field_ty = f.ty(self.tcx(), substs);\n+            Operand::Move(self.place.clone().field(field, field_ty))\n+        }).collect();\n \n         let call = TerminatorKind::Call {\n             func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-            args: vec![Operand::Move(self.place.clone())],\n+            args: args,\n             destination: Some((unit_temp, target)),\n             cleanup: None\n         }; // FIXME(#43234)"}]}