{"sha": "2fd46b54fb7e211fed34cff4833efdc4a7ab5752", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZDQ2YjU0ZmI3ZTIxMWZlZDM0Y2ZmNDgzM2VmZGM0YTdhYjU3NTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T23:15:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T19:04:59Z"}, "message": "rustc: Make type parameter substitutions interior vectors", "tree": {"sha": "038ff6e0e970229f27be2966cb7f0cbe2ab9fbbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038ff6e0e970229f27be2966cb7f0cbe2ab9fbbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fd46b54fb7e211fed34cff4833efdc4a7ab5752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fd46b54fb7e211fed34cff4833efdc4a7ab5752", "html_url": "https://github.com/rust-lang/rust/commit/2fd46b54fb7e211fed34cff4833efdc4a7ab5752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fd46b54fb7e211fed34cff4833efdc4a7ab5752/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb2018c6db7dea9c3ff5e477c017a2677c0e15a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb2018c6db7dea9c3ff5e477c017a2677c0e15a7", "html_url": "https://github.com/rust-lang/rust/commit/cb2018c6db7dea9c3ff5e477c017a2677c0e15a7"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "93a8d775e1d110cd5305cfcdf89171121bd31a69", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fd46b54fb7e211fed34cff4833efdc4a7ab5752/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd46b54fb7e211fed34cff4833efdc4a7ab5752/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2fd46b54fb7e211fed34cff4833efdc4a7ab5752", "patch": "@@ -4891,7 +4891,7 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n     auto tys = ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, id);\n-    if (vec::len[ty::t](tys) != 0u) {\n+    if (std::ivec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = [];\n         let vec[option::t[@tydesc_info]] tis = [];"}, {"sha": "3d60eba98af14cd2e079930a44a36820e97ffc25", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fd46b54fb7e211fed34cff4833efdc4a7ab5752/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd46b54fb7e211fed34cff4833efdc4a7ab5752/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2fd46b54fb7e211fed34cff4833efdc4a7ab5752", "patch": "@@ -351,7 +351,7 @@ const uint idx_first_others = 21u;\n \n type type_store = interner::interner[raw_t];\n \n-type ty_param_substs_opt_and_ty = tup(option::t[vec[ty::t]], ty::t);\n+type ty_param_substs_opt_and_ty = tup(option::t[ty::t[]], ty::t);\n \n type node_type_table =\n     @smallintmap::smallintmap[ty::ty_param_substs_opt_and_ty];\n@@ -1748,16 +1748,16 @@ fn node_id_to_type(&ctxt cx, &ast::node_id id) -> t {\n     ret node_id_to_ty_param_substs_opt_and_ty(cx, id)._1;\n }\n \n-fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> vec[t] {\n+fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> t[] {\n     alt (node_id_to_ty_param_substs_opt_and_ty(cx, id)._0) {\n-        case (none) { let vec[t] result = []; ret result; }\n+        case (none)       { ret ~[]; }\n         case (some(?tps)) { ret tps; }\n     }\n }\n \n fn node_id_has_type_params(&ctxt cx, &ast::node_id id) -> bool {\n     auto tpt = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n-    ret !option::is_none[vec[t]](tpt._0);\n+    ret !option::is_none[t[]](tpt._0);\n }\n \n \n@@ -1883,7 +1883,7 @@ fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n     ret node_id_to_monotype(cx, expr.id);\n }\n \n-fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(vec[t], t) {\n+fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(t[], t) {\n     ret tup(node_id_to_type_params(cx, expr.id),\n             node_id_to_type(cx, expr.id));\n }"}, {"sha": "b54fcf4c111f9a75d0e02b2892f9e49678946e6b", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2fd46b54fb7e211fed34cff4833efdc4a7ab5752/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd46b54fb7e211fed34cff4833efdc4a7ab5752/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2fd46b54fb7e211fed34cff4833efdc4a7ab5752", "patch": "@@ -159,7 +159,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n     auto ty_substs_opt;\n     auto ty_substs_len = vec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n-        let vec[ty::t] ty_substs = [];\n+        let ty::t[] ty_substs = ~[];\n         auto i = 0u;\n         while (i < ty_substs_len) {\n             // TODO: Report an error if the number of type params in the item\n@@ -168,10 +168,10 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n             auto ty_var = ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i));\n             auto ty_subst = ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i));\n             auto res_ty = demand::simple(fcx, pth.span, ty_var, ty_subst);\n-            ty_substs += [res_ty];\n+            ty_substs += ~[res_ty];\n             i += 1u;\n         }\n-        ty_substs_opt = some[vec[ty::t]](ty_substs);\n+        ty_substs_opt = some[ty::t[]](ty_substs);\n         if (ty_param_count == 0u) {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                       \"this item does not take type \" +\n@@ -181,13 +181,13 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n     } else {\n         // We will acquire the type parameters through unification.\n \n-        let vec[ty::t] ty_substs = [];\n+        let ty::t[] ty_substs = ~[];\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            ty_substs += [ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n+            ty_substs += ~[ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n             i += 1u;\n         }\n-        ty_substs_opt = some[vec[ty::t]](ty_substs);\n+        ty_substs_opt = some[ty::t[]](ty_substs);\n     }\n     ret tup(ty_substs_opt, tpt._1);\n }\n@@ -437,23 +437,23 @@ mod write {\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(&ty::ctxt tcx, ast::node_id node_id, ty::t typ) {\n-        ret ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty(tcx, node_id, tup(none[ty::t[]], typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(@fn_ctxt fcx, ast::node_id node_id, ty::t typ) {\n-        ret ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty_fixup(fcx, node_id, tup(none[ty::t[]], typ));\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n+        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_bot(tcx)));\n     }\n }\n \n@@ -914,24 +914,22 @@ fn resolve_type_vars_if_possible(&@fn_ctxt fcx, ty::t typ) -> ty::t {\n \n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n-type ty_param_substs_and_ty = tup(vec[ty::t], ty::t);\n+type ty_param_substs_and_ty = tup(ty::t[], ty::t);\n \n mod demand {\n     fn simple(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual) ->\n        ty::t {\n-        let vec[ty::t] tps = [];\n-        ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n+        ret full(fcx, sp, expected, actual, ~[], NO_AUTODEREF)._1;\n     }\n     fn autoderef(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n                  autoderef_kind adk) -> ty::t {\n-        let vec[ty::t] tps = [];\n-        ret full(fcx, sp, expected, actual, tps, adk)._1;\n+        ret full(fcx, sp, expected, actual, ~[], adk)._1;\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n     fn full(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n-            &vec[ty::t] ty_param_substs_0, autoderef_kind adk) ->\n+            &ty::t[] ty_param_substs_0, autoderef_kind adk) ->\n        ty_param_substs_and_ty {\n         auto expected_1 = expected;\n         auto actual_1 = actual;\n@@ -956,10 +954,10 @@ mod demand {\n         fn mk_result(&@fn_ctxt fcx, &ty::t result_ty,\n                      &vec[int] ty_param_subst_var_ids,\n                      uint implicit_boxes) -> ty_param_substs_and_ty {\n-            let vec[ty::t] result_ty_param_substs = [];\n+            let ty::t[] result_ty_param_substs = ~[];\n             for (int var_id in ty_param_subst_var_ids) {\n                 auto tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n-                result_ty_param_substs += [tp_subst];\n+                result_ty_param_substs += ~[tp_subst];\n             }\n             ret tup(result_ty_param_substs,\n                     add_boxes(fcx.ccx, implicit_boxes, result_ty));\n@@ -1061,21 +1059,21 @@ mod writeback {\n         };\n         auto new_substs_opt;\n         alt (tpot._0) {\n-            case (none[vec[ty::t]]) { new_substs_opt = none[vec[ty::t]]; }\n-            case (some[vec[ty::t]](?substs)) {\n-                let vec[ty::t] new_substs = [];\n+            case (none[ty::t[]]) { new_substs_opt = none[ty::t[]]; }\n+            case (some[ty::t[]](?substs)) {\n+                let ty::t[] new_substs = ~[];\n                 for (ty::t subst in substs) {\n                     alt (resolve_type_vars_in_type(fcx, sp, subst)) {\n                         case (some(?t)) {\n-                            new_substs += [t];\n+                            new_substs += ~[t];\n                         }\n                         case (none) {\n                             wbcx.success = false;\n                             ret;\n                         }\n                     }\n                 }\n-                new_substs_opt = some[vec[ty::t]](new_substs);\n+                new_substs_opt = some[ty::t[]](new_substs);\n             }\n         }\n         write::ty(fcx.ccx.tcx, id, tup(new_substs_opt, new_ty));\n@@ -1266,11 +1264,11 @@ fn gather_locals(&@crate_ctxt ccx, &ast::fn_decl decl, &ast::block body,\n \n // AST fragment utilities\n fn replace_expr_type(&@fn_ctxt fcx, &@ast::expr expr,\n-                     &tup(vec[ty::t], ty::t) new_tyt) {\n+                     &tup(ty::t[], ty::t) new_tyt) {\n     auto new_tps;\n     if (ty::expr_has_ty_params(fcx.ccx.tcx, expr)) {\n-        new_tps = some[vec[ty::t]](new_tyt._0);\n-    } else { new_tps = none[vec[ty::t]]; }\n+        new_tps = some[ty::t[]](new_tyt._0);\n+    } else { new_tps = none[ty::t[]]; }\n     write::ty_fixup(fcx, expr.id, tup(new_tps, new_tyt._1));\n }\n \n@@ -1327,13 +1325,13 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                                                                path_tpot);\n \n                 // FIXME: Remove this ivec->vec conversion.\n-                auto tps_vec = [];\n-                for (ty::t tp in expected_tps) { tps_vec += [tp]; }\n+                auto tps_vec = ~[];\n+                for (ty::t tp in expected_tps) { tps_vec += ~[tp]; }\n \n                 auto path_tpt =\n                     demand::full(fcx, pat.span, expected, ctor_ty, tps_vec,\n                                  NO_AUTODEREF);\n-                path_tpot = tup(some[vec[ty::t]](path_tpt._0), path_tpt._1);\n+                path_tpot = tup(some[ty::t[]](path_tpt._0), path_tpt._1);\n                 // Get the number of arguments in this tag variant.\n \n                 auto arg_types ="}]}