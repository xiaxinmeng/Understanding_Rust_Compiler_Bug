{"sha": "eb90be779877caa2e2d51095301f83695d77dd44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViOTBiZTc3OTg3N2NhYTJlMmQ1MTA5NTMwMWY4MzY5NWQ3N2RkNDQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-01T20:24:14Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-01T20:24:14Z"}, "message": "Add session, span tracking, error reporting, beginning of a function to parse an item to rustc.", "tree": {"sha": "76756b9fa7e4cfc6284632b7cde93302d87348c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76756b9fa7e4cfc6284632b7cde93302d87348c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb90be779877caa2e2d51095301f83695d77dd44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb90be779877caa2e2d51095301f83695d77dd44", "html_url": "https://github.com/rust-lang/rust/commit/eb90be779877caa2e2d51095301f83695d77dd44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb90be779877caa2e2d51095301f83695d77dd44/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b90e6b93c1d48d4a4816467dd489794bc2c89c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b90e6b93c1d48d4a4816467dd489794bc2c89c9c", "html_url": "https://github.com/rust-lang/rust/commit/b90e6b93c1d48d4a4816467dd489794bc2c89c9c"}], "stats": {"total": 200, "additions": 165, "deletions": 35}, "files": [{"sha": "a54639409ea08dbd4ca59225b97c4a2a108a9dd2", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=eb90be779877caa2e2d51095301f83695d77dd44", "patch": "@@ -25,9 +25,10 @@ fn main(vec[str] args) {\n   log \"You want rustboot, the compiler next door.\";\n \n   auto i = 0;\n+  auto sess = session.session();\n   for (str filename in args) {\n     if (i > 0) {\n-        auto p = parser.new_parser(filename);\n+        auto p = parser.new_parser(sess, filename);\n         log \"opened file: \" + filename;\n         auto tok = p.peek();\n         while (true) {"}, {"sha": "3b92e073e688610a0b893f1cf4837bbd057d6381", "filename": "src/comp/driver/session.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=eb90be779877caa2e2d51095301f83695d77dd44", "patch": "@@ -0,0 +1,37 @@\n+import util.common.span;\n+import std._uint;\n+\n+io obj session() {\n+    io fn span_err(span sp, str msg) {\n+        let str s =  sp.filename;\n+        s += ':' as u8;\n+        // We really need #fmt soon!\n+        s += _uint.to_str(sp.lo.line, 10u);\n+        s += ':' as u8;\n+        s += _uint.to_str(sp.lo.col, 10u);\n+        s += ':' as u8;\n+        s += _uint.to_str(sp.hi.line, 10u);\n+        s += ':' as u8;\n+        s += _uint.to_str(sp.hi.col, 10u);\n+        s += \": error: \";\n+        s += msg;\n+        log s;\n+        fail;\n+    }\n+\n+    io fn err(str msg) {\n+        let str s = \"error: \";\n+        s += msg;\n+        log s;\n+        fail;\n+    }\n+}\n+\n+\n+// Local Variables:\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "ba0849793894e2fef1126eccd96971429641ad15", "filename": "src/comp/fe/ast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Ffe%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Ffe%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fast.rs?ref=eb90be779877caa2e2d51095301f83695d77dd44", "patch": "@@ -1,13 +1,14 @@\n \n import std.util.option;\n import std.map.hashmap;\n+import util.common.span;\n \n type ident = str;\n \n type crate = rec( str filename,\n                   _mod module);\n \n-type block = vec[stmt];\n+type block = vec[@stmt];\n \n type stmt = tag( stmt_block(block),\n                  stmt_decl(@decl),\n@@ -20,7 +21,7 @@ type lval = tag( lval_ident(ident),\n                  lval_ext(@lval, ident),\n                  lval_idx(@lval, @atom) );\n \n-type atom = tag( atom_lit(lit));\n+type atom = tag( atom_lit(@lit), atom_lval(@lval) );\n \n type lit = tag( lit_char(char),\n                 lit_int(int),\n@@ -32,7 +33,7 @@ type ty = tag( ty_nil(),\n                ty_int(),\n                ty_char() );\n \n-type mode = tag( local(), alias() );\n+type mode = tag( val(), alias() );\n \n type slot = rec(ty ty, mode mode);\n "}, {"sha": "e2c83dccc8863ed56e1ece22c0c274f4d344c6b6", "filename": "src/comp/fe/lexer.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Ffe%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Ffe%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Flexer.rs?ref=eb90be779877caa2e2d51095301f83695d77dd44", "patch": "@@ -10,33 +10,46 @@ fn new_str_hash[V]() -> map.hashmap[str,V] {\n     ret map.mk_hashmap[str,V](hasher, eqer);\n }\n \n-type reader = obj {\n-              fn is_eof() -> bool;\n-              fn curr() -> char;\n-              fn next() -> char;\n-              fn bump();\n-              fn get_curr_pos() -> tup(str,uint,uint);\n-              fn get_keywords() -> hashmap[str,token.token];\n-              fn get_reserved() -> hashmap[str,()];\n+state type reader = state obj {\n+                          fn is_eof() -> bool;\n+                          fn curr() -> char;\n+                          fn next() -> char;\n+                          state fn bump();\n+                          state fn mark();\n+                          fn get_filename() -> str;\n+                          fn get_mark_pos() -> common.pos;\n+                          fn get_curr_pos() -> common.pos;\n+                          fn get_keywords() -> hashmap[str,token.token];\n+                          fn get_reserved() -> hashmap[str,()];\n };\n \n fn new_reader(stdio_reader rdr, str filename) -> reader\n {\n-    obj reader(stdio_reader rdr,\n-               str filename,\n-               mutable char c,\n-               mutable char n,\n-               mutable uint line,\n-               mutable uint col,\n-               hashmap[str,token.token] keywords,\n-               hashmap[str,()] reserved)\n-        {\n+    state obj reader(stdio_reader rdr,\n+                     str filename,\n+                     mutable char c,\n+                     mutable char n,\n+                     mutable uint mark_line,\n+                     mutable uint mark_col,\n+                     mutable uint line,\n+                     mutable uint col,\n+                     hashmap[str,token.token] keywords,\n+                     hashmap[str,()] reserved) {\n+\n             fn is_eof() -> bool {\n                 ret c == (-1) as char;\n             }\n \n-            fn get_curr_pos() -> tup(str,uint,uint) {\n-                ret tup(filename, line, col);\n+            fn get_curr_pos() -> common.pos {\n+                ret rec(line=line, col=col);\n+            }\n+\n+            fn get_mark_pos() -> common.pos {\n+                ret rec(line=mark_line, col=mark_col);\n+            }\n+\n+            fn get_filename() -> str {\n+                ret filename;\n             }\n \n             fn curr() -> char {\n@@ -47,7 +60,7 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n                 ret n;\n             }\n \n-            fn bump() {\n+            state fn bump() {\n                 c = n;\n \n                 if (c == (-1) as char) {\n@@ -56,14 +69,19 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n \n                 if (c == '\\n') {\n                     line += 1u;\n-                    col = 0u;\n+                    col = 1u;\n                 } else {\n                     col += 1u;\n                 }\n \n                 n = rdr.getc() as char;\n             }\n \n+            state fn mark() {\n+                mark_line = line;\n+                mark_col = col;\n+            }\n+\n             fn get_keywords() -> hashmap[str,token.token] {\n                 ret keywords;\n             }\n@@ -171,7 +189,7 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n     keywords.insert(\"f64\", token.MACH(common.ty_f64()));\n \n     ret reader(rdr, filename, rdr.getc() as char, rdr.getc() as char,\n-               1u, 1u, keywords, reserved);\n+               1u, 1u, 1u, 1u, keywords, reserved);\n }\n \n \n@@ -229,14 +247,14 @@ fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-fn consume_any_whitespace(reader rdr) {\n+state fn consume_any_whitespace(reader rdr) {\n     while (is_whitespace(rdr.curr())) {\n         rdr.bump();\n     }\n     be consume_any_line_comment(rdr);\n }\n \n-fn consume_any_line_comment(reader rdr) {\n+state fn consume_any_line_comment(reader rdr) {\n     if (rdr.curr() == '/') {\n         alt (rdr.next()) {\n             case ('/') {\n@@ -259,7 +277,7 @@ fn consume_any_line_comment(reader rdr) {\n }\n \n \n-fn consume_block_comment(reader rdr) {\n+state fn consume_block_comment(reader rdr) {\n     let int level = 1;\n     while (level > 0) {\n         if (rdr.curr() == '/' && rdr.next() == '*') {\n@@ -280,7 +298,7 @@ fn consume_block_comment(reader rdr) {\n     be consume_any_whitespace(rdr);\n }\n \n-fn next_token(reader rdr) -> token.token {\n+state fn next_token(reader rdr) -> token.token {\n     auto accum_str = \"\";\n     auto accum_int = 0;\n \n@@ -341,8 +359,7 @@ fn next_token(reader rdr) -> token.token {\n         ret token.LIT_INT(accum_int);\n     }\n \n-\n-    fn binop(reader rdr, token.binop op) -> token.token {\n+    state fn binop(reader rdr, token.binop op) -> token.token {\n         rdr.bump();\n         if (rdr.next() == '=') {\n             rdr.bump();"}, {"sha": "6ffd911e83093cf34dd10ae43f12d3593db5e925", "filename": "src/comp/fe/parser.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Ffe%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Ffe%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fparser.rs?ref=eb90be779877caa2e2d51095301f83695d77dd44", "patch": "@@ -1,25 +1,94 @@\n import std._io;\n+import driver.session;\n+import util.common;\n \n state type parser =\n     state obj {\n           state fn peek() -> token.token;\n           state fn bump();\n+          io fn err(str s);\n+          fn get_session() -> session.session;\n+          fn get_span() -> common.span;\n     };\n \n-fn new_parser(str path) -> parser {\n-    state obj stdio_parser(mutable token.token tok,\n+state fn new_parser(session.session sess, str path) -> parser {\n+    state obj stdio_parser(session.session sess,\n+                           mutable token.token tok,\n+                           mutable common.pos lo,\n+                           mutable common.pos hi,\n                            lexer.reader rdr)\n         {\n             state fn peek() -> token.token {\n                 ret tok;\n             }\n+\n             state fn bump() {\n                 tok = lexer.next_token(rdr);\n+                lo = rdr.get_mark_pos();\n+                hi = rdr.get_curr_pos();\n+            }\n+\n+            io fn err(str m) {\n+                auto span = rec(filename = rdr.get_filename(),\n+                                lo = lo, hi = hi);\n+                sess.span_err(span, m);\n+            }\n+\n+            fn get_session() -> session.session {\n+                ret sess;\n+            }\n+\n+            fn get_span() -> common.span {\n+                ret rec(filename = rdr.get_filename(),\n+                        lo = lo, hi = hi);\n             }\n         }\n     auto srdr = _io.new_stdio_reader(path);\n     auto rdr = lexer.new_reader(srdr, path);\n-    ret stdio_parser(lexer.next_token(rdr), rdr);\n+    auto npos = rdr.get_curr_pos();\n+    ret stdio_parser(sess, lexer.next_token(rdr), npos, npos, rdr);\n+}\n+\n+state fn expect(parser p, token.token t) {\n+    // FIXME: comparing tags would be good. One of these days.\n+    if (true /* p.peek() == t */) {\n+        p.bump();\n+    } else {\n+        let str s = \"expecting \";\n+        s += token.to_str(t);\n+        s += \", found \";\n+        s += token.to_str(t);\n+        p.err(s);\n+    }\n+}\n+\n+state fn parse_ident(parser p) -> ast.ident {\n+    alt (p.peek()) {\n+        case (token.IDENT(i)) { ret i; }\n+        case (_) {\n+            p.err(\"expecting ident\");\n+            fail;\n+        }\n+    }\n+}\n+\n+state fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n+    alt (p.peek()) {\n+        case (token.FN()) {\n+            p.bump();\n+            auto id = parse_ident(p);\n+            expect(p, token.LPAREN());\n+            let vec[rec(ast.slot slot, ast.ident ident)] inputs = vec();\n+            let vec[@ast.stmt] body = vec();\n+            auto output = rec(ty = ast.ty_nil(), mode = ast.val() );\n+            let ast._fn f = rec(inputs = inputs,\n+                                output = output,\n+                                body = body);\n+            ret tup(id, ast.item_fn(@f));\n+        }\n+    }\n+    p.err(\"expecting item\");\n+    fail;\n }\n \n //"}, {"sha": "5f5bc893ae213bedd467801e563ed918015a52b6", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=eb90be779877caa2e2d51095301f83695d77dd44", "patch": "@@ -12,6 +12,7 @@ mod fe {\n \n mod driver {\n     mod rustc;\n+    mod session;\n }\n \n mod util {"}, {"sha": "9bcb67b2dc8303a6633f5f061fde29be102579e3", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb90be779877caa2e2d51095301f83695d77dd44/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=eb90be779877caa2e2d51095301f83695d77dd44", "patch": "@@ -1,3 +1,7 @@\n+import std._uint;\n+\n+type pos = rec(uint line, uint col);\n+type span = rec(str filename, pos lo, pos hi);\n \n type ty_mach = tag( ty_i8(), ty_i16(), ty_i32(), ty_i64(),\n                     ty_u8(), ty_u16(), ty_u32(), ty_u64(),"}]}