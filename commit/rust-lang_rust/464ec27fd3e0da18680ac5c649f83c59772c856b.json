{"sha": "464ec27fd3e0da18680ac5c649f83c59772c856b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NGVjMjdmZDNlMGRhMTg2ODBhYzVjNjQ5ZjgzYzU5NzcyYzg1NmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T00:51:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T00:51:16Z"}, "message": "librustc: De-export metadata. rs=deexporting", "tree": {"sha": "7e45bb48bb75732facb1ba8ca55d595fc6cd4e4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e45bb48bb75732facb1ba8ca55d595fc6cd4e4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/464ec27fd3e0da18680ac5c649f83c59772c856b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/464ec27fd3e0da18680ac5c649f83c59772c856b", "html_url": "https://github.com/rust-lang/rust/commit/464ec27fd3e0da18680ac5c649f83c59772c856b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/464ec27fd3e0da18680ac5c649f83c59772c856b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bae482185173d11d9aae2497ba3764947f196675", "url": "https://api.github.com/repos/rust-lang/rust/commits/bae482185173d11d9aae2497ba3764947f196675", "html_url": "https://github.com/rust-lang/rust/commit/bae482185173d11d9aae2497ba3764947f196675"}], "stats": {"total": 707, "additions": 279, "deletions": 428}, "files": [{"sha": "52f7c874af4a0f56dcaf14346972adb4f65c6846", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -11,84 +11,84 @@\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n-const tag_items: uint = 0x02u;\n+pub const tag_items: uint = 0x02u;\n \n-const tag_paths_data_name: uint = 0x04u;\n+pub const tag_paths_data_name: uint = 0x04u;\n \n-const tag_def_id: uint = 0x07u;\n+pub const tag_def_id: uint = 0x07u;\n \n-const tag_items_data: uint = 0x08u;\n+pub const tag_items_data: uint = 0x08u;\n \n-const tag_items_data_item: uint = 0x09u;\n+pub const tag_items_data_item: uint = 0x09u;\n \n-const tag_items_data_item_family: uint = 0x0au;\n+pub const tag_items_data_item_family: uint = 0x0au;\n \n-const tag_items_data_item_ty_param_bounds: uint = 0x0bu;\n+pub const tag_items_data_item_ty_param_bounds: uint = 0x0bu;\n \n-const tag_items_data_item_type: uint = 0x0cu;\n+pub const tag_items_data_item_type: uint = 0x0cu;\n \n-const tag_items_data_item_symbol: uint = 0x0du;\n+pub const tag_items_data_item_symbol: uint = 0x0du;\n \n-const tag_items_data_item_variant: uint = 0x0eu;\n+pub const tag_items_data_item_variant: uint = 0x0eu;\n \n-const tag_items_data_parent_item: uint = 0x0fu;\n+pub const tag_items_data_parent_item: uint = 0x0fu;\n \n-const tag_index: uint = 0x11u;\n+pub const tag_index: uint = 0x11u;\n \n-const tag_index_buckets: uint = 0x12u;\n+pub const tag_index_buckets: uint = 0x12u;\n \n-const tag_index_buckets_bucket: uint = 0x13u;\n+pub const tag_index_buckets_bucket: uint = 0x13u;\n \n-const tag_index_buckets_bucket_elt: uint = 0x14u;\n+pub const tag_index_buckets_bucket_elt: uint = 0x14u;\n \n-const tag_index_table: uint = 0x15u;\n+pub const tag_index_table: uint = 0x15u;\n \n-const tag_meta_item_name_value: uint = 0x18u;\n+pub const tag_meta_item_name_value: uint = 0x18u;\n \n-const tag_meta_item_name: uint = 0x19u;\n+pub const tag_meta_item_name: uint = 0x19u;\n \n-const tag_meta_item_value: uint = 0x20u;\n+pub const tag_meta_item_value: uint = 0x20u;\n \n-const tag_attributes: uint = 0x21u;\n+pub const tag_attributes: uint = 0x21u;\n \n-const tag_attribute: uint = 0x22u;\n+pub const tag_attribute: uint = 0x22u;\n \n-const tag_meta_item_word: uint = 0x23u;\n+pub const tag_meta_item_word: uint = 0x23u;\n \n-const tag_meta_item_list: uint = 0x24u;\n+pub const tag_meta_item_list: uint = 0x24u;\n \n // The list of crates that this crate depends on\n-const tag_crate_deps: uint = 0x25u;\n+pub const tag_crate_deps: uint = 0x25u;\n \n // A single crate dependency\n-const tag_crate_dep: uint = 0x26u;\n+pub const tag_crate_dep: uint = 0x26u;\n \n-const tag_crate_hash: uint = 0x28u;\n+pub const tag_crate_hash: uint = 0x28u;\n \n-const tag_parent_item: uint = 0x29u;\n+pub const tag_parent_item: uint = 0x29u;\n \n-const tag_crate_dep_name: uint = 0x2au;\n-const tag_crate_dep_hash: uint = 0x2bu;\n-const tag_crate_dep_vers: uint = 0x2cu;\n+pub const tag_crate_dep_name: uint = 0x2au;\n+pub const tag_crate_dep_hash: uint = 0x2bu;\n+pub const tag_crate_dep_vers: uint = 0x2cu;\n \n-const tag_mod_impl: uint = 0x30u;\n+pub const tag_mod_impl: uint = 0x30u;\n \n-const tag_item_trait_method: uint = 0x31u;\n-const tag_impl_trait: uint = 0x32u;\n+pub const tag_item_trait_method: uint = 0x31u;\n+pub const tag_impl_trait: uint = 0x32u;\n \n // discriminator value for variants\n-const tag_disr_val: uint = 0x34u;\n+pub const tag_disr_val: uint = 0x34u;\n \n // used to encode ast_map::path and ast_map::path_elt\n-const tag_path: uint = 0x40u;\n-const tag_path_len: uint = 0x41u;\n-const tag_path_elt_mod: uint = 0x42u;\n-const tag_path_elt_name: uint = 0x43u;\n-const tag_item_field: uint = 0x44u;\n-const tag_struct_mut: uint = 0x45u;\n-\n-const tag_region_param: uint = 0x46u;\n-const tag_mod_impl_trait: uint = 0x47u;\n+pub const tag_path: uint = 0x40u;\n+pub const tag_path_len: uint = 0x41u;\n+pub const tag_path_elt_mod: uint = 0x42u;\n+pub const tag_path_elt_name: uint = 0x43u;\n+pub const tag_item_field: uint = 0x44u;\n+pub const tag_struct_mut: uint = 0x45u;\n+\n+pub const tag_region_param: uint = 0x46u;\n+pub const tag_mod_impl_trait: uint = 0x47u;\n /*\n   trait items contain tag_item_trait_method elements,\n   impl items contain tag_item_impl_method elements, and classes\n@@ -97,19 +97,19 @@ const tag_mod_impl_trait: uint = 0x47u;\n   both, tag_item_trait_method and tag_item_impl_method have to be two\n   different tags.\n  */\n-const tag_item_impl_method: uint = 0x48u;\n-const tag_item_dtor: uint = 0x49u;\n-const tag_item_trait_method_self_ty: uint = 0x4b;\n-const tag_item_trait_method_self_ty_region: uint = 0x4c;\n+pub const tag_item_impl_method: uint = 0x48u;\n+pub const tag_item_dtor: uint = 0x49u;\n+pub const tag_item_trait_method_self_ty: uint = 0x4b;\n+pub const tag_item_trait_method_self_ty_region: uint = 0x4c;\n \n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n-const tag_items_data_item_reexport: uint = 0x4d;\n-const tag_items_data_item_reexport_def_id: uint = 0x4e;\n-const tag_items_data_item_reexport_name: uint = 0x4f;\n+pub const tag_items_data_item_reexport: uint = 0x4d;\n+pub const tag_items_data_item_reexport_def_id: uint = 0x4e;\n+pub const tag_items_data_item_reexport_name: uint = 0x4f;\n \n // used to encode crate_ctxt side tables\n-enum astencode_tag { // Reserves 0x50 -- 0x6f\n+pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,\n \n     tag_tree = 0x51,\n@@ -136,9 +136,9 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_value_mode = 0x64\n }\n \n-const tag_item_trait_method_sort: uint = 0x70;\n+pub const tag_item_trait_method_sort: uint = 0x70;\n \n-const tag_item_impl_type_basename: uint = 0x71;\n+pub const tag_item_impl_type_basename: uint = 0x71;\n \n // Language items are a top-level directory (for speed). Hierarchy:\n //\n@@ -147,10 +147,10 @@ const tag_item_impl_type_basename: uint = 0x71;\n //   - tag_lang_items_item_id: u32\n //   - tag_lang_items_item_node_id: u32\n \n-const tag_lang_items: uint = 0x72;\n-const tag_lang_items_item: uint = 0x73;\n-const tag_lang_items_item_id: uint = 0x74;\n-const tag_lang_items_item_node_id: uint = 0x75;\n+pub const tag_lang_items: uint = 0x72;\n+pub const tag_lang_items_item: uint = 0x73;\n+pub const tag_lang_items_item_id: uint = 0x74;\n+pub const tag_lang_items_item_node_id: uint = 0x75;\n \n-type link_meta = {name: @str, vers: @str, extras_hash: @str};\n+pub type link_meta = {name: @str, vers: @str, extras_hash: @str};\n "}, {"sha": "96f64c2a088152191508b927bfc659a0fe422b27", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -32,17 +32,15 @@ use syntax::visit;\n use syntax::{ast, ast_util};\n use std::map::HashMap;\n \n-export read_crates;\n-\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n-fn read_crates(diag: span_handler,\n-               crate: ast::crate,\n-               cstore: cstore::CStore,\n-               filesearch: FileSearch,\n-               os: loader::os,\n-               static: bool,\n-               intr: @ident_interner) {\n+pub fn read_crates(diag: span_handler,\n+                   crate: ast::crate,\n+                   cstore: cstore::CStore,\n+                   filesearch: FileSearch,\n+                   os: loader::os,\n+                   static: bool,\n+                   intr: @ident_interner) {\n     let e = @{diag: diag,\n               filesearch: filesearch,\n               cstore: cstore,"}, {"sha": "a150ef6e3371549aab46fc68a8e686231a5286b4", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 49, "deletions": 68, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -31,72 +31,47 @@ use syntax::ast_util;\n use syntax::diagnostic::expect;\n use syntax::diagnostic::span_handler;\n \n-export struct_dtor;\n-export get_symbol;\n-export get_struct_fields;\n-export get_field_type;\n-export get_type_param_count;\n-export get_region_param;\n-export get_enum_variants;\n-export get_impls_for_mod;\n-export get_trait_methods;\n-export get_provided_trait_methods;\n-export get_supertraits;\n-export get_method_names_if_trait;\n-export get_type_name_if_impl;\n-export get_static_methods_if_impl;\n-export get_item_attrs;\n-export each_lang_item;\n-export each_path;\n-export get_type;\n-export get_impl_traits;\n-export get_impl_method;\n-export get_item_path;\n-export get_lang_items;\n-export maybe_get_item_ast, found_ast, found, found_parent, not_found;\n-export ProvidedTraitMethodInfo;\n-export StaticMethodInfo;\n-\n-struct ProvidedTraitMethodInfo {\n+pub struct ProvidedTraitMethodInfo {\n     ty: ty::method,\n     def_id: ast::def_id\n }\n \n-struct StaticMethodInfo {\n+pub struct StaticMethodInfo {\n     ident: ast::ident,\n     def_id: ast::def_id,\n     purity: ast::purity\n }\n \n-fn get_symbol(cstore: cstore::CStore, def: ast::def_id) -> ~str {\n+pub fn get_symbol(cstore: cstore::CStore, def: ast::def_id) -> ~str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-fn get_type_param_count(cstore: cstore::CStore, def: ast::def_id) -> uint {\n+pub fn get_type_param_count(cstore: cstore::CStore, def: ast::def_id)\n+                         -> uint {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n /// Iterates over all the language items in the given crate.\n-fn each_lang_item(cstore: cstore::CStore,\n-                  cnum: ast::crate_num,\n-                  f: &fn(ast::node_id, uint) -> bool) {\n+pub fn each_lang_item(cstore: cstore::CStore,\n+                      cnum: ast::crate_num,\n+                      f: &fn(ast::node_id, uint) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_lang_item(crate_data, f)\n }\n \n /// Iterates over all the paths in the given crate.\n-fn each_path(cstore: cstore::CStore, cnum: ast::crate_num,\n-             f: fn(&str, decoder::def_like) -> bool) {\n+pub fn each_path(cstore: cstore::CStore, cnum: ast::crate_num,\n+                 f: fn(&str, decoder::def_like) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n     };\n     decoder::each_path(cstore.intr, crate_data, get_crate_data, f);\n }\n \n-fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n+pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     let path = decoder::get_item_path(cstore.intr, cdata, def.node);\n@@ -107,7 +82,7 @@ fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n         /*bad*/copy cdata.name))], path)\n }\n \n-enum found_ast {\n+pub enum found_ast {\n     found(ast::inlined_item),\n     found_parent(ast::def_id, ast::inlined_item),\n     not_found,\n@@ -116,97 +91,102 @@ enum found_ast {\n // Finds the AST for this item in the crate metadata, if any.  If the item was\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n-fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n-                      decode_inlined_item: decoder::decode_inlined_item)\n-    -> found_ast {\n+pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n+                          decode_inlined_item: decoder::decode_inlined_item)\n+                       -> found_ast {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::maybe_get_item_ast(cstore.intr, cdata, tcx, def.node,\n                                 decode_inlined_item)\n }\n \n-fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n-    -> ~[ty::VariantInfo] {\n+pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n+                      -> ~[ty::VariantInfo] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n-fn get_impls_for_mod(cstore: cstore::CStore, def: ast::def_id,\n-                     name: Option<ast::ident>)\n-    -> @~[@decoder::_impl] {\n+pub fn get_impls_for_mod(cstore: cstore::CStore, def: ast::def_id,\n+                         name: Option<ast::ident>)\n+                      -> @~[@decoder::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     do decoder::get_impls_for_mod(cstore.intr, cdata, def.node, name) |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n     }\n }\n \n-fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n+pub fn get_trait_methods(tcx: ty::ctxt,\n+                         def: ast::def_id)\n+                      -> @~[ty::method] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-fn get_provided_trait_methods(tcx: ty::ctxt, def: ast::def_id) ->\n-        ~[ProvidedTraitMethodInfo] {\n+pub fn get_provided_trait_methods(tcx: ty::ctxt,\n+                                  def: ast::def_id)\n+                               -> ~[ProvidedTraitMethodInfo] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n+pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-fn get_method_names_if_trait(cstore: cstore::CStore, def: ast::def_id)\n+pub fn get_method_names_if_trait(cstore: cstore::CStore, def: ast::def_id)\n     -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n }\n \n-fn get_type_name_if_impl(cstore: cstore::CStore, def: ast::def_id) ->\n+pub fn get_type_name_if_impl(cstore: cstore::CStore, def: ast::def_id) ->\n         Option<ast::ident> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type_name_if_impl(cstore.intr, cdata, def.node)\n }\n \n-fn get_static_methods_if_impl(cstore: cstore::CStore, def: ast::def_id) ->\n-        Option<~[StaticMethodInfo]> {\n+pub fn get_static_methods_if_impl(cstore: cstore::CStore,\n+                                  def: ast::def_id)\n+                               -> Option<~[StaticMethodInfo]> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n-fn get_item_attrs(cstore: cstore::CStore,\n-                  def_id: ast::def_id,\n-                  f: fn(~[@ast::meta_item])) {\n-\n+pub fn get_item_attrs(cstore: cstore::CStore,\n+                      def_id: ast::def_id,\n+                      f: fn(~[@ast::meta_item])) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n-fn get_struct_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n+pub fn get_struct_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n \n-fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+pub fn get_type(tcx: ty::ctxt,\n+                def: ast::def_id)\n+             -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n-fn get_region_param(cstore: metadata::cstore::CStore,\n-                    def: ast::def_id) -> Option<ty::region_variance> {\n+pub fn get_region_param(cstore: metadata::cstore::CStore,\n+                        def: ast::def_id) -> Option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_region_param(cdata, def.node);\n }\n \n-fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n-                  def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n+                      def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n@@ -230,21 +210,22 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n // Given a def_id for an impl or class, return the traits it implements,\n // or the empty vector if it's not for an impl or for a class that implements\n // traits\n-fn get_impl_traits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n+pub fn get_impl_traits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_traits(cdata, def.node, tcx)\n }\n \n-fn get_impl_method(cstore: cstore::CStore,\n-                   def: ast::def_id, mname: ast::ident)\n-    -> ast::def_id {\n+pub fn get_impl_method(cstore: cstore::CStore,\n+                       def: ast::def_id,\n+                       mname: ast::ident)\n+                    -> ast::def_id {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n /* If def names a class with a dtor, return it. Otherwise, return none. */\n-fn struct_dtor(cstore: cstore::CStore, def: ast::def_id)\n+pub fn struct_dtor(cstore: cstore::CStore, def: ast::def_id)\n     -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::struct_dtor(cdata, def.node)"}, {"sha": "f2bd998b55706bafdcbfb4d854b9ea02fa0b87a6", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -27,44 +27,23 @@ use std;\n use syntax::{ast, attr};\n use syntax::parse::token::ident_interner;\n \n-export CStore;\n-export cnum_map;\n-export crate_metadata;\n-export mk_cstore;\n-export get_crate_data;\n-export set_crate_data;\n-export get_crate_hash;\n-export get_crate_vers;\n-export have_crate_data;\n-export iter_crate_data;\n-export add_used_crate_file;\n-export get_used_crate_files;\n-export add_used_library;\n-export get_used_libraries;\n-export add_used_link_args;\n-export get_used_link_args;\n-export add_use_stmt_cnum;\n-export find_use_stmt_cnum;\n-export get_dep_hashes;\n-\n-\n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-type cnum_map = map::HashMap<ast::crate_num, ast::crate_num>;\n+pub type cnum_map = map::HashMap<ast::crate_num, ast::crate_num>;\n \n-type crate_metadata = @{name: ~str,\n-                        data: @~[u8],\n-                        cnum_map: cnum_map,\n-                        cnum: ast::crate_num};\n+pub type crate_metadata = @{name: ~str,\n+                            data: @~[u8],\n+                            cnum_map: cnum_map,\n+                            cnum: ast::crate_num};\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n // keeping all the data in a non-exported enum variant, it's impossible for\n // other modules to access the cstore's private data. This could also be\n // achieved with an obj, but at the expense of a vtable. Not sure if this is a\n // good pattern or not.\n-enum CStore { private(cstore_private), }\n+pub enum CStore { private(cstore_private), }\n \n type cstore_private =\n     @{metas: map::HashMap<ast::crate_num, crate_metadata>,\n@@ -82,7 +61,7 @@ pure fn p(cstore: CStore) -> cstore_private {\n     match cstore { private(p) => p }\n }\n \n-fn mk_cstore(intr: @ident_interner) -> CStore {\n+pub fn mk_cstore(intr: @ident_interner) -> CStore {\n     let meta_cache = map::HashMap();\n     let crate_map = map::HashMap();\n     return private(@{metas: meta_cache,\n@@ -93,77 +72,79 @@ fn mk_cstore(intr: @ident_interner) -> CStore {\n                      intr: intr});\n }\n \n-fn get_crate_data(cstore: CStore, cnum: ast::crate_num) -> crate_metadata {\n+pub fn get_crate_data(cstore: CStore, cnum: ast::crate_num)\n+                   -> crate_metadata {\n     return p(cstore).metas.get(cnum);\n }\n \n-fn get_crate_hash(cstore: CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_hash(cstore: CStore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_hash(cdata.data);\n }\n \n-fn get_crate_vers(cstore: CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_vers(cstore: CStore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_vers(cdata.data);\n }\n \n-fn set_crate_data(cstore: CStore,\n-                  cnum: ast::crate_num,\n-                  data: crate_metadata) {\n+pub fn set_crate_data(cstore: CStore,\n+                      cnum: ast::crate_num,\n+                      data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n }\n \n-fn have_crate_data(cstore: CStore, cnum: ast::crate_num) -> bool {\n+pub fn have_crate_data(cstore: CStore, cnum: ast::crate_num) -> bool {\n     return p(cstore).metas.contains_key(cnum);\n }\n \n-fn iter_crate_data(cstore: CStore, i: fn(ast::crate_num, crate_metadata)) {\n+pub fn iter_crate_data(cstore: CStore,\n+                       i: fn(ast::crate_num, crate_metadata)) {\n     for p(cstore).metas.each |k,v| { i(k, v);};\n }\n \n-fn add_used_crate_file(cstore: CStore, lib: &Path) {\n+pub fn add_used_crate_file(cstore: CStore, lib: &Path) {\n     if !vec::contains(p(cstore).used_crate_files, lib) {\n         p(cstore).used_crate_files.push(copy *lib);\n     }\n }\n \n-fn get_used_crate_files(cstore: CStore) -> ~[Path] {\n+pub fn get_used_crate_files(cstore: CStore) -> ~[Path] {\n     return /*bad*/copy p(cstore).used_crate_files;\n }\n \n-fn add_used_library(cstore: CStore, +lib: ~str) -> bool {\n+pub fn add_used_library(cstore: CStore, +lib: ~str) -> bool {\n     assert lib != ~\"\";\n \n     if vec::contains(p(cstore).used_libraries, &lib) { return false; }\n     p(cstore).used_libraries.push(lib);\n     return true;\n }\n \n-fn get_used_libraries(cstore: CStore) -> ~[~str] {\n+pub fn get_used_libraries(cstore: CStore) -> ~[~str] {\n     return /*bad*/copy p(cstore).used_libraries;\n }\n \n-fn add_used_link_args(cstore: CStore, args: ~str) {\n+pub fn add_used_link_args(cstore: CStore, args: ~str) {\n     p(cstore).used_link_args.push_all(str::split_char(args, ' '));\n }\n \n-fn get_used_link_args(cstore: CStore) -> ~[~str] {\n+pub fn get_used_link_args(cstore: CStore) -> ~[~str] {\n     return /*bad*/copy p(cstore).used_link_args;\n }\n \n-fn add_use_stmt_cnum(cstore: CStore, use_id: ast::node_id,\n-                     cnum: ast::crate_num) {\n+pub fn add_use_stmt_cnum(cstore: CStore, use_id: ast::node_id,\n+                         cnum: ast::crate_num) {\n     p(cstore).use_crate_map.insert(use_id, cnum);\n }\n \n-fn find_use_stmt_cnum(cstore: CStore,\n-                      use_id: ast::node_id) -> Option<ast::crate_num> {\n+pub fn find_use_stmt_cnum(cstore: CStore,\n+                          use_id: ast::node_id) -> Option<ast::crate_num> {\n     p(cstore).use_crate_map.find(use_id)\n }\n \n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n-fn get_dep_hashes(cstore: CStore) -> ~[~str] {\n+pub fn get_dep_hashes(cstore: CStore) -> ~[~str] {\n     type crate_hash = {name: ~str, hash: ~str};\n     let mut result = ~[];\n "}, {"sha": "173547a268dae3623ae8deb6e3b1ac19cbf18645", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 64, "deletions": 100, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -46,48 +46,6 @@ use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n \n-export struct_dtor;\n-export get_struct_fields;\n-export get_symbol;\n-export get_enum_variants;\n-export get_type;\n-export get_region_param;\n-export get_type_param_count;\n-export get_impl_traits;\n-export get_impl_method;\n-export get_static_methods_if_impl;\n-export lookup_def;\n-export resolve_path;\n-export get_crate_attributes;\n-export list_crate_metadata;\n-export crate_dep;\n-export get_crate_deps;\n-export get_crate_hash;\n-export get_crate_vers;\n-export get_impls_for_mod;\n-export get_trait_methods;\n-export get_provided_trait_methods;\n-export get_supertraits;\n-export get_method_names_if_trait;\n-export get_type_name_if_impl;\n-export get_item_attrs;\n-export def_like;\n-export dl_def;\n-export dl_impl;\n-export dl_field;\n-export each_lang_item;\n-export each_path;\n-export get_item_path;\n-export maybe_find_item; // sketchy\n-export item_type; // sketchy\n-export maybe_get_item_ast;\n-export decode_inlined_item;\n-export method_info, _impl;\n-export GetCrateDataCb;\n-\n-// Used internally by astencode:\n-export translate_def_id;\n-\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -114,7 +72,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n \n pub type GetCrateDataCb = &fn(ast::crate_num) -> cmd;\n \n-fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n+pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(vec::view(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n@@ -267,8 +225,8 @@ fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_type(item_id: ast::def_id, item: ebml::Doc,\n-             tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n+                 tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let t = doc_type(item, tcx, cdata);\n     if family_names_type(item_family(item)) {\n         ty::mk_with_id(tcx, t, item_id)\n@@ -380,15 +338,15 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n     }\n }\n \n-fn lookup_def(cnum: ast::crate_num, data: @~[u8], did_: ast::def_id) ->\n+pub fn lookup_def(cnum: ast::crate_num, data: @~[u8], did_: ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n     let did = ast::def_id { crate: cnum, node: did_.node };\n     // We treat references to enums as references to types.\n     return def_like_to_def(item_to_def_like(item, did, cnum));\n }\n \n-fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data);\n@@ -403,23 +361,24 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n             ty: t};\n }\n \n-fn get_region_param(cdata: cmd, id: ast::node_id)\n+pub fn get_region_param(cdata: cmd, id: ast::node_id)\n     -> Option<ty::region_variance> {\n \n     let item = lookup_item(id, cdata.data);\n     return item_ty_region_param(item);\n }\n \n-fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n+pub fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n+pub fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+                    -> ~[ty::t] {\n     item_impl_traits(lookup_item(id, cdata.data), tcx, cdata)\n }\n \n-fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                   name: ast::ident) -> ast::def_id {\n+pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+                       name: ast::ident) -> ast::def_id {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     for reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n@@ -432,7 +391,7 @@ fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     found.get()\n }\n \n-fn struct_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n+pub fn struct_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n@@ -448,12 +407,12 @@ fn struct_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n     found\n }\n \n-fn get_symbol(data: @~[u8], id: ast::node_id) -> ~str {\n+pub fn get_symbol(data: @~[u8], id: ast::node_id) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n \n // Something that a name can resolve to.\n-enum def_like {\n+pub enum def_like {\n     dl_def(ast::def),\n     dl_impl(ast::def_id),\n     dl_field\n@@ -468,7 +427,7 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n }\n \n /// Iterates over the language items in the given crate.\n-fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n+pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     for reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n@@ -485,9 +444,9 @@ fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n }\n \n /// Iterates over all the paths in the given crate.\n-fn each_path(intr: @ident_interner, cdata: cmd,\n-             get_crate_data: GetCrateDataCb,\n-             f: fn(&str, def_like) -> bool) {\n+pub fn each_path(intr: @ident_interner, cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: fn(&str, def_like) -> bool) {\n     let root = reader::Doc(cdata.data);\n     let items = reader::get_doc(root, tag_items);\n     let items_data = reader::get_doc(items, tag_items_data);\n@@ -575,21 +534,21 @@ fn each_path(intr: @ident_interner, cdata: cmd,\n     }\n }\n \n-fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n+pub fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n     -> ast_map::path {\n     item_path(intr, lookup_item(id, cdata.data))\n }\n \n-type decode_inlined_item = fn(\n+pub type decode_inlined_item = fn(\n     cdata: cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,\n     par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n \n-fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n-                      id: ast::node_id,\n-                      decode_inlined_item: decode_inlined_item\n-                     ) -> csearch::found_ast {\n+pub fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n+                          id: ast::node_id,\n+                          decode_inlined_item: decode_inlined_item)\n+                       -> csearch::found_ast {\n     debug!(\"Looking up item: %d\", id);\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(intr, item_doc));\n@@ -612,7 +571,7 @@ fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n     }\n }\n \n-fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                      tcx: ty::ctxt) -> ~[ty::VariantInfo] {\n     let data = cdata.data;\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n@@ -646,14 +605,18 @@ fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n }\n \n // NB: These types are duplicated in resolve.rs\n-type method_info = {\n+pub type method_info = {\n     did: ast::def_id,\n     n_tps: uint,\n     ident: ast::ident,\n     self_type: ast::self_ty_\n };\n \n-type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n+pub type _impl = {\n+    did: ast::def_id,\n+    ident: ast::ident,\n+    methods: ~[@method_info]\n+};\n \n fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n@@ -699,10 +662,10 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n     rslt\n }\n \n-fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n-                     m_id: ast::node_id, name: Option<ast::ident>,\n-                     get_cdata: fn(ast::crate_num) -> cmd)\n-                  -> @~[@_impl] {\n+pub fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n+                         m_id: ast::node_id, name: Option<ast::ident>,\n+                         get_cdata: fn(ast::crate_num) -> cmd)\n+                      -> @~[@_impl] {\n \n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n@@ -730,8 +693,8 @@ fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n }\n \n /* Works for both classes and traits */\n-fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                     tcx: ty::ctxt) -> @~[ty::method] {\n+pub fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+                         tcx: ty::ctxt) -> @~[ty::method] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n@@ -754,8 +717,8 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     @result\n }\n \n-fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n-                              id: ast::node_id, tcx: ty::ctxt) ->\n+pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n+                                  id: ast::node_id, tcx: ty::ctxt) ->\n         ~[ProvidedTraitMethodInfo] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n@@ -794,7 +757,8 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n }\n \n /// Returns the supertraits of the given trait.\n-fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n+pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+                    -> ~[ty::t] {\n     let results = dvec::DVec();\n     let item_doc = lookup_item(id, cdata.data);\n     for reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n@@ -806,9 +770,9 @@ fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n // If the item in question is a trait, returns its set of methods and\n // their self types. Otherwise, returns none. This overlaps in an\n // annoying way with get_trait_methods.\n-fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n-                             node_id: ast::node_id)\n-                          -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n+pub fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n+                                 node_id: ast::node_id)\n+                              -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Trait {\n@@ -823,9 +787,9 @@ fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n     return Some(resulting_methods);\n }\n \n-fn get_type_name_if_impl(intr: @ident_interner,\n-                         cdata: cmd,\n-                         node_id: ast::node_id) -> Option<ast::ident> {\n+pub fn get_type_name_if_impl(intr: @ident_interner,\n+                             cdata: cmd,\n+                             node_id: ast::node_id) -> Option<ast::ident> {\n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Impl {\n         return None;\n@@ -838,10 +802,10 @@ fn get_type_name_if_impl(intr: @ident_interner,\n     return None;\n }\n \n-fn get_static_methods_if_impl(intr: @ident_interner,\n-                               cdata: cmd,\n-                               node_id: ast::node_id) ->\n-                               Option<~[StaticMethodInfo]> {\n+pub fn get_static_methods_if_impl(intr: @ident_interner,\n+                                  cdata: cmd,\n+                                  node_id: ast::node_id)\n+                               -> Option<~[StaticMethodInfo]> {\n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Impl {\n         return None;\n@@ -884,9 +848,9 @@ fn get_static_methods_if_impl(intr: @ident_interner,\n     return Some(dvec::unwrap(move static_impl_methods));\n }\n \n-fn get_item_attrs(cdata: cmd,\n-                  node_id: ast::node_id,\n-                  f: fn(~[@ast::meta_item])) {\n+pub fn get_item_attrs(cdata: cmd,\n+                      node_id: ast::node_id,\n+                      f: fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n     for reader::tagged_docs(item, tag_attributes) |attributes| {\n@@ -905,7 +869,7 @@ pure fn family_to_visibility(family: Family) -> ast::visibility {\n     }\n }\n \n-fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n+pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n     -> ~[ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n@@ -1050,14 +1014,14 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n     out.write_str(~\"\\n\\n\");\n }\n \n-fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n+pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n     return get_attributes(reader::Doc(data));\n }\n \n-type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n-                  vers: ~str, hash: ~str};\n+pub type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n+                      vers: ~str, hash: ~str};\n \n-fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n+pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n@@ -1087,13 +1051,13 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n     out.write_str(~\"\\n\");\n }\n \n-fn get_crate_hash(data: @~[u8]) -> ~str {\n+pub fn get_crate_hash(data: @~[u8]) -> ~str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     return str::from_bytes(reader::doc_data(hashdoc));\n }\n \n-fn get_crate_vers(data: @~[u8]) -> ~str {\n+pub fn get_crate_vers(data: @~[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     return match attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n@@ -1116,8 +1080,8 @@ fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n     }\n }\n \n-fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n-                       out: io::Writer) {\n+pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n+                           out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n@@ -1129,7 +1093,7 @@ fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n // external crates - if those types further refer to types in other crates\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n-fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n+pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n     if did.crate == ast::local_crate {\n         return ast::def_id { crate: cdata.cnum, node: did.node };\n     }"}, {"sha": "6e7e504eb4600ce6d51d93cf4c82a77b004eb87a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -51,28 +51,15 @@ use syntax::{ast_util, visit};\n use syntax;\n use writer = std::ebml::writer;\n \n-export encode_parms;\n-export encode_metadata;\n-export encoded_ty;\n-export reachable;\n-export encode_inlined_item;\n-export metadata_encoding_version;\n-\n // used by astencode:\n-export def_to_str;\n-export encode_ctxt;\n-export write_type;\n-export write_vstore;\n-export encode_def_id;\n-\n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = fn@(ecx: @encode_ctxt,\n                                    ebml_w: writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n-type encode_parms = {\n+pub type encode_parms = {\n     diag: span_handler,\n     tcx: ty::ctxt,\n     reachable: HashMap<ast::node_id, ()>,\n@@ -97,7 +84,7 @@ type stats = {\n     mut n_inlines: uint\n };\n \n-enum encode_ctxt = {\n+pub enum encode_ctxt = {\n     diag: span_handler,\n     tcx: ty::ctxt,\n     stats: stats,\n@@ -111,7 +98,7 @@ enum encode_ctxt = {\n     type_abbrevs: abbrev_map\n };\n \n-fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n+pub fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n@@ -125,7 +112,7 @@ fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                          ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n+pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n@@ -177,7 +164,7 @@ fn encode_family(ebml_w: writer::Encoder, c: char) {\n     ebml_w.end_tag();\n }\n \n-fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n+pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n@@ -208,7 +195,7 @@ fn encode_variant_id(ebml_w: writer::Encoder, vid: def_id) {\n     ebml_w.end_tag();\n }\n \n-fn write_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n+pub fn write_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -218,8 +205,8 @@ fn write_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                vstore: ty::vstore) {\n+pub fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n+                    vstore: ty::vstore) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -1156,13 +1143,13 @@ fn encode_hash(ebml_w: writer::Encoder, hash: &str) {\n }\n \n // NB: Increment this as you change the metadata encoding version.\n-const metadata_encoding_version : &[u8] = &[0x72, //'r' as u8,\n-                                            0x75, //'u' as u8,\n-                                            0x73, //'s' as u8,\n-                                            0x74, //'t' as u8,\n-                                            0, 0, 0, 1 ];\n+pub const metadata_encoding_version : &[u8] = &[0x72, //'r' as u8,\n+                                                0x75, //'u' as u8,\n+                                                0x73, //'s' as u8,\n+                                                0x74, //'t' as u8,\n+                                                0, 0, 0, 1 ];\n \n-fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n+pub fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let stats =\n         {mut inline_bytes: 0,\n@@ -1260,7 +1247,7 @@ fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n }\n \n // Get the encoded string for a type\n-fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n+pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n     let cx = @tyencode::ctxt {\n         diag: tcx.diag,\n         ds: def_to_str,"}, {"sha": "cd0544202a757f150575572138dbcc5bd1b4054d", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -21,34 +21,23 @@ use core::result::Result;\n use core::result;\n use core::str;\n \n-export FileSearch;\n-export mk_filesearch;\n-export pick;\n-export pick_file;\n-export search;\n-export relative_target_lib_path;\n-export get_cargo_sysroot;\n-export get_cargo_root;\n-export get_cargo_root_nearest;\n-export libdir;\n-\n-type pick<T> = fn(path: &Path) -> Option<T>;\n-\n-fn pick_file(file: Path, path: &Path) -> Option<Path> {\n+pub type pick<T> = fn(path: &Path) -> Option<T>;\n+\n+pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n     if path.file_path() == file { option::Some(copy *path) }\n     else { option::None }\n }\n \n-trait FileSearch {\n+pub trait FileSearch {\n     fn sysroot() -> Path;\n     fn lib_search_paths() -> ~[Path];\n     fn get_target_lib_path() -> Path;\n     fn get_target_lib_file_path(file: &Path) -> Path;\n }\n \n-fn mk_filesearch(maybe_sysroot: Option<Path>,\n-                 target_triple: &str,\n-                 +addl_lib_search_paths: ~[Path]) -> FileSearch {\n+pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n+                     target_triple: &str,\n+                     +addl_lib_search_paths: ~[Path]) -> FileSearch {\n     type filesearch_impl = {sysroot: Path,\n                             addl_lib_search_paths: ~[Path],\n                             target_triple: ~str};\n@@ -85,7 +74,7 @@ fn mk_filesearch(maybe_sysroot: Option<Path>,\n      target_triple: str::from_slice(target_triple)} as FileSearch\n }\n \n-fn search<T: Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {\n+pub fn search<T: Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n@@ -105,7 +94,7 @@ fn search<T: Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {\n     return rslt;\n }\n \n-fn relative_target_lib_path(target_triple: &str) -> Path {\n+pub fn relative_target_lib_path(target_triple: &str) -> Path {\n     Path(libdir()).push_many([~\"rustc\",\n                               str::from_slice(target_triple),\n                               libdir()])\n@@ -130,11 +119,11 @@ fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n     }\n }\n \n-fn get_cargo_sysroot() -> Result<Path, ~str> {\n+pub fn get_cargo_sysroot() -> Result<Path, ~str> {\n     result::Ok(get_or_default_sysroot().push_many([libdir(), ~\"cargo\"]))\n }\n \n-fn get_cargo_root() -> Result<Path, ~str> {\n+pub fn get_cargo_root() -> Result<Path, ~str> {\n     match os::getenv(~\"CARGO_ROOT\") {\n         Some(ref _p) => result::Ok(Path((*_p))),\n         None => match os::homedir() {\n@@ -144,7 +133,7 @@ fn get_cargo_root() -> Result<Path, ~str> {\n     }\n }\n \n-fn get_cargo_root_nearest() -> Result<Path, ~str> {\n+pub fn get_cargo_root_nearest() -> Result<Path, ~str> {\n     do result::chain(get_cargo_root()) |p| {\n         let cwd = os::getcwd();\n         let cwd_cargo = cwd.push(\".cargo\");\n@@ -184,7 +173,7 @@ fn get_cargo_lib_path_nearest() -> Result<Path, ~str> {\n \n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n-fn libdir() -> ~str {\n+pub fn libdir() -> ~str {\n    let libdir = env!(\"CFG_LIBDIR\");\n    if str::is_empty(libdir) {\n       fail ~\"rustc compiled without CFG_LIBDIR environment variable\";"}, {"sha": "3979eeee87e29d07ff7a82f061ca71769fdcd29e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -35,25 +35,15 @@ use core::str;\n use core::uint;\n use core::vec;\n \n-export os;\n-export os_macos, os_win32, os_linux, os_freebsd, os_android;\n-export ctxt;\n-export load_library_crate;\n-export list_file_metadata;\n-export note_linkage_attrs;\n-export crate_name_from_metas;\n-export metadata_matches;\n-export meta_section_name;\n-\n-enum os {\n+pub enum os {\n     os_macos,\n     os_win32,\n     os_linux,\n     os_android,\n     os_freebsd\n }\n \n-type ctxt = {\n+pub type ctxt = {\n     diag: span_handler,\n     filesearch: FileSearch,\n     span: span,\n@@ -65,7 +55,7 @@ type ctxt = {\n     intr: @ident_interner\n };\n \n-fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n+pub fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     match find_library_crate(cx) {\n       Some(ref t) => return (/*bad*/copy *t),\n       None => {\n@@ -152,7 +142,7 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n+pub fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     match vec::last_opt(name_items) {\n       Some(i) => {\n@@ -167,8 +157,8 @@ fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n     }\n }\n \n-fn note_linkage_attrs(intr: @ident_interner, diag: span_handler,\n-                      attrs: ~[ast::attribute]) {\n+pub fn note_linkage_attrs(intr: @ident_interner, diag: span_handler,\n+                          attrs: ~[ast::attribute]) {\n     for attr::find_linkage_metas(attrs).each |mi| {\n         diag.handler().note(fmt!(\"meta: %s\",\n               pprust::meta_item_to_str(*mi,intr)));\n@@ -186,8 +176,8 @@ fn crate_matches(crate_data: @~[u8], +metas: ~[@ast::meta_item],\n     metadata_matches(linkage_metas, metas)\n }\n \n-fn metadata_matches(extern_metas: ~[@ast::meta_item],\n-                    local_metas: ~[@ast::meta_item]) -> bool {\n+pub fn metadata_matches(extern_metas: ~[@ast::meta_item],\n+                        local_metas: ~[@ast::meta_item]) -> bool {\n \n     debug!(\"matching %u metadata requirements against %u items\",\n            vec::len(local_metas), vec::len(extern_metas));\n@@ -250,7 +240,7 @@ fn get_metadata_section(os: os,\n     }\n }\n \n-fn meta_section_name(os: os) -> ~str {\n+pub fn meta_section_name(os: os) -> ~str {\n     match os {\n       os_macos => ~\"__DATA,__note.rustc\",\n       os_win32 => ~\".note.rustc\",\n@@ -261,8 +251,8 @@ fn meta_section_name(os: os) -> ~str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(intr: @ident_interner,\n-                      os: os, path: &Path, out: io::Writer) {\n+pub fn list_file_metadata(intr: @ident_interner,\n+                          os: os, path: &Path, out: io::Writer) {\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {"}, {"sha": "78d5be4d4ae19d14db4754c3d027ff4b0054e024", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -8,37 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[legacy_exports];\n-\n-export encoder;\n-export creader;\n-export cstore;\n-export csearch;\n-export common;\n-export decoder;\n-export tyencode;\n-export tydecode;\n-export loader;\n-export filesearch;\n-\n-#[legacy_exports]\n-mod common;\n-#[legacy_exports]\n-mod tyencode;\n-#[legacy_exports]\n-mod tydecode;\n-#[legacy_exports]\n-mod encoder;\n-#[legacy_exports]\n-mod decoder;\n-#[legacy_exports]\n-mod creader;\n-#[legacy_exports]\n-mod cstore;\n-#[legacy_exports]\n-mod csearch;\n-#[legacy_exports]\n-mod loader;\n-#[legacy_exports]\n-mod filesearch;\n+pub mod common;\n+pub mod tyencode;\n+pub mod tydecode;\n+pub mod encoder;\n+pub mod decoder;\n+pub mod creader;\n+pub mod cstore;\n+pub mod csearch;\n+pub mod loader;\n+pub mod filesearch;\n "}, {"sha": "c50666d039fce15f5c3bfe1811ab1d67095e9c0b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -30,12 +30,6 @@ use syntax::ast_util;\n use syntax::ast_util::respan;\n use std::map::HashMap;\n \n-export parse_state_from_data;\n-export parse_arg_data, parse_ty_data, parse_def_id, parse_ident;\n-export parse_bounds_data;\n-export pstate;\n-export DefIdSource, NominalType, TypeWithId, TypeParameter;\n-\n // Compact string representation for ty::t values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n@@ -50,7 +44,7 @@ export DefIdSource, NominalType, TypeWithId, TypeParameter;\n // def-id will depend on where it originated from.  Therefore, the conversion\n // function is given an indicator of the source of the def-id.  See\n // astencode.rs for more information.\n-enum DefIdSource {\n+pub enum DefIdSource {\n     // Identifies a struct, trait, enum, etc.\n     NominalType,\n \n@@ -62,7 +56,7 @@ enum DefIdSource {\n }\n type conv_did = fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n \n-type pstate = {data: @~[u8], crate: int, mut pos: uint, tcx: ty::ctxt};\n+pub type pstate = {data: @~[u8], crate: int, mut pos: uint, tcx: ty::ctxt};\n \n fn peek(st: @pstate) -> char {\n     st.data[st.pos] as char\n@@ -80,7 +74,7 @@ fn next_byte(st: @pstate) -> u8 {\n     return b;\n }\n \n-fn parse_ident(st: @pstate, last: char) -> ast::ident {\n+pub fn parse_ident(st: @pstate, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n@@ -94,21 +88,19 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n     return st.tcx.sess.ident_of(rslt);\n }\n \n-fn parse_state_from_data(data: @~[u8], crate_num: int,\n-                         pos: uint, tcx: ty::ctxt)\n-    -> @pstate\n-{\n+pub fn parse_state_from_data(data: @~[u8], crate_num: int,\n+                         pos: uint, tcx: ty::ctxt) -> @pstate {\n     @{data: data, crate: crate_num, mut pos: pos, tcx: tcx}\n }\n \n-fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n-                 conv: conv_did) -> ty::t {\n+pub fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                     conv: conv_did) -> ty::t {\n     let st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(st, conv)\n }\n \n-fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n-                  conv: conv_did) -> ty::arg {\n+pub fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                      conv: conv_did) -> ty::arg {\n     let st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_arg(st, conv)\n }\n@@ -466,7 +458,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n \n \n // Rust metadata parsing\n-fn parse_def_id(buf: &[u8]) -> ast::def_id {\n+pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let mut colon_idx = 0u;\n     let len = vec::len(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n@@ -491,10 +483,9 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     ast::def_id { crate: crate_num, node: def_num }\n }\n \n-fn parse_bounds_data(data: @~[u8], start: uint,\n-                     crate_num: int, tcx: ty::ctxt, conv: conv_did)\n-    -> @~[ty::param_bound]\n-{\n+pub fn parse_bounds_data(data: @~[u8], start: uint,\n+                         crate_num: int, tcx: ty::ctxt, conv: conv_did)\n+                      -> @~[ty::param_bound] {\n     let st = parse_state_from_data(data, crate_num, start, tcx);\n     parse_bounds(st, conv)\n }"}, {"sha": "f06bbb5a0a8ec9bad699883faede554604f8283f", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464ec27fd3e0da18680ac5c649f83c59772c856b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=464ec27fd3e0da18680ac5c649f83c59772c856b", "patch": "@@ -26,17 +26,7 @@ use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n use middle::ty::Vid;\n \n-export ctxt;\n-export ty_abbrev;\n-export ac_no_abbrevs;\n-export ac_use_abbrevs;\n-export enc_ty;\n-export enc_bounds;\n-export enc_mode;\n-export enc_arg;\n-export enc_vstore;\n-\n-struct ctxt {\n+pub struct ctxt {\n     diag: span_handler,\n     // Def -> str Callback:\n     ds: fn@(def_id) -> ~str,\n@@ -49,9 +39,12 @@ struct ctxt {\n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n-type ty_abbrev = {pos: uint, len: uint, s: @~str};\n+pub type ty_abbrev = {pos: uint, len: uint, s: @~str};\n \n-enum abbrev_ctxt { ac_no_abbrevs, ac_use_abbrevs(HashMap<ty::t, ty_abbrev>), }\n+pub enum abbrev_ctxt {\n+    ac_no_abbrevs,\n+    ac_use_abbrevs(HashMap<ty::t, ty_abbrev>),\n+}\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     match cx.abbrevs {\n@@ -60,7 +53,7 @@ fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     }\n }\n \n-fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n+pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(t) {\n@@ -197,7 +190,7 @@ fn enc_bound_region(w: io::Writer, cx: @ctxt, br: ty::bound_region) {\n     }\n }\n \n-fn enc_vstore(w: io::Writer, cx: @ctxt, v: ty::vstore) {\n+pub fn enc_vstore(w: io::Writer, cx: @ctxt, v: ty::vstore) {\n     w.write_char('/');\n     match v {\n       ty::vstore_fixed(u) => {\n@@ -342,12 +335,12 @@ fn enc_proto(w: io::Writer, proto: Proto) {\n     }\n }\n \n-fn enc_arg(w: io::Writer, cx: @ctxt, arg: ty::arg) {\n+pub fn enc_arg(w: io::Writer, cx: @ctxt, arg: ty::arg) {\n     enc_mode(w, cx, arg.mode);\n     enc_ty(w, cx, arg.ty);\n }\n \n-fn enc_mode(w: io::Writer, cx: @ctxt, m: mode) {\n+pub fn enc_mode(w: io::Writer, cx: @ctxt, m: mode) {\n     match ty::resolved_mode(cx.tcx, m) {\n       by_move => w.write_char('-'),\n       by_copy => w.write_char('+'),\n@@ -386,7 +379,7 @@ fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n     enc_ty(w, cx, ft.sig.output);\n }\n \n-fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n+pub fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n         match *bound {\n           ty::bound_owned => w.write_char('S'),"}]}