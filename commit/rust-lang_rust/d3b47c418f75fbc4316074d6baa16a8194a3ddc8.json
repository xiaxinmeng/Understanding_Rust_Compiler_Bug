{"sha": "d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYjQ3YzQxOGY3NWZiYzQzMTYwNzRkNmJhYTE2YTgxOTRhM2RkYzg=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T05:28:49Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T05:28:49Z"}, "message": "WIP: Support array indexing including a `get_unchecked` test.\n\nRequired supporting:\n  * Trait method lookup\n  * The `offset` intrinsic\n  * Fat pointers\n  * Unsizing coercions and some raw pointer and integer casts", "tree": {"sha": "c9b99d9a8a0a14a65a9bb3a87a9307a690368e20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9b99d9a8a0a14a65a9bb3a87a9307a690368e20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "html_url": "https://github.com/rust-lang/rust/commit/d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59cf49baf4c4c3a0e558fa720056f27ceb0e067f", "url": "https://api.github.com/repos/rust-lang/rust/commits/59cf49baf4c4c3a0e558fa720056f27ceb0e067f", "html_url": "https://github.com/rust-lang/rust/commit/59cf49baf4c4c3a0e558fa720056f27ceb0e067f"}], "stats": {"total": 248, "additions": 208, "deletions": 40}, "files": [{"sha": "de49d6e1564a4a914fbae0178bdf718ec3cd3561", "filename": "src/interpreter.rs", "status": "modified", "additions": 192, "deletions": 25, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "patch": "@@ -1,13 +1,15 @@\n use rustc::middle::const_eval;\n use rustc::middle::def_id::DefId;\n use rustc::middle::subst::{self, Subst, Substs};\n+use rustc::middle::traits;\n use rustc::middle::ty::{self, TyCtxt};\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n use std::ops::Deref;\n use std::rc::Rc;\n+use syntax::codemap::DUMMY_SP;\n \n use error::EvalResult;\n use memory::{self, FieldRepr, Memory, Pointer, Repr};\n@@ -226,32 +228,57 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 let func_ty = self.current_frame().mir.operand_ty(self.tcx, func);\n \n                 match func_ty.sty {\n-                    ty::TyFnDef(def_id, substs, bare_fn_ty) => {\n+                    ty::TyFnDef(def_id, substs, fn_ty) => {\n+                        let substs = self.tcx.mk_substs(\n+                            substs.subst(self.tcx, self.current_substs()));\n+\n                         use syntax::abi::Abi;\n-                        match bare_fn_ty.abi {\n-                            Abi::RustIntrinsic => match &self.tcx.item_name(def_id).as_str()[..] {\n-                                \"size_of\" => {\n-                                    let ty = *substs.types.get(subst::FnSpace, 0);\n-                                    let ret_ptr = &mir::Lvalue::ReturnPointer;\n-                                    let dest = try!(self.eval_lvalue(ret_ptr));\n-                                    let dest_repr = self.lvalue_repr(ret_ptr);\n-                                    let size = PrimVal::from_usize(self.ty_to_repr(ty).size(),\n-                                                                   &dest_repr);\n-                                    try!(self.memory.write_primval(dest, size));\n-\n-                                    // Since we pushed no stack frame, the main loop will act as if\n-                                    // the call just completed and it's returning to the current\n-                                    // frame.\n-                                    TerminatorTarget::Call\n-                                },\n-\n-                                name => panic!(\"can't handle intrinsic named {}\", name),\n-                            },\n+                        match fn_ty.abi {\n+                            Abi::RustIntrinsic => {\n+                                let ret_ptr = &mir::Lvalue::ReturnPointer;\n+                                let dest = try!(self.eval_lvalue(ret_ptr));\n+                                let dest_repr = self.lvalue_repr(ret_ptr);\n+\n+                                match &self.tcx.item_name(def_id).as_str()[..] {\n+                                    \"size_of\" => {\n+                                        let ty = *substs.types.get(subst::FnSpace, 0);\n+                                        let size = PrimVal::from_usize(\n+                                            self.ty_to_repr(ty).size(),\n+                                            &dest_repr\n+                                        );\n+                                        try!(self.memory.write_primval(dest, size));\n+                                    }\n+\n+                                    \"offset\" => {\n+                                        let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n+                                        let pointee_size = self.ty_to_repr(pointee_ty).size() as isize;\n+                                        let ptr_arg = try!(self.eval_operand(&args[0]));\n+                                        let offset_arg = try!(self.eval_operand(&args[1]));\n+                                        let ptr = try!(self.memory.read_ptr(ptr_arg));\n+                                        // TODO(tsion): read_isize\n+                                        let offset = try!(self.memory.read_i64(offset_arg));\n+                                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n+                                        try!(self.memory.write_ptr(dest, result_ptr));\n+                                    }\n+\n+                                    name => panic!(\"can't handle intrinsic named {}\", name),\n+                                }\n+\n+                                // Since we pushed no stack frame, the main loop will act\n+                                // as if the call just completed and it's returning to the\n+                                // current frame.\n+                                TerminatorTarget::Call\n+                            }\n \n                             Abi::Rust => {\n+                                // Only trait methods can have a Self parameter.\n+                                let (def_id, substs) = if substs.self_ty().is_some() {\n+                                    self.trait_method(def_id, substs)\n+                                } else {\n+                                    (def_id, substs)\n+                                };\n+\n                                 let mir = self.load_mir(def_id);\n-                                let substs = self.tcx.mk_substs(\n-                                    substs.subst(self.tcx, self.current_substs()));\n                                 self.substs_stack.push(substs);\n                                 try!(self.push_stack_frame(mir, args, return_ptr));\n                                 TerminatorTarget::Call\n@@ -372,6 +399,51 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 self.memory.write_ptr(dest, ptr)\n             }\n \n+            Cast(kind, ref operand, dest_ty) => {\n+                fn pointee_type<'tcx>(ptr_ty: ty::Ty<'tcx>) -> Option<ty::Ty<'tcx>> {\n+                    match ptr_ty.sty {\n+                        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+                        ty::TyBox(ty) => {\n+                            Some(ty)\n+                        }\n+\n+                        _ => None,\n+                    }\n+                }\n+\n+                let src = try!(self.eval_operand(operand));\n+                let src_ty = self.current_frame().mir.operand_ty(self.tcx, operand);\n+\n+                use rustc::mir::repr::CastKind::*;\n+                match kind {\n+                    Unsize => {\n+                        try!(self.memory.copy(src, dest, 8));\n+                        let src_pointee_ty = pointee_type(src_ty).unwrap();\n+                        let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n+\n+                        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n+                            (&ty::TyArray(_, length), &ty::TySlice(_)) =>\n+                                // TODO(tsion): Add write_usize? (Host/target issues.)\n+                                self.memory.write_u64(dest.offset(8), length as u64),\n+\n+                            _ => panic!(\"can't handle cast: {:?}\", rvalue),\n+                        }\n+                    }\n+\n+                    Misc => {\n+                        if pointee_type(src_ty).is_some() && pointee_type(dest_ty).is_some() {\n+                            self.memory.copy(src, dest, 8)\n+                        } else {\n+                            self.memory.copy(src, dest, 8)\n+                            // panic!(\"can't handle cast: {:?}\", rvalue);\n+                        }\n+                    }\n+\n+                    _ => panic!(\"can't handle cast: {:?}\", rvalue),\n+                }\n+            }\n+\n             ref r => panic!(\"can't handle rvalue: {:?}\", r),\n         }\n     }\n@@ -544,9 +616,15 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 length: length,\n             },\n \n-            ty::TyRef(_, ty::TypeAndMut { ty, .. }) | ty::TyBox(ty) => Repr::Pointer {\n-                target: Box::new(self.ty_to_repr(ty))\n-            },\n+            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyBox(ty) => {\n+                if ty.is_sized(&self.tcx.empty_parameter_environment(), DUMMY_SP) {\n+                    Repr::Pointer\n+                } else {\n+                    Repr::FatPointer\n+                }\n+            }\n \n             ref t => panic!(\"can't convert type to repr: {:?}\", t),\n         }\n@@ -582,6 +660,95 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n+        use rustc::middle::infer;\n+        use syntax::ast;\n+\n+        // Do the initial selection for the obligation. This yields the shallow result we are\n+        // looking for -- that is, what specific impl.\n+        let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables);\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+        let obligation = traits::Obligation::new(\n+            traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+            trait_ref.to_poly_trait_predicate(),\n+        );\n+        let selection = selcx.select(&obligation).unwrap().unwrap();\n+\n+        // Currently, we use a fulfillment context to completely resolve all nested obligations.\n+        // This is because they can inform the inference of the impl's type parameters.\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infer::drain_fulfillment_cx_or_panic(\n+            DUMMY_SP, &infcx, &mut fulfill_cx, &vtable\n+        );\n+\n+        vtable\n+    }\n+\n+    /// Trait method, which has to be resolved to an impl method.\n+    pub fn trait_method(&self, def_id: DefId, substs: &'tcx Substs<'tcx>)\n+            -> (DefId, &'tcx Substs<'tcx>) {\n+        let method_item = self.tcx.impl_or_trait_item(def_id);\n+        let trait_id = method_item.container().id();\n+        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n+        match self.fulfill_obligation(trait_ref) {\n+            traits::VtableImpl(vtable_impl) => {\n+                let impl_did = vtable_impl.impl_def_id;\n+                let mname = self.tcx.item_name(def_id);\n+                // Create a concatenated set of substitutions which includes those from the\n+                // impl and those from the method:\n+                let impl_substs = vtable_impl.substs.with_method_from(&substs);\n+                let substs = self.tcx.mk_substs(impl_substs);\n+                let mth = self.tcx.get_impl_method(impl_did, substs, mname);\n+\n+                println!(\"{:?} {:?}\", mth.method.def_id, mth.substs);\n+                (mth.method.def_id, mth.substs)\n+            }\n+            traits::VtableClosure(vtable_closure) => {\n+                // The substitutions should have no type parameters remaining after passing\n+                // through fulfill_obligation\n+                let trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                unimplemented!()\n+                // vtable_closure.closure_def_id\n+                // vtable_closure.substs\n+                // trait_closure_kind\n+\n+                // let method_ty = def_ty(tcx, def_id, substs);\n+                // let fn_ptr_ty = match method_ty.sty {\n+                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                //     _ => unreachable!(\"expected fn item type, found {}\",\n+                //                       method_ty)\n+                // };\n+                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            }\n+            traits::VtableFnPointer(fn_ty) => {\n+                let trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                unimplemented!()\n+                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+\n+                // let method_ty = def_ty(tcx, def_id, substs);\n+                // let fn_ptr_ty = match method_ty.sty {\n+                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                //     _ => unreachable!(\"expected fn item type, found {}\",\n+                //                       method_ty)\n+                // };\n+                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            }\n+            traits::VtableObject(ref data) => {\n+                unimplemented!()\n+                // Callee {\n+                //     data: Virtual(traits::get_vtable_index_of_object_method(\n+                //                   tcx, data, def_id)),\n+                //                   ty: def_ty(tcx, def_id, substs)\n+                // }\n+            }\n+            vtable => unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n+        }\n+    }\n }\n \n impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {"}, {"sha": "a7da9e19dfd9ba5fce78e07e5aa4b3a6fac45a0f", "filename": "src/memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "patch": "@@ -43,6 +43,9 @@ pub enum Repr {\n     I8, I16, I32, I64,\n     U8, U16, U32, U64,\n \n+    Pointer,\n+    FatPointer,\n+\n     /// The representation for product types including tuples, structs, and the contents of enum\n     /// variants.\n     Product {\n@@ -65,10 +68,6 @@ pub enum Repr {\n         /// Number of elements.\n         length: usize,\n     },\n-\n-    Pointer {\n-        target: Box<Repr>,\n-    }\n }\n \n impl Memory {\n@@ -362,7 +361,8 @@ impl Repr {\n             Repr::Product { size, .. } => size,\n             Repr::Sum { ref discr, max_variant_size, .. } => discr.size() + max_variant_size,\n             Repr::Array { ref elem, length } => elem.size() * length,\n-            Repr::Pointer { .. } => POINTER_SIZE,\n+            Repr::Pointer => POINTER_SIZE,\n+            Repr::FatPointer => POINTER_SIZE * 2,\n         }\n     }\n }"}, {"sha": "1add02561e38ed21dde2f002d7eec3a5c8424ca2", "filename": "test/arrays.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/test%2Farrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/test%2Farrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Farrays.rs?ref=d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "patch": "@@ -6,16 +6,6 @@ fn empty_array() -> [u16; 0] {\n     []\n }\n \n-#[miri_run]\n-fn singular_array() -> [u16; 1] {\n-    [42]\n-}\n-\n-#[miri_run]\n-fn deuce_array() -> [u16; 2] {\n-    [42, 53]\n-}\n-\n #[miri_run]\n fn big_array() -> [u16; 5] {\n     [5, 4, 3, 2, 1]\n@@ -25,3 +15,9 @@ fn big_array() -> [u16; 5] {\n fn array_array() -> [[u8; 2]; 3] {\n     [[5, 4], [3, 2], [1, 0]]\n }\n+\n+#[miri_run]\n+fn indexing() -> i32 {\n+    let a = [0, 10, 20, 30];\n+    unsafe { *a.get_unchecked(2) }\n+}"}, {"sha": "c40165909df02335044ad4e7b7145ca0a0d8eb57", "filename": "test/heap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/test%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b47c418f75fbc4316074d6baa16a8194a3ddc8/test%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fheap.rs?ref=d3b47c418f75fbc4316074d6baa16a8194a3ddc8", "patch": "@@ -10,3 +10,8 @@ fn make_box() -> Box<(i16, i16)> {\n fn make_box_syntax() -> Box<(i16, i16)> {\n     box (1, 2)\n }\n+\n+// #[miri_run]\n+// fn make_vec() -> Vec<i32> {\n+//     Vec::new()\n+// }"}]}