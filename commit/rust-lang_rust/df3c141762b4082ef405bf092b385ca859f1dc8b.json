{"sha": "df3c141762b4082ef405bf092b385ca859f1dc8b", "node_id": "C_kwDOAAsO6NoAKGRmM2MxNDE3NjJiNDA4MmVmNDA1YmYwOTJiMzg1Y2E4NTlmMWRjOGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-08T15:37:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-08T15:37:01Z"}, "message": "Auto merge of #2477 - RalfJung:show-error, r=RalfJung\n\ndon't make it quite so easy to get Miri to panic\n\nPanicking on incorrect `-Zmiri` flags is a bit embarrassing, so let's finally fix that.", "tree": {"sha": "b0afd1e7090e6f3cd42e28eae3ec092d1f0fe52b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0afd1e7090e6f3cd42e28eae3ec092d1f0fe52b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df3c141762b4082ef405bf092b385ca859f1dc8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df3c141762b4082ef405bf092b385ca859f1dc8b", "html_url": "https://github.com/rust-lang/rust/commit/df3c141762b4082ef405bf092b385ca859f1dc8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df3c141762b4082ef405bf092b385ca859f1dc8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "654e15b51c5d177b7d2c2345904a021c4c61f2ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/654e15b51c5d177b7d2c2345904a021c4c61f2ef", "html_url": "https://github.com/rust-lang/rust/commit/654e15b51c5d177b7d2c2345904a021c4c61f2ef"}, {"sha": "b99d7bc77f1b7986954ec8bd2f1c9f80664e8fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b99d7bc77f1b7986954ec8bd2f1c9f80664e8fd4", "html_url": "https://github.com/rust-lang/rust/commit/b99d7bc77f1b7986954ec8bd2f1c9f80664e8fd4"}], "stats": {"total": 129, "additions": 69, "deletions": 60}, "files": [{"sha": "09e2cd3c2867ced1530061991f5a40b685d26a62", "filename": "cargo-miri/src/main.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fmain.rs?ref=df3c141762b4082ef405bf092b385ca859f1dc8b", "patch": "@@ -1,15 +1,17 @@\n #![feature(let_else)]\n #![allow(clippy::useless_format, clippy::derive_partial_eq_without_eq, rustc::internal)]\n \n+#[macro_use]\n+mod util;\n+\n mod arg;\n mod phases;\n mod setup;\n-mod util;\n mod version;\n \n use std::{env, iter};\n \n-use crate::{phases::*, util::*};\n+use crate::phases::*;\n \n fn main() {\n     // Rustc does not support non-UTF-8 arguments so we make no attempt either.\n@@ -73,9 +75,9 @@ fn main() {\n     }\n \n     let Some(first) = args.next() else {\n-        show_error(format!(\n+        show_error!(\n             \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n-        ))\n+        )\n     };\n     match first.as_str() {\n         \"miri\" => phase_cargo_miri(args),"}, {"sha": "93eb3cb174659c7d8337f67be296971a59886169", "filename": "cargo-miri/src/phases.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fphases.rs?ref=df3c141762b4082ef405bf092b385ca859f1dc8b", "patch": "@@ -77,15 +77,15 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     // We cannot know which of those flags take arguments and which do not,\n     // so we cannot detect subcommands later.\n     let Some(subcommand) = args.next() else {\n-        show_error(format!(\"`cargo miri` needs to be called with a subcommand (`run`, `test`)\"));\n+        show_error!(\"`cargo miri` needs to be called with a subcommand (`run`, `test`)\");\n     };\n     let subcommand = match &*subcommand {\n         \"setup\" => MiriCommand::Setup,\n         \"test\" | \"t\" | \"run\" | \"r\" | \"nextest\" => MiriCommand::Forward(subcommand),\n         _ =>\n-            show_error(format!(\n+            show_error!(\n                 \"`cargo miri` supports the following subcommands: `run`, `test`, `nextest`, and `setup`.\"\n-            )),\n+            ),\n     };\n     let verbose = num_arg_flag(\"-v\");\n \n@@ -123,7 +123,7 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n         match arg {\n             Ok(value) => {\n                 if target_dir.is_some() {\n-                    show_error(format!(\"`--target-dir` is provided more than once\"));\n+                    show_error!(\"`--target-dir` is provided more than once\");\n                 }\n                 target_dir = Some(value.into());\n             }\n@@ -456,16 +456,13 @@ pub fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: Runner\n \n     let binary = binary_args.next().unwrap();\n     let file = File::open(&binary)\n-        .unwrap_or_else(|_| show_error(format!(\n+        .unwrap_or_else(|_| show_error!(\n             \"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary\n-        )));\n+        ));\n     let file = BufReader::new(file);\n \n     let info = serde_json::from_reader(file).unwrap_or_else(|_| {\n-        show_error(format!(\n-            \"file {:?} contains outdated or invalid JSON; try `cargo clean`\",\n-            binary\n-        ))\n+        show_error!(\"file {:?} contains outdated or invalid JSON; try `cargo clean`\", binary)\n     });\n     let info = match info {\n         CrateRunInfo::RunWith(info) => info,\n@@ -562,7 +559,7 @@ pub fn phase_rustdoc(mut args: impl Iterator<Item = String>) {\n             // An existing --runtool flag indicates cargo is running in cross-target mode, which we don't support.\n             // Note that this is only passed when cargo is run with the unstable -Zdoctest-xcompile flag;\n             // otherwise, we won't be called as rustdoc at all.\n-            show_error(format!(\"cross-interpreting doctests is not currently supported by Miri.\"));\n+            show_error!(\"cross-interpreting doctests is not currently supported by Miri.\");\n         } else {\n             cmd.arg(arg);\n         }"}, {"sha": "62d6e25a53e0cce51a9dd1f6b184d7d9b8571136", "filename": "cargo-miri/src/setup.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fsetup.rs?ref=df3c141762b4082ef405bf092b385ca859f1dc8b", "patch": "@@ -73,7 +73,7 @@ pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n     if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n         if std::env::var_os(\"XARGO_CHECK\").is_some() {\n             // The user manually gave us a xargo binary; don't do anything automatically.\n-            show_error(format!(\"xargo is too old; please upgrade to the latest version\"))\n+            show_error!(\"xargo is too old; please upgrade to the latest version\")\n         }\n         let mut cmd = cargo();\n         cmd.args(&[\"install\", \"xargo\"]);\n@@ -97,10 +97,10 @@ pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n                 .output()\n                 .expect(\"failed to determine sysroot\");\n             if !output.status.success() {\n-                show_error(format!(\n+                show_error!(\n                     \"Failed to determine sysroot; Miri said:\\n{}\",\n                     String::from_utf8_lossy(&output.stderr).trim_end()\n-                ));\n+                );\n             }\n             let sysroot = std::str::from_utf8(&output.stdout).unwrap();\n             let sysroot = Path::new(sysroot.trim_end_matches('\\n'));\n@@ -121,14 +121,14 @@ pub fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n         }\n     };\n     if !rust_src.exists() {\n-        show_error(format!(\"given Rust source directory `{}` does not exist.\", rust_src.display()));\n+        show_error!(\"given Rust source directory `{}` does not exist.\", rust_src.display());\n     }\n     if rust_src.file_name().and_then(OsStr::to_str) != Some(\"library\") {\n-        show_error(format!(\n+        show_error!(\n             \"given Rust source directory `{}` does not seem to be the `library` subdirectory of \\\n              a Rust source checkout.\",\n             rust_src.display()\n-        ));\n+        );\n     }\n \n     // Next, we need our own libstd. Prepare a xargo project for that purpose.\n@@ -226,11 +226,9 @@ path = \"lib.rs\"\n     // Finally run it!\n     if command.status().expect(\"failed to run xargo\").success().not() {\n         if only_setup {\n-            show_error(format!(\"failed to run xargo, see error details above\"))\n+            show_error!(\"failed to run xargo, see error details above\")\n         } else {\n-            show_error(format!(\n-                \"failed to run xargo; run `cargo miri setup` to see the error details\"\n-            ))\n+            show_error!(\"failed to run xargo; run `cargo miri setup` to see the error details\")\n         }\n     }\n "}, {"sha": "8f29eebaac1008fbe2ab9e57ce89fdbd88f6992f", "filename": "cargo-miri/src/util.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df3c141762b4082ef405bf092b385ca859f1dc8b/cargo-miri%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Futil.rs?ref=df3c141762b4082ef405bf092b385ca859f1dc8b", "patch": "@@ -14,6 +14,15 @@ use serde::{Deserialize, Serialize};\n \n pub use crate::arg::*;\n \n+pub fn show_error(msg: &impl std::fmt::Display) -> ! {\n+    eprintln!(\"fatal error: {msg}\");\n+    std::process::exit(1)\n+}\n+\n+macro_rules! show_error {\n+    ($($tt:tt)*) => { crate::util::show_error(&format_args!($($tt)*)) };\n+}\n+\n /// The information to run a crate with the given environment.\n #[derive(Clone, Serialize, Deserialize)]\n pub struct CrateRunEnv {\n@@ -55,10 +64,10 @@ pub enum CrateRunInfo {\n impl CrateRunInfo {\n     pub fn store(&self, filename: &Path) {\n         let file = File::create(filename)\n-            .unwrap_or_else(|_| show_error(format!(\"cannot create `{}`\", filename.display())));\n+            .unwrap_or_else(|_| show_error!(\"cannot create `{}`\", filename.display()));\n         let file = BufWriter::new(file);\n         serde_json::ser::to_writer(file, self)\n-            .unwrap_or_else(|_| show_error(format!(\"cannot write to `{}`\", filename.display())));\n+            .unwrap_or_else(|_| show_error!(\"cannot write to `{}`\", filename.display()));\n     }\n }\n \n@@ -70,11 +79,6 @@ pub enum MiriCommand {\n     Forward(String),\n }\n \n-pub fn show_error(msg: String) -> ! {\n-    eprintln!(\"fatal error: {}\", msg);\n-    std::process::exit(1)\n-}\n-\n /// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n pub fn escape_for_toml(s: &str) -> String {\n     // We want to surround this string in quotes `\"`. So we first escape all quotes,\n@@ -187,15 +191,15 @@ pub fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n         match buf.trim().to_lowercase().as_ref() {\n             // Proceed.\n             \"\" | \"y\" | \"yes\" => {}\n-            \"n\" | \"no\" => show_error(format!(\"aborting as per your request\")),\n-            a => show_error(format!(\"invalid answer `{}`\", a)),\n+            \"n\" | \"no\" => show_error!(\"aborting as per your request\"),\n+            a => show_error!(\"invalid answer `{}`\", a),\n         };\n     } else {\n         eprintln!(\"Running `{:?}` to {}.\", cmd, text);\n     }\n \n     if cmd.status().unwrap_or_else(|_| panic!(\"failed to execute {:?}\", cmd)).success().not() {\n-        show_error(format!(\"failed to {}\", text));\n+        show_error!(\"failed to {}\", text);\n     }\n }\n "}, {"sha": "ca0787b22983022124e935dfeab4eb9e12373c96", "filename": "src/bin/miri.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/df3c141762b4082ef405bf092b385ca859f1dc8b/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df3c141762b4082ef405bf092b385ca859f1dc8b/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=df3c141762b4082ef405bf092b385ca859f1dc8b", "patch": "@@ -152,11 +152,15 @@ impl rustc_driver::Callbacks for MiriBeRustCompilerCalls {\n     }\n }\n \n-fn show_error(msg: String) -> ! {\n-    eprintln!(\"fatal error: {}\", msg);\n+fn show_error(msg: &impl std::fmt::Display) -> ! {\n+    eprintln!(\"fatal error: {msg}\");\n     std::process::exit(1)\n }\n \n+macro_rules! show_error {\n+    ($($tt:tt)*) => { show_error(&format_args!($($tt)*)) };\n+}\n+\n fn init_early_loggers() {\n     // Note that our `extern crate log` is *not* the same as rustc's; as a result, we have to\n     // initialize them both, and we always initialize `miri`'s first.\n@@ -234,19 +238,19 @@ fn host_sysroot() -> Option<String> {\n                 env::var_os(\"RUSTUP_TOOLCHAIN\").or_else(|| env::var_os(\"MULTIRUST_TOOLCHAIN\"))\n             {\n                 if toolchain_runtime != toolchain {\n-                    show_error(format!(\n+                    show_error!(\n                         \"This Miri got built with local toolchain `{toolchain}`, but now is being run under a different toolchain. \\n\\\n                         Make sure to run Miri in the toolchain it got built with, e.g. via `cargo +{toolchain} miri`.\"\n-                    ));\n+                    )\n                 }\n             }\n             format!(\"{}/toolchains/{}\", home, toolchain)\n         }\n         _ => option_env!(\"RUST_SYSROOT\")\n             .unwrap_or_else(|| {\n-                show_error(format!(\n+                show_error!(\n                     \"To build Miri without rustup, set the `RUST_SYSROOT` env var at build time\",\n-                ))\n+                )\n             })\n             .to_owned(),\n     })\n@@ -272,9 +276,9 @@ fn run_compiler(\n             // Using the built-in default here would be plain wrong, so we *require*\n             // the env var to make sure things make sense.\n             Some(env::var(\"MIRI_SYSROOT\").unwrap_or_else(|_| {\n-                show_error(format!(\n+                show_error!(\n                     \"Miri was invoked in 'target' mode without `MIRI_SYSROOT` or `--sysroot` being set\"\n-                ))\n+                )\n             }))\n         } else {\n             host_default_sysroot\n@@ -379,7 +383,9 @@ fn main() {\n             miri_config.check_abi = false;\n         } else if arg == \"-Zmiri-disable-isolation\" {\n             if matches!(isolation_enabled, Some(true)) {\n-                panic!(\"-Zmiri-disable-isolation cannot be used along with -Zmiri-isolation-error\");\n+                show_error!(\n+                    \"-Zmiri-disable-isolation cannot be used along with -Zmiri-isolation-error\"\n+                );\n             } else {\n                 isolation_enabled = Some(false);\n             }\n@@ -390,7 +396,9 @@ fn main() {\n             miri_config.track_outdated_loads = true;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-isolation-error=\") {\n             if matches!(isolation_enabled, Some(false)) {\n-                panic!(\"-Zmiri-isolation-error cannot be used along with -Zmiri-disable-isolation\");\n+                show_error!(\n+                    \"-Zmiri-isolation-error cannot be used along with -Zmiri-disable-isolation\"\n+                );\n             } else {\n                 isolation_enabled = Some(true);\n             }\n@@ -402,7 +410,7 @@ fn main() {\n                 \"warn-nobacktrace\" =>\n                     miri::IsolatedOp::Reject(miri::RejectOpWith::WarningWithoutBacktrace),\n                 _ =>\n-                    panic!(\n+                    show_error!(\n                         \"-Zmiri-isolation-error must be `abort`, `hide`, `warn`, or `warn-nobacktrace`\"\n                     ),\n             };\n@@ -426,11 +434,11 @@ fn main() {\n             );\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-seed=\") {\n             if miri_config.seed.is_some() {\n-                panic!(\"Cannot specify -Zmiri-seed multiple times!\");\n+                show_error!(\"Cannot specify -Zmiri-seed multiple times!\");\n             }\n             let seed = u64::from_str_radix(param, 16)\n-                        .unwrap_or_else(|_| panic!(\n-                            \"-Zmiri-seed should only contain valid hex digits [0-9a-fA-F] and fit into a u64 (max 16 characters)\"\n+                        .unwrap_or_else(|_| show_error!(\n+                            \"-Zmiri-seed should only contain valid hex digits [0-9a-fA-F] and must fit into a u64 (max 16 characters)\"\n                         ));\n             miri_config.seed = Some(seed);\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-env-exclude=\") {\n@@ -441,7 +449,7 @@ fn main() {\n             let ids: Vec<u64> = match parse_comma_list(param) {\n                 Ok(ids) => ids,\n                 Err(err) =>\n-                    panic!(\n+                    show_error!(\n                         \"-Zmiri-track-pointer-tag requires a comma separated list of valid `u64` arguments: {}\",\n                         err\n                     ),\n@@ -450,14 +458,14 @@ fn main() {\n                 if let Some(id) = id {\n                     miri_config.tracked_pointer_tags.insert(id);\n                 } else {\n-                    panic!(\"-Zmiri-track-pointer-tag requires nonzero arguments\");\n+                    show_error!(\"-Zmiri-track-pointer-tag requires nonzero arguments\");\n                 }\n             }\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-track-call-id=\") {\n             let ids: Vec<u64> = match parse_comma_list(param) {\n                 Ok(ids) => ids,\n                 Err(err) =>\n-                    panic!(\n+                    show_error!(\n                         \"-Zmiri-track-call-id requires a comma separated list of valid `u64` arguments: {}\",\n                         err\n                     ),\n@@ -466,14 +474,14 @@ fn main() {\n                 if let Some(id) = id {\n                     miri_config.tracked_call_ids.insert(id);\n                 } else {\n-                    panic!(\"-Zmiri-track-call-id requires a nonzero argument\");\n+                    show_error!(\"-Zmiri-track-call-id requires a nonzero argument\");\n                 }\n             }\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-track-alloc-id=\") {\n             let ids: Vec<miri::AllocId> = match parse_comma_list::<NonZeroU64>(param) {\n                 Ok(ids) => ids.into_iter().map(miri::AllocId).collect(),\n                 Err(err) =>\n-                    panic!(\n+                    show_error!(\n                         \"-Zmiri-track-alloc-id requires a comma separated list of valid non-zero `u64` arguments: {}\",\n                         err\n                     ),\n@@ -483,11 +491,11 @@ fn main() {\n             let rate = match param.parse::<f64>() {\n                 Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n                 Ok(_) =>\n-                    panic!(\n+                    show_error!(\n                         \"-Zmiri-compare-exchange-weak-failure-rate must be between `0.0` and `1.0`\"\n                     ),\n                 Err(err) =>\n-                    panic!(\n+                    show_error!(\n                         \"-Zmiri-compare-exchange-weak-failure-rate requires a `f64` between `0.0` and `1.0`: {}\",\n                         err\n                     ),\n@@ -496,9 +504,9 @@ fn main() {\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-preemption-rate=\") {\n             let rate = match param.parse::<f64>() {\n                 Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n-                Ok(_) => panic!(\"-Zmiri-preemption-rate must be between `0.0` and `1.0`\"),\n+                Ok(_) => show_error!(\"-Zmiri-preemption-rate must be between `0.0` and `1.0`\"),\n                 Err(err) =>\n-                    panic!(\n+                    show_error!(\n                         \"-Zmiri-preemption-rate requires a `f64` between `0.0` and `1.0`: {}\",\n                         err\n                     ),\n@@ -510,7 +518,7 @@ fn main() {\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-report-progress=\") {\n             let interval = match param.parse::<u32>() {\n                 Ok(i) => i,\n-                Err(err) => panic!(\"-Zmiri-report-progress requires a `u32`: {}\", err),\n+                Err(err) => show_error!(\"-Zmiri-report-progress requires a `u32`: {}\", err),\n             };\n             miri_config.report_progress = Some(interval);\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-measureme=\") {\n@@ -520,7 +528,7 @@ fn main() {\n                 \"0\" => BacktraceStyle::Off,\n                 \"1\" => BacktraceStyle::Short,\n                 \"full\" => BacktraceStyle::Full,\n-                _ => panic!(\"-Zmiri-backtrace may only be 0, 1, or full\"),\n+                _ => show_error!(\"-Zmiri-backtrace may only be 0, 1, or full\"),\n             };\n         } else {\n             // Forward to rustc."}]}