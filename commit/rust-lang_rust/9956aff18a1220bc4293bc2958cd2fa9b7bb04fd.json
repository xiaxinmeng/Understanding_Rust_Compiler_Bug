{"sha": "9956aff18a1220bc4293bc2958cd2fa9b7bb04fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NTZhZmYxOGExMjIwYmM0MjkzYmMyOTU4Y2QyZmE5YjdiYjA0ZmQ=", "commit": {"author": {"name": "nham", "email": "hamann.nick@gmail.com", "date": "2014-07-30T15:35:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-31T18:50:23Z"}, "message": "Add examples for GenericPath methods.", "tree": {"sha": "324bb9565c1de7815a725af229878673c804d0b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/324bb9565c1de7815a725af229878673c804d0b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9956aff18a1220bc4293bc2958cd2fa9b7bb04fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9956aff18a1220bc4293bc2958cd2fa9b7bb04fd", "html_url": "https://github.com/rust-lang/rust/commit/9956aff18a1220bc4293bc2958cd2fa9b7bb04fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9956aff18a1220bc4293bc2958cd2fa9b7bb04fd/comments", "author": {"login": "nham", "id": 546409, "node_id": "MDQ6VXNlcjU0NjQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/546409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nham", "html_url": "https://github.com/nham", "followers_url": "https://api.github.com/users/nham/followers", "following_url": "https://api.github.com/users/nham/following{/other_user}", "gists_url": "https://api.github.com/users/nham/gists{/gist_id}", "starred_url": "https://api.github.com/users/nham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nham/subscriptions", "organizations_url": "https://api.github.com/users/nham/orgs", "repos_url": "https://api.github.com/users/nham/repos", "events_url": "https://api.github.com/users/nham/events{/privacy}", "received_events_url": "https://api.github.com/users/nham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3fcc0bc5114aa511b3c4e8d75794726bdb10342", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fcc0bc5114aa511b3c4e8d75794726bdb10342", "html_url": "https://github.com/rust-lang/rust/commit/c3fcc0bc5114aa511b3c4e8d75794726bdb10342"}], "stats": {"total": 233, "additions": 233, "deletions": 0}, "files": [{"sha": "25367dd53f4cd819743d59aa130e6d1940e32c9b", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/9956aff18a1220bc4293bc2958cd2fa9b7bb04fd/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9956aff18a1220bc4293bc2958cd2fa9b7bb04fd/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=9956aff18a1220bc4293bc2958cd2fa9b7bb04fd", "patch": "@@ -142,6 +142,12 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Creates a new Path from a byte vector or string.\n     /// The resulting Path will always be normalized.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let path = Path::new(\"foo/bar\");\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the path contains a NUL.\n@@ -155,6 +161,13 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n     /// Creates a new Path from a byte vector or string, if possible.\n     /// The resulting Path will always be normalized.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: &[u8] = ['f' as u8, 'o' as u8, 'o' as u8, 0];\n+    /// assert!(Path::new_opt(x).is_none());\n+    /// ```\n     #[inline]\n     fn new_opt<T: BytesContainer>(path: T) -> Option<Self> {\n         if contains_nul(&path) {\n@@ -166,51 +179,126 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n     /// Returns the path as a string, if possible.\n     /// If the path is not representable in utf-8, this returns None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"/abc/def\");\n+    /// assert_eq!(p.as_str(), Some(\"/abc/def\"));\n+    /// ```\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n         str::from_utf8(self.as_vec())\n     }\n \n     /// Returns the path as a byte vector\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def\");\n+    /// assert_eq!(p.as_vec(), &[97, 98, 99, 47, 100, 101, 102]);\n+    /// ```\n     fn as_vec<'a>(&'a self) -> &'a [u8];\n \n     /// Converts the Path into an owned byte vector\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def\");\n+    /// assert_eq!(p.into_vec(), vec!(97, 98, 99, 47, 100, 101, 102));\n+    /// // attempting to use p now results in \"error: use of moved value\"\n+    /// ```\n     fn into_vec(self) -> Vec<u8>;\n \n     /// Returns an object that implements `Show` for printing paths\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def\");\n+    /// println!(\"{}\", p.display()); // prints \"abc/def\"\n+    /// ```\n     fn display<'a>(&'a self) -> Display<'a, Self> {\n         Display{ path: self, filename: false }\n     }\n \n     /// Returns an object that implements `Show` for printing filenames\n     ///\n     /// If there is no filename, nothing will be printed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def\");\n+    /// println!(\"{}\", p.filename_display()); // prints \"def\"\n+    /// ```\n     fn filename_display<'a>(&'a self) -> Display<'a, Self> {\n         Display{ path: self, filename: true }\n     }\n \n     /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n     /// If `self` has no directory component, returns ['.'].\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.dirname(), &[97, 98, 99, 47, 100, 101, 102]);\n+    /// ```\n     fn dirname<'a>(&'a self) -> &'a [u8];\n+\n     /// Returns the directory component of `self`, as a string, if possible.\n     /// See `dirname` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.dirname_str(), Some(\"abc/def\"));\n+    /// ```\n     #[inline]\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         str::from_utf8(self.dirname())\n     }\n+\n     /// Returns the file component of `self`, as a byte vector.\n     /// If `self` represents the root of the file hierarchy, returns None.\n     /// If `self` is \".\" or \"..\", returns None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.filename(), Some(&[103, 104, 105]));\n+    /// ```\n     fn filename<'a>(&'a self) -> Option<&'a [u8]>;\n+\n     /// Returns the file component of `self`, as a string, if possible.\n     /// See `filename` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert_eq!(p.filename_str(), Some(\"ghi\"));\n+    /// ```\n     #[inline]\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n         self.filename().and_then(str::from_utf8)\n     }\n+\n     /// Returns the stem of the filename of `self`, as a byte vector.\n     /// The stem is the portion of the filename just before the last '.'.\n     /// If there is no '.', the entire filename is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"/abc/def.txt\");\n+    /// assert_eq!(p.filestem(), Some(&[100, 101, 102]));\n+    /// ```\n     fn filestem<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.filename() {\n             None => None,\n@@ -224,16 +312,32 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             })\n         }\n     }\n+\n     /// Returns the stem of the filename of `self`, as a string, if possible.\n     /// See `filestem` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"/abc/def.txt\");\n+    /// assert_eq!(p.filestem_str(), Some(\"def\"));\n+    /// ```\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n         self.filestem().and_then(str::from_utf8)\n     }\n+\n     /// Returns the extension of the filename of `self`, as an optional byte vector.\n     /// The extension is the portion of the filename just after the last '.'.\n     /// If there is no extension, None is returned.\n     /// If the filename ends in '.', the empty vector is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def.txt\");\n+    /// assert_eq!(p.extension(), Some(&[116, 120, 116]));\n+    /// ```\n     fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.filename() {\n             None => None,\n@@ -247,8 +351,16 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             }\n         }\n     }\n+\n     /// Returns the extension of the filename of `self`, as a string, if possible.\n     /// See `extension` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def.txt\");\n+    /// assert_eq!(p.extension_str(), Some(\"txt\"));\n+    /// ```\n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n         self.extension().and_then(str::from_utf8)\n@@ -257,6 +369,14 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Replaces the filename portion of the path with the given byte vector or string.\n     /// If the replacement name is [], this is equivalent to popping the path.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut p = Path::new(\"abc/def.txt\");\n+    /// p.set_filename(\"foo.dat\");\n+    /// assert!(p == Path::new(\"abc/foo.dat\"));\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the filename contains a NUL.\n@@ -265,11 +385,20 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         assert!(!contains_nul(&filename));\n         unsafe { self.set_filename_unchecked(filename) }\n     }\n+\n     /// Replaces the extension with the given byte vector or string.\n     /// If there is no extension in `self`, this adds one.\n     /// If the argument is [] or \"\", this removes the extension.\n     /// If `self` has no filename, this is a no-op.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut p = Path::new(\"abc/def.txt\");\n+    /// p.set_extension(\"csv\");\n+    /// assert!(p == Path::new(\"abc/def.csv\"));\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the extension contains a NUL.\n@@ -308,6 +437,13 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// byte vector or string.\n     /// See `set_filename` for details.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut p = Path::new(\"abc/def.txt\");\n+    /// assert!(p.with_filename(\"foo.dat\") == Path::new(\"abc/foo.dat\"));\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the filename contains a NUL.\n@@ -317,6 +453,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.set_filename(filename);\n         p\n     }\n+\n     /// Returns a new Path constructed by setting the extension to the given\n     /// byte vector or string.\n     /// See `set_extension` for details.\n@@ -333,6 +470,13 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n     /// Returns the directory component of `self`, as a Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def/ghi\");\n+    /// assert!(p.dir_path() == Path::new(\"abc/def\"));\n+    /// ```\n     fn dir_path(&self) -> Self {\n         // self.dirname() returns a NUL-free vector\n         unsafe { GenericPathUnsafe::new_unchecked(self.dirname()) }\n@@ -341,11 +485,26 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Returns a Path that represents the filesystem root that `self` is rooted in.\n     ///\n     /// If `self` is not absolute, or vol/cwd-relative in the case of Windows, this returns None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert!(Path::new(\"abc/def\").root_path() == None);\n+    /// assert!(Path::new(\"/abc/def\").root_path() == Some(Path::new(\"/\")));\n+    /// ```\n     fn root_path(&self) -> Option<Self>;\n \n     /// Pushes a path (as a byte vector or string) onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut p = Path::new(\"foo/bar\");\n+    /// p.push(\"baz.txt\");\n+    /// assert!(p == Path::new(\"foo/bar/baz.txt\"));\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the path contains a NUL.\n@@ -354,8 +513,17 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         assert!(!contains_nul(&path));\n         unsafe { self.push_unchecked(path) }\n     }\n+\n     /// Pushes multiple paths (as byte vectors or strings) onto `self`.\n     /// See `push` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut p = Path::new(\"foo\");\n+    /// p.push_many(&[\"bar\", \"baz.txt\"]);\n+    /// assert!(p == Path::new(\"foo/bar/baz.txt\"));\n+    /// ```\n     #[inline]\n     fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {\n         let t: Option<T> = None;\n@@ -369,15 +537,31 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             }\n         }\n     }\n+\n     /// Removes the last path component from the receiver.\n     /// Returns `true` if the receiver was modified, or `false` if it already\n     /// represented the root of the file hierarchy.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut p = Path::new(\"foo/bar/baz.txt\");\n+    /// p.pop();\n+    /// assert!(p == Path::new(\"foo/bar\"));\n+    /// ```\n     fn pop(&mut self) -> bool;\n \n     /// Returns a new Path constructed by joining `self` with the given path\n     /// (as a byte vector or string).\n     /// If the given path is absolute, the new Path will represent just that.\n     ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"/foo\");\n+    /// assert!(p.join(\"bar.txt\") == Path::new(\"/foo/bar.txt\"));\n+    /// ```\n+    ///\n     /// # Failure\n     ///\n     /// Fails the task if the path contains a NUL.\n@@ -387,9 +571,18 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.push(path);\n         p\n     }\n+\n     /// Returns a new Path constructed by joining `self` with the given paths\n     /// (as byte vectors or strings).\n     /// See `join` for details.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"foo\");\n+    /// let fbbq = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// assert!(p.join_many(&[\"bar\", \"baz\", \"quux.txt\"]) == fbbq);\n+    /// ```\n     #[inline]\n     fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self {\n         let mut p = self.clone();\n@@ -400,28 +593,68 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Returns whether `self` represents an absolute path.\n     /// An absolute path is defined as one that, when joined to another path, will\n     /// yield back the same absolute path.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"/abc/def\");\n+    /// assert!(p.is_absolute());\n+    /// ```\n     fn is_absolute(&self) -> bool;\n \n     /// Returns whether `self` represents a relative path.\n     /// Typically this is the inverse of `is_absolute`.\n     /// But for Windows paths, it also means the path is not volume-relative or\n     /// relative to the current working directory.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"abc/def\");\n+    /// assert!(p.is_relative());\n+    /// ```\n     fn is_relative(&self) -> bool {\n         !self.is_absolute()\n     }\n \n     /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n     /// If both paths are relative, they are compared as though they are relative\n     /// to the same parent path.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// let fb = Path::new(\"foo/bar\");\n+    /// let bq = Path::new(\"baz/quux.txt\");\n+    /// assert!(fb.is_ancestor_of(&p));\n+    /// ```\n     fn is_ancestor_of(&self, other: &Self) -> bool;\n \n     /// Returns the Path that, were it joined to `base`, would yield `self`.\n     /// If no such path exists, None is returned.\n     /// If `self` is absolute and `base` is relative, or on Windows if both\n     /// paths refer to separate drives, an absolute path is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// let fb = Path::new(\"foo/bar\");\n+    /// let bq = Path::new(\"baz/quux.txt\");\n+    /// assert!(p.path_relative_from(&fb) == Some(bq));\n+    /// ```\n     fn path_relative_from(&self, base: &Self) -> Option<Self>;\n \n     /// Returns whether the relative path `child` is a suffix of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n+    /// let bq = Path::new(\"baz/quux.txt\");\n+    /// assert!(p.ends_with_path(&bq));\n+    /// ```\n     fn ends_with_path(&self, child: &Self) -> bool;\n }\n "}]}