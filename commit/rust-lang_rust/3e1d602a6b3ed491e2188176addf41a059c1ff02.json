{"sha": "3e1d602a6b3ed491e2188176addf41a059c1ff02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMWQ2MDJhNmIzZWQ0OTFlMjE4ODE3NmFkZGY0MWEwNTljMWZmMDI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-01-23T14:25:56Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-02-09T11:33:18Z"}, "message": "BTreeMap: share panicky test code & test panic during clear, clone", "tree": {"sha": "a5261a5b5f065ffe8041cc9dbf07353ab99dc389", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5261a5b5f065ffe8041cc9dbf07353ab99dc389"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e1d602a6b3ed491e2188176addf41a059c1ff02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1d602a6b3ed491e2188176addf41a059c1ff02", "html_url": "https://github.com/rust-lang/rust/commit/3e1d602a6b3ed491e2188176addf41a059c1ff02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e1d602a6b3ed491e2188176addf41a059c1ff02/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d2247eac2256b3f6e8d10e3bc9c3b6068d74967", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d2247eac2256b3f6e8d10e3bc9c3b6068d74967", "html_url": "https://github.com/rust-lang/rust/commit/6d2247eac2256b3f6e8d10e3bc9c3b6068d74967"}], "stats": {"total": 486, "additions": 303, "deletions": 183}, "files": [{"sha": "56d6ae57e04a57ab3b0c2b9bcf4af20d0f6327fe", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 152, "deletions": 127, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=3e1d602a6b3ed491e2188176addf41a059c1ff02", "patch": "@@ -1,3 +1,4 @@\n+use super::super::testing::crash_test::{CrashTestDummy, Panic};\n use super::super::testing::ord_chaos::{Cyclic3, Governed, Governor};\n use super::super::testing::rng::DeterministicRng;\n use super::Entry::{Occupied, Vacant};\n@@ -1134,103 +1135,78 @@ mod test_drain_filter {\n \n     #[test]\n     fn drop_panic_leak() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                if DROPS.fetch_add(1, SeqCst) == 1 {\n-                    panic!(\"panic in `drop`\");\n-                }\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InDrop), ());\n+        map.insert(c.spawn(Panic::Never), ());\n \n-        catch_unwind(move || {\n-            drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                true\n-            }))\n-        })\n-        .unwrap_err();\n+        catch_unwind(move || drop(map.drain_filter(|dummy, _| dummy.query(true)))).unwrap_err();\n \n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 3);\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 1);\n+        assert_eq!(c.dropped(), 1);\n     }\n \n     #[test]\n     fn pred_panic_leak() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                DROPS.fetch_add(1, SeqCst);\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n-\n-        catch_unwind(AssertUnwindSafe(|| {\n-            drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                match i {\n-                    0 => true,\n-                    _ => panic!(),\n-                }\n-            }))\n-        }))\n-        .unwrap_err();\n-\n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 1);\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InQuery), ());\n+        map.insert(c.spawn(Panic::InQuery), ());\n+\n+        catch_unwind(AssertUnwindSafe(|| drop(map.drain_filter(|dummy, _| dummy.query(true)))))\n+            .unwrap_err();\n+\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 0);\n+        assert_eq!(c.dropped(), 0);\n         assert_eq!(map.len(), 2);\n-        assert_eq!(map.first_entry().unwrap().key(), &4);\n-        assert_eq!(map.last_entry().unwrap().key(), &8);\n+        assert_eq!(map.first_entry().unwrap().key().id(), 1);\n+        assert_eq!(map.last_entry().unwrap().key().id(), 2);\n         map.check();\n     }\n \n     // Same as above, but attempt to use the iterator again after the panic in the predicate\n     #[test]\n     fn pred_panic_reuse() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                DROPS.fetch_add(1, SeqCst);\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InQuery), ());\n+        map.insert(c.spawn(Panic::InQuery), ());\n \n         {\n-            let mut it = map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                match i {\n-                    0 => true,\n-                    _ => panic!(),\n-                }\n-            });\n+            let mut it = map.drain_filter(|dummy, _| dummy.query(true));\n             catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n             // Iterator behaviour after a panic is explicitly unspecified,\n             // so this is just the current implementation:\n             let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n             assert!(matches!(result, Ok(None)));\n         }\n \n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 1);\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 0);\n+        assert_eq!(c.dropped(), 0);\n         assert_eq!(map.len(), 2);\n-        assert_eq!(map.first_entry().unwrap().key(), &4);\n-        assert_eq!(map.last_entry().unwrap().key(), &8);\n+        assert_eq!(map.first_entry().unwrap().key().id(), 1);\n+        assert_eq!(map.last_entry().unwrap().key().id(), 2);\n         map.check();\n     }\n }\n@@ -1437,6 +1413,43 @@ fn test_bad_zst() {\n     m.check();\n }\n \n+#[test]\n+fn test_clear() {\n+    let mut map = BTreeMap::new();\n+    for &len in &[MIN_INSERTS_HEIGHT_1, MIN_INSERTS_HEIGHT_2, 0, NODE_CAPACITY] {\n+        for i in 0..len {\n+            map.insert(i, ());\n+        }\n+        assert_eq!(map.len(), len);\n+        map.clear();\n+        map.check();\n+        assert!(map.is_empty());\n+    }\n+}\n+\n+#[test]\n+fn test_clear_drop_panic_leak() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(a.spawn(Panic::Never), ());\n+    map.insert(b.spawn(Panic::InDrop), ());\n+    map.insert(c.spawn(Panic::Never), ());\n+\n+    catch_unwind(AssertUnwindSafe(|| map.clear())).unwrap_err();\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+    assert_eq!(map.len(), 0);\n+\n+    drop(map);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n@@ -1482,6 +1495,35 @@ fn test_clone() {\n     map.check();\n }\n \n+#[test]\n+fn test_clone_panic_leak() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(a.spawn(Panic::Never), ());\n+    map.insert(b.spawn(Panic::InClone), ());\n+    map.insert(c.spawn(Panic::Never), ());\n+\n+    catch_unwind(|| map.clone()).unwrap_err();\n+    assert_eq!(a.cloned(), 1);\n+    assert_eq!(b.cloned(), 1);\n+    assert_eq!(c.cloned(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 0);\n+    assert_eq!(map.len(), 3);\n+\n+    drop(map);\n+    assert_eq!(a.cloned(), 1);\n+    assert_eq!(b.cloned(), 1);\n+    assert_eq!(c.cloned(), 0);\n+    assert_eq!(a.dropped(), 2);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n@@ -1899,29 +1941,21 @@ create_append_test!(test_append_1700, 1700);\n \n #[test]\n fn test_append_drop_leak() {\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut left = BTreeMap::new();\n     let mut right = BTreeMap::new();\n-    left.insert(0, D);\n-    left.insert(1, D); // first to be dropped during append\n-    left.insert(2, D);\n-    right.insert(1, D);\n-    right.insert(2, D);\n+    left.insert(a.spawn(Panic::Never), ());\n+    left.insert(b.spawn(Panic::InDrop), ()); // first duplicate key, dropped during append\n+    left.insert(c.spawn(Panic::Never), ());\n+    right.insert(b.spawn(Panic::Never), ());\n+    right.insert(c.spawn(Panic::Never), ());\n \n     catch_unwind(move || left.append(&mut right)).unwrap_err();\n-\n-    assert_eq!(DROPS.load(SeqCst), 4); // Rust issue #47949 ate one little piggy\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1); // should be 2 were it not for Rust issue #47949\n+    assert_eq!(c.dropped(), 2);\n }\n \n #[test]\n@@ -2048,51 +2082,42 @@ fn test_split_off_large_random_sorted() {\n \n #[test]\n fn test_into_iter_drop_leak_height_0() {\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 3 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+    let d = CrashTestDummy::new(3);\n+    let e = CrashTestDummy::new(4);\n     let mut map = BTreeMap::new();\n-    map.insert(\"a\", D);\n-    map.insert(\"b\", D);\n-    map.insert(\"c\", D);\n-    map.insert(\"d\", D);\n-    map.insert(\"e\", D);\n+    map.insert(\"a\", a.spawn(Panic::Never));\n+    map.insert(\"b\", b.spawn(Panic::Never));\n+    map.insert(\"c\", c.spawn(Panic::Never));\n+    map.insert(\"d\", d.spawn(Panic::InDrop));\n+    map.insert(\"e\", e.spawn(Panic::Never));\n \n     catch_unwind(move || drop(map.into_iter())).unwrap_err();\n \n-    assert_eq!(DROPS.load(SeqCst), 5);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+    assert_eq!(d.dropped(), 1);\n+    assert_eq!(e.dropped(), 1);\n }\n \n #[test]\n fn test_into_iter_drop_leak_height_1() {\n     let size = MIN_INSERTS_HEIGHT_1;\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-    static PANIC_POINT: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == PANIC_POINT.load(SeqCst) {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n     for panic_point in vec![0, 1, size - 2, size - 1] {\n-        DROPS.store(0, SeqCst);\n-        PANIC_POINT.store(panic_point, SeqCst);\n-        let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n+        let dummies: Vec<_> = (0..size).map(|i| CrashTestDummy::new(i)).collect();\n+        let map: BTreeMap<_, _> = (0..size)\n+            .map(|i| {\n+                let panic = if i == panic_point { Panic::InDrop } else { Panic::Never };\n+                (dummies[i].spawn(Panic::Never), dummies[i].spawn(panic))\n+            })\n+            .collect();\n         catch_unwind(move || drop(map.into_iter())).unwrap_err();\n-        assert_eq!(DROPS.load(SeqCst), size);\n+        for i in 0..size {\n+            assert_eq!(dummies[i].dropped(), 2);\n+        }\n     }\n }\n "}, {"sha": "4cb6e3d6619dcb05ac25c1154f3151ee0b1a6343", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 31, "deletions": 56, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=3e1d602a6b3ed491e2188176addf41a059c1ff02", "patch": "@@ -1,10 +1,10 @@\n+use super::super::testing::crash_test::{CrashTestDummy, Panic};\n use super::super::testing::rng::DeterministicRng;\n use super::*;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicU32, Ordering::SeqCst};\n \n #[test]\n fn test_clone_eq() {\n@@ -349,70 +349,45 @@ fn test_drain_filter() {\n \n #[test]\n fn test_drain_filter_drop_panic_leak() {\n-    static PREDS: AtomicU32 = AtomicU32::new(0);\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(i32);\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 1 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut set = BTreeSet::new();\n-    set.insert(D(0));\n-    set.insert(D(4));\n-    set.insert(D(8));\n+    set.insert(a.spawn(Panic::Never));\n+    set.insert(b.spawn(Panic::InDrop));\n+    set.insert(c.spawn(Panic::Never));\n \n-    catch_unwind(move || {\n-        drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, SeqCst);\n-            true\n-        }))\n-    })\n-    .ok();\n+    catch_unwind(move || drop(set.drain_filter(|dummy| dummy.query(true)))).ok();\n \n-    assert_eq!(PREDS.load(SeqCst), 0x011);\n-    assert_eq!(DROPS.load(SeqCst), 3);\n+    assert_eq!(a.queried(), 1);\n+    assert_eq!(b.queried(), 1);\n+    assert_eq!(c.queried(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n }\n \n #[test]\n fn test_drain_filter_pred_panic_leak() {\n-    static PREDS: AtomicU32 = AtomicU32::new(0);\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(i32);\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            DROPS.fetch_add(1, SeqCst);\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut set = BTreeSet::new();\n-    set.insert(D(0));\n-    set.insert(D(4));\n-    set.insert(D(8));\n-\n-    catch_unwind(AssertUnwindSafe(|| {\n-        drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, SeqCst);\n-            match d.0 {\n-                0 => true,\n-                _ => panic!(),\n-            }\n-        }))\n-    }))\n-    .ok();\n-\n-    assert_eq!(PREDS.load(SeqCst), 0x011);\n-    assert_eq!(DROPS.load(SeqCst), 1);\n+    set.insert(a.spawn(Panic::Never));\n+    set.insert(b.spawn(Panic::InQuery));\n+    set.insert(c.spawn(Panic::InQuery));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(set.drain_filter(|dummy| dummy.query(true))))).ok();\n+\n+    assert_eq!(a.queried(), 1);\n+    assert_eq!(b.queried(), 1);\n+    assert_eq!(c.queried(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 0);\n     assert_eq!(set.len(), 2);\n-    assert_eq!(set.first().unwrap().0, 4);\n-    assert_eq!(set.last().unwrap().0, 8);\n+    assert_eq!(set.first().unwrap().id(), 1);\n+    assert_eq!(set.last().unwrap().id(), 2);\n }\n \n #[test]"}, {"sha": "b2527b95f5bba874009a7c5fdc8f82011c8805de", "filename": "library/alloc/src/collections/btree/testing/crash_test.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs?ref=3e1d602a6b3ed491e2188176addf41a059c1ff02", "patch": "@@ -0,0 +1,119 @@\n+use crate::fmt::Debug;\n+use std::cmp::Ordering;\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+\n+/// A blueprint for crash test dummy instances that monitor particular events.\n+/// Some instances may be configured to panic at some point.\n+/// Events are `clone`, `drop` or some anonymous `query`.\n+///\n+/// Crash test dummies are identified and ordered by an id, so they can be used\n+/// as keys in a BTreeMap. The implementation intentionally uses does not rely\n+/// on anything defined in the crate, apart from the `Debug` trait.\n+#[derive(Debug)]\n+pub struct CrashTestDummy {\n+    id: usize,\n+    cloned: AtomicUsize,\n+    dropped: AtomicUsize,\n+    queried: AtomicUsize,\n+}\n+\n+impl CrashTestDummy {\n+    /// Creates a crash test dummy design. The `id` determines order and equality of instances.\n+    pub fn new(id: usize) -> CrashTestDummy {\n+        CrashTestDummy {\n+            id,\n+            cloned: AtomicUsize::new(0),\n+            dropped: AtomicUsize::new(0),\n+            queried: AtomicUsize::new(0),\n+        }\n+    }\n+\n+    /// Creates an instance of a crash test dummy that records what events it experiences\n+    /// and optionally panics.\n+    pub fn spawn(&self, panic: Panic) -> Instance<'_> {\n+        Instance { origin: self, panic }\n+    }\n+\n+    /// Returns how many times instances of the dummy have been cloned.\n+    pub fn cloned(&self) -> usize {\n+        self.cloned.load(SeqCst)\n+    }\n+\n+    /// Returns how many times instances of the dummy have been dropped.\n+    pub fn dropped(&self) -> usize {\n+        self.dropped.load(SeqCst)\n+    }\n+\n+    /// Returns how many times instances of the dummy have had their `query` member invoked.\n+    pub fn queried(&self) -> usize {\n+        self.queried.load(SeqCst)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Instance<'a> {\n+    origin: &'a CrashTestDummy,\n+    panic: Panic,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Panic {\n+    Never,\n+    InClone,\n+    InDrop,\n+    InQuery,\n+}\n+\n+impl Instance<'_> {\n+    pub fn id(&self) -> usize {\n+        self.origin.id\n+    }\n+\n+    /// Some anonymous query, the result of which is already given.\n+    pub fn query<R>(&self, result: R) -> R {\n+        self.origin.queried.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InQuery {\n+            panic!(\"panic in `query`\");\n+        }\n+        result\n+    }\n+}\n+\n+impl Clone for Instance<'_> {\n+    fn clone(&self) -> Self {\n+        self.origin.cloned.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InClone {\n+            panic!(\"panic in `clone`\");\n+        }\n+        Self { origin: self.origin, panic: Panic::Never }\n+    }\n+}\n+\n+impl Drop for Instance<'_> {\n+    fn drop(&mut self) {\n+        self.origin.dropped.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InDrop {\n+            panic!(\"panic in `drop`\");\n+        }\n+    }\n+}\n+\n+impl PartialOrd for Instance<'_> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.id().partial_cmp(&other.id())\n+    }\n+}\n+\n+impl Ord for Instance<'_> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.id().cmp(&other.id())\n+    }\n+}\n+\n+impl PartialEq for Instance<'_> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.id().eq(&other.id())\n+    }\n+}\n+\n+impl Eq for Instance<'_> {}"}, {"sha": "7a094f8a59522216ad1891e2beac432695737300", "filename": "library/alloc/src/collections/btree/testing/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1d602a6b3ed491e2188176addf41a059c1ff02/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs?ref=3e1d602a6b3ed491e2188176addf41a059c1ff02", "patch": "@@ -1,2 +1,3 @@\n+pub mod crash_test;\n pub mod ord_chaos;\n pub mod rng;"}]}