{"sha": "22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyYTEwZjBlNGFmYzUwNDM4NGY1YTY0ZWNiOGQ2YjQ0Y2IzZDk1MDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-30T18:01:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-30T18:04:12Z"}, "message": "refactor region manip. to remove redundancy, get closer to fn subtyping\n\nalso: remove \"auto-mode-matching\" for implemented interfaces, as it\nis complex and interacts poorly with classes\n\ncc #2263", "tree": {"sha": "9316b4aa3c72d45f515b60cf83238867f41af4e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9316b4aa3c72d45f515b60cf83238867f41af4e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "html_url": "https://github.com/rust-lang/rust/commit/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4694ca51942248308c1d3e05d7c6df90539f994", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4694ca51942248308c1d3e05d7c6df90539f994", "html_url": "https://github.com/rust-lang/rust/commit/e4694ca51942248308c1d3e05d7c6df90539f994"}], "stats": {"total": 319, "additions": 162, "deletions": 157}, "files": [{"sha": "deede6b5e6ffba32bc8661e6aae773339ac9773b", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "patch": "@@ -70,9 +70,7 @@ import astconv::{ast_conv, ast_ty_to_ty};\n import collect::{methods}; // ccx.to_ty()\n import method::{methods};  // methods for method::lookup\n import middle::ty::tys_in_fn_ty;\n-import regionmanip::{replace_bound_regions_in_fn_ty,\n-                     region_of, replace_bound_regions,\n-                     collect_bound_regions_in_tys};\n+import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n import rscope::*;\n \n type fn_ctxt ="}, {"sha": "5d9572e029d6631eebf1de2c09c502fe8f658d88", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 96, "deletions": 106, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "patch": "@@ -20,7 +20,7 @@ fn replace_bound_regions_in_fn_ty(\n            all_tys.map { |t| ty_to_str(tcx, t) }];\n     let _i = indenter();\n \n-    let isr = collect_bound_regions_in_tys(tcx, isr, all_tys) { |br|\n+    let isr = create_bound_region_mapping(tcx, isr, all_tys) { |br|\n         #debug[\"br=%?\", br];\n         mapf(br)\n     };\n@@ -36,47 +36,105 @@ fn replace_bound_regions_in_fn_ty(\n     ret {isr: isr,\n          self_ty: t_self,\n          fn_ty: alt check ty::get(t_fn).struct { ty::ty_fn(o) {o} }};\n-}\n \n-// Takes `isr`, a mapping from in-scope region names (\"isr\"s) to their\n-// corresponding regions (possibly produced by a call to\n-// collect_bound_regions_in_tys; and `ty`, a type.  Returns an updated\n-// version of `ty`, in which bound regions in `ty` have been replaced\n-// with the corresponding bindings in `isr`.\n-fn replace_bound_regions(\n-    tcx: ty::ctxt,\n-    isr: isr_alist,\n-    ty: ty::t) -> ty::t {\n-\n-    ty::fold_regions(tcx, ty) { |r, in_fn|\n-        alt r {\n-          // As long as we are not within a fn() type, `&T` is mapped to the\n-          // free region anon_r.  But within a fn type, it remains bound.\n-          ty::re_bound(ty::br_anon) if in_fn { r }\n-\n-          ty::re_bound(br) {\n-            alt isr.find(br) {\n-              // In most cases, all named, bound regions will be mapped to\n-              // some free region.\n-              some(fr) { fr }\n-\n-              // But in the case of a fn() type, there may be named regions\n-              // within that remain bound:\n-              none if in_fn { r }\n-              none {\n-                tcx.sess.bug(\n-                    #fmt[\"Bound region not found in \\\n-                          in_scope_regions list: %s\",\n-                         region_to_str(tcx, r)]);\n+\n+    // Takes `isr`, a (possibly empty) mapping from in-scope region\n+    // names (\"isr\"s) to their corresponding regions; `tys`, a list of\n+    // types, and `to_r`, a closure that takes a bound_region and\n+    // returns a region.  Returns an updated version of `isr`,\n+    // extended with the in-scope region names from all of the bound\n+    // regions appearing in the types in the `tys` list (if they're\n+    // not in `isr` already), with each of those in-scope region names\n+    // mapped to a region that's the result of applying `to_r` to\n+    // itself.\n+    fn create_bound_region_mapping(\n+        tcx: ty::ctxt,\n+        isr: isr_alist,\n+        tys: [ty::t],\n+        to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n+\n+        // Takes `isr` (described above), `to_r` (described above),\n+        // and `r`, a region.  If `r` is anything other than a bound\n+        // region, or if it's a bound region that already appears in\n+        // `isr`, then we return `isr` unchanged.  If `r` is a bound\n+        // region that doesn't already appear in `isr`, we return an\n+        // updated isr_alist that now contains a mapping from `r` to\n+        // the result of calling `to_r` on it.\n+        fn append_isr(isr: isr_alist,\n+                      to_r: fn(ty::bound_region) -> ty::region,\n+                      r: ty::region) -> isr_alist {\n+            alt r {\n+              ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n+              ty::re_var(_) {\n+                isr\n+              }\n+              ty::re_bound(br) {\n+                alt isr.find(br) {\n+                  some(_) { isr }\n+                  none { @cons((br, to_r(br)), isr) }\n+                }\n               }\n             }\n-          }\n+        }\n+\n+        // For each type `ty` in `tys`...\n+        tys.foldl(isr) { |isr, ty|\n+            let mut isr = isr;\n+\n+            // Using fold_regions is inefficient, because it\n+            // constructs new types, but it avoids code duplication in\n+            // terms of locating all the regions within the various\n+            // kinds of types.  This had already caused me several\n+            // bugs so I decided to switch over.\n+            ty::fold_regions(tcx, ty) { |r, in_fn|\n+                if !in_fn { isr = append_isr(isr, to_r, r); }\n+                r\n+            };\n+\n+            isr\n+        }\n+    }\n+\n+    // Takes `isr`, a mapping from in-scope region names (\"isr\"s) to\n+    // their corresponding regions; and `ty`, a type.  Returns an\n+    // updated version of `ty`, in which bound regions in `ty` have\n+    // been replaced with the corresponding bindings in `isr`.\n+    fn replace_bound_regions(\n+        tcx: ty::ctxt,\n+        isr: isr_alist,\n+        ty: ty::t) -> ty::t {\n+\n+        ty::fold_regions(tcx, ty) { |r, in_fn|\n+            alt r {\n+              // As long as we are not within a fn() type, `&T` is\n+              // mapped to the free region anon_r.  But within a fn\n+              // type, it remains bound.\n+              ty::re_bound(ty::br_anon) if in_fn { r }\n+\n+              ty::re_bound(br) {\n+                alt isr.find(br) {\n+                  // In most cases, all named, bound regions will be\n+                  // mapped to some free region.\n+                  some(fr) { fr }\n+\n+                  // But in the case of a fn() type, there may be\n+                  // named regions within that remain bound:\n+                  none if in_fn { r }\n+                  none {\n+                    tcx.sess.bug(\n+                        #fmt[\"Bound region not found in \\\n+                              in_scope_regions list: %s\",\n+                             region_to_str(tcx, r)]);\n+                  }\n+                }\n+              }\n \n-          // Free regions like these just stay the same:\n-          ty::re_static |\n-          ty::re_scope(_) |\n-          ty::re_free(_, _) |\n-          ty::re_var(_) { r }\n+              // Free regions like these just stay the same:\n+              ty::re_static |\n+              ty::re_scope(_) |\n+              ty::re_free(_, _) |\n+              ty::re_var(_) { r }\n+            }\n         }\n     }\n }\n@@ -149,71 +207,3 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n         }\n     }\n }\n-\n-// Takes `isr`, a (possibly empty) mapping from in-scope region names (\"isr\"s)\n-// to their corresponding regions; `tys`, a list of types, and `to_r`, a\n-// closure that takes a bound_region and returns a region.  Returns an updated\n-// version of `isr`, extended with the in-scope region names from all of the\n-// bound regions appearing in the types in the `tys` list (if they're not in\n-// `isr` already), with each of those in-scope region names mapped to a region\n-// that's the result of applying `to_r` to itself.\n-\n-// \"collect\" is something of a misnomer -- we're not merely collecting\n-// a list of the bound regions, but also doing the work of applying\n-// `to_r` to them!\n-fn collect_bound_regions_in_tys(\n-    tcx: ty::ctxt,\n-    isr: isr_alist,\n-    tys: [ty::t],\n-    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n-\n-    // Takes `isr` (described above), `to_r` (described above), and `r`, a\n-    // region.  If `r` is anything other than a bound region, or if it's a\n-    // bound region that already appears in `isr`, then we return `isr`\n-    // unchanged.  If `r` is a bound region that doesn't already appear in\n-    // `isr`, we return an updated isr_alist that now contains a mapping from\n-    // `r` to the result of calling `to_r` on it.\n-    fn append_isr(isr: isr_alist,\n-                  to_r: fn(ty::bound_region) -> ty::region,\n-                  r: ty::region) -> isr_alist {\n-        alt r {\n-          ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n-          ty::re_var(_) {\n-            isr\n-          }\n-          ty::re_bound(br) {\n-            alt isr.find(br) {\n-              some(_) { isr }\n-              none { @cons((br, to_r(br)), isr) }\n-            }\n-          }\n-        }\n-    }\n-\n-    // For each region in `t`, apply the `append_isr` function to that\n-    // region, accumulating and returning the results in an isr_alist.\n-    fn fold_over_regions_in_type(\n-        tcx: ty::ctxt,\n-        isr: isr_alist,\n-        ty: ty::t,\n-        to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n-\n-        let mut isr = isr;\n-\n-        // Using fold_regions is inefficient, because it constructs new types,\n-        // but it avoids code duplication in terms of locating all the regions\n-        // within the various kinds of types.  This had already caused me\n-        // several bugs so I decided to switch over.\n-        ty::fold_regions(tcx, ty) { |r, in_fn|\n-            if !in_fn { isr = append_isr(isr, to_r, r); }\n-            r\n-        };\n-\n-        ret isr;\n-    }\n-\n-    // For each type `t` in `tys`...\n-    tys.foldl(isr) { |isr, t|\n-        fold_over_regions_in_type(tcx, isr, t, to_r)\n-    }\n-}"}, {"sha": "71051954fb7f076579e430a15fbd90655de7cc81", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "patch": "@@ -151,48 +151,74 @@ fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n     }\n }\n \n-fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n-                       impl_tps: uint, if_m: ty::method, substs: ty::substs,\n-                       self_ty: ty::t) -> ty::t {\n+#[doc = \"\n+Checks that a method from an impl/class conforms to the signature of\n+the same method as declared in the iface.\n+\n+# Parameters\n+\n+- impl_m: the method in the impl\n+- impl_tps: the type params declared on the impl itself (not the method!)\n+- if_m: the method in the iface\n+- if_substs: the substitutions used on the type of the iface\n+- self_ty: the self type of the impl\n+\"]\n+fn compare_impl_method(tcx: ty::ctxt, sp: span,\n+                       impl_m: ty::method, impl_tps: uint,\n+                       if_m: ty::method, if_substs: ty::substs,\n+                       self_ty: ty::t) {\n \n     if impl_m.tps != if_m.tps {\n         tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                           \"` has an incompatible set of type parameters\");\n-        ty::mk_fn(tcx, impl_m.fty)\n-    } else if vec::len(impl_m.fty.inputs) != vec::len(if_m.fty.inputs) {\n+        ret;\n+    }\n+\n+    if vec::len(impl_m.fty.inputs) != vec::len(if_m.fty.inputs) {\n         tcx.sess.span_err(sp,#fmt[\"method `%s` has %u parameters \\\n                                    but the iface has %u\",\n                                   if_m.ident,\n                                   vec::len(impl_m.fty.inputs),\n                                   vec::len(if_m.fty.inputs)]);\n-        ty::mk_fn(tcx, impl_m.fty)\n-    } else {\n-        let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n-            alt ty::get(f.ty).struct {\n-              ty::ty_param(*) | ty::ty_self\n-              if alt i.mode { ast::infer(_) { true } _ { false } } {\n-                {mode: ast::expl(ast::by_ref) with i}\n-              }\n-              _ { i }\n-            }\n-        });\n-        let impl_fty = ty::mk_fn(tcx, {inputs: auto_modes with impl_m.fty});\n+        ret;\n+    }\n \n-        // Add dummy substs for the parameters of the impl method\n+    // Perform substitutions so that the iface/impl methods are expressed\n+    // in terms of the same set of type/region parameters:\n+    // - replace iface type parameters with those from `if_substs`\n+    // - replace method parameters on the iface with fresh, dummy parameters\n+    //   that correspond to the parameters we will find on the impl\n+    // - replace self region with a fresh, dummy region\n+    let dummy_self_r = ty::re_free(0, ty::br_self);\n+    let impl_fty = {\n+        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        replace_bound_self(tcx, impl_fty, dummy_self_r)\n+    };\n+    let if_fty = {\n+        let dummy_tps = vec::from_fn((*if_m.tps).len()) { |i|\n+            // hack: we don't know the def id of the impl tp, but it\n+            // is not important for unification\n+            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n+        };\n         let substs = {\n-            self_r: substs.self_r,\n+            self_r: some(dummy_self_r),\n             self_ty: some(self_ty),\n-            tps: substs.tps + vec::from_fn(vec::len(*if_m.tps), {|i|\n-                ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n-            })\n+            tps: if_substs.tps + dummy_tps\n         };\n-        let mut if_fty = ty::mk_fn(tcx, if_m.fty);\n-        if_fty = ty::subst(tcx, substs, if_fty);\n-        require_same_types(\n-            tcx, sp, impl_fty, if_fty,\n-            {|| \"method `\" + if_m.ident +\n-                 \"` has an incompatible type\"});\n-        ret impl_fty;\n+        let if_fty = ty::mk_fn(tcx, if_m.fty);\n+        ty::subst(tcx, substs, if_fty)\n+    };\n+    require_same_types(\n+        tcx, sp, impl_fty, if_fty,\n+        {|| \"method `\" + if_m.ident + \"` has an incompatible type\"});\n+    ret;\n+\n+    // Replaces bound references to the self region with `with_r`.\n+    fn replace_bound_self(tcx: ty::ctxt, ty: ty::t,\n+                          with_r: ty::region) -> ty::t {\n+        ty::fold_regions(tcx, ty) { |r, _in_fn|\n+            if r == ty::re_bound(ty::br_self) {with_r} else {r}\n+        }\n     }\n }\n \n@@ -219,18 +245,9 @@ fn check_methods_against_iface(ccx: @crate_ctxt,\n                                 not match the iface method's \\\n                                 purity\", m.ident]);\n             }\n-            let mt = compare_impl_method(\n+            compare_impl_method(\n                 ccx.tcx, span, m, vec::len(tps),\n                 if_m, tpt.substs, selfty);\n-            let old = tcx.tcache.get(local_def(id));\n-            if old.ty != mt {\n-                tcx.tcache.insert(\n-                    local_def(id),\n-                    {bounds: old.bounds,\n-                     rp: old.rp,\n-                     ty: mt});\n-                write_ty_to_tcx(tcx, id, mt);\n-            }\n           }\n           none {\n             tcx.sess.span_err("}, {"sha": "97bd43cc5274c399394c7d8b99987912f8caaee2", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "patch": "@@ -361,29 +361,29 @@ iface st {\n }\n \n impl of st for ty::t {\n-    fn sub(infcx: infer_ctxt, b: ty::t) -> ures {\n+    fn sub(infcx: infer_ctxt, &&b: ty::t) -> ures {\n         sub(infcx).tys(self, b).to_ures()\n     }\n \n-    fn lub(infcx: infer_ctxt, b: ty::t) -> cres<ty::t> {\n+    fn lub(infcx: infer_ctxt, &&b: ty::t) -> cres<ty::t> {\n         lub(infcx).tys(self, b)\n     }\n \n-    fn glb(infcx: infer_ctxt, b: ty::t) -> cres<ty::t> {\n+    fn glb(infcx: infer_ctxt, &&b: ty::t) -> cres<ty::t> {\n         glb(infcx).tys(self, b)\n     }\n }\n \n impl of st for ty::region {\n-    fn sub(infcx: infer_ctxt, b: ty::region) -> ures {\n+    fn sub(infcx: infer_ctxt, &&b: ty::region) -> ures {\n         sub(infcx).regions(self, b).chain {|_r| ok(()) }\n     }\n \n-    fn lub(infcx: infer_ctxt, b: ty::region) -> cres<ty::region> {\n+    fn lub(infcx: infer_ctxt, &&b: ty::region) -> cres<ty::region> {\n         lub(infcx).regions(self, b)\n     }\n \n-    fn glb(infcx: infer_ctxt, b: ty::region) -> cres<ty::region> {\n+    fn glb(infcx: infer_ctxt, &&b: ty::region) -> cres<ty::region> {\n         glb(infcx).regions(self, b)\n     }\n }"}, {"sha": "f0d79ccc589fac7b445596ae8f19cad5581fefc1", "filename": "src/test/compile-fail/selftype-astparam.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs?ref=22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "patch": "@@ -1,9 +1,9 @@\n iface add {\n-    fn +(x: self) -> self;\n+    fn +(++x: self) -> self;\n }\n \n impl of add for int {\n-    fn +(x: int) -> int { self + x }\n+    fn +(++x: int) -> int { self + x }\n }\n \n fn do_add<A:add>(x: A, y: A) -> A { x + y }"}, {"sha": "64aae3d15441dd57dd8a69ad38460265031eadc2", "filename": "src/test/run-pass/selftype-add-ints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs?ref=22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "patch": "@@ -1,5 +1,5 @@\n iface add {\n-    fn +(x: self) -> self;\n+    fn +(++x: self) -> self;\n }\n \n impl of add for int {"}]}