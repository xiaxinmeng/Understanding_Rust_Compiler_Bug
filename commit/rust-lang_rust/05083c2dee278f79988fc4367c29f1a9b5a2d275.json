{"sha": "05083c2dee278f79988fc4367c29f1a9b5a2d275", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MDgzYzJkZWUyNzhmNzk5ODhmYzQzNjdjMjlmMWE5YjVhMmQyNzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-12T02:13:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-12T02:13:11Z"}, "message": "Auto merge of #60187 - tmandry:generator-optimization, r=eddyb\n\nGenerator optimization: Overlap locals that never have storage live at the same time\n\nThe specific goal of this optimization is to optimize async fns which use `await!`. Notably, `await!` has an enclosing scope around the futures it awaits ([definition](https://github.com/rust-lang/rust/blob/08bfe16129b0621bc90184f8704523d4929695ef/src/libstd/macros.rs#L365-L381)), which we rely on to implement the optimization.\n\nMore generally, the optimization allows overlapping the storage of some locals which are never storage-live at the same time. **We care about storage-liveness when computing the layout, because knowing a field is `StorageDead` is the only way to prove it will not be accessed, either directly or through a reference.**\n\nTo determine whether we can overlap two locals in the generator layout, we look at whether they might *both* be `StorageLive` at any point in the MIR. We use the `MaybeStorageLive` dataflow analysis for this. We iterate over every location in the MIR, and build a bitset for each local of the locals it might potentially conflict with.\n\nNext, we assign every saved local to one or more variants. The variants correspond to suspension points, and we include the set of locals live across a given suspension point in the variant. (Note that we use liveness instead of storage-liveness here; this ensures that the local has actually been initialized in each variant it has been included in. If the local is not live across a suspension point, then it doesn't need to be included in that variant.). It's important to note that the variants are a \"view\" into our layout.\n\nFor the layout computation, we use a simplified approach.\n\n1. Start with the set of locals assigned to only one variant. The rest are disqualified.\n2. For each pair of locals which may conflict *and are not assigned to the same variant*, we pick one local to disqualify from overlapping.\n\nDisqualified locals go into a non-overlapping \"prefix\" at the beginning of our layout. This means they always have space reserved for them. All the locals that are allowed to overlap in each variant are then laid out after this prefix, in the \"overlap zone\".\n\nSo, if A and B were disqualified, and X, Y, and Z were all eligible for overlap, our generator might look something like this:\n\nYou can think of a generator as an enum, where some fields are shared between variants. e.g.\n\n```rust\nenum Generator {\n  Unresumed,\n  Poisoned,\n  Returned,\n  Suspend0(A, B, X),\n  Suspend1(B),\n  Suspend2(A, Y, Z),\n}\n```\n\nwhere every mention of `A` and `B` refer to the same field, which does not move when changing variants. Note that `A` and `B` would automatically be sent to the prefix in this example. Assuming that `X` is never `StorageLive` at the same time as either `Y` or `Z`, it would be allowed to overlap with them.\n\nNote that if two locals (`Y` and `Z` in this case) are assigned to the same variant in our generator, their memory would never overlap in the layout. Thus they can both be eligible for the overlapping section, even if they are storage-live at the same time.\n\n---\n\nDepends on:\n- [x] #59897 Multi-variant layouts for generators\n- [x] #60840 Preserve local scopes in generator MIR\n- [x] #61373 Emit StorageDead along unwind paths for generators\n\nBefore merging:\n\n- [x] ~Wrap the types of all generator fields in `MaybeUninitialized` in layout::ty::field~ (opened #60889)\n- [x] Make PR description more complete (e.g. explain why storage liveness is important and why we have to check every location)\n- [x] Clean up TODO\n- [x] Fix the layout code to enforce that the same field never moves around in the generator\n- [x] Add tests for async/await\n- [x] ~Reduce # bits we store by half, since the conflict relation is symmetric~ (note: decided not to do this, for simplicity)\n- [x] Store liveness information for each yield point in our `GeneratorLayout`, that way we can emit more useful debuginfo AND tell miri which fields are definitely initialized for a given variant (see discussion at https://github.com/rust-lang/rust/pull/59897#issuecomment-489468627)", "tree": {"sha": "a640aea25e47f742c79a40018b3357b7f58c8718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a640aea25e47f742c79a40018b3357b7f58c8718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05083c2dee278f79988fc4367c29f1a9b5a2d275", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05083c2dee278f79988fc4367c29f1a9b5a2d275", "html_url": "https://github.com/rust-lang/rust/commit/05083c2dee278f79988fc4367c29f1a9b5a2d275", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05083c2dee278f79988fc4367c29f1a9b5a2d275/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "961a9d6e97a37ff1bb33578721dfa8687054c7b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/961a9d6e97a37ff1bb33578721dfa8687054c7b8", "html_url": "https://github.com/rust-lang/rust/commit/961a9d6e97a37ff1bb33578721dfa8687054c7b8"}, {"sha": "aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22", "html_url": "https://github.com/rust-lang/rust/commit/aeefbc4cbad4461f4f846e897a04e0b3ce8cdb22"}], "stats": {"total": 1284, "additions": 960, "deletions": 324}, "files": [{"sha": "310228838e0ad4bff571b500353acc3f735bfd48", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -9,6 +9,7 @@ use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n+use rustc_data_structures::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n@@ -2997,6 +2998,11 @@ pub struct GeneratorLayout<'tcx> {\n     /// be stored in multiple variants.\n     pub variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>>,\n \n+    /// Which saved locals are storage-live at the same time. Locals that do not\n+    /// have conflicts with each other are allowed to overlap in the computed\n+    /// layout.\n+    pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n+\n     /// Names and scopes of all the stored generator locals.\n     /// NOTE(tmandry) This is *strictly* a temporary hack for codegen\n     /// debuginfo generation, and will be removed at some point.\n@@ -3193,6 +3199,7 @@ BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n         field_tys,\n         variant_fields,\n+        storage_conflicts,\n         __local_debuginfo_codegen_only_do_not_use,\n     }\n }\n@@ -3572,6 +3579,15 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n     }\n }\n \n+impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+        self.clone()\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {"}, {"sha": "65cdd4ec4d7aab015760818f4e019b43071e75e0", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 487, "deletions": 280, "changes": 767, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -14,6 +14,10 @@ use std::ops::Bound;\n \n use crate::hir;\n use crate::ich::StableHashingContext;\n+use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n+use crate::ty::GeneratorSubsts;\n+use crate::ty::subst::Subst;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -212,260 +216,268 @@ pub struct LayoutCx<'tcx, C> {\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+enum StructKind {\n+    /// A tuple, closure, or univariant which cannot be coerced to unsized.\n+    AlwaysSized,\n+    /// A univariant, the last field of which may be coerced to unsized.\n+    MaybeUnsized,\n+    /// A univariant, but with a prefix of an arbitrary size & alignment (e.g., enum tag).\n+    Prefixed(Size, Align),\n+}\n+\n impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n-    fn layout_raw_uncached(&self, ty: Ty<'tcx>) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n-        let tcx = self.tcx;\n-        let param_env = self.param_env;\n+    fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutDetails {\n         let dl = self.data_layout();\n-        let scalar_unit = |value: Primitive| {\n-            let bits = value.size(dl).bits();\n-            assert!(bits <= 128);\n-            Scalar {\n-                value,\n-                valid_range: 0..=(!0 >> (128 - bits))\n-            }\n-        };\n-        let scalar = |value: Primitive| {\n-            tcx.intern_layout(LayoutDetails::scalar(self, scalar_unit(value)))\n-        };\n-        let scalar_pair = |a: Scalar, b: Scalar| {\n-            let b_align = b.value.align(dl);\n-            let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n-            let b_offset = a.value.size(dl).align_to(b_align.abi);\n-            let size = (b_offset + b.value.size(dl)).align_to(align.abi);\n-            LayoutDetails {\n-                variants: Variants::Single { index: VariantIdx::new(0) },\n-                fields: FieldPlacement::Arbitrary {\n-                    offsets: vec![Size::ZERO, b_offset],\n-                    memory_index: vec![0, 1]\n-                },\n-                abi: Abi::ScalarPair(a, b),\n-                align,\n-                size\n-            }\n-        };\n-\n-        #[derive(Copy, Clone, Debug)]\n-        enum StructKind {\n-            /// A tuple, closure, or univariant which cannot be coerced to unsized.\n-            AlwaysSized,\n-            /// A univariant, the last field of which may be coerced to unsized.\n-            MaybeUnsized,\n-            /// A univariant, but with a prefix of an arbitrary size & alignment (e.g., enum tag).\n-            Prefixed(Size, Align),\n+        let b_align = b.value.align(dl);\n+        let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n+        let b_offset = a.value.size(dl).align_to(b_align.abi);\n+        let size = (b_offset + b.value.size(dl)).align_to(align.abi);\n+        LayoutDetails {\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n+            fields: FieldPlacement::Arbitrary {\n+                offsets: vec![Size::ZERO, b_offset],\n+                memory_index: vec![0, 1]\n+            },\n+            abi: Abi::ScalarPair(a, b),\n+            align,\n+            size\n         }\n+    }\n \n-        let univariant_uninterned = |fields: &[TyLayout<'_>], repr: &ReprOptions, kind| {\n-            let packed = repr.packed();\n-            if packed && repr.align > 0 {\n-                bug!(\"struct cannot be packed and aligned\");\n-            }\n+    fn univariant_uninterned(&self,\n+                             ty: Ty<'tcx>,\n+                             fields: &[TyLayout<'_>],\n+                             repr: &ReprOptions,\n+                             kind: StructKind) -> Result<LayoutDetails, LayoutError<'tcx>> {\n+        let dl = self.data_layout();\n+        let packed = repr.packed();\n+        if packed && repr.align > 0 {\n+            bug!(\"struct cannot be packed and aligned\");\n+        }\n \n-            let pack = Align::from_bytes(repr.pack as u64).unwrap();\n+        let pack = Align::from_bytes(repr.pack as u64).unwrap();\n \n-            let mut align = if packed {\n-                dl.i8_align\n-            } else {\n-                dl.aggregate_align\n-            };\n+        let mut align = if packed {\n+            dl.i8_align\n+        } else {\n+            dl.aggregate_align\n+        };\n \n-            let mut sized = true;\n-            let mut offsets = vec![Size::ZERO; fields.len()];\n-            let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n+        let mut sized = true;\n+        let mut offsets = vec![Size::ZERO; fields.len()];\n+        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n-            let mut optimize = !repr.inhibit_struct_field_reordering_opt();\n-            if let StructKind::Prefixed(_, align) = kind {\n-                optimize &= align.bytes() == 1;\n-            }\n+        let mut optimize = !repr.inhibit_struct_field_reordering_opt();\n+        if let StructKind::Prefixed(_, align) = kind {\n+            optimize &= align.bytes() == 1;\n+        }\n \n-            if optimize {\n-                let end = if let StructKind::MaybeUnsized = kind {\n-                    fields.len() - 1\n-                } else {\n-                    fields.len()\n-                };\n-                let optimizing = &mut inverse_memory_index[..end];\n-                let field_align = |f: &TyLayout<'_>| {\n-                    if packed { f.align.abi.min(pack) } else { f.align.abi }\n-                };\n-                match kind {\n-                    StructKind::AlwaysSized |\n-                    StructKind::MaybeUnsized => {\n-                        optimizing.sort_by_key(|&x| {\n-                            // Place ZSTs first to avoid \"interesting offsets\",\n-                            // especially with only one or two non-ZST fields.\n-                            let f = &fields[x as usize];\n-                            (!f.is_zst(), cmp::Reverse(field_align(f)))\n-                        });\n-                    }\n-                    StructKind::Prefixed(..) => {\n-                        optimizing.sort_by_key(|&x| field_align(&fields[x as usize]));\n-                    }\n+        if optimize {\n+            let end = if let StructKind::MaybeUnsized = kind {\n+                fields.len() - 1\n+            } else {\n+                fields.len()\n+            };\n+            let optimizing = &mut inverse_memory_index[..end];\n+            let field_align = |f: &TyLayout<'_>| {\n+                if packed { f.align.abi.min(pack) } else { f.align.abi }\n+            };\n+            match kind {\n+                StructKind::AlwaysSized |\n+                StructKind::MaybeUnsized => {\n+                    optimizing.sort_by_key(|&x| {\n+                        // Place ZSTs first to avoid \"interesting offsets\",\n+                        // especially with only one or two non-ZST fields.\n+                        let f = &fields[x as usize];\n+                        (!f.is_zst(), cmp::Reverse(field_align(f)))\n+                    });\n+                }\n+                StructKind::Prefixed(..) => {\n+                    optimizing.sort_by_key(|&x| field_align(&fields[x as usize]));\n                 }\n             }\n+        }\n \n-            // inverse_memory_index holds field indices by increasing memory offset.\n-            // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n-            // We now write field offsets to the corresponding offset slot;\n-            // field 5 with offset 0 puts 0 in offsets[5].\n-            // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n+        // inverse_memory_index holds field indices by increasing memory offset.\n+        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+        // We now write field offsets to the corresponding offset slot;\n+        // field 5 with offset 0 puts 0 in offsets[5].\n+        // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n \n-            let mut offset = Size::ZERO;\n+        let mut offset = Size::ZERO;\n \n-            if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-                let prefix_align = if packed {\n-                    prefix_align.min(pack)\n-                } else {\n-                    prefix_align\n-                };\n-                align = align.max(AbiAndPrefAlign::new(prefix_align));\n-                offset = prefix_size.align_to(prefix_align);\n+        if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n+            let prefix_align = if packed {\n+                prefix_align.min(pack)\n+            } else {\n+                prefix_align\n+            };\n+            align = align.max(AbiAndPrefAlign::new(prefix_align));\n+            offset = prefix_size.align_to(prefix_align);\n+        }\n+\n+        for &i in &inverse_memory_index {\n+            let field = fields[i as usize];\n+            if !sized {\n+                bug!(\"univariant: field #{} of `{}` comes after unsized field\",\n+                     offsets.len(), ty);\n             }\n \n-            for &i in &inverse_memory_index {\n-                let field = fields[i as usize];\n-                if !sized {\n-                    bug!(\"univariant: field #{} of `{}` comes after unsized field\",\n-                         offsets.len(), ty);\n-                }\n+            if field.is_unsized() {\n+                sized = false;\n+            }\n \n-                if field.is_unsized() {\n-                    sized = false;\n-                }\n+            // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+            let field_align = if packed {\n+                field.align.min(AbiAndPrefAlign::new(pack))\n+            } else {\n+                field.align\n+            };\n+            offset = offset.align_to(field_align.abi);\n+            align = align.max(field_align);\n \n-                // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-                let field_align = if packed {\n-                    field.align.min(AbiAndPrefAlign::new(pack))\n-                } else {\n-                    field.align\n-                };\n-                offset = offset.align_to(field_align.abi);\n-                align = align.max(field_align);\n+            debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n+            offsets[i as usize] = offset;\n \n-                debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n-                offsets[i as usize] = offset;\n+            offset = offset.checked_add(field.size, dl)\n+                .ok_or(LayoutError::SizeOverflow(ty))?;\n+        }\n \n-                offset = offset.checked_add(field.size, dl)\n-                    .ok_or(LayoutError::SizeOverflow(ty))?;\n-            }\n+        if repr.align > 0 {\n+            let repr_align = repr.align as u64;\n+            align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n+            debug!(\"univariant repr_align: {:?}\", repr_align);\n+        }\n \n-            if repr.align > 0 {\n-                let repr_align = repr.align as u64;\n-                align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n-                debug!(\"univariant repr_align: {:?}\", repr_align);\n-            }\n+        debug!(\"univariant min_size: {:?}\", offset);\n+        let min_size = offset;\n \n-            debug!(\"univariant min_size: {:?}\", offset);\n-            let min_size = offset;\n+        // As stated above, inverse_memory_index holds field indices by increasing offset.\n+        // This makes it an already-sorted view of the offsets vec.\n+        // To invert it, consider:\n+        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+        // Field 5 would be the first element, so memory_index is i:\n+        // Note: if we didn't optimize, it's already right.\n \n-            // As stated above, inverse_memory_index holds field indices by increasing offset.\n-            // This makes it an already-sorted view of the offsets vec.\n-            // To invert it, consider:\n-            // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n-            // Field 5 would be the first element, so memory_index is i:\n-            // Note: if we didn't optimize, it's already right.\n+        let mut memory_index;\n+        if optimize {\n+            memory_index = vec![0; inverse_memory_index.len()];\n \n-            let mut memory_index;\n-            if optimize {\n-                memory_index = vec![0; inverse_memory_index.len()];\n+            for i in 0..inverse_memory_index.len() {\n+                memory_index[inverse_memory_index[i] as usize]  = i as u32;\n+            }\n+        } else {\n+            memory_index = inverse_memory_index;\n+        }\n \n-                for i in 0..inverse_memory_index.len() {\n-                    memory_index[inverse_memory_index[i] as usize]  = i as u32;\n-                }\n-            } else {\n-                memory_index = inverse_memory_index;\n-            }\n-\n-            let size = min_size.align_to(align.abi);\n-            let mut abi = Abi::Aggregate { sized };\n-\n-            // Unpack newtype ABIs and find scalar pairs.\n-            if sized && size.bytes() > 0 {\n-                // All other fields must be ZSTs, and we need them to all start at 0.\n-                let mut zst_offsets =\n-                    offsets.iter().enumerate().filter(|&(i, _)| fields[i].is_zst());\n-                if zst_offsets.all(|(_, o)| o.bytes() == 0) {\n-                    let mut non_zst_fields =\n-                        fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n-\n-                    match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n-                        // We have exactly one non-ZST field.\n-                        (Some((i, field)), None, None) => {\n-                            // Field fills the struct and it has a scalar or scalar pair ABI.\n-                            if offsets[i].bytes() == 0 &&\n-                               align.abi == field.align.abi &&\n-                               size == field.size {\n-                                match field.abi {\n-                                    // For plain scalars, or vectors of them, we can't unpack\n-                                    // newtypes for `#[repr(C)]`, as that affects C ABIs.\n-                                    Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                        abi = field.abi.clone();\n-                                    }\n-                                    // But scalar pairs are Rust-specific and get\n-                                    // treated as aggregates by C ABIs anyway.\n-                                    Abi::ScalarPair(..) => {\n-                                        abi = field.abi.clone();\n-                                    }\n-                                    _ => {}\n+        let size = min_size.align_to(align.abi);\n+        let mut abi = Abi::Aggregate { sized };\n+\n+        // Unpack newtype ABIs and find scalar pairs.\n+        if sized && size.bytes() > 0 {\n+            // All other fields must be ZSTs, and we need them to all start at 0.\n+            let mut zst_offsets =\n+                offsets.iter().enumerate().filter(|&(i, _)| fields[i].is_zst());\n+            if zst_offsets.all(|(_, o)| o.bytes() == 0) {\n+                let mut non_zst_fields =\n+                    fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+\n+                match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+                    // We have exactly one non-ZST field.\n+                    (Some((i, field)), None, None) => {\n+                        // Field fills the struct and it has a scalar or scalar pair ABI.\n+                        if offsets[i].bytes() == 0 &&\n+                           align.abi == field.align.abi &&\n+                           size == field.size {\n+                            match field.abi {\n+                                // For plain scalars, or vectors of them, we can't unpack\n+                                // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                                Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                                    abi = field.abi.clone();\n                                 }\n+                                // But scalar pairs are Rust-specific and get\n+                                // treated as aggregates by C ABIs anyway.\n+                                Abi::ScalarPair(..) => {\n+                                    abi = field.abi.clone();\n+                                }\n+                                _ => {}\n                             }\n                         }\n+                    }\n \n-                        // Two non-ZST fields, and they're both scalars.\n-                        (Some((i, &TyLayout {\n-                            details: &LayoutDetails { abi: Abi::Scalar(ref a), .. }, ..\n-                        })), Some((j, &TyLayout {\n-                            details: &LayoutDetails { abi: Abi::Scalar(ref b), .. }, ..\n-                        })), None) => {\n-                            // Order by the memory placement, not source order.\n-                            let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n-                                ((i, a), (j, b))\n-                            } else {\n-                                ((j, b), (i, a))\n-                            };\n-                            let pair = scalar_pair(a.clone(), b.clone());\n-                            let pair_offsets = match pair.fields {\n-                                FieldPlacement::Arbitrary {\n-                                    ref offsets,\n-                                    ref memory_index\n-                                } => {\n-                                    assert_eq!(memory_index, &[0, 1]);\n-                                    offsets\n-                                }\n-                                _ => bug!()\n-                            };\n-                            if offsets[i] == pair_offsets[0] &&\n-                               offsets[j] == pair_offsets[1] &&\n-                               align == pair.align &&\n-                               size == pair.size {\n-                                // We can use `ScalarPair` only when it matches our\n-                                // already computed layout (including `#[repr(C)]`).\n-                                abi = pair.abi;\n+                    // Two non-ZST fields, and they're both scalars.\n+                    (Some((i, &TyLayout {\n+                        details: &LayoutDetails { abi: Abi::Scalar(ref a), .. }, ..\n+                    })), Some((j, &TyLayout {\n+                        details: &LayoutDetails { abi: Abi::Scalar(ref b), .. }, ..\n+                    })), None) => {\n+                        // Order by the memory placement, not source order.\n+                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                            ((i, a), (j, b))\n+                        } else {\n+                            ((j, b), (i, a))\n+                        };\n+                        let pair = self.scalar_pair(a.clone(), b.clone());\n+                        let pair_offsets = match pair.fields {\n+                            FieldPlacement::Arbitrary {\n+                                ref offsets,\n+                                ref memory_index\n+                            } => {\n+                                assert_eq!(memory_index, &[0, 1]);\n+                                offsets\n                             }\n+                            _ => bug!()\n+                        };\n+                        if offsets[i] == pair_offsets[0] &&\n+                           offsets[j] == pair_offsets[1] &&\n+                           align == pair.align &&\n+                           size == pair.size {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n                         }\n-\n-                        _ => {}\n                     }\n+\n+                    _ => {}\n                 }\n             }\n+        }\n \n-            if sized && fields.iter().any(|f| f.abi.is_uninhabited()) {\n-                abi = Abi::Uninhabited;\n-            }\n+        if sized && fields.iter().any(|f| f.abi.is_uninhabited()) {\n+            abi = Abi::Uninhabited;\n+        }\n \n-            Ok(LayoutDetails {\n-                variants: Variants::Single { index: VariantIdx::new(0) },\n-                fields: FieldPlacement::Arbitrary {\n-                    offsets,\n-                    memory_index\n-                },\n-                abi,\n-                align,\n-                size\n-            })\n+        Ok(LayoutDetails {\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n+            fields: FieldPlacement::Arbitrary {\n+                offsets,\n+                memory_index\n+            },\n+            abi,\n+            align,\n+            size\n+        })\n+    }\n+\n+    fn layout_raw_uncached(&self, ty: Ty<'tcx>) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n+        let tcx = self.tcx;\n+        let param_env = self.param_env;\n+        let dl = self.data_layout();\n+        let scalar_unit = |value: Primitive| {\n+            let bits = value.size(dl).bits();\n+            assert!(bits <= 128);\n+            Scalar {\n+                value,\n+                valid_range: 0..=(!0 >> (128 - bits))\n+            }\n+        };\n+        let scalar = |value: Primitive| {\n+            tcx.intern_layout(LayoutDetails::scalar(self, scalar_unit(value)))\n         };\n+\n         let univariant = |fields: &[TyLayout<'_>], repr: &ReprOptions, kind| {\n-            Ok(tcx.intern_layout(univariant_uninterned(fields, repr, kind)?))\n+            Ok(tcx.intern_layout(self.univariant_uninterned(ty, fields, repr, kind)?))\n         };\n         debug_assert!(!ty.has_infer_types());\n \n@@ -537,7 +549,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 };\n \n                 // Effectively a (ptr, meta) tuple.\n-                tcx.intern_layout(scalar_pair(data_ptr, metadata))\n+                tcx.intern_layout(self.scalar_pair(data_ptr, metadata))\n             }\n \n             // Arrays and slices.\n@@ -602,7 +614,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?\n             }\n             ty::Dynamic(..) | ty::Foreign(..) => {\n-                let mut unit = univariant_uninterned(&[], &ReprOptions::default(),\n+                let mut unit = self.univariant_uninterned(ty, &[], &ReprOptions::default(),\n                   StructKind::AlwaysSized)?;\n                 match unit.abi {\n                     Abi::Aggregate { ref mut sized } => *sized = false,\n@@ -611,64 +623,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 tcx.intern_layout(unit)\n             }\n \n-            ty::Generator(def_id, ref substs, _) => {\n-                // FIXME(tmandry): For fields that are repeated in multiple\n-                // variants in the GeneratorLayout, we need code to ensure that\n-                // the offset of these fields never change. Right now this is\n-                // not an issue since every variant has every field, but once we\n-                // optimize this we have to be more careful.\n-\n-                let discr_index = substs.prefix_tys(def_id, tcx).count();\n-                let prefix_tys = substs.prefix_tys(def_id, tcx)\n-                    .chain(iter::once(substs.discr_ty(tcx)));\n-                let prefix = univariant_uninterned(\n-                    &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(),\n-                    StructKind::AlwaysSized)?;\n-\n-                let mut size = prefix.size;\n-                let mut align = prefix.align;\n-                let variants_tys = substs.state_tys(def_id, tcx);\n-                let variants = variants_tys.enumerate().map(|(i, variant_tys)| {\n-                    let mut variant = univariant_uninterned(\n-                        &variant_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n-                        &ReprOptions::default(),\n-                        StructKind::Prefixed(prefix.size, prefix.align.abi))?;\n-\n-                    variant.variants = Variants::Single { index: VariantIdx::new(i) };\n-\n-                    size = size.max(variant.size);\n-                    align = align.max(variant.align);\n-\n-                    Ok(variant)\n-                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n-\n-                let abi = if prefix.abi.is_uninhabited() ||\n-                             variants.iter().all(|v| v.abi.is_uninhabited()) {\n-                    Abi::Uninhabited\n-                } else {\n-                    Abi::Aggregate { sized: true }\n-                };\n-                let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n-                    Abi::Scalar(s) => s.clone(),\n-                    _ => bug!(),\n-                };\n-\n-                let layout = tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Multiple {\n-                        discr,\n-                        discr_kind: DiscriminantKind::Tag,\n-                        discr_index,\n-                        variants,\n-                    },\n-                    fields: prefix.fields,\n-                    abi,\n-                    size,\n-                    align,\n-                });\n-                debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n-                layout\n-            }\n+            ty::Generator(def_id, substs, _) => self.generator_layout(ty, def_id, &substs)?,\n \n             ty::Closure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n@@ -853,7 +808,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         else { StructKind::AlwaysSized }\n                     };\n \n-                    let mut st = univariant_uninterned(&variants[v], &def.repr, kind)?;\n+                    let mut st = self.univariant_uninterned(ty, &variants[v], &def.repr, kind)?;\n                     st.variants = Variants::Single { index: v };\n                     let (start, end) = self.tcx.layout_scalar_valid_range(def.did);\n                     match st.abi {\n@@ -932,7 +887,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                             let mut align = dl.aggregate_align;\n                             let st = variants.iter_enumerated().map(|(j, v)| {\n-                                let mut st = univariant_uninterned(v,\n+                                let mut st = self.univariant_uninterned(ty, v,\n                                     &def.repr, StructKind::AlwaysSized)?;\n                                 st.variants = Variants::Single { index: j };\n \n@@ -1040,7 +995,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                 // Create the set of structs that represent each variant.\n                 let mut layout_variants = variants.iter_enumerated().map(|(i, field_layouts)| {\n-                    let mut st = univariant_uninterned(&field_layouts,\n+                    let mut st = self.univariant_uninterned(ty, &field_layouts,\n                         &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n                     // Find the first field we can't move later\n@@ -1172,7 +1127,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         }\n                     }\n                     if let Some((prim, offset)) = common_prim {\n-                        let pair = scalar_pair(tag.clone(), scalar_unit(prim));\n+                        let pair = self.scalar_pair(tag.clone(), scalar_unit(prim));\n                         let pair_offsets = match pair.fields {\n                             FieldPlacement::Arbitrary {\n                                 ref offsets,\n@@ -1237,7 +1192,259 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n         })\n     }\n+}\n \n+/// Overlap eligibility and variant assignment for each GeneratorSavedLocal.\n+#[derive(Clone, Debug, PartialEq)]\n+enum SavedLocalEligibility {\n+    Unassigned,\n+    Assigned(VariantIdx),\n+    // FIXME: Use newtype_index so we aren't wasting bytes\n+    Ineligible(Option<u32>),\n+}\n+\n+// When laying out generators, we divide our saved local fields into two\n+// categories: overlap-eligible and overlap-ineligible.\n+//\n+// Those fields which are ineligible for overlap go in a \"prefix\" at the\n+// beginning of the layout, and always have space reserved for them.\n+//\n+// Overlap-eligible fields are only assigned to one variant, so we lay\n+// those fields out for each variant and put them right after the\n+// prefix.\n+//\n+// Finally, in the layout details, we point to the fields from the\n+// variants they are assigned to. It is possible for some fields to be\n+// included in multiple variants. No field ever \"moves around\" in the\n+// layout; its offset is always the same.\n+//\n+// Also included in the layout are the upvars and the discriminant.\n+// These are included as fields on the \"outer\" layout; they are not part\n+// of any variant.\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+    /// Compute the eligibility and assignment of each local.\n+    fn generator_saved_local_eligibility(&self, info: &GeneratorLayout<'tcx>)\n+    -> (BitSet<GeneratorSavedLocal>, IndexVec<GeneratorSavedLocal, SavedLocalEligibility>) {\n+        use SavedLocalEligibility::*;\n+\n+        let mut assignments: IndexVec<GeneratorSavedLocal, SavedLocalEligibility> =\n+            IndexVec::from_elem_n(Unassigned, info.field_tys.len());\n+\n+        // The saved locals not eligible for overlap. These will get\n+        // \"promoted\" to the prefix of our generator.\n+        let mut ineligible_locals = BitSet::new_empty(info.field_tys.len());\n+\n+        // Figure out which of our saved locals are fields in only\n+        // one variant. The rest are deemed ineligible for overlap.\n+        for (variant_index, fields) in info.variant_fields.iter_enumerated() {\n+            for local in fields {\n+                match assignments[*local] {\n+                    Unassigned => {\n+                        assignments[*local] = Assigned(variant_index);\n+                    }\n+                    Assigned(idx) => {\n+                        // We've already seen this local at another suspension\n+                        // point, so it is no longer a candidate.\n+                        trace!(\"removing local {:?} in >1 variant ({:?}, {:?})\",\n+                               local, variant_index, idx);\n+                        ineligible_locals.insert(*local);\n+                        assignments[*local] = Ineligible(None);\n+                    }\n+                    Ineligible(_) => {},\n+                }\n+            }\n+        }\n+\n+        // Next, check every pair of eligible locals to see if they\n+        // conflict.\n+        for local_a in info.storage_conflicts.rows() {\n+            let conflicts_a = info.storage_conflicts.count(local_a);\n+            if ineligible_locals.contains(local_a) {\n+                continue;\n+            }\n+\n+            for local_b in info.storage_conflicts.iter(local_a) {\n+                // local_a and local_b are storage live at the same time, therefore they\n+                // cannot overlap in the generator layout. The only way to guarantee\n+                // this is if they are in the same variant, or one is ineligible\n+                // (which means it is stored in every variant).\n+                if ineligible_locals.contains(local_b) ||\n+                    assignments[local_a] == assignments[local_b]\n+                {\n+                    continue;\n+                }\n+\n+                // If they conflict, we will choose one to make ineligible.\n+                // This is not always optimal; it's just a greedy heuristic that\n+                // seems to produce good results most of the time.\n+                let conflicts_b = info.storage_conflicts.count(local_b);\n+                let (remove, other) = if conflicts_a > conflicts_b {\n+                    (local_a, local_b)\n+                } else {\n+                    (local_b, local_a)\n+                };\n+                ineligible_locals.insert(remove);\n+                assignments[remove] = Ineligible(None);\n+                trace!(\"removing local {:?} due to conflict with {:?}\", remove, other);\n+            }\n+        }\n+\n+        // Write down the order of our locals that will be promoted to the prefix.\n+        {\n+            let mut idx = 0u32;\n+            for local in ineligible_locals.iter() {\n+                assignments[local] = Ineligible(Some(idx));\n+                idx += 1;\n+            }\n+        }\n+        debug!(\"generator saved local assignments: {:?}\", assignments);\n+\n+        (ineligible_locals, assignments)\n+    }\n+\n+    /// Compute the full generator layout.\n+    fn generator_layout(\n+        &self,\n+        ty: Ty<'tcx>,\n+        def_id: hir::def_id::DefId,\n+        substs: &GeneratorSubsts<'tcx>,\n+    ) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n+        use SavedLocalEligibility::*;\n+        let tcx = self.tcx;\n+        let recompute_memory_index = |offsets: &[Size]| -> Vec<u32> {\n+            debug!(\"recompute_memory_index({:?})\", offsets);\n+            let mut inverse_index = (0..offsets.len() as u32).collect::<Vec<_>>();\n+            inverse_index.sort_unstable_by_key(|i| offsets[*i as usize]);\n+\n+            let mut index = vec![0; offsets.len()];\n+            for i in 0..index.len() {\n+                index[inverse_index[i] as usize] = i as u32;\n+            }\n+            debug!(\"recompute_memory_index() => {:?}\", index);\n+            index\n+        };\n+        let subst_field = |ty: Ty<'tcx>| { ty.subst(tcx, substs.substs) };\n+\n+        let info = tcx.generator_layout(def_id);\n+        let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&info);\n+\n+        // Build a prefix layout, including \"promoting\" all ineligible\n+        // locals as part of the prefix. We compute the layout of all of\n+        // these fields at once to get optimal packing.\n+        let discr_index = substs.prefix_tys(def_id, tcx).count();\n+        let promoted_tys =\n+            ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n+        let prefix_tys = substs.prefix_tys(def_id, tcx)\n+            .chain(iter::once(substs.discr_ty(tcx)))\n+            .chain(promoted_tys);\n+        let prefix = self.univariant_uninterned(\n+            ty,\n+            &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+            &ReprOptions::default(),\n+            StructKind::AlwaysSized)?;\n+        let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n+\n+        // Split the prefix layout into the \"outer\" fields (upvars and\n+        // discriminant) and the \"promoted\" fields. Promoted fields will\n+        // get included in each variant that requested them in\n+        // GeneratorLayout.\n+        debug!(\"prefix = {:#?}\", prefix);\n+        let (outer_fields, promoted_offsets) = match prefix.fields {\n+            FieldPlacement::Arbitrary { mut offsets, .. } => {\n+                let offsets_b = offsets.split_off(discr_index + 1);\n+                let offsets_a = offsets;\n+\n+                let memory_index = recompute_memory_index(&offsets_a);\n+                let outer_fields = FieldPlacement::Arbitrary { offsets: offsets_a, memory_index };\n+                (outer_fields, offsets_b)\n+            }\n+            _ => bug!(),\n+        };\n+\n+        let mut size = prefix.size;\n+        let mut align = prefix.align;\n+        let variants = info.variant_fields.iter_enumerated().map(|(index, variant_fields)| {\n+            // Only include overlap-eligible fields when we compute our variant layout.\n+            let variant_only_tys = variant_fields\n+                .iter()\n+                .filter(|local| {\n+                    match assignments[**local] {\n+                        Unassigned => bug!(),\n+                        Assigned(v) if v == index => true,\n+                        Assigned(_) => bug!(\"assignment does not match variant\"),\n+                        Ineligible(_) => false,\n+                    }\n+                })\n+                .map(|local| subst_field(info.field_tys[*local]));\n+\n+            let mut variant = self.univariant_uninterned(\n+                ty,\n+                &variant_only_tys\n+                    .map(|ty| self.layout_of(ty))\n+                    .collect::<Result<Vec<_>, _>>()?,\n+                &ReprOptions::default(),\n+                StructKind::Prefixed(prefix_size, prefix_align.abi))?;\n+            variant.variants = Variants::Single { index };\n+\n+            let offsets = match variant.fields {\n+                FieldPlacement::Arbitrary { offsets, .. } => offsets,\n+                _ => bug!(),\n+            };\n+\n+            // Now, stitch the promoted and variant-only fields back together in\n+            // the order they are mentioned by our GeneratorLayout.\n+            let mut next_variant_field = 0;\n+            let mut combined_offsets = Vec::new();\n+            for local in variant_fields.iter() {\n+                match assignments[*local] {\n+                    Unassigned => bug!(),\n+                    Assigned(_) => {\n+                        combined_offsets.push(offsets[next_variant_field]);\n+                        next_variant_field += 1;\n+                    }\n+                    Ineligible(field_idx) => {\n+                        let field_idx = field_idx.unwrap() as usize;\n+                        combined_offsets.push(promoted_offsets[field_idx]);\n+                    }\n+                }\n+            }\n+            let memory_index = recompute_memory_index(&combined_offsets);\n+            variant.fields = FieldPlacement::Arbitrary { offsets: combined_offsets, memory_index };\n+\n+            size = size.max(variant.size);\n+            align = align.max(variant.align);\n+            Ok(variant)\n+        }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+        let abi = if prefix.abi.is_uninhabited() ||\n+                     variants.iter().all(|v| v.abi.is_uninhabited()) {\n+            Abi::Uninhabited\n+        } else {\n+            Abi::Aggregate { sized: true }\n+        };\n+        let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n+            Abi::Scalar(s) => s.clone(),\n+            _ => bug!(),\n+        };\n+\n+        let layout = tcx.intern_layout(LayoutDetails {\n+            variants: Variants::Multiple {\n+                discr,\n+                discr_kind: DiscriminantKind::Tag,\n+                discr_index,\n+                variants,\n+            },\n+            fields: outer_fields,\n+            abi,\n+            size,\n+            align,\n+        });\n+        debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n+        Ok(layout)\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline(always)]"}, {"sha": "7a11ca070071b6ec26509361700aad60fa41f566", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -636,7 +636,7 @@ impl<T: Idx> GrowableBitSet<T> {\n ///\n /// All operations that involve a row and/or column index will panic if the\n /// index exceeds the relevant bound.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n     num_rows: usize,\n     num_columns: usize,\n@@ -658,6 +658,23 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         }\n     }\n \n+    /// Creates a new matrix, with `row` used as the value for every row.\n+    pub fn from_row_n(row: &BitSet<C>, num_rows: usize) -> BitMatrix<R, C> {\n+        let num_columns = row.domain_size();\n+        let words_per_row = num_words(num_columns);\n+        assert_eq!(words_per_row, row.words().len());\n+        BitMatrix {\n+            num_rows,\n+            num_columns,\n+            words: iter::repeat(row.words()).take(num_rows).flatten().cloned().collect(),\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    pub fn rows(&self) -> impl Iterator<Item = R> {\n+        (0..self.num_rows).map(R::new)\n+    }\n+\n     /// The range of bits for a given row.\n     fn range(&self, row: R) -> (usize, usize) {\n         let words_per_row = num_words(self.num_columns);\n@@ -737,6 +754,49 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         changed\n     }\n \n+    /// Adds the bits from `with` to the bits from row `write`, and\n+    /// returns `true` if anything changed.\n+    pub fn union_row_with(&mut self, with: &BitSet<C>, write: R) -> bool {\n+        assert!(write.index() < self.num_rows);\n+        assert_eq!(with.domain_size(), self.num_columns);\n+        let (write_start, write_end) = self.range(write);\n+        let mut changed = false;\n+        for (read_index, write_index) in (0..with.words().len()).zip(write_start..write_end) {\n+            let word = self.words[write_index];\n+            let new_word = word | with.words()[read_index];\n+            self.words[write_index] = new_word;\n+            changed |= word != new_word;\n+        }\n+        changed\n+    }\n+\n+    /// Sets every cell in `row` to true.\n+    pub fn insert_all_into_row(&mut self, row: R) {\n+        assert!(row.index() < self.num_rows);\n+        let (start, end) = self.range(row);\n+        let words = &mut self.words[..];\n+        for index in start..end {\n+            words[index] = !0;\n+        }\n+        self.clear_excess_bits(row);\n+    }\n+\n+    /// Clear excess bits in the final word of the row.\n+    fn clear_excess_bits(&mut self, row: R) {\n+        let num_bits_in_final_word = self.num_columns % WORD_BITS;\n+        if num_bits_in_final_word > 0 {\n+            let mask = (1 << num_bits_in_final_word) - 1;\n+            let (_, end) = self.range(row);\n+            let final_word_idx = end - 1;\n+            self.words[final_word_idx] &= mask;\n+        }\n+    }\n+\n+    /// Gets a slice of the underlying words.\n+    pub fn words(&self) -> &[Word] {\n+        &self.words\n+    }\n+\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n@@ -748,6 +808,12 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n             marker: PhantomData,\n         }\n     }\n+\n+    /// Returns the number of elements in `row`.\n+    pub fn count(&self, row: R) -> usize {\n+        let (start, end) = self.range(row);\n+        self.words[start..end].iter().map(|e| e.count_ones() as usize).sum()\n+    }\n }\n \n /// A fixed-column-size, variable-row-size 2D bit matrix with a moderately\n@@ -1057,6 +1123,7 @@ fn matrix_iter() {\n     matrix.insert(2, 99);\n     matrix.insert(4, 0);\n     matrix.union_rows(3, 5);\n+    matrix.insert_all_into_row(6);\n \n     let expected = [99];\n     let mut iter = expected.iter();\n@@ -1068,6 +1135,7 @@ fn matrix_iter() {\n \n     let expected = [22, 75];\n     let mut iter = expected.iter();\n+    assert_eq!(matrix.count(3), expected.len());\n     for i in matrix.iter(3) {\n         let j = *iter.next().unwrap();\n         assert_eq!(i, j);\n@@ -1076,6 +1144,7 @@ fn matrix_iter() {\n \n     let expected = [0];\n     let mut iter = expected.iter();\n+    assert_eq!(matrix.count(4), expected.len());\n     for i in matrix.iter(4) {\n         let j = *iter.next().unwrap();\n         assert_eq!(i, j);\n@@ -1084,11 +1153,24 @@ fn matrix_iter() {\n \n     let expected = [22, 75];\n     let mut iter = expected.iter();\n+    assert_eq!(matrix.count(5), expected.len());\n     for i in matrix.iter(5) {\n         let j = *iter.next().unwrap();\n         assert_eq!(i, j);\n     }\n     assert!(iter.next().is_none());\n+\n+    assert_eq!(matrix.count(6), 100);\n+    let mut count = 0;\n+    for (idx, i) in matrix.iter(6).enumerate() {\n+        assert_eq!(idx, i);\n+        count += 1;\n+    }\n+    assert_eq!(count, 100);\n+\n+    if let Some(i) = matrix.iter(7).next() {\n+        panic!(\"expected no elements in row, but contains element {:?}\", i);\n+    }\n }\n \n #[test]"}, {"sha": "0c81c27a96ee5e018cb7b52ea0f7d101c693d449", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -503,6 +503,16 @@ impl<I: indexed_vec::Idx, CTX> HashStable<CTX> for bit_set::BitSet<I>\n     }\n }\n \n+impl<R: indexed_vec::Idx, C: indexed_vec::Idx, CTX> HashStable<CTX>\n+for bit_set::BitMatrix<R, C>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.words().hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl_stable_hash_via_hash!(::std::path::Path);\n impl_stable_hash_via_hash!(::std::path::PathBuf);\n "}, {"sha": "9cba34b425350bbcb8e4e5bb6512eb8bd1b3914c", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -131,6 +131,11 @@ where\n         curr_state.subtract(&self.stmt_kill);\n         f(curr_state.iter());\n     }\n+\n+    /// Returns a bitset of the elements present in the current state.\n+    pub fn as_dense(&self) -> &BitSet<BD::Idx> {\n+        &self.curr_state\n+    }\n }\n \n impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>"}, {"sha": "0665d09d756aa7d1e0aa71bdf9f0e938e8b932f1", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 226, "deletions": 43, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -59,13 +59,14 @@ use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::SubstsRef;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::bit_set::{BitSet, BitMatrix};\n use std::borrow::Cow;\n use std::iter;\n use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n+use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n use crate::util::dump_mir;\n@@ -393,16 +394,33 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     }\n }\n \n+struct LivenessInfo {\n+    /// Which locals are live across any suspension point.\n+    ///\n+    /// GeneratorSavedLocal is indexed in terms of the elements in this set;\n+    /// i.e. GeneratorSavedLocal::new(1) corresponds to the second local\n+    /// included in this set.\n+    live_locals: liveness::LiveVarSet,\n+\n+    /// The set of saved locals live at each suspension point.\n+    live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n+\n+    /// For every saved local, the set of other saved locals that are\n+    /// storage-live at the same time as this local. We cannot overlap locals in\n+    /// the layout which have conflicting storage.\n+    storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n+\n+    /// For every suspending block, the locals which are storage-live across\n+    /// that suspension point.\n+    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+}\n+\n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n-) -> (\n-    liveness::LiveVarSet,\n-    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n-    BitSet<BasicBlock>,\n-) {\n+) -> LivenessInfo {\n     let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n \n@@ -432,7 +450,7 @@ fn locals_live_across_suspend_points(\n     };\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut set = liveness::LiveVarSet::new_empty(body.local_decls.len());\n+    let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n         body,\n     );\n@@ -445,13 +463,10 @@ fn locals_live_across_suspend_points(\n     );\n \n     let mut storage_liveness_map = FxHashMap::default();\n-\n-    let mut suspending_blocks = BitSet::new_empty(body.basic_blocks().len());\n+    let mut live_locals_at_suspension_points = Vec::new();\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n-            suspending_blocks.insert(block);\n-\n             let loc = Location {\n                 block: block,\n                 statement_index: data.statements.len(),\n@@ -490,20 +505,177 @@ fn locals_live_across_suspend_points(\n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)\n             // and their storage is live (the `storage_liveness` variable)\n-            storage_liveness.intersect(&liveness.outs[block]);\n+            let mut live_locals_here = storage_liveness;\n+            live_locals_here.intersect(&liveness.outs[block]);\n \n-            let live_locals = storage_liveness;\n+            // The generator argument is ignored\n+            live_locals_here.remove(self_arg());\n \n-            // Add the locals life at this suspension point to the set of locals which live across\n+            // Add the locals live at this suspension point to the set of locals which live across\n             // any suspension points\n-            set.union(&live_locals);\n+            live_locals.union(&live_locals_here);\n+\n+            live_locals_at_suspension_points.push(live_locals_here);\n+        }\n+    }\n+\n+    // Renumber our liveness_map bitsets to include only the locals we are\n+    // saving.\n+    let live_locals_at_suspension_points = live_locals_at_suspension_points\n+        .iter()\n+        .map(|live_here| renumber_bitset(&live_here, &live_locals))\n+        .collect();\n+\n+    let storage_conflicts = compute_storage_conflicts(\n+        body,\n+        &live_locals,\n+        &ignored,\n+        storage_live,\n+        storage_live_analysis);\n+\n+    LivenessInfo {\n+        live_locals,\n+        live_locals_at_suspension_points,\n+        storage_conflicts,\n+        storage_liveness: storage_liveness_map,\n+    }\n+}\n+\n+/// Renumbers the items present in `stored_locals` and applies the renumbering\n+/// to 'input`.\n+///\n+/// For example, if `stored_locals = [1, 3, 5]`, this would be renumbered to\n+/// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n+fn renumber_bitset(input: &BitSet<Local>, stored_locals: &liveness::LiveVarSet)\n+-> BitSet<GeneratorSavedLocal> {\n+    assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n+    let mut out = BitSet::new_empty(stored_locals.count());\n+    for (idx, local) in stored_locals.iter().enumerate() {\n+        let saved_local = GeneratorSavedLocal::from(idx);\n+        if input.contains(local) {\n+            out.insert(saved_local);\n+        }\n+    }\n+    debug!(\"renumber_bitset({:?}, {:?}) => {:?}\", input, stored_locals, out);\n+    out\n+}\n+\n+/// For every saved local, looks for which locals are StorageLive at the same\n+/// time. Generates a bitset for every local of all the other locals that may be\n+/// StorageLive simultaneously with that local. This is used in the layout\n+/// computation; see `GeneratorLayout` for more.\n+fn compute_storage_conflicts(\n+    body: &'mir Body<'tcx>,\n+    stored_locals: &liveness::LiveVarSet,\n+    ignored: &StorageIgnored,\n+    storage_live: DataflowResults<'tcx, MaybeStorageLive<'mir, 'tcx>>,\n+    _storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n+) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n+    assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n+    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n+    debug!(\"compute_storage_conflicts({:?})\", body.span);\n+    debug!(\"ignored = {:?}\", ignored.0);\n+\n+    // Storage ignored locals are not eligible for overlap, since their storage\n+    // is always live.\n+    let mut ineligible_locals = ignored.0.clone();\n+    ineligible_locals.intersect(&stored_locals);\n+\n+    // Compute the storage conflicts for all eligible locals.\n+    let mut visitor = StorageConflictVisitor {\n+        body,\n+        stored_locals: &stored_locals,\n+        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len())\n+    };\n+    let mut state = FlowAtLocation::new(storage_live);\n+    visitor.analyze_results(&mut state);\n+    let local_conflicts = visitor.local_conflicts;\n+\n+    // Compress the matrix using only stored locals (Local -> GeneratorSavedLocal).\n+    //\n+    // NOTE: Today we store a full conflict bitset for every local. Technically\n+    // this is twice as many bits as we need, since the relation is symmetric.\n+    // However, in practice these bitsets are not usually large. The layout code\n+    // also needs to keep track of how many conflicts each local has, so it's\n+    // simpler to keep it this way for now.\n+    let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n+    for (idx_a, local_a) in stored_locals.iter().enumerate() {\n+        let saved_local_a = GeneratorSavedLocal::new(idx_a);\n+        if ineligible_locals.contains(local_a) {\n+            // Conflicts with everything.\n+            storage_conflicts.insert_all_into_row(saved_local_a);\n+        } else {\n+            // Keep overlap information only for stored locals.\n+            for (idx_b, local_b) in stored_locals.iter().enumerate() {\n+                let saved_local_b = GeneratorSavedLocal::new(idx_b);\n+                if local_conflicts.contains(local_a, local_b) {\n+                    storage_conflicts.insert(saved_local_a, saved_local_b);\n+                }\n+            }\n         }\n     }\n+    storage_conflicts\n+}\n+\n+struct StorageConflictVisitor<'body, 'tcx: 'body, 's> {\n+    body: &'body Body<'tcx>,\n+    stored_locals: &'s liveness::LiveVarSet,\n+    // FIXME(tmandry): Consider using sparse bitsets here once we have good\n+    // benchmarks for generators.\n+    local_conflicts: BitMatrix<Local, Local>,\n+}\n+\n+impl<'body, 'tcx: 'body, 's> DataflowResultsConsumer<'body, 'tcx>\n+for StorageConflictVisitor<'body, 'tcx, 's> {\n+    type FlowState = FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>;\n+\n+    fn body(&self) -> &'body Body<'tcx> {\n+        self.body\n+    }\n+\n+    fn visit_block_entry(&mut self,\n+                         block: BasicBlock,\n+                         flow_state: &Self::FlowState) {\n+        // statement_index is only used for logging, so this is fine.\n+        self.apply_state(flow_state, Location { block, statement_index: 0 });\n+    }\n+\n+    fn visit_statement_entry(&mut self,\n+                             loc: Location,\n+                             _stmt: &Statement<'tcx>,\n+                             flow_state: &Self::FlowState) {\n+        self.apply_state(flow_state, loc);\n+    }\n+\n+    fn visit_terminator_entry(&mut self,\n+                              loc: Location,\n+                              _term: &Terminator<'tcx>,\n+                              flow_state: &Self::FlowState) {\n+        self.apply_state(flow_state, loc);\n+    }\n+}\n \n-    // The generator argument is ignored\n-    set.remove(self_arg());\n+impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n+    fn apply_state(&mut self,\n+                   flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n+                   loc: Location) {\n+        // Ignore unreachable blocks.\n+        match self.body.basic_blocks()[loc.block].terminator().kind {\n+            TerminatorKind::Unreachable => return,\n+            _ => (),\n+        };\n \n-    (set, storage_liveness_map, suspending_blocks)\n+        let mut eligible_storage_live = flow_state.as_dense().clone();\n+        eligible_storage_live.intersect(&self.stored_locals);\n+\n+        for local in eligible_storage_live.iter() {\n+            self.local_conflicts.union_row_with(&eligible_storage_live, local);\n+        }\n+\n+        if eligible_storage_live.count() > 1 {\n+            trace!(\"at {:?}, eligible_storage_live={:?}\", loc, eligible_storage_live);\n+        }\n+    }\n }\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -517,8 +689,9 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let (live_locals, storage_liveness, suspending_blocks) =\n-        locals_live_across_suspend_points(tcx, body, source, movable);\n+    let LivenessInfo {\n+        live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness\n+    } = locals_live_across_suspend_points(tcx, body, source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -547,37 +720,47 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), body.span);\n \n-    // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n-    // to avoid changing local indices\n-    let live_decls = live_locals.iter().map(|local| {\n+    // Gather live locals and their indices replacing values in body.local_decls\n+    // with a dummy to avoid changing local indices.\n+    let mut locals = IndexVec::<GeneratorSavedLocal, _>::new();\n+    let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n+    let mut decls = IndexVec::<GeneratorSavedLocal, _>::new();\n+    for (idx, local) in live_locals.iter().enumerate() {\n         let var = mem::replace(&mut body.local_decls[local], dummy_local.clone());\n-        (local, var)\n-    });\n+        locals.push(local);\n+        tys.push(var.ty);\n+        decls.push(var);\n+        debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n+    }\n \n-    // For now we will access everything via variant #3, leaving empty variants\n-    // for the UNRESUMED, RETURNED, and POISONED states.\n-    // If there were a yield-less generator without a variant #3, it would not\n-    // have any vars to remap, so we would never use this.\n-    let variant_index = VariantIdx::new(3);\n+    // Leave empty variants for the UNRESUMED, RETURNED, and POISONED states.\n+    const RESERVED_VARIANTS: usize = 3;\n \n+    // Build the generator variant field list.\n     // Create a map from local indices to generator struct indices.\n-    // We also create a vector of the LocalDecls of these locals.\n+    let mut variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>> =\n+        iter::repeat(IndexVec::new()).take(RESERVED_VARIANTS).collect();\n     let mut remap = FxHashMap::default();\n-    let mut decls = IndexVec::new();\n-    for (idx, (local, var)) in live_decls.enumerate() {\n-        remap.insert(local, (var.ty, variant_index, idx));\n-        decls.push(var);\n+    for (suspension_point_idx, live_locals) in live_locals_at_suspension_points.iter().enumerate() {\n+        let variant_index = VariantIdx::from(RESERVED_VARIANTS + suspension_point_idx);\n+        let mut fields = IndexVec::new();\n+        for (idx, saved_local) in live_locals.iter().enumerate() {\n+            fields.push(saved_local);\n+            // Note that if a field is included in multiple variants, we will\n+            // just use the first one here. That's fine; fields do not move\n+            // around inside generators, so it doesn't matter which variant\n+            // index we access them by.\n+            remap.entry(locals[saved_local]).or_insert((tys[saved_local], variant_index, idx));\n+        }\n+        variant_fields.push(fields);\n     }\n-    let field_tys = decls.iter().map(|field| field.ty).collect::<IndexVec<_, _>>();\n-\n-    // Put every var in each variant, for now.\n-    let all_vars = (0..field_tys.len()).map(GeneratorSavedLocal::from).collect();\n-    let empty_variants = iter::repeat(IndexVec::new()).take(3);\n-    let state_variants = iter::repeat(all_vars).take(suspending_blocks.count());\n+    debug!(\"generator variant_fields = {:?}\", variant_fields);\n+    debug!(\"generator storage_conflicts = {:#?}\", storage_conflicts);\n \n     let layout = GeneratorLayout {\n-        field_tys,\n-        variant_fields: empty_variants.chain(state_variants).collect(),\n+        field_tys: tys,\n+        variant_fields,\n+        storage_conflicts,\n         __local_debuginfo_codegen_only_do_not_use: decls,\n     };\n "}, {"sha": "05afd6d40197745303fc8ef57a0e0e221d52a998", "filename": "src/test/run-pass/async-fn-size.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Ftest%2Frun-pass%2Fasync-fn-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Ftest%2Frun-pass%2Fasync-fn-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-fn-size.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -0,0 +1,106 @@\n+// edition:2018\n+// aux-build:arc_wake.rs\n+\n+#![feature(async_await, await_macro)]\n+\n+extern crate arc_wake;\n+\n+use std::pin::Pin;\n+use std::future::Future;\n+use std::sync::{\n+    Arc,\n+    atomic::{self, AtomicUsize},\n+};\n+use std::task::{Context, Poll};\n+use arc_wake::ArcWake;\n+\n+struct Counter {\n+    wakes: AtomicUsize,\n+}\n+\n+impl ArcWake for Counter {\n+    fn wake(self: Arc<Self>) {\n+        Self::wake_by_ref(&self)\n+    }\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+    }\n+}\n+\n+struct WakeOnceThenComplete(bool, u8);\n+\n+impl Future for WakeOnceThenComplete {\n+    type Output = u8;\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<u8> {\n+        if self.0 {\n+            Poll::Ready(self.1)\n+        } else {\n+            cx.waker().wake_by_ref();\n+            self.0 = true;\n+            Poll::Pending\n+        }\n+    }\n+}\n+\n+fn wait(fut: impl Future<Output = u8>) -> u8 {\n+    let mut fut = Box::pin(fut);\n+    let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n+    let waker = ArcWake::into_waker(counter.clone());\n+    let mut cx = Context::from_waker(&waker);\n+    loop {\n+        match fut.as_mut().poll(&mut cx) {\n+            Poll::Ready(out) => return out,\n+            Poll::Pending => (),\n+        }\n+    }\n+}\n+\n+fn base() -> WakeOnceThenComplete { WakeOnceThenComplete(false, 1) }\n+\n+async fn await1_level1() -> u8 {\n+    await!(base())\n+}\n+\n+async fn await2_level1() -> u8 {\n+    await!(base()) + await!(base())\n+}\n+\n+async fn await3_level1() -> u8 {\n+    await!(base()) + await!(base()) + await!(base())\n+}\n+\n+async fn await3_level2() -> u8 {\n+    await!(await3_level1()) + await!(await3_level1()) + await!(await3_level1())\n+}\n+\n+async fn await3_level3() -> u8 {\n+    await!(await3_level2()) + await!(await3_level2()) + await!(await3_level2())\n+}\n+\n+async fn await3_level4() -> u8 {\n+    await!(await3_level3()) + await!(await3_level3()) + await!(await3_level3())\n+}\n+\n+async fn await3_level5() -> u8 {\n+    await!(await3_level4()) + await!(await3_level4()) + await!(await3_level4())\n+}\n+\n+fn main() {\n+    assert_eq!(2, std::mem::size_of_val(&base()));\n+    assert_eq!(8, std::mem::size_of_val(&await1_level1()));\n+    assert_eq!(12, std::mem::size_of_val(&await2_level1()));\n+    assert_eq!(12, std::mem::size_of_val(&await3_level1()));\n+    assert_eq!(20, std::mem::size_of_val(&await3_level2()));\n+    assert_eq!(28, std::mem::size_of_val(&await3_level3()));\n+    assert_eq!(36, std::mem::size_of_val(&await3_level4()));\n+    assert_eq!(44, std::mem::size_of_val(&await3_level5()));\n+\n+    assert_eq!(1,   wait(base()));\n+    assert_eq!(1,   wait(await1_level1()));\n+    assert_eq!(2,   wait(await2_level1()));\n+    assert_eq!(3,   wait(await3_level1()));\n+    assert_eq!(9,   wait(await3_level2()));\n+    assert_eq!(27,  wait(await3_level3()));\n+    assert_eq!(81,  wait(await3_level4()));\n+    assert_eq!(243, wait(await3_level5()));\n+}"}, {"sha": "704484a480e26a38ea993a8365765ead108f4347", "filename": "src/test/run-pass/generator/overlap-locals.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Ftest%2Frun-pass%2Fgenerator%2Foverlap-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05083c2dee278f79988fc4367c29f1a9b5a2d275/src%2Ftest%2Frun-pass%2Fgenerator%2Foverlap-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Foverlap-locals.rs?ref=05083c2dee278f79988fc4367c29f1a9b5a2d275", "patch": "@@ -0,0 +1,27 @@\n+#![feature(generators)]\n+\n+fn main() {\n+    let a = || {\n+        {\n+            let w: i32 = 4;\n+            yield;\n+            println!(\"{:?}\", w);\n+        }\n+        {\n+            let x: i32 = 5;\n+            yield;\n+            println!(\"{:?}\", x);\n+        }\n+        {\n+            let y: i32 = 6;\n+            yield;\n+            println!(\"{:?}\", y);\n+        }\n+        {\n+            let z: i32 = 7;\n+            yield;\n+            println!(\"{:?}\", z);\n+        }\n+    };\n+    assert_eq!(8, std::mem::size_of_val(&a));\n+}"}]}