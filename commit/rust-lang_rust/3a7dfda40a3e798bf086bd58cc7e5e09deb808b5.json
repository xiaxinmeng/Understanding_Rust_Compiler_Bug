{"sha": "3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhN2RmZGE0MGEzZTc5OGJmMDg2YmQ1OGNjN2U1ZTA5ZGViODA4YjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-19T18:32:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-19T18:32:40Z"}, "message": "Auto merge of #69171 - Amanieu:new-asm, r=nagisa,nikomatsakis\n\nImplement new asm! syntax from RFC 2850\n\nThis PR implements the new `asm!` syntax proposed in https://github.com/rust-lang/rfcs/pull/2850.\n\n# Design\n\nA large part of this PR revolves around taking an `asm!` macro invocation and plumbing it through all of the compiler layers down to LLVM codegen. Throughout the various stages, an `InlineAsm` generally consists of 3 components:\n\n- The template string, which is stored as an array of `InlineAsmTemplatePiece`. Each piece represents either a literal or a placeholder for an operand (just like format strings).\n```rust\npub enum InlineAsmTemplatePiece {\n    String(String),\n    Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n}\n```\n\n- The list of operands to the `asm!` (`in`, `[late]out`, `in[late]out`, `sym`, `const`). These are represented differently at each stage of lowering, but follow a common pattern:\n  - `in`, `out` and `inout` all have an associated register class (`reg`) or explicit register (`\"eax\"`).\n  - `inout` has 2 forms: one with a single expression that is both read from and written to, and one with two separate expressions for the input and output parts.\n  - `out` and `inout` have a `late` flag (`lateout` / `inlateout`) to indicate that the register allocator is allowed to reuse an input register for this output.\n  - `out` and the split variant of `inout` allow `_` to be specified for an output, which means that the output is discarded. This is used to allocate scratch registers for assembly code.\n  - `sym` is a bit special since it only accepts a path expression, which must point to a `static` or a `fn`.\n\n- The options set at the end of the `asm!` macro. The only one that is particularly of interest to rustc is `NORETURN` which makes `asm!` return `!` instead of `()`.\n```rust\nbitflags::bitflags! {\n    pub struct InlineAsmOptions: u8 {\n        const PURE = 1 << 0;\n        const NOMEM = 1 << 1;\n        const READONLY = 1 << 2;\n        const PRESERVES_FLAGS = 1 << 3;\n        const NORETURN = 1 << 4;\n        const NOSTACK = 1 << 5;\n    }\n}\n```\n\n## AST\n\n`InlineAsm` is represented as an expression in the AST:\n\n```rust\npub struct InlineAsm {\n    pub template: Vec<InlineAsmTemplatePiece>,\n    pub operands: Vec<(InlineAsmOperand, Span)>,\n    pub options: InlineAsmOptions,\n}\n\npub enum InlineAsmRegOrRegClass {\n    Reg(Symbol),\n    RegClass(Symbol),\n}\n\npub enum InlineAsmOperand {\n    In {\n        reg: InlineAsmRegOrRegClass,\n        expr: P<Expr>,\n    },\n    Out {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        expr: Option<P<Expr>>,\n    },\n    InOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        expr: P<Expr>,\n    },\n    SplitInOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        in_expr: P<Expr>,\n        out_expr: Option<P<Expr>>,\n    },\n    Const {\n        expr: P<Expr>,\n    },\n    Sym {\n        expr: P<Expr>,\n    },\n}\n```\n\nThe `asm!` macro is implemented in librustc_builtin_macros and outputs an `InlineAsm` AST node. The template string is parsed using libfmt_macros, positional and named operands are resolved to explicit operand indicies. Since target information is not available to macro invocations, validation of the registers and register classes is deferred to AST lowering.\n\n## HIR\n\n`InlineAsm` is represented as an expression in the HIR:\n\n```rust\npub struct InlineAsm<'hir> {\n    pub template: &'hir [InlineAsmTemplatePiece],\n    pub operands: &'hir [InlineAsmOperand<'hir>],\n    pub options: InlineAsmOptions,\n}\n\npub enum InlineAsmRegOrRegClass {\n    Reg(InlineAsmReg),\n    RegClass(InlineAsmRegClass),\n}\n\npub enum InlineAsmOperand<'hir> {\n    In {\n        reg: InlineAsmRegOrRegClass,\n        expr: Expr<'hir>,\n    },\n    Out {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        expr: Option<Expr<'hir>>,\n    },\n    InOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        expr: Expr<'hir>,\n    },\n    SplitInOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        in_expr: Expr<'hir>,\n        out_expr: Option<Expr<'hir>>,\n    },\n    Const {\n        expr: Expr<'hir>,\n    },\n    Sym {\n        expr: Expr<'hir>,\n    },\n}\n```\n\nAST lowering is where `InlineAsmRegOrRegClass` is converted from `Symbol`s to an actual register or register class. If any modifiers are specified for a template string placeholder, these are validated against the set allowed for that operand type. Finally, explicit registers for inputs and outputs are checked for conflicts (same register used for different operands).\n\n## Type checking\n\nEach register class has a whitelist of types that it may be used with. After the types of all operands have been determined, the `intrinsicck` pass will check that these types are in the whitelist. It also checks that split `inout` operands have compatible types and that `const` operands are integers or floats. Suggestions are emitted where needed if a template modifier should be used for an operand based on the type that was passed into it.\n\n## HAIR\n\n`InlineAsm` is represented as an expression in the HAIR:\n\n```rust\ncrate enum ExprKind<'tcx> {\n    // [..]\n    InlineAsm {\n        template: &'tcx [InlineAsmTemplatePiece],\n        operands: Vec<InlineAsmOperand<'tcx>>,\n        options: InlineAsmOptions,\n    },\n}\ncrate enum InlineAsmOperand<'tcx> {\n    In {\n        reg: InlineAsmRegOrRegClass,\n        expr: ExprRef<'tcx>,\n    },\n    Out {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        expr: Option<ExprRef<'tcx>>,\n    },\n    InOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        expr: ExprRef<'tcx>,\n    },\n    SplitInOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        in_expr: ExprRef<'tcx>,\n        out_expr: Option<ExprRef<'tcx>>,\n    },\n    Const {\n        expr: ExprRef<'tcx>,\n    },\n    SymFn {\n        expr: ExprRef<'tcx>,\n    },\n    SymStatic {\n        expr: ExprRef<'tcx>,\n    },\n}\n```\n\nThe only significant change compared to HIR is that `Sym` has been lowered to either a `SymFn` whose `expr` is a `Literal` ZST of the `fn`, or a `SymStatic` whose `expr` is a `StaticRef`.\n\n## MIR\n\n`InlineAsm` is represented as a `Terminator` in the MIR:\n\n```rust\npub enum TerminatorKind<'tcx> {\n    // [..]\n\n    /// Block ends with an inline assembly block. This is a terminator since\n    /// inline assembly is allowed to diverge.\n    InlineAsm {\n        /// The template for the inline assembly, with placeholders.\n        template: &'tcx [InlineAsmTemplatePiece],\n\n        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n        operands: Vec<InlineAsmOperand<'tcx>>,\n\n        /// Miscellaneous options for the inline assembly.\n        options: InlineAsmOptions,\n\n        /// Destination block after the inline assembly returns, unless it is\n        /// diverging (InlineAsmOptions::NORETURN).\n        destination: Option<BasicBlock>,\n    },\n}\n\npub enum InlineAsmOperand<'tcx> {\n    In {\n        reg: InlineAsmRegOrRegClass,\n        value: Operand<'tcx>,\n    },\n    Out {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        place: Option<Place<'tcx>>,\n    },\n    InOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        in_value: Operand<'tcx>,\n        out_place: Option<Place<'tcx>>,\n    },\n    Const {\n        value: Operand<'tcx>,\n    },\n    SymFn {\n        value: Box<Constant<'tcx>>,\n    },\n    SymStatic {\n        value: Box<Constant<'tcx>>,\n    },\n}\n```\n\nAs part of HAIR lowering, `InOut` and `SplitInOut` operands are lowered to a split form with a separate `in_value` and `out_place`.\n\nSemantically, the `InlineAsm` terminator is similar to the `Call` terminator except that it has multiple output places where a `Call` only has a single return place output.\n\nThe constant promotion pass is used to ensure that `const` operands are actually constants (using the same logic as `#[rustc_args_required_const]`).\n\n## Codegen\n\nOperands are lowered one more time before being passed to LLVM codegen:\n\n```rust\npub enum InlineAsmOperandRef<'tcx, B: BackendTypes + ?Sized> {\n    In {\n        reg: InlineAsmRegOrRegClass,\n        value: OperandRef<'tcx, B::Value>,\n    },\n    Out {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        place: Option<PlaceRef<'tcx, B::Value>>,\n    },\n    InOut {\n        reg: InlineAsmRegOrRegClass,\n        late: bool,\n        in_value: OperandRef<'tcx, B::Value>,\n        out_place: Option<PlaceRef<'tcx, B::Value>>,\n    },\n    Const {\n        string: String,\n    },\n    SymFn {\n        instance: Instance<'tcx>,\n    },\n    SymStatic {\n        def_id: DefId,\n    },\n}\n```\n\nThe operands are lowered to LLVM operands and constraint codes as follow:\n- `out` and the output part of `inout` operands are added first, as required by LLVM. Late output operands have a `=` prefix added to their constraint code, non-late output operands have a `=&` prefix added to their constraint code.\n- `in` operands are added normally.\n- `inout` operands are tied to the matching output operand.\n- `sym` operands are passed as function pointers or pointers, using the `\"s\"` constraint.\n- `const` operands are formatted to a string and directly inserted in the template string.\n\nThe template string is converted to LLVM form:\n- `$` characters are escaped as `$$`.\n- `const` operands are converted to strings and inserted directly.\n- Placeholders are formatted as `${X:M}` where `X` is the operand index and `M` is the modifier character. Modifiers are converted from the Rust form to the LLVM form.\n\nThe various options are converted to clobber constraints or LLVM attributes, refer to the [RFC](https://github.com/Amanieu/rfcs/blob/inline-asm/text/0000-inline-asm.md#mapping-to-llvm-ir) for more details.\n\nNote that LLVM is sometimes rather picky about what types it accepts for certain constraint codes so we sometimes need to insert conversions to/from a supported type. See the target-specific ISelLowering.cpp files in LLVM for details.\n\n# Adding support for new architectures\n\nAdding inline assembly support to an architecture is mostly a matter of defining the registers and register classes for that architecture. All the definitions for register classes are located in `src/librustc_target/asm/`.\n\nAdditionally you will need to implement lowering of these register classes to LLVM constraint codes in `src/librustc_codegen_llvm/asm.rs`.", "tree": {"sha": "6b16c0081f6f626ab2702a1f0cbb1543a25571df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b16c0081f6f626ab2702a1f0cbb1543a25571df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "html_url": "https://github.com/rust-lang/rust/commit/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "672b272077561ca7b5027a8aff9ea2957c7d4c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/672b272077561ca7b5027a8aff9ea2957c7d4c21", "html_url": "https://github.com/rust-lang/rust/commit/672b272077561ca7b5027a8aff9ea2957c7d4c21"}, {"sha": "1cfdc7ed0c97a082ca7e638d4114590d03a059a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfdc7ed0c97a082ca7e638d4114590d03a059a9", "html_url": "https://github.com/rust-lang/rust/commit/1cfdc7ed0c97a082ca7e638d4114590d03a059a9"}], "stats": {"total": 9564, "additions": 9285, "deletions": 279}, "files": [{"sha": "6295b40e9762977d1dab4892c587018ce50eda1e", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -635,9 +635,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.27\"\n+version = \"0.1.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38f18416546abfbf8d801c555a0e99524453e7214f9cc9107ad49de3d5948ccc\"\n+checksum = \"439a6fab343b1dab347823537734a5cd4ae6ae2000b465ab886f64cdb723bd14\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -1012,9 +1012,9 @@ dependencies = [\n \n [[package]]\n name = \"dlmalloc\"\n-version = \"0.1.3\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f283302e035e61c23f2b86b3093e8c6273a4c3125742d6087e96ade001ca5e63\"\n+checksum = \"35055b1021724f4eb5262eb49130eebff23fc59fc5a14160e05faad8eeb36673\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -3625,6 +3625,7 @@ dependencies = [\n name = \"rustc_ast\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags\",\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n@@ -3678,6 +3679,7 @@ dependencies = [\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_span\",\n+ \"rustc_target\",\n ]\n \n [[package]]"}, {"sha": "0b68991fce2a1053538de77b9ec7805edcae4839", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "added", "additions": 699, "deletions": 0, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,699 @@\n+# `asm`\n+\n+The tracking issue for this feature is: [#72016]\n+\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n+\n+------------------------\n+\n+For extremely low-level manipulations and performance reasons, one\n+might wish to control the CPU directly. Rust supports using inline\n+assembly to do this via the `asm!` macro.\n+\n+# Guide-level explanation\n+[guide-level-explanation]: #guide-level-explanation\n+\n+Rust provides support for inline assembly via the `asm!` macro.\n+It can be used to embed handwritten assembly in the assembly output generated by the compiler.\n+Generally this should not be necessary, but might be where the required performance or timing\n+cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but ARM, AArch64 and RISC-V are also supported.\n+\n+## Basic usage\n+\n+Let us start with the simplest possible example:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+unsafe {\n+    asm!(\"nop\");\n+}\n+```\n+\n+This will insert a NOP (no operation) instruction into the assembly generated by the compiler.\n+Note that all `asm!` invocations have to be inside an `unsafe` block, as they could insert\n+arbitrary instructions and break various invariants. The instructions to be inserted are listed\n+in the first argument of the `asm!` macro as a string literal.\n+\n+## Inputs and outputs\n+\n+Now inserting an instruction that does nothing is rather boring. Let us do something that\n+actually acts on data:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64;\n+unsafe {\n+    asm!(\"mov {}, 5\", out(reg) x);\n+}\n+assert_eq!(x, 5);\n+```\n+\n+This will write the value `5` into the `u64` variable `x`.\n+You can see that the string literal we use to specify instructions is actually a template string.\n+It is governed by the same rules as Rust [format strings][format-syntax].\n+The arguments that are inserted into the template however look a bit different then you may\n+be familiar with. First we need to specify if the variable is an input or an output of the\n+inline assembly. In this case it is an output. We declared this by writing `out`.\n+We also need to specify in what kind of register the assembly expects the variable.\n+In this case we put it in an arbitrary general purpose register by specifying `reg`.\n+The compiler will choose an appropriate register to insert into\n+the template and will read the variable from there after the inline assembly finishes executing.\n+\n+Let us see another example that also uses an input:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let i: u64 = 3;\n+let o: u64;\n+unsafe {\n+    asm!(\"\n+        mov {0}, {1}\n+        add {0}, {number}\n+    \", out(reg) o, in(reg) i, number = const 5);\n+}\n+assert_eq!(o, 8);\n+```\n+\n+This will add `5` to the input in variable `i` and write the result to variable `o`.\n+The particular way this assembly does this is first copying the value from `i` to the output,\n+and then adding `5` to it.\n+\n+The example shows a few things:\n+\n+First we can see that inputs are declared by writing `in` instead of `out`.\n+\n+Second one of our operands has a type we haven't seen yet, `const`.\n+This tells the compiler to expand this argument to value directly inside the assembly template.\n+This is only possible for constants and literals.\n+\n+Third we can see that we can specify an argument number, or name as in any format string.\n+For inline assembly templates this is particularly useful as arguments are often used more than once.\n+For more complex inline assembly using this facility is generally recommended, as it improves\n+readability, and allows reordering instructions without changing the argument order.\n+\n+We can further refine the above example to avoid the `mov` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut x: u64 = 3;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x, number = const 5);\n+}\n+assert_eq!(x, 8);\n+```\n+\n+We can see that `inout` is used to specify an argument that is both input and output.\n+This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.\n+\n+It is also possible to specify different variables for the input and output parts of an `inout` operand:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64 = 3;\n+let y: u64;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x => y, number = const 5);\n+}\n+assert_eq!(y, 8);\n+```\n+\n+## Late output operands\n+\n+The Rust compiler is conservative with its allocation of operands. It is assumed that an `out`\n+can be written at any time, and can therefore not share its location with any other argument.\n+However, to guarantee optimal performance it is important to use as few registers as possible,\n+so they won't have to be saved and reloaded around the inline assembly block.\n+To achieve this Rust provides a `lateout` specifier. This can be used on any output that is\n+written only after all inputs have been consumed.\n+There is also a `inlateout` variant of this specifier.\n+\n+Here is an example where `inlateout` *cannot* be used:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+let c: u64 = 4;\n+unsafe {\n+    asm!(\"\n+        add {0}, {1}\n+        add {0}, {2}\n+    \", inout(reg) a, in(reg) b, in(reg) c);\n+}\n+assert_eq!(a, 12);\n+```\n+\n+Here the compiler is free to allocate the same register for inputs `b` and `c` since it knows they have the same value. However it must allocate a separate register for `a` since it uses `inout` and not `inlateout`. If `inlateout` was used, then `a` and `c` could be allocated to the same register, in which case the first instruction to overwrite the value of `c` and cause the assembly code to produce the wrong result.\n+\n+However the following example can use `inlateout` since the output is only modified after all input registers have been read:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+unsafe {\n+    asm!(\"add {0}, {1}\", inlateout(reg) a, in(reg) b);\n+}\n+assert_eq!(a, 8);\n+```\n+\n+As you can see, this assembly fragment will still work correctly if `a` and `b` are assigned to the same register.\n+\n+## Explicit register operands\n+\n+Some instructions require that the operands be in a specific register.\n+Therefore, Rust inline assembly provides some more specific constraint specifiers.\n+While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n+among others can be addressed by their name.\n+\n+```rust,allow_fail,no_run\n+# #![feature(asm)]\n+let cmd = 0xd1;\n+unsafe {\n+    asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n+}\n+```\n+\n+In this example we call the `out` instruction to output the content of the `cmd` variable\n+to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand\n+we had to use the `eax` constraint specifier.\n+\n+Note that unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n+\n+Consider this example which uses the x86 `mul` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+fn mul(a: u64, b: u64) -> u128 {\n+    let lo: u64;\n+    let hi: u64;\n+\n+    unsafe {\n+        asm!(\n+            // The x86 mul instruction takes rax as an implicit input and writes\n+            // the 128-bit result of the multiplication to rax:rdx.\n+            \"mul {}\",\n+            in(reg) a,\n+            inlateout(\"rax\") b => lo,\n+            lateout(\"rdx\") hi\n+        );\n+    }\n+\n+    (hi as u128) << 64 + lo as u128\n+}\n+```\n+\n+This uses the `mul` instruction to multiply two 64-bit inputs with a 128-bit result.\n+The only explicit operand is a register, that we fill from the variable `a`.\n+The second operand is implicit, and must be the `rax` register, which we fill from the variable `b`.\n+The lower 64 bits of the result are stored in `rax` from which we fill the variable `lo`.\n+The higher 64 bits are stored in `rdx` from which we fill the variable `hi`.\n+\n+## Clobbered registers\n+\n+In many cases inline assembly will modify state that is not needed as an output.\n+Usually this is either because we have to use a scratch register in the assembly,\n+or instructions modify state that we don't need to further examine.\n+This state is generally referred to as being \"clobbered\".\n+We need to tell the compiler about this since it may need to save and restore this state\n+around the inline assembly block.\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let ebx: u32;\n+let ecx: u32;\n+\n+unsafe {\n+    asm!(\n+        \"cpuid\",\n+        // EAX 4 selects the \"Deterministic Cache Parameters\" CPUID leaf\n+        inout(\"eax\") 4 => _,\n+        // ECX 0 selects the L0 cache information.\n+        inout(\"ecx\") 0 => ecx,\n+        lateout(\"ebx\") ebx,\n+        lateout(\"edx\") _\n+    );\n+}\n+\n+println!(\n+    \"L1 Cache: {}\",\n+    ((ebx >> 22) + 1) * (((ebx >> 12) & 0x3ff) + 1) * ((ebx & 0xfff) + 1) * (ecx + 1)\n+);\n+```\n+\n+In the example above we use the `cpuid` instruction to get the L1 cache size.\n+This instruction writes to `eax`, `ebx`, `ecx`, and `edx`, but for the cache size we only care about the contents of `ebx` and `ecx`.\n+\n+However we still need to tell the compiler that `eax` and `edx` have been modified so that it can save any values that were in these registers before the asm. This is done by declaring these as outputs but with `_` instead of a variable name, which indicates that the output value is to be discarded.\n+\n+This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+// Multiply x by 6 using shifts and adds\n+let mut x: u64 = 4;\n+unsafe {\n+    asm!(\"\n+        mov {tmp}, {x}\n+        shl {tmp}, 1\n+        shl {x}, 2\n+        add {x}, {tmp}\n+    \", x = inout(reg) x, tmp = out(reg) _);\n+}\n+assert_eq!(x, 4 * 6);\n+```\n+\n+## Symbol operands\n+\n+A special operand type, `sym`, allows you to use the symbol name of a `fn` or `static` in inline assembly code.\n+This allows you to call a function or access a global variable without needing to keep its address in a register.\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+extern \"C\" fn foo(arg: i32) {\n+    println!(\"arg = {}\", arg);\n+}\n+\n+fn call_foo(arg: i32) {\n+    unsafe {\n+        asm!(\n+            \"call {}\",\n+            sym foo,\n+            // 1st argument in rdi, which is caller-saved\n+            inout(\"rdi\") arg => _,\n+            // All caller-saved registers must be marked as clobberred\n+            out(\"rax\") _, out(\"rcx\") _, out(\"rdx\") _, out(\"rsi\") _,\n+            out(\"r8\") _, out(\"r9\") _, out(\"r10\") _, out(\"r11\") _,\n+            out(\"xmm0\") _, out(\"xmm1\") _, out(\"xmm2\") _, out(\"xmm3\") _,\n+            out(\"xmm4\") _, out(\"xmm5\") _, out(\"xmm6\") _, out(\"xmm7\") _,\n+            out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n+            out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n+        )\n+    }\n+}\n+```\n+\n+Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`:\n+the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n+\n+## Register template modifiers\n+\n+In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a \"view\" over a subset of the register (e.g. the low 32 bits of a 64-bit register).\n+\n+By default the compiler will always choose the name that refers to the full register size (e.g. `rax` on x86-64, `eax` on x86, etc).\n+\n+This default can be overriden by using modifiers on the template string operands, just like you would with format strings:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut x: u16 = 0xab;\n+\n+unsafe {\n+    asm!(\"mov {0:h}, {0:l}\", inout(reg_abcd) x);\n+}\n+\n+assert_eq!(x, 0xabab);\n+```\n+\n+In this example, we use the `reg_abcd` register class to restrict the register allocator to the 4 legacy x86 register (`ax`, `bx`, `cx`, `dx`) of which the first two bytes can be addressed independently.\n+\n+Let us assume that the register allocator has chosen to allocate `x` in the `ax` register.\n+The `h` modifier will emit the register name for the high byte of that register and the `l` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.\n+\n+If you use a smaller data type (e.g. `u16`) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.\n+\n+## Options\n+\n+By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n+\n+Let's take our previous example of an `add` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+unsafe {\n+    asm!(\n+        \"add {0}, {1}\",\n+        inlateout(reg) a, in(reg) b,\n+        options(pure, nomem, nostack)\n+    );\n+}\n+assert_eq!(a, 8);\n+```\n+\n+Options can be provided as an optional final argument to the `asm!` macro. We specified three options here:\n+- `pure` means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.\n+- `nomem` means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).\n+- `nostack` means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.\n+\n+These allow the compiler to better optimize code using `asm!`, for example by eliminating pure `asm!` blocks whose outputs are not needed.\n+\n+See the reference for the full list of available options and their effects.\n+\n+# Reference-level explanation\n+[reference-level-explanation]: #reference-level-explanation\n+\n+Inline assembler is implemented as an unsafe macro `asm!()`.\n+The first argument to this macro is a template string literal used to build the final assembly.\n+The following arguments specify input and output operands.\n+When required, options are specified as the final argument.\n+\n+The following ABNF specifies the general syntax:\n+\n+```ignore\n+dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n+reg_spec := <register class> / \"<explicit register>\"\n+operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n+reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n+operand := reg_operand / \"const\" const_expr / \"sym\" path\n+option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"att_syntax\"\n+options := \"options(\" option *[\",\" option] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+```\n+\n+The macro will initially be supported only on ARM, AArch64, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+\n+[format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n+\n+## Template string\n+\n+The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.\n+\n+As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after any named arguments if any. Explicit register operands cannot be used by placeholders in the template string. All other operands must appear at least once in the template string, otherwise a compiler error is generated.\n+\n+The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.\n+\n+The 4 targets specified in this RFC (x86, ARM, AArch64, RISC-V) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n+\n+[rfc-2795]: https://github.com/rust-lang/rfcs/pull/2795\n+\n+## Operand type\n+\n+Several types of operands are supported:\n+\n+* `in(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - The allocated register must contain the same value at the end of the asm code (except if a `lateout` is allocated to the same register).\n+* `out(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain an undefined value at the start of the asm code.\n+  - `<expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+* `lateout(<reg>) <expr>`\n+  - Identical to `out` except that the register allocator can reuse a register allocated to an `in`.\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `inout(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - `<expr>` must be a mutable initialized place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+* `inout(<reg>) <in expr> => <out expr>`\n+  - Same as `inout` except that the initial value of the register is taken from the value of `<in expr>`.\n+  - `<out expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression for `<out expr>`, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+  - `<in expr>` and `<out expr>` may have different types.\n+* `inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`\n+  - Identical to `inout` except that the register allocator can reuse a register allocated to an `in` (this can happen if the compiler knows the `in` has the same initial value as the `inlateout`).\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `const <expr>`\n+  - `<expr>` must be an integer or floating-point constant expression.\n+  - The value of the expression is formatted as a string and substituted directly into the asm template string.\n+* `sym <path>`\n+  - `<path>` must refer to a `fn` or `static`.\n+  - A mangled symbol name referring to the item is substituted into the asm template string.\n+  - The substituted string does not include any modifiers (e.g. GOT, PLT, relocations, etc).\n+  - `<path>` is allowed to point to a `#[thread_local]` static, in which case the asm code can combine the symbol with relocations (e.g. `@plt`, `@TPOFF`) to read from thread-local data.\n+\n+Operand expressions are evaluated from left to right, just like function call arguments. After the `asm!` has executed, outputs are written to in left to right order. This is significant if two outputs point to the same place: that place will contain the value of the rightmost output.\n+\n+## Register operands\n+\n+Input and output operands can be specified either as an explicit register or as a register class from which the register allocator can select a register. Explicit registers are specified as string literals (e.g. `\"eax\"`) while register classes are specified as identifiers (e.g. `reg`). Using string literals for register names enables support for architectures that use special characters in register names, such as MIPS (`$0`, `$1`, etc).\n+\n+Note that explicit registers treat register aliases (e.g. `r14` vs `lr` on ARM) and smaller views of a register (e.g. `eax` vs `rax`) as equivalent to the base register. It is a compile-time error to use the same explicit register for two input operands or two output operands. Additionally, it is also a compile-time error to use overlapping registers (e.g. ARM VFP) in input operands or in output operands.\n+\n+Only the following types are allowed as operands for inline assembly:\n+- Integers (signed and unsigned)\n+- Floating-point numbers\n+- Pointers (thin only)\n+- Function pointers\n+- SIMD vectors (structs defined with `#[repr(simd)]` and which implement `Copy`). This includes architecture-specific vector types defined in `std::arch` such as `__m128` (x86) or `int8x16_t` (ARM).\n+\n+Here is the list of currently supported register classes:\n+\n+| Architecture | Register class | Registers | LLVM constraint code |\n+| ------------ | -------------- | --------- | -------------------- |\n+| x86 | `reg` | `ax`, `bx`, `cx`, `dx`, `si`, `di`, `r[8-15]` (x86-64 only) | `r` |\n+| x86 | `reg_abcd` | `ax`, `bx`, `cx`, `dx` | `Q` |\n+| x86-32 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `ah`, `bh`, `ch`, `dh` | `q` |\n+| x86-64 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `sil`, `dil`, `r[8-15]b`, `ah`\\*, `bh`\\*, `ch`\\*, `dh`\\* | `q` |\n+| x86 | `xmm_reg` | `xmm[0-7]` (x86) `xmm[0-15]` (x86-64) | `x` |\n+| x86 | `ymm_reg` | `ymm[0-7]` (x86) `ymm[0-15]` (x86-64) | `x` |\n+| x86 | `zmm_reg` | `zmm[0-7]` (x86) `zmm[0-31]` (x86-64) | `v` |\n+| x86 | `kreg` | `k[1-7]` | `Yk` |\n+| AArch64 | `reg` | `x[0-28]`, `x30` | `r` |\n+| AArch64 | `vreg` | `v[0-31]` | `w` |\n+| AArch64 | `vreg_low16` | `v[0-15]` | `x` |\n+| ARM | `reg` | `r[0-r10]`, `r12`, `r14` | `r` |\n+| ARM (Thumb) | `reg_thumb` | `r[0-r7]` | `l` |\n+| ARM (ARM) | `reg_thumb` | `r[0-r10]`, `r12`, `r14` | `l` |\n+| ARM | `sreg` | `s[0-31]` | `t` |\n+| ARM | `sreg_low16` | `s[0-15]` | `x` |\n+| ARM | `dreg` | `d[0-31]` | `w` |\n+| ARM | `dreg_low16` | `d[0-15]` | `t` |\n+| ARM | `dreg_low8` | `d[0-8]` | `x` |\n+| ARM | `qreg` | `q[0-15]` | `w` |\n+| ARM | `qreg_low8` | `q[0-7]` | `t` |\n+| ARM | `qreg_low4` | `q[0-3]` | `x` |\n+| RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n+| RISC-V | `freg` | `f[0-31]` | `f` |\n+\n+> **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n+>\n+> Note #2: On x86-64 the high byte registers (e.g. `ah`) are only available when used as an explicit register. Specifying the `reg_byte` register class for an operand will always allocate a low byte register.\n+\n+Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n+\n+Each register class has constraints on which value types they can be used with. This is necessary because the way a value is loaded into a register depends on its type. For example, on big-endian systems, loading a `i32x4` and a `i8x16` into a SIMD register may result in different register contents even if the byte-wise memory representation of both values is identical. The availability of supported types for a particular register class may depend on what target features are currently enabled.\n+\n+| Architecture | Register class | Target feature | Allowed types |\n+| ------------ | -------------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `i16`, `i32`, `f32` |\n+| x86-64 | `reg` | None | `i16`, `i32`, `f32`, `i64`, `f64` |\n+| x86 | `reg_byte` | None | `i8` |\n+| x86 | `xmm_reg` | `sse` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| x86 | `ymm_reg` | `avx` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` |\n+| x86 | `zmm_reg` | `avx512f` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` <br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8` |\n+| x86 | `kreg` | `axv512f` | `i8`, `i16` |\n+| x86 | `kreg` | `axv512bw` | `i32`, `i64` |\n+| AArch64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| AArch64 | `vreg` | `fp` | `i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| ARM | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| ARM | `sreg` | `vfp2` | `i32`, `f32` |\n+| ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n+| ARM | `qreg` | `neon` | `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4` |\n+| RISC-V32 | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| RISC-V | `freg` | `f` | `f32` |\n+| RISC-V | `freg` | `d` | `f64` |\n+\n+> **Note**: For the purposes of the above table pointers, function pointers and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/`i64` depending on the target).\n+\n+If a value is of a smaller size than the register it is allocated in then the upper bits of that register will have an undefined value for inputs and will be ignored for outputs. The only exception is the `freg` register class on RISC-V where `f32` values are NaN-boxed in a `f64` as required by the RISC-V architecture.\n+\n+When separate input and output expressions are specified for an `inout` operand, both expressions must have the same type. The only exception is if both operands are pointers or integers, in which case they are only required to have the same size. This restriction exists because the register allocators in LLVM and GCC sometimes cannot handle tied operands with different types.\n+\n+## Register names\n+\n+Some registers have multiple names. These are all treated by the compiler as identical to the base register name. Here is the list of all supported register aliases:\n+\n+| Architecture | Base register | Aliases |\n+| ------------ | ------------- | ------- |\n+| x86 | `ax` | `eax`, `rax` |\n+| x86 | `bx` | `ebx`, `rbx` |\n+| x86 | `cx` | `ecx`, `rcx` |\n+| x86 | `dx` | `edx`, `rdx` |\n+| x86 | `si` | `esi`, `rsi` |\n+| x86 | `di` | `edi`, `rdi` |\n+| x86 | `bp` | `bpl`, `ebp`, `rbp` |\n+| x86 | `sp` | `spl`, `esp`, `rsp` |\n+| x86 | `ip` | `eip`, `rip` |\n+| x86 | `st(0)` | `st` |\n+| x86 | `r[8-15]` | `r[8-15]b`, `r[8-15]w`, `r[8-15]d` |\n+| x86 | `xmm[0-31]` | `ymm[0-31]`, `zmm[0-31]` |\n+| AArch64 | `x[0-30]` | `w[0-30]` |\n+| AArch64 | `x29` | `fp` |\n+| AArch64 | `x30` | `lr` |\n+| AArch64 | `sp` | `wsp` |\n+| AArch64 | `xzr` | `wzr` |\n+| AArch64 | `v[0-31]` | `b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]` |\n+| ARM | `r[0-3]` | `a[1-4]` |\n+| ARM | `r[4-9]` | `v[1-6]` |\n+| ARM | `r9` | `rfp` |\n+| ARM | `r10` | `sl` |\n+| ARM | `r11` | `fp` |\n+| ARM | `r12` | `ip` |\n+| ARM | `r13` | `sp` |\n+| ARM | `r14` | `lr` |\n+| ARM | `r15` | `pc` |\n+| RISC-V | `x0` | `zero` |\n+| RISC-V | `x1` | `ra` |\n+| RISC-V | `x2` | `sp` |\n+| RISC-V | `x3` | `gp` |\n+| RISC-V | `x4` | `tp` |\n+| RISC-V | `x[5-7]` | `t[0-2]` |\n+| RISC-V | `x8` | `fp`, `s0` |\n+| RISC-V | `x9` | `s1` |\n+| RISC-V | `x[10-17]` | `a[0-7]` |\n+| RISC-V | `x[18-27]` | `s[2-11]` |\n+| RISC-V | `x[28-31]` | `t[3-6]` |\n+| RISC-V | `f[0-7]` | `ft[0-7]` |\n+| RISC-V | `f[8-9]` | `fs[0-1]` |\n+| RISC-V | `f[10-17]` | `fa[0-7]` |\n+| RISC-V | `f[18-27]` | `fs[2-11]` |\n+| RISC-V | `f[28-31]` | `ft[8-11]` |\n+\n+Some registers cannot be used for input or output operands:\n+\n+| Architecture | Unsupported register | Reason |\n+| ------------ | -------------------- | ------ |\n+| All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |\n+| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V) | The frame pointer cannot be used as an input or output. |\n+| x86 | `k0` | This is a constant zero register which can't be modified. |\n+| x86 | `ip` | This is the program counter, not a real register. |\n+| x86 | `mm[0-7]` | MMX registers are not currently supported (but may be in the future). |\n+| x86 | `st([0-7])` | x87 registers are not currently supported (but may be in the future). |\n+| AArch64 | `xzr` | This is a constant zero register which can't be modified. |\n+| ARM | `pc` | This is the program counter, not a real register. |\n+| RISC-V | `x0` | This is a constant zero register which can't be modified. |\n+| RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n+\n+## Template modifiers\n+\n+The placeholders can be augmented by modifiers which are specified after the `:` in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string. Only one modifier is allowed per template placeholder.\n+\n+The supported modifiers are a subset of LLVM's (and GCC's) [asm template argument modifiers][llvm-argmod], but do not use the same letter codes.\n+\n+| Architecture | Register class | Modifier | Example output | LLVM modifier |\n+| ------------ | -------------- | -------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `eax` | `k` |\n+| x86-64 | `reg` | None | `rax` | `q` |\n+| x86-32 | `reg_abcd` | `l` | `al` | `b` |\n+| x86-64 | `reg` | `l` | `al` | `b` |\n+| x86 | `reg_abcd` | `h` | `ah` | `h` |\n+| x86 | `reg` | `x` | `ax` | `w` |\n+| x86 | `reg` | `e` | `eax` | `k` |\n+| x86-64 | `reg` | `r` | `rax` | `q` |\n+| x86 | `reg_byte` | None | `al` / `ah` | None |\n+| x86 | `xmm_reg` | None | `xmm0` | `x` |\n+| x86 | `ymm_reg` | None | `ymm0` | `t` |\n+| x86 | `zmm_reg` | None | `zmm0` | `g` |\n+| x86 | `*mm_reg` | `x` | `xmm0` | `x` |\n+| x86 | `*mm_reg` | `y` | `ymm0` | `t` |\n+| x86 | `*mm_reg` | `z` | `zmm0` | `g` |\n+| x86 | `kreg` | None | `k1` | None |\n+| AArch64 | `reg` | None | `x0` | `x` |\n+| AArch64 | `reg` | `w` | `w0` | `w` |\n+| AArch64 | `reg` | `x` | `x0` | `x` |\n+| AArch64 | `vreg` | None | `v0` | None |\n+| AArch64 | `vreg` | `v` | `v0` | None |\n+| AArch64 | `vreg` | `b` | `b0` | `b` |\n+| AArch64 | `vreg` | `h` | `h0` | `h` |\n+| AArch64 | `vreg` | `s` | `s0` | `s` |\n+| AArch64 | `vreg` | `d` | `d0` | `d` |\n+| AArch64 | `vreg` | `q` | `q0` | `q` |\n+| ARM | `reg` | None | `r0` | None |\n+| ARM | `sreg` | None | `s0` | None |\n+| ARM | `dreg` | None | `d0` | `P` |\n+| ARM | `qreg` | None | `q0` | `q` |\n+| ARM | `qreg` | `e` / `f` | `d0` / `d1` | `e` / `f` |\n+| RISC-V | `reg` | None | `x1` | None |\n+| RISC-V | `freg` | None | `f0` | None |\n+\n+> Notes:\n+> - on ARM `e` / `f`: this prints the low or high doubleword register name of a NEON quad (128-bit) register.\n+> - on x86: our behavior for `reg` with no modifiers differs from what GCC does. GCC will infer the modifier based on the operand value type, while we default to the full register size.\n+> - on x86 `xmm_reg`: the `x`, `t` and `g` LLVM modifiers are not yet implemented in LLVM (they are supported by GCC only), but this should be a simple change.\n+\n+As stated in the previous section, passing an input value smaller than the register width will result in the upper bits of the register containing undefined values. This is not a problem if the inline asm only accesses the lower bits of the register, which can be done by using a template modifier to use a subregister name in the asm code (e.g. `ax` instead of `rax`). Since this an easy pitfall, the compiler will suggest a template modifier to use where appropriate given the input type. If all references to an operand already have modifiers then the warning is suppressed for that operand.\n+\n+[llvm-argmod]: http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers\n+\n+## Options\n+\n+Flags are used to further influence the behavior of the inline assembly block.\n+Currently the following options are defined:\n+- `pure`: The `asm` block has no side effects, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to) or values read from memory (unless the `nomem` options is also set). This allows the compiler to execute the `asm` block fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used.\n+- `nomem`: The `asm` blocks does not read or write to any memory. This allows the compiler to cache the values of modified global variables in registers across the `asm` block since it knows that they are not read or written to by the `asm`.\n+- `readonly`: The `asm` block does not write to any memory. This allows the compiler to cache the values of unmodified global variables in registers across the `asm` block since it knows that they are not written to by the `asm`.\n+- `preserves_flags`: The `asm` block does not modify the flags register (defined in the rules below). This allows the compiler to avoid recomputing the condition flags after the `asm` block.\n+- `noreturn`: The `asm` block never returns, and its return type is defined as `!` (never). Behavior is undefined if execution falls through past the end of the asm code. A `noreturn` asm block behaves just like a function which doesn't return; notably, local variables in scope are not dropped before it is invoked.\n+- `nostack`: The `asm` block does not push data to the stack, or write to the stack red-zone (if supported by the target). If this option is *not* used then the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+- `att_syntax`: This option is only valid on x86, and causes the assembler to use the `.att_syntax prefix` mode of the GNU assembler. Register operands are substituted in with a leading `%`.\n+\n+The compiler performs some additional checks on options:\n+- The `nomem` and `readonly` options are mutually exclusive: it is a compile-time error to specify both.\n+- The `pure` option must be combined with either the `nomem` or `readonly` options, otherwise a compile-time error is emitted.\n+- It is a compile-time error to specify `pure` on an asm block with no outputs or only discarded outputs (`_`).\n+- It is a compile-time error to specify `noreturn` on an asm block with outputs.\n+\n+## Rules for inline assembly\n+\n+- Any registers not specified as inputs will contain an undefined value on entry to the asm block.\n+  - An \"undefined value\" in the context of inline assembly means that the register can (non-deterministically) have any one of the possible values allowed by the architecture. Notably it is not the same as an LLVM `undef` which can have a different value every time you read it (since such a concept does not exist in assembly code).\n+- Any registers not specified as outputs must have the same value upon exiting the asm block as they had on entry, otherwise behavior is undefined.\n+  - This only applies to registers which can be specified as an input or output. Other registers follow target-specific rules.\n+  - Note that a `lateout` may be allocated to the same register as an `in`, in which case this rule does not apply. Code should not rely on this however since it depends on the results of register allocation.\n+- Behavior is undefined if execution unwinds out of an asm block.\n+  - This also applies if the assembly code calls a function which then unwinds.\n+- The set of memory locations that assembly code is allowed the read and write are the same as those allowed for an FFI function.\n+  - Refer to the unsafe code guidelines for the exact rules.\n+  - If the `readonly` option is set, then only memory reads are allowed.\n+  - If the `nomem` option is set then no reads or writes to memory are allowed.\n+  - These rules do not apply to memory which is private to the asm code, such as stack space allocated within the asm block.\n+- The compiler cannot assume that the instructions in the asm are the ones that will actually end up executed.\n+  - This effectively means that the compiler must treat the `asm!` as a black box and only take the interface specification into account, not the instructions themselves.\n+  - Runtime code patching is allowed, via target-specific mechanisms (outside the scope of this RFC).\n+- Unless the `nostack` option is set, asm code is allowed to use stack space below the stack pointer.\n+  - On entry to the asm block the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+  - You are responsible for making sure you don't overflow the stack (e.g. use stack probing to ensure you hit a guard page).\n+  - You should adjust the stack pointer when allocating stack memory as required by the target ABI.\n+  - The stack pointer must be restored to its original value before leaving the asm block.\n+- If the `noreturn` option is set then behavior is undefined if execution falls through to the end of the asm block.\n+- If the `pure` option is set then behavior is undefined if the `asm` has side-effects other than its direct outputs. Behavior is also undefined if two executions of the `asm` code with the same inputs result in different outputs.\n+  - When used with the `nomem` option, \"inputs\" are just the direct inputs of the `asm!`.\n+  - When used with the `readonly` option, \"inputs\" comprise the direct inputs of the `asm!` and any memory that the `asm!` block is allowed to read.\n+- These flags registers must be restored upon exiting the asm block if the `preserves_flags` option is set:\n+  - x86\n+    - Status flags in `EFLAGS` (CF, PF, AF, ZF, SF, OF).\n+    - Floating-point status word (all).\n+    - Floating-point exception flags in `MXCSR` (PE, UE, OE, ZE, DE, IE).\n+  - ARM\n+    - Condition flags in `CPSR` (N, Z, C, V)\n+    - Saturation flag in `CPSR` (Q)\n+    - Greater than or equal flags in `CPSR` (GE).\n+    - Condition flags in `FPSCR` (N, Z, C, V)\n+    - Saturation flag in `FPSCR` (QC)\n+    - Floating-point exception flags in `FPSCR` (IDC, IXC, UFC, OFC, DZC, IOC).\n+  - AArch64\n+    - Condition flags (`NZCV` register).\n+    - Floating-point status (`FPSR` register).\n+  - RISC-V\n+    - Floating-point exception flags in `fcsr` (`fflags`).\n+- On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm block and must be clear on exit.\n+  - Behavior is undefined if the direction flag is set on exiting an asm block.\n+- The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting an `asm!` block.\n+  - This means that `asm!` blocks that never return (even if not marked `noreturn`) don't need to preserve these registers.\n+  - When returning to a different `asm!` block than you entered (e.g. for context switching), these registers must contain the value they had upon entering the `asm!` block that you are *exiting*.\n+    - You cannot exit an `asm!` block that has not been entered. Neither can you exit an `asm!` block that has already been exited.\n+    - You are responsible for switching any target-specific state (e.g. thread-local storage, stack bounds).\n+    - The set of memory locations that you may access is the intersection of those allowed by the `asm!` blocks you entered and exited.\n+- You cannot assume that an `asm!` block will appear exactly once in the output binary. The compiler is allowed to instantiate multiple copies of the `asm!` block, for example when the function containing it is inlined in multiple places.\n+  - As a consequence, you should only use [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+\n+> **Note**: As a general rule, the flags covered by `preserves_flags` are those which are *not* preserved when performing a function call.\n+\n+[local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels"}, {"sha": "625ceb0953b0a9404d940a3726f8f15568bde154", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1293,38 +1293,29 @@ pub(crate) mod builtin {\n     /// [unstable book]: ../unstable-book/library-features/asm.html\n     #[unstable(\n         feature = \"asm\",\n-        issue = \"70173\",\n+        issue = \"72016\",\n         reason = \"inline assembly is not stable enough for use and is subject to change\"\n     )]\n-    #[cfg_attr(\n-        not(bootstrap),\n-        rustc_deprecated(\n-            since = \"1.44.0\",\n-            reason = \"the syntax of asm! will change soon, use llvm_asm! to avoid breakage\",\n-            suggestion = \"llvm_asm\",\n-        )\n-    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! asm {\n-        (\"assembly template\"\n-                        : $(\"output\"(operand),)*\n-                        : $(\"input\"(operand),)*\n-                        : $(\"clobbers\",)*\n-                        : $(\"options\",)*) => {\n+        (\"assembly template\",\n+            $(operands,)*\n+            $(options($(option),*))?\n+        ) => {\n             /* compiler built-in */\n         };\n     }\n \n-    /// Inline assembly.\n+    /// LLVM-style inline assembly.\n     ///\n     /// Read the [unstable book] for the usage.\n     ///\n     /// [unstable book]: ../unstable-book/library-features/llvm-asm.html\n     #[unstable(\n         feature = \"llvm_asm\",\n         issue = \"70173\",\n-        reason = \"inline assembly is not stable enough for use and is subject to change\"\n+        reason = \"LLVM-style inline assembly will never be stabilized, prefer using asm! instead\"\n     )]\n     #[rustc_builtin_macro]\n     #[macro_export]"}, {"sha": "677c027f17b54c65480db41e57d50c5132730931", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 152, "deletions": 3, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -27,6 +27,15 @@ use std::string;\n \n use rustc_span::{InnerSpan, Symbol};\n \n+/// The type of format string that we are parsing.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum ParseMode {\n+    /// A normal format string as per `format_args!`.\n+    Format,\n+    /// An inline assembly template string for `asm!`.\n+    InlineAsm,\n+}\n+\n #[derive(Copy, Clone)]\n struct InnerOffset(usize);\n \n@@ -163,6 +172,7 @@ pub struct ParseError {\n /// This is a recursive-descent parser for the sake of simplicity, and if\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'a> {\n+    mode: ParseMode,\n     input: &'a str,\n     cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n@@ -179,6 +189,8 @@ pub struct Parser<'a> {\n     last_opening_brace: Option<InnerSpan>,\n     /// Whether the source string is comes from `println!` as opposed to `format!` or `print!`\n     append_newline: bool,\n+    /// Whether this formatting string is a literal or it comes from a macro.\n+    is_literal: bool,\n }\n \n impl<'a> Iterator for Parser<'a> {\n@@ -201,7 +213,9 @@ impl<'a> Iterator for Parser<'a> {\n                         if let Some(end) = self.must_consume('}') {\n                             let start = self.to_span_index(pos);\n                             let end = self.to_span_index(end + 1);\n-                            self.arg_places.push(start.to(end));\n+                            if self.is_literal {\n+                                self.arg_places.push(start.to(end));\n+                            }\n                         }\n                         Some(NextArgument(arg))\n                     }\n@@ -235,10 +249,13 @@ impl<'a> Parser<'a> {\n     pub fn new(\n         s: &'a str,\n         style: Option<usize>,\n-        skips: Vec<usize>,\n+        snippet: Option<string::String>,\n         append_newline: bool,\n+        mode: ParseMode,\n     ) -> Parser<'a> {\n+        let (skips, is_literal) = find_skips_from_snippet(snippet, style);\n         Parser {\n+            mode,\n             input: s,\n             cur: s.char_indices().peekable(),\n             errors: vec![],\n@@ -248,6 +265,7 @@ impl<'a> Parser<'a> {\n             skips,\n             last_opening_brace: None,\n             append_newline,\n+            is_literal,\n         }\n     }\n \n@@ -426,7 +444,10 @@ impl<'a> Parser<'a> {\n     /// Parses an `Argument` structure, or what's contained within braces inside the format string.\n     fn argument(&mut self) -> Argument<'a> {\n         let pos = self.position();\n-        let format = self.format();\n+        let format = match self.mode {\n+            ParseMode::Format => self.format(),\n+            ParseMode::InlineAsm => self.inline_asm(),\n+        };\n \n         // Resolve position after parsing format spec.\n         let pos = match pos {\n@@ -574,6 +595,36 @@ impl<'a> Parser<'a> {\n         spec\n     }\n \n+    /// Parses an inline assembly template modifier at the current position, returning the modifier\n+    /// in the `ty` field of the `FormatSpec` struct.\n+    fn inline_asm(&mut self) -> FormatSpec<'a> {\n+        let mut spec = FormatSpec {\n+            fill: None,\n+            align: AlignUnknown,\n+            flags: 0,\n+            precision: CountImplied,\n+            precision_span: None,\n+            width: CountImplied,\n+            width_span: None,\n+            ty: &self.input[..0],\n+            ty_span: None,\n+        };\n+        if !self.consume(':') {\n+            return spec;\n+        }\n+\n+        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n+        spec.ty = self.word();\n+        let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n+        if !spec.ty.is_empty() {\n+            spec.ty_span = ty_span_start\n+                .and_then(|s| ty_span_end.map(|e| (s, e)))\n+                .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+        }\n+\n+        spec\n+    }\n+\n     /// Parses a `Count` parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n@@ -652,5 +703,103 @@ impl<'a> Parser<'a> {\n     }\n }\n \n+/// Finds the indices of all characters that have been processed and differ between the actual\n+/// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n+/// in order to properly synthethise the intra-string `Span`s for error diagnostics.\n+fn find_skips_from_snippet(\n+    snippet: Option<string::String>,\n+    str_style: Option<usize>,\n+) -> (Vec<usize>, bool) {\n+    let snippet = match snippet {\n+        Some(ref s) if s.starts_with('\"') || s.starts_with(\"r#\") => s,\n+        _ => return (vec![], false),\n+    };\n+\n+    fn find_skips(snippet: &str, is_raw: bool) -> Vec<usize> {\n+        let mut eat_ws = false;\n+        let mut s = snippet.chars().enumerate().peekable();\n+        let mut skips = vec![];\n+        while let Some((pos, c)) = s.next() {\n+            match (c, s.peek()) {\n+                // skip whitespace and empty lines ending in '\\\\'\n+                ('\\\\', Some((next_pos, '\\n'))) if !is_raw => {\n+                    eat_ws = true;\n+                    skips.push(pos);\n+                    skips.push(*next_pos);\n+                    let _ = s.next();\n+                }\n+                ('\\\\', Some((next_pos, '\\n' | 'n' | 't'))) if eat_ws => {\n+                    skips.push(pos);\n+                    skips.push(*next_pos);\n+                    let _ = s.next();\n+                }\n+                (' ' | '\\n' | '\\t', _) if eat_ws => {\n+                    skips.push(pos);\n+                }\n+                ('\\\\', Some((next_pos, 'n' | 't' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n+                    skips.push(*next_pos);\n+                    let _ = s.next();\n+                }\n+                ('\\\\', Some((_, 'x'))) if !is_raw => {\n+                    for _ in 0..3 {\n+                        // consume `\\xAB` literal\n+                        if let Some((pos, _)) = s.next() {\n+                            skips.push(pos);\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                }\n+                ('\\\\', Some((_, 'u'))) if !is_raw => {\n+                    if let Some((pos, _)) = s.next() {\n+                        skips.push(pos);\n+                    }\n+                    if let Some((next_pos, next_c)) = s.next() {\n+                        if next_c == '{' {\n+                            skips.push(next_pos);\n+                            let mut i = 0; // consume up to 6 hexanumeric chars + closing `}`\n+                            while let (Some((next_pos, c)), true) = (s.next(), i < 7) {\n+                                if c.is_digit(16) {\n+                                    skips.push(next_pos);\n+                                } else if c == '}' {\n+                                    skips.push(next_pos);\n+                                    break;\n+                                } else {\n+                                    break;\n+                                }\n+                                i += 1;\n+                            }\n+                        } else if next_c.is_digit(16) {\n+                            skips.push(next_pos);\n+                            // We suggest adding `{` and `}` when appropriate, accept it here as if\n+                            // it were correct\n+                            let mut i = 0; // consume up to 6 hexanumeric chars\n+                            while let (Some((next_pos, c)), _) = (s.next(), i < 6) {\n+                                if c.is_digit(16) {\n+                                    skips.push(next_pos);\n+                                } else {\n+                                    break;\n+                                }\n+                                i += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+                _ if eat_ws => {\n+                    // `take_while(|c| c.is_whitespace())`\n+                    eat_ws = false;\n+                }\n+                _ => {}\n+            }\n+        }\n+        skips\n+    }\n+\n+    let r_start = str_style.map(|r| r + 1).unwrap_or(0);\n+    let r_end = str_style.map(|r| r).unwrap_or(0);\n+    let s = &snippet[r_start + 1..snippet.len() - r_end - 1];\n+    (find_skips(s, str_style.is_some()), true)\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "9932c1df7a935c4ef8fe89879878d819853d117c", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n \n fn same(fmt: &'static str, p: &[Piece<'static>]) {\n-    let parser = Parser::new(fmt, None, vec![], false);\n+    let parser = Parser::new(fmt, None, None, false, ParseMode::Format);\n     assert_eq!(parser.collect::<Vec<Piece<'static>>>(), p);\n }\n \n@@ -20,7 +20,7 @@ fn fmtdflt() -> FormatSpec<'static> {\n }\n \n fn musterr(s: &str) {\n-    let mut p = Parser::new(s, None, vec![], false);\n+    let mut p = Parser::new(s, None, None, false, ParseMode::Format);\n     p.next();\n     assert!(!p.errors.is_empty());\n }"}, {"sha": "7d105f9e8863da12eabee8368e291b8404836ba5", "filename": "src/librustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2FCargo.toml?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -19,3 +19,4 @@ rustc_index = { path = \"../librustc_index\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_macros = { path = \"../librustc_macros\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+bitflags = \"1.2.1\""}, {"sha": "7ff835725073dabc71057337e3447557ed8e3752", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1121,7 +1121,7 @@ impl Expr {\n             ExprKind::Break(..) => ExprPrecedence::Break,\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n-            ExprKind::LlvmInlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::InlineAsm(..) | ExprKind::LlvmInlineAsm(..) => ExprPrecedence::InlineAsm,\n             ExprKind::MacCall(..) => ExprPrecedence::Mac,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n@@ -1250,6 +1250,8 @@ pub enum ExprKind {\n     /// A `return`, with an optional value to be returned.\n     Ret(Option<P<Expr>>),\n \n+    /// Output of the `asm!()` macro.\n+    InlineAsm(InlineAsm),\n     /// Output of the `llvm_asm!()` macro.\n     LlvmInlineAsm(P<LlvmInlineAsm>),\n \n@@ -1864,6 +1866,112 @@ pub enum TraitObjectSyntax {\n     None,\n }\n \n+/// Inline assembly operand explicit register or register class.\n+///\n+/// E.g., `\"eax\"` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum InlineAsmRegOrRegClass {\n+    Reg(Symbol),\n+    RegClass(Symbol),\n+}\n+\n+bitflags::bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+    pub struct InlineAsmOptions: u8 {\n+        const PURE = 1 << 0;\n+        const NOMEM = 1 << 1;\n+        const READONLY = 1 << 2;\n+        const PRESERVES_FLAGS = 1 << 3;\n+        const NORETURN = 1 << 4;\n+        const NOSTACK = 1 << 5;\n+        const ATT_SYNTAX = 1 << 6;\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub enum InlineAsmTemplatePiece {\n+    String(String),\n+    Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n+}\n+\n+impl fmt::Display for InlineAsmTemplatePiece {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::String(s) => {\n+                for c in s.chars() {\n+                    match c {\n+                        '{' => f.write_str(\"{{\")?,\n+                        '}' => f.write_str(\"}}\")?,\n+                        _ => write!(f, \"{}\", c.escape_debug())?,\n+                    }\n+                }\n+                Ok(())\n+            }\n+            Self::Placeholder { operand_idx, modifier: Some(modifier), .. } => {\n+                write!(f, \"{{{}:{}}}\", operand_idx, modifier)\n+            }\n+            Self::Placeholder { operand_idx, modifier: None, .. } => {\n+                write!(f, \"{{{}}}\", operand_idx)\n+            }\n+        }\n+    }\n+}\n+\n+impl InlineAsmTemplatePiece {\n+    /// Rebuilds the asm template string from its pieces.\n+    pub fn to_string(s: &[Self]) -> String {\n+        use fmt::Write;\n+        let mut out = String::new();\n+        for p in s.iter() {\n+            let _ = write!(out, \"{}\", p);\n+        }\n+        out\n+    }\n+}\n+\n+/// Inline assembly operand.\n+///\n+/// E.g., `out(\"eax\") result` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum InlineAsmOperand {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        expr: P<Expr>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: Option<P<Expr>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: P<Expr>,\n+    },\n+    SplitInOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_expr: P<Expr>,\n+        out_expr: Option<P<Expr>>,\n+    },\n+    Const {\n+        expr: P<Expr>,\n+    },\n+    Sym {\n+        expr: P<Expr>,\n+    },\n+}\n+\n+/// Inline assembly.\n+///\n+/// E.g., `asm!(\"NOP\");`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct InlineAsm {\n+    pub template: Vec<InlineAsmTemplatePiece>,\n+    pub operands: Vec<(InlineAsmOperand, Span)>,\n+    pub options: InlineAsmOptions,\n+}\n+\n /// Inline assembly dialect.\n ///\n /// E.g., `\"intel\"` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`."}, {"sha": "2c575c3e288617703c75a8c8232082190eb0a544", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1205,6 +1205,27 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr,\n         ExprKind::Ret(expr) => {\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n+        ExprKind::InlineAsm(asm) => {\n+            for (op, _) in &mut asm.operands {\n+                match op {\n+                    InlineAsmOperand::In { expr, .. }\n+                    | InlineAsmOperand::InOut { expr, .. }\n+                    | InlineAsmOperand::Const { expr, .. }\n+                    | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n+                    InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            vis.visit_expr(expr);\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        vis.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            vis.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         ExprKind::LlvmInlineAsm(asm) => {\n             let LlvmInlineAsm {\n                 asm: _,"}, {"sha": "41c02734442a42fbd5097b54069bd05b23cc331f", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -818,6 +818,27 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::MacCall(ref mac) => visitor.visit_mac(mac),\n         ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::InlineAsm(ref ia) => {\n+            for (op, _) in &ia.operands {\n+                match op {\n+                    InlineAsmOperand::In { expr, .. }\n+                    | InlineAsmOperand::InOut { expr, .. }\n+                    | InlineAsmOperand::Const { expr, .. }\n+                    | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+                    InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            visitor.visit_expr(expr);\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        visitor.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            visitor.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         ExprKind::LlvmInlineAsm(ref ia) => {\n             for &(_, ref input) in &ia.inputs {\n                 visitor.visit_expr(input)"}, {"sha": "856387421d90cc96bde877f01edfbf63f3271ba7", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 303, "deletions": 2, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -3,13 +3,17 @@ use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericAr\n use rustc_ast::ast::*;\n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_target::asm;\n+use std::collections::hash_map::Entry;\n+use std::fmt::Write;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -175,7 +179,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_asm(asm),\n+                ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n+                ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                     let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Struct(\n@@ -968,7 +973,303 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         result\n     }\n \n-    fn lower_expr_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n+    fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n+        let asm_arch = if let Some(asm_arch) = self.sess.asm_arch {\n+            asm_arch\n+        } else {\n+            struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n+            return hir::ExprKind::Err;\n+        };\n+        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            match asm_arch {\n+                asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64 => {}\n+                _ => self\n+                    .sess\n+                    .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n+                    .emit(),\n+            }\n+        }\n+\n+        // Lower operands to HIR, filter_map skips any operands with invalid\n+        // register classes.\n+        let sess = self.sess;\n+        let operands: Vec<_> = asm\n+            .operands\n+            .iter()\n+            .filter_map(|(op, op_sp)| {\n+                let lower_reg = |reg| {\n+                    Some(match reg {\n+                        InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n+                            asm::InlineAsmReg::parse(\n+                                asm_arch,\n+                                |feature| {\n+                                    self.sess.target_features.contains(&Symbol::intern(feature))\n+                                },\n+                                s,\n+                            )\n+                            .map_err(|e| {\n+                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                            })\n+                            .ok()?,\n+                        ),\n+                        InlineAsmRegOrRegClass::RegClass(s) => {\n+                            asm::InlineAsmRegOrRegClass::RegClass(\n+                                asm::InlineAsmRegClass::parse(asm_arch, s)\n+                                    .map_err(|e| {\n+                                        let msg = format!(\n+                                            \"invalid register class `{}`: {}\",\n+                                            s.as_str(),\n+                                            e\n+                                        );\n+                                        sess.struct_span_err(*op_sp, &msg).emit();\n+                                    })\n+                                    .ok()?,\n+                            )\n+                        }\n+                    })\n+                };\n+                let op = match op {\n+                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n+                        reg: lower_reg(*reg)?,\n+                        expr: self.lower_expr_mut(expr),\n+                    },\n+                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n+                        reg: lower_reg(*reg)?,\n+                        late: *late,\n+                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                    },\n+                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n+                        reg: lower_reg(*reg)?,\n+                        late: *late,\n+                        expr: self.lower_expr_mut(expr),\n+                    },\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            reg: lower_reg(*reg)?,\n+                            late: *late,\n+                            in_expr: self.lower_expr_mut(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        }\n+                    }\n+                    InlineAsmOperand::Const { expr } => {\n+                        hir::InlineAsmOperand::Const { expr: self.lower_expr_mut(expr) }\n+                    }\n+                    InlineAsmOperand::Sym { expr } => {\n+                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n+                    }\n+                };\n+                Some(op)\n+            })\n+            .collect();\n+\n+        // Stop if there were any errors when lowering the register classes\n+        if operands.len() != asm.operands.len() {\n+            return hir::ExprKind::Err;\n+        }\n+\n+        // Validate template modifiers against the register classes for the operands\n+        for p in &asm.template {\n+            if let InlineAsmTemplatePiece::Placeholder {\n+                operand_idx,\n+                modifier: Some(modifier),\n+                span: placeholder_span,\n+            } = *p\n+            {\n+                let op_sp = asm.operands[operand_idx].1;\n+                match &operands[operand_idx] {\n+                    hir::InlineAsmOperand::In { reg, .. }\n+                    | hir::InlineAsmOperand::Out { reg, .. }\n+                    | hir::InlineAsmOperand::InOut { reg, .. }\n+                    | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n+                        let class = reg.reg_class();\n+                        let valid_modifiers = class.valid_modifiers(asm_arch);\n+                        if !valid_modifiers.contains(&modifier) {\n+                            let mut err = sess.struct_span_err(\n+                                placeholder_span,\n+                                \"invalid asm template modifier for this register class\",\n+                            );\n+                            err.span_label(placeholder_span, \"template modifier\");\n+                            err.span_label(op_sp, \"argument\");\n+                            if !valid_modifiers.is_empty() {\n+                                let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n+                                for m in &valid_modifiers[1..] {\n+                                    let _ = write!(mods, \", `{}`\", m);\n+                                }\n+                                err.note(&format!(\n+                                    \"the `{}` register class supports \\\n+                                     the following template modifiers: {}\",\n+                                    class.name(),\n+                                    mods\n+                                ));\n+                            } else {\n+                                err.note(&format!(\n+                                    \"the `{}` register class does not support template modifiers\",\n+                                    class.name()\n+                                ));\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::Const { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `const` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                    hir::InlineAsmOperand::Sym { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `sym` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut used_input_regs = FxHashMap::default();\n+        let mut used_output_regs = FxHashMap::default();\n+        for (idx, op) in operands.iter().enumerate() {\n+            let op_sp = asm.operands[idx].1;\n+            if let Some(reg) = op.reg() {\n+                // Validate register classes against currently enabled target\n+                // features. We check that at least one type is available for\n+                // the current target.\n+                let reg_class = reg.reg_class();\n+                let mut required_features = vec![];\n+                for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                    if let Some(feature) = feature {\n+                        if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                            required_features.clear();\n+                            break;\n+                        } else {\n+                            required_features.push(feature);\n+                        }\n+                    } else {\n+                        required_features.clear();\n+                        break;\n+                    }\n+                }\n+                required_features.sort();\n+                required_features.dedup();\n+                match &required_features[..] {\n+                    [] => {}\n+                    [feature] => {\n+                        let msg = format!(\n+                            \"register class `{}` requires the `{}` target feature\",\n+                            reg_class.name(),\n+                            feature\n+                        );\n+                        sess.struct_span_err(op_sp, &msg).emit();\n+                    }\n+                    features => {\n+                        let msg = format!(\n+                            \"register class `{}` requires at least one target feature: {}\",\n+                            reg_class.name(),\n+                            features.join(\", \")\n+                        );\n+                        sess.struct_span_err(op_sp, &msg).emit();\n+                    }\n+                }\n+\n+                // Check for conflicts between explicit register operands.\n+                if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    let (input, output) = match op {\n+                        hir::InlineAsmOperand::In { .. } => (true, false),\n+                        // Late output do not conflict with inputs, but normal outputs do\n+                        hir::InlineAsmOperand::Out { late, .. } => (!late, true),\n+                        hir::InlineAsmOperand::InOut { .. }\n+                        | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n+                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n+                            unreachable!()\n+                        }\n+                    };\n+\n+                    // Flag to output the error only once per operand\n+                    let mut skip = false;\n+                    reg.overlapping_regs(|r| {\n+                        let mut check = |used_regs: &mut FxHashMap<asm::InlineAsmReg, usize>,\n+                                         input| {\n+                            match used_regs.entry(r) {\n+                                Entry::Occupied(o) => {\n+                                    if !skip {\n+                                        skip = true;\n+\n+                                        let idx2 = *o.get();\n+                                        let op2 = &operands[idx2];\n+                                        let op_sp2 = asm.operands[idx2].1;\n+                                        let reg2 = match op2.reg() {\n+                                            Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n+                                            _ => unreachable!(),\n+                                        };\n+\n+                                        let msg = format!(\n+                                            \"register `{}` conflicts with register `{}`\",\n+                                            reg.name(),\n+                                            reg2.name()\n+                                        );\n+                                        let mut err = sess.struct_span_err(op_sp, &msg);\n+                                        err.span_label(\n+                                            op_sp,\n+                                            &format!(\"register `{}`\", reg.name()),\n+                                        );\n+                                        err.span_label(\n+                                            op_sp2,\n+                                            &format!(\"register `{}`\", reg2.name()),\n+                                        );\n+\n+                                        match (op, op2) {\n+                                            (\n+                                                hir::InlineAsmOperand::In { .. },\n+                                                hir::InlineAsmOperand::Out { late, .. },\n+                                            )\n+                                            | (\n+                                                hir::InlineAsmOperand::Out { late, .. },\n+                                                hir::InlineAsmOperand::In { .. },\n+                                            ) => {\n+                                                assert!(!*late);\n+                                                let out_op_sp = if input { op_sp2 } else { op_sp };\n+                                                let msg = &format!(\n+                                                    \"use `lateout` instead of \\\n+                                                     `out` to avoid conflict\"\n+                                                );\n+                                                err.span_help(out_op_sp, msg);\n+                                            }\n+                                            _ => {}\n+                                        }\n+\n+                                        err.emit();\n+                                    }\n+                                }\n+                                Entry::Vacant(v) => {\n+                                    v.insert(idx);\n+                                }\n+                            }\n+                        };\n+                        if input {\n+                            check(&mut used_input_regs, true);\n+                        }\n+                        if output {\n+                            check(&mut used_output_regs, false);\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+\n+        let operands = self.arena.alloc_from_iter(operands);\n+        let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n+        let hir_asm = hir::InlineAsm { template, operands, options: asm.options };\n+        hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n+    }\n+\n+    fn lower_expr_llvm_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::LlvmInlineAsmInner {\n             inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),\n             outputs: asm"}, {"sha": "6c076d2c5b866467ec2ed89cb3898cc79d7c889f", "filename": "src/librustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2FCargo.toml?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -13,3 +13,4 @@ doctest = false\n log = \"0.4\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }\n+rustc_target = { path = \"../librustc_target\" }"}, {"sha": "872126646f33d1507487458d29ce59881eb2ad0d", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -4,6 +4,8 @@ use crate::pp::{self, Breaks};\n use rustc_ast::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use rustc_ast::ast::{Attribute, GenericArg, MacArgs};\n use rustc_ast::ast::{GenericBound, SelfKind, TraitBoundModifier};\n+use rustc_ast::ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, BinOpToken, DelimToken, Nonterminal, Token, TokenKind};\n@@ -2014,6 +2016,119 @@ impl<'a> State<'a> {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n+            ast::ExprKind::InlineAsm(ref a) => {\n+                enum AsmArg<'a> {\n+                    Template(String),\n+                    Operand(&'a InlineAsmOperand),\n+                    Options(InlineAsmOptions),\n+                }\n+\n+                let mut args = vec![];\n+                args.push(AsmArg::Template(InlineAsmTemplatePiece::to_string(&a.template)));\n+                args.extend(a.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n+                if !a.options.is_empty() {\n+                    args.push(AsmArg::Options(a.options));\n+                }\n+\n+                self.word(\"asm!\");\n+                self.popen();\n+                self.commasep(Consistent, &args, |s, arg| match arg {\n+                    AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+                    AsmArg::Operand(op) => {\n+                        let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r\n+                        {\n+                            InlineAsmRegOrRegClass::Reg(r) => {\n+                                s.print_string(&r.as_str(), ast::StrStyle::Cooked)\n+                            }\n+                            InlineAsmRegOrRegClass::RegClass(r) => s.word(r.to_string()),\n+                        };\n+                        match op {\n+                            InlineAsmOperand::In { reg, expr } => {\n+                                s.word(\"in\");\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                            InlineAsmOperand::Out { reg, late, expr } => {\n+                                s.word(if *late { \"lateout\" } else { \"out\" });\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                match expr {\n+                                    Some(expr) => s.print_expr(expr),\n+                                    None => s.word(\"_\"),\n+                                }\n+                            }\n+                            InlineAsmOperand::InOut { reg, late, expr } => {\n+                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                            InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                s.print_expr(in_expr);\n+                                s.space();\n+                                s.word_space(\"=>\");\n+                                match out_expr {\n+                                    Some(out_expr) => s.print_expr(out_expr),\n+                                    None => s.word(\"_\"),\n+                                }\n+                            }\n+                            InlineAsmOperand::Const { expr } => {\n+                                s.word(\"const\");\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                            InlineAsmOperand::Sym { expr } => {\n+                                s.word(\"sym\");\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                        }\n+                    }\n+                    AsmArg::Options(opts) => {\n+                        s.word(\"options\");\n+                        s.popen();\n+                        let mut options = vec![];\n+                        if opts.contains(InlineAsmOptions::PURE) {\n+                            options.push(\"pure\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::NOMEM) {\n+                            options.push(\"nomem\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::READONLY) {\n+                            options.push(\"readonly\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+                            options.push(\"preserves_flags\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::NORETURN) {\n+                            options.push(\"noreturn\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::NOSTACK) {\n+                            options.push(\"nostack\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                            options.push(\"att_syntax\");\n+                        }\n+                        s.commasep(Inconsistent, &options, |s, &opt| {\n+                            s.word(opt);\n+                        });\n+                        s.pclose();\n+                    }\n+                });\n+                self.pclose();\n+            }\n             ast::ExprKind::LlvmInlineAsm(ref a) => {\n                 self.s.word(\"llvm_asm!\");\n                 self.popen();"}, {"sha": "c29739248976cc89d0e64b95f679fcf5e87ba4e6", "filename": "src/librustc_builtin_macros/asm.rs", "status": "added", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,537 @@\n+use fmt_macros as parse;\n+\n+use rustc_ast::ast;\n+use rustc_ast::ptr::P;\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_expand::base::{self, *};\n+use rustc_parse::parser::Parser;\n+use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::{InnerSpan, Span};\n+\n+struct AsmArgs {\n+    template: P<ast::Expr>,\n+    operands: Vec<(ast::InlineAsmOperand, Span)>,\n+    named_args: FxHashMap<Symbol, usize>,\n+    reg_args: FxHashSet<usize>,\n+    options: ast::InlineAsmOptions,\n+    options_span: Option<Span>,\n+}\n+\n+fn parse_args<'a>(\n+    ecx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n+    let mut p = ecx.new_parser_from_tts(tts);\n+\n+    if p.token == token::Eof {\n+        return Err(ecx.struct_span_err(sp, \"requires at least a template string argument\"));\n+    }\n+\n+    // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n+    if p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n+        let mut err = ecx.struct_span_err(sp, \"legacy asm! syntax is no longer supported\");\n+\n+        // Find the span of the \"asm!\" so that we can offer an automatic suggestion\n+        let asm_span = sp.from_inner(InnerSpan::new(0, 4));\n+        if let Ok(s) = ecx.source_map().span_to_snippet(asm_span) {\n+            if s == \"asm!\" {\n+                err.span_suggestion(\n+                    asm_span,\n+                    \"replace with\",\n+                    \"llvm_asm!\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        return Err(err);\n+    }\n+\n+    let template = p.parse_expr()?;\n+    let mut args = AsmArgs {\n+        template,\n+        operands: vec![],\n+        named_args: FxHashMap::default(),\n+        reg_args: FxHashSet::default(),\n+        options: ast::InlineAsmOptions::empty(),\n+        options_span: None,\n+    };\n+\n+    let mut first = true;\n+    while p.token != token::Eof {\n+        if !p.eat(&token::Comma) {\n+            if first {\n+                // After `asm!(\"\"` we always expect *only* a comma...\n+                let mut err = ecx.struct_span_err(p.token.span, \"expected token: `,`\");\n+                err.span_label(p.token.span, \"expected `,`\");\n+                p.maybe_annotate_with_ascription(&mut err, false);\n+                return Err(err);\n+            } else {\n+                // ...after that delegate to `expect` to also include the other expected tokens.\n+                return Err(p.expect(&token::Comma).err().unwrap());\n+            }\n+        }\n+        first = false;\n+        if p.token == token::Eof {\n+            break;\n+        } // accept trailing commas\n+\n+        // Parse options\n+        if p.eat(&token::Ident(sym::options, false)) {\n+            parse_options(&mut p, &mut args)?;\n+            continue;\n+        }\n+\n+        let span_start = p.token.span;\n+\n+        // Parse operand names\n+        let name = if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n+            let (ident, _) = p.token.ident().unwrap();\n+            p.bump();\n+            p.expect(&token::Eq)?;\n+            Some(ident.name)\n+        } else {\n+            None\n+        };\n+\n+        let mut explicit_reg = false;\n+        let op = if p.eat(&token::Ident(kw::In, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            ast::InlineAsmOperand::In { reg, expr }\n+        } else if p.eat(&token::Ident(sym::out, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+            ast::InlineAsmOperand::Out { reg, expr, late: false }\n+        } else if p.eat(&token::Ident(sym::lateout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+            ast::InlineAsmOperand::Out { reg, expr, late: true }\n+        } else if p.eat(&token::Ident(sym::inout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            if p.eat(&token::FatArrow) {\n+                let out_expr =\n+                    if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+                ast::InlineAsmOperand::SplitInOut { reg, in_expr: expr, out_expr, late: false }\n+            } else {\n+                ast::InlineAsmOperand::InOut { reg, expr, late: false }\n+            }\n+        } else if p.eat(&token::Ident(sym::inlateout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            if p.eat(&token::FatArrow) {\n+                let out_expr =\n+                    if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+                ast::InlineAsmOperand::SplitInOut { reg, in_expr: expr, out_expr, late: true }\n+            } else {\n+                ast::InlineAsmOperand::InOut { reg, expr, late: true }\n+            }\n+        } else if p.eat(&token::Ident(kw::Const, false)) {\n+            let expr = p.parse_expr()?;\n+            ast::InlineAsmOperand::Const { expr }\n+        } else {\n+            p.expect(&token::Ident(sym::sym, false))?;\n+            let expr = p.parse_expr()?;\n+            match expr.kind {\n+                ast::ExprKind::Path(..) => {}\n+                _ => {\n+                    let err = ecx\n+                        .struct_span_err(expr.span, \"argument to `sym` must be a path expression\");\n+                    return Err(err);\n+                }\n+            }\n+            ast::InlineAsmOperand::Sym { expr }\n+        };\n+\n+        let span = span_start.to(p.prev_token.span);\n+        let slot = args.operands.len();\n+        args.operands.push((op, span));\n+\n+        // Validate the order of named, positional & explicit register operands and options. We do\n+        // this at the end once we have the full span of the argument available.\n+        if let Some(options_span) = args.options_span {\n+            ecx.struct_span_err(span, \"arguments are not allowed after options\")\n+                .span_label(options_span, \"previous options\")\n+                .span_label(span, \"argument\")\n+                .emit();\n+        }\n+        if explicit_reg {\n+            if name.is_some() {\n+                ecx.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n+            }\n+            args.reg_args.insert(slot);\n+        } else if let Some(name) = name {\n+            if let Some(&prev) = args.named_args.get(&name) {\n+                ecx.struct_span_err(span, &format!(\"duplicate argument named `{}`\", name))\n+                    .span_label(args.operands[prev].1, \"previously here\")\n+                    .span_label(span, \"duplicate argument\")\n+                    .emit();\n+                continue;\n+            }\n+            if !args.reg_args.is_empty() {\n+                let mut err = ecx.struct_span_err(\n+                    span,\n+                    \"named arguments cannot follow explicit register arguments\",\n+                );\n+                err.span_label(span, \"named argument\");\n+                for pos in &args.reg_args {\n+                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n+                }\n+                err.emit();\n+            }\n+            args.named_args.insert(name, slot);\n+        } else {\n+            if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n+                let mut err = ecx.struct_span_err(\n+                    span,\n+                    \"positional arguments cannot follow named arguments \\\n+                     or explicit register arguments\",\n+                );\n+                err.span_label(span, \"positional argument\");\n+                for pos in args.named_args.values() {\n+                    err.span_label(args.operands[*pos].1, \"named argument\");\n+                }\n+                for pos in &args.reg_args {\n+                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    if args.options.contains(ast::InlineAsmOptions::NOMEM)\n+        && args.options.contains(ast::InlineAsmOptions::READONLY)\n+    {\n+        let span = args.options_span.unwrap();\n+        ecx.struct_span_err(span, \"the `nomem` and `readonly` options are mutually exclusive\")\n+            .emit();\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::PURE)\n+        && args.options.contains(ast::InlineAsmOptions::NORETURN)\n+    {\n+        let span = args.options_span.unwrap();\n+        ecx.struct_span_err(span, \"the `pure` and `noreturn` options are mutually exclusive\")\n+            .emit();\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::PURE)\n+        && !args.options.intersects(ast::InlineAsmOptions::NOMEM | ast::InlineAsmOptions::READONLY)\n+    {\n+        let span = args.options_span.unwrap();\n+        ecx.struct_span_err(\n+            span,\n+            \"the `pure` option must be combined with either `nomem` or `readonly`\",\n+        )\n+        .emit();\n+    }\n+\n+    let mut have_real_output = false;\n+    let mut outputs_sp = vec![];\n+    for (op, op_sp) in &args.operands {\n+        match op {\n+            ast::InlineAsmOperand::Out { expr, .. }\n+            | ast::InlineAsmOperand::SplitInOut { out_expr: expr, .. } => {\n+                outputs_sp.push(*op_sp);\n+                have_real_output |= expr.is_some();\n+            }\n+            ast::InlineAsmOperand::InOut { .. } => {\n+                outputs_sp.push(*op_sp);\n+                have_real_output = true;\n+            }\n+            _ => {}\n+        }\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::PURE) && !have_real_output {\n+        ecx.struct_span_err(\n+            args.options_span.unwrap(),\n+            \"asm with `pure` option must have at least one output\",\n+        )\n+        .emit();\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n+        let err = ecx\n+            .struct_span_err(outputs_sp, \"asm outputs are not allowed with the `noreturn` option\");\n+\n+        // Bail out now since this is likely to confuse MIR\n+        return Err(err);\n+    }\n+\n+    Ok(args)\n+}\n+\n+fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), DiagnosticBuilder<'a>> {\n+    let span_start = p.prev_token.span;\n+\n+    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+\n+    while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+        if p.eat(&token::Ident(sym::pure, false)) {\n+            args.options |= ast::InlineAsmOptions::PURE;\n+        } else if p.eat(&token::Ident(sym::nomem, false)) {\n+            args.options |= ast::InlineAsmOptions::NOMEM;\n+        } else if p.eat(&token::Ident(sym::readonly, false)) {\n+            args.options |= ast::InlineAsmOptions::READONLY;\n+        } else if p.eat(&token::Ident(sym::preserves_flags, false)) {\n+            args.options |= ast::InlineAsmOptions::PRESERVES_FLAGS;\n+        } else if p.eat(&token::Ident(sym::noreturn, false)) {\n+            args.options |= ast::InlineAsmOptions::NORETURN;\n+        } else if p.eat(&token::Ident(sym::nostack, false)) {\n+            args.options |= ast::InlineAsmOptions::NOSTACK;\n+        } else {\n+            p.expect(&token::Ident(sym::att_syntax, false))?;\n+            args.options |= ast::InlineAsmOptions::ATT_SYNTAX;\n+        }\n+\n+        // Allow trailing commas\n+        if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+            break;\n+        }\n+        p.expect(&token::Comma)?;\n+    }\n+\n+    let new_span = span_start.to(p.prev_token.span);\n+    if let Some(options_span) = args.options_span {\n+        p.struct_span_err(new_span, \"asm options cannot be specified multiple times\")\n+            .span_label(options_span, \"previously here\")\n+            .span_label(new_span, \"duplicate options\")\n+            .emit();\n+    } else {\n+        args.options_span = Some(new_span);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn parse_reg<'a>(\n+    p: &mut Parser<'a>,\n+    explicit_reg: &mut bool,\n+) -> Result<ast::InlineAsmRegOrRegClass, DiagnosticBuilder<'a>> {\n+    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+    let result = match p.token.kind {\n+        token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),\n+        token::Literal(token::Lit { kind: token::LitKind::Str, symbol, suffix: _ }) => {\n+            *explicit_reg = true;\n+            ast::InlineAsmRegOrRegClass::Reg(symbol)\n+        }\n+        _ => {\n+            return Err(\n+                p.struct_span_err(p.token.span, \"expected register class or explicit register\")\n+            );\n+        }\n+    };\n+    p.bump();\n+    p.expect(&token::CloseDelim(token::DelimToken::Paren))?;\n+    Ok(result)\n+}\n+\n+fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n+    let msg = \"asm template must be a string literal\";\n+    let template_sp = args.template.span;\n+    let (template_str, template_style, template_span) =\n+        match expr_to_spanned_string(ecx, args.template, msg) {\n+            Ok(template) => template,\n+            Err(err) => {\n+                if let Some(mut err) = err {\n+                    err.emit();\n+                }\n+                return DummyResult::raw_expr(sp, true);\n+            }\n+        };\n+\n+    let str_style = match template_style {\n+        ast::StrStyle::Cooked => None,\n+        ast::StrStyle::Raw(raw) => Some(raw as usize),\n+    };\n+\n+    let template_str = &template_str.as_str();\n+    let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+    let mut parser = parse::Parser::new(\n+        template_str,\n+        str_style,\n+        template_snippet,\n+        false,\n+        parse::ParseMode::InlineAsm,\n+    );\n+\n+    let mut unverified_pieces = Vec::new();\n+    while let Some(piece) = parser.next() {\n+        if !parser.errors.is_empty() {\n+            break;\n+        } else {\n+            unverified_pieces.push(piece);\n+        }\n+    }\n+\n+    if !parser.errors.is_empty() {\n+        let err = parser.errors.remove(0);\n+        let err_sp = template_span.from_inner(err.span);\n+        let mut e = ecx\n+            .struct_span_err(err_sp, &format!(\"invalid asm template string: {}\", err.description));\n+        e.span_label(err_sp, err.label + \" in asm template string\");\n+        if let Some(note) = err.note {\n+            e.note(&note);\n+        }\n+        if let Some((label, span)) = err.secondary_label {\n+            let err_sp = template_span.from_inner(span);\n+            e.span_label(err_sp, label);\n+        }\n+        e.emit();\n+        return DummyResult::raw_expr(sp, true);\n+    }\n+\n+    // Register operands are implicitly used since they are not allowed to be\n+    // referenced in the template string.\n+    let mut used = vec![false; args.operands.len()];\n+    for pos in &args.reg_args {\n+        used[*pos] = true;\n+    }\n+\n+    let named_pos: FxHashSet<usize> = args.named_args.values().cloned().collect();\n+    let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n+    let mut template = vec![];\n+    for piece in unverified_pieces {\n+        match piece {\n+            parse::Piece::String(s) => {\n+                template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+            }\n+            parse::Piece::NextArgument(arg) => {\n+                let span = arg_spans.next().unwrap_or(template_sp);\n+\n+                let operand_idx = match arg.position {\n+                    parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n+                        if idx >= args.operands.len()\n+                            || named_pos.contains(&idx)\n+                            || args.reg_args.contains(&idx)\n+                        {\n+                            let msg = format!(\"invalid reference to argument at index {}\", idx);\n+                            let mut err = ecx.struct_span_err(span, &msg);\n+                            err.span_label(span, \"from here\");\n+\n+                            let positional_args =\n+                                args.operands.len() - args.named_args.len() - args.reg_args.len();\n+                            let positional = if positional_args != args.operands.len() {\n+                                \"positional \"\n+                            } else {\n+                                \"\"\n+                            };\n+                            let msg = match positional_args {\n+                                0 => format!(\"no {}arguments were given\", positional),\n+                                1 => format!(\"there is 1 {}argument\", positional),\n+                                x => format!(\"there are {} {}arguments\", x, positional),\n+                            };\n+                            err.note(&msg);\n+\n+                            if named_pos.contains(&idx) {\n+                                err.span_label(args.operands[idx].1, \"named argument\");\n+                                err.span_note(\n+                                    args.operands[idx].1,\n+                                    \"named arguments cannot be referenced by position\",\n+                                );\n+                            } else if args.reg_args.contains(&idx) {\n+                                err.span_label(args.operands[idx].1, \"explicit register argument\");\n+                                err.span_note(\n+                                    args.operands[idx].1,\n+                                    \"explicit register arguments cannot be used in the asm template\",\n+                                );\n+                            }\n+                            err.emit();\n+                            None\n+                        } else {\n+                            Some(idx)\n+                        }\n+                    }\n+                    parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n+                        Some(&idx) => Some(idx),\n+                        None => {\n+                            let msg = format!(\"there is no argument named `{}`\", name);\n+                            ecx.struct_span_err(span, &msg[..]).emit();\n+                            None\n+                        }\n+                    },\n+                };\n+\n+                let mut chars = arg.format.ty.chars();\n+                let mut modifier = chars.next();\n+                if !chars.next().is_none() {\n+                    let span = arg\n+                        .format\n+                        .ty_span\n+                        .map(|sp| template_sp.from_inner(sp))\n+                        .unwrap_or(template_sp);\n+                    ecx.struct_span_err(span, \"asm template modifier must be a single character\")\n+                        .emit();\n+                    modifier = None;\n+                }\n+\n+                if let Some(operand_idx) = operand_idx {\n+                    used[operand_idx] = true;\n+                    template.push(ast::InlineAsmTemplatePiece::Placeholder {\n+                        operand_idx,\n+                        modifier,\n+                        span,\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    let operands = args.operands;\n+    let unused_operands: Vec<_> = used\n+        .into_iter()\n+        .enumerate()\n+        .filter(|&(_, used)| !used)\n+        .map(|(idx, _)| {\n+            if named_pos.contains(&idx) {\n+                // named argument\n+                (operands[idx].1, \"named argument never used\")\n+            } else {\n+                // positional argument\n+                (operands[idx].1, \"argument never used\")\n+            }\n+        })\n+        .collect();\n+    match unused_operands.len() {\n+        0 => {}\n+        1 => {\n+            let (sp, msg) = unused_operands.into_iter().next().unwrap();\n+            let mut err = ecx.struct_span_err(sp, msg);\n+            err.span_label(sp, msg);\n+            err.emit();\n+        }\n+        _ => {\n+            let mut err = ecx.struct_span_err(\n+                unused_operands.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n+                \"multiple unused asm arguments\",\n+            );\n+            for (sp, msg) in unused_operands {\n+                err.span_label(sp, msg);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    let inline_asm = ast::InlineAsm { template, operands, options: args.options };\n+    P(ast::Expr {\n+        id: ast::DUMMY_NODE_ID,\n+        kind: ast::ExprKind::InlineAsm(inline_asm),\n+        span: sp,\n+        attrs: ast::AttrVec::new(),\n+    })\n+}\n+\n+pub fn expand_asm<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    match parse_args(ecx, sp, tts) {\n+        Ok(args) => MacEager::expr(expand_preparsed_asm(ecx, sp, args)),\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n+        }\n+    }\n+}"}, {"sha": "eed01b262bf0c10cf5a9bb74acc075b9e485fb1c", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 11, "deletions": 108, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -108,8 +108,6 @@ struct Context<'a, 'b> {\n     arg_spans: Vec<Span>,\n     /// All the formatting arguments that have formatting flags set, in order for diagnostics.\n     arg_with_formatting: Vec<parse::FormatSpec<'a>>,\n-    /// Whether this formatting string is a literal or it comes from a macro.\n-    is_literal: bool,\n }\n \n /// Parses the arguments from the given list of tokens, returning the diagnostic\n@@ -324,7 +322,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// format string.\n     fn report_invalid_references(&self, numbered_position_args: bool) {\n         let mut e;\n-        let sp = if self.is_literal {\n+        let sp = if !self.arg_spans.is_empty() {\n             // Point at the formatting arguments.\n             MultiSpan::from_spans(self.arg_spans.clone())\n         } else {\n@@ -372,7 +370,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let reg = refs.pop().unwrap();\n                 (format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg,), pos)\n             };\n-            if !self.is_literal {\n+            if self.arg_spans.is_empty() {\n                 sp = MultiSpan::from_span(self.fmtsp);\n             }\n \n@@ -502,11 +500,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        let sp = if self.is_literal {\n-                            *self.arg_spans.get(self.curpiece).unwrap_or(&self.fmtsp)\n-                        } else {\n-                            self.fmtsp\n-                        };\n+                        let sp = *self.arg_spans.get(self.curpiece).unwrap_or(&self.fmtsp);\n                         let mut err = self.ecx.struct_span_err(sp, &msg[..]);\n                         err.emit();\n                     }\n@@ -892,110 +886,20 @@ pub fn expand_preparsed_format_args(\n         }\n     };\n \n-    let (is_literal, fmt_snippet) = match ecx.source_map().span_to_snippet(fmt_sp) {\n-        Ok(s) => (s.starts_with('\"') || s.starts_with(\"r#\"), Some(s)),\n-        _ => (false, None),\n-    };\n-\n     let str_style = match fmt_style {\n         ast::StrStyle::Cooked => None,\n         ast::StrStyle::Raw(raw) => Some(raw as usize),\n     };\n \n-    /// Finds the indices of all characters that have been processed and differ between the actual\n-    /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n-    /// in order to properly synthethise the intra-string `Span`s for error diagnostics.\n-    fn find_skips(snippet: &str, is_raw: bool) -> Vec<usize> {\n-        let mut eat_ws = false;\n-        let mut s = snippet.chars().enumerate().peekable();\n-        let mut skips = vec![];\n-        while let Some((pos, c)) = s.next() {\n-            match (c, s.peek()) {\n-                // skip whitespace and empty lines ending in '\\\\'\n-                ('\\\\', Some((next_pos, '\\n'))) if !is_raw => {\n-                    eat_ws = true;\n-                    skips.push(pos);\n-                    skips.push(*next_pos);\n-                    let _ = s.next();\n-                }\n-                ('\\\\', Some((next_pos, '\\n' | 'n' | 't'))) if eat_ws => {\n-                    skips.push(pos);\n-                    skips.push(*next_pos);\n-                    let _ = s.next();\n-                }\n-                (' ' | '\\n' | '\\t', _) if eat_ws => {\n-                    skips.push(pos);\n-                }\n-                ('\\\\', Some((next_pos, 'n' | 't' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n-                    skips.push(*next_pos);\n-                    let _ = s.next();\n-                }\n-                ('\\\\', Some((_, 'x'))) if !is_raw => {\n-                    for _ in 0..3 {\n-                        // consume `\\xAB` literal\n-                        if let Some((pos, _)) = s.next() {\n-                            skips.push(pos);\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-                }\n-                ('\\\\', Some((_, 'u'))) if !is_raw => {\n-                    if let Some((pos, _)) = s.next() {\n-                        skips.push(pos);\n-                    }\n-                    if let Some((next_pos, next_c)) = s.next() {\n-                        if next_c == '{' {\n-                            skips.push(next_pos);\n-                            let mut i = 0; // consume up to 6 hexanumeric chars + closing `}`\n-                            while let (Some((next_pos, c)), true) = (s.next(), i < 7) {\n-                                if c.is_digit(16) {\n-                                    skips.push(next_pos);\n-                                } else if c == '}' {\n-                                    skips.push(next_pos);\n-                                    break;\n-                                } else {\n-                                    break;\n-                                }\n-                                i += 1;\n-                            }\n-                        } else if next_c.is_digit(16) {\n-                            skips.push(next_pos);\n-                            // We suggest adding `{` and `}` when appropriate, accept it here as if\n-                            // it were correct\n-                            let mut i = 0; // consume up to 6 hexanumeric chars\n-                            while let (Some((next_pos, c)), _) = (s.next(), i < 6) {\n-                                if c.is_digit(16) {\n-                                    skips.push(next_pos);\n-                                } else {\n-                                    break;\n-                                }\n-                                i += 1;\n-                            }\n-                        }\n-                    }\n-                }\n-                _ if eat_ws => {\n-                    // `take_while(|c| c.is_whitespace())`\n-                    eat_ws = false;\n-                }\n-                _ => {}\n-            }\n-        }\n-        skips\n-    }\n-\n-    let skips = if let (true, Some(ref snippet)) = (is_literal, fmt_snippet.as_ref()) {\n-        let r_start = str_style.map(|r| r + 1).unwrap_or(0);\n-        let r_end = str_style.map(|r| r).unwrap_or(0);\n-        let s = &snippet[r_start + 1..snippet.len() - r_end - 1];\n-        find_skips(s, str_style.is_some())\n-    } else {\n-        vec![]\n-    };\n-\n     let fmt_str = &fmt_str.as_str(); // for the suggestions below\n-    let mut parser = parse::Parser::new(fmt_str, str_style, skips, append_newline);\n+    let fmt_snippet = ecx.source_map().span_to_snippet(fmt_sp).ok();\n+    let mut parser = parse::Parser::new(\n+        fmt_str,\n+        str_style,\n+        fmt_snippet,\n+        append_newline,\n+        parse::ParseMode::Format,\n+    );\n \n     let mut unverified_pieces = Vec::new();\n     while let Some(piece) = parser.next() {\n@@ -1048,7 +952,6 @@ pub fn expand_preparsed_format_args(\n         invalid_refs: Vec::new(),\n         arg_spans,\n         arg_with_formatting: Vec::new(),\n-        is_literal,\n     };\n \n     // This needs to happen *after* the Parser has consumed all pieces to create all the spans"}, {"sha": "a0f82d65618f460d8313510c5f38683711fdf8d0", "filename": "src/librustc_builtin_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_builtin_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_builtin_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Flib.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -19,6 +19,7 @@ use rustc_expand::proc_macro::BangProcMacro;\n use rustc_span::edition::Edition;\n use rustc_span::symbol::{sym, Ident};\n \n+mod asm;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n@@ -61,7 +62,7 @@ pub fn register_builtin_macros(resolver: &mut dyn Resolver, edition: Edition) {\n     }\n \n     register_bang! {\n-        asm: llvm_asm::expand_llvm_asm,\n+        asm: asm::expand_asm,\n         assert: assert::expand_assert,\n         cfg: cfg::expand_cfg,\n         column: source_util::expand_column,"}, {"sha": "8986ab322c07fa383b43137a7b01825933d63b88", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 546, "deletions": 15, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,14 +1,22 @@\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::llvm;\n+use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n \n+use rustc_ast::ast::LlvmAsmDialect;\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::mir::operand::OperandValue;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n+use rustc_middle::span_bug;\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::Span;\n+use rustc_target::abi::*;\n+use rustc_target::asm::*;\n \n use libc::{c_char, c_uint};\n use log::debug;\n@@ -40,7 +48,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     indirect_outputs.push(operand.immediate());\n                 }\n             } else {\n-                output_types.push(place.layout.llvm_type(self.cx()));\n+                output_types.push(place.layout.llvm_type(self.cx));\n             }\n         }\n         if !indirect_outputs.is_empty() {\n@@ -89,6 +97,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             ia.volatile,\n             ia.alignstack,\n             ia.dialect,\n+            span,\n         );\n         if r.is_none() {\n             return false;\n@@ -102,22 +111,214 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             OperandValue::Immediate(v).store(self, place);\n         }\n \n-        // Store mark in a metadata node so we can map LLVM errors\n-        // back to source locations.  See #17552.\n-        unsafe {\n-            let key = \"srcloc\";\n-            let kind = llvm::LLVMGetMDKindIDInContext(\n-                self.llcx,\n-                key.as_ptr() as *const c_char,\n-                key.len() as c_uint,\n-            );\n+        true\n+    }\n \n-            let val: &'ll Value = self.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n+    fn codegen_inline_asm(\n+        &mut self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[InlineAsmOperandRef<'tcx, Self>],\n+        options: InlineAsmOptions,\n+        span: Span,\n+    ) {\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n \n-            llvm::LLVMSetMetadata(r, kind, llvm::LLVMMDNodeInContext(self.llcx, &val, 1));\n+        // Collect the types of output operands\n+        let mut constraints = vec![];\n+        let mut output_types = vec![];\n+        let mut op_idx = FxHashMap::default();\n+        for (idx, op) in operands.iter().enumerate() {\n+            match *op {\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    let ty = if let Some(place) = place {\n+                        llvm_fixup_output_type(self.cx, reg.reg_class(), &place.layout)\n+                    } else {\n+                        // If the output is discarded, we don't really care what\n+                        // type is used. We're just using this to tell LLVM to\n+                        // reserve the register.\n+                        dummy_output_type(self.cx, reg.reg_class())\n+                    };\n+                    output_types.push(ty);\n+                    op_idx.insert(idx, constraints.len());\n+                    let prefix = if late { \"=\" } else { \"=&\" };\n+                    constraints.push(format!(\"{}{}\", prefix, reg_to_llvm(reg)));\n+                }\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    let ty = if let Some(ref out_place) = out_place {\n+                        llvm_fixup_output_type(self.cx, reg.reg_class(), &out_place.layout)\n+                    } else {\n+                        // LLVM required tied operands to have the same type,\n+                        // so we just use the type of the input.\n+                        llvm_fixup_output_type(self.cx, reg.reg_class(), &in_value.layout)\n+                    };\n+                    output_types.push(ty);\n+                    op_idx.insert(idx, constraints.len());\n+                    let prefix = if late { \"=\" } else { \"=&\" };\n+                    constraints.push(format!(\"{}{}\", prefix, reg_to_llvm(reg)));\n+                }\n+                _ => {}\n+            }\n         }\n \n-        true\n+        // Collect input operands\n+        let mut inputs = vec![];\n+        for (idx, op) in operands.iter().enumerate() {\n+            match *op {\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    let value =\n+                        llvm_fixup_input(self, value.immediate(), reg.reg_class(), &value.layout);\n+                    inputs.push(value);\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(reg_to_llvm(reg));\n+                }\n+                InlineAsmOperandRef::InOut { reg, late: _, in_value, out_place: _ } => {\n+                    let value = llvm_fixup_input(\n+                        self,\n+                        in_value.immediate(),\n+                        reg.reg_class(),\n+                        &in_value.layout,\n+                    );\n+                    inputs.push(value);\n+                    constraints.push(format!(\"{}\", op_idx[&idx]));\n+                }\n+                InlineAsmOperandRef::SymFn { instance } => {\n+                    inputs.push(self.cx.get_fn(instance));\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(\"s\".to_string());\n+                }\n+                InlineAsmOperandRef::SymStatic { def_id } => {\n+                    inputs.push(self.cx.get_static(def_id));\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(\"s\".to_string());\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Build the template string\n+        let mut template_str = String::new();\n+        for piece in template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => {\n+                    if s.contains('$') {\n+                        for c in s.chars() {\n+                            if c == '$' {\n+                                template_str.push_str(\"$$\");\n+                            } else {\n+                                template_str.push(c);\n+                            }\n+                        }\n+                    } else {\n+                        template_str.push_str(s)\n+                    }\n+                }\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n+                    match operands[operand_idx] {\n+                        InlineAsmOperandRef::In { reg, .. }\n+                        | InlineAsmOperandRef::Out { reg, .. }\n+                        | InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let modifier = modifier_to_llvm(asm_arch, reg.reg_class(), modifier);\n+                            if let Some(modifier) = modifier {\n+                                template_str.push_str(&format!(\n+                                    \"${{{}:{}}}\",\n+                                    op_idx[&operand_idx], modifier\n+                                ));\n+                            } else {\n+                                template_str.push_str(&format!(\"${{{}}}\", op_idx[&operand_idx]));\n+                            }\n+                        }\n+                        InlineAsmOperandRef::Const { ref string } => {\n+                            // Const operands get injected directly into the template\n+                            template_str.push_str(string);\n+                        }\n+                        InlineAsmOperandRef::SymFn { .. }\n+                        | InlineAsmOperandRef::SymStatic { .. } => {\n+                            // Only emit the raw symbol name\n+                            template_str.push_str(&format!(\"${{{}:c}}\", op_idx[&operand_idx]));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+            match asm_arch {\n+                InlineAsmArch::AArch64 | InlineAsmArch::Arm => {\n+                    constraints.push(\"~{cc}\".to_string());\n+                }\n+                InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                    constraints.extend_from_slice(&[\n+                        \"~{dirflag}\".to_string(),\n+                        \"~{fpsr}\".to_string(),\n+                        \"~{flags}\".to_string(),\n+                    ]);\n+                }\n+                InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n+            }\n+        }\n+        if !options.contains(InlineAsmOptions::NOMEM) {\n+            // This is actually ignored by LLVM, but it's probably best to keep\n+            // it just in case. LLVM instead uses the ReadOnly/ReadNone\n+            // attributes on the call instruction to optimize.\n+            constraints.push(\"~{memory}\".to_string());\n+        }\n+        let volatile = !options.contains(InlineAsmOptions::PURE);\n+        let alignstack = !options.contains(InlineAsmOptions::NOSTACK);\n+        let output_type = match &output_types[..] {\n+            [] => self.type_void(),\n+            [ty] => ty,\n+            tys => self.type_struct(&tys, false),\n+        };\n+        let dialect = match asm_arch {\n+            InlineAsmArch::X86 | InlineAsmArch::X86_64\n+                if !options.contains(InlineAsmOptions::ATT_SYNTAX) =>\n+            {\n+                LlvmAsmDialect::Intel\n+            }\n+            _ => LlvmAsmDialect::Att,\n+        };\n+        let result = inline_asm_call(\n+            self,\n+            &template_str,\n+            &constraints.join(\",\"),\n+            &inputs,\n+            output_type,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            span,\n+        )\n+        .unwrap_or_else(|| span_bug!(span, \"LLVM asm constraint validation failed\"));\n+\n+        if options.contains(InlineAsmOptions::PURE) {\n+            if options.contains(InlineAsmOptions::NOMEM) {\n+                llvm::Attribute::ReadNone.apply_callsite(llvm::AttributePlace::Function, result);\n+            } else if options.contains(InlineAsmOptions::READONLY) {\n+                llvm::Attribute::ReadOnly.apply_callsite(llvm::AttributePlace::Function, result);\n+            }\n+        } else {\n+            if options.contains(InlineAsmOptions::NOMEM) {\n+                llvm::Attribute::InaccessibleMemOnly\n+                    .apply_callsite(llvm::AttributePlace::Function, result);\n+            } else {\n+                // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n+            }\n+        }\n+\n+        // Write results to outputs\n+        for (idx, op) in operands.iter().enumerate() {\n+            if let InlineAsmOperandRef::Out { reg, place: Some(place), .. }\n+            | InlineAsmOperandRef::InOut { reg, out_place: Some(place), .. } = *op\n+            {\n+                let value = if output_types.len() == 1 {\n+                    result\n+                } else {\n+                    self.extract_value(result, op_idx[&idx] as u64)\n+                };\n+                let value = llvm_fixup_output(self, value, reg.reg_class(), &place.layout);\n+                OperandValue::Immediate(value).store(self, place);\n+            }\n+        }\n     }\n }\n \n@@ -138,7 +339,8 @@ fn inline_asm_call(\n     output: &'ll llvm::Type,\n     volatile: bool,\n     alignstack: bool,\n-    dia: ::rustc_ast::ast::LlvmAsmDialect,\n+    dia: LlvmAsmDialect,\n+    span: Span,\n ) -> Option<&'ll Value> {\n     let volatile = if volatile { llvm::True } else { llvm::False };\n     let alignstack = if alignstack { llvm::True } else { llvm::False };\n@@ -168,10 +370,339 @@ fn inline_asm_call(\n                 alignstack,\n                 llvm::AsmDialect::from_generic(dia),\n             );\n-            Some(bx.call(v, inputs, None))\n+            let call = bx.call(v, inputs, None);\n+\n+            // Store mark in a metadata node so we can map LLVM errors\n+            // back to source locations.  See #17552.\n+            let key = \"srcloc\";\n+            let kind = llvm::LLVMGetMDKindIDInContext(\n+                bx.llcx,\n+                key.as_ptr() as *const c_char,\n+                key.len() as c_uint,\n+            );\n+\n+            let val: &'ll Value = bx.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n+            llvm::LLVMSetMetadata(call, kind, llvm::LLVMMDNodeInContext(bx.llcx, &val, 1));\n+\n+            Some(call)\n         } else {\n             // LLVM has detected an issue with our constraints, bail out\n             None\n         }\n     }\n }\n+\n+/// Converts a register class to an LLVM constraint code.\n+fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n+    match reg {\n+        InlineAsmRegOrRegClass::Reg(reg) => format!(\"{{{}}}\", reg.name()),\n+        InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => \"w\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => \"x\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => \"l\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8) => \"t\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"^Yk\",\n+        }\n+        .to_string(),\n+    }\n+}\n+\n+/// Converts a modifier into LLVM's equivalent modifier.\n+fn modifier_to_llvm(\n+    arch: InlineAsmArch,\n+    reg: InlineAsmRegClass,\n+    modifier: Option<char>,\n+) -> Option<char> {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            if modifier == Some('v') { None } else { modifier }\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => None,\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => None,\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => Some('P'),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            if modifier.is_none() {\n+                Some('q')\n+            } else {\n+                modifier\n+            }\n+        }\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n+            None if arch == InlineAsmArch::X86_64 => Some('q'),\n+            None => Some('k'),\n+            Some('l') => Some('b'),\n+            Some('h') => Some('h'),\n+            Some('x') => Some('w'),\n+            Some('e') => Some('k'),\n+            Some('r') => Some('q'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => None,\n+        InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::zmm_reg) => match (reg, modifier) {\n+            (X86InlineAsmRegClass::xmm_reg, None) => Some('x'),\n+            (X86InlineAsmRegClass::ymm_reg, None) => Some('t'),\n+            (X86InlineAsmRegClass::zmm_reg, None) => Some('g'),\n+            (_, Some('x')) => Some('x'),\n+            (_, Some('y')) => Some('t'),\n+            (_, Some('z')) => Some('g'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+    }\n+}\n+\n+/// Type to use for outputs that are discarded. It doesn't really matter what\n+/// the type is, as long as it is valid for the constraint code.\n+fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll Type {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            cx.type_vector(cx.type_i64(), 2)\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => cx.type_i32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => cx.type_f32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => cx.type_f64(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            cx.type_vector(cx.type_i64(), 2)\n+        }\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => cx.type_i32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => cx.type_i8(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+    }\n+}\n+\n+/// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n+/// the equivalent integer type.\n+fn llvm_asm_scalar_type(cx: &CodegenCx<'ll, 'tcx>, scalar: &Scalar) -> &'ll Type {\n+    match scalar.value {\n+        Primitive::Int(Integer::I8, _) => cx.type_i8(),\n+        Primitive::Int(Integer::I16, _) => cx.type_i16(),\n+        Primitive::Int(Integer::I32, _) => cx.type_i32(),\n+        Primitive::Int(Integer::I64, _) => cx.type_i64(),\n+        Primitive::F32 => cx.type_f32(),\n+        Primitive::F64 => cx.type_f64(),\n+        Primitive::Pointer => cx.type_isize(),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+/// Fix up an input value to work around LLVM bugs.\n+fn llvm_fixup_input(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    mut value: &'ll Value,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Value {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                let vec_ty = bx.cx.type_vector(bx.cx.type_i8(), 8);\n+                bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n+            } else {\n+                value\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, s);\n+            let count = 16 / layout.size.bytes();\n+            let vec_ty = bx.cx.type_vector(elem_ty, count);\n+            if let Primitive::Pointer = s.value {\n+                value = bx.ptrtoint(value, bx.cx.type_isize());\n+            }\n+            bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n+            let vec_ty = bx.cx.type_vector(elem_ty, *count);\n+            let indices: Vec<_> = (0..count * 2).map(|x| bx.const_i32(x as i32)).collect();\n+            bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n+        }\n+        (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n+            if s.value == Primitive::F64 =>\n+        {\n+            bx.bitcast(value, bx.cx.type_i64())\n+        }\n+        (\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg | X86InlineAsmRegClass::zmm_reg),\n+            Abi::Vector { .. },\n+        ) if layout.size.bytes() == 64 => bx.bitcast(value, bx.cx.type_vector(bx.cx.type_f64(), 8)),\n+        (\n+            InlineAsmRegClass::Arm(\n+                ArmInlineAsmRegClass::sreg_low16\n+                | ArmInlineAsmRegClass::dreg_low8\n+                | ArmInlineAsmRegClass::qreg_low4\n+                | ArmInlineAsmRegClass::dreg\n+                | ArmInlineAsmRegClass::qreg,\n+            ),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I32, _) = s.value {\n+                bx.bitcast(value, bx.cx.type_f32())\n+            } else {\n+                value\n+            }\n+        }\n+        _ => value,\n+    }\n+}\n+\n+/// Fix up an output value to work around LLVM bugs.\n+fn llvm_fixup_output(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    mut value: &'ll Value,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Value {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                bx.extract_element(value, bx.const_i32(0))\n+            } else {\n+                value\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            value = bx.extract_element(value, bx.const_i32(0));\n+            if let Primitive::Pointer = s.value {\n+                value = bx.inttoptr(value, layout.llvm_type(bx.cx));\n+            }\n+            value\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n+            let vec_ty = bx.cx.type_vector(elem_ty, *count * 2);\n+            let indices: Vec<_> = (0..*count).map(|x| bx.const_i32(x as i32)).collect();\n+            bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n+        }\n+        (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n+            if s.value == Primitive::F64 =>\n+        {\n+            bx.bitcast(value, bx.cx.type_f64())\n+        }\n+        (\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg | X86InlineAsmRegClass::zmm_reg),\n+            Abi::Vector { .. },\n+        ) if layout.size.bytes() == 64 => bx.bitcast(value, layout.llvm_type(bx.cx)),\n+        (\n+            InlineAsmRegClass::Arm(\n+                ArmInlineAsmRegClass::sreg_low16\n+                | ArmInlineAsmRegClass::dreg_low8\n+                | ArmInlineAsmRegClass::qreg_low4\n+                | ArmInlineAsmRegClass::dreg\n+                | ArmInlineAsmRegClass::qreg,\n+            ),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I32, _) = s.value {\n+                bx.bitcast(value, bx.cx.type_i32())\n+            } else {\n+                value\n+            }\n+        }\n+        _ => value,\n+    }\n+}\n+\n+/// Output type to use for llvm_fixup_output.\n+fn llvm_fixup_output_type(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Type {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                cx.type_vector(cx.type_i8(), 8)\n+            } else {\n+                layout.llvm_type(cx)\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            let elem_ty = llvm_asm_scalar_type(cx, s);\n+            let count = 16 / layout.size.bytes();\n+            cx.type_vector(elem_ty, count)\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(cx, element);\n+            cx.type_vector(elem_ty, count * 2)\n+        }\n+        (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n+            if s.value == Primitive::F64 =>\n+        {\n+            cx.type_i64()\n+        }\n+        (\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg | X86InlineAsmRegClass::zmm_reg),\n+            Abi::Vector { .. },\n+        ) if layout.size.bytes() == 64 => cx.type_vector(cx.type_f64(), 8),\n+        (\n+            InlineAsmRegClass::Arm(\n+                ArmInlineAsmRegClass::sreg_low16\n+                | ArmInlineAsmRegClass::dreg_low8\n+                | ArmInlineAsmRegClass::qreg_low4\n+                | ArmInlineAsmRegClass::dreg\n+                | ArmInlineAsmRegClass::qreg,\n+            ),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I32, _) = s.value {\n+                cx.type_f32()\n+            } else {\n+                layout.llvm_type(cx)\n+            }\n+        }\n+        _ => layout.llvm_type(cx),\n+    }\n+}"}, {"sha": "9cb0f0e0c2e677d1340951cd487c693e27b9d0c7", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -124,6 +124,8 @@ pub enum Attribute {\n     NonLazyBind = 23,\n     OptimizeNone = 24,\n     ReturnsTwice = 25,\n+    ReadNone = 26,\n+    InaccessibleMemOnly = 27,\n }\n \n /// LLVMIntPredicate"}, {"sha": "286d3630181cb7ebc1a2a42d1f13af73266c704f", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -236,6 +236,15 @@ const POWERPC_WHITELIST: &[(&str, Option<Symbol>)] = &[\n const MIPS_WHITELIST: &[(&str, Option<Symbol>)] =\n     &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n \n+const RISCV_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"m\", Some(sym::riscv_target_feature)),\n+    (\"a\", Some(sym::riscv_target_feature)),\n+    (\"c\", Some(sym::riscv_target_feature)),\n+    (\"f\", Some(sym::riscv_target_feature)),\n+    (\"d\", Some(sym::riscv_target_feature)),\n+    (\"e\", Some(sym::riscv_target_feature)),\n+];\n+\n const WASM_WHITELIST: &[(&str, Option<Symbol>)] =\n     &[(\"simd128\", Some(sym::wasm_target_feature)), (\"atomics\", Some(sym::wasm_target_feature))];\n \n@@ -253,6 +262,7 @@ pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol\n         .chain(HEXAGON_WHITELIST.iter().cloned())\n         .chain(POWERPC_WHITELIST.iter().cloned())\n         .chain(MIPS_WHITELIST.iter().cloned())\n+        .chain(RISCV_WHITELIST.iter().cloned())\n         .chain(WASM_WHITELIST.iter().cloned())\n }\n \n@@ -297,6 +307,7 @@ pub fn target_feature_whitelist(sess: &Session) -> &'static [(&'static str, Opti\n         \"hexagon\" => HEXAGON_WHITELIST,\n         \"mips\" | \"mips64\" => MIPS_WHITELIST,\n         \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n+        \"riscv32\" | \"riscv64\" => RISCV_WHITELIST,\n         \"wasm32\" => WASM_WHITELIST,\n         _ => &[],\n     }"}, {"sha": "5e3a37e20bd4f1beb6f0d7513ffcebf39caea1ce", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -358,7 +358,8 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n                 | TerminatorKind::SwitchInt { .. }\n                 | TerminatorKind::Yield { .. }\n                 | TerminatorKind::FalseEdges { .. }\n-                | TerminatorKind::FalseUnwind { .. } => { /* nothing to do */ }\n+                | TerminatorKind::FalseUnwind { .. }\n+                | TerminatorKind::InlineAsm { .. } => { /* nothing to do */ }\n                 TerminatorKind::Call { cleanup: unwind, .. }\n                 | TerminatorKind::Assert { cleanup: unwind, .. }\n                 | TerminatorKind::DropAndReplace { unwind, .. }"}, {"sha": "b487ed8dea8b69cf135a2ae5fb41f344012a35d4", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -9,9 +9,11 @@ use crate::meth;\n use crate::traits::*;\n use crate::MemFlags;\n \n+use rustc_ast::ast;\n use rustc_hir::lang_items;\n use rustc_index::vec::Idx;\n use rustc_middle::mir;\n+use rustc_middle::mir::interpret::{AllocId, ConstValue, Pointer, Scalar};\n use rustc_middle::mir::AssertKind;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n@@ -820,6 +822,123 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             cleanup,\n         );\n     }\n+\n+    fn codegen_asm_terminator(\n+        &mut self,\n+        helper: TerminatorCodegenHelper<'tcx>,\n+        mut bx: Bx,\n+        terminator: &mir::Terminator<'tcx>,\n+        template: &[ast::InlineAsmTemplatePiece],\n+        operands: &[mir::InlineAsmOperand<'tcx>],\n+        options: ast::InlineAsmOptions,\n+        destination: Option<mir::BasicBlock>,\n+    ) {\n+        let span = terminator.source_info.span;\n+\n+        let operands: Vec<_> = operands\n+            .iter()\n+            .map(|op| match *op {\n+                mir::InlineAsmOperand::In { reg, ref value } => {\n+                    let value = self.codegen_operand(&mut bx, value);\n+                    InlineAsmOperandRef::In { reg, value }\n+                }\n+                mir::InlineAsmOperand::Out { reg, late, ref place } => {\n+                    let place = place.map(|place| self.codegen_place(&mut bx, place.as_ref()));\n+                    InlineAsmOperandRef::Out { reg, late, place }\n+                }\n+                mir::InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n+                    let in_value = self.codegen_operand(&mut bx, in_value);\n+                    let out_place =\n+                        out_place.map(|out_place| self.codegen_place(&mut bx, out_place.as_ref()));\n+                    InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n+                }\n+                mir::InlineAsmOperand::Const { ref value } => {\n+                    if let mir::Operand::Constant(constant) = value {\n+                        let const_value = self\n+                            .eval_mir_constant(constant)\n+                            .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n+                        let ty = constant.literal.ty;\n+                        let size = bx.layout_of(ty).size;\n+                        let scalar = match const_value {\n+                            // Promoted constants are evaluated into a ByRef instead of a Scalar,\n+                            // but we want the scalar value here.\n+                            ConstValue::ByRef { alloc, offset } => {\n+                                let ptr = Pointer::new(AllocId(0), offset);\n+                                alloc\n+                                    .read_scalar(&bx, ptr, size)\n+                                    .and_then(|s| s.not_undef())\n+                                    .unwrap_or_else(|e| {\n+                                        bx.tcx().sess.span_err(\n+                                            span,\n+                                            &format!(\"Could not evaluate asm const: {}\", e),\n+                                        );\n+\n+                                        // We are erroring out, just emit a dummy constant.\n+                                        Scalar::from_u64(0)\n+                                    })\n+                            }\n+                            _ => span_bug!(span, \"expected ByRef for promoted asm const\"),\n+                        };\n+                        let value = scalar.assert_bits(size);\n+                        let string = match ty.kind {\n+                            ty::Uint(_) => value.to_string(),\n+                            ty::Int(int_ty) => {\n+                                match int_ty.normalize(bx.tcx().sess.target.ptr_width) {\n+                                    ast::IntTy::I8 => (value as i8).to_string(),\n+                                    ast::IntTy::I16 => (value as i16).to_string(),\n+                                    ast::IntTy::I32 => (value as i32).to_string(),\n+                                    ast::IntTy::I64 => (value as i64).to_string(),\n+                                    ast::IntTy::I128 => (value as i128).to_string(),\n+                                    ast::IntTy::Isize => unreachable!(),\n+                                }\n+                            }\n+                            ty::Float(ast::FloatTy::F32) => {\n+                                f32::from_bits(value as u32).to_string()\n+                            }\n+                            ty::Float(ast::FloatTy::F64) => {\n+                                f64::from_bits(value as u64).to_string()\n+                            }\n+                            _ => span_bug!(span, \"asm const has bad type {}\", ty),\n+                        };\n+                        InlineAsmOperandRef::Const { string }\n+                    } else {\n+                        span_bug!(span, \"asm const is not a constant\");\n+                    }\n+                }\n+                mir::InlineAsmOperand::SymFn { ref value } => {\n+                    let literal = self.monomorphize(&value.literal);\n+                    if let ty::FnDef(def_id, substs) = literal.ty.kind {\n+                        let instance = ty::Instance::resolve(\n+                            bx.tcx(),\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            substs,\n+                        )\n+                        .unwrap()\n+                        .unwrap();\n+                        InlineAsmOperandRef::SymFn { instance }\n+                    } else {\n+                        span_bug!(span, \"invalid type for asm sym (fn)\");\n+                    }\n+                }\n+                mir::InlineAsmOperand::SymStatic { ref value } => {\n+                    if let Some(def_id) = value.check_static_ptr(bx.tcx()) {\n+                        InlineAsmOperandRef::SymStatic { def_id }\n+                    } else {\n+                        span_bug!(span, \"invalid type for asm sym (static)\");\n+                    }\n+                }\n+            })\n+            .collect();\n+\n+        bx.codegen_inline_asm(template, &operands, options, span);\n+\n+        if let Some(target) = destination {\n+            helper.funclet_br(self, &mut bx, target);\n+        } else {\n+            bx.unreachable();\n+        }\n+    }\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -914,6 +1033,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::TerminatorKind::FalseEdges { .. } | mir::TerminatorKind::FalseUnwind { .. } => {\n                 bug!(\"borrowck false edges in codegen\")\n             }\n+\n+            mir::TerminatorKind::InlineAsm { template, ref operands, options, destination } => {\n+                self.codegen_asm_terminator(\n+                    helper,\n+                    bx,\n+                    terminator,\n+                    template,\n+                    operands,\n+                    options,\n+                    destination,\n+                );\n+            }\n         }\n     }\n "}, {"sha": "0abfdfde7801bbe18c78587f5846a3f4cef81cfe", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,7 +1,40 @@\n use super::BackendTypes;\n+use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::{GlobalAsm, LlvmInlineAsmInner};\n+use rustc_middle::ty::Instance;\n use rustc_span::Span;\n+use rustc_target::asm::InlineAsmRegOrRegClass;\n+\n+#[derive(Debug)]\n+pub enum InlineAsmOperandRef<'tcx, B: BackendTypes + ?Sized> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        value: OperandRef<'tcx, B::Value>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        place: Option<PlaceRef<'tcx, B::Value>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_value: OperandRef<'tcx, B::Value>,\n+        out_place: Option<PlaceRef<'tcx, B::Value>>,\n+    },\n+    Const {\n+        string: String,\n+    },\n+    SymFn {\n+        instance: Instance<'tcx>,\n+    },\n+    SymStatic {\n+        def_id: DefId,\n+    },\n+}\n \n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n     /// Take an inline assembly expression and splat it out via LLVM\n@@ -12,6 +45,15 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n         inputs: Vec<Self::Value>,\n         span: Span,\n     ) -> bool;\n+\n+    /// Take an inline assembly expression and splat it out via LLVM\n+    fn codegen_inline_asm(\n+        &mut self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[InlineAsmOperandRef<'tcx, Self>],\n+        options: InlineAsmOptions,\n+        span: Span,\n+    );\n }\n \n pub trait AsmMethods {"}, {"sha": "6b782731d535c2191c8db5fb528ed6099d269516", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -28,7 +28,7 @@ mod type_;\n mod write;\n \n pub use self::abi::AbiBuilderMethods;\n-pub use self::asm::{AsmBuilderMethods, AsmMethods};\n+pub use self::asm::{AsmBuilderMethods, AsmMethods, InlineAsmOperandRef};\n pub use self::backend::{Backend, BackendTypes, CodegenBackend, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;"}, {"sha": "fccd1b96f60dbe24873b98df3deb2adb2c7d4723", "filename": "src/librustc_error_codes/error_codes/E0660.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0660.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0660.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0660.md?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -7,6 +7,6 @@ llvm_asm!(\"nop\" \"nop\");\n ```\n \n Considering that this would be a long explanation, we instead recommend you\n-take a look at the [`asm`] chapter of the Unstable book:\n+take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/asm.html\n+[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "f1debee7a18f188795781a9a17c09c36857abab4", "filename": "src/librustc_error_codes/error_codes/E0661.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0661.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0661.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0661.md?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -8,6 +8,6 @@ llvm_asm!(\"nop\" : \"r\"(a));\n ```\n \n Considering that this would be a long explanation, we instead recommend you\n-take a look at the [`asm`] chapter of the Unstable book:\n+take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/asm.html\n+[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "d4765f078b0e6d975ecbea7a4500e521dfad7028", "filename": "src/librustc_error_codes/error_codes/E0662.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0662.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0662.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0662.md?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -11,6 +11,6 @@ llvm_asm!(\"xor %eax, %eax\"\n ```\n \n Considering that this would be a long explanation, we instead recommend you\n-take a look at the [`asm`] chapter of the Unstable book:\n+take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/asm.html\n+[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "d5a85b275db632a83dd8e7d0ba7131fbf61820f6", "filename": "src/librustc_error_codes/error_codes/E0663.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0663.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0663.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0663.md?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -11,6 +11,6 @@ llvm_asm!(\"xor %eax, %eax\"\n ```\n \n Considering that this would be a long explanation, we instead recommend you\n-take a look at the [`asm`] chapter of the Unstable book:\n+take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/asm.html\n+[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "ce9c9491df3d767f1fe6e9513749071ce7497e6f", "filename": "src/librustc_error_codes/error_codes/E0664.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0664.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_error_codes%2Ferror_codes%2FE0664.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0664.md?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -11,6 +11,6 @@ llvm_asm!(\"mov $$0x200, %eax\"\n ```\n \n Considering that this would be a long explanation, we instead recommend you\n-take a look at the [`asm`] chapter of the Unstable book:\n+take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/asm.html\n+[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "30b8b52bf24d0517daa9a71c3bf3d927d6c2345e", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -238,6 +238,7 @@ declare_features! (\n     (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n     (active, rtm_target_feature, \"1.35.0\", Some(44839), None),\n     (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n+    (active, riscv_target_feature, \"1.45.0\", Some(44839), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates (target features)"}, {"sha": "6ba396666070ab4fbca05381ee111235acf3549e", "filename": "src/librustc_hir/arena.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Farena.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -14,6 +14,8 @@ macro_rules! arena_types {\n             // HIR types\n             [few] hir_krate: rustc_hir::Crate<$tcx>,\n             [] arm: rustc_hir::Arm<$tcx>,\n+            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>,\n+            [] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n             [] attribute: rustc_ast::ast::Attribute,\n             [] block: rustc_hir::Block<$tcx>,\n             [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>,\n@@ -28,7 +30,8 @@ macro_rules! arena_types {\n             [] fn_decl: rustc_hir::FnDecl<$tcx>,\n             [] foreign_item: rustc_hir::ForeignItem<$tcx>,\n             [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>,\n-            [] inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n+            [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n+            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n             [] local: rustc_hir::Local<$tcx>,\n             [few] macro_def: rustc_hir::MacroDef<$tcx>,\n             [] param: rustc_hir::Param<$tcx>,"}, {"sha": "ef398ab25d3fbd283c0053b6866c1958a44f9735", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::ast::{self, CrateSugar, LlvmAsmDialect};\n use rustc_ast::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n pub use rustc_ast::ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::ast::{CaptureBy, Movability, Mutability};\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_data_structures::fx::FxHashSet;\n@@ -15,6 +16,7 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_target::asm::InlineAsmRegOrRegClass;\n use rustc_target::spec::abi::Abi;\n \n use smallvec::SmallVec;\n@@ -1391,6 +1393,7 @@ impl Expr<'_> {\n             ExprKind::Break(..) => ExprPrecedence::Break,\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n+            ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n             ExprKind::LlvmInlineAsm(..) => ExprPrecedence::InlineAsm,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n@@ -1446,6 +1449,7 @@ impl Expr<'_> {\n             | ExprKind::Ret(..)\n             | ExprKind::Loop(..)\n             | ExprKind::Assign(..)\n+            | ExprKind::InlineAsm(..)\n             | ExprKind::LlvmInlineAsm(..)\n             | ExprKind::AssignOp(..)\n             | ExprKind::Lit(_)\n@@ -1622,6 +1626,8 @@ pub enum ExprKind<'hir> {\n     /// A `return`, with an optional value to be returned.\n     Ret(Option<&'hir Expr<'hir>>),\n \n+    /// Inline assembly (from `asm!`), with its outputs and inputs.\n+    InlineAsm(&'hir InlineAsm<'hir>),\n     /// Inline assembly (from `llvm_asm!`), with its outputs and inputs.\n     LlvmInlineAsm(&'hir LlvmInlineAsm<'hir>),\n \n@@ -2054,6 +2060,55 @@ pub enum TyKind<'hir> {\n     Err,\n }\n \n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub enum InlineAsmOperand<'hir> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        expr: Expr<'hir>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: Option<Expr<'hir>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: Expr<'hir>,\n+    },\n+    SplitInOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_expr: Expr<'hir>,\n+        out_expr: Option<Expr<'hir>>,\n+    },\n+    Const {\n+        expr: Expr<'hir>,\n+    },\n+    Sym {\n+        expr: Expr<'hir>,\n+    },\n+}\n+\n+impl<'hir> InlineAsmOperand<'hir> {\n+    pub fn reg(&self) -> Option<InlineAsmRegOrRegClass> {\n+        match *self {\n+            Self::In { reg, .. }\n+            | Self::Out { reg, .. }\n+            | Self::InOut { reg, .. }\n+            | Self::SplitInOut { reg, .. } => Some(reg),\n+            Self::Const { .. } | Self::Sym { .. } => None,\n+        }\n+    }\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub struct InlineAsm<'hir> {\n+    pub template: &'hir [InlineAsmTemplatePiece],\n+    pub operands: &'hir [InlineAsmOperand<'hir>],\n+    pub options: InlineAsmOptions,\n+}\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n pub struct LlvmInlineAsmOutput {\n     pub constraint: Symbol,"}, {"sha": "97601a3e1ac7bd1cf84e89674fabe11d11271e21", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1157,6 +1157,27 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n+        ExprKind::InlineAsm(ref asm) => {\n+            for op in asm.operands {\n+                match op {\n+                    InlineAsmOperand::In { expr, .. }\n+                    | InlineAsmOperand::InOut { expr, .. }\n+                    | InlineAsmOperand::Const { expr, .. }\n+                    | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+                    InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            visitor.visit_expr(expr);\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        visitor.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            visitor.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         ExprKind::LlvmInlineAsm(ref asm) => {\n             walk_list!(visitor, visit_expr, asm.outputs_exprs);\n             walk_list!(visitor, visit_expr, asm.inputs_exprs);"}, {"sha": "8eb19cbb65a0aa3f786672f288d26a9b48ce4c5e", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1409,6 +1409,110 @@ impl<'a> State<'a> {\n                     self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n                 }\n             }\n+            hir::ExprKind::InlineAsm(ref a) => {\n+                enum AsmArg<'a> {\n+                    Template(String),\n+                    Operand(&'a hir::InlineAsmOperand<'a>),\n+                    Options(ast::InlineAsmOptions),\n+                }\n+\n+                let mut args = vec![];\n+                args.push(AsmArg::Template(ast::InlineAsmTemplatePiece::to_string(&a.template)));\n+                args.extend(a.operands.iter().map(|o| AsmArg::Operand(o)));\n+                if !a.options.is_empty() {\n+                    args.push(AsmArg::Options(a.options));\n+                }\n+\n+                self.word(\"asm!\");\n+                self.popen();\n+                self.commasep(Consistent, &args, |s, arg| match arg {\n+                    AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+                    AsmArg::Operand(op) => match op {\n+                        hir::InlineAsmOperand::In { reg, expr } => {\n+                            s.word(\"in\");\n+                            s.popen();\n+                            s.word(format!(\"{}\", reg));\n+                            s.pclose();\n+                            s.space();\n+                            s.print_expr(expr);\n+                        }\n+                        hir::InlineAsmOperand::Out { reg, late, expr } => {\n+                            s.word(if *late { \"lateout\" } else { \"out\" });\n+                            s.popen();\n+                            s.word(format!(\"{}\", reg));\n+                            s.pclose();\n+                            s.space();\n+                            match expr {\n+                                Some(expr) => s.print_expr(expr),\n+                                None => s.word(\"_\"),\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { reg, late, expr } => {\n+                            s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                            s.popen();\n+                            s.word(format!(\"{}\", reg));\n+                            s.pclose();\n+                            s.space();\n+                            s.print_expr(expr);\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                            s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                            s.popen();\n+                            s.word(format!(\"{}\", reg));\n+                            s.pclose();\n+                            s.space();\n+                            s.print_expr(in_expr);\n+                            s.space();\n+                            s.word_space(\"=>\");\n+                            match out_expr {\n+                                Some(out_expr) => s.print_expr(out_expr),\n+                                None => s.word(\"_\"),\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::Const { expr } => {\n+                            s.word(\"const\");\n+                            s.space();\n+                            s.print_expr(expr);\n+                        }\n+                        hir::InlineAsmOperand::Sym { expr } => {\n+                            s.word(\"sym\");\n+                            s.space();\n+                            s.print_expr(expr);\n+                        }\n+                    },\n+                    AsmArg::Options(opts) => {\n+                        s.word(\"options\");\n+                        s.popen();\n+                        let mut options = vec![];\n+                        if opts.contains(ast::InlineAsmOptions::PURE) {\n+                            options.push(\"pure\");\n+                        }\n+                        if opts.contains(ast::InlineAsmOptions::NOMEM) {\n+                            options.push(\"nomem\");\n+                        }\n+                        if opts.contains(ast::InlineAsmOptions::READONLY) {\n+                            options.push(\"readonly\");\n+                        }\n+                        if opts.contains(ast::InlineAsmOptions::PRESERVES_FLAGS) {\n+                            options.push(\"preserves_flags\");\n+                        }\n+                        if opts.contains(ast::InlineAsmOptions::NORETURN) {\n+                            options.push(\"noreturn\");\n+                        }\n+                        if opts.contains(ast::InlineAsmOptions::NOSTACK) {\n+                            options.push(\"nostack\");\n+                        }\n+                        if opts.contains(ast::InlineAsmOptions::ATT_SYNTAX) {\n+                            options.push(\"att_syntax\");\n+                        }\n+                        s.commasep(Inconsistent, &options, |s, &opt| {\n+                            s.word(opt);\n+                        });\n+                        s.pclose();\n+                    }\n+                });\n+                self.pclose();\n+            }\n             hir::ExprKind::LlvmInlineAsm(ref a) => {\n                 let i = &a.inner;\n                 self.s.word(\"llvm_asm!\");"}, {"sha": "5a76802014e0d18b8bb4d1a6d53355f76a15f914", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -42,12 +42,15 @@ use std::{panic, thread};\n /// features is available on the target machine, by querying LLVM.\n pub fn add_configuration(\n     cfg: &mut CrateConfig,\n-    sess: &Session,\n+    sess: &mut Session,\n     codegen_backend: &dyn CodegenBackend,\n ) {\n     let tf = sym::target_feature;\n \n-    cfg.extend(codegen_backend.target_features(sess).into_iter().map(|feat| (tf, Some(feat))));\n+    let target_features = codegen_backend.target_features(sess);\n+    sess.target_features.extend(target_features.iter().cloned());\n+\n+    cfg.extend(target_features.into_iter().map(|feat| (tf, Some(feat))));\n \n     if sess.crt_static(None) {\n         cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n@@ -75,7 +78,7 @@ pub fn create_session(\n     let codegen_backend = get_codegen_backend(&sess);\n \n     let mut cfg = config::build_configuration(&sess, config::to_crate_config(cfg));\n-    add_configuration(&mut cfg, &sess, &*codegen_backend);\n+    add_configuration(&mut cfg, &mut sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;\n \n     (Lrc::new(sess), Lrc::new(codegen_backend), source_map)"}, {"sha": "8247338ae0fadc1fbdf6d27d4f800f354745c288", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 105, "deletions": 8, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -19,6 +19,7 @@ use rustc_target::abi::VariantIdx;\n \n use polonius_engine::Atom;\n pub use rustc_ast::ast::Mutability;\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n@@ -28,6 +29,7 @@ use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{Index, IndexMut};\n@@ -1178,6 +1180,23 @@ pub enum TerminatorKind<'tcx> {\n         /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n         unwind: Option<BasicBlock>,\n     },\n+\n+    /// Block ends with an inline assembly block. This is a terminator since\n+    /// inline assembly is allowed to diverge.\n+    InlineAsm {\n+        /// The template for the inline assembly, with placeholders.\n+        template: &'tcx [InlineAsmTemplatePiece],\n+\n+        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n+        operands: Vec<InlineAsmOperand<'tcx>>,\n+\n+        /// Miscellaneous options for the inline assembly.\n+        options: InlineAsmOptions,\n+\n+        /// Destination block after the inline assembly returns, unless it is\n+        /// diverging (InlineAsmOptions::NORETURN).\n+        destination: Option<BasicBlock>,\n+    },\n }\n \n /// Information about an assertion failure.\n@@ -1192,6 +1211,34 @@ pub enum AssertKind<O> {\n     ResumedAfterPanic(GeneratorKind),\n }\n \n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum InlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        value: Operand<'tcx>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        place: Option<Place<'tcx>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_value: Operand<'tcx>,\n+        out_place: Option<Place<'tcx>>,\n+    },\n+    Const {\n+        value: Operand<'tcx>,\n+    },\n+    SymFn {\n+        value: Box<Constant<'tcx>>,\n+    },\n+    SymStatic {\n+        value: Box<Constant<'tcx>>,\n+    },\n+}\n+\n /// Type for MIR `Assert` terminator error messages.\n pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n \n@@ -1242,15 +1289,17 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | GeneratorDrop\n             | Return\n             | Unreachable\n-            | Call { destination: None, cleanup: None, .. } => None.into_iter().chain(&[]),\n+            | Call { destination: None, cleanup: None, .. }\n+            | InlineAsm { destination: None, .. } => None.into_iter().chain(&[]),\n             Goto { target: ref t }\n             | Call { destination: None, cleanup: Some(ref t), .. }\n             | Call { destination: Some((_, ref t)), cleanup: None, .. }\n             | Yield { resume: ref t, drop: None, .. }\n             | DropAndReplace { target: ref t, unwind: None, .. }\n             | Drop { target: ref t, unwind: None, .. }\n             | Assert { target: ref t, cleanup: None, .. }\n-            | FalseUnwind { real_target: ref t, unwind: None } => Some(t).into_iter().chain(&[]),\n+            | FalseUnwind { real_target: ref t, unwind: None }\n+            | InlineAsm { destination: Some(ref t), .. } => Some(t).into_iter().chain(&[]),\n             Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. }\n             | Yield { resume: ref t, drop: Some(ref u), .. }\n             | DropAndReplace { target: ref t, unwind: Some(ref u), .. }\n@@ -1274,17 +1323,17 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | GeneratorDrop\n             | Return\n             | Unreachable\n-            | Call { destination: None, cleanup: None, .. } => None.into_iter().chain(&mut []),\n+            | Call { destination: None, cleanup: None, .. }\n+            | InlineAsm { destination: None, .. } => None.into_iter().chain(&mut []),\n             Goto { target: ref mut t }\n             | Call { destination: None, cleanup: Some(ref mut t), .. }\n             | Call { destination: Some((_, ref mut t)), cleanup: None, .. }\n             | Yield { resume: ref mut t, drop: None, .. }\n             | DropAndReplace { target: ref mut t, unwind: None, .. }\n             | Drop { target: ref mut t, unwind: None, .. }\n             | Assert { target: ref mut t, cleanup: None, .. }\n-            | FalseUnwind { real_target: ref mut t, unwind: None } => {\n-                Some(t).into_iter().chain(&mut [])\n-            }\n+            | FalseUnwind { real_target: ref mut t, unwind: None }\n+            | InlineAsm { destination: Some(ref mut t), .. } => Some(t).into_iter().chain(&mut []),\n             Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. }\n             | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n             | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n@@ -1310,7 +1359,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdges { .. } => None,\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::InlineAsm { .. } => None,\n             TerminatorKind::Call { cleanup: ref unwind, .. }\n             | TerminatorKind::Assert { cleanup: ref unwind, .. }\n             | TerminatorKind::DropAndReplace { ref unwind, .. }\n@@ -1329,7 +1379,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::FalseEdges { .. } => None,\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::InlineAsm { .. } => None,\n             TerminatorKind::Call { cleanup: ref mut unwind, .. }\n             | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n             | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n@@ -1544,6 +1595,50 @@ impl<'tcx> TerminatorKind<'tcx> {\n             }\n             FalseEdges { .. } => write!(fmt, \"falseEdges\"),\n             FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n+            InlineAsm { template, ref operands, options, destination: _ } => {\n+                write!(fmt, \"asm!(\\\"{}\\\"\", InlineAsmTemplatePiece::to_string(template))?;\n+                for op in operands {\n+                    write!(fmt, \", \")?;\n+                    let print_late = |&late| if late { \"late\" } else { \"\" };\n+                    match op {\n+                        InlineAsmOperand::In { reg, value } => {\n+                            write!(fmt, \"in({}) {:?}\", reg, value)?;\n+                        }\n+                        InlineAsmOperand::Out { reg, late, place: Some(place) } => {\n+                            write!(fmt, \"{}out({}) {:?}\", print_late(late), reg, place)?;\n+                        }\n+                        InlineAsmOperand::Out { reg, late, place: None } => {\n+                            write!(fmt, \"{}out({}) _\", print_late(late), reg)?;\n+                        }\n+                        InlineAsmOperand::InOut {\n+                            reg,\n+                            late,\n+                            in_value,\n+                            out_place: Some(out_place),\n+                        } => {\n+                            write!(\n+                                fmt,\n+                                \"in{}out({}) {:?} => {:?}\",\n+                                print_late(late),\n+                                reg,\n+                                in_value,\n+                                out_place\n+                            )?;\n+                        }\n+                        InlineAsmOperand::InOut { reg, late, in_value, out_place: None } => {\n+                            write!(fmt, \"in{}out({}) {:?} => _\", print_late(late), reg, in_value)?;\n+                        }\n+                        InlineAsmOperand::Const { value } => {\n+                            write!(fmt, \"const {:?}\", value)?;\n+                        }\n+                        InlineAsmOperand::SymFn { value }\n+                        | InlineAsmOperand::SymStatic { value } => {\n+                            write!(fmt, \"sym {:?}\", value)?;\n+                        }\n+                    }\n+                }\n+                write!(fmt, \", options({:?}))\", options)\n+            }\n         }\n     }\n \n@@ -1586,6 +1681,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             FalseEdges { .. } => vec![\"real\".into(), \"imaginary\".into()],\n             FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n             FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n+            InlineAsm { destination: Some(_), .. } => vec![\"\".into()],\n+            InlineAsm { destination: None, .. } => vec![],\n         }\n     }\n }"}, {"sha": "bb7001c1207bf51dfd50872053dcca7d047e1568", "filename": "src/librustc_middle/mir/type_foldable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -78,6 +78,9 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 FalseEdges { real_target, imaginary_target }\n             }\n             FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n+            InlineAsm { template, ref operands, options, destination } => {\n+                InlineAsm { template, operands: operands.fold_with(folder), options, destination }\n+            }\n         };\n         Terminator { source_info: self.source_info, kind }\n     }\n@@ -120,6 +123,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     false\n                 }\n             }\n+            InlineAsm { ref operands, .. } => operands.visit_with(visitor),\n             Goto { .. }\n             | Resume\n             | Abort"}, {"sha": "02164244771c9ad92ddef6662d23f0d344d53596", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -531,6 +531,44 @@ macro_rules! make_mir_visitor {\n                         );\n                     }\n \n+                    TerminatorKind::InlineAsm {\n+                        template: _,\n+                        operands,\n+                        options: _,\n+                        destination: _,\n+                    } => {\n+                        for op in operands {\n+                            match op {\n+                                InlineAsmOperand::In { value, .. }\n+                                | InlineAsmOperand::Const { value } => {\n+                                    self.visit_operand(value, source_location);\n+                                }\n+                                InlineAsmOperand::Out { place, .. } => {\n+                                    if let Some(place) = place {\n+                                        self.visit_place(\n+                                            place,\n+                                            PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                                            source_location,\n+                                        );\n+                                    }\n+                                }\n+                                InlineAsmOperand::InOut { in_value, out_place, .. } => {\n+                                    self.visit_operand(in_value, source_location);\n+                                    if let Some(out_place) = out_place {\n+                                        self.visit_place(\n+                                            out_place,\n+                                            PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                                            source_location,\n+                                        );\n+                                    }\n+                                }\n+                                InlineAsmOperand::SymFn { value }\n+                                | InlineAsmOperand::SymStatic { value } => {\n+                                    self.visit_constant(value, source_location);\n+                                }\n+                            }\n+                        }\n+                    }\n                 }\n             }\n "}, {"sha": "adbeac29bdd75d785557cac3d0c6641a49df5928", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -180,6 +180,8 @@ pub enum ObligationCauseCode<'tcx> {\n     SizedReturnType,\n     /// Yield type must be `Sized`.\n     SizedYieldType,\n+    /// Inline asm operand type must be `Sized`.\n+    InlineAsmSized,\n     /// `[T, ..n]` implies that `T` must be `Copy`.\n     /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n     RepeatVec(bool),"}, {"sha": "56744283b0c4743abe0eef995f0866bc4d53c0ab", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -152,6 +152,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::SizedArgumentType => Some(super::SizedArgumentType),\n             super::SizedReturnType => Some(super::SizedReturnType),\n             super::SizedYieldType => Some(super::SizedYieldType),\n+            super::InlineAsmSized => Some(super::InlineAsmSized),\n             super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n             super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n             super::ConstSized => Some(super::ConstSized),"}, {"sha": "c23a351ac515ca71c0125c48ac98b9ebcc793bca", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -260,6 +260,8 @@ CloneTypeFoldableAndLiftImpls! {\n     String,\n     crate::middle::region::Scope,\n     ::rustc_ast::ast::FloatTy,\n+    ::rustc_ast::ast::InlineAsmOptions,\n+    ::rustc_ast::ast::InlineAsmTemplatePiece,\n     ::rustc_ast::ast::NodeId,\n     ::rustc_span::symbol::Symbol,\n     ::rustc_hir::def::Res,\n@@ -268,6 +270,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::rustc_hir::MatchSource,\n     ::rustc_hir::Mutability,\n     ::rustc_hir::Unsafety,\n+    ::rustc_target::asm::InlineAsmRegOrRegClass,\n     ::rustc_target::spec::abi::Abi,\n     crate::mir::Local,\n     crate::mir::Promoted,"}, {"sha": "178e3db17cd32cda18259a01b04e12cdafdea475", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n-use rustc_middle::mir::TerminatorKind;\n use rustc_middle::mir::{BasicBlock, Body, Location, Place, Rvalue};\n use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n+use rustc_middle::mir::{InlineAsmOperand, TerminatorKind};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n \n@@ -183,6 +183,29 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     }\n                 }\n             }\n+            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+                for op in operands {\n+                    match *op {\n+                        InlineAsmOperand::In { reg: _, ref value }\n+                        | InlineAsmOperand::Const { ref value } => {\n+                            self.consume_operand(location, value);\n+                        }\n+                        InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n+                            if let Some(place) = place {\n+                                self.mutate_place(location, place, Shallow(None), JustWrite);\n+                            }\n+                        }\n+                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                            self.consume_operand(location, in_value);\n+                            if let Some(out_place) = out_place {\n+                                self.mutate_place(location, out_place, Shallow(None), JustWrite);\n+                            }\n+                        }\n+                        InlineAsmOperand::SymFn { value: _ }\n+                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                    }\n+                }\n+            }\n             TerminatorKind::Goto { target: _ }\n             | TerminatorKind::Abort\n             | TerminatorKind::Unreachable"}, {"sha": "a0c1d96bb4743fc2a63ce57f32a4fcde8c509a3f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n-use rustc_middle::mir::{Terminator, TerminatorKind};\n+use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n@@ -724,6 +724,42 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n \n+            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+                for op in operands {\n+                    match *op {\n+                        InlineAsmOperand::In { reg: _, ref value }\n+                        | InlineAsmOperand::Const { ref value } => {\n+                            self.consume_operand(loc, (value, span), flow_state);\n+                        }\n+                        InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n+                            if let Some(place) = place {\n+                                self.mutate_place(\n+                                    loc,\n+                                    (place, span),\n+                                    Shallow(None),\n+                                    JustWrite,\n+                                    flow_state,\n+                                );\n+                            }\n+                        }\n+                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                            self.consume_operand(loc, (in_value, span), flow_state);\n+                            if let Some(out_place) = out_place {\n+                                self.mutate_place(\n+                                    loc,\n+                                    (out_place, span),\n+                                    Shallow(None),\n+                                    JustWrite,\n+                                    flow_state,\n+                                );\n+                            }\n+                        }\n+                        InlineAsmOperand::SymFn { value: _ }\n+                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                    }\n+                }\n+            }\n+\n             TerminatorKind::Goto { target: _ }\n             | TerminatorKind::Abort\n             | TerminatorKind::Unreachable\n@@ -778,7 +814,8 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             | TerminatorKind::FalseUnwind { real_target: _, unwind: _ }\n             | TerminatorKind::Goto { .. }\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Unreachable => {}\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::InlineAsm { .. } => {}\n         }\n     }\n }"}, {"sha": "08aa4340107106d33d66bea8cac95dd94d54d04c", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1548,7 +1548,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. } => {\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::InlineAsm { .. } => {\n                 // no checks needed for these\n             }\n \n@@ -1855,6 +1856,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     self.assert_iscleanup(body, block_data, unwind, true);\n                 }\n             }\n+            TerminatorKind::InlineAsm { ref destination, .. } => {\n+                if let &Some(target) = destination {\n+                    self.assert_iscleanup(body, block_data, target, is_cleanup);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "97b14ea771b2fc0fdf4042bd606d489510876a20", "filename": "src/librustc_mir/dataflow/framework/direction.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -482,6 +482,12 @@ impl Direction for Forward {\n                 }\n             }\n \n+            InlineAsm { template: _, operands: _, options: _, destination } => {\n+                if let Some(target) = destination {\n+                    propagate(target, exit_state);\n+                }\n+            }\n+\n             SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n                 let enum_ = discr\n                     .place()"}, {"sha": "f929b2ddde0bad4b7c9b3d82f2386da7d20bb53b", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -203,6 +203,7 @@ where\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Goto { .. }\n+            | TerminatorKind::InlineAsm { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Return\n             | TerminatorKind::SwitchInt { .. }"}, {"sha": "dfca270396de923368a79c6c2c57e25c581fbd36", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -317,10 +317,19 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n \n     fn terminator_effect(\n         &self,\n-        _: &mut impl GenKill<Self::Idx>,\n-        _: &mir::Terminator<'tcx>,\n-        _: Location,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        teminator: &mir::Terminator<'tcx>,\n+        _location: Location,\n     ) {\n+        if let mir::TerminatorKind::InlineAsm { operands, .. } = &teminator.kind {\n+            for op in operands {\n+                if let mir::InlineAsmOperand::Out { place: Some(place), .. }\n+                | mir::InlineAsmOperand::InOut { out_place: Some(place), .. } = *op\n+                {\n+                    self.kill_borrows_on_place(trans, place);\n+                }\n+            }\n+        }\n     }\n \n     fn call_return_effect("}, {"sha": "bbc4942030ef796902ca3f31789052de634ea919", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -183,6 +183,23 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n             // place to have storage *before* the yield, only after.\n             TerminatorKind::Yield { .. } => {}\n \n+            TerminatorKind::InlineAsm { operands, .. } => {\n+                for op in operands {\n+                    match op {\n+                        InlineAsmOperand::Out { place, .. }\n+                        | InlineAsmOperand::InOut { out_place: place, .. } => {\n+                            if let Some(place) = place {\n+                                trans.gen(place.local);\n+                            }\n+                        }\n+                        InlineAsmOperand::In { .. }\n+                        | InlineAsmOperand::Const { .. }\n+                        | InlineAsmOperand::SymFn { .. }\n+                        | InlineAsmOperand::SymStatic { .. } => {}\n+                    }\n+                }\n+            }\n+\n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added.\n             TerminatorKind::Call { destination: None, .. }\n@@ -228,6 +245,7 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Goto { .. }\n+            | TerminatorKind::InlineAsm { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Return\n             | TerminatorKind::SwitchInt { .. }"}, {"sha": "0f2760b3f3b4ed4dac6e3edebf78fa9ef221555a", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -411,6 +411,31 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     self.gather_init(destination.as_ref(), InitKind::NonPanicPathOnly);\n                 }\n             }\n+            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+                for op in operands {\n+                    match *op {\n+                        InlineAsmOperand::In { reg: _, ref value }\n+                        | InlineAsmOperand::Const { ref value } => {\n+                            self.gather_operand(value);\n+                        }\n+                        InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n+                            if let Some(place) = place {\n+                                self.create_move_path(place);\n+                                self.gather_init(place.as_ref(), InitKind::Deep);\n+                            }\n+                        }\n+                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                            self.gather_operand(in_value);\n+                            if let Some(out_place) = out_place {\n+                                self.create_move_path(out_place);\n+                                self.gather_init(out_place.as_ref(), InitKind::Deep);\n+                            }\n+                        }\n+                        InlineAsmOperand::SymFn { value: _ }\n+                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "b048240ca8dc12ef881b8652a69aef22045979f0", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -131,6 +131,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 \"{:#?} should have been eliminated by MIR pass\",\n                 terminator.kind\n             ),\n+\n+            // Inline assembly can't be interpreted.\n+            InlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n         }\n \n         Ok(())"}, {"sha": "925b8d329668f4649b83ca01a9f54838de932b9f", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -639,7 +639,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             | mir::TerminatorKind::Abort\n             | mir::TerminatorKind::Return\n             | mir::TerminatorKind::Unreachable\n-            | mir::TerminatorKind::Assert { .. } => {}\n+            | mir::TerminatorKind::Assert { .. }\n+            | mir::TerminatorKind::InlineAsm { .. } => {}\n             mir::TerminatorKind::GeneratorDrop\n             | mir::TerminatorKind::Yield { .. }\n             | mir::TerminatorKind::FalseEdges { .. }"}, {"sha": "987c9e24fc3c33044c720b0abc4fa5522644dd49", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -603,6 +603,10 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 }\n             }\n \n+            TerminatorKind::InlineAsm { .. } => {\n+                self.check_op(ops::InlineAsm);\n+            }\n+\n             // FIXME: Some of these are only caught by `min_const_fn`, but should error here\n             // instead.\n             TerminatorKind::Abort"}, {"sha": "9bcb45f6493d16e07df611f4414c3675b50b6725", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -95,6 +95,12 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     self.check_target_features(func_id);\n                 }\n             }\n+\n+            TerminatorKind::InlineAsm { .. } => self.require_unsafe(\n+                \"use of inline assembly\",\n+                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n+                UnsafetyViolationKind::General,\n+            ),\n         }\n         self.super_terminator(terminator, location);\n     }"}, {"sha": "f69343f4d7500855002e47ee842ef4c5543f0c96", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1014,7 +1014,8 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. } => {}\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::InlineAsm { .. } => {}\n             // Every argument in our function calls can be const propagated.\n             TerminatorKind::Call { ref mut args, .. } => {\n                 let mir_opt_level = self.tcx.sess.opts.debugging_opts.mir_opt_level;"}, {"sha": "4bf2adcd450c0b75a0b92d0537c138ca5d93cd07", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -981,7 +981,8 @@ fn can_unwind<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n             | TerminatorKind::Unreachable\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. } => {}\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::InlineAsm { .. } => {}\n \n             // Resume will *continue* unwinding, but if there's no other unwinding terminator it\n             // will never be reached."}, {"sha": "35d55c4cb9b6d53c776466c91bb15a22d22bcd08", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -800,6 +800,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             {\n                 bug!(\"False unwinds should have been removed before inlining\")\n             }\n+            TerminatorKind::InlineAsm { ref mut destination, .. } => {\n+                if let Some(ref mut tgt) = *destination {\n+                    *tgt = self.update_target(*tgt);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "13a8b9a1000c957523c1bd11a8991a566cd775f7", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -113,14 +113,17 @@ pub enum Candidate {\n     /// the attribute currently provides the semantic requirement that arguments\n     /// must be constant.\n     Argument { bb: BasicBlock, index: usize },\n+\n+    /// `const` operand in asm!.\n+    InlineAsm { bb: BasicBlock, index: usize },\n }\n \n impl Candidate {\n     /// Returns `true` if we should use the \"explicit\" rules for promotability for this `Candidate`.\n     fn forces_explicit_promotion(&self) -> bool {\n         match self {\n             Candidate::Ref(_) | Candidate::Repeat(_) => false,\n-            Candidate::Argument { .. } => true,\n+            Candidate::Argument { .. } | Candidate::InlineAsm { .. } => true,\n         }\n     }\n }\n@@ -216,25 +219,39 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n     fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n         self.super_terminator_kind(kind, location);\n \n-        if let TerminatorKind::Call { ref func, .. } = *kind {\n-            if let ty::FnDef(def_id, _) = func.ty(self.ccx.body, self.ccx.tcx).kind {\n-                let fn_sig = self.ccx.tcx.fn_sig(def_id);\n-                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n-                    let name = self.ccx.tcx.item_name(def_id);\n-                    // FIXME(eddyb) use `#[rustc_args_required_const(2)]` for shuffles.\n-                    if name.as_str().starts_with(\"simd_shuffle\") {\n-                        self.candidates.push(Candidate::Argument { bb: location.block, index: 2 });\n+        match *kind {\n+            TerminatorKind::Call { ref func, .. } => {\n+                if let ty::FnDef(def_id, _) = func.ty(self.ccx.body, self.ccx.tcx).kind {\n+                    let fn_sig = self.ccx.tcx.fn_sig(def_id);\n+                    if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n+                        let name = self.ccx.tcx.item_name(def_id);\n+                        // FIXME(eddyb) use `#[rustc_args_required_const(2)]` for shuffles.\n+                        if name.as_str().starts_with(\"simd_shuffle\") {\n+                            self.candidates\n+                                .push(Candidate::Argument { bb: location.block, index: 2 });\n+\n+                            return; // Don't double count `simd_shuffle` candidates\n+                        }\n+                    }\n \n-                        return; // Don't double count `simd_shuffle` candidates\n+                    if let Some(constant_args) = args_required_const(self.ccx.tcx, def_id) {\n+                        for index in constant_args {\n+                            self.candidates.push(Candidate::Argument { bb: location.block, index });\n+                        }\n                     }\n                 }\n-\n-                if let Some(constant_args) = args_required_const(self.ccx.tcx, def_id) {\n-                    for index in constant_args {\n-                        self.candidates.push(Candidate::Argument { bb: location.block, index });\n+            }\n+            TerminatorKind::InlineAsm { ref operands, .. } => {\n+                for (index, op) in operands.iter().enumerate() {\n+                    match op {\n+                        InlineAsmOperand::Const { .. } => {\n+                            self.candidates.push(Candidate::InlineAsm { bb: location.block, index })\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }\n+            _ => {}\n         }\n     }\n \n@@ -402,6 +419,18 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     _ => bug!(),\n                 }\n             }\n+            Candidate::InlineAsm { bb, index } => {\n+                assert!(self.explicit);\n+\n+                let terminator = self.body[bb].terminator();\n+                match &terminator.kind {\n+                    TerminatorKind::InlineAsm { operands, .. } => match &operands[index] {\n+                        InlineAsmOperand::Const { value } => self.validate_operand(value),\n+                        _ => bug!(),\n+                    },\n+                    _ => bug!(),\n+                }\n+            }\n         }\n     }\n \n@@ -747,7 +776,9 @@ pub fn validate_candidates(\n             }\n \n             match candidate {\n-                Candidate::Argument { bb, index } if !is_promotable => {\n+                Candidate::Argument { bb, index } | Candidate::InlineAsm { bb, index }\n+                    if !is_promotable =>\n+                {\n                     let span = ccx.body[bb].terminator().source_info.span;\n                     let msg = format!(\"argument {} is required to be a constant\", index + 1);\n                     ccx.tcx.sess.span_err(span, &msg);\n@@ -1024,6 +1055,24 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         _ => bug!(),\n                     }\n                 }\n+                Candidate::InlineAsm { bb, index } => {\n+                    let terminator = blocks[bb].terminator_mut();\n+                    match terminator.kind {\n+                        TerminatorKind::InlineAsm { ref mut operands, .. } => {\n+                            match &mut operands[index] {\n+                                InlineAsmOperand::Const { ref mut value } => {\n+                                    let ty = value.ty(local_decls, self.tcx);\n+                                    let span = terminator.source_info.span;\n+\n+                                    Rvalue::Use(mem::replace(value, promoted_operand(ty, span)))\n+                                }\n+                                _ => bug!(),\n+                            }\n+                        }\n+\n+                        _ => bug!(),\n+                    }\n+                }\n             }\n         };\n \n@@ -1080,7 +1129,7 @@ pub fn promote_candidates<'tcx>(\n                     }\n                 }\n             }\n-            Candidate::Argument { .. } => {}\n+            Candidate::Argument { .. } | Candidate::InlineAsm { .. } => {}\n         }\n \n         // Declare return place local so that `mir::Body::new` doesn't complain."}, {"sha": "0750284889391acf3e96a1d2ef9cffb15da6ea25", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -392,5 +392,9 @@ fn check_terminator(\n         TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n             check_operand(tcx, cond, span, def_id, body)\n         }\n+\n+        TerminatorKind::InlineAsm { .. } => {\n+            Err((span, \"cannot use inline assembly in const fn\".into()))\n+        }\n     }\n }"}, {"sha": "69c0163b649d6ef90d25dca2a17a1d4947f5dcd7", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -77,7 +77,8 @@ impl RemoveNoopLandingPads {\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::DropAndReplace { .. }\n-            | TerminatorKind::Drop { .. } => false,\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::InlineAsm { .. } => false,\n         }\n     }\n "}, {"sha": "16bba6ad14780812baded5515a63faec94f9d861", "filename": "src/librustc_mir_build/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -255,6 +255,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Return { .. }\n             | ExprKind::Literal { .. }\n             | ExprKind::StaticRef { .. }\n+            | ExprKind::InlineAsm { .. }\n             | ExprKind::LlvmInlineAsm { .. }\n             | ExprKind::Yield { .. }\n             | ExprKind::Call { .. } => {"}, {"sha": "0f15190975087c09b6155df5043ded62c4d0a208", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -252,6 +252,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Break { .. }\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n+            | ExprKind::InlineAsm { .. }\n             | ExprKind::LlvmInlineAsm { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {"}, {"sha": "59d3003c9f49a04c7c7368fceb621dbb0321efe3", "filename": "src/librustc_mir_build/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -51,7 +51,8 @@ impl Category {\n             | ExprKind::Borrow { .. }\n             | ExprKind::AddressOf { .. }\n             | ExprKind::Yield { .. }\n-            | ExprKind::Call { .. } => Some(Category::Rvalue(RvalueFunc::Into)),\n+            | ExprKind::Call { .. }\n+            | ExprKind::InlineAsm { .. } => Some(Category::Rvalue(RvalueFunc::Into)),\n \n             ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }"}, {"sha": "ff3c7ee3ee8237ecac444b35df6e0289a9da066a", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -3,6 +3,7 @@\n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n+use rustc_ast::ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::mir::*;\n@@ -53,7 +54,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::NeverToAny { source } => {\n                 let source = this.hir.mirror(source);\n                 let is_call = match source.kind {\n-                    ExprKind::Call { .. } => true,\n+                    ExprKind::Call { .. } | ExprKind::InlineAsm { .. } => true,\n                     _ => false,\n                 };\n \n@@ -309,6 +310,73 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n                 block.unit()\n             }\n+            ExprKind::InlineAsm { template, operands, options } => {\n+                use crate::hair;\n+                use rustc_middle::mir;\n+                let operands = operands\n+                    .into_iter()\n+                    .map(|op| match op {\n+                        hair::InlineAsmOperand::In { reg, expr } => mir::InlineAsmOperand::In {\n+                            reg,\n+                            value: unpack!(block = this.as_local_operand(block, expr)),\n+                        },\n+                        hair::InlineAsmOperand::Out { reg, late, expr } => {\n+                            mir::InlineAsmOperand::Out {\n+                                reg,\n+                                late,\n+                                place: expr.map(|expr| unpack!(block = this.as_place(block, expr))),\n+                            }\n+                        }\n+                        hair::InlineAsmOperand::InOut { reg, late, expr } => {\n+                            let place = unpack!(block = this.as_place(block, expr));\n+                            mir::InlineAsmOperand::InOut {\n+                                reg,\n+                                late,\n+                                // This works because asm operands must be Copy\n+                                in_value: Operand::Copy(place),\n+                                out_place: Some(place),\n+                            }\n+                        }\n+                        hair::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                            mir::InlineAsmOperand::InOut {\n+                                reg,\n+                                late,\n+                                in_value: unpack!(block = this.as_local_operand(block, in_expr)),\n+                                out_place: out_expr.map(|out_expr| {\n+                                    unpack!(block = this.as_place(block, out_expr))\n+                                }),\n+                            }\n+                        }\n+                        hair::InlineAsmOperand::Const { expr } => mir::InlineAsmOperand::Const {\n+                            value: unpack!(block = this.as_local_operand(block, expr)),\n+                        },\n+                        hair::InlineAsmOperand::SymFn { expr } => {\n+                            mir::InlineAsmOperand::SymFn { value: box this.as_constant(expr) }\n+                        }\n+                        hair::InlineAsmOperand::SymStatic { expr } => {\n+                            mir::InlineAsmOperand::SymStatic { value: box this.as_constant(expr) }\n+                        }\n+                    })\n+                    .collect();\n+\n+                let destination = this.cfg.start_new_block();\n+\n+                this.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::InlineAsm {\n+                        template,\n+                        operands,\n+                        options,\n+                        destination: if options.contains(InlineAsmOptions::NORETURN) {\n+                            None\n+                        } else {\n+                            Some(destination)\n+                        },\n+                    },\n+                );\n+                destination.unit()\n+            }\n \n             // These cases don't actually need a destination\n             ExprKind::Assign { .. }"}, {"sha": "868fb69abe80c60e382c775b940d789bd0f1cb59", "filename": "src/librustc_mir_build/build/scope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1388,7 +1388,8 @@ impl<'tcx> DropTreeBuilder<'tcx> for Unwind {\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::FalseEdges { .. } => {\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::InlineAsm { .. } => {\n                 span_bug!(term.source_info.span, \"cannot unwind from {:?}\", term.kind)\n             }\n         }"}, {"sha": "99b59d16029ff73df3689d61dc7cbd85dc42020f", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -400,6 +400,121 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             convert_path_expr(cx, expr, res)\n         }\n \n+        hir::ExprKind::InlineAsm(ref asm) => ExprKind::InlineAsm {\n+            template: asm.template,\n+            operands: asm\n+                .operands\n+                .iter()\n+                .map(|op| {\n+                    match *op {\n+                        hir::InlineAsmOperand::In { reg, ref expr } => {\n+                            InlineAsmOperand::In { reg, expr: expr.to_ref() }\n+                        }\n+                        hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n+                            InlineAsmOperand::Out {\n+                                reg,\n+                                late,\n+                                expr: expr.as_ref().map(|expr| expr.to_ref()),\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                            InlineAsmOperand::InOut { reg, late, expr: expr.to_ref() }\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            reg,\n+                            late,\n+                            ref in_expr,\n+                            ref out_expr,\n+                        } => InlineAsmOperand::SplitInOut {\n+                            reg,\n+                            late,\n+                            in_expr: in_expr.to_ref(),\n+                            out_expr: out_expr.as_ref().map(|expr| expr.to_ref()),\n+                        },\n+                        hir::InlineAsmOperand::Const { ref expr } => {\n+                            InlineAsmOperand::Const { expr: expr.to_ref() }\n+                        }\n+                        hir::InlineAsmOperand::Sym { ref expr } => {\n+                            let qpath = match expr.kind {\n+                                hir::ExprKind::Path(ref qpath) => qpath,\n+                                _ => span_bug!(\n+                                    expr.span,\n+                                    \"asm `sym` operand should be a path, found {:?}\",\n+                                    expr.kind\n+                                ),\n+                            };\n+                            let temp_lifetime =\n+                                cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                            let res = cx.tables().qpath_res(qpath, expr.hir_id);\n+                            let ty;\n+                            match res {\n+                                Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n+                                    ty = cx.tables().node_type(expr.hir_id);\n+                                    let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n+                                    InlineAsmOperand::SymFn {\n+                                        expr: Expr {\n+                                            ty,\n+                                            temp_lifetime,\n+                                            span: expr.span,\n+                                            kind: ExprKind::Literal {\n+                                                literal: ty::Const::zero_sized(cx.tcx, ty),\n+                                                user_ty,\n+                                            },\n+                                        }\n+                                        .to_ref(),\n+                                    }\n+                                }\n+\n+                                Res::Def(DefKind::Static, id) => {\n+                                    ty = cx.tcx.static_ptr_ty(id);\n+                                    let ptr = cx.tcx.create_static_alloc(id);\n+                                    InlineAsmOperand::SymStatic {\n+                                        expr: Expr {\n+                                            ty,\n+                                            temp_lifetime,\n+                                            span: expr.span,\n+                                            kind: ExprKind::StaticRef {\n+                                                literal: ty::Const::from_scalar(\n+                                                    cx.tcx,\n+                                                    Scalar::Ptr(ptr.into()),\n+                                                    ty,\n+                                                ),\n+                                                def_id: id,\n+                                            },\n+                                        }\n+                                        .to_ref(),\n+                                    }\n+                                }\n+\n+                                _ => {\n+                                    cx.tcx.sess.span_err(\n+                                        expr.span,\n+                                        \"asm `sym` operand must point to a fn or static\",\n+                                    );\n+\n+                                    // Not a real fn, but we're not reaching codegen anyways...\n+                                    ty = cx.tcx.types.err;\n+                                    InlineAsmOperand::SymFn {\n+                                        expr: Expr {\n+                                            ty,\n+                                            temp_lifetime,\n+                                            span: expr.span,\n+                                            kind: ExprKind::Literal {\n+                                                literal: ty::Const::zero_sized(cx.tcx, ty),\n+                                                user_ty: None,\n+                                            },\n+                                        }\n+                                        .to_ref(),\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect(),\n+            options: asm.options,\n+        },\n+\n         hir::ExprKind::LlvmInlineAsm(ref asm) => ExprKind::LlvmInlineAsm {\n             asm: &asm.inner,\n             outputs: asm.outputs_exprs.to_ref(),"}, {"sha": "aba7a7a1b420c730e4b81466a6d99593f206face", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -5,6 +5,7 @@\n //! structures.\n \n use self::cx::Cx;\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::infer::canonical::Canonical;\n@@ -15,6 +16,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{AdtDef, Const, Ty, UpvarSubsts, UserType};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n+use rustc_target::asm::InlineAsmRegOrRegClass;\n \n crate mod constant;\n crate mod cx;\n@@ -277,6 +279,11 @@ crate enum ExprKind<'tcx> {\n         literal: &'tcx Const<'tcx>,\n         def_id: DefId,\n     },\n+    InlineAsm {\n+        template: &'tcx [InlineAsmTemplatePiece],\n+        operands: Vec<InlineAsmOperand<'tcx>>,\n+        options: InlineAsmOptions,\n+    },\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,\n         outputs: Vec<ExprRef<'tcx>>,\n@@ -335,6 +342,39 @@ impl<'tcx> ExprRef<'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+crate enum InlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        expr: ExprRef<'tcx>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: Option<ExprRef<'tcx>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: ExprRef<'tcx>,\n+    },\n+    SplitInOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_expr: ExprRef<'tcx>,\n+        out_expr: Option<ExprRef<'tcx>>,\n+    },\n+    Const {\n+        expr: ExprRef<'tcx>,\n+    },\n+    SymFn {\n+        expr: ExprRef<'tcx>,\n+    },\n+    SymStatic {\n+        expr: ExprRef<'tcx>,\n+    },\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Mirror trait\n "}, {"sha": "dbafc98fb50f1633809557d5721d1b67680779eb", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -114,6 +114,15 @@ impl<'mir, 'tcx> TriColorVisitor<&'mir Body<'tcx>> for Search<'mir, 'tcx> {\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Yield { .. } => ControlFlow::Break(NonRecursive),\n \n+            // A diverging InlineAsm is treated as non-recursing\n+            TerminatorKind::InlineAsm { destination, .. } => {\n+                if destination.is_some() {\n+                    ControlFlow::Continue\n+                } else {\n+                    ControlFlow::Break(NonRecursive)\n+                }\n+            }\n+\n             // These do not.\n             TerminatorKind::Assert { .. }\n             | TerminatorKind::Call { .. }"}, {"sha": "93344e907c344a507d9468274b3f72bb1dea9b25", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 285, "deletions": 13, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::ast::{FloatTy, InlineAsmTemplatePiece, IntTy, UintTy};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -7,8 +8,10 @@ use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::{sym, Span};\n+use rustc_session::lint;\n+use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Pointer, VariantIdx};\n+use rustc_target::asm::{InlineAsmRegOrRegClass, InlineAsmType};\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: DefId) {\n@@ -119,6 +122,271 @@ impl ExprVisitor<'tcx> {\n         }\n         err.emit()\n     }\n+\n+    fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n+        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+            return true;\n+        }\n+        if let ty::Foreign(..) = ty.kind {\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn check_asm_operand_type(\n+        &self,\n+        idx: usize,\n+        reg: InlineAsmRegOrRegClass,\n+        expr: &hir::Expr<'tcx>,\n+        template: &[InlineAsmTemplatePiece],\n+        tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n+    ) -> Option<InlineAsmType> {\n+        // Check the type against the allowed types for inline asm.\n+        let ty = self.tables.expr_ty_adjusted(expr);\n+        let asm_ty_isize = match self.tcx.sess.target.ptr_width {\n+            16 => InlineAsmType::I16,\n+            32 => InlineAsmType::I32,\n+            64 => InlineAsmType::I64,\n+            _ => unreachable!(),\n+        };\n+        let asm_ty = match ty.kind {\n+            ty::Never | ty::Error => return None,\n+            ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => Some(InlineAsmType::I8),\n+            ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => Some(InlineAsmType::I16),\n+            ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => Some(InlineAsmType::I32),\n+            ty::Int(IntTy::I64) | ty::Uint(UintTy::U64) => Some(InlineAsmType::I64),\n+            ty::Int(IntTy::I128) | ty::Uint(UintTy::U128) => Some(InlineAsmType::I128),\n+            ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => Some(asm_ty_isize),\n+            ty::Float(FloatTy::F32) => Some(InlineAsmType::F32),\n+            ty::Float(FloatTy::F64) => Some(InlineAsmType::F64),\n+            ty::FnPtr(_) => Some(asm_ty_isize),\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if self.is_thin_ptr_ty(ty) => {\n+                Some(asm_ty_isize)\n+            }\n+            ty::Adt(adt, substs) if adt.repr.simd() => {\n+                let fields = &adt.non_enum_variant().fields;\n+                let elem_ty = fields[0].ty(self.tcx, substs);\n+                match elem_ty.kind {\n+                    ty::Never | ty::Error => return None,\n+                    ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => {\n+                        Some(InlineAsmType::VecI8(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => {\n+                        Some(InlineAsmType::VecI16(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => {\n+                        Some(InlineAsmType::VecI32(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I64) | ty::Uint(UintTy::U64) => {\n+                        Some(InlineAsmType::VecI64(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I128) | ty::Uint(UintTy::U128) => {\n+                        Some(InlineAsmType::VecI128(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => {\n+                        Some(match self.tcx.sess.target.ptr_width {\n+                            16 => InlineAsmType::VecI16(fields.len() as u64),\n+                            32 => InlineAsmType::VecI32(fields.len() as u64),\n+                            64 => InlineAsmType::VecI64(fields.len() as u64),\n+                            _ => unreachable!(),\n+                        })\n+                    }\n+                    ty::Float(FloatTy::F32) => Some(InlineAsmType::VecF32(fields.len() as u64)),\n+                    ty::Float(FloatTy::F64) => Some(InlineAsmType::VecF64(fields.len() as u64)),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        };\n+        let asm_ty = match asm_ty {\n+            Some(asm_ty) => asm_ty,\n+            None => {\n+                let msg = &format!(\"cannot use value of type `{}` for inline assembly\", ty);\n+                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+                err.note(\n+                    \"only integers, floats, SIMD vectors, pointers and function pointers \\\n+                     can be used as arguments for inline assembly\",\n+                );\n+                err.emit();\n+                return None;\n+            }\n+        };\n+\n+        // Check that the type implements Copy. The only case where this can\n+        // possibly fail is for SIMD types which don't #[derive(Copy)].\n+        if !ty.is_copy_modulo_regions(self.tcx, self.param_env, DUMMY_SP) {\n+            let msg = \"arguments for inline assembly must be copyable\";\n+            let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+            err.note(&format!(\"`{}` does not implement the Copy trait\", ty));\n+            err.emit();\n+        }\n+\n+        // Ideally we wouldn't need to do this, but LLVM's register allocator\n+        // really doesn't like it when tied operands have different types.\n+        //\n+        // This is purely an LLVM limitation, but we have to live with it since\n+        // there is no way to hide this with implicit conversions.\n+        //\n+        // For the purposes of this check we only look at the `InlineAsmType`,\n+        // which means that pointers and integers are treated as identical (modulo\n+        // size).\n+        if let Some((in_expr, Some(in_asm_ty))) = tied_input {\n+            if in_asm_ty != asm_ty {\n+                let msg = &format!(\"incompatible types for asm inout argument\");\n+                let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n+                err.span_label(\n+                    in_expr.span,\n+                    &format!(\"type `{}`\", self.tables.expr_ty_adjusted(in_expr)),\n+                );\n+                err.span_label(expr.span, &format!(\"type `{}`\", ty));\n+                err.note(\n+                    \"asm inout arguments must have the same type, \\\n+                    unless they are both pointers or integers of the same size\",\n+                );\n+                err.emit();\n+            }\n+\n+            // All of the later checks have already been done on the input, so\n+            // let's not emit errors and warnings twice.\n+            return Some(asm_ty);\n+        }\n+\n+        // Check the type against the list of types supported by the selected\n+        // register class.\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+        let reg_class = reg.reg_class();\n+        let supported_tys = reg_class.supported_types(asm_arch);\n+        let feature = match supported_tys.iter().find(|&&(t, _)| t == asm_ty) {\n+            Some((_, feature)) => feature,\n+            None => {\n+                let msg = &format!(\"type `{}` cannot be used with this register class\", ty);\n+                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+                let supported_tys: Vec<_> =\n+                    supported_tys.iter().map(|(t, _)| t.to_string()).collect();\n+                err.note(&format!(\n+                    \"register class `{}` supports these types: {}\",\n+                    reg_class.name(),\n+                    supported_tys.join(\", \"),\n+                ));\n+                if let Some(suggest) = reg_class.suggest_class(asm_arch, asm_ty) {\n+                    err.help(&format!(\n+                        \"consider using the `{}` register class instead\",\n+                        suggest.name()\n+                    ));\n+                }\n+                err.emit();\n+                return Some(asm_ty);\n+            }\n+        };\n+\n+        // Check whether the selected type requires a target feature. Note that\n+        // this is different from the feature check we did earlier in AST\n+        // lowering. While AST lowering checked that this register class is\n+        // usable at all with the currently enabled features, some types may\n+        // only be usable with a register class when a certain feature is\n+        // enabled. We check this here since it depends on the results of typeck.\n+        //\n+        // Also note that this check isn't run when the operand type is never\n+        // (!). In that case we still need the earlier check in AST lowering to\n+        // verify that the register class is usable at all.\n+        if let Some(feature) = feature {\n+            if !self.tcx.sess.target_features.contains(&Symbol::intern(feature)) {\n+                let msg = &format!(\"`{}` target feature is not enabled\", feature);\n+                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+                err.note(&format!(\n+                    \"this is required to use type `{}` with register class `{}`\",\n+                    ty,\n+                    reg_class.name(),\n+                ));\n+                err.emit();\n+                return Some(asm_ty);\n+            }\n+        }\n+\n+        // Check whether a modifier is suggested for using this type.\n+        if let Some((suggested_modifier, suggested_result)) =\n+            reg_class.suggest_modifier(asm_arch, asm_ty)\n+        {\n+            // Search for any use of this operand without a modifier and emit\n+            // the suggestion for them.\n+            let mut spans = vec![];\n+            for piece in template {\n+                if let &InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span } = piece\n+                {\n+                    if operand_idx == idx && modifier.is_none() {\n+                        spans.push(span);\n+                    }\n+                }\n+            }\n+            if !spans.is_empty() {\n+                let (default_modifier, default_result) =\n+                    reg_class.default_modifier(asm_arch).unwrap();\n+                self.tcx.struct_span_lint_hir(\n+                    lint::builtin::ASM_SUB_REGISTER,\n+                    expr.hir_id,\n+                    spans,\n+                    |lint| {\n+                        let msg = \"formatting may not be suitable for sub-register argument\";\n+                        let mut err = lint.build(msg);\n+                        err.span_label(expr.span, \"for this argument\");\n+                        err.help(&format!(\n+                            \"use the `{}` modifier to have the register formatted as `{}`\",\n+                            suggested_modifier, suggested_result,\n+                        ));\n+                        err.help(&format!(\n+                            \"or use the `{}` modifier to keep the default formatting of `{}`\",\n+                            default_modifier, default_result,\n+                        ));\n+                        err.emit();\n+                    },\n+                );\n+            }\n+        }\n+\n+        Some(asm_ty)\n+    }\n+\n+    fn check_asm(&self, asm: &hir::InlineAsm<'tcx>) {\n+        for (idx, op) in asm.operands.iter().enumerate() {\n+            match *op {\n+                hir::InlineAsmOperand::In { reg, ref expr } => {\n+                    self.check_asm_operand_type(idx, reg, expr, asm.template, None);\n+                }\n+                hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n+                    if let Some(expr) = expr {\n+                        self.check_asm_operand_type(idx, reg, expr, asm.template, None);\n+                    }\n+                }\n+                hir::InlineAsmOperand::InOut { reg, late: _, ref expr } => {\n+                    self.check_asm_operand_type(idx, reg, expr, asm.template, None);\n+                }\n+                hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n+                    let in_ty = self.check_asm_operand_type(idx, reg, in_expr, asm.template, None);\n+                    if let Some(out_expr) = out_expr {\n+                        self.check_asm_operand_type(\n+                            idx,\n+                            reg,\n+                            out_expr,\n+                            asm.template,\n+                            Some((in_expr, in_ty)),\n+                        );\n+                    }\n+                }\n+                hir::InlineAsmOperand::Const { ref expr } => {\n+                    let ty = self.tables.expr_ty_adjusted(expr);\n+                    match ty.kind {\n+                        ty::Int(_) | ty::Uint(_) | ty::Float(_) => {}\n+                        _ => {\n+                            let msg =\n+                                \"asm `const` arguments must be integer or floating-point values\";\n+                            self.tcx.sess.span_err(expr.span, msg);\n+                        }\n+                    }\n+                }\n+                hir::InlineAsmOperand::Sym { .. } => {}\n+            }\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for ItemVisitor<'tcx> {\n@@ -146,19 +414,23 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        let res = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n-            self.tables.qpath_res(qpath, expr.hir_id)\n-        } else {\n-            Res::Err\n-        };\n-        if let Res::Def(DefKind::Fn, did) = res {\n-            if self.def_id_is_transmute(did) {\n-                let typ = self.tables.node_type(expr.hir_id);\n-                let sig = typ.fn_sig(self.tcx);\n-                let from = sig.inputs().skip_binder()[0];\n-                let to = *sig.output().skip_binder();\n-                self.check_transmute(expr.span, from, to);\n+        match expr.kind {\n+            hir::ExprKind::Path(ref qpath) => {\n+                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                if let Res::Def(DefKind::Fn, did) = res {\n+                    if self.def_id_is_transmute(did) {\n+                        let typ = self.tables.node_type(expr.hir_id);\n+                        let sig = typ.fn_sig(self.tcx);\n+                        let from = sig.inputs().skip_binder()[0];\n+                        let to = *sig.output().skip_binder();\n+                        self.check_transmute(expr.span, from, to);\n+                    }\n+                }\n             }\n+\n+            hir::ExprKind::InlineAsm(asm) => self.check_asm(asm),\n+\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "21512c566e1c53ee3a2f3804b6b6668963de1e60", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -96,6 +96,7 @@\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n+use rustc_ast::ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -531,6 +532,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n         | hir::ExprKind::AssignOp(..)\n         | hir::ExprKind::Struct(..)\n         | hir::ExprKind::Repeat(..)\n+        | hir::ExprKind::InlineAsm(..)\n         | hir::ExprKind::LlvmInlineAsm(..)\n         | hir::ExprKind::Box(..)\n         | hir::ExprKind::Yield(..)\n@@ -1176,6 +1178,64 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             | hir::ExprKind::Yield(ref e, _)\n             | hir::ExprKind::Repeat(ref e, _) => self.propagate_through_expr(&e, succ),\n \n+            hir::ExprKind::InlineAsm(ref asm) => {\n+                // Handle non-returning asm\n+                let mut succ = if asm.options.contains(InlineAsmOptions::NORETURN) {\n+                    self.s.exit_ln\n+                } else {\n+                    succ\n+                };\n+\n+                // Do a first pass for writing outputs only\n+                for op in asm.operands.iter().rev() {\n+                    match op {\n+                        hir::InlineAsmOperand::In { .. }\n+                        | hir::InlineAsmOperand::Const { .. }\n+                        | hir::InlineAsmOperand::Sym { .. } => {}\n+                        hir::InlineAsmOperand::Out { expr, .. } => {\n+                            if let Some(expr) = expr {\n+                                succ = self.write_place(expr, succ, ACC_WRITE);\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { expr, .. } => {\n+                            succ = self.write_place(expr, succ, ACC_READ | ACC_WRITE);\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut { out_expr, .. } => {\n+                            if let Some(expr) = out_expr {\n+                                succ = self.write_place(expr, succ, ACC_WRITE);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Then do a second pass for inputs\n+                let mut succ = succ;\n+                for op in asm.operands.iter().rev() {\n+                    match op {\n+                        hir::InlineAsmOperand::In { expr, .. }\n+                        | hir::InlineAsmOperand::Const { expr, .. }\n+                        | hir::InlineAsmOperand::Sym { expr, .. } => {\n+                            succ = self.propagate_through_expr(expr, succ)\n+                        }\n+                        hir::InlineAsmOperand::Out { expr, .. } => {\n+                            if let Some(expr) = expr {\n+                                succ = self.propagate_through_place_components(expr, succ);\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { expr, .. } => {\n+                            succ = self.propagate_through_place_components(expr, succ);\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                            if let Some(expr) = out_expr {\n+                                succ = self.propagate_through_place_components(expr, succ);\n+                            }\n+                            succ = self.propagate_through_expr(in_expr, succ);\n+                        }\n+                    }\n+                }\n+                succ\n+            }\n+\n             hir::ExprKind::LlvmInlineAsm(ref asm) => {\n                 let ia = &asm.inner;\n                 let outputs = asm.outputs_exprs;\n@@ -1397,6 +1457,33 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n         }\n \n+        hir::ExprKind::InlineAsm(ref asm) => {\n+            for op in asm.operands {\n+                match op {\n+                    hir::InlineAsmOperand::In { expr, .. }\n+                    | hir::InlineAsmOperand::Const { expr, .. }\n+                    | hir::InlineAsmOperand::Sym { expr, .. } => this.visit_expr(expr),\n+                    hir::InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            this.check_place(expr);\n+                            this.visit_expr(expr);\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::InOut { expr, .. } => {\n+                        this.check_place(expr);\n+                        this.visit_expr(expr);\n+                    }\n+                    hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        this.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            this.check_place(out_expr);\n+                            this.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         hir::ExprKind::LlvmInlineAsm(ref asm) => {\n             for input in asm.inputs_exprs {\n                 this.visit_expr(input);"}, {"sha": "3d03e46683ed5a138c61196ae236404df7eea561", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -508,6 +508,12 @@ declare_lint! {\n     \"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\",\n }\n \n+declare_lint! {\n+    pub ASM_SUB_REGISTER,\n+    Warn,\n+    \"using only a subset of a register for inline asm inputs\",\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -576,6 +582,7 @@ declare_lint_pass! {\n         INDIRECT_STRUCTURAL_MATCH,\n         SOFT_UNSTABLE,\n         INLINE_NO_SANITIZE,\n+        ASM_SUB_REGISTER,\n     ]\n }\n "}, {"sha": "143401dd3b62244d0d1692e36b4b0c6c80abaf72", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -23,6 +23,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{self, FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n use rustc_span::{SourceFileHashAlgorithm, Symbol};\n+use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple, TlsModel};\n \n@@ -31,6 +32,7 @@ use std::env;\n use std::io::Write;\n use std::num::NonZeroU32;\n use std::path::PathBuf;\n+use std::str::FromStr;\n use std::sync::Arc;\n use std::time::Duration;\n \n@@ -158,6 +160,12 @@ pub struct Session {\n     /// if Rust was built with path remapping to `/rustc/$hash` enabled\n     /// (the `rust.remap-debuginfo` option in `config.toml`).\n     pub real_rust_source_base_dir: Option<PathBuf>,\n+\n+    /// Architecture to use for interpreting asm!.\n+    pub asm_arch: Option<InlineAsmArch>,\n+\n+    /// Set of enabled features for the current target.\n+    pub target_features: FxHashSet<Symbol>,\n }\n \n pub struct PerfStats {\n@@ -1183,6 +1191,12 @@ pub fn build_session_with_source_map(\n         if candidate.join(\"src/libstd/lib.rs\").is_file() { Some(candidate) } else { None }\n     };\n \n+    let asm_arch = if target_cfg.target.options.allow_asm {\n+        InlineAsmArch::from_str(&target_cfg.target.arch).ok()\n+    } else {\n+        None\n+    };\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1223,6 +1237,8 @@ pub fn build_session_with_source_map(\n         ctfe_backtrace,\n         miri_unleashed_features: Lock::new(Default::default()),\n         real_rust_source_base_dir,\n+        asm_arch,\n+        target_features: FxHashSet::default(),\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "a38f594920410700704749bd2edfc5a0e4abd6ec", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -160,6 +160,7 @@ symbols! {\n         attr,\n         attributes,\n         attr_literals,\n+        att_syntax,\n         augmented_assignments,\n         automatically_derived,\n         avx512_target_feature,\n@@ -376,6 +377,8 @@ symbols! {\n         if_let,\n         if_while_or_patterns,\n         ignore,\n+        inlateout,\n+        inout,\n         impl_header_lifetime_elision,\n         impl_lint_pass,\n         impl_trait_in_bindings,\n@@ -411,6 +414,7 @@ symbols! {\n         label_break_value,\n         lang,\n         lang_items,\n+        lateout,\n         let_chains,\n         lhs,\n         lib,\n@@ -495,12 +499,15 @@ symbols! {\n         no_link,\n         no_main,\n         no_mangle,\n+        nomem,\n         non_ascii_idents,\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n-        no_sanitize,\n+        noreturn,\n         no_niche,\n+        no_sanitize,\n+        nostack,\n         no_stack_check,\n         no_start,\n         no_std,\n@@ -519,11 +526,13 @@ symbols! {\n         option,\n         Option,\n         option_env,\n+        options,\n         opt_out_copy,\n         or,\n         or_patterns,\n         Ord,\n         Ordering,\n+        out,\n         Output,\n         overlapping_marker_traits,\n         packed,\n@@ -556,6 +565,7 @@ symbols! {\n         pref_align_of,\n         prelude,\n         prelude_import,\n+        preserves_flags,\n         primitive,\n         proc_dash_macro: \"proc-macro\",\n         proc_macro,\n@@ -572,6 +582,7 @@ symbols! {\n         profiler_runtime,\n         ptr_offset_from,\n         pub_restricted,\n+        pure,\n         pushpop_unsafe,\n         quad_precision_float,\n         question_mark,\n@@ -586,6 +597,7 @@ symbols! {\n         raw_identifiers,\n         raw_ref_op,\n         Rc,\n+        readonly,\n         Ready,\n         reason,\n         recursion_limit,\n@@ -607,6 +619,7 @@ symbols! {\n         Result,\n         Return,\n         rhs,\n+        riscv_target_feature,\n         rlib,\n         rotate_left,\n         rotate_right,\n@@ -722,6 +735,7 @@ symbols! {\n         sty,\n         sub_with_overflow,\n         suggestion,\n+        sym,\n         sync_trait,\n         target_feature,\n         target_feature_11,\n@@ -1186,8 +1200,8 @@ pub mod sym {\n     // have a static symbol and therefore are fast.\n     pub fn integer<N: TryInto<usize> + Copy + ToString>(n: N) -> Symbol {\n         if let Result::Ok(idx) = n.try_into() {\n-            if let Option::Some(&sym) = digits_array.get(idx) {\n-                return sym;\n+            if let Option::Some(&sym_) = digits_array.get(idx) {\n+                return sym_;\n             }\n         }\n         Symbol::intern(&n.to_string())"}, {"sha": "e7c9edea7653aec7f996724f806e69c602459ddb", "filename": "src/librustc_target/asm/aarch64.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Faarch64.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,156 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    AArch64 AArch64InlineAsmRegClass {\n+        reg,\n+        vreg,\n+        vreg_low16,\n+    }\n+}\n+\n+impl AArch64InlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::reg => &['w', 'x'],\n+            Self::vreg | Self::vreg_low16 => &['b', 'h', 's', 'd', 'q', 'v'],\n+        }\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::reg => match ty.size().bits() {\n+                64 => None,\n+                _ => Some(('w', \"w0\")),\n+            },\n+            Self::vreg | Self::vreg_low16 => match ty.size().bits() {\n+                8 => Some(('b', \"b0\")),\n+                16 => Some(('h', \"h0\")),\n+                32 => Some(('s', \"s0\")),\n+                64 => Some(('d', \"d0\")),\n+                128 => Some(('q', \"q0\")),\n+                _ => None,\n+            },\n+        }\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::reg => Some(('x', \"x0\")),\n+            Self::vreg | Self::vreg_low16 => Some(('v', \"v0\")),\n+        }\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => types! { _: I8, I16, I32, I64, F32, F64; },\n+            Self::vreg | Self::vreg_low16 => types! {\n+                \"fp\": I8, I16, I32, I64, F32, F64,\n+                    VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2), VecF64(1),\n+                    VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n+            },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    AArch64 AArch64InlineAsmReg AArch64InlineAsmRegClass {\n+        x0: reg = [\"x0\", \"w0\"],\n+        x1: reg = [\"x1\", \"w1\"],\n+        x2: reg = [\"x2\", \"w2\"],\n+        x3: reg = [\"x3\", \"w3\"],\n+        x4: reg = [\"x4\", \"w4\"],\n+        x5: reg = [\"x5\", \"w5\"],\n+        x6: reg = [\"x6\", \"w6\"],\n+        x7: reg = [\"x7\", \"w7\"],\n+        x8: reg = [\"x8\", \"w8\"],\n+        x9: reg = [\"x9\", \"w9\"],\n+        x10: reg = [\"x10\", \"w10\"],\n+        x11: reg = [\"x11\", \"w11\"],\n+        x12: reg = [\"x12\", \"w12\"],\n+        x13: reg = [\"x13\", \"w13\"],\n+        x14: reg = [\"x14\", \"w14\"],\n+        x15: reg = [\"x15\", \"w15\"],\n+        x16: reg = [\"x16\", \"w16\"],\n+        x17: reg = [\"x17\", \"w17\"],\n+        x18: reg = [\"x18\", \"w18\"],\n+        x19: reg = [\"x19\", \"w19\"],\n+        x20: reg = [\"x20\", \"w20\"],\n+        x21: reg = [\"x21\", \"w21\"],\n+        x22: reg = [\"x22\", \"w22\"],\n+        x23: reg = [\"x23\", \"w23\"],\n+        x24: reg = [\"x24\", \"w24\"],\n+        x25: reg = [\"x25\", \"w25\"],\n+        x26: reg = [\"x26\", \"w26\"],\n+        x27: reg = [\"x27\", \"w27\"],\n+        x28: reg = [\"x28\", \"w28\"],\n+        x30: reg = [\"x30\", \"w30\", \"lr\"],\n+        v0: vreg, vreg_low16 = [\"v0\", \"b0\", \"h0\", \"s0\", \"d0\", \"q0\"],\n+        v1: vreg, vreg_low16 = [\"v1\", \"b1\", \"h1\", \"s1\", \"d1\", \"q1\"],\n+        v2: vreg, vreg_low16 = [\"v2\", \"b2\", \"h2\", \"s2\", \"d2\", \"q2\"],\n+        v3: vreg, vreg_low16 = [\"v3\", \"b3\", \"h3\", \"s3\", \"d3\", \"q3\"],\n+        v4: vreg, vreg_low16 = [\"v4\", \"b4\", \"h4\", \"s4\", \"d4\", \"q4\"],\n+        v5: vreg, vreg_low16 = [\"v5\", \"b5\", \"h5\", \"s5\", \"d5\", \"q5\"],\n+        v6: vreg, vreg_low16 = [\"v6\", \"b6\", \"h6\", \"s6\", \"d6\", \"q6\"],\n+        v7: vreg, vreg_low16 = [\"v7\", \"b7\", \"h7\", \"s7\", \"d7\", \"q7\"],\n+        v8: vreg, vreg_low16 = [\"v8\", \"b8\", \"h8\", \"s8\", \"d8\", \"q8\"],\n+        v9: vreg, vreg_low16 = [\"v9\", \"b9\", \"h9\", \"s9\", \"d9\", \"q9\"],\n+        v10: vreg, vreg_low16 = [\"v10\", \"b10\", \"h10\", \"s10\", \"d10\", \"q10\"],\n+        v11: vreg, vreg_low16 = [\"v11\", \"b11\", \"h11\", \"s11\", \"d11\", \"q11\"],\n+        v12: vreg, vreg_low16 = [\"v12\", \"b12\", \"h12\", \"s12\", \"d12\", \"q12\"],\n+        v13: vreg, vreg_low16 = [\"v13\", \"b13\", \"h13\", \"s13\", \"d13\", \"q13\"],\n+        v14: vreg, vreg_low16 = [\"v14\", \"b14\", \"h14\", \"s14\", \"d14\", \"q14\"],\n+        v15: vreg, vreg_low16 = [\"v15\", \"b15\", \"h15\", \"s15\", \"d15\", \"q15\"],\n+        v16: vreg = [\"v16\", \"b16\", \"h16\", \"s16\", \"d16\", \"q16\"],\n+        v17: vreg = [\"v17\", \"b17\", \"h17\", \"s17\", \"d17\", \"q17\"],\n+        v18: vreg = [\"v18\", \"b18\", \"h18\", \"s18\", \"d18\", \"q18\"],\n+        v19: vreg = [\"v19\", \"b19\", \"h19\", \"s19\", \"d19\", \"q19\"],\n+        v20: vreg = [\"v20\", \"b20\", \"h20\", \"s20\", \"d20\", \"q20\"],\n+        v21: vreg = [\"v21\", \"b21\", \"h21\", \"s21\", \"d21\", \"q21\"],\n+        v22: vreg = [\"v22\", \"b22\", \"h22\", \"s22\", \"d22\", \"q22\"],\n+        v23: vreg = [\"v23\", \"b23\", \"h23\", \"s23\", \"d23\", \"q23\"],\n+        v24: vreg = [\"v24\", \"b24\", \"h24\", \"s24\", \"d24\", \"q24\"],\n+        v25: vreg = [\"v25\", \"b25\", \"h25\", \"s25\", \"d25\", \"q25\"],\n+        v26: vreg = [\"v26\", \"b26\", \"h26\", \"s26\", \"d26\", \"q26\"],\n+        v27: vreg = [\"v27\", \"b27\", \"h27\", \"s27\", \"d27\", \"q27\"],\n+        v28: vreg = [\"v28\", \"b28\", \"h28\", \"s28\", \"d28\", \"q28\"],\n+        v29: vreg = [\"v29\", \"b29\", \"h29\", \"s29\", \"d29\", \"q29\"],\n+        v30: vreg = [\"v30\", \"b30\", \"h30\", \"s30\", \"d30\", \"q30\"],\n+        v31: vreg = [\"v31\", \"b31\", \"h31\", \"s31\", \"d31\", \"q31\"],\n+        #error = [\"x29\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"sp\", \"wsp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"xzr\", \"wzr\"] =>\n+            \"the zero register cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl AArch64InlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        let (prefix, index) = if (self as u32) < Self::v0 as u32 {\n+            (modifier.unwrap_or('x'), self as u32 - Self::x0 as u32)\n+        } else {\n+            (modifier.unwrap_or('v'), self as u32 - Self::v0 as u32)\n+        };\n+        assert!(index < 32);\n+        write!(out, \"{}{}\", prefix, index)\n+    }\n+}"}, {"sha": "1798b2a0949754125a40e92b2a43afc3c3780aba", "filename": "src/librustc_target/asm/arm.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Farm.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,266 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Arm ArmInlineAsmRegClass {\n+        reg,\n+        reg_thumb,\n+        sreg,\n+        sreg_low16,\n+        dreg,\n+        dreg_low16,\n+        dreg_low8,\n+        qreg,\n+        qreg_low8,\n+        qreg_low4,\n+    }\n+}\n+\n+impl ArmInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::qreg | Self::qreg_low8 | Self::qreg_low4 => &['e', 'f'],\n+            _ => &[],\n+        }\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg | Self::reg_thumb => types! { _: I8, I16, I32, F32; },\n+            Self::sreg | Self::sreg_low16 => types! { \"vfp2\": I32, F32; },\n+            Self::dreg | Self::dreg_low16 | Self::dreg_low8 => types! {\n+                \"vfp2\": I64, F64, VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2);\n+            },\n+            Self::qreg | Self::qreg_low8 | Self::qreg_low4 => types! {\n+                \"neon\": VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4);\n+            },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    Arm ArmInlineAsmReg ArmInlineAsmRegClass {\n+        r0: reg, reg_thumb = [\"r0\", \"a1\"],\n+        r1: reg, reg_thumb = [\"r1\", \"a2\"],\n+        r2: reg, reg_thumb = [\"r2\", \"a3\"],\n+        r3: reg, reg_thumb = [\"r3\", \"a4\"],\n+        r4: reg, reg_thumb = [\"r4\", \"v1\"],\n+        r5: reg, reg_thumb = [\"r5\", \"v2\"],\n+        r6: reg, reg_thumb = [\"r6\", \"v3\"],\n+        r7: reg, reg_thumb = [\"r7\", \"v4\"],\n+        r8: reg = [\"r8\", \"v5\"],\n+        r9: reg = [\"r9\", \"v6\", \"rfp\"],\n+        r10: reg = [\"r10\", \"sl\"],\n+        r12: reg = [\"r12\", \"ip\"],\n+        r14: reg = [\"r14\", \"lr\"],\n+        s0: sreg, sreg_low16 = [\"s0\"],\n+        s1: sreg, sreg_low16 = [\"s1\"],\n+        s2: sreg, sreg_low16 = [\"s2\"],\n+        s3: sreg, sreg_low16 = [\"s3\"],\n+        s4: sreg, sreg_low16 = [\"s4\"],\n+        s5: sreg, sreg_low16 = [\"s5\"],\n+        s6: sreg, sreg_low16 = [\"s6\"],\n+        s7: sreg, sreg_low16 = [\"s7\"],\n+        s8: sreg, sreg_low16 = [\"s8\"],\n+        s9: sreg, sreg_low16 = [\"s9\"],\n+        s10: sreg, sreg_low16 = [\"s10\"],\n+        s11: sreg, sreg_low16 = [\"s11\"],\n+        s12: sreg, sreg_low16 = [\"s12\"],\n+        s13: sreg, sreg_low16 = [\"s13\"],\n+        s14: sreg, sreg_low16 = [\"s14\"],\n+        s15: sreg, sreg_low16 = [\"s15\"],\n+        s16: sreg = [\"s16\"],\n+        s17: sreg = [\"s17\"],\n+        s18: sreg = [\"s18\"],\n+        s19: sreg = [\"s19\"],\n+        s20: sreg = [\"s20\"],\n+        s21: sreg = [\"s21\"],\n+        s22: sreg = [\"s22\"],\n+        s23: sreg = [\"s23\"],\n+        s24: sreg = [\"s24\"],\n+        s25: sreg = [\"s25\"],\n+        s26: sreg = [\"s26\"],\n+        s27: sreg = [\"s27\"],\n+        s28: sreg = [\"s28\"],\n+        s29: sreg = [\"s29\"],\n+        s30: sreg = [\"s30\"],\n+        s31: sreg = [\"s31\"],\n+        d0: dreg, dreg_low16, dreg_low8 = [\"d0\"],\n+        d1: dreg, dreg_low16, dreg_low8 = [\"d1\"],\n+        d2: dreg, dreg_low16, dreg_low8 = [\"d2\"],\n+        d3: dreg, dreg_low16, dreg_low8 = [\"d3\"],\n+        d4: dreg, dreg_low16, dreg_low8 = [\"d4\"],\n+        d5: dreg, dreg_low16, dreg_low8 = [\"d5\"],\n+        d6: dreg, dreg_low16, dreg_low8 = [\"d6\"],\n+        d7: dreg, dreg_low16, dreg_low8 = [\"d7\"],\n+        d8: dreg, dreg_low16 = [\"d8\"],\n+        d9: dreg, dreg_low16 = [\"d9\"],\n+        d10: dreg, dreg_low16 = [\"d10\"],\n+        d11: dreg, dreg_low16 = [\"d11\"],\n+        d12: dreg, dreg_low16 = [\"d12\"],\n+        d13: dreg, dreg_low16 = [\"d13\"],\n+        d14: dreg, dreg_low16 = [\"d14\"],\n+        d15: dreg, dreg_low16 = [\"d15\"],\n+        d16: dreg = [\"d16\"],\n+        d17: dreg = [\"d17\"],\n+        d18: dreg = [\"d18\"],\n+        d19: dreg = [\"d19\"],\n+        d20: dreg = [\"d20\"],\n+        d21: dreg = [\"d21\"],\n+        d22: dreg = [\"d22\"],\n+        d23: dreg = [\"d23\"],\n+        d24: dreg = [\"d24\"],\n+        d25: dreg = [\"d25\"],\n+        d26: dreg = [\"d26\"],\n+        d27: dreg = [\"d27\"],\n+        d28: dreg = [\"d28\"],\n+        d29: dreg = [\"d29\"],\n+        d30: dreg = [\"d30\"],\n+        d31: dreg = [\"d31\"],\n+        q0: qreg, qreg_low8, qreg_low4 = [\"q0\"],\n+        q1: qreg, qreg_low8, qreg_low4 = [\"q1\"],\n+        q2: qreg, qreg_low8, qreg_low4 = [\"q2\"],\n+        q3: qreg, qreg_low8, qreg_low4 = [\"q3\"],\n+        q4: qreg, qreg_low8 = [\"q4\"],\n+        q5: qreg, qreg_low8 = [\"q5\"],\n+        q6: qreg, qreg_low8 = [\"q6\"],\n+        q7: qreg, qreg_low8 = [\"q7\"],\n+        q8: qreg = [\"q8\"],\n+        q9: qreg = [\"q9\"],\n+        q10: qreg = [\"q10\"],\n+        q11: qreg = [\"q11\"],\n+        q12: qreg = [\"q12\"],\n+        q13: qreg = [\"q13\"],\n+        q14: qreg = [\"q14\"],\n+        q15: qreg = [\"q15\"],\n+        #error = [\"r11\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r13\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r15\", \"pc\"] =>\n+            \"the program pointer cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl ArmInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        // Only qreg is allowed to have modifiers. This should have been\n+        // validated already by now.\n+        if let Some(modifier) = modifier {\n+            let index = self as u32 - Self::q0 as u32;\n+            assert!(index < 16);\n+            let index = index * 2 + (modifier == 'f') as u32;\n+            write!(out, \"d{}\", index)\n+        } else {\n+            out.write_str(self.name())\n+        }\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(ArmInlineAsmReg)) {\n+        cb(self);\n+\n+        macro_rules! reg_conflicts {\n+            (\n+                $(\n+                    $q:ident : $d0:ident $d1:ident : $s0:ident $s1:ident $s2:ident $s3:ident\n+                ),*;\n+                $(\n+                    $q_high:ident : $d0_high:ident $d1_high:ident\n+                ),*;\n+            ) => {\n+                match self {\n+                    $(\n+                        Self::$q => {\n+                            cb(Self::$d0);\n+                            cb(Self::$d1);\n+                            cb(Self::$s0);\n+                            cb(Self::$s1);\n+                            cb(Self::$s2);\n+                            cb(Self::$s3);\n+                        }\n+                        Self::$d0 => {\n+                            cb(Self::$q);\n+                            cb(Self::$s0);\n+                            cb(Self::$s1);\n+                        }\n+                        Self::$d1 => {\n+                            cb(Self::$q);\n+                            cb(Self::$s2);\n+                            cb(Self::$s3);\n+                        }\n+                        Self::$s0 | Self::$s1 => {\n+                            cb(Self::$q);\n+                            cb(Self::$d0);\n+                        }\n+                        Self::$s2 | Self::$s3 => {\n+                            cb(Self::$q);\n+                            cb(Self::$d1);\n+                        }\n+                    )*\n+                    $(\n+                        Self::$q_high => {\n+                            cb(Self::$d0_high);\n+                            cb(Self::$d1_high);\n+                        }\n+                        Self::$d0_high | Self::$d1_high => {\n+                            cb(Self::$q_high);\n+                        }\n+                    )*\n+                    _ => {},\n+                }\n+            };\n+        }\n+\n+        // ARM's floating-point register file is interesting in that it can be\n+        // viewed as 16 128-bit registers, 32 64-bit registers or 32 32-bit\n+        // registers. Because these views overlap, the registers of different\n+        // widths will conflict (e.g. d0 overlaps with s0 and s1, and q1\n+        // overlaps with d2 and d3).\n+        //\n+        // See section E1.3.1 of the ARM Architecture Reference Manual for\n+        // ARMv8-A for more details.\n+        reg_conflicts! {\n+            q0 : d0 d1 : s0 s1 s2 s3,\n+            q1 : d2 d3 : s4 s5 s6 s7,\n+            q2 : d4 d5 : s8 s9 s10 s11,\n+            q3 : d6 d7 : s12 s13 s14 s15,\n+            q4 : d8 d9 : s16 s17 s18 s19,\n+            q5 : d10 d11 : s20 s21 s22 s23,\n+            q6 : d12 d13 : s24 s25 s26 s27,\n+            q7 : d14 d15 : s28 s29 s30 s31;\n+            q8 : d16 d17,\n+            q9 : d18 d19,\n+            q10 : d20 d21,\n+            q11 : d22 d23,\n+            q12 : d24 d25,\n+            q13 : d26 d27,\n+            q14 : d28 d29,\n+            q15 : d30 d31;\n+        }\n+    }\n+}"}, {"sha": "05aa85ecb7448b33ae35bb17ff1db5677fe6db9a", "filename": "src/librustc_target/asm/mod.rs", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,522 @@\n+use crate::abi::Size;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n+use std::fmt;\n+use std::str::FromStr;\n+\n+#[macro_use]\n+macro_rules! def_reg_class {\n+    ($arch:ident $arch_regclass:ident {\n+        $(\n+            $class:ident,\n+        )*\n+    }) => {\n+        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[allow(non_camel_case_types)]\n+        pub enum $arch_regclass {\n+            $($class,)*\n+        }\n+\n+        impl $arch_regclass {\n+            pub fn name(self) -> &'static str {\n+                match self {\n+                    $(Self::$class => stringify!($class),)*\n+                }\n+            }\n+\n+            pub fn parse(_arch: super::InlineAsmArch, name: &str) -> Result<Self, &'static str> {\n+                match name {\n+                    $(\n+                        stringify!($class) => Ok(Self::$class),\n+                    )*\n+                    _ => Err(\"unknown register class\"),\n+                }\n+            }\n+        }\n+\n+        pub(super) fn regclass_map() -> rustc_data_structures::fx::FxHashMap<\n+            super::InlineAsmRegClass,\n+            rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n+        > {\n+            use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+            use super::InlineAsmRegClass;\n+            let mut map = FxHashMap::default();\n+            $(\n+                map.insert(InlineAsmRegClass::$arch($arch_regclass::$class), FxHashSet::default());\n+            )*\n+            map\n+        }\n+    }\n+}\n+\n+#[macro_use]\n+macro_rules! def_regs {\n+    ($arch:ident $arch_reg:ident $arch_regclass:ident {\n+        $(\n+            $reg:ident: $class:ident $(, $extra_class:ident)* = [$reg_name:literal $(, $alias:literal)*] $(% $filter:ident)?,\n+        )*\n+        $(\n+            #error = [$($bad_reg:literal),+] => $error:literal,\n+        )*\n+    }) => {\n+        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[allow(non_camel_case_types)]\n+        pub enum $arch_reg {\n+            $($reg,)*\n+        }\n+\n+        impl $arch_reg {\n+            pub fn name(self) -> &'static str {\n+                match self {\n+                    $(Self::$reg => $reg_name,)*\n+                }\n+            }\n+\n+            pub fn reg_class(self) -> $arch_regclass {\n+                match self {\n+                    $(Self::$reg => $arch_regclass::$class,)*\n+                }\n+            }\n+\n+            pub fn parse(\n+                _arch: super::InlineAsmArch,\n+                mut _has_feature: impl FnMut(&str) -> bool,\n+                name: &str,\n+            ) -> Result<Self, &'static str> {\n+                match name {\n+                    $(\n+                        $($alias)|* | $reg_name => {\n+                            $($filter(_arch, &mut _has_feature, false)?;)?\n+                            Ok(Self::$reg)\n+                        }\n+                    )*\n+                    $(\n+                        $($bad_reg)|* => Err($error),\n+                    )*\n+                    _ => Err(\"unknown register\"),\n+                }\n+            }\n+        }\n+\n+        pub(super) fn fill_reg_map(\n+            _arch: super::InlineAsmArch,\n+            mut _has_feature: impl FnMut(&str) -> bool,\n+            map: &mut rustc_data_structures::fx::FxHashMap<\n+                super::InlineAsmRegClass,\n+                rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n+            >,\n+        ) {\n+            use super::{InlineAsmReg, InlineAsmRegClass};\n+            $(\n+                if $($filter(_arch, &mut _has_feature, true).is_ok() &&)? true {\n+                    if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n+                        set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n+                    }\n+                    $(\n+                        if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$extra_class)) {\n+                            set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n+                        }\n+                    )*\n+                }\n+            )*\n+        }\n+    }\n+}\n+\n+#[macro_use]\n+macro_rules! types {\n+    (\n+        $(_ : $($ty:expr),+;)?\n+        $($feature:literal: $($ty2:expr),+;)*\n+    ) => {\n+        {\n+            use super::InlineAsmType::*;\n+            &[\n+                $($(\n+                    ($ty, None),\n+                )*)?\n+                $($(\n+                    ($ty2, Some($feature)),\n+                )*)*\n+            ]\n+        }\n+    };\n+}\n+\n+mod aarch64;\n+mod arm;\n+mod riscv;\n+mod x86;\n+\n+pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n+pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n+pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n+\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash)]\n+pub enum InlineAsmArch {\n+    X86,\n+    X86_64,\n+    Arm,\n+    AArch64,\n+    RiscV32,\n+    RiscV64,\n+}\n+\n+impl FromStr for InlineAsmArch {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<InlineAsmArch, ()> {\n+        match s {\n+            \"x86\" => Ok(Self::X86),\n+            \"x86_64\" => Ok(Self::X86_64),\n+            \"arm\" => Ok(Self::Arm),\n+            \"aarch64\" => Ok(Self::AArch64),\n+            \"riscv32\" => Ok(Self::RiscV32),\n+            \"riscv64\" => Ok(Self::RiscV64),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+#[derive(\n+    Copy,\n+    Clone,\n+    RustcEncodable,\n+    RustcDecodable,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    Hash,\n+    HashStable_Generic\n+)]\n+pub enum InlineAsmReg {\n+    X86(X86InlineAsmReg),\n+    Arm(ArmInlineAsmReg),\n+    AArch64(AArch64InlineAsmReg),\n+    RiscV(RiscVInlineAsmReg),\n+}\n+\n+impl InlineAsmReg {\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            Self::X86(r) => r.name(),\n+            Self::Arm(r) => r.name(),\n+            Self::AArch64(r) => r.name(),\n+            Self::RiscV(r) => r.name(),\n+        }\n+    }\n+\n+    pub fn reg_class(self) -> InlineAsmRegClass {\n+        match self {\n+            Self::X86(r) => InlineAsmRegClass::X86(r.reg_class()),\n+            Self::Arm(r) => InlineAsmRegClass::Arm(r.reg_class()),\n+            Self::AArch64(r) => InlineAsmRegClass::AArch64(r.reg_class()),\n+            Self::RiscV(r) => InlineAsmRegClass::RiscV(r.reg_class()),\n+        }\n+    }\n+\n+    pub fn parse(\n+        arch: InlineAsmArch,\n+        has_feature: impl FnMut(&str) -> bool,\n+        name: Symbol,\n+    ) -> Result<Self, &'static str> {\n+        // FIXME: use direct symbol comparison for register names\n+        name.with(|name| {\n+            Ok(match arch {\n+                InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                    Self::X86(X86InlineAsmReg::parse(arch, has_feature, name)?)\n+                }\n+                InlineAsmArch::Arm => Self::Arm(ArmInlineAsmReg::parse(arch, has_feature, name)?),\n+                InlineAsmArch::AArch64 => {\n+                    Self::AArch64(AArch64InlineAsmReg::parse(arch, has_feature, name)?)\n+                }\n+                InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                    Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, name)?)\n+                }\n+            })\n+        })\n+    }\n+\n+    // NOTE: This function isn't used at the moment, but is needed to support\n+    // falling back to an external assembler.\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        match self {\n+            Self::X86(r) => r.emit(out, arch, modifier),\n+            Self::Arm(r) => r.emit(out, arch, modifier),\n+            Self::AArch64(r) => r.emit(out, arch, modifier),\n+            Self::RiscV(r) => r.emit(out, arch, modifier),\n+        }\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(InlineAsmReg)) {\n+        match self {\n+            Self::X86(r) => r.overlapping_regs(|r| cb(Self::X86(r))),\n+            Self::Arm(r) => r.overlapping_regs(|r| cb(Self::Arm(r))),\n+            Self::AArch64(_) => cb(self),\n+            Self::RiscV(_) => cb(self),\n+        }\n+    }\n+}\n+\n+#[derive(\n+    Copy,\n+    Clone,\n+    RustcEncodable,\n+    RustcDecodable,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    Hash,\n+    HashStable_Generic\n+)]\n+pub enum InlineAsmRegClass {\n+    X86(X86InlineAsmRegClass),\n+    Arm(ArmInlineAsmRegClass),\n+    AArch64(AArch64InlineAsmRegClass),\n+    RiscV(RiscVInlineAsmRegClass),\n+}\n+\n+impl InlineAsmRegClass {\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            Self::X86(r) => r.name(),\n+            Self::Arm(r) => r.name(),\n+            Self::AArch64(r) => r.name(),\n+            Self::RiscV(r) => r.name(),\n+        }\n+    }\n+\n+    /// Returns a suggested register class to use for this type. This is called\n+    /// after type checking via `supported_types` fails to give a better error\n+    /// message to the user.\n+    pub fn suggest_class(self, arch: InlineAsmArch, ty: InlineAsmType) -> Option<Self> {\n+        match self {\n+            Self::X86(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::X86),\n+            Self::Arm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Arm),\n+            Self::AArch64(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::AArch64),\n+            Self::RiscV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::RiscV),\n+        }\n+    }\n+\n+    /// Returns a suggested template modifier to use for this type and an\n+    /// example of a  register named formatted with it.\n+    ///\n+    /// Such suggestions are useful if a type smaller than the full register\n+    /// size is used and a modifier can be used to point to the subregister of\n+    /// the correct size.\n+    pub fn suggest_modifier(\n+        self,\n+        arch: InlineAsmArch,\n+        ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::X86(r) => r.suggest_modifier(arch, ty),\n+            Self::Arm(r) => r.suggest_modifier(arch, ty),\n+            Self::AArch64(r) => r.suggest_modifier(arch, ty),\n+            Self::RiscV(r) => r.suggest_modifier(arch, ty),\n+        }\n+    }\n+\n+    /// Returns the default modifier for this register and an example of a\n+    /// register named formatted with it.\n+    ///\n+    /// This is only needed when the register class can suggest a modifier, so\n+    /// that the user can be shown how to get the default behavior without a\n+    /// warning.\n+    pub fn default_modifier(self, arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::X86(r) => r.default_modifier(arch),\n+            Self::Arm(r) => r.default_modifier(arch),\n+            Self::AArch64(r) => r.default_modifier(arch),\n+            Self::RiscV(r) => r.default_modifier(arch),\n+        }\n+    }\n+\n+    /// Returns a list of supported types for this register class, each with a\n+    /// options target feature required to use this type.\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::X86(r) => r.supported_types(arch),\n+            Self::Arm(r) => r.supported_types(arch),\n+            Self::AArch64(r) => r.supported_types(arch),\n+            Self::RiscV(r) => r.supported_types(arch),\n+        }\n+    }\n+\n+    pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n+        // FIXME: use direct symbol comparison for register class names\n+        name.with(|name| {\n+            Ok(match arch {\n+                InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                    Self::X86(X86InlineAsmRegClass::parse(arch, name)?)\n+                }\n+                InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(arch, name)?),\n+                InlineAsmArch::AArch64 => {\n+                    Self::AArch64(AArch64InlineAsmRegClass::parse(arch, name)?)\n+                }\n+                InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                    Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n+                }\n+            })\n+        })\n+    }\n+\n+    /// Returns the list of template modifiers that can be used with this\n+    /// register class.\n+    pub fn valid_modifiers(self, arch: InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::X86(r) => r.valid_modifiers(arch),\n+            Self::Arm(r) => r.valid_modifiers(arch),\n+            Self::AArch64(r) => r.valid_modifiers(arch),\n+            Self::RiscV(r) => r.valid_modifiers(arch),\n+        }\n+    }\n+}\n+\n+#[derive(\n+    Copy,\n+    Clone,\n+    RustcEncodable,\n+    RustcDecodable,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    Hash,\n+    HashStable_Generic\n+)]\n+pub enum InlineAsmRegOrRegClass {\n+    Reg(InlineAsmReg),\n+    RegClass(InlineAsmRegClass),\n+}\n+\n+impl InlineAsmRegOrRegClass {\n+    pub fn reg_class(self) -> InlineAsmRegClass {\n+        match self {\n+            Self::Reg(r) => r.reg_class(),\n+            Self::RegClass(r) => r,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for InlineAsmRegOrRegClass {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Reg(r) => write!(f, \"\\\"{}\\\"\", r.name()),\n+            Self::RegClass(r) => f.write_str(r.name()),\n+        }\n+    }\n+}\n+\n+/// Set of types which can be used with a particular register class.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum InlineAsmType {\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+    F32,\n+    F64,\n+    VecI8(u64),\n+    VecI16(u64),\n+    VecI32(u64),\n+    VecI64(u64),\n+    VecI128(u64),\n+    VecF32(u64),\n+    VecF64(u64),\n+}\n+\n+impl InlineAsmType {\n+    pub fn is_integer(self) -> bool {\n+        match self {\n+            Self::I8 | Self::I16 | Self::I32 | Self::I64 | Self::I128 => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn size(self) -> Size {\n+        Size::from_bytes(match self {\n+            Self::I8 => 1,\n+            Self::I16 => 2,\n+            Self::I32 => 4,\n+            Self::I64 => 8,\n+            Self::I128 => 16,\n+            Self::F32 => 4,\n+            Self::F64 => 8,\n+            Self::VecI8(n) => n * 1,\n+            Self::VecI16(n) => n * 2,\n+            Self::VecI32(n) => n * 4,\n+            Self::VecI64(n) => n * 8,\n+            Self::VecI128(n) => n * 16,\n+            Self::VecF32(n) => n * 4,\n+            Self::VecF64(n) => n * 8,\n+        })\n+    }\n+}\n+\n+impl fmt::Display for InlineAsmType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Self::I8 => f.write_str(\"i8\"),\n+            Self::I16 => f.write_str(\"i16\"),\n+            Self::I32 => f.write_str(\"i32\"),\n+            Self::I64 => f.write_str(\"i64\"),\n+            Self::I128 => f.write_str(\"i128\"),\n+            Self::F32 => f.write_str(\"f32\"),\n+            Self::F64 => f.write_str(\"f64\"),\n+            Self::VecI8(n) => write!(f, \"i8x{}\", n),\n+            Self::VecI16(n) => write!(f, \"i16x{}\", n),\n+            Self::VecI32(n) => write!(f, \"i32x{}\", n),\n+            Self::VecI64(n) => write!(f, \"i64x{}\", n),\n+            Self::VecI128(n) => write!(f, \"i128x{}\", n),\n+            Self::VecF32(n) => write!(f, \"f32x{}\", n),\n+            Self::VecF64(n) => write!(f, \"f64x{}\", n),\n+        }\n+    }\n+}\n+\n+/// Returns the full set of allocatable registers for a given architecture.\n+///\n+/// The registers are structured as a map containing the set of allocatable\n+/// registers in each register class. A particular register may be allocatable\n+/// from multiple register classes, in which case it will appear multiple times\n+/// in the map.\n+// NOTE: This function isn't used at the moment, but is needed to support\n+// falling back to an external assembler.\n+pub fn allocatable_registers(\n+    arch: InlineAsmArch,\n+    has_feature: impl FnMut(&str) -> bool,\n+) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n+    match arch {\n+        InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+            let mut map = x86::regclass_map();\n+            x86::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+        InlineAsmArch::Arm => {\n+            let mut map = arm::regclass_map();\n+            arm::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+        InlineAsmArch::AArch64 => {\n+            let mut map = aarch64::regclass_map();\n+            aarch64::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+        InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+            let mut map = riscv::regclass_map();\n+            riscv::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n+    }\n+}"}, {"sha": "3ff542247ff02c4a438e413c5ce637d46fa33ec3", "filename": "src/librustc_target/asm/riscv.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Friscv.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,145 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    RiscV RiscVInlineAsmRegClass {\n+        reg,\n+        freg,\n+    }\n+}\n+\n+impl RiscVInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => {\n+                if arch == InlineAsmArch::RiscV64 {\n+                    types! { _: I8, I16, I32, I64, F32, F64; }\n+                } else {\n+                    types! { _: I8, I16, I32, F32; }\n+                }\n+            }\n+            Self::freg => types! { \"f\": F32; \"d\": F64; },\n+        }\n+    }\n+}\n+\n+fn not_e(\n+    _arch: InlineAsmArch,\n+    mut has_feature: impl FnMut(&str) -> bool,\n+    _allocating: bool,\n+) -> Result<(), &'static str> {\n+    if has_feature(\"e\") {\n+        Err(\"register can't be used with the `e` target feature\")\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+def_regs! {\n+    RiscV RiscVInlineAsmReg RiscVInlineAsmRegClass {\n+        x1: reg = [\"x1\", \"ra\"],\n+        x5: reg = [\"x5\", \"t0\"],\n+        x6: reg = [\"x6\", \"t1\"],\n+        x7: reg = [\"x7\", \"t2\"],\n+        x9: reg = [\"x9\", \"s1\"],\n+        x10: reg = [\"x10\", \"a0\"],\n+        x11: reg = [\"x11\", \"a1\"],\n+        x12: reg = [\"x12\", \"a2\"],\n+        x13: reg = [\"x13\", \"a3\"],\n+        x14: reg = [\"x14\", \"a4\"],\n+        x15: reg = [\"x15\", \"a5\"],\n+        x16: reg = [\"x16\", \"a6\"] % not_e,\n+        x17: reg = [\"x17\", \"a7\"] % not_e,\n+        x18: reg = [\"x18\", \"s2\"] % not_e,\n+        x19: reg = [\"x19\", \"s3\"] % not_e,\n+        x20: reg = [\"x20\", \"s4\"] % not_e,\n+        x21: reg = [\"x21\", \"s5\"] % not_e,\n+        x22: reg = [\"x22\", \"s6\"] % not_e,\n+        x23: reg = [\"x23\", \"s7\"] % not_e,\n+        x24: reg = [\"x24\", \"s8\"] % not_e,\n+        x25: reg = [\"x25\", \"s9\"] % not_e,\n+        x26: reg = [\"x26\", \"s10\"] % not_e,\n+        x27: reg = [\"x27\", \"s11\"] % not_e,\n+        x28: reg = [\"x28\", \"t3\"] % not_e,\n+        x29: reg = [\"x29\", \"t4\"] % not_e,\n+        x30: reg = [\"x30\", \"t5\"] % not_e,\n+        x31: reg = [\"x31\", \"t6\"] % not_e,\n+        f0: freg = [\"f0\", \"ft0\"],\n+        f1: freg = [\"f1\", \"ft1\"],\n+        f2: freg = [\"f2\", \"ft2\"],\n+        f3: freg = [\"f3\", \"ft3\"],\n+        f4: freg = [\"f4\", \"ft4\"],\n+        f5: freg = [\"f5\", \"ft5\"],\n+        f6: freg = [\"f6\", \"ft6\"],\n+        f7: freg = [\"f7\", \"ft7\"],\n+        f8: freg = [\"f8\", \"fs0\"],\n+        f9: freg = [\"f9\", \"fs1\"],\n+        f10: freg = [\"f10\", \"fa0\"],\n+        f11: freg = [\"f11\", \"fa1\"],\n+        f12: freg = [\"f12\", \"fa2\"],\n+        f13: freg = [\"f13\", \"fa3\"],\n+        f14: freg = [\"f14\", \"fa4\"],\n+        f15: freg = [\"f15\", \"fa5\"],\n+        f16: freg = [\"f16\", \"fa6\"],\n+        f17: freg = [\"f17\", \"fa7\"],\n+        f18: freg = [\"f18\", \"fs2\"],\n+        f19: freg = [\"f19\", \"fs3\"],\n+        f20: freg = [\"f20\", \"fs4\"],\n+        f21: freg = [\"f21\", \"fs5\"],\n+        f22: freg = [\"f22\", \"fs6\"],\n+        f23: freg = [\"f23\", \"fs7\"],\n+        f24: freg = [\"f24\", \"fs8\"],\n+        f25: freg = [\"f25\", \"fs9\"],\n+        f26: freg = [\"f26\", \"fs10\"],\n+        f27: freg = [\"f27\", \"fs11\"],\n+        f28: freg = [\"f28\", \"ft8\"],\n+        f29: freg = [\"f29\", \"ft9\"],\n+        f30: freg = [\"f30\", \"ft10\"],\n+        f31: freg = [\"f31\", \"ft11\"],\n+        #error = [\"x8\", \"s0\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"x2\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"x3\", \"gp\"] =>\n+            \"the global pointer cannot be used as an operand for inline asm\",\n+        #error = [\"x4\", \"tp\"] =>\n+            \"the thread pointer cannot be used as an operand for inline asm\" ,\n+        #error = [\"x0\", \"zero\"] =>\n+            \"the zero register cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl RiscVInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+}"}, {"sha": "ed51b526414d138bf78af559094348bfffd95ea5", "filename": "src/librustc_target/asm/x86.rs", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fx86.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,424 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    X86 X86InlineAsmRegClass {\n+        reg,\n+        reg_abcd,\n+        reg_byte,\n+        xmm_reg,\n+        ymm_reg,\n+        zmm_reg,\n+        kreg,\n+    }\n+}\n+\n+impl X86InlineAsmRegClass {\n+    pub fn valid_modifiers(self, arch: super::InlineAsmArch) -> &'static [char] {\n+        match self {\n+            Self::reg => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    &['l', 'x', 'e', 'r']\n+                } else {\n+                    &['x', 'e']\n+                }\n+            }\n+            Self::reg_abcd => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    &['l', 'h', 'x', 'e', 'r']\n+                } else {\n+                    &['l', 'h', 'x', 'e']\n+                }\n+            }\n+            Self::reg_byte => &[],\n+            Self::xmm_reg | Self::ymm_reg | Self::zmm_reg => &['x', 'y', 'z'],\n+            Self::kreg => &[],\n+        }\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, ty: InlineAsmType) -> Option<Self> {\n+        match self {\n+            Self::reg | Self::reg_abcd if ty.size().bits() == 8 => Some(Self::reg_byte),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        arch: InlineAsmArch,\n+        ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::reg => match ty.size().bits() {\n+                16 => Some(('x', \"ax\")),\n+                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\")),\n+                _ => None,\n+            },\n+            Self::reg_abcd => match ty.size().bits() {\n+                16 => Some(('x', \"ax\")),\n+                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\")),\n+                _ => None,\n+            },\n+            Self::reg_byte => None,\n+            Self::xmm_reg => None,\n+            Self::ymm_reg => match ty.size().bits() {\n+                256 => None,\n+                _ => Some(('x', \"xmm0\")),\n+            },\n+            Self::zmm_reg => match ty.size().bits() {\n+                512 => None,\n+                256 => Some(('y', \"ymm0\")),\n+                _ => Some(('x', \"xmm0\")),\n+            },\n+            Self::kreg => None,\n+        }\n+    }\n+\n+    pub fn default_modifier(self, arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        match self {\n+            Self::reg | Self::reg_abcd => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    Some(('r', \"rax\"))\n+                } else {\n+                    Some(('e', \"eax\"))\n+                }\n+            }\n+            Self::reg_byte => None,\n+            Self::xmm_reg => Some(('x', \"xmm0\")),\n+            Self::ymm_reg => Some(('y', \"ymm0\")),\n+            Self::zmm_reg => Some(('z', \"zmm0\")),\n+            Self::kreg => None,\n+        }\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg | Self::reg_abcd => {\n+                if arch == InlineAsmArch::X86_64 {\n+                    types! { _: I16, I32, I64, F32, F64; }\n+                } else {\n+                    types! { _: I16, I32, F32; }\n+                }\n+            }\n+            Self::reg_byte => types! { _: I8; },\n+            Self::xmm_reg => types! {\n+                \"sse\": I32, I64, F32, F64,\n+                  VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n+            },\n+            Self::ymm_reg => types! {\n+                \"avx\": I32, I64, F32, F64,\n+                    VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n+                    VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4);\n+            },\n+            Self::zmm_reg => types! {\n+                \"avx512f\": I32, I64, F32, F64,\n+                    VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n+                    VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4),\n+                    VecI8(64), VecI16(32), VecI32(16), VecI64(8), VecF32(16), VecF64(8);\n+            },\n+            Self::kreg => types! {\n+                \"avx512f\": I8, I16;\n+                \"avx512bw\": I32, I64;\n+            },\n+        }\n+    }\n+}\n+\n+fn x86_64_only(\n+    arch: InlineAsmArch,\n+    _has_feature: impl FnMut(&str) -> bool,\n+    _allocating: bool,\n+) -> Result<(), &'static str> {\n+    match arch {\n+        InlineAsmArch::X86 => Err(\"register is only available on x86_64\"),\n+        InlineAsmArch::X86_64 => Ok(()),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+fn high_byte(\n+    arch: InlineAsmArch,\n+    _has_feature: impl FnMut(&str) -> bool,\n+    allocating: bool,\n+) -> Result<(), &'static str> {\n+    match arch {\n+        InlineAsmArch::X86_64 if allocating => {\n+            // The error message isn't actually used...\n+            Err(\"high byte registers are not allocated by reg_byte\")\n+        }\n+        _ => Ok(()),\n+    }\n+}\n+\n+def_regs! {\n+    X86 X86InlineAsmReg X86InlineAsmRegClass {\n+        ax: reg, reg_abcd = [\"ax\", \"eax\", \"rax\"],\n+        bx: reg, reg_abcd = [\"bx\", \"ebx\", \"rbx\"],\n+        cx: reg, reg_abcd = [\"cx\", \"ecx\", \"rcx\"],\n+        dx: reg, reg_abcd = [\"dx\", \"edx\", \"rdx\"],\n+        si: reg = [\"si\", \"esi\", \"rsi\"],\n+        di: reg = [\"di\", \"edi\", \"rdi\"],\n+        r8: reg = [\"r8\", \"r8w\", \"r8d\"] % x86_64_only,\n+        r9: reg = [\"r9\", \"r9w\", \"r9d\"] % x86_64_only,\n+        r10: reg = [\"r10\", \"r10w\", \"r10d\"] % x86_64_only,\n+        r11: reg = [\"r11\", \"r11w\", \"r11d\"] % x86_64_only,\n+        r12: reg = [\"r12\", \"r12w\", \"r12d\"] % x86_64_only,\n+        r13: reg = [\"r13\", \"r13w\", \"r13d\"] % x86_64_only,\n+        r14: reg = [\"r14\", \"r14w\", \"r14d\"] % x86_64_only,\n+        r15: reg = [\"r15\", \"r15w\", \"r15d\"] % x86_64_only,\n+        al: reg_byte = [\"al\"],\n+        ah: reg_byte = [\"ah\"] % high_byte,\n+        bl: reg_byte = [\"bl\"],\n+        bh: reg_byte = [\"bh\"] % high_byte,\n+        cl: reg_byte = [\"cl\"],\n+        ch: reg_byte = [\"ch\"] % high_byte,\n+        dl: reg_byte = [\"dl\"],\n+        dh: reg_byte = [\"dh\"] % high_byte,\n+        sil: reg_byte = [\"sil\"] % x86_64_only,\n+        dil: reg_byte = [\"dil\"] % x86_64_only,\n+        r8b: reg_byte = [\"r8b\"] % x86_64_only,\n+        r9b: reg_byte = [\"r9b\"] % x86_64_only,\n+        r10b: reg_byte = [\"r10b\"] % x86_64_only,\n+        r11b: reg_byte = [\"r11b\"] % x86_64_only,\n+        r12b: reg_byte = [\"r12b\"] % x86_64_only,\n+        r13b: reg_byte = [\"r13b\"] % x86_64_only,\n+        r14b: reg_byte = [\"r14b\"] % x86_64_only,\n+        r15b: reg_byte = [\"r15b\"] % x86_64_only,\n+        xmm0: xmm_reg = [\"xmm0\"],\n+        xmm1: xmm_reg = [\"xmm1\"],\n+        xmm2: xmm_reg = [\"xmm2\"],\n+        xmm3: xmm_reg = [\"xmm3\"],\n+        xmm4: xmm_reg = [\"xmm4\"],\n+        xmm5: xmm_reg = [\"xmm5\"],\n+        xmm6: xmm_reg = [\"xmm6\"],\n+        xmm7: xmm_reg = [\"xmm7\"],\n+        xmm8: xmm_reg = [\"xmm8\"] % x86_64_only,\n+        xmm9: xmm_reg = [\"xmm9\"] % x86_64_only,\n+        xmm10: xmm_reg = [\"xmm10\"] % x86_64_only,\n+        xmm11: xmm_reg = [\"xmm11\"] % x86_64_only,\n+        xmm12: xmm_reg = [\"xmm12\"] % x86_64_only,\n+        xmm13: xmm_reg = [\"xmm13\"] % x86_64_only,\n+        xmm14: xmm_reg = [\"xmm14\"] % x86_64_only,\n+        xmm15: xmm_reg = [\"xmm15\"] % x86_64_only,\n+        ymm0: ymm_reg = [\"ymm0\"],\n+        ymm1: ymm_reg = [\"ymm1\"],\n+        ymm2: ymm_reg = [\"ymm2\"],\n+        ymm3: ymm_reg = [\"ymm3\"],\n+        ymm4: ymm_reg = [\"ymm4\"],\n+        ymm5: ymm_reg = [\"ymm5\"],\n+        ymm6: ymm_reg = [\"ymm6\"],\n+        ymm7: ymm_reg = [\"ymm7\"],\n+        ymm8: ymm_reg = [\"ymm8\"] % x86_64_only,\n+        ymm9: ymm_reg = [\"ymm9\"] % x86_64_only,\n+        ymm10: ymm_reg = [\"ymm10\"] % x86_64_only,\n+        ymm11: ymm_reg = [\"ymm11\"] % x86_64_only,\n+        ymm12: ymm_reg = [\"ymm12\"] % x86_64_only,\n+        ymm13: ymm_reg = [\"ymm13\"] % x86_64_only,\n+        ymm14: ymm_reg = [\"ymm14\"] % x86_64_only,\n+        ymm15: ymm_reg = [\"ymm15\"] % x86_64_only,\n+        zmm0: zmm_reg = [\"zmm0\"],\n+        zmm1: zmm_reg = [\"zmm1\"],\n+        zmm2: zmm_reg = [\"zmm2\"],\n+        zmm3: zmm_reg = [\"zmm3\"],\n+        zmm4: zmm_reg = [\"zmm4\"],\n+        zmm5: zmm_reg = [\"zmm5\"],\n+        zmm6: zmm_reg = [\"zmm6\"],\n+        zmm7: zmm_reg = [\"zmm7\"],\n+        zmm8: zmm_reg = [\"zmm8\"] % x86_64_only,\n+        zmm9: zmm_reg = [\"zmm9\"] % x86_64_only,\n+        zmm10: zmm_reg = [\"zmm10\"] % x86_64_only,\n+        zmm11: zmm_reg = [\"zmm11\"] % x86_64_only,\n+        zmm12: zmm_reg = [\"zmm12\"] % x86_64_only,\n+        zmm13: zmm_reg = [\"zmm13\"] % x86_64_only,\n+        zmm14: zmm_reg = [\"zmm14\"] % x86_64_only,\n+        zmm15: zmm_reg = [\"zmm15\"] % x86_64_only,\n+        zmm16: zmm_reg = [\"zmm16\", \"xmm16\", \"ymm16\"] % x86_64_only,\n+        zmm17: zmm_reg = [\"zmm17\", \"xmm17\", \"ymm17\"] % x86_64_only,\n+        zmm18: zmm_reg = [\"zmm18\", \"xmm18\", \"ymm18\"] % x86_64_only,\n+        zmm19: zmm_reg = [\"zmm19\", \"xmm19\", \"ymm19\"] % x86_64_only,\n+        zmm20: zmm_reg = [\"zmm20\", \"xmm20\", \"ymm20\"] % x86_64_only,\n+        zmm21: zmm_reg = [\"zmm21\", \"xmm21\", \"ymm21\"] % x86_64_only,\n+        zmm22: zmm_reg = [\"zmm22\", \"xmm22\", \"ymm22\"] % x86_64_only,\n+        zmm23: zmm_reg = [\"zmm23\", \"xmm23\", \"ymm23\"] % x86_64_only,\n+        zmm24: zmm_reg = [\"zmm24\", \"xmm24\", \"ymm24\"] % x86_64_only,\n+        zmm25: zmm_reg = [\"zmm25\", \"xmm25\", \"ymm25\"] % x86_64_only,\n+        zmm26: zmm_reg = [\"zmm26\", \"xmm26\", \"ymm26\"] % x86_64_only,\n+        zmm27: zmm_reg = [\"zmm27\", \"xmm27\", \"ymm27\"] % x86_64_only,\n+        zmm28: zmm_reg = [\"zmm28\", \"xmm28\", \"ymm28\"] % x86_64_only,\n+        zmm29: zmm_reg = [\"zmm29\", \"xmm29\", \"ymm29\"] % x86_64_only,\n+        zmm30: zmm_reg = [\"zmm30\", \"xmm30\", \"ymm30\"] % x86_64_only,\n+        zmm31: zmm_reg = [\"zmm31\", \"xmm31\", \"ymm31\"] % x86_64_only,\n+        k1: kreg = [\"k1\"],\n+        k2: kreg = [\"k2\"],\n+        k3: kreg = [\"k3\"],\n+        k4: kreg = [\"k4\"],\n+        k5: kreg = [\"k5\"],\n+        k6: kreg = [\"k6\"],\n+        k7: kreg = [\"k7\"],\n+        #error = [\"bp\", \"bpl\", \"ebp\", \"rbp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"sp\", \"spl\", \"esp\", \"rsp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"ip\", \"eip\", \"rip\"] =>\n+            \"the instruction pointer cannot be used as an operand for inline asm\",\n+        #error = [\"st\", \"st(0)\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\"] =>\n+            \"x87 registers are not currently supported as operands for inline asm\",\n+        #error = [\"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\"] =>\n+            \"MMX registers are not currently supported as operands for inline asm\",\n+        #error = [\"k0\"] =>\n+            \"the k0 AVX mask register cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl X86InlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        arch: InlineAsmArch,\n+        modifier: Option<char>,\n+    ) -> fmt::Result {\n+        let reg_default_modifier = match arch {\n+            InlineAsmArch::X86 => 'e',\n+            InlineAsmArch::X86_64 => 'r',\n+            _ => unreachable!(),\n+        };\n+        if self as u32 <= Self::dx as u32 {\n+            let root = ['a', 'b', 'c', 'd'][self as usize - Self::ax as usize];\n+            match modifier.unwrap_or(reg_default_modifier) {\n+                'l' => write!(out, \"{}l\", root),\n+                'h' => write!(out, \"{}h\", root),\n+                'x' => write!(out, \"{}x\", root),\n+                'e' => write!(out, \"e{}x\", root),\n+                'r' => write!(out, \"r{}x\", root),\n+                _ => unreachable!(),\n+            }\n+        } else if self as u32 <= Self::di as u32 {\n+            let root = self.name();\n+            match modifier.unwrap_or(reg_default_modifier) {\n+                'l' => write!(out, \"{}l\", root),\n+                'x' => write!(out, \"{}\", root),\n+                'e' => write!(out, \"e{}\", root),\n+                'r' => write!(out, \"r{}\", root),\n+                _ => unreachable!(),\n+            }\n+        } else if self as u32 <= Self::r15 as u32 {\n+            let root = self.name();\n+            match modifier.unwrap_or(reg_default_modifier) {\n+                'l' => write!(out, \"{}b\", root),\n+                'x' => write!(out, \"{}w\", root),\n+                'e' => write!(out, \"{}d\", root),\n+                'r' => out.write_str(root),\n+                _ => unreachable!(),\n+            }\n+        } else if self as u32 <= Self::r15b as u32 {\n+            out.write_str(self.name())\n+        } else if self as u32 <= Self::xmm15 as u32 {\n+            let prefix = modifier.unwrap_or('x');\n+            let index = self as u32 - Self::xmm0 as u32;\n+            write!(out, \"{}{}\", prefix, index)\n+        } else if self as u32 <= Self::ymm15 as u32 {\n+            let prefix = modifier.unwrap_or('y');\n+            let index = self as u32 - Self::ymm0 as u32;\n+            write!(out, \"{}{}\", prefix, index)\n+        } else if self as u32 <= Self::zmm31 as u32 {\n+            let prefix = modifier.unwrap_or('z');\n+            let index = self as u32 - Self::zmm0 as u32;\n+            write!(out, \"{}{}\", prefix, index)\n+        } else {\n+            out.write_str(self.name())\n+        }\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(X86InlineAsmReg)) {\n+        macro_rules! reg_conflicts {\n+            (\n+                $(\n+                    $w:ident : $l:ident $h:ident\n+                ),*;\n+                $(\n+                    $w2:ident : $l2:ident\n+                ),*;\n+                $(\n+                    $x:ident : $y:ident : $z:ident\n+                ),*;\n+            ) => {\n+                match self {\n+                    $(\n+                        Self::$w => {\n+                            cb(Self::$w);\n+                            cb(Self::$l);\n+                            cb(Self::$h);\n+                        }\n+                        Self::$l => {\n+                            cb(Self::$w);\n+                            cb(Self::$l);\n+                        }\n+                        Self::$h => {\n+                            cb(Self::$w);\n+                            cb(Self::$h);\n+                        }\n+                    )*\n+                    $(\n+                        Self::$w2 | Self::$l2 => {\n+                            cb(Self::$w2);\n+                            cb(Self::$l2);\n+                        }\n+                    )*\n+                    $(\n+                        Self::$x | Self::$y | Self::$z => {\n+                            cb(Self::$x);\n+                            cb(Self::$y);\n+                            cb(Self::$z);\n+                        }\n+                    )*\n+                    r => cb(r),\n+                }\n+            };\n+        }\n+\n+        // XMM*, YMM* and ZMM* are all different views of the same register.\n+        //\n+        // See section 15.5 of the combined Intel\u00ae 64 and IA-32 Architectures\n+        // Software Developer\u2019s Manual for more details.\n+        //\n+        // We don't need to specify conflicts for [x,y,z]mm[16-31] since these\n+        // registers are only available with AVX-512, so we just specify them\n+        // as aliases directly.\n+        reg_conflicts! {\n+            ax : al ah,\n+            bx : bl bh,\n+            cx : cl ch,\n+            dx : dl dh;\n+            si : sil,\n+            di : dil,\n+            r8 : r8b,\n+            r9 : r9b,\n+            r10 : r10b,\n+            r11 : r11b,\n+            r12 : r12b,\n+            r13 : r13b,\n+            r14 : r14b,\n+            r15 : r15b;\n+            xmm0 : ymm0 : zmm0,\n+            xmm1 : ymm1 : zmm1,\n+            xmm2 : ymm2 : zmm2,\n+            xmm3 : ymm3 : zmm3,\n+            xmm4 : ymm4 : zmm4,\n+            xmm5 : ymm5 : zmm5,\n+            xmm6 : ymm6 : zmm6,\n+            xmm7 : ymm7 : zmm7,\n+            xmm8 : ymm8 : zmm8,\n+            xmm9 : ymm9 : zmm9,\n+            xmm10 : ymm10 : zmm10,\n+            xmm11 : ymm11 : zmm11,\n+            xmm12 : ymm12 : zmm12,\n+            xmm13 : ymm13 : zmm13,\n+            xmm14 : ymm14 : zmm14,\n+            xmm15 : ymm15 : zmm15;\n+        }\n+    }\n+}"}, {"sha": "c2cdd2fd3ecf615b5fc3a6d3796244b3f338379f", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -25,6 +25,7 @@ extern crate rustc_macros;\n extern crate log;\n \n pub mod abi;\n+pub mod asm;\n pub mod spec;\n \n /// Requirements for a `StableHashingContext` to be used in this crate."}, {"sha": "bd58e86988a00a3eaebec1bc95f3ba90ae55a4d1", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1746,6 +1746,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ObligationCauseCode::ConstSized => {\n                 err.note(\"constant expressions must have a statically known size\");\n             }\n+            ObligationCauseCode::InlineAsmSized => {\n+                err.note(\"all inline asm arguments must have a statically known size\");\n+            }\n             ObligationCauseCode::ConstPatternStructural => {\n                 err.note(\"constants used for pattern-matching must derive `PartialEq` and `Eq`\");\n             }"}, {"sha": "7e66e08f7e6a663194efcc4b7145e1263b05caee", "filename": "src/librustc_trait_selection/traits/on_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,4 +1,4 @@\n-use fmt_macros::{Parser, Piece, Position};\n+use fmt_macros::{ParseMode, Parser, Piece, Position};\n \n use rustc_ast::ast::{MetaItem, NestedMetaItem};\n use rustc_attr as attr;\n@@ -272,7 +272,7 @@ impl<'tcx> OnUnimplementedFormatString {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let s = self.0.as_str();\n-        let parser = Parser::new(&s, None, vec![], false);\n+        let parser = Parser::new(&s, None, None, false, ParseMode::Format);\n         let mut result = Ok(());\n         for token in parser {\n             match token {\n@@ -350,7 +350,7 @@ impl<'tcx> OnUnimplementedFormatString {\n         let empty_string = String::new();\n \n         let s = self.0.as_str();\n-        let parser = Parser::new(&s, None, vec![], false);\n+        let parser = Parser::new(&s, None, None, false, ParseMode::Format);\n         let item_context = (options.get(&sym::item_context)).unwrap_or(&empty_string);\n         parser\n             .map(|p| match p {"}, {"sha": "266e9b21d69a99e8d53e2f55c38b5d4f2209e580", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -232,6 +232,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr),\n+            ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n             ExprKind::LlvmInlineAsm(ref asm) => {\n                 for expr in asm.outputs_exprs.iter().chain(asm.inputs_exprs.iter()) {\n                     self.check_expr(expr);\n@@ -1811,6 +1812,72 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn check_expr_asm_operand(&self, expr: &'tcx hir::Expr<'tcx>, is_input: bool) {\n+        let needs = if is_input { Needs::None } else { Needs::MutPlace };\n+        let ty = self.check_expr_with_needs(expr, needs);\n+        self.require_type_is_sized(ty, expr.span, traits::InlineAsmSized);\n+\n+        if !is_input && !expr.is_syntactic_place_expr() {\n+            let mut err = self.tcx.sess.struct_span_err(expr.span, \"invalid asm output\");\n+            err.span_label(expr.span, \"cannot assign to this expression\");\n+            err.emit();\n+        }\n+\n+        // If this is an input value, we require its type to be fully resolved\n+        // at this point. This allows us to provide helpful coercions which help\n+        // pass the type whitelist in a later pass.\n+        //\n+        // We don't require output types to be resolved at this point, which\n+        // allows them to be inferred based on how they are used later in the\n+        // function.\n+        if is_input {\n+            let ty = self.structurally_resolved_type(expr.span, &ty);\n+            match ty.kind {\n+                ty::FnDef(..) => {\n+                    let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));\n+                    self.demand_coerce(expr, ty, fnptr_ty, AllowTwoPhase::No);\n+                }\n+                ty::Ref(_, base_ty, mutbl) => {\n+                    let ptr_ty = self.tcx.mk_ptr(ty::TypeAndMut { ty: base_ty, mutbl });\n+                    self.demand_coerce(expr, ty, ptr_ty, AllowTwoPhase::No);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn check_expr_asm(&self, asm: &'tcx hir::InlineAsm<'tcx>) -> Ty<'tcx> {\n+        for op in asm.operands {\n+            match op {\n+                hir::InlineAsmOperand::In { expr, .. } | hir::InlineAsmOperand::Const { expr } => {\n+                    self.check_expr_asm_operand(expr, true);\n+                }\n+                hir::InlineAsmOperand::Out { expr, .. } => {\n+                    if let Some(expr) = expr {\n+                        self.check_expr_asm_operand(expr, false);\n+                    }\n+                }\n+                hir::InlineAsmOperand::InOut { expr, .. } => {\n+                    self.check_expr_asm_operand(expr, false);\n+                }\n+                hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                    self.check_expr_asm_operand(in_expr, true);\n+                    if let Some(out_expr) = out_expr {\n+                        self.check_expr_asm_operand(out_expr, false);\n+                    }\n+                }\n+                hir::InlineAsmOperand::Sym { expr } => {\n+                    self.check_expr(expr);\n+                }\n+            }\n+        }\n+        if asm.options.contains(ast::InlineAsmOptions::NORETURN) {\n+            self.tcx.types.never\n+        } else {\n+            self.tcx.mk_unit()\n+        }\n+    }\n }\n \n pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {"}, {"sha": "fe3028102c6858b7ee7051192349a0286aab1cda", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -2279,6 +2279,7 @@ fn from_target_feature(\n                 Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n                 Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n                 Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n+                Some(sym::riscv_target_feature) => rust_features.riscv_target_feature,\n                 Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n                 Some(sym::mmx_target_feature) => rust_features.mmx_target_feature,\n                 Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,"}, {"sha": "9ba00faec4978ea47246e6719a670eb763310e12", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -220,6 +220,30 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.borrow_expr(&base, bk);\n             }\n \n+            hir::ExprKind::InlineAsm(ref asm) => {\n+                for op in asm.operands {\n+                    match op {\n+                        hir::InlineAsmOperand::In { expr, .. }\n+                        | hir::InlineAsmOperand::Const { expr, .. }\n+                        | hir::InlineAsmOperand::Sym { expr, .. } => self.consume_expr(expr),\n+                        hir::InlineAsmOperand::Out { expr, .. } => {\n+                            if let Some(expr) = expr {\n+                                self.mutate_expr(expr);\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { expr, .. } => {\n+                            self.mutate_expr(expr);\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                            self.consume_expr(in_expr);\n+                            if let Some(out_expr) = out_expr {\n+                                self.mutate_expr(out_expr);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n             hir::ExprKind::LlvmInlineAsm(ref ia) => {\n                 for (o, output) in ia.inner.outputs.iter().zip(ia.outputs_exprs) {\n                     if o.is_indirect {"}, {"sha": "71f3e2d03c9ff79f6b6076746d70ba82a6dfb5af", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -405,6 +405,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | hir::ExprKind::Continue(..)\n             | hir::ExprKind::Struct(..)\n             | hir::ExprKind::Repeat(..)\n+            | hir::ExprKind::InlineAsm(..)\n             | hir::ExprKind::LlvmInlineAsm(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::Err => Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty)),"}, {"sha": "246dfcd1c864d4eab417f74d3599f061d01cb3ae", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1 +1 @@\n-Subproject commit 3ba91917e52bd66ac37161ad4a1bc87d32aa2e18\n+Subproject commit 246dfcd1c864d4eab417f74d3599f061d01cb3ae"}, {"sha": "b988d06871bf6c8d64f2b7d0af349fb32c5c0fe5", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -203,6 +203,10 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n     return Attribute::OptimizeNone;\n   case ReturnsTwice:\n     return Attribute::ReturnsTwice;\n+  case ReadNone:\n+    return Attribute::ReadNone;\n+  case InaccessibleMemOnly:\n+    return Attribute::InaccessibleMemOnly;\n   }\n   report_fatal_error(\"bad AttributeKind\");\n }"}, {"sha": "da48048113bc218f6fb7464e9bd190be589aa1fc", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -82,6 +82,8 @@ enum LLVMRustAttribute {\n   NonLazyBind = 23,\n   OptimizeNone = 24,\n   ReturnsTwice = 25,\n+  ReadNone = 26,\n+  InaccessibleMemOnly = 27,\n };\n \n typedef struct OpaqueRustString *RustStringRef;"}, {"sha": "c2484e9b6d0a686c640bfa2ad990f49a52e08349", "filename": "src/test/assembly/asm/aarch64-modifiers.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Faarch64-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Faarch64-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Faarch64-modifiers.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,145 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: -O\n+// compile-flags: --target aarch64-unknown-linux-gnu\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+impl Copy for i32 {}\n+\n+macro_rules! check {\n+    ($func:ident $reg:ident $code:literal) => {\n+        // -O and extern \"C\" guarantee that the selected register is always r0/s0/d0/q0\n+        #[no_mangle]\n+        pub unsafe extern \"C\" fn $func() -> i32 {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!($code, out($reg) y);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg:\n+// CHECK: //APP\n+// CHECK: mov x0, x0\n+// CHECK: //NO_APP\n+check!(reg reg \"mov {0}, {0}\");\n+\n+// CHECK-LABEL: reg_w:\n+// CHECK: //APP\n+// CHECK: mov w0, w0\n+// CHECK: //NO_APP\n+check!(reg_w reg \"mov {0:w}, {0:w}\");\n+\n+// CHECK-LABEL: reg_x:\n+// CHECK: //APP\n+// CHECK: mov x0, x0\n+// CHECK: //NO_APP\n+check!(reg_x reg \"mov {0:x}, {0:x}\");\n+\n+// CHECK-LABEL: vreg:\n+// CHECK: //APP\n+// CHECK: add v0.4s, v0.4s, v0.4s\n+// CHECK: //NO_APP\n+check!(vreg vreg \"add {0}.4s, {0}.4s, {0}.4s\");\n+\n+// CHECK-LABEL: vreg_b:\n+// CHECK: //APP\n+// CHECK: ldr b0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_b vreg \"ldr {:b}, [x0]\");\n+\n+// CHECK-LABEL: vreg_h:\n+// CHECK: //APP\n+// CHECK: ldr h0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_h vreg \"ldr {:h}, [x0]\");\n+\n+// CHECK-LABEL: vreg_s:\n+// CHECK: //APP\n+// CHECK: ldr s0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_s vreg \"ldr {:s}, [x0]\");\n+\n+// CHECK-LABEL: vreg_d:\n+// CHECK: //APP\n+// CHECK: ldr d0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_d vreg \"ldr {:d}, [x0]\");\n+\n+// CHECK-LABEL: vreg_q:\n+// CHECK: //APP\n+// CHECK: ldr q0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_q vreg \"ldr {:q}, [x0]\");\n+\n+// CHECK-LABEL: vreg_v:\n+// CHECK: //APP\n+// CHECK: add v0.4s, v0.4s, v0.4s\n+// CHECK: //NO_APP\n+check!(vreg_v vreg \"add {0:v}.4s, {0:v}.4s, {0:v}.4s\");\n+\n+// CHECK-LABEL: vreg_low16:\n+// CHECK: //APP\n+// CHECK: add v0.4s, v0.4s, v0.4s\n+// CHECK: //NO_APP\n+check!(vreg_low16 vreg_low16 \"add {0}.4s, {0}.4s, {0}.4s\");\n+\n+// CHECK-LABEL: vreg_low16_b:\n+// CHECK: //APP\n+// CHECK: ldr b0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_low16_b vreg_low16 \"ldr {:b}, [x0]\");\n+\n+// CHECK-LABEL: vreg_low16_h:\n+// CHECK: //APP\n+// CHECK: ldr h0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_low16_h vreg_low16 \"ldr {:h}, [x0]\");\n+\n+// CHECK-LABEL: vreg_low16_s:\n+// CHECK: //APP\n+// CHECK: ldr s0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_low16_s vreg_low16 \"ldr {:s}, [x0]\");\n+\n+// CHECK-LABEL: vreg_low16_d:\n+// CHECK: //APP\n+// CHECK: ldr d0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_low16_d vreg_low16 \"ldr {:d}, [x0]\");\n+\n+// CHECK-LABEL: vreg_low16_q:\n+// CHECK: //APP\n+// CHECK: ldr q0, [x0]\n+// CHECK: //NO_APP\n+check!(vreg_low16_q vreg_low16 \"ldr {:q}, [x0]\");\n+\n+// CHECK-LABEL: vreg_low16_v:\n+// CHECK: //APP\n+// CHECK: add v0.4s, v0.4s, v0.4s\n+// CHECK: //NO_APP\n+check!(vreg_low16_v vreg_low16 \"add {0:v}.4s, {0:v}.4s, {0:v}.4s\");"}, {"sha": "ce2f0082a06b15c18d6805c1d4f11769c0ec7a36", "filename": "src/test/assembly/asm/aarch64-types.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,381 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: --target aarch64-unknown-linux-gnu\n+\n+#![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register, non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *mut u8;\n+\n+#[repr(simd)]\n+pub struct i8x8(i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+pub struct i16x4(i16, i16, i16, i16);\n+#[repr(simd)]\n+pub struct i32x2(i32, i32);\n+#[repr(simd)]\n+pub struct i64x1(i64);\n+#[repr(simd)]\n+pub struct f32x2(f32, f32);\n+#[repr(simd)]\n+pub struct f64x1(f64);\n+#[repr(simd)]\n+pub struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+pub struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+pub struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+pub struct i64x2(i64, i64);\n+#[repr(simd)]\n+pub struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+pub struct f64x2(f64, f64);\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for i64 {}\n+impl Copy for f64 {}\n+impl Copy for ptr {}\n+impl Copy for i8x8 {}\n+impl Copy for i16x4 {}\n+impl Copy for i32x2 {}\n+impl Copy for i64x1 {}\n+impl Copy for f32x2 {}\n+impl Copy for f64x1 {}\n+impl Copy for i8x16 {}\n+impl Copy for i16x8 {}\n+impl Copy for i32x4 {}\n+impl Copy for i64x2 {}\n+impl Copy for f32x4 {}\n+impl Copy for f64x2 {}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: u8;\n+}\n+\n+// CHECK-LABEL: sym_fn:\n+// CHECK: //APP\n+// CHECK: bl extern_func\n+// CHECK: //NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"bl {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static:\n+// CHECK: //APP\n+// CHECK: adr x0, extern_static\n+// CHECK: //NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() {\n+    asm!(\"adr x0, {}\", sym extern_static);\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident $mov:literal $modifier:literal) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(\n+                concat!($mov, \" {:\", $modifier, \"}, {:\", $modifier, \"}\"),\n+                out($class) y,\n+                in($class) x\n+            );\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: //APP\n+// CHECK: mov x{{[0-9]+}}, x{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(reg_i8 i8 reg \"mov\" \"\");\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: //APP\n+// CHECK: mov x{{[0-9]+}}, x{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(reg_i16 i16 reg \"mov\" \"\");\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: //APP\n+// CHECK: mov x{{[0-9]+}}, x{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(reg_i32 i32 reg \"mov\" \"\");\n+\n+// CHECK-LABEL: reg_f32:\n+// CHECK: //APP\n+// CHECK: mov x{{[0-9]+}}, x{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(reg_f32 f32 reg \"mov\" \"\");\n+\n+// CHECK-LABEL: reg_i64:\n+// CHECK: //APP\n+// CHECK: mov x{{[0-9]+}}, x{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(reg_i64 i64 reg \"mov\" \"\");\n+\n+// CHECK-LABEL: reg_f64:\n+// CHECK: //APP\n+// CHECK: mov x{{[0-9]+}}, x{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(reg_f64 f64 reg \"mov\" \"\");\n+\n+// CHECK-LABEL: reg_ptr:\n+// CHECK: //APP\n+// CHECK: mov x{{[0-9]+}}, x{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(reg_ptr ptr reg \"mov\" \"\");\n+\n+// CHECK-LABEL: vreg_i8:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i8 i8 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i16:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i16 i16 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i32:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i32 i32 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_f32:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_f32 f32 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i64:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i64 i64 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_f64:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_f64 f64 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_ptr:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_ptr ptr vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i8x8:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i8x8 i8x8 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i16x4:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i16x4 i16x4 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i32x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i32x2 i32x2 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i64x1:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i64x1 i64x1 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_f32x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_f32x2 f32x2 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_f64x1:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_f64x1 f64x1 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i8x16:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i8x16 i8x16 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i16x8:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i16x8 i16x8 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i32x4:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i32x4 i32x4 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_i64x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_i64x2 i64x2 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_f32x4:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_f32x4 f32x4 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_f64x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_f64x2 f64x2 vreg \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i8:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i8 i8 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i16:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i16 i16 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_f32:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_f32 f32 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i64:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i64 i64 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_f64:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_f64 f64 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_ptr:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_ptr ptr vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i8x8:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i8x8 i8x8 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i16x4:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i16x4 i16x4 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i32x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i32x2 i32x2 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i64x1:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i64x1 i64x1 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_f32x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_f32x2 f32x2 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_f64x1:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_f64x1 f64x1 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i8x16:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i8x16 i8x16 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i16x8:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i16x8 i16x8 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i32x4:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i32x4 i32x4 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_i64x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_i64x2 i64x2 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_f32x4:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_f32x4 f32x4 vreg_low16 \"fmov\" \"s\");\n+\n+// CHECK-LABEL: vreg_low16_f64x2:\n+// CHECK: //APP\n+// CHECK: fmov s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: //NO_APP\n+check!(vreg_low16_f64x2 f64x2 vreg_low16 \"fmov\" \"s\");"}, {"sha": "b71503d0a535e6f5b4339aeee8449769166839e8", "filename": "src/test/assembly/asm/arm-modifiers.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Farm-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Farm-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Farm-modifiers.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,150 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: -O\n+// compile-flags: --target armv7-unknown-linux-gnueabihf\n+// compile-flags: -C target-feature=+neon\n+\n+#![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register, non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+#[repr(simd)]\n+pub struct f32x4(f32, f32, f32, f32);\n+\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for f64 {}\n+impl Copy for f32x4 {}\n+\n+macro_rules! check {\n+    ($func:ident $modifier:literal $reg:ident $ty:ident $mov:literal) => {\n+        // -O and extern \"C\" guarantee that the selected register is always r0/s0/d0/q0\n+        #[no_mangle]\n+        pub unsafe extern \"C\" fn $func() -> $ty {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(concat!($mov, \" {0:\", $modifier, \"}, {0:\", $modifier, \"}\"), out($reg) y);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg:\n+// CHECK: @APP\n+// CHECK: mov r0, r0\n+// CHECK: @NO_APP\n+check!(reg \"\" reg i32 \"mov\");\n+\n+// CHECK-LABEL: reg_thumb:\n+// CHECK: @APP\n+// CHECK: mov r0, r0\n+// CHECK: @NO_APP\n+check!(reg_thumb \"\" reg_thumb i32 \"mov\");\n+\n+// CHECK-LABEL: sreg:\n+// CHECK: @APP\n+// CHECK: vmov.f32 s0, s0\n+// CHECK: @NO_APP\n+check!(sreg \"\" sreg f32 \"vmov.f32\");\n+\n+// CHECK-LABEL: sreg_low16:\n+// CHECK: @APP\n+// CHECK: vmov.f32 s0, s0\n+// CHECK: @NO_APP\n+check!(sreg_low16 \"\" sreg_low16 f32 \"vmov.f32\");\n+\n+// CHECK-LABEL: dreg:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d0, d0\n+// CHECK: @NO_APP\n+check!(dreg \"\" dreg f64 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d0, d0\n+// CHECK: @NO_APP\n+check!(dreg_low16 \"\" dreg_low16 f64 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d0, d0\n+// CHECK: @NO_APP\n+check!(dreg_low8 \"\" dreg_low8 f64 \"vmov.f64\");\n+\n+// CHECK-LABEL: qreg:\n+// CHECK: @APP\n+// CHECK: vorr q0, q0, q0\n+// CHECK: @NO_APP\n+check!(qreg \"\" qreg f32x4 \"vmov\");\n+\n+// CHECK-LABEL: qreg_e:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d0, d0\n+// CHECK: @NO_APP\n+check!(qreg_e \"e\" qreg f32x4 \"vmov.f64\");\n+\n+// CHECK-LABEL: qreg_f:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d1, d1\n+// CHECK: @NO_APP\n+check!(qreg_f \"f\" qreg f32x4 \"vmov.f64\");\n+\n+// CHECK-LABEL: qreg_low8:\n+// CHECK: @APP\n+// CHECK: vorr q0, q0, q0\n+// CHECK: @NO_APP\n+check!(qreg_low8 \"\" qreg_low8 f32x4 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low8_e:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d0, d0\n+// CHECK: @NO_APP\n+check!(qreg_low8_e \"e\" qreg_low8 f32x4 \"vmov.f64\");\n+\n+// CHECK-LABEL: qreg_low8_f:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d1, d1\n+// CHECK: @NO_APP\n+check!(qreg_low8_f \"f\" qreg_low8 f32x4 \"vmov.f64\");\n+\n+// CHECK-LABEL: qreg_low4:\n+// CHECK: @APP\n+// CHECK: vorr q0, q0, q0\n+// CHECK: @NO_APP\n+check!(qreg_low4 \"\" qreg_low4 f32x4 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low4_e:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d0, d0\n+// CHECK: @NO_APP\n+check!(qreg_low4_e \"e\" qreg_low4 f32x4 \"vmov.f64\");\n+\n+// CHECK-LABEL: qreg_low4_f:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d1, d1\n+// CHECK: @NO_APP\n+check!(qreg_low4_f \"f\" qreg_low4 f32x4 \"vmov.f64\");"}, {"sha": "1e338f56c4dd7733b20b952a0d57855c45eece5c", "filename": "src/test/assembly/asm/arm-types.rs", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Farm-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Farm-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Farm-types.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,414 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: --target armv7-unknown-linux-gnueabihf\n+// compile-flags: -C target-feature=+neon\n+\n+#![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register, non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *mut u8;\n+\n+#[repr(simd)]\n+pub struct i8x8(i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+pub struct i16x4(i16, i16, i16, i16);\n+#[repr(simd)]\n+pub struct i32x2(i32, i32);\n+#[repr(simd)]\n+pub struct i64x1(i64);\n+#[repr(simd)]\n+pub struct f32x2(f32, f32);\n+#[repr(simd)]\n+pub struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+pub struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+pub struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+pub struct i64x2(i64, i64);\n+#[repr(simd)]\n+pub struct f32x4(f32, f32, f32, f32);\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for i64 {}\n+impl Copy for f64 {}\n+impl Copy for ptr {}\n+impl Copy for i8x8 {}\n+impl Copy for i16x4 {}\n+impl Copy for i32x2 {}\n+impl Copy for i64x1 {}\n+impl Copy for f32x2 {}\n+impl Copy for i8x16 {}\n+impl Copy for i16x8 {}\n+impl Copy for i32x4 {}\n+impl Copy for i64x2 {}\n+impl Copy for f32x4 {}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: u8;\n+}\n+\n+// CHECK-LABEL: sym_fn:\n+// CHECK: @APP\n+// CHECK: bl extern_func\n+// CHECK: @NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"bl {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static:\n+// CHECK: @APP\n+// CHECK: adr r0, extern_static\n+// CHECK: @NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() {\n+    asm!(\"adr r0, {}\", sym extern_static);\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident $mov:literal) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(concat!($mov, \" {}, {}\"), out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_i8 i8 reg \"mov\");\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_i16 i16 reg \"mov\");\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_i32 i32 reg \"mov\");\n+\n+// CHECK-LABEL: reg_f32:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_f32 f32 reg \"mov\");\n+\n+// CHECK-LABEL: reg_ptr:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_ptr ptr reg \"mov\");\n+\n+// CHECK-LABEL: reg_thumb_i8:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_thumb_i8 i8 reg_thumb \"mov\");\n+\n+// CHECK-LABEL: reg_thumb_i16:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_thumb_i16 i16 reg_thumb \"mov\");\n+\n+// CHECK-LABEL: reg_thumb_i32:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_thumb_i32 i32 reg_thumb \"mov\");\n+\n+// CHECK-LABEL: reg_thumb_f32:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_thumb_f32 f32 reg_thumb \"mov\");\n+\n+// CHECK-LABEL: reg_thumb_ptr:\n+// CHECK: @APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: @NO_APP\n+check!(reg_thumb_ptr ptr reg_thumb \"mov\");\n+\n+// CHECK-LABEL: sreg_i32:\n+// CHECK: @APP\n+// CHECK: vmov.f32 s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(sreg_i32 i32 sreg \"vmov.f32\");\n+\n+// CHECK-LABEL: sreg_f32:\n+// CHECK: @APP\n+// CHECK: vmov.f32 s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(sreg_f32 f32 sreg \"vmov.f32\");\n+\n+// CHECK-LABEL: sreg_ptr:\n+// CHECK: @APP\n+// CHECK: vmov.f32 s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(sreg_ptr ptr sreg \"vmov.f32\");\n+\n+// CHECK-LABEL: sreg_low16_i32:\n+// CHECK: @APP\n+// CHECK: vmov.f32 s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(sreg_low16_i32 i32 sreg_low16 \"vmov.f32\");\n+\n+// CHECK-LABEL: sreg_low16_f32:\n+// CHECK: @APP\n+// CHECK: vmov.f32 s{{[0-9]+}}, s{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(sreg_low16_f32 f32 sreg_low16 \"vmov.f32\");\n+\n+// CHECK-LABEL: dreg_i64:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_i64 i64 dreg \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_f64:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_f64 f64 dreg \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_i8x8:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_i8x8 i8x8 dreg \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_i16x4:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_i16x4 i16x4 dreg \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_i32x2:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_i32x2 i32x2 dreg \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_i64x1:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_i64x1 i64x1 dreg \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_f32x2:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_f32x2 f32x2 dreg \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16_i64:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low16_i64 i64 dreg_low16 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16_f64:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low16_f64 f64 dreg_low16 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16_i8x8:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low16_i8x8 i8x8 dreg_low16 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16_i16x4:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low16_i16x4 i16x4 dreg_low16 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16_i32x2:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low16_i32x2 i32x2 dreg_low16 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16_i64x1:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low16_i64x1 i64x1 dreg_low16 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low16_f32x2:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low16_f32x2 f32x2 dreg_low16 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8_i64:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low8_i64 i64 dreg_low8 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8_f64:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low8_f64 f64 dreg_low8 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8_i8x8:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low8_i8x8 i8x8 dreg_low8 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8_i16x4:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low8_i16x4 i16x4 dreg_low8 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8_i32x2:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low8_i32x2 i32x2 dreg_low8 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8_i64x1:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low8_i64x1 i64x1 dreg_low8 \"vmov.f64\");\n+\n+// CHECK-LABEL: dreg_low8_f32x2:\n+// CHECK: @APP\n+// CHECK: vmov.f64 d{{[0-9]+}}, d{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(dreg_low8_f32x2 f32x2 dreg_low8 \"vmov.f64\");\n+\n+// CHECK-LABEL: qreg_i8x16:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_i8x16 i8x16 qreg \"vmov\");\n+\n+// CHECK-LABEL: qreg_i16x8:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_i16x8 i16x8 qreg \"vmov\");\n+\n+// CHECK-LABEL: qreg_i32x4:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_i32x4 i32x4 qreg \"vmov\");\n+\n+// CHECK-LABEL: qreg_i64x2:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_i64x2 i64x2 qreg \"vmov\");\n+\n+// CHECK-LABEL: qreg_f32x4:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_f32x4 f32x4 qreg \"vmov\");\n+\n+// CHECK-LABEL: qreg_low8_i8x16:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low8_i8x16 i8x16 qreg_low8 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low8_i16x8:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low8_i16x8 i16x8 qreg_low8 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low8_i32x4:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low8_i32x4 i32x4 qreg_low8 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low8_i64x2:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low8_i64x2 i64x2 qreg_low8 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low8_f32x4:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low8_f32x4 f32x4 qreg_low8 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low4_i8x16:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low4_i8x16 i8x16 qreg_low4 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low4_i16x8:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low4_i16x8 i16x8 qreg_low4 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low4_i32x4:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low4_i32x4 i32x4 qreg_low4 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low4_i64x2:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low4_i64x2 i64x2 qreg_low4 \"vmov\");\n+\n+// CHECK-LABEL: qreg_low4_f32x4:\n+// CHECK: @APP\n+// CHECK: vorr q{{[0-9]+}}, q{{[0-9]+}}, q{{[0-9]+}}\n+// CHECK: @NO_APP\n+check!(qreg_low4_f32x4 f32x4 qreg_low4 \"vmov\");"}, {"sha": "8c816e3220b74ca1d1d1d36e18cb1a742d3c5295", "filename": "src/test/assembly/asm/riscv-modifiers.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Friscv-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Friscv-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Friscv-modifiers.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,59 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: -O\n+// compile-flags: --target riscv64gc-unknown-linux-gnu\n+// compile-flags: -C target-feature=+f\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+impl Copy for f32 {}\n+\n+macro_rules! check {\n+    ($func:ident $modifier:literal $reg:ident $mov:literal) => {\n+        // -O and extern \"C\" guarantee that the selected register is always r0/s0/d0/q0\n+        #[no_mangle]\n+        pub unsafe extern \"C\" fn $func() -> f32 {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(concat!($mov, \" {0:\", $modifier, \"}, {0:\", $modifier, \"}\"), out($reg) y);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg:\n+// CHECK: #APP\n+// CHECK: mv a0, a0\n+// CHECK: #NO_APP\n+check!(reg \"\" reg \"mv\");\n+\n+// CHECK-LABEL: freg:\n+// CHECK: #APP\n+// CHECK: fmv.s fa0, fa0\n+// CHECK: #NO_APP\n+check!(freg \"\" freg \"fmv.s\");"}, {"sha": "449213471cc6fe7bf5dc23de2b6204260c94eca9", "filename": "src/test/assembly/asm/riscv-types.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Friscv-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Friscv-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Friscv-types.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,135 @@\n+// no-system-llvm\n+// revisions: riscv64 riscv32\n+// assembly-output: emit-asm\n+//[riscv64] compile-flags: --target riscv64imac-unknown-none-elf\n+//[riscv32] compile-flags: --target riscv32imac-unknown-none-elf\n+// compile-flags: -C target-feature=+d\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *mut u8;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for i64 {}\n+impl Copy for f64 {}\n+impl Copy for ptr {}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: u8;\n+}\n+\n+// CHECK-LABEL: sym_fn:\n+// CHECK: #APP\n+// CHECK: call extern_func\n+// CHECK: #NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"call {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static:\n+// CHECK: #APP\n+// CHECK: lb t0, extern_static\n+// CHECK: #NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() {\n+    asm!(\"lb t0, {}\", sym extern_static);\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident $mov:literal) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(concat!($mov, \" {}, {}\"), out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: #APP\n+// CHECK: mv {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i8 i8 reg \"mv\");\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: #APP\n+// CHECK: mv {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i16 i16 reg \"mv\");\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: #APP\n+// CHECK: mv {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i32 i32 reg \"mv\");\n+\n+// CHECK-LABEL: reg_f32:\n+// CHECK: #APP\n+// CHECK: mv {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_f32 f32 reg \"mv\");\n+\n+// riscv64-LABEL: reg_i64:\n+// riscv64: #APP\n+// riscv64: mv {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// riscv64: #NO_APP\n+#[cfg(riscv64)]\n+check!(reg_i64 i64 reg \"mv\");\n+\n+// riscv64-LABEL: reg_f64:\n+// riscv64: #APP\n+// riscv64: mv {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// riscv64: #NO_APP\n+#[cfg(riscv64)]\n+check!(reg_f64 f64 reg \"mv\");\n+\n+// CHECK-LABEL: reg_ptr:\n+// CHECK: #APP\n+// CHECK: mv {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_ptr ptr reg \"mv\");\n+\n+// CHECK-LABEL: freg_f32:\n+// CHECK: #APP\n+// CHECK: fmv.s f{{[a-z0-9]+}}, f{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(freg_f32 f32 freg \"fmv.s\");\n+\n+// CHECK-LABEL: freg_f64:\n+// CHECK: #APP\n+// CHECK: fmv.d f{{[a-z0-9]+}}, f{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(freg_f64 f64 freg \"fmv.d\");"}, {"sha": "e538167cd462a8e446751515175a67d4656c98a2", "filename": "src/test/assembly/asm/x86-modifiers.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Fx86-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Fx86-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fx86-modifiers.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,204 @@\n+// no-system-llvm\n+// revisions: x86_64 i686\n+// assembly-output: emit-asm\n+// compile-flags: -O\n+//[x86_64] compile-flags: --target x86_64-unknown-linux-gnu\n+//[i686] compile-flags: --target i686-unknown-linux-gnu\n+// compile-flags: -C llvm-args=--x86-asm-syntax=intel\n+// compile-flags: -C target-feature=+avx512bw\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+impl Copy for i32 {}\n+\n+macro_rules! check {\n+    ($func:ident $modifier:literal $reg:ident $mov:literal) => {\n+        // -O and extern \"C\" guarantee that the selected register is always ax/xmm0\n+        #[no_mangle]\n+        pub unsafe extern \"C\" fn $func() -> i32 {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(concat!($mov, \" {0:\", $modifier, \"}, {0:\", $modifier, \"}\"), out($reg) y);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg:\n+// CHECK: #APP\n+// x86_64: mov rax, rax\n+// i686: mov eax, eax\n+// CHECK: #NO_APP\n+check!(reg \"\" reg \"mov\");\n+\n+// x86_64-LABEL: reg_l:\n+// x86_64: #APP\n+// x86_64: mov al, al\n+// x86_64: #NO_APP\n+#[cfg(x86_64)]\n+check!(reg_l \"l\" reg \"mov\");\n+\n+// CHECK-LABEL: reg_x:\n+// CHECK: #APP\n+// CHECK: mov ax, ax\n+// CHECK: #NO_APP\n+check!(reg_x \"x\" reg \"mov\");\n+\n+// CHECK-LABEL: reg_e:\n+// CHECK: #APP\n+// CHECK: mov eax, eax\n+// CHECK: #NO_APP\n+check!(reg_e \"e\" reg \"mov\");\n+\n+// x86_64-LABEL: reg_r:\n+// x86_64: #APP\n+// x86_64: mov rax, rax\n+// x86_64: #NO_APP\n+#[cfg(x86_64)]\n+check!(reg_r \"r\" reg \"mov\");\n+\n+// CHECK-LABEL: reg_abcd:\n+// CHECK: #APP\n+// x86_64: mov rax, rax\n+// i686: mov eax, eax\n+// CHECK: #NO_APP\n+check!(reg_abcd \"\" reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_l:\n+// CHECK: #APP\n+// CHECK: mov al, al\n+// CHECK: #NO_APP\n+check!(reg_abcd_l \"l\" reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_h:\n+// CHECK: #APP\n+// CHECK: mov ah, ah\n+// CHECK: #NO_APP\n+check!(reg_abcd_h \"h\" reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_x:\n+// CHECK: #APP\n+// CHECK: mov ax, ax\n+// CHECK: #NO_APP\n+check!(reg_abcd_x \"x\" reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_e:\n+// CHECK: #APP\n+// CHECK: mov eax, eax\n+// CHECK: #NO_APP\n+check!(reg_abcd_e \"e\" reg_abcd \"mov\");\n+\n+// x86_64-LABEL: reg_abcd_r:\n+// x86_64: #APP\n+// x86_64: mov rax, rax\n+// x86_64: #NO_APP\n+#[cfg(x86_64)]\n+check!(reg_abcd_r \"r\" reg_abcd \"mov\");\n+\n+// CHECK-LABEL: xmm_reg\n+// CHECK: #APP\n+// CHECK: movaps xmm0, xmm0\n+// CHECK: #NO_APP\n+check!(xmm_reg \"\" xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_x\n+// CHECK: #APP\n+// CHECK: movaps xmm0, xmm0\n+// CHECK: #NO_APP\n+check!(xmm_reg_x \"x\" xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_y\n+// CHECK: #APP\n+// CHECK: vmovaps ymm0, ymm0\n+// CHECK: #NO_APP\n+check!(xmm_reg_y \"y\" xmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: xmm_reg_z\n+// CHECK: #APP\n+// CHECK: vmovaps zmm0, zmm0\n+// CHECK: #NO_APP\n+check!(xmm_reg_z \"z\" xmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg\n+// CHECK: #APP\n+// CHECK: movaps ymm0, ymm0\n+// CHECK: #NO_APP\n+check!(ymm_reg \"\" ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_x\n+// CHECK: #APP\n+// CHECK: movaps xmm0, xmm0\n+// CHECK: #NO_APP\n+check!(ymm_reg_x \"x\" ymm_reg \"movaps\");\n+\n+// CHECK-LABEL: ymm_reg_y\n+// CHECK: #APP\n+// CHECK: vmovaps ymm0, ymm0\n+// CHECK: #NO_APP\n+check!(ymm_reg_y \"y\" ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_z\n+// CHECK: #APP\n+// CHECK: vmovaps zmm0, zmm0\n+// CHECK: #NO_APP\n+check!(ymm_reg_z \"z\" ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg\n+// CHECK: #APP\n+// CHECK: movaps zmm0, zmm0\n+// CHECK: #NO_APP\n+check!(zmm_reg \"\" zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_x\n+// CHECK: #APP\n+// CHECK: movaps xmm0, xmm0\n+// CHECK: #NO_APP\n+check!(zmm_reg_x \"x\" zmm_reg \"movaps\");\n+\n+// CHECK-LABEL: zmm_reg_y\n+// CHECK: #APP\n+// CHECK: vmovaps ymm0, ymm0\n+// CHECK: #NO_APP\n+check!(zmm_reg_y \"y\" zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_z\n+// CHECK: #APP\n+// CHECK: vmovaps zmm0, zmm0\n+// CHECK: #NO_APP\n+check!(zmm_reg_z \"z\" zmm_reg \"vmovaps\");\n+\n+// Note: we don't have any way of ensuring that k1 is actually the register\n+// chosen by the register allocator, so this check may fail if a different\n+// register is chosen.\n+\n+// CHECK-LABEL: kreg:\n+// CHECK: #APP\n+// CHECK: kmovb k1, k1\n+// CHECK: #NO_APP\n+check!(kreg \"\" kreg \"kmovb\");"}, {"sha": "de2e67c421f2e11007a007203b1663b361837787", "filename": "src/test/assembly/asm/x86-types.rs", "status": "added", "additions": 694, "deletions": 0, "changes": 694, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Fx86-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fassembly%2Fasm%2Fx86-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fx86-types.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,694 @@\n+// no-system-llvm\n+// revisions: x86_64 i686\n+// assembly-output: emit-asm\n+//[x86_64] compile-flags: --target x86_64-unknown-linux-gnu\n+//[i686] compile-flags: --target i686-unknown-linux-gnu\n+// compile-flags: -C llvm-args=--x86-asm-syntax=intel\n+// compile-flags: -C target-feature=+avx512bw\n+\n+#![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register, non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *mut u8;\n+\n+#[repr(simd)]\n+pub struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+pub struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+pub struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+pub struct i64x2(i64, i64);\n+#[repr(simd)]\n+pub struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+pub struct f64x2(f64, f64);\n+\n+#[repr(simd)]\n+pub struct i8x32(\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+);\n+#[repr(simd)]\n+pub struct i16x16(i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+pub struct i32x8(i32, i32, i32, i32, i32, i32, i32, i32);\n+#[repr(simd)]\n+pub struct i64x4(i64, i64, i64, i64);\n+#[repr(simd)]\n+pub struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);\n+#[repr(simd)]\n+pub struct f64x4(f64, f64, f64, f64);\n+\n+#[repr(simd)]\n+pub struct i8x64(\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+    i8,\n+);\n+#[repr(simd)]\n+pub struct i16x32(\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+    i16,\n+);\n+#[repr(simd)]\n+pub struct i32x16(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32);\n+#[repr(simd)]\n+pub struct i64x8(i64, i64, i64, i64, i64, i64, i64, i64);\n+#[repr(simd)]\n+pub struct f32x16(f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32);\n+#[repr(simd)]\n+pub struct f64x8(f64, f64, f64, f64, f64, f64, f64, f64);\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for i64 {}\n+impl Copy for f64 {}\n+impl Copy for ptr {}\n+impl Copy for i8x16 {}\n+impl Copy for i16x8 {}\n+impl Copy for i32x4 {}\n+impl Copy for i64x2 {}\n+impl Copy for f32x4 {}\n+impl Copy for f64x2 {}\n+impl Copy for i8x32 {}\n+impl Copy for i16x16 {}\n+impl Copy for i32x8 {}\n+impl Copy for i64x4 {}\n+impl Copy for f32x8 {}\n+impl Copy for f64x4 {}\n+impl Copy for i8x64 {}\n+impl Copy for i16x32 {}\n+impl Copy for i32x16 {}\n+impl Copy for i64x8 {}\n+impl Copy for f32x16 {}\n+impl Copy for f64x8 {}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: u8;\n+}\n+\n+// CHECK-LABEL: sym_fn:\n+// CHECK: #APP\n+// CHECK: call extern_func\n+// CHECK: #NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"call {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static:\n+// CHECK: #APP\n+// CHECK: mov al, byte ptr [extern_static]\n+// CHECK: #NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() {\n+    asm!(\"mov al, byte ptr [{}]\", sym extern_static);\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident $mov:literal) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(concat!($mov, \" {}, {}\"), out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i16 i16 reg \"mov\");\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_i32 i32 reg \"mov\");\n+\n+// CHECK-LABEL: reg_f32:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_f32 f32 reg \"mov\");\n+\n+// x86_64-LABEL: reg_i64:\n+// x86_64: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// x86_64: #NO_APP\n+#[cfg(x86_64)]\n+check!(reg_i64 i64 reg \"mov\");\n+\n+// x86_64-LABEL: reg_f64:\n+// x86_64: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// x86_64: #NO_APP\n+#[cfg(x86_64)]\n+check!(reg_f64 f64 reg \"mov\");\n+\n+// CHECK-LABEL: reg_ptr:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_ptr ptr reg \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_i16:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_abcd_i16 i16 reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_i32:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_abcd_i32 i32 reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_f32:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_abcd_f32 f32 reg_abcd \"mov\");\n+\n+// x86_64-LABEL: reg_abcd_i64:\n+// x86_64: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// x86_64: #NO_APP\n+#[cfg(x86_64)]\n+check!(reg_abcd_i64 i64 reg_abcd \"mov\");\n+\n+// x86_64-LABEL: reg_abcd_f64:\n+// x86_64: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// x86_64: #NO_APP\n+#[cfg(x86_64)]\n+check!(reg_abcd_f64 f64 reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_abcd_ptr:\n+// CHECK: #APP\n+// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n+// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_abcd_ptr ptr reg_abcd \"mov\");\n+\n+// CHECK-LABEL: reg_byte:\n+// CHECK: #APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_byte i8 reg_byte \"mov\");\n+\n+// CHECK-LABEL: xmm_reg_i32:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_i32 i32 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_f32:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_f32 f32 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_i64:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_i64 i64 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_f64:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_f64 f64 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_ptr:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_ptr ptr xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_i8x16:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_i8x16 i8x16 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_i16x8:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_i16x8 i16x8 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_i32x4:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_i32x4 i32x4 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_i64x2:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_i64x2 i64x2 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_f32x4:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_f32x4 f32x4 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: xmm_reg_f64x2:\n+// CHECK: #APP\n+// CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(xmm_reg_f64x2 f64x2 xmm_reg \"movaps\");\n+\n+// CHECK-LABEL: ymm_reg_i32:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i32 i32 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_f32:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_f32 f32 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i64:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i64 i64 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_f64:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_f64 f64 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_ptr:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_ptr ptr ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i8x16:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i8x16 i8x16 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i16x8:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i16x8 i16x8 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i32x4:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i32x4 i32x4 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i64x2:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i64x2 i64x2 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_f32x4:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_f32x4 f32x4 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_f64x2:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_f64x2 f64x2 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i8x32:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i8x32 i8x32 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i16x16:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i16x16 i16x16 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i32x8:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i32x8 i32x8 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_i64x4:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_i64x4 i64x4 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_f32x8:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_f32x8 f32x8 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: ymm_reg_f64x4:\n+// CHECK: #APP\n+// CHECK: vmovaps ymm{{[0-9]+}}, ymm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(ymm_reg_f64x4 f64x4 ymm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i32:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i32 i32 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f32:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f32 f32 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i64:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i64 i64 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f64:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f64 f64 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_ptr:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_ptr ptr zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i8x16:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i8x16 i8x16 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i16x8:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i16x8 i16x8 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i32x4:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i32x4 i32x4 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i64x2:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i64x2 i64x2 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f32x4:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f32x4 f32x4 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f64x2:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f64x2 f64x2 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i8x32:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i8x32 i8x32 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i16x16:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i16x16 i16x16 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i32x8:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i32x8 i32x8 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i64x4:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i64x4 i64x4 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f32x8:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f32x8 f32x8 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f64x4:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f64x4 f64x4 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i8x64:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i8x64 i8x64 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i16x32:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i16x32 i16x32 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i32x16:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i32x16 i32x16 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_i64x8:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_i64x8 i64x8 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f32x16:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f32x16 f32x16 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: zmm_reg_f64x8:\n+// CHECK: #APP\n+// CHECK: vmovaps zmm{{[0-9]+}}, zmm{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(zmm_reg_f64x8 f64x8 zmm_reg \"vmovaps\");\n+\n+// CHECK-LABEL: kreg_i8:\n+// CHECK: #APP\n+// CHECK: kmovb k{{[0-9]+}}, k{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(kreg_i8 i8 kreg \"kmovb\");\n+\n+// CHECK-LABEL: kreg_i16:\n+// CHECK: #APP\n+// CHECK: kmovw k{{[0-9]+}}, k{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(kreg_i16 i16 kreg \"kmovw\");\n+\n+// CHECK-LABEL: kreg_i32:\n+// CHECK: #APP\n+// CHECK: kmovd k{{[0-9]+}}, k{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(kreg_i32 i32 kreg \"kmovd\");\n+\n+// CHECK-LABEL: kreg_i64:\n+// CHECK: #APP\n+// CHECK: kmovq k{{[0-9]+}}, k{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(kreg_i64 i64 kreg \"kmovq\");\n+\n+// CHECK-LABEL: kreg_ptr:\n+// CHECK: #APP\n+// CHECK: kmovq k{{[0-9]+}}, k{{[0-9]+}}\n+// CHECK: #NO_APP\n+check!(kreg_ptr ptr kreg \"kmovq\");"}, {"sha": "21e7eb43796345932bd2a571db09149e571a86f8", "filename": "src/test/codegen/asm-options.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fcodegen%2Fasm-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fcodegen%2Fasm-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasm-options.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,96 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"rlib\"]\n+#![feature(asm)]\n+\n+// CHECK-LABEL: @pure\n+// CHECK-NOT: asm\n+// CHECK: ret void\n+#[no_mangle]\n+pub unsafe fn pure(x: i32) {\n+    let y: i32;\n+    asm!(\"\", out(\"ax\") y, in(\"bx\") x, options(pure, nomem));\n+}\n+\n+// CHECK-LABEL: @noreturn\n+// CHECK: call void asm\n+// CHECK-NEXT: unreachable\n+#[no_mangle]\n+pub unsafe fn noreturn() {\n+    asm!(\"\", options(noreturn));\n+}\n+\n+pub static mut VAR: i32 = 0;\n+pub static mut DUMMY_OUTPUT: i32 = 0;\n+\n+// CHECK-LABEL: @readonly\n+// CHECK: call i32 asm\n+// CHECK: ret i32 1\n+#[no_mangle]\n+pub unsafe fn readonly() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options(pure, readonly));\n+    VAR\n+}\n+\n+// CHECK-LABEL: @not_readonly\n+// CHECK: call i32 asm\n+// CHECK: ret i32 %\n+#[no_mangle]\n+pub unsafe fn not_readonly() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options());\n+    VAR\n+}\n+\n+// CHECK-LABEL: @nomem\n+// CHECK-NOT: store\n+// CHECK: call i32 asm\n+// CHECK: store\n+// CHECK: ret i32 2\n+#[no_mangle]\n+pub unsafe fn nomem() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options(pure, nomem));\n+    VAR = 2;\n+    VAR\n+}\n+\n+// CHECK-LABEL: @nomem_nopure\n+// CHECK-NOT: store\n+// CHECK: call i32 asm\n+// CHECK: store\n+// CHECK: ret i32 2\n+#[no_mangle]\n+pub unsafe fn nomem_nopure() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options(nomem));\n+    VAR = 2;\n+    VAR\n+}\n+\n+// CHECK-LABEL: @not_nomem\n+// CHECK: store\n+// CHECK: call i32 asm\n+// CHECK: store\n+// CHECK: ret i32 2\n+#[no_mangle]\n+pub unsafe fn not_nomem() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options(pure, readonly));\n+    VAR = 2;\n+    VAR\n+}\n+\n+// CHECK-LABEL: @dont_remove_nonpure\n+// CHECK: call void asm\n+// CHECK: call void asm\n+// CHECK: call void asm\n+// CHECK: ret void\n+#[no_mangle]\n+pub unsafe fn dont_remove_nonpure() {\n+    asm!(\"\", options());\n+    asm!(\"\", options(nomem));\n+    asm!(\"\", options(readonly));\n+}"}, {"sha": "1723e1cc1cb095da734f73c75499cc93f00bc1c4", "filename": "src/test/pretty/asm.pp", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fasm.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fasm.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.pp?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,25 @@\n+#![feature(prelude_import)]\n+#![no_std]\n+#![feature(asm)]\n+#[prelude_import]\n+use ::std::prelude::v1::*;\n+#[macro_use]\n+extern crate std;\n+\n+// pretty-mode:expanded\n+// pp-exact:asm.pp\n+\n+pub fn main() {\n+    let a: i32;\n+    let mut b = 4i32;\n+    unsafe {\n+        asm!(\"\");\n+        asm!(\"\");\n+        asm!(\"\", options(nomem, nostack));\n+        asm!(\"{0}\", in(reg) 4);\n+        asm!(\"{0}\", out(reg) a);\n+        asm!(\"{0}\", inout(reg) b);\n+        asm!(\"{0} {1}\", out(reg) _, inlateout(reg) b => _);\n+        asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+    }\n+}"}, {"sha": "9812f1d97e5ff21949c9c6097bc7f6188918e6f7", "filename": "src/test/pretty/asm.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,19 @@\n+#![feature(asm)]\n+\n+// pretty-mode:expanded\n+// pp-exact:asm.pp\n+\n+pub fn main() {\n+    let a: i32;\n+    let mut b = 4i32;\n+    unsafe {\n+        asm!(\"\");\n+        asm!(\"\", options());\n+        asm!(\"\", options(nostack, nomem));\n+        asm!(\"{}\", in(reg) 4);\n+        asm!(\"{0}\", out(reg) a);\n+        asm!(\"{name}\", name = inout(reg) b);\n+        asm!(\"{} {}\", out(reg) _, inlateout(reg) b => _);\n+        asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+    }\n+}"}, {"sha": "2c09646e47e4ab1b421af5b9a1e9bea1360733a5", "filename": "src/test/pretty/llvm-asm-clobbers.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fllvm-asm-clobbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fllvm-asm-clobbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fllvm-asm-clobbers.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "previous_filename": "src/test/pretty/asm-clobbers.rs"}, {"sha": "86a881bfbd18a8f201d2e532dfb0522e0763fc7b", "filename": "src/test/pretty/llvm-asm-options.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fllvm-asm-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fpretty%2Fllvm-asm-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fllvm-asm-options.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "previous_filename": "src/test/pretty/asm-options.rs"}, {"sha": "755fc2ca238aa8e7feebfcf0023006764e3ffb2c", "filename": "src/test/ui/asm/bad-options.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-options.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,18 @@\n+// only-x86_64\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    let mut foo = 0;\n+    unsafe {\n+        asm!(\"\", options(nomem, readonly));\n+        //~^ ERROR the `nomem` and `readonly` options are mutually exclusive\n+        asm!(\"\", options(pure, nomem, noreturn));\n+        //~^ ERROR the `pure` and `noreturn` options are mutually exclusive\n+        //~^^ ERROR asm with `pure` option must have at least one output\n+        asm!(\"{}\", in(reg) foo, options(pure, nomem));\n+        //~^ ERROR asm with `pure` option must have at least one output\n+        asm!(\"{}\", out(reg) foo, options(noreturn));\n+        //~^ ERROR asm outputs are not allowed with the `noreturn` option\n+    }\n+}"}, {"sha": "c5e8e2ccf44ccf7ab31e139dcb25a359c206129c", "filename": "src/test/ui/asm/bad-options.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-options.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-options.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-options.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,32 @@\n+error: the `nomem` and `readonly` options are mutually exclusive\n+  --> $DIR/bad-options.rs:8:18\n+   |\n+LL |         asm!(\"\", options(nomem, readonly));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the `pure` and `noreturn` options are mutually exclusive\n+  --> $DIR/bad-options.rs:10:18\n+   |\n+LL |         asm!(\"\", options(pure, nomem, noreturn));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: asm with `pure` option must have at least one output\n+  --> $DIR/bad-options.rs:10:18\n+   |\n+LL |         asm!(\"\", options(pure, nomem, noreturn));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: asm with `pure` option must have at least one output\n+  --> $DIR/bad-options.rs:13:33\n+   |\n+LL |         asm!(\"{}\", in(reg) foo, options(pure, nomem));\n+   |                                 ^^^^^^^^^^^^^^^^^^^^\n+\n+error: asm outputs are not allowed with the `noreturn` option\n+  --> $DIR/bad-options.rs:15:20\n+   |\n+LL |         asm!(\"{}\", out(reg) foo, options(noreturn));\n+   |                    ^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "016ea9329c4d0988407a47a7b85cad9de9fe05b5", "filename": "src/test/ui/asm/bad-reg.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-reg.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,55 @@\n+// only-x86_64\n+// compile-flags: -C target-feature=+avx2\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    let mut foo = 0;\n+    let mut bar = 0;\n+    unsafe {\n+        // Bad register/register class\n+\n+        asm!(\"{}\", in(foo) foo);\n+        //~^ ERROR invalid register class `foo`: unknown register class\n+        asm!(\"\", in(\"foo\") foo);\n+        //~^ ERROR invalid register `foo`: unknown register\n+        asm!(\"{:z}\", in(reg) foo);\n+        //~^ ERROR invalid asm template modifier for this register class\n+        asm!(\"{:r}\", in(xmm_reg) foo);\n+        //~^ ERROR invalid asm template modifier for this register class\n+        asm!(\"{:a}\", const 0);\n+        //~^ ERROR asm template modifiers are not allowed for `const` arguments\n+        asm!(\"{:a}\", sym main);\n+        //~^ ERROR asm template modifiers are not allowed for `sym` arguments\n+        asm!(\"{}\", in(zmm_reg) foo);\n+        //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n+        asm!(\"\", in(\"zmm0\") foo);\n+        //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n+        asm!(\"\", in(\"ebp\") foo);\n+        //~^ ERROR invalid register `ebp`: the frame pointer cannot be used as an operand\n+        asm!(\"\", in(\"rsp\") foo);\n+        //~^ ERROR invalid register `rsp`: the stack pointer cannot be used as an operand\n+        asm!(\"\", in(\"ip\") foo);\n+        //~^ ERROR invalid register `ip`: the instruction pointer cannot be used as an operand\n+        asm!(\"\", in(\"st(2)\") foo);\n+        //~^ ERROR invalid register `st(2)`: x87 registers are not currently supported as operands\n+        asm!(\"\", in(\"mm0\") foo);\n+        //~^ ERROR invalid register `mm0`: MMX registers are not currently supported as operands\n+        asm!(\"\", in(\"k0\") foo);\n+        //~^ ERROR invalid register `k0`: the k0 AVX mask register cannot be used as an operand\n+\n+        // Explicit register conflicts\n+        // (except in/lateout which don't conflict)\n+\n+        asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n+        //~^ ERROR register `al` conflicts with register `ax`\n+        asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n+        //~^ ERROR register `ax` conflicts with register `ax`\n+        asm!(\"\", in(\"al\") foo, lateout(\"al\") bar);\n+        asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n+        //~^ ERROR register `ymm0` conflicts with register `xmm0`\n+        asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n+        //~^ ERROR register `ymm0` conflicts with register `xmm0`\n+        asm!(\"\", in(\"xmm0\") foo, lateout(\"ymm0\") bar);\n+    }\n+}"}, {"sha": "c6b7d310dfa6cd83c226a46c9ef4dc35e3ea0c81", "filename": "src/test/ui/asm/bad-reg.stderr", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-reg.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,142 @@\n+error: invalid register class `foo`: unknown register class\n+  --> $DIR/bad-reg.rs:12:20\n+   |\n+LL |         asm!(\"{}\", in(foo) foo);\n+   |                    ^^^^^^^^^^^\n+\n+error: invalid register `foo`: unknown register\n+  --> $DIR/bad-reg.rs:14:18\n+   |\n+LL |         asm!(\"\", in(\"foo\") foo);\n+   |                  ^^^^^^^^^^^^^\n+\n+error: invalid asm template modifier for this register class\n+  --> $DIR/bad-reg.rs:16:15\n+   |\n+LL |         asm!(\"{:z}\", in(reg) foo);\n+   |               ^^^^   ----------- argument\n+   |               |\n+   |               template modifier\n+   |\n+   = note: the `reg` register class supports the following template modifiers: `l`, `x`, `e`, `r`\n+\n+error: invalid asm template modifier for this register class\n+  --> $DIR/bad-reg.rs:18:15\n+   |\n+LL |         asm!(\"{:r}\", in(xmm_reg) foo);\n+   |               ^^^^   --------------- argument\n+   |               |\n+   |               template modifier\n+   |\n+   = note: the `xmm_reg` register class supports the following template modifiers: `x`, `y`, `z`\n+\n+error: asm template modifiers are not allowed for `const` arguments\n+  --> $DIR/bad-reg.rs:20:15\n+   |\n+LL |         asm!(\"{:a}\", const 0);\n+   |               ^^^^   ------- argument\n+   |               |\n+   |               template modifier\n+\n+error: asm template modifiers are not allowed for `sym` arguments\n+  --> $DIR/bad-reg.rs:22:15\n+   |\n+LL |         asm!(\"{:a}\", sym main);\n+   |               ^^^^   -------- argument\n+   |               |\n+   |               template modifier\n+\n+error: register class `zmm_reg` requires the `avx512f` target feature\n+  --> $DIR/bad-reg.rs:24:20\n+   |\n+LL |         asm!(\"{}\", in(zmm_reg) foo);\n+   |                    ^^^^^^^^^^^^^^^\n+\n+error: register class `zmm_reg` requires the `avx512f` target feature\n+  --> $DIR/bad-reg.rs:26:18\n+   |\n+LL |         asm!(\"\", in(\"zmm0\") foo);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error: invalid register `ebp`: the frame pointer cannot be used as an operand for inline asm\n+  --> $DIR/bad-reg.rs:28:18\n+   |\n+LL |         asm!(\"\", in(\"ebp\") foo);\n+   |                  ^^^^^^^^^^^^^\n+\n+error: invalid register `rsp`: the stack pointer cannot be used as an operand for inline asm\n+  --> $DIR/bad-reg.rs:30:18\n+   |\n+LL |         asm!(\"\", in(\"rsp\") foo);\n+   |                  ^^^^^^^^^^^^^\n+\n+error: invalid register `ip`: the instruction pointer cannot be used as an operand for inline asm\n+  --> $DIR/bad-reg.rs:32:18\n+   |\n+LL |         asm!(\"\", in(\"ip\") foo);\n+   |                  ^^^^^^^^^^^^\n+\n+error: invalid register `st(2)`: x87 registers are not currently supported as operands for inline asm\n+  --> $DIR/bad-reg.rs:34:18\n+   |\n+LL |         asm!(\"\", in(\"st(2)\") foo);\n+   |                  ^^^^^^^^^^^^^^^\n+\n+error: invalid register `mm0`: MMX registers are not currently supported as operands for inline asm\n+  --> $DIR/bad-reg.rs:36:18\n+   |\n+LL |         asm!(\"\", in(\"mm0\") foo);\n+   |                  ^^^^^^^^^^^^^\n+\n+error: invalid register `k0`: the k0 AVX mask register cannot be used as an operand for inline asm\n+  --> $DIR/bad-reg.rs:38:18\n+   |\n+LL |         asm!(\"\", in(\"k0\") foo);\n+   |                  ^^^^^^^^^^^^\n+\n+error: register `al` conflicts with register `ax`\n+  --> $DIR/bad-reg.rs:44:33\n+   |\n+LL |         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n+   |                  -------------  ^^^^^^^^^^^^ register `al`\n+   |                  |\n+   |                  register `ax`\n+\n+error: register `ax` conflicts with register `ax`\n+  --> $DIR/bad-reg.rs:46:33\n+   |\n+LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n+   |                  -------------  ^^^^^^^^^^^^^^ register `ax`\n+   |                  |\n+   |                  register `ax`\n+   |\n+help: use `lateout` instead of `out` to avoid conflict\n+  --> $DIR/bad-reg.rs:46:18\n+   |\n+LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n+   |                  ^^^^^^^^^^^^^\n+\n+error: register `ymm0` conflicts with register `xmm0`\n+  --> $DIR/bad-reg.rs:49:34\n+   |\n+LL |         asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n+   |                  --------------  ^^^^^^^^^^^^^^ register `ymm0`\n+   |                  |\n+   |                  register `xmm0`\n+\n+error: register `ymm0` conflicts with register `xmm0`\n+  --> $DIR/bad-reg.rs:51:34\n+   |\n+LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n+   |                  --------------  ^^^^^^^^^^^^^^^ register `ymm0`\n+   |                  |\n+   |                  register `xmm0`\n+   |\n+help: use `lateout` instead of `out` to avoid conflict\n+  --> $DIR/bad-reg.rs:51:18\n+   |\n+LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error: aborting due to 18 previous errors\n+"}, {"sha": "0b333eca1ab917193009545dd22bad73fa74fe6d", "filename": "src/test/ui/asm/bad-template.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-template.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,26 @@\n+// only-x86_64\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    let mut foo = 0;\n+    unsafe {\n+        asm!(\"{}\");\n+        //~^ ERROR invalid reference to argument at index 0\n+        asm!(\"{1}\", in(reg) foo);\n+        //~^ ERROR invalid reference to argument at index 1\n+        //~^^ ERROR argument never used\n+        asm!(\"{a}\");\n+        //~^ ERROR there is no argument named `a`\n+        asm!(\"{}\", a = in(reg) foo);\n+        //~^ ERROR invalid reference to argument at index 0\n+        //~^^ ERROR argument never used\n+        asm!(\"{1}\", a = in(reg) foo);\n+        //~^ ERROR invalid reference to argument at index 1\n+        //~^^ ERROR named argument never used\n+        asm!(\"{}\", in(\"eax\") foo);\n+        //~^ ERROR invalid reference to argument at index 0\n+        asm!(\"{:foo}\", in(reg) foo);\n+        //~^ ERROR asm template modifier must be a single character\n+    }\n+}"}, {"sha": "2de76ef824192d5301907e38b6a7f42207bd507e", "filename": "src/test/ui/asm/bad-template.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-template.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fbad-template.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-template.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,86 @@\n+error: invalid reference to argument at index 0\n+  --> $DIR/bad-template.rs:8:15\n+   |\n+LL |         asm!(\"{}\");\n+   |               ^^ from here\n+   |\n+   = note: no arguments were given\n+\n+error: invalid reference to argument at index 1\n+  --> $DIR/bad-template.rs:10:15\n+   |\n+LL |         asm!(\"{1}\", in(reg) foo);\n+   |               ^^^ from here\n+   |\n+   = note: there is 1 argument\n+\n+error: argument never used\n+  --> $DIR/bad-template.rs:10:21\n+   |\n+LL |         asm!(\"{1}\", in(reg) foo);\n+   |                     ^^^^^^^^^^^ argument never used\n+\n+error: there is no argument named `a`\n+  --> $DIR/bad-template.rs:13:15\n+   |\n+LL |         asm!(\"{a}\");\n+   |               ^^^\n+\n+error: invalid reference to argument at index 0\n+  --> $DIR/bad-template.rs:15:15\n+   |\n+LL |         asm!(\"{}\", a = in(reg) foo);\n+   |               ^^   --------------- named argument\n+   |               |\n+   |               from here\n+   |\n+   = note: no positional arguments were given\n+note: named arguments cannot be referenced by position\n+  --> $DIR/bad-template.rs:15:20\n+   |\n+LL |         asm!(\"{}\", a = in(reg) foo);\n+   |                    ^^^^^^^^^^^^^^^\n+\n+error: named argument never used\n+  --> $DIR/bad-template.rs:15:20\n+   |\n+LL |         asm!(\"{}\", a = in(reg) foo);\n+   |                    ^^^^^^^^^^^^^^^ named argument never used\n+\n+error: invalid reference to argument at index 1\n+  --> $DIR/bad-template.rs:18:15\n+   |\n+LL |         asm!(\"{1}\", a = in(reg) foo);\n+   |               ^^^ from here\n+   |\n+   = note: no positional arguments were given\n+\n+error: named argument never used\n+  --> $DIR/bad-template.rs:18:21\n+   |\n+LL |         asm!(\"{1}\", a = in(reg) foo);\n+   |                     ^^^^^^^^^^^^^^^ named argument never used\n+\n+error: invalid reference to argument at index 0\n+  --> $DIR/bad-template.rs:21:15\n+   |\n+LL |         asm!(\"{}\", in(\"eax\") foo);\n+   |               ^^   ------------- explicit register argument\n+   |               |\n+   |               from here\n+   |\n+   = note: no positional arguments were given\n+note: explicit register arguments cannot be used in the asm template\n+  --> $DIR/bad-template.rs:21:20\n+   |\n+LL |         asm!(\"{}\", in(\"eax\") foo);\n+   |                    ^^^^^^^^^^^^^\n+\n+error: asm template modifier must be a single character\n+  --> $DIR/bad-template.rs:23:17\n+   |\n+LL |         asm!(\"{:foo}\", in(reg) foo);\n+   |                 ^^^\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "e08da24f44a22658a96053c328d4e74cd546264f", "filename": "src/test/ui/asm/const.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fconst.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,56 @@\n+// no-system-llvm\n+// only-x86_64\n+// run-pass\n+\n+#![feature(asm)]\n+\n+use std::mem::size_of;\n+\n+trait Proj {\n+    const C: usize;\n+}\n+impl Proj for i8 {\n+    const C: usize = 8;\n+}\n+impl Proj for i16 {\n+    const C: usize = 16;\n+}\n+\n+const fn constfn(x: usize) -> usize {\n+    x\n+}\n+\n+fn generic<T: Proj>() {\n+    unsafe {\n+        let a: usize;\n+        asm!(\"mov {}, {}\", out(reg) a, const size_of::<T>());\n+        assert_eq!(a, size_of::<T>());\n+\n+        let b: usize;\n+        asm!(\"mov {}, {}\", out(reg) b, const size_of::<T>() + constfn(5));\n+        assert_eq!(b, size_of::<T>() + 5);\n+\n+        let c: usize;\n+        asm!(\"mov {}, {}\", out(reg) c, const T::C);\n+        assert_eq!(c, T::C);\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        let a: usize;\n+        asm!(\"mov {}, {}\", out(reg) a, const 5);\n+        assert_eq!(a, 5);\n+\n+        let b: usize;\n+        asm!(\"mov {}, {}\", out(reg) b, const constfn(5));\n+        assert_eq!(b, 5);\n+\n+        let c: usize;\n+        asm!(\"mov {}, {}\", out(reg) c, const constfn(5) + constfn(5));\n+        assert_eq!(c, 10);\n+    }\n+\n+    generic::<i8>();\n+    generic::<i16>();\n+}"}, {"sha": "5e1ee93bfb0735320c3266feaa9b0a4fa0d30034", "filename": "src/test/ui/asm/noreturn.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fnoreturn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fnoreturn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnoreturn.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,17 @@\n+// only-x86_64\n+// check-pass\n+\n+#![feature(asm, never_type)]\n+#![crate_type = \"rlib\"]\n+\n+pub unsafe fn asm1() {\n+    let _: () = asm!(\"\");\n+}\n+\n+pub unsafe fn asm2() {\n+    let _: ! = asm!(\"\", options(noreturn));\n+}\n+\n+pub unsafe fn asm3() -> ! {\n+    asm!(\"\", options(noreturn));\n+}"}, {"sha": "2b1f018f3642eedc253a3cab86e43c924803905f", "filename": "src/test/ui/asm/parse-error.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,56 @@\n+// only-x86_64\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    let mut foo = 0;\n+    let mut bar = 0;\n+    unsafe {\n+        asm!();\n+        //~^ ERROR requires at least a template string argument\n+        asm!(foo);\n+        //~^ ERROR asm template must be a string literal\n+        asm!(\"{}\" foo);\n+        //~^ ERROR expected token: `,`\n+        asm!(\"{}\", foo);\n+        //~^ ERROR expected one of\n+        asm!(\"{}\", in foo);\n+        //~^ ERROR expected `(`, found `foo`\n+        asm!(\"{}\", in(reg foo));\n+        //~^ ERROR expected `)`, found `foo`\n+        asm!(\"{}\", in(reg));\n+        //~^ ERROR expected expression, found end of macro arguments\n+        asm!(\"{}\", inout(=) foo => bar);\n+        //~^ ERROR expected register class or explicit register\n+        asm!(\"{}\", inout(reg) foo =>);\n+        //~^ ERROR expected expression, found end of macro arguments\n+        asm!(\"{}\", in(reg) foo => bar);\n+        //~^ ERROR expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n+        asm!(\"{}\", sym foo + bar);\n+        //~^ ERROR argument to `sym` must be a path expression\n+        asm!(\"\", options(foo));\n+        //~^ ERROR expected one of\n+        asm!(\"\", options(nomem foo));\n+        //~^ ERROR expected one of\n+        asm!(\"\", options(nomem, foo));\n+        //~^ ERROR expected one of\n+        asm!(\"\", options(), options());\n+        //~^ ERROR asm options cannot be specified multiple times\n+        asm!(\"\", options(), options(), options());\n+        //~^ ERROR asm options cannot be specified multiple times\n+        //~^^ ERROR asm options cannot be specified multiple times\n+        asm!(\"{}\", options(), const foo);\n+        //~^ ERROR arguments are not allowed after options\n+        asm!(\"{a}\", a = const foo, a = const bar);\n+        //~^ ERROR duplicate argument named `a`\n+        //~^^ ERROR argument never used\n+        asm!(\"\", a = in(\"eax\") foo);\n+        //~^ ERROR explicit register arguments cannot have names\n+        asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n+        //~^ ERROR named arguments cannot follow explicit register arguments\n+        asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n+        //~^ ERROR named arguments cannot follow explicit register arguments\n+        asm!(\"{1}\", in(\"eax\") foo, const bar);\n+        //~^ ERROR positional arguments cannot follow named arguments or explicit register arguments\n+    }\n+}"}, {"sha": "fa422f56bece56bf2053390654e56fad1ce7360c", "filename": "src/test/ui/asm/parse-error.stderr", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,162 @@\n+error: requires at least a template string argument\n+  --> $DIR/parse-error.rs:9:9\n+   |\n+LL |         asm!();\n+   |         ^^^^^^^\n+\n+error: asm template must be a string literal\n+  --> $DIR/parse-error.rs:11:14\n+   |\n+LL |         asm!(foo);\n+   |              ^^^\n+\n+error: expected token: `,`\n+  --> $DIR/parse-error.rs:13:19\n+   |\n+LL |         asm!(\"{}\" foo);\n+   |                   ^^^ expected `,`\n+\n+error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `foo`\n+  --> $DIR/parse-error.rs:15:20\n+   |\n+LL |         asm!(\"{}\", foo);\n+   |                    ^^^ expected one of 8 possible tokens\n+\n+error: expected `(`, found `foo`\n+  --> $DIR/parse-error.rs:17:23\n+   |\n+LL |         asm!(\"{}\", in foo);\n+   |                       ^^^ expected `(`\n+\n+error: expected `)`, found `foo`\n+  --> $DIR/parse-error.rs:19:27\n+   |\n+LL |         asm!(\"{}\", in(reg foo));\n+   |                           ^^^ expected `)`\n+\n+error: expected expression, found end of macro arguments\n+  --> $DIR/parse-error.rs:21:27\n+   |\n+LL |         asm!(\"{}\", in(reg));\n+   |                           ^ expected expression\n+\n+error: expected register class or explicit register\n+  --> $DIR/parse-error.rs:23:26\n+   |\n+LL |         asm!(\"{}\", inout(=) foo => bar);\n+   |                          ^\n+\n+error: expected expression, found end of macro arguments\n+  --> $DIR/parse-error.rs:25:37\n+   |\n+LL |         asm!(\"{}\", inout(reg) foo =>);\n+   |                                     ^ expected expression\n+\n+error: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n+  --> $DIR/parse-error.rs:27:32\n+   |\n+LL |         asm!(\"{}\", in(reg) foo => bar);\n+   |                                ^^ expected one of 7 possible tokens\n+\n+error: argument to `sym` must be a path expression\n+  --> $DIR/parse-error.rs:29:24\n+   |\n+LL |         asm!(\"{}\", sym foo + bar);\n+   |                        ^^^^^^^^^\n+\n+error: expected one of `)`, `att_syntax`, `nomem`, `noreturn`, `nostack`, `preserves_flags`, `pure`, or `readonly`, found `foo`\n+  --> $DIR/parse-error.rs:31:26\n+   |\n+LL |         asm!(\"\", options(foo));\n+   |                          ^^^ expected one of 8 possible tokens\n+\n+error: expected one of `)` or `,`, found `foo`\n+  --> $DIR/parse-error.rs:33:32\n+   |\n+LL |         asm!(\"\", options(nomem foo));\n+   |                                ^^^ expected one of `)` or `,`\n+\n+error: expected one of `)`, `att_syntax`, `nomem`, `noreturn`, `nostack`, `preserves_flags`, `pure`, or `readonly`, found `foo`\n+  --> $DIR/parse-error.rs:35:33\n+   |\n+LL |         asm!(\"\", options(nomem, foo));\n+   |                                 ^^^ expected one of 8 possible tokens\n+\n+error: asm options cannot be specified multiple times\n+  --> $DIR/parse-error.rs:37:29\n+   |\n+LL |         asm!(\"\", options(), options());\n+   |                  ---------  ^^^^^^^^^ duplicate options\n+   |                  |\n+   |                  previously here\n+\n+error: asm options cannot be specified multiple times\n+  --> $DIR/parse-error.rs:39:29\n+   |\n+LL |         asm!(\"\", options(), options(), options());\n+   |                  ---------  ^^^^^^^^^ duplicate options\n+   |                  |\n+   |                  previously here\n+\n+error: asm options cannot be specified multiple times\n+  --> $DIR/parse-error.rs:39:40\n+   |\n+LL |         asm!(\"\", options(), options(), options());\n+   |                  ---------             ^^^^^^^^^ duplicate options\n+   |                  |\n+   |                  previously here\n+\n+error: arguments are not allowed after options\n+  --> $DIR/parse-error.rs:42:31\n+   |\n+LL |         asm!(\"{}\", options(), const foo);\n+   |                    ---------  ^^^^^^^^^ argument\n+   |                    |\n+   |                    previous options\n+\n+error: duplicate argument named `a`\n+  --> $DIR/parse-error.rs:44:36\n+   |\n+LL |         asm!(\"{a}\", a = const foo, a = const bar);\n+   |                     -------------  ^^^^^^^^^^^^^ duplicate argument\n+   |                     |\n+   |                     previously here\n+\n+error: argument never used\n+  --> $DIR/parse-error.rs:44:36\n+   |\n+LL |         asm!(\"{a}\", a = const foo, a = const bar);\n+   |                                    ^^^^^^^^^^^^^ argument never used\n+\n+error: explicit register arguments cannot have names\n+  --> $DIR/parse-error.rs:47:18\n+   |\n+LL |         asm!(\"\", a = in(\"eax\") foo);\n+   |                  ^^^^^^^^^^^^^^^^^\n+\n+error: named arguments cannot follow explicit register arguments\n+  --> $DIR/parse-error.rs:49:36\n+   |\n+LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n+   |                     -------------  ^^^^^^^^^^^^^ named argument\n+   |                     |\n+   |                     explicit register argument\n+\n+error: named arguments cannot follow explicit register arguments\n+  --> $DIR/parse-error.rs:51:36\n+   |\n+LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n+   |                     -------------  ^^^^^^^^^^^^^ named argument\n+   |                     |\n+   |                     explicit register argument\n+\n+error: positional arguments cannot follow named arguments or explicit register arguments\n+  --> $DIR/parse-error.rs:53:36\n+   |\n+LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n+   |                     -------------  ^^^^^^^^^ positional argument\n+   |                     |\n+   |                     explicit register argument\n+\n+error: aborting due to 24 previous errors\n+"}, {"sha": "c9271059810c7d91141041954c0bbd9981e36394", "filename": "src/test/ui/asm/rustfix-asm.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.fixed?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+// only-x86_64\n+\n+#![feature(asm, llvm_asm)]\n+\n+fn main() {\n+    unsafe {\n+        let x = 1;\n+        let y: i32;\n+        llvm_asm!(\"\" :: \"r\" (x));\n+        //~^ ERROR legacy asm! syntax is no longer supported\n+        llvm_asm!(\"\" : \"=r\" (y));\n+        //~^ ERROR legacy asm! syntax is no longer supported\n+        let _ = y;\n+    }\n+}"}, {"sha": "a108595ca1b666468cf5419c858bcc4f8ca05a01", "filename": "src/test/ui/asm/rustfix-asm.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+// only-x86_64\n+\n+#![feature(asm, llvm_asm)]\n+\n+fn main() {\n+    unsafe {\n+        let x = 1;\n+        let y: i32;\n+        asm!(\"\" :: \"r\" (x));\n+        //~^ ERROR legacy asm! syntax is no longer supported\n+        asm!(\"\" : \"=r\" (y));\n+        //~^ ERROR legacy asm! syntax is no longer supported\n+        let _ = y;\n+    }\n+}"}, {"sha": "28675b51d15fb828ff9349f0a70f3a3e97b47cae", "filename": "src/test/ui/asm/rustfix-asm.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Frustfix-asm.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,18 @@\n+error: legacy asm! syntax is no longer supported\n+  --> $DIR/rustfix-asm.rs:10:9\n+   |\n+LL |         asm!(\"\" :: \"r\" (x));\n+   |         ----^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: replace with: `llvm_asm!`\n+\n+error: legacy asm! syntax is no longer supported\n+  --> $DIR/rustfix-asm.rs:12:9\n+   |\n+LL |         asm!(\"\" : \"=r\" (y));\n+   |         ----^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: replace with: `llvm_asm!`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7880382c3b74f58e0507504bcfd5e24fb4290113", "filename": "src/test/ui/asm/type-check-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,25 @@\n+// only-x86_64\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        // Outputs must be place expressions\n+\n+        asm!(\"{}\", in(reg) 1 + 2);\n+        asm!(\"{}\", out(reg) 1 + 2);\n+        //~^ ERROR invalid asm output\n+        asm!(\"{}\", inout(reg) 1 + 2);\n+        //~^ ERROR invalid asm output\n+\n+        // Operands must be sized\n+\n+        let v: [u64; 3] = [0, 1, 2];\n+        asm!(\"{}\", in(reg) v[..]);\n+        //~^ ERROR the size for values of type `[u64]` cannot be known at compilation time\n+        asm!(\"{}\", out(reg) v[..]);\n+        //~^ ERROR the size for values of type `[u64]` cannot be known at compilation time\n+        asm!(\"{}\", inout(reg) v[..]);\n+        //~^ ERROR the size for values of type `[u64]` cannot be known at compilation time\n+    }\n+}"}, {"sha": "7c9c041f45784b58999606a2bc3f07da4180dfbc", "filename": "src/test/ui/asm/type-check-1.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-1.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,45 @@\n+error: invalid asm output\n+  --> $DIR/type-check-1.rs:10:29\n+   |\n+LL |         asm!(\"{}\", out(reg) 1 + 2);\n+   |                             ^^^^^ cannot assign to this expression\n+\n+error: invalid asm output\n+  --> $DIR/type-check-1.rs:12:31\n+   |\n+LL |         asm!(\"{}\", inout(reg) 1 + 2);\n+   |                               ^^^^^ cannot assign to this expression\n+\n+error[E0277]: the size for values of type `[u64]` cannot be known at compilation time\n+  --> $DIR/type-check-1.rs:18:28\n+   |\n+LL |         asm!(\"{}\", in(reg) v[..]);\n+   |                            ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u64]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all inline asm arguments must have a statically known size\n+\n+error[E0277]: the size for values of type `[u64]` cannot be known at compilation time\n+  --> $DIR/type-check-1.rs:20:29\n+   |\n+LL |         asm!(\"{}\", out(reg) v[..]);\n+   |                             ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u64]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all inline asm arguments must have a statically known size\n+\n+error[E0277]: the size for values of type `[u64]` cannot be known at compilation time\n+  --> $DIR/type-check-1.rs:22:31\n+   |\n+LL |         asm!(\"{}\", inout(reg) v[..]);\n+   |                               ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u64]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all inline asm arguments must have a statically known size\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1652e9e4c9f661a581e1640e5188a11006490cb6", "filename": "src/test/ui/asm/type-check-2.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-2.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,104 @@\n+// only-x86_64\n+\n+#![feature(asm, repr_simd, never_type)]\n+\n+#[repr(simd)]\n+struct SimdNonCopy(f32, f32, f32, f32);\n+\n+fn main() {\n+    unsafe {\n+        // Inputs must be initialized\n+\n+        let x: u64;\n+        asm!(\"{}\", in(reg) x);\n+        //~^ ERROR use of possibly-uninitialized variable: `x`\n+        let mut y: u64;\n+        asm!(\"{}\", inout(reg) y);\n+        //~^ ERROR use of possibly-uninitialized variable: `y`\n+        let _ = y;\n+\n+        // Outputs require mutable places\n+\n+        let v: Vec<u64> = vec![0, 1, 2];\n+        asm!(\"{}\", in(reg) v[0]);\n+        asm!(\"{}\", out(reg) v[0]);\n+        //~^ ERROR cannot borrow `v` as mutable, as it is not declared as mutable\n+        asm!(\"{}\", inout(reg) v[0]);\n+        //~^ ERROR cannot borrow `v` as mutable, as it is not declared as mutable\n+\n+        // Const operands must be integer or floats, and must be constants.\n+\n+        let x = 0;\n+        const C: i32 = 0;\n+        const fn const_foo(x: i32) -> i32 {\n+            x\n+        }\n+        const fn const_bar<T>(x: T) -> T {\n+            x\n+        }\n+        asm!(\"{}\", const 0i32);\n+        asm!(\"{}\", const 0f32);\n+        asm!(\"{}\", const 0 as *mut u8);\n+        //~^ ERROR asm `const` arguments must be integer or floating-point values\n+        asm!(\"{}\", const &0);\n+        //~^ ERROR asm `const` arguments must be integer or floating-point values\n+        asm!(\"{}\", const x);\n+        //~^ ERROR argument 1 is required to be a constant\n+        asm!(\"{}\", const const_foo(0));\n+        asm!(\"{}\", const const_foo(x));\n+        //~^ ERROR argument 1 is required to be a constant\n+        asm!(\"{}\", const const_bar(0));\n+        asm!(\"{}\", const const_bar(x));\n+        //~^ ERROR argument 1 is required to be a constant\n+\n+        // Sym operands must point to a function or static\n+\n+        static S: i32 = 0;\n+        asm!(\"{}\", sym S);\n+        asm!(\"{}\", sym main);\n+        asm!(\"{}\", sym C);\n+        //~^ ERROR asm `sym` operand must point to a fn or static\n+        asm!(\"{}\", sym x);\n+        //~^ ERROR asm `sym` operand must point to a fn or static\n+\n+        // Register operands must be Copy\n+\n+        asm!(\"{}\", in(xmm_reg) SimdNonCopy(0.0, 0.0, 0.0, 0.0));\n+        //~^ ERROR arguments for inline assembly must be copyable\n+\n+        // Register operands must be integers, floats, SIMD vectors, pointers or\n+        // function pointers.\n+\n+        asm!(\"{}\", in(reg) 0i64);\n+        asm!(\"{}\", in(reg) 0f64);\n+        asm!(\"{}\", in(xmm_reg) std::arch::x86_64::_mm_setzero_ps());\n+        asm!(\"{}\", in(reg) 0 as *const u8);\n+        asm!(\"{}\", in(reg) 0 as *mut u8);\n+        asm!(\"{}\", in(reg) main as fn());\n+        asm!(\"{}\", in(reg) |x: i32| x);\n+        //~^ ERROR cannot use value of type\n+        asm!(\"{}\", in(reg) vec![0]);\n+        //~^ ERROR cannot use value of type `std::vec::Vec<i32>` for inline assembly\n+        asm!(\"{}\", in(reg) (1, 2, 3));\n+        //~^ ERROR cannot use value of type `(i32, i32, i32)` for inline assembly\n+        asm!(\"{}\", in(reg) [1, 2, 3]);\n+        //~^ ERROR cannot use value of type `[i32; 3]` for inline assembly\n+\n+        // Register inputs (but not outputs) allow references and function types\n+\n+        let mut f = main;\n+        let mut r = &mut 0;\n+        asm!(\"{}\", in(reg) f);\n+        asm!(\"{}\", inout(reg) f);\n+        //~^ ERROR cannot use value of type `fn() {main}` for inline assembly\n+        asm!(\"{}\", in(reg) r);\n+        asm!(\"{}\", inout(reg) r);\n+        //~^ ERROR cannot use value of type `&mut i32` for inline assembly\n+        let _ = (f, r);\n+\n+        // Type checks ignore never type\n+\n+        let u: ! = unreachable!();\n+        asm!(\"{}\", in(reg) u);\n+    }\n+}"}, {"sha": "dc7949534f1a91713e3b626f4b3c6412db4eb3fa", "filename": "src/test/ui/asm/type-check-2.stderr", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-2.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,133 @@\n+error: asm `const` arguments must be integer or floating-point values\n+  --> $DIR/type-check-2.rs:41:26\n+   |\n+LL |         asm!(\"{}\", const 0 as *mut u8);\n+   |                          ^^^^^^^^^^^^\n+\n+error: asm `const` arguments must be integer or floating-point values\n+  --> $DIR/type-check-2.rs:43:26\n+   |\n+LL |         asm!(\"{}\", const &0);\n+   |                          ^^\n+\n+error: arguments for inline assembly must be copyable\n+  --> $DIR/type-check-2.rs:66:32\n+   |\n+LL |         asm!(\"{}\", in(xmm_reg) SimdNonCopy(0.0, 0.0, 0.0, 0.0));\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `SimdNonCopy` does not implement the Copy trait\n+\n+error: cannot use value of type `[closure@$DIR/type-check-2.rs:78:28: 78:38]` for inline assembly\n+  --> $DIR/type-check-2.rs:78:28\n+   |\n+LL |         asm!(\"{}\", in(reg) |x: i32| x);\n+   |                            ^^^^^^^^^^\n+   |\n+   = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n+\n+error: cannot use value of type `std::vec::Vec<i32>` for inline assembly\n+  --> $DIR/type-check-2.rs:80:28\n+   |\n+LL |         asm!(\"{}\", in(reg) vec![0]);\n+   |                            ^^^^^^^\n+   |\n+   = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: cannot use value of type `(i32, i32, i32)` for inline assembly\n+  --> $DIR/type-check-2.rs:82:28\n+   |\n+LL |         asm!(\"{}\", in(reg) (1, 2, 3));\n+   |                            ^^^^^^^^^\n+   |\n+   = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n+\n+error: cannot use value of type `[i32; 3]` for inline assembly\n+  --> $DIR/type-check-2.rs:84:28\n+   |\n+LL |         asm!(\"{}\", in(reg) [1, 2, 3]);\n+   |                            ^^^^^^^^^\n+   |\n+   = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n+\n+error: cannot use value of type `fn() {main}` for inline assembly\n+  --> $DIR/type-check-2.rs:92:31\n+   |\n+LL |         asm!(\"{}\", inout(reg) f);\n+   |                               ^\n+   |\n+   = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n+\n+error: cannot use value of type `&mut i32` for inline assembly\n+  --> $DIR/type-check-2.rs:95:31\n+   |\n+LL |         asm!(\"{}\", inout(reg) r);\n+   |                               ^\n+   |\n+   = note: only integers, floats, SIMD vectors, pointers and function pointers can be used as arguments for inline assembly\n+\n+error: asm `sym` operand must point to a fn or static\n+  --> $DIR/type-check-2.rs:59:24\n+   |\n+LL |         asm!(\"{}\", sym C);\n+   |                        ^\n+\n+error: asm `sym` operand must point to a fn or static\n+  --> $DIR/type-check-2.rs:61:24\n+   |\n+LL |         asm!(\"{}\", sym x);\n+   |                        ^\n+\n+error: argument 1 is required to be a constant\n+  --> $DIR/type-check-2.rs:45:9\n+   |\n+LL |         asm!(\"{}\", const x);\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: argument 1 is required to be a constant\n+  --> $DIR/type-check-2.rs:48:9\n+   |\n+LL |         asm!(\"{}\", const const_foo(x));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: argument 1 is required to be a constant\n+  --> $DIR/type-check-2.rs:51:9\n+   |\n+LL |         asm!(\"{}\", const const_bar(x));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0381]: use of possibly-uninitialized variable: `x`\n+  --> $DIR/type-check-2.rs:13:28\n+   |\n+LL |         asm!(\"{}\", in(reg) x);\n+   |                            ^ use of possibly-uninitialized `x`\n+\n+error[E0381]: use of possibly-uninitialized variable: `y`\n+  --> $DIR/type-check-2.rs:16:9\n+   |\n+LL |         asm!(\"{}\", inout(reg) y);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ use of possibly-uninitialized `y`\n+\n+error[E0596]: cannot borrow `v` as mutable, as it is not declared as mutable\n+  --> $DIR/type-check-2.rs:24:29\n+   |\n+LL |         let v: Vec<u64> = vec![0, 1, 2];\n+   |             - help: consider changing this to be mutable: `mut v`\n+LL |         asm!(\"{}\", in(reg) v[0]);\n+LL |         asm!(\"{}\", out(reg) v[0]);\n+   |                             ^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `v` as mutable, as it is not declared as mutable\n+  --> $DIR/type-check-2.rs:26:31\n+   |\n+LL |         let v: Vec<u64> = vec![0, 1, 2];\n+   |             - help: consider changing this to be mutable: `mut v`\n+...\n+LL |         asm!(\"{}\", inout(reg) v[0]);\n+   |                               ^ cannot borrow as mutable\n+\n+error: aborting due to 18 previous errors\n+\n+Some errors have detailed explanations: E0381, E0596.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "5de15fe49067ae85416a011c1b899f4800165b74", "filename": "src/test/ui/asm/type-check-3.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,71 @@\n+// only-x86_64\n+// compile-flags: -C target-feature=+avx512f\n+\n+#![feature(asm)]\n+\n+use std::arch::x86_64::{_mm256_setzero_ps, _mm_setzero_ps};\n+\n+fn main() {\n+    unsafe {\n+        // Types must be in the whitelist for the register class\n+\n+        asm!(\"{}\", in(reg) 0i128);\n+        //~^ ERROR type `i128` cannot be used with this register class\n+        asm!(\"{}\", in(reg) _mm_setzero_ps());\n+        //~^ ERROR type `std::arch::x86_64::__m128` cannot be used with this register class\n+        asm!(\"{}\", in(reg) _mm256_setzero_ps());\n+        //~^ ERROR type `std::arch::x86_64::__m256` cannot be used with this register class\n+        asm!(\"{}\", in(xmm_reg) 0u8);\n+        //~^ ERROR type `u8` cannot be used with this register class\n+        asm!(\"{:e}\", in(reg) 0i32);\n+        asm!(\"{}\", in(xmm_reg) 0i32);\n+        asm!(\"{:e}\", in(reg) 0f32);\n+        asm!(\"{}\", in(xmm_reg) 0f32);\n+        asm!(\"{}\", in(xmm_reg) _mm_setzero_ps());\n+        asm!(\"{:x}\", in(ymm_reg) _mm_setzero_ps());\n+        asm!(\"{}\", in(kreg) 0u16);\n+        asm!(\"{}\", in(kreg) 0u64);\n+        //~^ ERROR `avx512bw` target feature is not enabled\n+\n+        // Template modifier suggestions for sub-registers\n+\n+        asm!(\"{0} {0}\", in(reg) 0i16);\n+        //~^ WARN formatting may not be suitable for sub-register argument\n+        asm!(\"{0} {0:x}\", in(reg) 0i16);\n+        //~^ WARN formatting may not be suitable for sub-register argument\n+        asm!(\"{}\", in(reg) 0i32);\n+        //~^ WARN formatting may not be suitable for sub-register argument\n+        asm!(\"{}\", in(reg) 0i64);\n+        asm!(\"{}\", in(ymm_reg) 0i64);\n+        //~^ WARN formatting may not be suitable for sub-register argument\n+        asm!(\"{}\", in(ymm_reg) _mm256_setzero_ps());\n+        asm!(\"{:l}\", in(reg) 0i16);\n+        asm!(\"{:l}\", in(reg) 0i32);\n+        asm!(\"{:l}\", in(reg) 0i64);\n+        asm!(\"{:x}\", in(ymm_reg) 0i64);\n+        asm!(\"{:x}\", in(ymm_reg) _mm256_setzero_ps());\n+\n+        // Suggest different register class for type\n+\n+        asm!(\"{}\", in(reg) 0i8);\n+        //~^ ERROR type `i8` cannot be used with this register class\n+        asm!(\"{}\", in(reg_byte) 0i8);\n+\n+        // Split inout operands must have compatible types\n+\n+        let mut val_i16: i16;\n+        let mut val_f32: f32;\n+        let mut val_u32: u32;\n+        let mut val_u64: u64;\n+        let mut val_ptr: *mut u8;\n+        asm!(\"{:r}\", inout(reg) 0u16 => val_i16);\n+        asm!(\"{:r}\", inout(reg) 0u32 => val_f32);\n+        //~^ ERROR incompatible types for asm inout argument\n+        asm!(\"{:r}\", inout(reg) 0u32 => val_ptr);\n+        //~^ ERROR incompatible types for asm inout argument\n+        asm!(\"{:r}\", inout(reg) main => val_u32);\n+        //~^ ERROR incompatible types for asm inout argument\n+        asm!(\"{:r}\", inout(reg) 0u64 => val_ptr);\n+        asm!(\"{:r}\", inout(reg) main => val_u64);\n+    }\n+}"}, {"sha": "01dbe78db887a70fc3c033c7fda455b51dbd45af", "filename": "src/test/ui/asm/type-check-3.stderr", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,118 @@\n+error: type `i128` cannot be used with this register class\n+  --> $DIR/type-check-3.rs:12:28\n+   |\n+LL |         asm!(\"{}\", in(reg) 0i128);\n+   |                            ^^^^^\n+   |\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n+\n+error: type `std::arch::x86_64::__m128` cannot be used with this register class\n+  --> $DIR/type-check-3.rs:14:28\n+   |\n+LL |         asm!(\"{}\", in(reg) _mm_setzero_ps());\n+   |                            ^^^^^^^^^^^^^^^^\n+   |\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n+\n+error: type `std::arch::x86_64::__m256` cannot be used with this register class\n+  --> $DIR/type-check-3.rs:16:28\n+   |\n+LL |         asm!(\"{}\", in(reg) _mm256_setzero_ps());\n+   |                            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n+\n+error: type `u8` cannot be used with this register class\n+  --> $DIR/type-check-3.rs:18:32\n+   |\n+LL |         asm!(\"{}\", in(xmm_reg) 0u8);\n+   |                                ^^^\n+   |\n+   = note: register class `xmm_reg` supports these types: i32, i64, f32, f64, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2\n+\n+error: `avx512bw` target feature is not enabled\n+  --> $DIR/type-check-3.rs:27:29\n+   |\n+LL |         asm!(\"{}\", in(kreg) 0u64);\n+   |                             ^^^^\n+   |\n+   = note: this is required to use type `u64` with register class `kreg`\n+\n+warning: formatting may not be suitable for sub-register argument\n+  --> $DIR/type-check-3.rs:32:15\n+   |\n+LL |         asm!(\"{0} {0}\", in(reg) 0i16);\n+   |               ^^^ ^^^           ---- for this argument\n+   |\n+   = note: `#[warn(asm_sub_register)]` on by default\n+   = help: use the `x` modifier to have the register formatted as `ax`\n+   = help: or use the `r` modifier to keep the default formatting of `rax`\n+\n+warning: formatting may not be suitable for sub-register argument\n+  --> $DIR/type-check-3.rs:34:15\n+   |\n+LL |         asm!(\"{0} {0:x}\", in(reg) 0i16);\n+   |               ^^^                 ---- for this argument\n+   |\n+   = help: use the `x` modifier to have the register formatted as `ax`\n+   = help: or use the `r` modifier to keep the default formatting of `rax`\n+\n+warning: formatting may not be suitable for sub-register argument\n+  --> $DIR/type-check-3.rs:36:15\n+   |\n+LL |         asm!(\"{}\", in(reg) 0i32);\n+   |               ^^           ---- for this argument\n+   |\n+   = help: use the `e` modifier to have the register formatted as `eax`\n+   = help: or use the `r` modifier to keep the default formatting of `rax`\n+\n+warning: formatting may not be suitable for sub-register argument\n+  --> $DIR/type-check-3.rs:39:15\n+   |\n+LL |         asm!(\"{}\", in(ymm_reg) 0i64);\n+   |               ^^               ---- for this argument\n+   |\n+   = help: use the `x` modifier to have the register formatted as `xmm0`\n+   = help: or use the `y` modifier to keep the default formatting of `ymm0`\n+\n+error: type `i8` cannot be used with this register class\n+  --> $DIR/type-check-3.rs:50:28\n+   |\n+LL |         asm!(\"{}\", in(reg) 0i8);\n+   |                            ^^^\n+   |\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n+   = help: consider using the `reg_byte` register class instead\n+\n+error: incompatible types for asm inout argument\n+  --> $DIR/type-check-3.rs:62:33\n+   |\n+LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_f32);\n+   |                                 ^^^^    ^^^^^^^ type `f32`\n+   |                                 |\n+   |                                 type `u32`\n+   |\n+   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n+\n+error: incompatible types for asm inout argument\n+  --> $DIR/type-check-3.rs:64:33\n+   |\n+LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_ptr);\n+   |                                 ^^^^    ^^^^^^^ type `*mut u8`\n+   |                                 |\n+   |                                 type `u32`\n+   |\n+   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n+\n+error: incompatible types for asm inout argument\n+  --> $DIR/type-check-3.rs:66:33\n+   |\n+LL |         asm!(\"{:r}\", inout(reg) main => val_u32);\n+   |                                 ^^^^    ^^^^^^^ type `u32`\n+   |                                 |\n+   |                                 type `fn()`\n+   |\n+   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n+\n+error: aborting due to 9 previous errors; 4 warnings emitted\n+"}, {"sha": "2be627c11657b4b95e645d3a5af41bc78bd3d5ce", "filename": "src/test/ui/asm/type-check-4.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-4.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,23 @@\n+// only-x86_64\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        // Can't output to borrowed values.\n+\n+        let mut a = 0isize;\n+        let p = &a;\n+        asm!(\"{}\", out(reg) a);\n+        //~^ cannot assign to `a` because it is borrowed\n+        println!(\"{}\", p);\n+\n+        // Can't read from mutable borrowed values.\n+\n+        let mut a = 0isize;\n+        let p = &mut a;\n+        asm!(\"{}\", in(reg) a);\n+        //~^ cannot use `a` because it was mutably borrowed\n+        println!(\"{}\", p);\n+    }\n+}"}, {"sha": "8035bbefc1aa1156ffc700fb77b9eff2fcc8c727", "filename": "src/test/ui/asm/type-check-4.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fasm%2Ftype-check-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-4.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -0,0 +1,26 @@\n+error[E0506]: cannot assign to `a` because it is borrowed\n+  --> $DIR/type-check-4.rs:11:9\n+   |\n+LL |         let p = &a;\n+   |                 -- borrow of `a` occurs here\n+LL |         asm!(\"{}\", out(reg) a);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `a` occurs here\n+LL |\n+LL |         println!(\"{}\", p);\n+   |                        - borrow later used here\n+\n+error[E0503]: cannot use `a` because it was mutably borrowed\n+  --> $DIR/type-check-4.rs:19:28\n+   |\n+LL |         let p = &mut a;\n+   |                 ------ borrow of `a` occurs here\n+LL |         asm!(\"{}\", in(reg) a);\n+   |                            ^ use of borrowed `a`\n+LL |\n+LL |         println!(\"{}\", p);\n+   |                        - borrow later used here\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0503, E0506.\n+For more information about an error, try `rustc --explain E0503`."}, {"sha": "4eb72031d51b10b8086c77dcecb038b079730727", "filename": "src/test/ui/feature-gates/feature-gate-asm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -2,8 +2,9 @@\n \n fn main() {\n     unsafe {\n-        asm!(\"\"); //~ ERROR inline assembly is not stable enough\n-        //~^ WARN use of deprecated item 'asm'\n-        llvm_asm!(\"\"); //~ ERROR inline assembly is not stable enough\n+        asm!(\"\");\n+        //~^ ERROR inline assembly is not stable enough\n+        llvm_asm!(\"\");\n+        //~^ ERROR LLVM-style inline assembly will never be stabilized\n     }\n }"}, {"sha": "a71643e0d33a328c44170524509f58f9ec5a7042", "filename": "src/test/ui/feature-gates/feature-gate-asm.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -4,10 +4,10 @@ error[E0658]: use of unstable library feature 'asm': inline assembly is not stab\n LL |         asm!(\"\");\n    |         ^^^\n    |\n-   = note: see issue #70173 <https://github.com/rust-lang/rust/issues/70173> for more information\n+   = note: see issue #72016 <https://github.com/rust-lang/rust/issues/72016> for more information\n    = help: add `#![feature(asm)]` to the crate attributes to enable\n \n-error[E0658]: use of unstable library feature 'llvm_asm': inline assembly is not stable enough for use and is subject to change\n+error[E0658]: use of unstable library feature 'llvm_asm': LLVM-style inline assembly will never be stabilized, prefer using asm! instead\n   --> $DIR/feature-gate-asm.rs:7:9\n    |\n LL |         llvm_asm!(\"\");\n@@ -16,14 +16,6 @@ LL |         llvm_asm!(\"\");\n    = note: see issue #70173 <https://github.com/rust-lang/rust/issues/70173> for more information\n    = help: add `#![feature(llvm_asm)]` to the crate attributes to enable\n \n-warning: use of deprecated item 'asm': the syntax of asm! will change soon, use llvm_asm! to avoid breakage\n-  --> $DIR/feature-gate-asm.rs:5:9\n-   |\n-LL |         asm!(\"\");\n-   |         ^^^ help: replace the use of the deprecated item: `llvm_asm`\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n-error: aborting due to 2 previous errors; 1 warning emitted\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "8bd7226aca730d4cc827ccf057aa05d0b9afff3d", "filename": "src/test/ui/feature-gates/feature-gate-asm2.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -2,8 +2,9 @@\n \n fn main() {\n     unsafe {\n-        println!(\"{:?}\", asm!(\"\")); //~ ERROR inline assembly is not stable\n-        //~^ WARN use of deprecated item 'asm'\n-        println!(\"{:?}\", llvm_asm!(\"\")); //~ ERROR inline assembly is not stable\n+        println!(\"{:?}\", asm!(\"\"));\n+        //~^ ERROR inline assembly is not stable enough\n+        println!(\"{:?}\", llvm_asm!(\"\"));\n+        //~^ ERROR LLVM-style inline assembly will never be stabilized\n     }\n }"}, {"sha": "a8022cb72e0e3a9f5bbdef922b9e5ebc9d212dfb", "filename": "src/test/ui/feature-gates/feature-gate-asm2.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -4,10 +4,10 @@ error[E0658]: use of unstable library feature 'asm': inline assembly is not stab\n LL |         println!(\"{:?}\", asm!(\"\"));\n    |                          ^^^\n    |\n-   = note: see issue #70173 <https://github.com/rust-lang/rust/issues/70173> for more information\n+   = note: see issue #72016 <https://github.com/rust-lang/rust/issues/72016> for more information\n    = help: add `#![feature(asm)]` to the crate attributes to enable\n \n-error[E0658]: use of unstable library feature 'llvm_asm': inline assembly is not stable enough for use and is subject to change\n+error[E0658]: use of unstable library feature 'llvm_asm': LLVM-style inline assembly will never be stabilized, prefer using asm! instead\n   --> $DIR/feature-gate-asm2.rs:7:26\n    |\n LL |         println!(\"{:?}\", llvm_asm!(\"\"));\n@@ -16,14 +16,6 @@ LL |         println!(\"{:?}\", llvm_asm!(\"\"));\n    = note: see issue #70173 <https://github.com/rust-lang/rust/issues/70173> for more information\n    = help: add `#![feature(llvm_asm)]` to the crate attributes to enable\n \n-warning: use of deprecated item 'asm': the syntax of asm! will change soon, use llvm_asm! to avoid breakage\n-  --> $DIR/feature-gate-asm2.rs:5:26\n-   |\n-LL |         println!(\"{:?}\", asm!(\"\"));\n-   |                          ^^^ help: replace the use of the deprecated item: `llvm_asm`\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n-error: aborting due to 2 previous errors; 1 warning emitted\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "1dc1c859c6b0e3645ef11fbcdd53870019d42f5f", "filename": "src/test/ui/llvm-asm/llvm-asm-concat-src.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-concat-src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-concat-src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-concat-src.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "previous_filename": "src/test/ui/asm-concat-src.rs"}, {"sha": "35f4d92c8ffbcf6ff9b22721c679f00831395a68", "filename": "src/test/ui/llvm-asm/llvm-asm-in-moved.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-in-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-in-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-in-moved.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "previous_filename": "src/test/ui/asm-in-moved.rs"}, {"sha": "acefabd8a666e0385a9092cc4ecfd3bc58e5782b", "filename": "src/test/ui/llvm-asm/llvm-asm-in-out-operand.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-in-out-operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-in-out-operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-in-out-operand.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "previous_filename": "src/test/ui/asm-in-out-operand.rs"}, {"sha": "556ad83a4ead8202d76062e286161a15efa49657", "filename": "src/test/ui/llvm-asm/llvm-asm-indirect-memory.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-indirect-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-indirect-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-indirect-memory.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "previous_filename": "src/test/ui/asm-indirect-memory.rs"}, {"sha": "321f28565ff180d3c2810da8e76f9c82c53d22f5", "filename": "src/test/ui/llvm-asm/llvm-asm-out-assign.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-out-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-out-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fllvm-asm-out-assign.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "previous_filename": "src/test/ui/asm-out-assign.rs"}, {"sha": "a8bfa0299f66f0b1fadc94f5c13803b0634929d3", "filename": "src/test/ui/macros/macro-expanded-include/foo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-expanded-include%2Ffoo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-expanded-include%2Ffoo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-expanded-include%2Ffoo%2Fmod.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -5,5 +5,5 @@ macro_rules! m {\n }\n \n macro_rules! n {\n-    () => { unsafe { llvm_asm!(include_str!(\"file.txt\")); } }\n+    () => { unsafe { asm!(include_str!(\"file.txt\")); } }\n }"}, {"sha": "f1a71059a89016e1684d4d25c8657a0f969f84c1", "filename": "src/test/ui/macros/macro-expanded-include/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-expanded-include%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-expanded-include%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-expanded-include%2Ftest.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,6 +1,6 @@\n // ignore-emscripten no llvm_asm! support\n // build-pass (FIXME(62277): could be check-pass?)\n-#![feature(llvm_asm)]\n+#![feature(asm)]\n #![allow(unused)]\n \n #[macro_use]"}, {"sha": "0a496c9dc3d33eee41add0057acce1ca745e9dfb", "filename": "src/test/ui/macros/macros-nonfatal-errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -3,13 +3,14 @@\n // test that errors in a (selection) of macros don't kill compilation\n // immediately, so that we get more errors listed at a time.\n \n-#![feature(llvm_asm)]\n+#![feature(asm, llvm_asm)]\n #![feature(trace_macros, concat_idents)]\n \n #[derive(Default)] //~ ERROR\n enum OrDeriveThis {}\n \n fn main() {\n+    asm!(invalid); //~ ERROR\n     llvm_asm!(invalid); //~ ERROR\n \n     concat_idents!(\"not\", \"idents\"); //~ ERROR"}, {"sha": "6ef757a55b8fb82d2b569ad12684cba406da1151", "filename": "src/test/ui/macros/macros-nonfatal-errors.stderr", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -6,44 +6,50 @@ LL | #[derive(Default)]\n    |\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error: asm template must be a string literal\n+  --> $DIR/macros-nonfatal-errors.rs:13:10\n+   |\n+LL |     asm!(invalid);\n+   |          ^^^^^^^\n+\n error: inline assembly must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:13:15\n+  --> $DIR/macros-nonfatal-errors.rs:14:15\n    |\n LL |     llvm_asm!(invalid);\n    |               ^^^^^^^\n \n error: concat_idents! requires ident args.\n-  --> $DIR/macros-nonfatal-errors.rs:15:5\n+  --> $DIR/macros-nonfatal-errors.rs:16:5\n    |\n LL |     concat_idents!(\"not\", \"idents\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:17:17\n+  --> $DIR/macros-nonfatal-errors.rs:18:17\n    |\n LL |     option_env!(invalid);\n    |                 ^^^^^^^\n \n error: expected string literal\n-  --> $DIR/macros-nonfatal-errors.rs:18:10\n+  --> $DIR/macros-nonfatal-errors.rs:19:10\n    |\n LL |     env!(invalid);\n    |          ^^^^^^^\n \n error: expected string literal\n-  --> $DIR/macros-nonfatal-errors.rs:19:10\n+  --> $DIR/macros-nonfatal-errors.rs:20:10\n    |\n LL |     env!(foo, abr, baz);\n    |          ^^^\n \n error: environment variable `RUST_HOPEFULLY_THIS_DOESNT_EXIST` not defined\n-  --> $DIR/macros-nonfatal-errors.rs:20:5\n+  --> $DIR/macros-nonfatal-errors.rs:21:5\n    |\n LL |     env!(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: format argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:22:13\n+  --> $DIR/macros-nonfatal-errors.rs:23:13\n    |\n LL |     format!(invalid);\n    |             ^^^^^^^\n@@ -54,45 +60,45 @@ LL |     format!(\"{}\", invalid);\n    |             ^^^^^\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:24:14\n+  --> $DIR/macros-nonfatal-errors.rs:25:14\n    |\n LL |     include!(invalid);\n    |              ^^^^^^^\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:26:18\n+  --> $DIR/macros-nonfatal-errors.rs:27:18\n    |\n LL |     include_str!(invalid);\n    |                  ^^^^^^^\n \n error: couldn't read $DIR/i'd be quite surprised if a file with this name existed: $FILE_NOT_FOUND_MSG (os error 2)\n-  --> $DIR/macros-nonfatal-errors.rs:27:5\n+  --> $DIR/macros-nonfatal-errors.rs:28:5\n    |\n LL |     include_str!(\"i'd be quite surprised if a file with this name existed\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:28:20\n+  --> $DIR/macros-nonfatal-errors.rs:29:20\n    |\n LL |     include_bytes!(invalid);\n    |                    ^^^^^^^\n \n error: couldn't read $DIR/i'd be quite surprised if a file with this name existed: $FILE_NOT_FOUND_MSG (os error 2)\n-  --> $DIR/macros-nonfatal-errors.rs:29:5\n+  --> $DIR/macros-nonfatal-errors.rs:30:5\n    |\n LL |     include_bytes!(\"i'd be quite surprised if a file with this name existed\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: trace_macros! accepts only `true` or `false`\n-  --> $DIR/macros-nonfatal-errors.rs:31:5\n+  --> $DIR/macros-nonfatal-errors.rs:32:5\n    |\n LL |     trace_macros!(invalid);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0665`."}, {"sha": "f738c16673dca9f16a156dc3c23ee1121b394498", "filename": "src/test/ui/target-feature/gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -25,6 +25,7 @@\n // gate-test-movbe_target_feature\n // gate-test-rtm_target_feature\n // gate-test-f16c_target_feature\n+// gate-test-riscv_target_feature\n \n #[target_feature(enable = \"avx512bw\")]\n //~^ ERROR: currently unstable"}, {"sha": "2384a00aa47aa2395ea11d580cf3250289c3fbea", "filename": "src/test/ui/target-feature/gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable\n-  --> $DIR/gate.rs:29:18\n+  --> $DIR/gate.rs:30:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^"}, {"sha": "38a5829b3f74530d7b38c0090fec56043ae1ab3c", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -16,8 +16,8 @@ use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    def_id, BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, LoopSource,\n-    MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+    def_id, BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand,\n+    LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -693,6 +693,20 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n+        ExprKind::InlineAsm(ref asm) => asm\n+            .operands\n+            .iter()\n+            .map(|o| match o {\n+                InlineAsmOperand::In { expr, .. }\n+                | InlineAsmOperand::InOut { expr, .. }\n+                | InlineAsmOperand::Const { expr }\n+                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n+                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n+                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                    never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n+                },\n+            })\n+            .fold(NeverLoopResult::Otherwise, combine_both),\n         ExprKind::Struct(_, _, None)\n         | ExprKind::Yield(_, _)\n         | ExprKind::Closure(_, _, _, _, _)"}, {"sha": "bbcf396eef7d61ba1b04144da9bc59ffc82ed825", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -469,6 +469,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     println!(\"Ret(None) = {};\", current);\n                 }\n             },\n+            ExprKind::InlineAsm(_) => {\n+                println!(\"InlineAsm(_) = {};\", current);\n+                println!(\"    // unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n+            },\n             ExprKind::LlvmInlineAsm(_) => {\n                 println!(\"LlvmInlineAsm(_) = {};\", current);\n                 println!(\"    // unimplemented: `ExprKind::LlvmInlineAsm` is not further destructured at the moment\");"}, {"sha": "92c27e79452ab7110ba6f41ed9039f6cf906126c", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,10 +1,11 @@\n use crate::consts::{constant_context, constant_simple};\n use crate::utils::differing_macro_contexts;\n+use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{\n     BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FnRetTy, GenericArg,\n-    GenericArgs, Guard, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path, PathSegment, QPath, Stmt, StmtKind, Ty,\n-    TyKind, TypeBinding,\n+    GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path, PathSegment, QPath,\n+    Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n@@ -474,6 +475,56 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n+            ExprKind::InlineAsm(ref asm) => {\n+                for piece in asm.template {\n+                    match piece {\n+                        InlineAsmTemplatePiece::String(s) => s.hash(&mut self.s),\n+                        InlineAsmTemplatePiece::Placeholder {\n+                            operand_idx,\n+                            modifier,\n+                            span: _,\n+                        } => {\n+                            operand_idx.hash(&mut self.s);\n+                            modifier.hash(&mut self.s);\n+                        },\n+                    }\n+                }\n+                asm.options.hash(&mut self.s);\n+                for op in asm.operands {\n+                    match op {\n+                        InlineAsmOperand::In { reg, expr } => {\n+                            reg.hash(&mut self.s);\n+                            self.hash_expr(expr);\n+                        },\n+                        InlineAsmOperand::Out { reg, late, expr } => {\n+                            reg.hash(&mut self.s);\n+                            late.hash(&mut self.s);\n+                            if let Some(expr) = expr {\n+                                self.hash_expr(expr);\n+                            }\n+                        },\n+                        InlineAsmOperand::InOut { reg, late, expr } => {\n+                            reg.hash(&mut self.s);\n+                            late.hash(&mut self.s);\n+                            self.hash_expr(expr);\n+                        },\n+                        InlineAsmOperand::SplitInOut {\n+                            reg,\n+                            late,\n+                            in_expr,\n+                            out_expr,\n+                        } => {\n+                            reg.hash(&mut self.s);\n+                            late.hash(&mut self.s);\n+                            self.hash_expr(in_expr);\n+                            if let Some(out_expr) = out_expr {\n+                                self.hash_expr(out_expr);\n+                            }\n+                        },\n+                        InlineAsmOperand::Const { expr } | InlineAsmOperand::Sym { expr } => self.hash_expr(expr),\n+                    }\n+                }\n+            },\n             ExprKind::LlvmInlineAsm(..) | ExprKind::Err => {},\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);"}, {"sha": "748c11fac64ff523a01ad0c454204a4e2134b159", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -1,7 +1,7 @@\n //! checks for attributes\n \n use crate::utils::get_attr;\n-use rustc_ast::ast::Attribute;\n+use rustc_ast::ast::{Attribute, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::Session;\n@@ -282,6 +282,31 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n+        hir::ExprKind::InlineAsm(ref asm) => {\n+            println!(\"{}InlineAsm\", ind);\n+            println!(\"{}template: {}\", ind, InlineAsmTemplatePiece::to_string(asm.template));\n+            println!(\"{}options: {:?}\", ind, asm.options);\n+            println!(\"{}operands:\", ind);\n+            for op in asm.operands {\n+                match op {\n+                    hir::InlineAsmOperand::In { expr, .. } => print_expr(cx, expr, indent + 1),\n+                    hir::InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            print_expr(cx, expr, indent + 1);\n+                        }\n+                    },\n+                    hir::InlineAsmOperand::InOut { expr, .. } => print_expr(cx, expr, indent + 1),\n+                    hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        print_expr(cx, in_expr, indent + 1);\n+                        if let Some(out_expr) = out_expr {\n+                            print_expr(cx, out_expr, indent + 1);\n+                        }\n+                    },\n+                    hir::InlineAsmOperand::Const { expr } => print_expr(cx, expr, indent + 1),\n+                    hir::InlineAsmOperand::Sym { expr } => print_expr(cx, expr, indent + 1),\n+                }\n+            }\n+        },\n         hir::ExprKind::LlvmInlineAsm(ref asm) => {\n             let inputs = &asm.inputs_exprs;\n             let outputs = &asm.outputs_exprs;"}, {"sha": "4ebe2e2852fb4445492161c8bfd693db4dc4fed1", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -108,6 +108,7 @@ impl<'a> Sugg<'a> {\n             | hir::ExprKind::Call(..)\n             | hir::ExprKind::Field(..)\n             | hir::ExprKind::Index(..)\n+            | hir::ExprKind::InlineAsm(..)\n             | hir::ExprKind::LlvmInlineAsm(..)\n             | hir::ExprKind::Lit(..)\n             | hir::ExprKind::Loop(..)\n@@ -150,6 +151,7 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::Field(..)\n             | ast::ExprKind::ForLoop(..)\n             | ast::ExprKind::Index(..)\n+            | ast::ExprKind::InlineAsm(..)\n             | ast::ExprKind::LlvmInlineAsm(..)\n             | ast::ExprKind::Lit(..)\n             | ast::ExprKind::Loop(..)"}, {"sha": "dfa6223f1b9dd104c4ec32cedbac186205f2f362", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a7dfda40a3e798bf086bd58cc7e5e09deb808b5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=3a7dfda40a3e798bf086bd58cc7e5e09deb808b5", "patch": "@@ -353,7 +353,8 @@ impl Write {\n         is_write: bool,\n     ) -> (Option<StrLit>, Option<Expr>) {\n         use fmt_macros::{\n-            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, Parser, Piece,\n+            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, ParseMode, Parser,\n+            Piece,\n         };\n         let tts = tts.clone();\n \n@@ -376,7 +377,7 @@ impl Write {\n         };\n         let tmp = fmtstr.symbol.as_str();\n         let mut args = vec![];\n-        let mut fmt_parser = Parser::new(&tmp, None, Vec::new(), false);\n+        let mut fmt_parser = Parser::new(&tmp, None, None, false, ParseMode::Format);\n         while let Some(piece) = fmt_parser.next() {\n             if !fmt_parser.errors.is_empty() {\n                 return (None, expr);"}]}