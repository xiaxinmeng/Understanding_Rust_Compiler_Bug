{"sha": "357d53c4ce6eed4d93fe1ed576613687d34d10b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1N2Q1M2M0Y2U2ZWVkNGQ5M2ZlMWVkNTc2NjEzNjg3ZDM0ZDEwYjI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-12T12:44:00Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-12T15:02:00Z"}, "message": "Introduce Constructor::NonExhaustive\n\nIt counts as an extra constructor for types that are not allowed to be\nmatched exhaustively.", "tree": {"sha": "ee7772e04d943145d140d1a4e4ac581498d971b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee7772e04d943145d140d1a4e4ac581498d971b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/357d53c4ce6eed4d93fe1ed576613687d34d10b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/357d53c4ce6eed4d93fe1ed576613687d34d10b2", "html_url": "https://github.com/rust-lang/rust/commit/357d53c4ce6eed4d93fe1ed576613687d34d10b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/357d53c4ce6eed4d93fe1ed576613687d34d10b2/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb99c73e04ae48a7847c703cb29f5b0bb8595f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb99c73e04ae48a7847c703cb29f5b0bb8595f08", "html_url": "https://github.com/rust-lang/rust/commit/eb99c73e04ae48a7847c703cb29f5b0bb8595f08"}], "stats": {"total": 115, "additions": 58, "deletions": 57}, "files": [{"sha": "fbf073d9423d931262e6f1f4b28b72ad581482af", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 58, "deletions": 57, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/357d53c4ce6eed4d93fe1ed576613687d34d10b2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357d53c4ce6eed4d93fe1ed576613687d34d10b2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=357d53c4ce6eed4d93fe1ed576613687d34d10b2", "patch": "@@ -590,13 +590,16 @@ enum Constructor<'tcx> {\n     FixedLenSlice(u64),\n     /// Slice patterns. Captures any array constructor of `length >= i + j`.\n     VarLenSlice(u64, u64),\n+    /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n+    NonExhaustive,\n }\n \n // Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n             (Constructor::Single, Constructor::Single) => true,\n+            (Constructor::NonExhaustive, Constructor::NonExhaustive) => true,\n             (Constructor::Variant(a), Constructor::Variant(b)) => a == b,\n             (Constructor::ConstantValue(a, _), Constructor::ConstantValue(b, _)) => a == b,\n             (\n@@ -771,6 +774,8 @@ impl<'tcx> Constructor<'tcx> {\n                 // ranges have been omitted.\n                 remaining_ctors\n             }\n+            // This constructor is never covered by anything else\n+            NonExhaustive => vec![NonExhaustive],\n         }\n     }\n \n@@ -842,7 +847,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n-            ConstantValue(..) | ConstantRange(..) => vec![],\n+            ConstantValue(..) | ConstantRange(..) | NonExhaustive => vec![],\n         }\n     }\n \n@@ -865,7 +870,7 @@ impl<'tcx> Constructor<'tcx> {\n             },\n             FixedLenSlice(length) => *length,\n             VarLenSlice(prefix, suffix) => prefix + suffix,\n-            ConstantValue(..) | ConstantRange(..) => 0,\n+            ConstantValue(..) | ConstantRange(..) | NonExhaustive => 0,\n         }\n     }\n \n@@ -932,6 +937,7 @@ impl<'tcx> Constructor<'tcx> {\n                 hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                 end,\n             }),\n+            NonExhaustive => PatKind::Wild,\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1193,6 +1199,36 @@ fn all_constructors<'a, 'tcx>(\n             }\n         }\n     };\n+\n+    // FIXME: currently the only way I know of something can\n+    // be a privately-empty enum is when the exhaustive_patterns\n+    // feature flag is not present, so this is only\n+    // needed for that case.\n+    let is_privately_empty = ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+    let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n+    let is_non_exhaustive = is_privately_empty\n+        || is_declared_nonexhaustive\n+        || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n+    if is_non_exhaustive {\n+        // If our scrutinee is *privately* an empty enum, we must treat it as though it had an\n+        // \"unknown\" constructor (in that case, all other patterns obviously can't be variants) to\n+        // avoid exposing its emptyness. See the `match_privately_empty` test for details.\n+        //\n+        // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an additionnal\n+        // \"unknown\" constructor. However there is no point in enumerating all possible variants,\n+        // because the user can't actually match against them themselves. So we return only the\n+        // fictitious constructor.\n+        // E.g., in an example like:\n+        // ```\n+        //     let err: io::ErrorKind = ...;\n+        //     match err {\n+        //         io::ErrorKind::NotFound => {},\n+        //     }\n+        // ```\n+        // we don't want to show every possible IO error, but instead have only `_` as the witness.\n+        return vec![NonExhaustive];\n+    }\n+\n     ctors\n }\n \n@@ -1591,48 +1627,22 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         let all_ctors = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n \n-        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-\n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n         // from the first column.\n         //\n         // Therefore, if there is some pattern that is unmatched by `matrix`,\n         // it will still be unmatched if the first constructor is replaced by\n         // any of the constructors in `missing_ctors`\n-        //\n-        // However, if our scrutinee is *privately* an empty enum, we\n-        // must treat it as though it had an \"unknown\" constructor (in\n-        // that case, all other patterns obviously can't be variants)\n-        // to avoid exposing its emptyness. See the `match_privately_empty`\n-        // test for details.\n-        //\n-        // FIXME: currently the only way I know of something can\n-        // be a privately-empty enum is when the exhaustive_patterns\n-        // feature flag is not present, so this is only\n-        // needed for that case.\n-\n-        // Missing constructors are those that are not matched by any\n-        // non-wildcard patterns in the current column. To determine if\n-        // the set is empty, we can check that `.peek().is_none()`, so\n-        // we only fully construct them on-demand, because they're rarely used and can be big.\n-        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n \n-        debug!(\n-            \"missing_ctors.empty()={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-            missing_ctors.is_empty(),\n-            is_privately_empty,\n-            is_declared_nonexhaustive\n-        );\n+        // Missing constructors are those that are not matched by any non-wildcard patterns in the\n+        // current column. We only fully construct them on-demand, because they're rarely used and\n+        // can be big.\n+        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n \n-        // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n-        // `_` constructor for the type, so we can never match over all constructors.\n-        let is_non_exhaustive = is_privately_empty\n-            || is_declared_nonexhaustive\n-            || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n+        debug!(\"missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n \n-        if missing_ctors.is_empty() && !is_non_exhaustive {\n+        if missing_ctors.is_empty() {\n             let (all_ctors, _) = missing_ctors.into_inner();\n             split_grouped_constructors(cx.tcx, cx.param_env, pcx, all_ctors, matrix, DUMMY_SP, None)\n                 .into_iter()\n@@ -1661,26 +1671,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             //\n             // we can report 3 witnesses: `S`, `E`, and `W`.\n             //\n-            // However, there are 2 cases where we don't want\n+            // However, there is a case where we don't want\n             // to do this and instead report a single `_` witness:\n-            //\n-            // 1) If the user is matching against a non-exhaustive\n-            // enum, there is no point in enumerating all possible\n-            // variants, because the user can't actually match\n-            // against them themselves, e.g., in an example like:\n-            // ```\n-            //     let err: io::ErrorKind = ...;\n-            //     match err {\n-            //         io::ErrorKind::NotFound => {},\n-            //     }\n-            // ```\n-            // we don't want to show every possible IO error,\n-            // but instead have `_` as the witness (this is\n-            // actually *required* if the user specified *all*\n-            // IO errors, but is probably what we want in every\n-            // case).\n-            //\n-            // 2) If the user didn't actually specify a constructor\n+            // if the user didn't actually specify a constructor\n             // in this arm, e.g., in\n             // ```\n             //     let x: (Direction, Direction, bool) = ...;\n@@ -1690,7 +1683,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             // `(<direction-1>, <direction-2>, true)` - we are\n             // satisfied with `(_, _, true)`. In this case,\n             // `used_ctors` is empty.\n-            if is_non_exhaustive || missing_ctors.all_ctors_are_missing() {\n+            if missing_ctors.all_ctors_are_missing() {\n                 // All constructors are unused. Add a wild pattern\n                 // rather than each individual constructor.\n                 usefulness.apply_wildcard(pcx.ty)\n@@ -2217,13 +2210,21 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n /// fields filled with wild patterns.\n fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    pat: &'q Pat<'tcx>,\n+    mut pat: &'q Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n ) -> Option<PatStack<'p, 'tcx>> {\n+    while let PatKind::AscribeUserType { ref subpattern, .. } = *pat.kind {\n+        pat = subpattern;\n+    }\n+\n+    if let NonExhaustive = constructor {\n+        // Only a wildcard pattern can match the special extra constructor\n+        return if pat.is_wildcard() { Some(PatStack::default()) } else { None };\n+    }\n+\n     let result = match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } => PatStack::from_pattern(subpattern)\n-            .specialize_constructor(cx, constructor, ctor_wild_subpatterns),\n+        PatKind::AscribeUserType { .. } => bug!(), // Handled above\n \n         PatKind::Binding { .. } | PatKind::Wild => {\n             Some(PatStack::from_slice(ctor_wild_subpatterns))"}]}