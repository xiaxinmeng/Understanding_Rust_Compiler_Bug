{"sha": "cbc70ff277dda8b7f227208eff789f1f68b6de5a", "node_id": "C_kwDOAAsO6NoAKGNiYzcwZmYyNzdkZGE4YjdmMjI3MjA4ZWZmNzg5ZjFmNjhiNmRlNWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-10T08:23:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-10T08:23:16Z"}, "message": "Auto merge of #105357 - oli-obk:feeding, r=cjgillot,petrochenkov\n\nGroup some fields in a common struct so we only pass one reference instead of three\n\nr? `@cjgillot`", "tree": {"sha": "be989eef9d0e7345ca13369408e6c7420a45824e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be989eef9d0e7345ca13369408e6c7420a45824e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbc70ff277dda8b7f227208eff789f1f68b6de5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc70ff277dda8b7f227208eff789f1f68b6de5a", "html_url": "https://github.com/rust-lang/rust/commit/cbc70ff277dda8b7f227208eff789f1f68b6de5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbc70ff277dda8b7f227208eff789f1f68b6de5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a000811405e6a3ca9b0b129c1177e78564e09666", "url": "https://api.github.com/repos/rust-lang/rust/commits/a000811405e6a3ca9b0b129c1177e78564e09666", "html_url": "https://github.com/rust-lang/rust/commit/a000811405e6a3ca9b0b129c1177e78564e09666"}, {"sha": "75ff5c7dd3c50371f77ae29d43f87343d44b3829", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ff5c7dd3c50371f77ae29d43f87343d44b3829", "html_url": "https://github.com/rust-lang/rust/commit/75ff5c7dd3c50371f77ae29d43f87343d44b3829"}], "stats": {"total": 349, "additions": 164, "deletions": 185}, "files": [{"sha": "6dac48b20d5e214b06c7af818fc48f2dc50dd5fe", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -4343,6 +4343,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_serialize\","}, {"sha": "89d9450cf4e89a0b6335647b5bf5f2446f7207bd", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -805,9 +805,9 @@ pub fn create_global_ctxt<'tcx>(\n     });\n \n     let ty::ResolverOutputs {\n-        definitions,\n         global_ctxt: untracked_resolutions,\n         ast_lowering: untracked_resolver_for_lowering,\n+        untracked,\n     } = resolver_outputs;\n \n     let gcx = sess.time(\"setup_global_ctxt\", || {\n@@ -817,8 +817,8 @@ pub fn create_global_ctxt<'tcx>(\n                 lint_store,\n                 arena,\n                 hir_arena,\n-                definitions,\n                 untracked_resolutions,\n+                untracked,\n                 krate,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),"}, {"sha": "01d7f3e03c50a5520d5c4d5f3efe1bd8a7d67d9d", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n@@ -68,11 +68,12 @@ impl std::fmt::Debug for CStore {\n pub struct CrateLoader<'a> {\n     // Immutable configuration.\n     sess: &'a Session,\n-    metadata_loader: Box<MetadataLoaderDyn>,\n+    metadata_loader: &'a MetadataLoaderDyn,\n+    definitions: ReadGuard<'a, Definitions>,\n     local_crate_name: Symbol,\n     // Mutable output.\n-    cstore: CStore,\n-    used_extern_options: FxHashSet<Symbol>,\n+    cstore: &'a mut CStore,\n+    used_extern_options: &'a mut FxHashSet<Symbol>,\n }\n \n pub enum LoadedMacro {\n@@ -239,47 +240,49 @@ impl CStore {\n             );\n         }\n     }\n+\n+    pub fn new(sess: &Session) -> CStore {\n+        let mut stable_crate_ids = FxHashMap::default();\n+        stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n+        CStore {\n+            // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n+            // order to make array indices in `metas` match with the\n+            // corresponding `CrateNum`. This first entry will always remain\n+            // `None`.\n+            metas: IndexVec::from_elem_n(None, 1),\n+            injected_panic_runtime: None,\n+            allocator_kind: None,\n+            alloc_error_handler_kind: None,\n+            has_global_allocator: false,\n+            has_alloc_error_handler: false,\n+            stable_crate_ids,\n+            unused_externs: Vec::new(),\n+        }\n+    }\n }\n \n impl<'a> CrateLoader<'a> {\n     pub fn new(\n         sess: &'a Session,\n-        metadata_loader: Box<MetadataLoaderDyn>,\n+        metadata_loader: &'a MetadataLoaderDyn,\n         local_crate_name: Symbol,\n+        cstore: &'a mut CStore,\n+        definitions: ReadGuard<'a, Definitions>,\n+        used_extern_options: &'a mut FxHashSet<Symbol>,\n     ) -> Self {\n-        let mut stable_crate_ids = FxHashMap::default();\n-        stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n-\n         CrateLoader {\n             sess,\n             metadata_loader,\n             local_crate_name,\n-            cstore: CStore {\n-                // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n-                // order to make array indices in `metas` match with the\n-                // corresponding `CrateNum`. This first entry will always remain\n-                // `None`.\n-                metas: IndexVec::from_elem_n(None, 1),\n-                injected_panic_runtime: None,\n-                allocator_kind: None,\n-                alloc_error_handler_kind: None,\n-                has_global_allocator: false,\n-                has_alloc_error_handler: false,\n-                stable_crate_ids,\n-                unused_externs: Vec::new(),\n-            },\n-            used_extern_options: Default::default(),\n+            cstore,\n+            used_extern_options,\n+            definitions,\n         }\n     }\n-\n     pub fn cstore(&self) -> &CStore {\n         &self.cstore\n     }\n \n-    pub fn into_cstore(self) -> CStore {\n-        self.cstore\n-    }\n-\n     fn existing_match(&self, name: Symbol, hash: Option<Svh>, kind: PathKind) -> Option<CrateNum> {\n         for (cnum, data) in self.cstore.iter_crate_data() {\n             if data.name() != name {\n@@ -989,7 +992,6 @@ impl<'a> CrateLoader<'a> {\n     pub fn process_extern_crate(\n         &mut self,\n         item: &ast::Item,\n-        definitions: &Definitions,\n         def_id: LocalDefId,\n     ) -> Option<CrateNum> {\n         match item.kind {\n@@ -1013,7 +1015,7 @@ impl<'a> CrateLoader<'a> {\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind)?;\n \n-                let path_len = definitions.def_path(def_id).data.len();\n+                let path_len = self.definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,\n                     ExternCrate {"}, {"sha": "9d0ccfeb16898309ae374f4b6b392e032eb4d550", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -629,6 +629,9 @@ impl CrateStore for CStore {\n     fn as_any(&self) -> &dyn Any {\n         self\n     }\n+    fn untracked_as_any(&mut self) -> &mut dyn Any {\n+        self\n+    }\n \n     fn crate_name(&self, cnum: CrateNum) -> Symbol {\n         self.get_crate_data(cnum).root.name"}, {"sha": "0450abed51b0652338a9bd7799d0dd2e566c62db", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -14,7 +14,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::hir::nested_filter;\n use rustc_span::def_id::StableCrateId;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n #[inline]\n@@ -1162,7 +1162,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n                 .filter_map(|(def_id, info)| {\n                     let _ = info.as_owner()?;\n                     let def_path_hash = definitions.def_path_hash(def_id);\n-                    let span = resolutions.source_span.get(def_id).unwrap_or(&DUMMY_SP);\n+                    let span = tcx.source_span(def_id);\n                     debug_assert_eq!(span.parent(), None);\n                     Some((def_path_hash, span))\n                 })"}, {"sha": "3f6e29ad611c911daf807d72be51dc5eb6e00780", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -141,8 +141,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_attrs = |tcx, id| {\n         tcx.hir_crate(()).owners[id.def_id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs)\n     };\n-    providers.source_span =\n-        |tcx, def_id| tcx.resolutions(()).source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n     providers.def_span = |tcx, def_id| {\n         let def_id = def_id.expect_local();\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);"}, {"sha": "ab512804330b9f647ca9bc14edf2e0d698b53b4a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -43,6 +43,8 @@ rustc_queries! {\n     /// This span is meant for dep-tracking rather than diagnostics. It should not be used outside\n     /// of rustc_middle::hir::source_map.\n     query source_span(key: LocalDefId) -> Span {\n+        // Accesses untracked data\n+        eval_always\n         desc { \"getting the source span\" }\n     }\n "}, {"sha": "7d4971d1e9e62d6fb5166ed9a5e248ea44164d2d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 34, "deletions": 66, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n-use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, RwLock, WorkerLocal};\n+use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, WorkerLocal};\n use rustc_data_structures::unord::UnordSet;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{\n@@ -59,7 +59,7 @@ use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n-use rustc_session::cstore::CrateStoreDyn;\n+use rustc_session::cstore::{CrateStoreDyn, Untracked};\n use rustc_session::lint::Lint;\n use rustc_session::Limit;\n use rustc_session::Session;\n@@ -182,20 +182,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n     /// Interns a type.\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n-    fn intern_ty(\n-        &self,\n-        kind: TyKind<'tcx>,\n-        sess: &Session,\n-        definitions: &rustc_hir::definitions::Definitions,\n-        cstore: &CrateStoreDyn,\n-        source_span: &IndexVec<LocalDefId, Span>,\n-    ) -> Ty<'tcx> {\n+    fn intern_ty(&self, kind: TyKind<'tcx>, sess: &Session, untracked: &Untracked) -> Ty<'tcx> {\n         Ty(Interned::new_unchecked(\n             self.type_\n                 .intern(kind, |kind| {\n                     let flags = super::flags::FlagComputation::for_kind(&kind);\n-                    let stable_hash =\n-                        self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n+                    let stable_hash = self.stable_hash(&flags, sess, untracked, &kind);\n \n                     InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n                         internee: kind,\n@@ -212,9 +204,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         &self,\n         flags: &ty::flags::FlagComputation,\n         sess: &'a Session,\n-        definitions: &'a rustc_hir::definitions::Definitions,\n-        cstore: &'a CrateStoreDyn,\n-        source_span: &'a IndexVec<LocalDefId, Span>,\n+        untracked: &'a Untracked,\n         val: &T,\n     ) -> Fingerprint {\n         // It's impossible to hash inference variables (and will ICE), so we don't need to try to cache them.\n@@ -223,7 +213,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             Fingerprint::ZERO\n         } else {\n             let mut hasher = StableHasher::new();\n-            let mut hcx = StableHashingContext::new(sess, definitions, cstore, source_span);\n+            let mut hcx = StableHashingContext::new(sess, untracked);\n             val.hash_stable(&mut hcx, &mut hasher);\n             hasher.finish()\n         }\n@@ -234,17 +224,14 @@ impl<'tcx> CtxtInterners<'tcx> {\n         &self,\n         kind: Binder<'tcx, PredicateKind<'tcx>>,\n         sess: &Session,\n-        definitions: &rustc_hir::definitions::Definitions,\n-        cstore: &CrateStoreDyn,\n-        source_span: &IndexVec<LocalDefId, Span>,\n+        untracked: &Untracked,\n     ) -> Predicate<'tcx> {\n         Predicate(Interned::new_unchecked(\n             self.predicate\n                 .intern(kind, |kind| {\n                     let flags = super::flags::FlagComputation::for_predicate(kind);\n \n-                    let stable_hash =\n-                        self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n+                    let stable_hash = self.stable_hash(&flags, sess, untracked, &kind);\n \n                     InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n                         internee: kind,\n@@ -962,11 +949,9 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(\n         interners: &CtxtInterners<'tcx>,\n         sess: &Session,\n-        definitions: &rustc_hir::definitions::Definitions,\n-        cstore: &CrateStoreDyn,\n-        source_span: &IndexVec<LocalDefId, Span>,\n+        untracked: &Untracked,\n     ) -> CommonTypes<'tcx> {\n-        let mk = |ty| interners.intern_ty(ty, sess, definitions, cstore, source_span);\n+        let mk = |ty| interners.intern_ty(ty, sess, untracked);\n \n         CommonTypes {\n             unit: mk(Tuple(List::empty())),\n@@ -1112,8 +1097,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n-    definitions: RwLock<Definitions>,\n-\n+    untracked: Untracked,\n     /// Output of the resolver.\n     pub(crate) untracked_resolutions: ty::ResolverGlobalCtxt,\n     /// The entire crate as AST. This field serves as the input for the hir_crate query,\n@@ -1278,8 +1262,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n-        definitions: Definitions,\n         untracked_resolutions: ty::ResolverGlobalCtxt,\n+        untracked: Untracked,\n         krate: Lrc<ast::Crate>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n@@ -1292,14 +1276,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             s.emit_fatal(err);\n         });\n         let interners = CtxtInterners::new(arena);\n-        let common_types = CommonTypes::new(\n-            &interners,\n-            s,\n-            &definitions,\n-            &*untracked_resolutions.cstore,\n-            // This is only used to create a stable hashing context.\n-            &untracked_resolutions.source_span,\n-        );\n+        let common_types = CommonTypes::new(&interners, s, &untracked);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n \n@@ -1310,11 +1287,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             hir_arena,\n             interners,\n             dep_graph,\n-            definitions: RwLock::new(definitions),\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n+            untracked,\n             untracked_resolutions,\n             untracked_crate: Steal::new(krate),\n             on_disk_cache,\n@@ -1428,7 +1405,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_key(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_key(id)\n+            self.untracked.cstore.def_key(id)\n         }\n     }\n \n@@ -1442,7 +1419,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_path(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path(id)\n+            self.untracked.cstore.def_path(id)\n         }\n     }\n \n@@ -1452,7 +1429,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.definitions_untracked().def_path_hash(def_id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path_hash(def_id)\n+            self.untracked.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1461,7 +1438,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id(crate_num)\n+            self.untracked.cstore.stable_crate_id(crate_num)\n         }\n     }\n \n@@ -1472,7 +1449,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.untracked.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -1487,11 +1464,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         // If this is a DefPathHash from the local crate, we can look up the\n         // DefId in the tcx's `Definitions`.\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n-            self.definitions.read().local_def_path_hash_to_def_id(hash, err).to_def_id()\n+            self.untracked.definitions.read().local_def_path_hash_to_def_id(hash, err).to_def_id()\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cstore = &*self.untracked_resolutions.cstore;\n+            let cstore = &*self.untracked.cstore;\n             let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n             cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n@@ -1505,7 +1482,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &*self.untracked_resolutions.cstore;\n+            let cstore = &*self.untracked.cstore;\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1547,7 +1524,7 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         // This is fine because:\n         // - those queries are `eval_always` so we won't miss their result changing;\n         // - this write will have happened before these queries are called.\n-        let key = self.definitions.write().create_def(parent, data);\n+        let key = self.untracked.definitions.write().create_def(parent, data);\n \n         let feed = TyCtxtFeed { tcx: self.tcx, key };\n         feed.def_span(self.span);\n@@ -1561,7 +1538,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // definitions change.\n         self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n \n-        let definitions = &self.definitions;\n+        let definitions = &self.untracked.definitions;\n         std::iter::from_generator(|| {\n             let mut i = 0;\n \n@@ -1585,7 +1562,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n         // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n-        let definitions = self.definitions.leak();\n+        let definitions = self.untracked.definitions.leak();\n         definitions.def_path_table()\n     }\n \n@@ -1597,43 +1574,36 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ensure().hir_crate(());\n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n         // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n-        let definitions = self.definitions.leak();\n+        let definitions = self.untracked.definitions.leak();\n         definitions.def_path_hash_to_def_index_map()\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n-        &*self.untracked_resolutions.cstore\n+        &*self.untracked.cstore\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n     pub fn definitions_untracked(self) -> ReadGuard<'tcx, Definitions> {\n-        self.definitions.read()\n+        self.untracked.definitions.read()\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n     pub fn source_span_untracked(self, def_id: LocalDefId) -> Span {\n-        self.untracked_resolutions.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n+        self.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n     }\n \n     #[inline(always)]\n     pub fn with_stable_hashing_context<R>(\n         self,\n         f: impl FnOnce(StableHashingContext<'_>) -> R,\n     ) -> R {\n-        let definitions = self.definitions_untracked();\n-        let hcx = StableHashingContext::new(\n-            self.sess,\n-            &*definitions,\n-            &*self.untracked_resolutions.cstore,\n-            &self.untracked_resolutions.source_span,\n-        );\n-        f(hcx)\n+        f(StableHashingContext::new(self.sess, &self.untracked))\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n@@ -2427,10 +2397,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_ty(\n             st,\n             self.sess,\n-            &self.definitions.read(),\n-            &*self.untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n-            &self.untracked_resolutions.source_span,\n+            &self.untracked,\n         )\n     }\n \n@@ -2439,10 +2407,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_predicate(\n             binder,\n             self.sess,\n-            &self.definitions.read(),\n-            &*self.untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n-            &self.untracked_resolutions.source_span,\n+            &self.untracked,\n         )\n     }\n \n@@ -3124,4 +3090,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         // We want to check if the panic handler was defined in this crate\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n     };\n+    providers.source_span =\n+        |tcx, def_id| tcx.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n }"}, {"sha": "659d99f025da03a469729b0f070448ac23cfc240", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -40,13 +40,12 @@ use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n-use rustc_hir::definitions::Definitions;\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_session::cstore::CrateStoreDyn;\n+use rustc_session::cstore::Untracked;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, Span};\n@@ -150,21 +149,18 @@ mod sty;\n pub type RegisteredTools = FxHashSet<Ident>;\n \n pub struct ResolverOutputs {\n-    pub definitions: Definitions,\n     pub global_ctxt: ResolverGlobalCtxt,\n     pub ast_lowering: ResolverAstLowering,\n+    pub untracked: Untracked,\n }\n \n #[derive(Debug)]\n pub struct ResolverGlobalCtxt {\n-    pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n     pub has_pub_restricted: bool,\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     pub expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-    /// Reference span for definitions.\n-    pub source_span: IndexVec<LocalDefId, Span>,\n     pub effective_visibilities: EffectiveVisibilities,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,"}, {"sha": "163da59edd5c7378fe43f9f8c565ae1237d72693", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -6,9 +6,8 @@ use rustc_data_structures::stable_hasher::{HashStable, HashingControls, StableHa\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::definitions::{DefPathHash, Definitions};\n-use rustc_index::vec::IndexVec;\n-use rustc_session::cstore::CrateStore;\n+use rustc_hir::definitions::DefPathHash;\n+use rustc_session::cstore::Untracked;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Symbol;\n@@ -20,9 +19,7 @@ use rustc_span::{BytePos, CachingSourceMapView, SourceFile, Span, SpanData, DUMM\n /// things (e.g., each `DefId`/`DefPath` is only hashed once).\n #[derive(Clone)]\n pub struct StableHashingContext<'a> {\n-    definitions: &'a Definitions,\n-    cstore: &'a dyn CrateStore,\n-    source_span: &'a IndexVec<LocalDefId, Span>,\n+    untracked: &'a Untracked,\n     // The value of `-Z incremental-ignore-spans`.\n     // This field should only be used by `unstable_opts_incremental_ignore_span`\n     incremental_ignore_spans: bool,\n@@ -49,19 +46,12 @@ pub(super) enum BodyResolver<'tcx> {\n \n impl<'a> StableHashingContext<'a> {\n     #[inline]\n-    pub fn new(\n-        sess: &'a Session,\n-        definitions: &'a Definitions,\n-        cstore: &'a dyn CrateStore,\n-        source_span: &'a IndexVec<LocalDefId, Span>,\n-    ) -> Self {\n+    pub fn new(sess: &'a Session, untracked: &'a Untracked) -> Self {\n         let hash_spans_initial = !sess.opts.unstable_opts.incremental_ignore_spans;\n \n         StableHashingContext {\n             body_resolver: BodyResolver::Forbidden,\n-            definitions,\n-            cstore,\n-            source_span,\n+            untracked,\n             incremental_ignore_spans: sess.opts.unstable_opts.incremental_ignore_spans,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n@@ -100,13 +90,13 @@ impl<'a> StableHashingContext<'a> {\n         if let Some(def_id) = def_id.as_local() {\n             self.local_def_path_hash(def_id)\n         } else {\n-            self.cstore.def_path_hash(def_id)\n+            self.untracked.cstore.def_path_hash(def_id)\n         }\n     }\n \n     #[inline]\n     pub fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash {\n-        self.definitions.def_path_hash(def_id)\n+        self.untracked.definitions.read().def_path_hash(def_id)\n     }\n \n     #[inline]\n@@ -156,7 +146,7 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n \n     #[inline]\n     fn def_span(&self, def_id: LocalDefId) -> Span {\n-        *self.source_span.get(def_id).unwrap_or(&DUMMY_SP)\n+        *self.untracked.source_span.get(def_id).unwrap_or(&DUMMY_SP)\n     }\n \n     #[inline]"}, {"sha": "f4a6a08df1c8514fe24987fce26eb2827b7afcc4", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -836,12 +836,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         } else if orig_name == Some(kw::SelfLower) {\n             Some(self.r.graph_root)\n         } else {\n-            self.r.crate_loader.process_extern_crate(item, &self.r.definitions, local_def_id).map(\n-                |crate_id| {\n-                    self.r.extern_crate_map.insert(local_def_id, crate_id);\n-                    self.r.expect_module(crate_id.as_def_id())\n-                },\n-            )\n+            let crate_id = self.r.crate_loader().process_extern_crate(item, local_def_id);\n+            crate_id.map(|crate_id| {\n+                self.r.extern_crate_map.insert(local_def_id, crate_id);\n+                self.r.expect_module(crate_id.as_def_id())\n+            })\n         }\n         .map(|module| {\n             let used = self.process_macro_use_imports(item, module);"}, {"sha": "37771693417b35a8c60d0e571ed98f7dab77a718", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -153,7 +153,7 @@ impl<'a> Resolver<'a> {\n             if !candidates.is_empty() {\n                 show_candidates(\n                     &self.session,\n-                    &self.source_span,\n+                    &self.untracked.source_span,\n                     &mut err,\n                     span,\n                     &candidates,\n@@ -682,7 +682,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     show_candidates(\n                         &self.session,\n-                        &self.source_span,\n+                        &self.untracked.source_span,\n                         &mut err,\n                         Some(span),\n                         &import_suggestions,\n@@ -1298,7 +1298,8 @@ impl<'a> Resolver<'a> {\n                     // otherwise cause duplicate suggestions.\n                     continue;\n                 }\n-                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name) {\n+                let crate_id = self.crate_loader().maybe_process_path_extern(ident.name);\n+                if let Some(crate_id) = crate_id {\n                     let crate_root = self.expect_module(crate_id.as_def_id());\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident,\n@@ -1335,7 +1336,7 @@ impl<'a> Resolver<'a> {\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(\n             &self.session,\n-            &self.source_span,\n+            &self.untracked.source_span,\n             err,\n             None,\n             &import_suggestions,"}, {"sha": "b8efa3f8b2743336dc894dcbac137b8a0047da94", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -107,7 +107,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                 r.effective_visibilities.update_eff_vis(\n                     r.local_def_id(node_id),\n                     eff_vis,\n-                    ResolverTree(&r.definitions, &r.crate_loader),\n+                    ResolverTree(&r.untracked),\n                 )\n             }\n         }"}, {"sha": "4d896b055268e975ab284861e93a8c85a4e70cda", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             if let Some(candidate) = &err.candidate {\n                 import_candidates(\n                     self.r.session,\n-                    &self.r.source_span,\n+                    &self.r.untracked.source_span,\n                     &mut diag,\n                     Some(err.span),\n                     &candidate,"}, {"sha": "d43983ea8150faf15db202c7b8a242a770c81c97", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -1663,8 +1663,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         if !module.no_implicit_prelude {\n                             let extern_prelude = self.r.extern_prelude.clone();\n                             names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n-                                self.r.crate_loader.maybe_process_path_extern(ident.name).and_then(\n-                                    |crate_id| {\n+                                self.r\n+                                    .crate_loader()\n+                                    .maybe_process_path_extern(ident.name)\n+                                    .and_then(|crate_id| {\n                                         let crate_mod =\n                                             Res::Def(DefKind::Mod, crate_id.as_def_id());\n \n@@ -1673,8 +1675,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                                         } else {\n                                             None\n                                         }\n-                                    },\n-                                )\n+                                    })\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {"}, {"sha": "24e4b5bdd3f50d8f84e8d3f435062eb401e9de07", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -29,7 +29,7 @@ use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, RwLock};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n@@ -46,7 +46,7 @@ use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStore, MetadataLoaderDyn, Untracked};\n use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n@@ -866,11 +866,8 @@ struct MacroData {\n pub struct Resolver<'a> {\n     session: &'a Session,\n \n-    definitions: Definitions,\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-    /// Reference span for definitions.\n-    source_span: IndexVec<LocalDefId, Span>,\n \n     graph_root: Module<'a>,\n \n@@ -954,7 +951,10 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    crate_loader: CrateLoader<'a>,\n+    local_crate_name: Symbol,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n+    untracked: Untracked,\n+    used_extern_options: FxHashSet<Symbol>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Symbol, BuiltinMacroState>,\n     /// A small map keeping true kinds of built-in macros that appear to be fn-like on\n@@ -1112,15 +1112,15 @@ impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n /// A minimal subset of resolver that can implemenent `DefIdTree`, sometimes\n /// required to satisfy borrow checker by avoiding borrowing the whole resolver.\n #[derive(Clone, Copy)]\n-struct ResolverTree<'a, 'b>(&'a Definitions, &'a CrateLoader<'b>);\n+struct ResolverTree<'a>(&'a Untracked);\n \n-impl DefIdTree for ResolverTree<'_, '_> {\n+impl DefIdTree for ResolverTree<'_> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        let ResolverTree(definitions, crate_loader) = self;\n+        let ResolverTree(Untracked { definitions, cstore, .. }) = self;\n         match id.as_local() {\n-            Some(id) => definitions.def_key(id).parent,\n-            None => crate_loader.cstore().def_key(id).parent,\n+            Some(id) => definitions.read().def_key(id).parent,\n+            None => cstore.as_any().downcast_ref::<CStore>().unwrap().def_key(id).parent,\n         }\n         .map(|index| DefId { index, ..id })\n     }\n@@ -1129,7 +1129,7 @@ impl DefIdTree for ResolverTree<'_, '_> {\n impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        ResolverTree(&self.definitions, &self.crate_loader).opt_parent(id)\n+        ResolverTree(&self.untracked).opt_parent(id)\n     }\n }\n \n@@ -1156,10 +1156,10 @@ impl Resolver<'_> {\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.definitions.def_key(self.node_id_to_def_id[&node_id]),\n+            self.untracked.definitions.read().def_key(self.node_id_to_def_id[&node_id]),\n         );\n \n-        let def_id = self.definitions.create_def(parent, data);\n+        let def_id = self.untracked.definitions.write().create_def(parent, data);\n \n         // Create the definition.\n         if expn_id != ExpnId::root() {\n@@ -1168,7 +1168,7 @@ impl Resolver<'_> {\n \n         // A relative span's parent must be an absolute span.\n         debug_assert_eq!(span.data_untracked().parent, None);\n-        let _id = self.source_span.push(span);\n+        let _id = self.untracked.source_span.push(span);\n         debug_assert_eq!(_id, def_id);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n@@ -1258,9 +1258,7 @@ impl<'a> Resolver<'a> {\n         let mut resolver = Resolver {\n             session,\n \n-            definitions,\n             expn_that_defined: Default::default(),\n-            source_span,\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1311,7 +1309,14 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n+            metadata_loader,\n+            local_crate_name: crate_name,\n+            used_extern_options: Default::default(),\n+            untracked: Untracked {\n+                cstore: Box::new(CStore::new(session)),\n+                source_span,\n+                definitions: RwLock::new(definitions),\n+            },\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n             builtin_macro_kinds: Default::default(),\n@@ -1402,9 +1407,6 @@ impl<'a> Resolver<'a> {\n \n     pub fn into_outputs(self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n-        let definitions = self.definitions;\n-        let cstore = Box::new(self.crate_loader.into_cstore());\n-        let source_span = self.source_span;\n         let expn_that_defined = self.expn_that_defined;\n         let visibilities = self.visibilities;\n         let has_pub_restricted = self.has_pub_restricted;\n@@ -1416,9 +1418,8 @@ impl<'a> Resolver<'a> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let effective_visibilities = self.effective_visibilities;\n+        let untracked = self.untracked;\n         let global_ctxt = ResolverGlobalCtxt {\n-            cstore,\n-            source_span,\n             expn_that_defined,\n             visibilities,\n             has_pub_restricted,\n@@ -1453,16 +1454,16 @@ impl<'a> Resolver<'a> {\n             builtin_macro_kinds: self.builtin_macro_kinds,\n             lifetime_elision_allowed: self.lifetime_elision_allowed,\n         };\n-        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n+        ResolverOutputs { global_ctxt, ast_lowering, untracked }\n     }\n \n     pub fn clone_outputs(&self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n-        let definitions = self.definitions.clone();\n+        let definitions = self.untracked.definitions.clone();\n         let cstore = Box::new(self.cstore().clone());\n+        let untracked =\n+            Untracked { cstore, source_span: self.untracked.source_span.clone(), definitions };\n         let global_ctxt = ResolverGlobalCtxt {\n-            cstore,\n-            source_span: self.source_span.clone(),\n             expn_that_defined: self.expn_that_defined.clone(),\n             visibilities: self.visibilities.clone(),\n             has_pub_restricted: self.has_pub_restricted,\n@@ -1497,20 +1498,26 @@ impl<'a> Resolver<'a> {\n             builtin_macro_kinds: self.builtin_macro_kinds.clone(),\n             lifetime_elision_allowed: self.lifetime_elision_allowed.clone(),\n         };\n-        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n+        ResolverOutputs { global_ctxt, ast_lowering, untracked }\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(\n-            self.session,\n-            &self.definitions,\n-            self.crate_loader.cstore(),\n-            &self.source_span,\n+        StableHashingContext::new(self.session, &self.untracked)\n+    }\n+\n+    pub fn crate_loader(&mut self) -> CrateLoader<'_> {\n+        CrateLoader::new(\n+            &self.session,\n+            &*self.metadata_loader,\n+            self.local_crate_name,\n+            &mut *self.untracked.cstore.untracked_as_any().downcast_mut().unwrap(),\n+            self.untracked.definitions.read(),\n+            &mut self.used_extern_options,\n         )\n     }\n \n     pub fn cstore(&self) -> &CStore {\n-        self.crate_loader.cstore()\n+        self.untracked.cstore.as_any().downcast_ref().unwrap()\n     }\n \n     fn dummy_ext(&self, macro_kind: MacroKind) -> Lrc<SyntaxExtension> {\n@@ -1553,7 +1560,7 @@ impl<'a> Resolver<'a> {\n             self.session.time(\"resolve_main\", || self.resolve_main());\n             self.session.time(\"resolve_check_unused\", || self.check_unused(krate));\n             self.session.time(\"resolve_report_errors\", || self.report_errors(krate));\n-            self.session.time(\"resolve_postprocess\", || self.crate_loader.postprocess(krate));\n+            self.session.time(\"resolve_postprocess\", || self.crate_loader().postprocess(krate));\n         });\n     }\n \n@@ -1871,10 +1878,10 @@ impl<'a> Resolver<'a> {\n             } else {\n                 let crate_id = if finalize {\n                     let Some(crate_id) =\n-                        self.crate_loader.process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n+                        self.crate_loader().process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n                     crate_id\n                 } else {\n-                    self.crate_loader.maybe_process_path_extern(ident.name)?\n+                    self.crate_loader().maybe_process_path_extern(ident.name)?\n                 };\n                 let crate_root = self.expect_module(crate_id.as_def_id());\n                 let vis = ty::Visibility::<LocalDefId>::Public;\n@@ -1946,14 +1953,14 @@ impl<'a> Resolver<'a> {\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.source_span[def_id])\n+        def_id.as_local().map(|def_id| self.untracked.source_span[def_id])\n     }\n \n     /// Retrieves the name of the given `DefId`.\n     #[inline]\n     pub fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n         let def_key = match def_id.as_local() {\n-            Some(def_id) => self.definitions.def_key(def_id),\n+            Some(def_id) => self.untracked.definitions.read().def_key(def_id),\n             None => self.cstore().def_key(def_id),\n         };\n         def_key.get_opt_name()"}, {"sha": "b5b1602c5e0d38ad3971cb62c3c19524412063a9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -455,7 +455,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     }\n \n     fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span {\n-        self.crate_loader.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n+        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n     }\n \n     fn declare_proc_macro(&mut self, id: NodeId) {"}, {"sha": "d8db86c5f6216e1643d7b1e33d881135cf096fb1", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -13,6 +13,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_index = { path = \"../rustc_index\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "7f926f7d8bc4a2cb2cd25871384eff142e0324a8", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc70ff277dda8b7f227208eff789f1f68b6de5a/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=cbc70ff277dda8b7f227208eff789f1f68b6de5a", "patch": "@@ -6,9 +6,10 @@ use crate::search_paths::PathKind;\n use crate::utils::NativeLibKind;\n use crate::Session;\n use rustc_ast as ast;\n-use rustc_data_structures::sync::{self, MetadataRef};\n-use rustc_hir::def_id::{CrateNum, DefId, StableCrateId, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n+use rustc_data_structures::sync::{self, MetadataRef, RwLock};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, StableCrateId, LOCAL_CRATE};\n+use rustc_hir::definitions::{DefKey, DefPath, DefPathHash, Definitions};\n+use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -217,6 +218,7 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// during resolve)\n pub trait CrateStore: std::fmt::Debug {\n     fn as_any(&self) -> &dyn Any;\n+    fn untracked_as_any(&mut self) -> &mut dyn Any;\n \n     // Foreign definitions.\n     // This information is safe to access, since it's hashed as part of the DefPathHash, which incr.\n@@ -249,3 +251,11 @@ pub trait CrateStore: std::fmt::Debug {\n }\n \n pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n+\n+#[derive(Debug)]\n+pub struct Untracked {\n+    pub cstore: Box<CrateStoreDyn>,\n+    /// Reference span for definitions.\n+    pub source_span: IndexVec<LocalDefId, Span>,\n+    pub definitions: RwLock<Definitions>,\n+}"}]}