{"sha": "bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNWU2ZWJkZDNlMWQ1NGQyMTBmZjAyODUwNThmZmEwOTc5YjliYWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-02T14:06:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T11:08:00Z"}, "message": "miri validity: make recursive ref checking optional", "tree": {"sha": "cc1b13aa9408eba1b01827c3661d6bd4b5ad21ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc1b13aa9408eba1b01827c3661d6bd4b5ad21ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "html_url": "https://github.com/rust-lang/rust/commit/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a75a4d8633b9a71b47dbc1cd3c84248725425b", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a75a4d8633b9a71b47dbc1cd3c84248725425b", "html_url": "https://github.com/rust-lang/rust/commit/25a75a4d8633b9a71b47dbc1cd3c84248725425b"}], "stats": {"total": 208, "additions": 121, "deletions": 87}, "files": [{"sha": "8dd1e2b53cdcb2e73a680c75f57e2ad658311e61", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "patch": "@@ -1558,15 +1558,12 @@ fn validate_const<'a, 'tcx>(\n     let ecx = ::rustc_mir::const_eval::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n     let result = (|| {\n         let op = ecx.const_to_op(constant)?;\n-        let mut todo = vec![(op, Vec::new())];\n-        let mut seen = FxHashSet();\n-        seen.insert(op);\n-        while let Some((op, mut path)) = todo.pop() {\n+        let mut ref_tracking = ::rustc_mir::interpret::RefTracking::new(op);\n+        while let Some((op, mut path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n                 op,\n                 &mut path,\n-                &mut seen,\n-                &mut todo,\n+                Some(&mut ref_tracking),\n             )?;\n         }\n         Ok(())"}, {"sha": "9e0efaa9c78ef6208c0eb1daf16b1394e6ff01be", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "patch": "@@ -35,3 +35,5 @@ pub use self::memory::{Memory, MemoryKind};\n pub use self::machine::Machine;\n \n pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n+\n+pub use self::validity::RefTracking;"}, {"sha": "fd952abf273ae188a5b778e419398f85f10bce50", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 116, "deletions": 81, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "patch": "@@ -11,15 +11,15 @@\n use std::fmt::Write;\n \n use syntax_pos::symbol::Symbol;\n-use rustc::ty::layout::{self, Size, Primitive};\n+use rustc::ty::layout::{self, Size};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n     Scalar, AllocType, EvalResult, EvalErrorKind, PointerArithmetic\n };\n \n use super::{\n-    OpTy, Machine, EvalContext, ScalarMaybeUndef\n+    OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n };\n \n macro_rules! validation_failure{\n@@ -63,6 +63,23 @@ pub enum PathElem {\n     Tag,\n }\n \n+/// State for tracking recursive validation of references\n+pub struct RefTracking<'tcx> {\n+    pub seen: FxHashSet<(OpTy<'tcx>)>,\n+    pub todo: Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n+}\n+\n+impl<'tcx> RefTracking<'tcx> {\n+    pub fn new(op: OpTy<'tcx>) -> Self {\n+        let mut ref_tracking = RefTracking {\n+            seen: FxHashSet(),\n+            todo: vec![(op, Vec::new())],\n+        };\n+        ref_tracking.seen.insert(op);\n+        ref_tracking\n+    }\n+}\n+\n // Adding a Deref and making a copy of the path to be put into the queue\n // always go together.  This one does it with only new allocation.\n fn path_clone_and_deref(path: &Vec<PathElem>) -> Vec<PathElem> {\n@@ -205,6 +222,41 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n     }\n \n+    /// Validate a reference, potentially recursively. `place` is assumed to already be\n+    /// dereferenced, i.e. it describes the target.\n+    fn validate_ref(\n+        &self,\n+        place: MPlaceTy<'tcx>,\n+        path: &mut Vec<PathElem>,\n+        ref_tracking: Option<&mut RefTracking<'tcx>>,\n+    ) -> EvalResult<'tcx> {\n+        // Skip recursion for some external statics\n+        if let Scalar::Ptr(ptr) = place.ptr {\n+            let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+            if let Some(AllocType::Static(did)) = alloc_kind {\n+                // statics from other crates are already checked.\n+                // they might be checked at a different type, but for now we want\n+                // to avoid recursing too deeply.\n+                // extern statics cannot be validated as they have no body.\n+                if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                    return Ok(());\n+                }\n+            }\n+        }\n+        // Check if we have encountered this pointer+layout combination\n+        // before.  Proceed recursively even for integer pointers, no\n+        // reason to skip them! They are valid for some ZST, but not for others\n+        // (e.g. `!` is a ZST).\n+        let op = place.into();\n+        if let Some(ref_tracking) = ref_tracking {\n+            if ref_tracking.seen.insert(op) {\n+                trace!(\"Recursing below ptr {:#?}\", *op);\n+                ref_tracking.todo.push((op, path_clone_and_deref(path)));\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// This function checks the data at `op`.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     /// The `path` may be pushed to, but the part that is present when the function\n@@ -213,8 +265,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         dest: OpTy<'tcx>,\n         path: &mut Vec<PathElem>,\n-        seen: &mut FxHashSet<(OpTy<'tcx>)>,\n-        todo: &mut Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n+        mut ref_tracking: Option<&mut RefTracking<'tcx>>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:#?}\", *dest, dest.layout);\n \n@@ -273,7 +324,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n         // Validate all fields\n         match dest.layout.fields {\n-            // primitives are unions with zero fields\n+            // Primitives appear as Union with 0 fields -- except for fat pointers.\n             // We still check `layout.fields`, not `layout.abi`, because `layout.abi`\n             // is `Scalar` for newtypes around scalars, but we want to descend through the\n             // fields to get a proper `path`.\n@@ -302,32 +353,61 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         };\n                         let scalar = value.to_scalar_or_undef();\n                         self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n-                        if scalar_layout.value == Primitive::Pointer {\n-                            // ignore integer pointers, we can't reason about the final hardware\n-                            if let Scalar::Ptr(ptr) = scalar.not_undef()? {\n-                                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                                if let Some(AllocType::Static(did)) = alloc_kind {\n-                                    // statics from other crates are already checked.\n-                                    // extern statics cannot be validated as they have no body.\n-                                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n-                                        return Ok(());\n-                                    }\n-                                }\n-                                if value.layout.ty.builtin_deref(false).is_some() {\n-                                    let ptr_op = self.ref_to_mplace(value)?.into();\n-                                    // we have not encountered this pointer+layout combination\n-                                    // before.\n-                                    if seen.insert(ptr_op) {\n-                                        trace!(\"Recursing below ptr {:#?}\", *value);\n-                                        todo.push((ptr_op, path_clone_and_deref(path)));\n-                                    }\n-                                }\n-                            }\n+                        // Recursively check *safe* references\n+                        if dest.layout.ty.builtin_deref(true).is_some() &&\n+                            !dest.layout.ty.is_unsafe_ptr()\n+                        {\n+                            self.validate_ref(self.ref_to_mplace(value)?, path, ref_tracking)?;\n                         }\n                     },\n                     _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n                 }\n             }\n+            layout::FieldPlacement::Arbitrary { .. }\n+                if dest.layout.ty.builtin_deref(true).is_some() =>\n+            {\n+                // This is a fat pointer.\n+                let ptr = match self.read_value(dest.into())\n+                    .and_then(|val| self.ref_to_mplace(val))\n+                {\n+                    Ok(ptr) => ptr,\n+                    Err(_) =>\n+                        return validation_failure!(\n+                            \"undefined location or metadata in fat pointer\", path\n+                        ),\n+                };\n+                // check metadata early, for better diagnostics\n+                match self.tcx.struct_tail(ptr.layout.ty).sty {\n+                    ty::Dynamic(..) => {\n+                        match ptr.extra.unwrap().to_ptr() {\n+                            Ok(_) => {},\n+                            Err(_) =>\n+                                return validation_failure!(\n+                                    \"non-pointer vtable in fat pointer\", path\n+                                ),\n+                        }\n+                        // FIXME: More checks for the vtable.\n+                    }\n+                    ty::Slice(..) | ty::Str => {\n+                        match ptr.extra.unwrap().to_usize(self) {\n+                            Ok(_) => {},\n+                            Err(_) =>\n+                                return validation_failure!(\n+                                    \"non-integer slice length in fat pointer\", path\n+                                ),\n+                        }\n+                    }\n+                    _ =>\n+                        bug!(\"Unexpected unsized type tail: {:?}\",\n+                            self.tcx.struct_tail(ptr.layout.ty)\n+                        ),\n+                }\n+                // for safe ptrs, recursively check it\n+                if !dest.layout.ty.is_unsafe_ptr() {\n+                    self.validate_ref(ptr, path, ref_tracking)?;\n+                }\n+            }\n+            // Compound data structures\n             layout::FieldPlacement::Union(_) => {\n                 // We can't check unions, their bits are allowed to be anything.\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n@@ -411,7 +491,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n                             let field = field?;\n                             path.push(PathElem::ArrayElem(i));\n-                            self.validate_operand(field.into(), path, seen, todo)?;\n+                            self.validate_operand(\n+                                field.into(),\n+                                path,\n+                                ref_tracking.as_mut().map(|r| &mut **r)\n+                            )?;\n                             path.truncate(path_len);\n                         }\n                     }\n@@ -421,60 +505,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // An empty array.  Nothing to do.\n             }\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // Fat pointers are treated like pointers, not aggregates.\n-                if dest.layout.ty.builtin_deref(true).is_some() {\n-                    // This is a fat pointer.\n-                    let ptr = match self.read_value(dest.into())\n-                        .and_then(|val| self.ref_to_mplace(val))\n-                    {\n-                        Ok(ptr) => ptr,\n-                        Err(_) =>\n-                            return validation_failure!(\n-                                \"undefined location or metadata in fat pointer\", path\n-                            ),\n-                    };\n-                    // check metadata early, for better diagnostics\n-                    match self.tcx.struct_tail(ptr.layout.ty).sty {\n-                        ty::Dynamic(..) => {\n-                            match ptr.extra.unwrap().to_ptr() {\n-                                Ok(_) => {},\n-                                Err(_) =>\n-                                    return validation_failure!(\n-                                        \"non-pointer vtable in fat pointer\", path\n-                                    ),\n-                            }\n-                            // FIXME: More checks for the vtable.\n-                        }\n-                        ty::Slice(..) | ty::Str => {\n-                            match ptr.extra.unwrap().to_usize(self) {\n-                                Ok(_) => {},\n-                                Err(_) =>\n-                                    return validation_failure!(\n-                                        \"non-integer slice length in fat pointer\", path\n-                                    ),\n-                            }\n-                        }\n-                        _ =>\n-                            bug!(\"Unexpected unsized type tail: {:?}\",\n-                                self.tcx.struct_tail(ptr.layout.ty)\n-                            ),\n-                    }\n-                    // for safe ptrs, recursively check it\n-                    if !dest.layout.ty.is_unsafe_ptr() {\n-                        let ptr = ptr.into();\n-                        if seen.insert(ptr) {\n-                            trace!(\"Recursing below fat ptr {:?}\", ptr);\n-                            todo.push((ptr, path_clone_and_deref(path)));\n-                        }\n-                    }\n-                } else {\n-                    // Not a pointer, perform regular aggregate handling below\n-                    for i in 0..offsets.len() {\n-                        let field = self.operand_field(dest, i as u64)?;\n-                        path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n-                        self.validate_operand(field, path, seen, todo)?;\n-                        path.truncate(path_len);\n-                    }\n+                for i in 0..offsets.len() {\n+                    let field = self.operand_field(dest, i as u64)?;\n+                    path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n+                    self.validate_operand(field, path, ref_tracking.as_mut().map(|r| &mut **r))?;\n+                    path.truncate(path_len);\n                 }\n             }\n         }"}]}