{"sha": "e783d2be405353b2ea99b77e107beb2970096b90", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ODNkMmJlNDA1MzUzYjJlYTk5Yjc3ZTEwN2JlYjI5NzAwOTZiOTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-26T12:39:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-26T12:39:20Z"}, "message": "Auto merge of #54199 - nikomatsakis:predicate_may_hold-failure, r=eddyb\n\noverlook overflows in rustdoc trait solving\n\nContext:\n\nThe new rustdoc \"auto trait\" feature walks across impls and tries to run trait solving on them with a lot of unconstrained variables. This is prone to overflows. These overflows used to cause an ICE because of a caching bug (fixed in this PR). But even once that is fixed, it means that rustdoc causes an overflow rather than generating docs.\n\nThis PR therefore adds a new helper that propagates the overflow error out. This requires rustdoc to then decide what to do when it encounters such an overflow: technically, an overflow represents neither \"yes\" nor \"no\", but rather a failure to make a decision. I've decided to opt on the side of treating this as \"yes, implemented\", since rustdoc already takes an optimistic view. This may prove to include too many items, but I *suspect* not.\n\nWe could probably reduce the rate of overflows by unifying more of the parameters from the impl -- right now we only seem to consider the self type. Moreover, in the future, as we transition to Chalk, overflow errors are expected to just \"go away\" (in some cases, though, queries might return an ambiguous result).\n\nFixes #52873\n\ncc @QuietMisdreavus -- this is the stuff we were talking about earlier\ncc @GuillaumeGomez -- this supersedes #53687", "tree": {"sha": "5e2adb229c1ae7f9501142038d86a5b9da09d500", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e2adb229c1ae7f9501142038d86a5b9da09d500"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e783d2be405353b2ea99b77e107beb2970096b90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e783d2be405353b2ea99b77e107beb2970096b90", "html_url": "https://github.com/rust-lang/rust/commit/e783d2be405353b2ea99b77e107beb2970096b90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e783d2be405353b2ea99b77e107beb2970096b90/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a1a0d3400bbbcac194efb6ef2b14eef9be5149", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a1a0d3400bbbcac194efb6ef2b14eef9be5149", "html_url": "https://github.com/rust-lang/rust/commit/c3a1a0d3400bbbcac194efb6ef2b14eef9be5149"}, {"sha": "a3997f72556855a175bd5447993c7361ddedb194", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3997f72556855a175bd5447993c7361ddedb194", "html_url": "https://github.com/rust-lang/rust/commit/a3997f72556855a175bd5447993c7361ddedb194"}], "stats": {"total": 229, "additions": 214, "deletions": 15}, "files": [{"sha": "f573b1ef45e9c677238982d3867de5f8a63c333c", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=e783d2be405353b2ea99b77e107beb2970096b90", "patch": "@@ -20,7 +20,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n-        self.evaluate_obligation(obligation).may_apply()\n+        self.evaluate_obligation_no_overflow(obligation).may_apply()\n     }\n \n     /// Evaluates whether the predicate can be satisfied in the given\n@@ -30,28 +30,44 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n-        self.evaluate_obligation(obligation) == EvaluationResult::EvaluatedToOk\n+        self.evaluate_obligation_no_overflow(obligation) == EvaluationResult::EvaluatedToOk\n     }\n \n-    // Helper function that canonicalizes and runs the query, as well as handles\n-    // overflow.\n-    fn evaluate_obligation(\n+    /// Evaluate a given predicate, capturing overflow and propagating it back.\n+    pub fn evaluate_obligation(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-    ) -> EvaluationResult {\n+    ) -> Result<EvaluationResult, OverflowError> {\n         let mut _orig_values = SmallVec::new();\n         let c_pred = self.canonicalize_query(&obligation.param_env.and(obligation.predicate),\n                                              &mut _orig_values);\n         // Run canonical query. If overflow occurs, rerun from scratch but this time\n         // in standard trait query mode so that overflow is handled appropriately\n         // within `SelectionContext`.\n-        match self.tcx.global_tcx().evaluate_obligation(c_pred) {\n+        self.tcx.global_tcx().evaluate_obligation(c_pred)\n+    }\n+\n+    // Helper function that canonicalizes and runs the query. If an\n+    // overflow results, we re-run it in the local context so we can\n+    // report a nice error.\n+    fn evaluate_obligation_no_overflow(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> EvaluationResult {\n+        match self.evaluate_obligation(obligation) {\n             Ok(result) => result,\n             Err(OverflowError) => {\n                 let mut selcx =\n                     SelectionContext::with_query_mode(&self, TraitQueryMode::Standard);\n                 selcx.evaluate_obligation_recursively(obligation)\n-                     .expect(\"Overflow should be caught earlier in standard query mode\")\n+                    .unwrap_or_else(|r| {\n+                        span_bug!(\n+                            obligation.cause.span,\n+                            \"Overflow should be caught earlier in standard query mode: {:?}, {:?}\",\n+                            obligation,\n+                            r,\n+                        )\n+                    })\n             }\n         }\n     }"}, {"sha": "abeec93c04104de556023dd875c8b975de0848c1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e783d2be405353b2ea99b77e107beb2970096b90", "patch": "@@ -1374,7 +1374,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         let trait_ref = cache_fresh_trait_pred.skip_binder().trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            if let Some(trait_ref) = tcx.lift_to_global(&trait_ref) {\n+            if let Err(Overflow) = candidate {\n+                // Don't cache overflow globally; we only produce this\n+                // in certain modes.\n+            } else if let Some(trait_ref) = tcx.lift_to_global(&trait_ref) {\n                 if let Some(candidate) = tcx.lift_to_global(&candidate) {\n                     debug!(\n                         \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) global\","}, {"sha": "3244b1d7480ac95bac10e829c362ebcb798ae332", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=e783d2be405353b2ea99b77e107beb2970096b90", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::ConstEvalFailure(ref err) => tcx.lift(&**err).map(|err| super::ConstEvalFailure(\n                 err.into(),\n             )),\n-            super::Overflow => bug!(), // FIXME: ape ConstEvalFailure?\n+            super::Overflow => Some(super::Overflow),\n         }\n     }\n }"}, {"sha": "b6bc8d603d5ac2a2c9f6b14bf6f830a6fdcc5da3", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783d2be405353b2ea99b77e107beb2970096b90/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=e783d2be405353b2ea99b77e107beb2970096b90", "patch": "@@ -103,11 +103,20 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n                         // FIXME(eddyb) ignoring `obligations` might cause false positives.\n                         drop(obligations);\n \n-                        let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n-                            cause.clone(),\n-                            param_env,\n-                            trait_ref.to_predicate(),\n-                        ));\n+                        debug!(\n+                            \"invoking predicate_may_hold: {:?}\",\n+                            trait_ref,\n+                        );\n+                        let may_apply = match infcx.evaluate_obligation(\n+                            &traits::Obligation::new(\n+                                cause.clone(),\n+                                param_env,\n+                                trait_ref.to_predicate(),\n+                            ),\n+                        ) {\n+                            Ok(eval_result) => eval_result.may_apply(),\n+                            Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no\n+                        };\n                         if !may_apply {\n                             return\n                         }"}, {"sha": "9138dd50defa06146503c5691decd12b78a07ba0", "filename": "src/test/rustdoc/issue-52873.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/e783d2be405353b2ea99b77e107beb2970096b90/src%2Ftest%2Frustdoc%2Fissue-52873.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783d2be405353b2ea99b77e107beb2970096b90/src%2Ftest%2Frustdoc%2Fissue-52873.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-52873.rs?ref=e783d2be405353b2ea99b77e107beb2970096b90", "patch": "@@ -0,0 +1,171 @@\n+// Regression test for #52873. We used to ICE due to unexpected\n+// overflows when checking for \"blanket impl inclusion\".\n+\n+use std::marker::PhantomData;\n+use std::cmp::Ordering;\n+use std::ops::{Add, Mul};\n+\n+pub type True = B1;\n+pub type False = B0;\n+pub type U0 = UTerm;\n+pub type U1 = UInt<UTerm, B1>;\n+\n+pub trait NonZero {}\n+\n+pub trait Bit {\n+}\n+\n+pub trait Unsigned {\n+}\n+\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy, Hash, Debug, Default)]\n+pub struct B0;\n+\n+impl B0 {\n+    #[inline]\n+    pub fn new() -> B0 {\n+        B0\n+    }\n+}\n+\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy, Hash, Debug, Default)]\n+pub struct B1;\n+\n+impl B1 {\n+    #[inline]\n+    pub fn new() -> B1 {\n+        B1\n+    }\n+}\n+\n+impl Bit for B0 {\n+}\n+\n+impl Bit for B1 {\n+}\n+\n+impl NonZero for B1 {}\n+\n+pub trait PrivatePow<Y, N> {\n+    type Output;\n+}\n+pub type PrivatePowOut<A, Y, N> = <A as PrivatePow<Y, N>>::Output;\n+\n+pub type Add1<A> = <A as Add<::B1>>::Output;\n+pub type Prod<A, B> = <A as Mul<B>>::Output;\n+pub type Square<A> = <A as Mul>::Output;\n+pub type Sum<A, B> = <A as Add<B>>::Output;\n+\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy, Hash, Debug, Default)]\n+pub struct UTerm;\n+\n+impl UTerm {\n+    #[inline]\n+    pub fn new() -> UTerm {\n+        UTerm\n+    }\n+}\n+\n+impl Unsigned for UTerm {\n+}\n+\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy, Hash, Debug, Default)]\n+pub struct UInt<U, B> {\n+    _marker: PhantomData<(U, B)>,\n+}\n+\n+impl<U: Unsigned, B: Bit> UInt<U, B> {\n+    #[inline]\n+    pub fn new() -> UInt<U, B> {\n+        UInt {\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<U: Unsigned, B: Bit> Unsigned for UInt<U, B> {\n+}\n+\n+impl<U: Unsigned, B: Bit> NonZero for UInt<U, B> {}\n+\n+impl Add<B0> for UTerm {\n+    type Output = UTerm;\n+    fn add(self, _: B0) -> Self::Output {\n+        UTerm\n+    }\n+}\n+\n+impl<U: Unsigned, B: Bit> Add<B0> for UInt<U, B> {\n+    type Output = UInt<U, B>;\n+    fn add(self, _: B0) -> Self::Output {\n+        UInt::new()\n+    }\n+}\n+\n+impl<U: Unsigned> Add<U> for UTerm {\n+    type Output = U;\n+    fn add(self, _: U) -> Self::Output {\n+        unsafe { ::std::mem::uninitialized() }\n+    }\n+}\n+\n+impl<U: Unsigned, B: Bit> Mul<B0> for UInt<U, B> {\n+    type Output = UTerm;\n+    fn mul(self, _: B0) -> Self::Output {\n+        UTerm\n+    }\n+}\n+\n+impl<U: Unsigned, B: Bit> Mul<B1> for UInt<U, B> {\n+    type Output = UInt<U, B>;\n+    fn mul(self, _: B1) -> Self::Output {\n+        UInt::new()\n+    }\n+}\n+\n+impl<U: Unsigned> Mul<U> for UTerm {\n+    type Output = UTerm;\n+    fn mul(self, _: U) -> Self::Output {\n+        UTerm\n+    }\n+}\n+\n+impl<Ul: Unsigned, B: Bit, Ur: Unsigned> Mul<UInt<Ur, B>> for UInt<Ul, B0>\n+where\n+    Ul: Mul<UInt<Ur, B>>,\n+{\n+    type Output = UInt<Prod<Ul, UInt<Ur, B>>, B0>;\n+    fn mul(self, _: UInt<Ur, B>) -> Self::Output {\n+        unsafe { ::std::mem::uninitialized() }\n+    }\n+}\n+\n+pub trait Pow<Exp> {\n+    type Output;\n+}\n+\n+impl<X: Unsigned, N: Unsigned> Pow<N> for X\n+where\n+    X: PrivatePow<U1, N>,\n+{\n+    type Output = PrivatePowOut<X, U1, N>;\n+}\n+\n+impl<Y: Unsigned, X: Unsigned> PrivatePow<Y, U0> for X {\n+    type Output = Y;\n+}\n+\n+impl<Y: Unsigned, X: Unsigned> PrivatePow<Y, U1> for X\n+where\n+    X: Mul<Y>,\n+{\n+    type Output = Prod<X, Y>;\n+}\n+\n+impl<Y: Unsigned, U: Unsigned, B: Bit, X: Unsigned> PrivatePow<Y, UInt<UInt<U, B>, B0>> for X\n+where\n+    X: Mul,\n+    Square<X>: PrivatePow<Y, UInt<U, B>>,\n+{\n+    type Output = PrivatePowOut<Square<X>, Y, UInt<U, B>>;\n+}"}]}