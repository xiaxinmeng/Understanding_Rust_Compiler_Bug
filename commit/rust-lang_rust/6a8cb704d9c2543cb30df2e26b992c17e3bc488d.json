{"sha": "6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOGNiNzA0ZDljMjU0M2NiMzBkZjJlMjZiOTkyYzE3ZTNiYzQ4OGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-12T04:42:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T22:32:20Z"}, "message": "get basic code generation working, clone type descs for lambda[send]", "tree": {"sha": "6ba04893e5cf0f91ecf9c19dc15b783184dc0093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ba04893e5cf0f91ecf9c19dc15b783184dc0093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "html_url": "https://github.com/rust-lang/rust/commit/6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36177dd3e986199f4f6cb669423ca9cf78ff8d74", "url": "https://api.github.com/repos/rust-lang/rust/commits/36177dd3e986199f4f6cb669423ca9cf78ff8d74", "html_url": "https://github.com/rust-lang/rust/commit/36177dd3e986199f4f6cb669423ca9cf78ff8d74"}], "stats": {"total": 146, "additions": 113, "deletions": 33}, "files": [{"sha": "1530e5c1453b6903de716df4f2c206fd0aea9c65", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "patch": "@@ -17,6 +17,7 @@ type upcalls =\n      shared_malloc: ValueRef,\n      shared_free: ValueRef,\n      mark: ValueRef,\n+     clone_type_desc: ValueRef,\n      get_type_desc: ValueRef,\n      vec_grow: ValueRef,\n      vec_push: ValueRef,\n@@ -54,21 +55,26 @@ fn declare_upcalls(targ_cfg: @session::config,\n           malloc:\n               d(\"malloc\", [size_t, T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n-          free: dv(\"free\", [T_ptr(T_i8()), int_t]),\n+          free:\n+              dv(\"free\", [T_ptr(T_i8()), int_t]),\n           shared_malloc:\n               d(\"shared_malloc\", [size_t, T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n-          shared_free: dv(\"shared_free\", [T_ptr(T_i8())]),\n-          mark: d(\"mark\", [T_ptr(T_i8())], int_t),\n+          shared_free:\n+              dv(\"shared_free\", [T_ptr(T_i8())]),\n+          mark:\n+              d(\"mark\", [T_ptr(T_i8())], int_t),\n+          clone_type_desc:\n+              d(\"clone_type_desc\", [T_ptr(tydesc_type)],\n+                T_ptr(tydesc_type)),\n           get_type_desc:\n               d(\"get_type_desc\",\n                 [T_ptr(T_nil()), size_t,\n                  size_t, size_t,\n                  T_ptr(T_ptr(tydesc_type)), int_t],\n                 T_ptr(tydesc_type)),\n           vec_grow:\n-              dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)),\n-                              int_t]),\n+              dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)), int_t]),\n           vec_push:\n               dv(\"vec_push\",\n                 [T_ptr(T_ptr(opaque_vec_t)), T_ptr(tydesc_type),\n@@ -80,18 +86,24 @@ fn declare_upcalls(targ_cfg: @session::config,\n                   T_i8()]),\n           log_type:\n               dv(\"log_type\", [T_ptr(tydesc_type), T_ptr(T_i8()), T_i32()]),\n-          dynastack_mark: d(\"dynastack_mark\", [], T_ptr(T_i8())),\n+          dynastack_mark:\n+              d(\"dynastack_mark\", [], T_ptr(T_i8())),\n           dynastack_alloc:\n               d(\"dynastack_alloc_2\", [size_t, T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n-          dynastack_free: dv(\"dynastack_free\", [T_ptr(T_i8())]),\n-          alloc_c_stack: d(\"alloc_c_stack\", [size_t], T_ptr(T_i8())),\n-          call_shim_on_c_stack: d(\"call_shim_on_c_stack\",\n-                                  // arguments: void *args, void *fn_ptr\n-                                  [T_ptr(T_i8()), T_ptr(T_i8())],\n-                                  int_t),\n-          rust_personality: d(\"rust_personality\", [], T_i32()),\n-          reset_stack_limit: dv(\"reset_stack_limit\", [])\n+          dynastack_free:\n+              dv(\"dynastack_free\", [T_ptr(T_i8())]),\n+          alloc_c_stack:\n+              d(\"alloc_c_stack\", [size_t], T_ptr(T_i8())),\n+          call_shim_on_c_stack:\n+              d(\"call_shim_on_c_stack\",\n+                // arguments: void *args, void *fn_ptr\n+                [T_ptr(T_i8()), T_ptr(T_i8())],\n+                int_t),\n+          rust_personality:\n+              d(\"rust_personality\", [], T_i32()),\n+          reset_stack_limit:\n+              dv(\"reset_stack_limit\", [])\n          };\n }\n //"}, {"sha": "95aa6cf3849207f3950dcf119315895f53067fbf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "patch": "@@ -2188,19 +2188,20 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n     let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let copying = alt f.proto {\n-      ast::proto_shared(_) | ast::proto_send. { true }\n-      ast::proto_bare. | ast::proto_block. { false }\n+    let mode = alt f.proto {\n+      ast::proto_shared(_) { for_closure }\n+      ast::proto_send. { for_send }\n+      ast::proto_bare. | ast::proto_block. { for_block }\n     };\n     let env;\n     alt f.proto {\n       ast::proto_block. | ast::proto_shared(_) | ast::proto_send. {\n         let upvars = get_freevars(ccx.tcx, id);\n-        let env_r = build_closure(bcx, upvars, copying);\n+        let env_r = build_closure(bcx, upvars, mode);\n         env = env_r.ptr;\n         bcx = env_r.bcx;\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|fcx|\n-            load_environment(bcx, fcx, env_r.ptrty, upvars, copying);\n+            load_environment(bcx, fcx, env_r.ptrty, upvars, mode);\n         });\n       }\n       ast::proto_bare. {\n@@ -2560,7 +2561,7 @@ tag environment_value {\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n                      bound_values: [environment_value],\n-                     copying: bool) ->\n+                     mode: closure_constr_mode) ->\n    {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n     let ccx = bcx_ccx(bcx);\n     let tcx = bcx_tcx(bcx);\n@@ -2602,13 +2603,15 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n \n     let temp_cleanups = [], bcx = bcx;\n     // Allocate a box that can hold something closure-sized.\n-    let (closure, box) = if copying {\n+    let (closure, box) = alt mode {\n+      for_closure. | for_send. {\n         let r = trans_malloc_boxed(bcx, closure_ty);\n         add_clean_free(bcx, r.box, false);\n         temp_cleanups += [r.box];\n         bcx = r.bcx;\n         (r.body, r.box)\n-    } else {\n+      }\n+      for_block. {\n         // We need to dummy up a box on the stack\n         let ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n         let r = alloc_ty(bcx, ty);\n@@ -2618,10 +2621,12 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n               C_int(ccx, 2),\n               GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]));\n         (GEPi(bcx, r.val, [0, abi::box_rc_field_body]), r.val)\n+      }\n     };\n \n     // Store bindings tydesc.\n-    if copying {\n+    alt mode {\n+      for_closure. | for_send. {\n         let bound_tydesc = GEPi(bcx, closure, [0, abi::closure_elt_tydesc]);\n         let ti = none;\n         let bindings_tydesc =\n@@ -2630,6 +2635,8 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = bindings_tydesc.bcx;\n         Store(bcx, bindings_tydesc.val, bound_tydesc);\n+      }\n+      for_block. {}\n     }\n \n     // Copy expr values into boxed bindings.\n@@ -2651,12 +2658,15 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n             temp_cleanups += [bound.val];\n           }\n           env_direct(val, ty, is_mem) {\n-            if copying {\n+            alt mode {\n+              for_closure. | for_send. {\n                 let val1 = is_mem ? load_if_immediate(bcx, val, ty) : val;\n                 bcx = copy_val(bcx, INIT, bound.val, val1, ty);\n-            } else {\n+              }\n+              for_block. {\n                 let addr = is_mem ? val : do_spill_noroot(bcx, val);\n                 Store(bcx, addr, bound.val);\n+              }\n             }\n           }\n         }\n@@ -2675,28 +2685,47 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     i = 0u;\n     for td: ValueRef in lltydescs {\n         let ty_param_slot = GEPi(bcx, ty_params_slot.val, [0, i as int]);\n-        Store(bcx, td, ty_param_slot);\n+        alt mode {\n+          for_closure. | for_block. {\n+            Store(bcx, td, ty_param_slot);\n+          }\n+          for_send. {\n+            let cloned_td = Call(bcx, ccx.upcalls.clone_type_desc, [td]);\n+            Store(bcx, cloned_td, ty_param_slot);\n+          }\n+        }\n         i += 1u;\n     }\n \n     ret {ptr: box, ptrty: closure_ty, bcx: bcx};\n }\n \n+tag closure_constr_mode {\n+    for_block;\n+    for_closure;\n+    for_send;\n+}\n+\n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for build_environment.\n-fn build_closure(cx: @block_ctxt, upvars: @[ast::def], copying: bool) ->\n-   {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+fn build_closure(cx: @block_ctxt,\n+                 upvars: @[ast::def],\n+                 mode: closure_constr_mode)\n+    -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n     // If we need to, package up the iterator body to call\n     let env_vals = [];\n     // Package up the upvars\n     for def in *upvars {\n         let lv = trans_local_var(cx, def);\n         let nid = ast_util::def_id_of_def(def).node;\n         let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n-        if !copying { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n+        alt mode {\n+          for_block. { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n+          for_send. | for_closure. {}\n+        }\n         env_vals += [env_direct(lv.val, ty, lv.kind == owned)];\n     }\n-    ret build_environment(cx, copy cx.fcx.lltydescs, env_vals, copying);\n+    ret build_environment(cx, copy cx.fcx.lltydescs, env_vals, mode);\n }\n \n // Return a pointer to the stored typarams in a closure.\n@@ -2734,7 +2763,7 @@ fn find_environment_tydescs(bcx: @block_ctxt, envty: ty::t, closure: ValueRef)\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n-                    upvars: @[ast::def], copying: bool) {\n+                    upvars: @[ast::def], mode: closure_constr_mode) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n     let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n@@ -2769,7 +2798,10 @@ fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n         let upvarptr = GEP_tup_like(bcx, ty, llclosure, path + [i as int]);\n         bcx = upvarptr.bcx;\n         let llupvarptr = upvarptr.val;\n-        if !copying { llupvarptr = Load(bcx, llupvarptr); }\n+        alt mode {\n+          for_block. { llupvarptr = Load(bcx, llupvarptr); }\n+          for_send. | for_closure. { }\n+        }\n         let def_id = ast_util::def_id_of_def(upvar_def);\n         fcx.llupvars.insert(def_id.node, llupvarptr);\n         i += 1u;\n@@ -3532,7 +3564,8 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n \n     // Actually construct the closure\n     let closure = build_environment(bcx, lltydescs, env_vals +\n-                                    vec::map({|x| env_expr(x)}, bound), true);\n+                                    vec::map({|x| env_expr(x)}, bound),\n+                                    for_closure);\n     bcx = closure.bcx;\n \n     // Make thunk"}, {"sha": "889b5f62018457ab36a0f2dd9c3040db7ad7af34", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "patch": "@@ -279,6 +279,8 @@ struct type_desc {\n     const type_desc *descs[];\n };\n \n+extern \"C\" type_desc *rust_clone_type_desc(type_desc*);\n+\n #include \"circular_buffer.h\"\n #include \"rust_task.h\"\n #include \"rust_port.h\""}, {"sha": "d91e282d2e235ae5b2a8a9d8bf4236fb03c477f6", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6a8cb704d9c2543cb30df2e26b992c17e3bc488d/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=6a8cb704d9c2543cb30df2e26b992c17e3bc488d", "patch": "@@ -195,6 +195,39 @@ upcall_shared_free(void* ptr) {\n     SWITCH_STACK(&args, upcall_s_shared_free);\n }\n \n+struct s_clone_type_desc_args {\n+    const type_desc *td;\n+    type_desc *res;\n+};\n+\n+void upcall_s_clone_type_desc(s_clone_type_desc_args *args)\n+{\n+    // Copy the main part of the type descriptor:\n+    const type_desc *td = args->td;\n+    int n_descs = td->n_descs;\n+    size_t sz = sizeof(type_desc) + sizeof(type_desc*) * n_descs;\n+    args->res = (type_desc*) malloc(sz);\n+    memcpy(args->res, td, sizeof(type_desc));\n+\n+    // Recursively copy any referenced descriptors:\n+    for (int i = 0; i < n_descs; i++) {\n+        s_clone_type_desc_args rec_args = { td->descs[i], 0 };\n+        upcall_s_clone_type_desc(&rec_args);\n+        args->res->descs[i] = rec_args.res;\n+    }\n+}\n+\n+/**\n+ * Called to deep-clone type descriptors so they can be attached to a sendable\n+ * function.  Eventually this should perhaps move to a centralized hashtable.\n+ */\n+type_desc *\n+upcall_clone_type_desc(type_desc *td) {\n+    s_clone_type_desc_args args = { td, 0 };\n+    SWITCH_STACK(&args, upcall_s_clone_type_desc);\n+    return args.res;\n+}\n+\n struct s_get_type_desc_args {\n     type_desc *retval;\n     size_t size;"}]}