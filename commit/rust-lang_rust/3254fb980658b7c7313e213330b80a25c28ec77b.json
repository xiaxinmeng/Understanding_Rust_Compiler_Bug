{"sha": "3254fb980658b7c7313e213330b80a25c28ec77b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNTRmYjk4MDY1OGI3YzczMTNlMjEzMzMwYjgwYTI1YzI4ZWM3N2I=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-03T01:09:27Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-03T18:06:58Z"}, "message": "Code cleanup in check_expr.", "tree": {"sha": "5bcf2f3a83b855185f0e2a6927f0d13a2ca034f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bcf2f3a83b855185f0e2a6927f0d13a2ca034f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3254fb980658b7c7313e213330b80a25c28ec77b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3254fb980658b7c7313e213330b80a25c28ec77b", "html_url": "https://github.com/rust-lang/rust/commit/3254fb980658b7c7313e213330b80a25c28ec77b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3254fb980658b7c7313e213330b80a25c28ec77b/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc458d4a02e10d72eaa44cb36916d74ac865019", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc458d4a02e10d72eaa44cb36916d74ac865019", "html_url": "https://github.com/rust-lang/rust/commit/fcc458d4a02e10d72eaa44cb36916d74ac865019"}], "stats": {"total": 312, "additions": 149, "deletions": 163}, "files": [{"sha": "5d6ce998b0c055b42ab25fee5cf5750a5be51a57", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 149, "deletions": 163, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/3254fb980658b7c7313e213330b80a25c28ec77b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3254fb980658b7c7313e213330b80a25c28ec77b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=3254fb980658b7c7313e213330b80a25c28ec77b", "patch": "@@ -1705,6 +1705,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         }\n     }\n \n+    let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let bot = false;\n     alt expr.node {\n@@ -1720,68 +1721,65 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n             bot |= check_expr(fcx, rhs);\n         }\n \n-        let lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n-        let rhs_t = expr_ty(fcx.ccx.tcx, rhs);\n+        let lhs_t = expr_ty(tcx, lhs);\n+        let rhs_t = expr_ty(tcx, rhs);\n \n         demand::autoderef(fcx, rhs.span, lhs_t, rhs_t, AUTODEREF_OK);\n         let deref_t = do_autoderef(fcx, expr.span, lhs_t);\n         check_binop_type_compat(fcx, expr.span, deref_t, binop);\n \n         let t =\n             alt binop {\n-              ast::eq. { ty::mk_bool(fcx.ccx.tcx) }\n-              ast::lt. { ty::mk_bool(fcx.ccx.tcx) }\n-              ast::le. { ty::mk_bool(fcx.ccx.tcx) }\n-              ast::ne. { ty::mk_bool(fcx.ccx.tcx) }\n-              ast::ge. { ty::mk_bool(fcx.ccx.tcx) }\n-              ast::gt. { ty::mk_bool(fcx.ccx.tcx) }\n+              ast::eq. { ty::mk_bool(tcx) }\n+              ast::lt. { ty::mk_bool(tcx) }\n+              ast::le. { ty::mk_bool(tcx) }\n+              ast::ne. { ty::mk_bool(tcx) }\n+              ast::ge. { ty::mk_bool(tcx) }\n+              ast::gt. { ty::mk_bool(tcx) }\n               _ { deref_t }\n             };\n         write::ty_only_fixup(fcx, id, t);\n       }\n       ast::expr_unary(unop, oper) {\n         bot = check_expr(fcx, oper);\n-        let oper_t = expr_ty(fcx.ccx.tcx, oper);\n+        let oper_t = expr_ty(tcx, oper);\n         alt unop {\n           ast::box(mut) {\n-            oper_t = ty::mk_box(fcx.ccx.tcx, {ty: oper_t, mut: mut});\n+            oper_t = ty::mk_box(tcx, {ty: oper_t, mut: mut});\n           }\n           ast::deref. {\n             alt structure_of(fcx, expr.span, oper_t) {\n               ty::ty_box(inner) { oper_t = inner.ty; }\n               ty::ty_res(_, inner, _) { oper_t = inner; }\n               ty::ty_tag(id, tps) {\n-                let variants = ty::tag_variants(fcx.ccx.tcx, id);\n+                let variants = ty::tag_variants(tcx, id);\n                 if ivec::len(variants) != 1u ||\n                        ivec::len(variants.(0).args) != 1u {\n-                    fcx.ccx.tcx.sess.span_fatal\n+                    tcx.sess.span_fatal\n                         (expr.span, \"can only dereference tags \" +\n                          \"with a single variant which has a \"\n                          + \"single argument\");\n                 }\n                 oper_t =\n-                    ty::substitute_type_params(fcx.ccx.tcx, tps,\n+                    ty::substitute_type_params(tcx, tps,\n                                                variants.(0).args.(0));\n               }\n               ty::ty_ptr(inner) { oper_t = inner.ty; }\n               _ {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                            \"dereferencing non-\" +\n-                                                \"dereferenceable type: \" +\n-                                                ty_to_str(fcx.ccx.tcx,\n-                                                          oper_t));\n+                tcx.sess.span_fatal(expr.span,\n+                                    \"dereferencing non-\" +\n+                                    \"dereferenceable type: \" +\n+                                    ty_to_str(tcx, oper_t));\n               }\n             }\n           }\n           ast::not. {\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                            #fmt(\"mismatched types: \\\n-                                                        expected bool or \\\n-                                                        integer but found %s\",\n-                                                 ty_to_str(fcx.ccx.tcx,\n-                                                           oper_t)));\n+                tcx.sess.span_fatal(expr.span,\n+                                    #fmt(\"mismatched types: expected bool \\\n+                                          or integer but found %s\",\n+                                         ty_to_str(tcx, oper_t)));\n             }\n           }\n           _ { oper_t = do_autoderef(fcx, expr.span, oper_t); }\n@@ -1799,65 +1797,62 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         // The definition doesn't take type parameters. If the programmer\n         // supplied some, that's an error.\n         if ivec::len[@ast::ty](pth.node.types) > 0u {\n-            fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                        \"this kind of value does not \\\n-                                           take type parameters\");\n+            tcx.sess.span_fatal(expr.span,\n+                                \"this kind of value does not \\\n+                                 take type parameters\");\n         }\n         write::ty_only_fixup(fcx, id, tpt.ty);\n       }\n-      ast::expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n+      ast::expr_mac(_) { tcx.sess.bug(\"unexpanded macro\"); }\n       ast::expr_fail(expr_opt) {\n         bot = true;\n         alt expr_opt {\n           none. {/* do nothing */ }\n           some(e) {\n             check_expr(fcx, e);\n-            let tcx = fcx.ccx.tcx;\n             let ety = expr_ty(tcx, e);\n             demand::simple(fcx, e.span, ty::mk_str(tcx), ety);\n           }\n         }\n-        write::bot_ty(fcx.ccx.tcx, id);\n+        write::bot_ty(tcx, id);\n       }\n-      ast::expr_break. { write::bot_ty(fcx.ccx.tcx, id); bot = true; }\n-      ast::expr_cont. { write::bot_ty(fcx.ccx.tcx, id); bot = true; }\n+      ast::expr_break. { write::bot_ty(tcx, id); bot = true; }\n+      ast::expr_cont. { write::bot_ty(tcx, id); bot = true; }\n       ast::expr_ret(expr_opt) {\n         bot = true;\n         alt expr_opt {\n           none. {\n-            let nil = ty::mk_nil(fcx.ccx.tcx);\n+            let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                            \"ret; in function \\\n-                                                   returning non-nil\");\n+                tcx.sess.span_fatal(expr.span,\n+                                    \"ret; in function returning non-nil\");\n             }\n-            write::bot_ty(fcx.ccx.tcx, id);\n+            write::bot_ty(tcx, id);\n           }\n           some(e) {\n             check_expr(fcx, e);\n             demand::simple(fcx, expr.span, fcx.ret_ty,\n-                           expr_ty(fcx.ccx.tcx, e));\n-            write::bot_ty(fcx.ccx.tcx, id);\n+                           expr_ty(tcx, e));\n+            write::bot_ty(tcx, id);\n           }\n         }\n       }\n       ast::expr_put(expr_opt) {\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n         alt expr_opt {\n           none. {\n-            let nil = ty::mk_nil(fcx.ccx.tcx);\n+            let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                            \"put; in iterator \\\n-                                                   yielding non-nil\");\n+                tcx.sess.span_fatal(expr.span,\n+                                    \"put; in iterator yielding non-nil\");\n             }\n-            write::nil_ty(fcx.ccx.tcx, id);\n+            write::nil_ty(tcx, id);\n           }\n           some(e) {\n             bot = check_expr(fcx, e);\n             demand::simple(fcx, expr.span, fcx.ret_ty,\n-                           expr_ty(fcx.ccx.tcx, e));\n-            write::nil_ty(fcx.ccx.tcx, id);\n+                           expr_ty(tcx, e));\n+            write::nil_ty(tcx, id);\n           }\n         }\n       }\n@@ -1866,16 +1861,16 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         assert (ast::is_call_expr(e));\n         check_expr(fcx, e);\n         bot = true;\n-        demand::simple(fcx, e.span, fcx.ret_ty, expr_ty(fcx.ccx.tcx, e));\n-        write::nil_ty(fcx.ccx.tcx, id);\n+        demand::simple(fcx, e.span, fcx.ret_ty, expr_ty(tcx, e));\n+        write::nil_ty(tcx, id);\n       }\n       ast::expr_log(l, e) {\n         bot = check_expr(fcx, e);\n-        write::nil_ty(fcx.ccx.tcx, id);\n+        write::nil_ty(tcx, id);\n       }\n       ast::expr_check(_, e) {\n         bot = check_pred_expr(fcx, e);\n-        write::nil_ty(fcx.ccx.tcx, id);\n+        write::nil_ty(tcx, id);\n       }\n       ast::expr_if_check(cond, thn, elsopt) {\n         bot = check_pred_expr(fcx, cond) |\n@@ -1886,103 +1881,101 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n       }\n       ast::expr_assert(e) {\n         bot = check_expr(fcx, e);\n-        let ety = expr_ty(fcx.ccx.tcx, e);\n-        demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx), ety);\n-        write::nil_ty(fcx.ccx.tcx, id);\n+        let ety = expr_ty(tcx, e);\n+        demand::simple(fcx, expr.span, ty::mk_bool(tcx), ety);\n+        write::nil_ty(tcx, id);\n       }\n       ast::expr_move(lhs, rhs) {\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_assign(lhs, rhs) {\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_swap(lhs, rhs) {\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n-        check_binop_type_compat(fcx, expr.span, expr_ty(fcx.ccx.tcx, lhs),\n+        check_binop_type_compat(fcx, expr.span, expr_ty(tcx, lhs),\n                                 op);\n       }\n       ast::expr_send(lhs, rhs) {\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n-        let rhs_t = expr_ty(fcx.ccx.tcx, rhs);\n-        let chan_t = ty::mk_chan(fcx.ccx.tcx, rhs_t);\n-        let lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n+        let rhs_t = expr_ty(tcx, rhs);\n+        let chan_t = ty::mk_chan(tcx, rhs_t);\n+        let lhs_t = expr_ty(tcx, lhs);\n         alt structure_of(fcx, expr.span, lhs_t) {\n           ty::ty_chan(it) { }\n           _ {\n-            let s =\n-                #fmt(\"mismatched types: expected chan \\\n-                                   but found %s\",\n-                     ty_to_str(fcx.ccx.tcx, lhs_t));\n-            fcx.ccx.tcx.sess.span_fatal(expr.span, s);\n+            let s = #fmt(\"mismatched types: expected chan but found %s\",\n+                         ty_to_str(tcx, lhs_t));\n+            tcx.sess.span_fatal(expr.span, s);\n           }\n         }\n         demand::simple(fcx, expr.span, chan_t, lhs_t);\n         write::ty_only_fixup(fcx, id, chan_t);\n       }\n       ast::expr_recv(lhs, rhs) {\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n-        let item_t = expr_ty(fcx.ccx.tcx, rhs);\n-        let port_t = ty::mk_port(fcx.ccx.tcx, item_t);\n-        demand::simple(fcx, expr.span, port_t, expr_ty(fcx.ccx.tcx, lhs));\n+        let item_t = expr_ty(tcx, rhs);\n+        let port_t = ty::mk_port(tcx, item_t);\n+        demand::simple(fcx, expr.span, port_t, expr_ty(tcx, lhs));\n         write::ty_only_fixup(fcx, id, item_t);\n       }\n       ast::expr_if(cond, thn, elsopt) {\n         bot = check_expr(fcx, cond) |\n               check_then_else(fcx, thn, elsopt, id, expr.span);\n-        demand::simple(fcx, cond.span, ty::mk_bool(fcx.ccx.tcx),\n-                       expr_ty(fcx.ccx.tcx, cond));\n+        demand::simple(fcx, cond.span, ty::mk_bool(tcx),\n+                       expr_ty(tcx, cond));\n       }\n       ast::expr_for(decl, seq, body) {\n         bot = check_expr(fcx, seq);\n         let elt_ty;\n-        let ety = expr_ty(fcx.ccx.tcx, seq);\n+        let ety = expr_ty(tcx, seq);\n         alt structure_of(fcx, expr.span, ety) {\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n-          ty::ty_str. { elt_ty = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8); }\n+          ty::ty_str. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n           ty::ty_ivec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n-          ty::ty_istr. { elt_ty = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8); }\n+          ty::ty_istr. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal\n+            tcx.sess.span_fatal\n                 (expr.span, \"mismatched types: expected vector or string but \"\n-                 + \"found \" + ty_to_str(fcx.ccx.tcx, ety));\n+                 + \"found \" + ty_to_str(tcx, ety));\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n       }\n       ast::expr_for_each(decl, seq, body) {\n         bot = check_expr(fcx, seq) |\n-              check_for_or_for_each(fcx, decl, expr_ty(fcx.ccx.tcx, seq),\n+              check_for_or_for_each(fcx, decl, expr_ty(tcx, seq),\n                                     body, id);\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr(fcx, cond);\n         check_block(fcx, body);\n-        demand::simple(fcx, cond.span, ty::mk_bool(fcx.ccx.tcx),\n-                       expr_ty(fcx.ccx.tcx, cond));\n-        let typ = ty::mk_nil(fcx.ccx.tcx);\n+        demand::simple(fcx, cond.span, ty::mk_bool(tcx),\n+                       expr_ty(tcx, cond));\n+        let typ = ty::mk_nil(tcx);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_do_while(body, cond) {\n         bot = check_expr(fcx, cond);\n         check_block(fcx, body);\n-        let typ = block_ty(fcx.ccx.tcx, body);\n+        let typ = block_ty(tcx, body);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_alt(expr, arms) {\n         bot = check_expr(fcx, expr);\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n \n-        let pattern_ty = ty::expr_ty(fcx.ccx.tcx, expr);\n+        let pattern_ty = ty::expr_ty(tcx, expr);\n         for arm: ast::arm  in arms {\n             let id_map = ast::pat_id_map(arm.pats.(0));\n             for p: @ast::pat  in arm.pats {\n@@ -1994,20 +1987,20 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         let arm_non_bot = false;\n         for arm: ast::arm  in arms {\n             if !check_block(fcx, arm.block) { arm_non_bot = true; }\n-            let bty = block_ty(fcx.ccx.tcx, arm.block);\n+            let bty = block_ty(tcx, arm.block);\n \n             // Failing alt arms don't need to have a matching type\n-            if !ty::type_is_bot(fcx.ccx.tcx, bty) {\n+            if !ty::type_is_bot(tcx, bty) {\n                 result_ty =\n                     demand::simple(fcx, arm.block.span, result_ty, bty);\n             }\n         }\n         bot |= !arm_non_bot;\n-        if !arm_non_bot { result_ty = ty::mk_bot(fcx.ccx.tcx); }\n+        if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n       ast::expr_fn(f) {\n-        let cx = @{tcx: fcx.ccx.tcx};\n+        let cx = @{tcx: tcx};\n         let convert =\n             bind ast_ty_to_ty(cx.tcx, bind collect::getter(cx, _), _);\n         let ty_of_arg = bind collect::ty_of_arg(cx, _);\n@@ -2021,11 +2014,11 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         bot = check_block(fcx, b);\n         alt b.node.expr {\n           some(expr) {\n-            let typ = expr_ty(fcx.ccx.tcx, expr);\n+            let typ = expr_ty(tcx, expr);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           none. {\n-            let typ = ty::mk_nil(fcx.ccx.tcx);\n+            let typ = ty::mk_nil(tcx);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n         }\n@@ -2038,7 +2031,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         let proto_1;\n         let arg_tys_1: ty::arg[] = ~[];\n         let rt_1;\n-        let fty = expr_ty(fcx.ccx.tcx, f);\n+        let fty = expr_ty(tcx, f);\n         let t_1;\n         alt structure_of(fcx, expr.span, fty) {\n           ty::ty_fn(proto, arg_tys, rt, cf, constrs) {\n@@ -2058,8 +2051,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n                 }\n                 i += 1u;\n             }\n-            t_1 =\n-                ty::mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1, cf, constrs);\n+            t_1 = ty::mk_fn(tcx, proto_1, arg_tys_1, rt_1, cf, constrs);\n           }\n           _ {\n             fail \"LHS of bind expr didn't have a function type?!\";\n@@ -2078,7 +2070,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         // Pull the return type out of the type of the function.\n \n         let rt_1;\n-        let fty = do_autoderef(fcx, expr.span, ty::expr_ty(fcx.ccx.tcx, f));\n+        let fty = do_autoderef(fcx, expr.span, ty::expr_ty(tcx, f));\n         alt structure_of(fcx, expr.span, fty) {\n           ty::ty_fn(_, _, rt, cf, _) {\n             bot |= cf == ast::noreturn;\n@@ -2092,9 +2084,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         write::ty_only_fixup(fcx, id, rt_1);\n       }\n       ast::expr_self_method(ident) {\n-        let t = ty::mk_nil(fcx.ccx.tcx);\n+        let t = ty::mk_nil(tcx);\n         let this_obj_sty: option::t[ty::sty] =\n-            some(structure_of(fcx, expr.span, ty::mk_nil(fcx.ccx.tcx)));\n+            some(structure_of(fcx, expr.span, ty::mk_nil(tcx)));\n         let this_obj_info: option::t[obj_info] = get_obj_info(fcx.ccx);\n         alt this_obj_info {\n           some(oinfo) {\n@@ -2103,16 +2095,16 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n                 let did = local_def(obj_id);\n                 // Try looking up the current object in the type\n                 // cache.\n-                alt fcx.ccx.tcx.tcache.find(did) {\n+                alt tcx.tcache.find(did) {\n                   some(tpt) {\n                     // If we're typechecking a self-method on\n                     // a regular object, this lookup should\n                     // succeed.\n                     this_obj_sty = some(structure_of(fcx, expr.span, tpt.ty));\n                   }\n                   none. {\n-                    fcx.ccx.tcx.sess.bug(\"didn't find \" + int::str(did.node) +\n-                                         \" in type cache\");\n+                    tcx.sess.bug(\"didn't find \" + int::str(did.node) +\n+                                 \" in type cache\");\n                   }\n                 }\n               }\n@@ -2121,8 +2113,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n           }\n           none. {\n             // Shouldn't happen.\n-            fcx.ccx.tcx.sess.span_err(expr.span,\n-                                      \"self-call in non-object context\");\n+            tcx.sess.span_err(expr.span, \"self-call in non-object context\");\n           }\n         }\n \n@@ -2133,7 +2124,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n               ty::ty_obj(methods) {\n                 for method: ty::method  in methods {\n                     if method.ident == ident {\n-                        t = ty::method_ty_to_fn_ty(fcx.ccx.tcx, method);\n+                        t = ty::method_ty_to_fn_ty(tcx, method);\n                     }\n                 }\n               }\n@@ -2143,43 +2134,41 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n           none. { }\n         }\n         write::ty_only_fixup(fcx, id, t);\n-        require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+        require_impure(tcx.sess, fcx.purity, expr.span);\n       }\n       ast::expr_spawn(_, _, f, args) {\n         bot = check_call(fcx, expr.span, f, args, kind_spawn);\n-        let fty = expr_ty(fcx.ccx.tcx, f);\n+        let fty = expr_ty(tcx, f);\n         let ret_ty = alt structure_of(fcx, expr.span, fty) {\n           ty::ty_fn(_, _, rt, _, _) { rt }\n           ty::ty_native_fn(_, _, rt) { rt }\n           _ { fail \"LHS of spawn expr didn't have a function type?!\" }\n         };\n \n-        demand::simple(fcx, f.span, ty::mk_nil(fcx.ccx.tcx), ret_ty);\n+        demand::simple(fcx, f.span, ty::mk_nil(tcx), ret_ty);\n \n         // make sure they aren't spawning a function with type params\n-        if ty::expr_has_ty_params(fcx.ccx.tcx, f) {\n-            fcx.ccx.tcx.sess.span_fatal(\n+        if ty::expr_has_ty_params(tcx, f) {\n+            tcx.sess.span_fatal(\n                 f.span,\n                 \"spawning functions with type params not allowed (for now)\");\n         }\n \n         // FIXME: Other typechecks needed\n-        let typ = ty::mk_task(fcx.ccx.tcx);\n+        let typ = ty::mk_task(tcx);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n         // FIXME: there are more forms of cast to support, eventually.\n \n-        if !(type_is_scalar(fcx, expr.span, expr_ty(fcx.ccx.tcx, e)) &&\n+        if !(type_is_scalar(fcx, expr.span, expr_ty(tcx, e)) &&\n                  type_is_scalar(fcx, expr.span, t_1)) {\n-            fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                        \"non-scalar cast: \" +\n-                                            ty_to_str(fcx.ccx.tcx,\n-                                                      expr_ty(fcx.ccx.tcx, e))\n-                                            + \" as \" +\n-                                            ty_to_str(fcx.ccx.tcx, t_1));\n+            tcx.sess.span_fatal(expr.span,\n+                                \"non-scalar cast: \" +\n+                                ty_to_str(tcx, expr_ty(tcx, e))\n+                                + \" as \" + ty_to_str(tcx, t_1));\n         }\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n@@ -2189,18 +2178,18 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n             t = next_ty_var(fcx);\n         } else {\n             bot |= check_expr(fcx, args.(0));\n-            t = expr_ty(fcx.ccx.tcx, args.(0));\n+            t = expr_ty(tcx, args.(0));\n         }\n         for e: @ast::expr in args {\n             bot |= check_expr(fcx, e);\n-            let expr_t = expr_ty(fcx.ccx.tcx, e);\n+            let expr_t = expr_ty(tcx, e);\n             demand::simple(fcx, expr.span, t, expr_t);\n         }\n         let typ;\n         alt kind {\n-          ast::sk_rc. { typ = ty::mk_vec(fcx.ccx.tcx, {ty: t, mut: mut}); }\n+          ast::sk_rc. { typ = ty::mk_vec(tcx, {ty: t, mut: mut}); }\n           ast::sk_unique. {\n-            typ = ty::mk_ivec(fcx.ccx.tcx, {ty: t, mut: mut});\n+            typ = ty::mk_ivec(tcx, {ty: t, mut: mut});\n           }\n         }\n         write::ty_only_fixup(fcx, id, typ);\n@@ -2210,7 +2199,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         let fields_t: (spanned[field])[] = ~[];\n         for f: ast::field  in fields {\n             bot |= check_expr(fcx, f.node.expr);\n-            let expr_t = expr_ty(fcx.ccx.tcx, f.node.expr);\n+            let expr_t = expr_ty(tcx, f.node.expr);\n             let expr_mt = {ty: expr_t, mut: f.node.mut};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n@@ -2221,19 +2210,18 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         alt base {\n           none. {\n             fn get_node(f: &spanned[field]) -> field { f.node }\n-            let typ = ty::mk_rec(fcx.ccx.tcx, ivec::map(get_node, fields_t));\n+            let typ = ty::mk_rec(tcx, ivec::map(get_node, fields_t));\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           some(bexpr) {\n             bot |= check_expr(fcx, bexpr);\n-            let bexpr_t = expr_ty(fcx.ccx.tcx, bexpr);\n+            let bexpr_t = expr_ty(tcx, bexpr);\n             let base_fields: field[] = ~[];\n             alt structure_of(fcx, expr.span, bexpr_t) {\n               ty::ty_rec(flds) { base_fields = flds; }\n               _ {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                            \"record update \\\n-                                                       non-record base\");\n+                tcx.sess.span_fatal(expr.span,\n+                                    \"record update has non-record base\");\n               }\n             }\n             write::ty_only_fixup(fcx, id, bexpr_t);\n@@ -2246,76 +2234,75 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n                     }\n                 }\n                 if !found {\n-                    fcx.ccx.tcx.sess.span_fatal(f.span,\n-                                                \"unknown field in \\\n-                                                       record update: \"\n-                                                    + f.node.ident);\n+                    tcx.sess.span_fatal(f.span,\n+                                        \"unknown field in record update: \"\n+                                        + f.node.ident);\n                 }\n             }\n           }\n         }\n       }\n       ast::expr_field(base, field) {\n         bot |= check_expr(fcx, base);\n-        let base_t = expr_ty(fcx.ccx.tcx, base);\n+        let base_t = expr_ty(tcx, base);\n         base_t = do_autoderef(fcx, expr.span, base_t);\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_rec(fields) {\n             let ix: uint =\n-                ty::field_idx(fcx.ccx.tcx.sess, expr.span, field, fields);\n+                ty::field_idx(tcx.sess, expr.span, field, fields);\n             if ix >= ivec::len[ty::field](fields) {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span, \"bad index on record\");\n+                tcx.sess.span_fatal(expr.span, \"bad index on record\");\n             }\n             write::ty_only_fixup(fcx, id, fields.(ix).mt.ty);\n           }\n           ty::ty_obj(methods) {\n             let ix: uint =\n-                ty::method_idx(fcx.ccx.tcx.sess, expr.span, field, methods);\n+                ty::method_idx(tcx.sess, expr.span, field, methods);\n             if ix >= ivec::len[ty::method](methods) {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n+                tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n             }\n             let meth = methods.(ix);\n             let t =\n-                ty::mk_fn(fcx.ccx.tcx, meth.proto, meth.inputs, meth.output,\n+                ty::mk_fn(tcx, meth.proto, meth.inputs, meth.output,\n                           meth.cf, meth.constrs);\n             write::ty_only_fixup(fcx, id, t);\n           }\n           _ {\n             let t_err = resolve_type_vars_if_possible(fcx, base_t);\n             let msg =\n                 #fmt(\"attempted field access on type %s\",\n-                     ty_to_str(fcx.ccx.tcx, t_err));\n-            fcx.ccx.tcx.sess.span_fatal(expr.span, msg);\n+                     ty_to_str(tcx, t_err));\n+            tcx.sess.span_fatal(expr.span, msg);\n           }\n         }\n       }\n       ast::expr_index(base, idx) {\n         bot |= check_expr(fcx, base);\n-        let base_t = expr_ty(fcx.ccx.tcx, base);\n+        let base_t = expr_ty(tcx, base);\n         base_t = do_autoderef(fcx, expr.span, base_t);\n         bot |= check_expr(fcx, idx);\n-        let idx_t = expr_ty(fcx.ccx.tcx, idx);\n+        let idx_t = expr_ty(tcx, idx);\n         if !type_is_integral(fcx, idx.span, idx_t) {\n-            fcx.ccx.tcx.sess.span_fatal(idx.span,\n-                                        \"mismatched types: expected \\\n-                                           integer but found \"\n-                                            + ty_to_str(fcx.ccx.tcx, idx_t));\n+            tcx.sess.span_fatal(idx.span,\n+                                \"mismatched types: expected \\\n+                                 integer but found \"\n+                                + ty_to_str(tcx, idx_t));\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n           ty::ty_ivec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n           ty::ty_str. {\n-            let typ = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8);\n+            let typ = ty::mk_mach(tcx, ast::ty_u8);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           ty::ty_istr. {\n-            let typ = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8);\n+            let typ = ty::mk_mach(tcx, ast::ty_u8);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                        \"vector-indexing bad type: \" +\n-                                            ty_to_str(fcx.ccx.tcx, base_t));\n+            tcx.sess.span_fatal(expr.span,\n+                                \"vector-indexing bad type: \" +\n+                                ty_to_str(tcx, base_t));\n           }\n         }\n       }\n@@ -2328,21 +2315,20 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n           }\n           none. { }\n         }\n-        let pt = ty::mk_port(fcx.ccx.tcx, t);\n+        let pt = ty::mk_port(tcx, t);\n         write::ty_only_fixup(fcx, id, pt);\n       }\n       ast::expr_chan(x) {\n         check_expr(fcx, x);\n-        let port_t = expr_ty(fcx.ccx.tcx, x);\n+        let port_t = expr_ty(tcx, x);\n         alt structure_of(fcx, expr.span, port_t) {\n           ty::ty_port(subtype) {\n-            let ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n+            let ct = ty::mk_chan(tcx, subtype);\n             write::ty_only_fixup(fcx, id, ct);\n           }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                        \"bad port type: \" +\n-                                            ty_to_str(fcx.ccx.tcx, port_t));\n+            tcx.sess.span_fatal(expr.span,\n+                                \"bad port type: \" + ty_to_str(tcx, port_t));\n           }\n         }\n       }\n@@ -2392,15 +2378,15 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n             // Typecheck 'inner_obj'.  If it exists, it had better have object\n             // type.\n             let inner_obj_methods: ty::method[] = ~[];\n-            let inner_obj_ty: ty::t = ty::mk_nil(fcx.ccx.tcx);\n+            let inner_obj_ty: ty::t = ty::mk_nil(tcx);\n             let inner_obj_sty: option::t[ty::sty] = none;\n             alt ao.inner_obj {\n               none. { }\n               some(e) {\n                 // If there's a inner_obj, we push it onto the obj_infos stack\n                 // so that self-calls can be checked within its context later.\n                 bot |= check_expr(fcx, e);\n-                inner_obj_ty = expr_ty(fcx.ccx.tcx, e);\n+                inner_obj_ty = expr_ty(tcx, e);\n                 inner_obj_sty = some(structure_of(fcx, e.span, inner_obj_ty));\n \n                 alt inner_obj_sty {\n@@ -2410,7 +2396,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n                       ty::ty_obj(ms) { inner_obj_methods = ms; }\n                       _ {\n                         // The user is trying to extend a non-object.\n-                        fcx.ccx.tcx.sess.span_fatal\n+                        tcx.sess.span_fatal\n                             (e.span, syntax::print::pprust::expr_to_str(e) +\n                              \" does not have object type\");\n                       }\n@@ -2457,16 +2443,16 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n             method_types += inner_obj_methods;\n         }\n \n-        let ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));\n+        let ot = ty::mk_obj(tcx, ty::sort_methods(method_types));\n \n         write::ty_only_fixup(fcx, id, ot);\n \n         // Write the methods into the node type table.  (This happens in\n         // collect::convert for regular objects.)\n         let i = 0u;\n         while i < ivec::len[@ast::method](ao.methods) {\n-            write::ty_only(fcx.ccx.tcx, ao.methods.(i).node.id,\n-                           ty::method_ty_to_fn_ty(fcx.ccx.tcx,\n+            write::ty_only(tcx, ao.methods.(i).node.id,\n+                           ty::method_ty_to_fn_ty(tcx,\n                                                   method_types.(i)));\n             i += 1u;\n         }\n@@ -2480,10 +2466,10 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         // Now remove the info from the stack.\n         ivec::pop[obj_info](fcx.ccx.obj_infos);\n       }\n-      _ { fcx.ccx.tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n+      _ { tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n     if bot {\n-        write::ty_only_fixup(fcx, expr.id, ty::mk_bot(fcx.ccx.tcx));\n+        write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx));\n     }\n     ret bot;\n }"}]}