{"sha": "babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYmI1ZGY1MjljZWVmMWNjOGMxMjE0M2Q2ZGQ0YWIyMTE4OGNjM2U=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-04-17T21:04:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-03T15:30:10Z"}, "message": "refactor the handling of builtin candidates", "tree": {"sha": "a2abecfcc4aca4fc2d8a09e3d78cec3170c3979e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2abecfcc4aca4fc2d8a09e3d78cec3170c3979e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "html_url": "https://github.com/rust-lang/rust/commit/babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bcabbd45a7b1a576465ff5e980d63fcd6cd34e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcabbd45a7b1a576465ff5e980d63fcd6cd34e0", "html_url": "https://github.com/rust-lang/rust/commit/4bcabbd45a7b1a576465ff5e980d63fcd6cd34e0"}], "stats": {"total": 315, "additions": 112, "deletions": 203}, "files": [{"sha": "3a208aba6d83cfc0063f91521aeb53d7a93da1c1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 101, "deletions": 198, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "patch": "@@ -187,7 +187,7 @@ pub enum MethodMatchedData {\n /// parameter environment.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n-    BuiltinCandidate(ty::BuiltinBound),\n+    BuiltinCandidate { has_nested: bool },\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(DefId),\n     DefaultImplCandidate(DefId),\n@@ -240,7 +240,7 @@ enum BuiltinImplConditions<'tcx> {\n     None,\n     /// There is *no* impl for this, builtin or not. Ignore\n     /// all where-clauses.\n-    Never(SelectionError<'tcx>),\n+    Never,\n     /// It is unknown whether there is an impl.\n     Ambiguous\n }\n@@ -1000,15 +1000,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n \n                 // For other types, we'll use the builtin rules.\n-                self.assemble_builtin_bound_candidates(ty::BoundCopy,\n-                                                       obligation,\n-                                                       &mut candidates)?;\n+                let copy_conditions = self.copy_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n             }\n-            Some(bound @ ty::BoundSized) => {\n+            Some(ty::BoundSized) => {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed.\n-                self.assemble_builtin_bound_candidates(bound,\n-                                                       obligation,\n+                let sized_conditions = self.sized_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(sized_conditions,\n                                                        &mut candidates)?;\n             }\n \n@@ -1577,7 +1576,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 BuiltinObjectCandidate |\n                 BuiltinUnsizeCandidate |\n                 DefaultImplObjectCandidate(..) |\n-                BuiltinCandidate(..) => {\n+                BuiltinCandidate { .. } => {\n                     // We have a where-clause so don't go around looking\n                     // for impls.\n                     true\n@@ -1618,210 +1617,123 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // HACK: if this returns an error, selection exits without considering\n     // other impls.\n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n-                                             bound: ty::BuiltinBound,\n-                                             obligation: &TraitObligation<'tcx>,\n+                                             conditions: BuiltinImplConditions<'tcx>,\n                                              candidates: &mut SelectionCandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n-        match self.builtin_bound(bound, obligation) {\n-            BuiltinImplConditions::Where(..) => {\n-                debug!(\"builtin_bound: bound={:?}\",\n-                       bound);\n-                candidates.vec.push(BuiltinCandidate(bound));\n+        match conditions {\n+            BuiltinImplConditions::Where(nested) => {\n+                debug!(\"builtin_bound: nested={:?}\", nested);\n+                candidates.vec.push(BuiltinCandidate {\n+                    has_nested: nested.skip_binder().len() > 0\n+                });\n                 Ok(())\n             }\n             BuiltinImplConditions::None => { Ok(()) }\n             BuiltinImplConditions::Ambiguous => {\n                 debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n                 Ok(candidates.ambiguous = true)\n             }\n-            BuiltinImplConditions::Never(e) => { Err(e) }\n+            BuiltinImplConditions::Never => { Err(Unimplemented) }\n         }\n     }\n \n-    fn builtin_bound(&mut self,\n-                     bound: ty::BuiltinBound,\n-                     obligation: &TraitObligation<'tcx>)\n+    fn sized_conditions(&mut self, obligation: &TraitObligation<'tcx>)\n                      -> BuiltinImplConditions<'tcx>\n     {\n-        // Note: these tests operate on types that may contain bound\n-        // regions. To be proper, we ought to skolemize here, but we\n-        // forego the skolemization and defer it until the\n-        // confirmation step.\n+        use self::BuiltinImplConditions::{Ambiguous, None, Never, Where};\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n+        // NOTE: binder moved to (*)\n+        let self_ty = self.infcx.shallow_resolve(\n+            obligation.predicate.skip_binder().self_ty());\n \n-        let always = BuiltinImplConditions::Where(ty::Binder(Vec::new()));\n-        let never = BuiltinImplConditions::Never(Unimplemented);\n-\n-        return match self_ty.sty {\n-            ty::TyInfer(ty::IntVar(_)) |\n-            ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyUint(_) |\n-            ty::TyInt(_) |\n-            ty::TyBool |\n-            ty::TyFloat(_) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) |\n-            ty::TyChar => {\n+        match self_ty.sty {\n+            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n+            ty::TyChar | ty::TyBox(_) | ty::TyRef(..) |\n+            ty::TyArray(..) | ty::TyTuple(..) | ty::TyClosure(..) |\n+            ty::TyError => {\n                 // safe for everything\n-                always\n+                Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyBox(_) => {  // Box<T>\n-                match bound {\n-                    ty::BoundCopy => never,\n-                    ty::BoundSized => always,\n+            ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n \n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                let sized_crit = def.sized_constraint(self.tcx());\n+                // (*) binder moved here\n+                Where(ty::Binder(match sized_crit.sty {\n+                    ty::TyTuple(ref tys) => tys.to_owned().subst(self.tcx(), substs),\n+                    ty::TyBool => vec![],\n+                    _ => vec![sized_crit.subst(self.tcx(), substs)]\n+                }))\n             }\n \n-            ty::TyRawPtr(..) => {     // *const T, *mut T\n-                match bound {\n-                    ty::BoundCopy | ty::BoundSized => always,\n+            ty::TyProjection(_) | ty::TyParam(_) => None,\n+            ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n \n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n-            }\n-\n-            ty::TyTrait(ref data) => {\n-                match bound {\n-                    ty::BoundSized => never,\n-                    ty::BoundCopy => {\n-                        // FIXME(#32963): bit-rot fungus infestation\n-                        if data.bounds.builtin_bounds.contains(&bound) {\n-                            always\n-                        } else {\n-                            // Recursively check all supertraits to find out if any further\n-                            // bounds are required and thus we must fulfill.\n-                            let principal =\n-                                data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                            let copy_def_id = obligation.predicate.def_id();\n-                            for tr in util::supertraits(self.tcx(), principal) {\n-                                if tr.def_id() == copy_def_id {\n-                                    return always\n-                                }\n-                            }\n-\n-                            never\n-                        }\n-                    }\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+                bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n+                     self_ty);\n             }\n+        }\n+    }\n \n-            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl }) => {\n-                // &mut T or &T\n-                match bound {\n-                    ty::BoundCopy => {\n-                        match mutbl {\n-                            // &mut T is affine and hence never `Copy`\n-                            hir::MutMutable => never,\n-\n-                            // &T is always copyable\n-                            hir::MutImmutable => always\n-                        }\n-                    }\n-\n-                    ty::BoundSized => always,\n+    fn copy_conditions(&mut self, obligation: &TraitObligation<'tcx>)\n+                     -> BuiltinImplConditions<'tcx>\n+    {\n+        // NOTE: binder moved to (*)\n+        let self_ty = self.infcx.shallow_resolve(\n+            obligation.predicate.skip_binder().self_ty());\n \n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n-            }\n+        use self::BuiltinImplConditions::{Ambiguous, None, Never, Where};\n \n-            ty::TyArray(element_ty, _) => {\n-                // [T; n]\n-                match bound {\n-                    ty::BoundCopy => ok_if(vec![element_ty]),\n-                    ty::BoundSized => always,\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n+        match self_ty.sty {\n+            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+            ty::TyRawPtr(..) | ty::TyError |\n+            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) => {\n-                match bound {\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-\n-                    ty::BoundCopy | ty::BoundSized => never\n-                }\n+            ty::TyBox(_) | ty::TyTrait(..) | ty::TyStr | ty::TySlice(..) |\n+            ty::TyClosure(..) |\n+            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                Never\n             }\n \n-            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-            ty::TyTuple(ref tys) => ok_if(tys.clone()),\n-\n-            ty::TyClosure(..) => {\n-                match bound {\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-\n-                    ty::BoundCopy => never,\n-                    ty::BoundSized => always\n-                }\n+            ty::TyArray(element_ty, _) => {\n+                // (*) binder moved here\n+                Where(ty::Binder(vec![element_ty]))\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n-                match bound {\n-                    // Fallback to whatever user-defined impls exist in this case.\n-                    ty::BoundCopy => BuiltinImplConditions::None,\n-\n-                    // Sized if all the component types are sized.\n-                    ty::BoundSized => {\n-                        let sized_crit = def.sized_constraint(self.tcx());\n-                        if sized_crit == self.tcx().types.bool {\n-                            always\n-                        } else {\n-                            ok_if(vec![sized_crit.subst(self.tcx(), substs)])\n-                        }\n-                    }\n-\n-                    // Shouldn't be coming through here.\n-                    ty::BoundSend | ty::BoundSync => bug!(),\n-                }\n+            ty::TyTuple(ref tys) => {\n+                // (*) binder moved here\n+                Where(ty::Binder(tys.clone()))\n             }\n \n-            ty::TyProjection(_) | ty::TyParam(_) => {\n-                // Note: A type parameter is only considered to meet a\n-                // particular bound if there is a where clause telling\n-                // us that it does, and that case is handled by\n-                // `assemble_candidates_from_caller_bounds()`.\n-                BuiltinImplConditions::None\n+            ty::TyStruct(..) | ty::TyEnum(..) | ty::TyProjection(..) | ty::TyParam(..) => {\n+                // Fallback to whatever user-defined impls exist in this case.\n+                None\n             }\n \n             ty::TyInfer(ty::TyVar(_)) => {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n-                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n-                BuiltinImplConditions::Ambiguous\n+                Ambiguous\n             }\n \n-            ty::TyError => always,\n-\n             ty::TyInfer(ty::FreshTy(_))\n             | ty::TyInfer(ty::FreshIntTy(_))\n             | ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n-        };\n-\n-        fn ok_if<'tcx>(v: Vec<Ty<'tcx>>) -> BuiltinImplConditions<'tcx> {\n-            BuiltinImplConditions::Where(ty::Binder(v))\n         }\n     }\n \n@@ -1988,9 +1900,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                candidate);\n \n         match candidate {\n-            BuiltinCandidate(builtin_bound) => {\n+            BuiltinCandidate { has_nested } => {\n                 Ok(VtableBuiltin(\n-                    self.confirm_builtin_candidate(obligation, builtin_bound)))\n+                    self.confirm_builtin_candidate(obligation, has_nested)))\n             }\n \n             ParamCandidate(param) => {\n@@ -2090,45 +2002,36 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_builtin_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n-                                 bound: ty::BuiltinBound)\n+                                 has_nested: bool)\n                                  -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_builtin_candidate({:?})\",\n-               obligation);\n-\n-        match self.builtin_bound(bound, obligation) {\n-            BuiltinImplConditions::Where(nested) =>\n-                self.vtable_builtin_data(obligation, bound, nested),\n-            _ => {\n-                span_bug!(\n-                    obligation.cause.span,\n-                    \"confiriming builtin impl for {:?} where none exists\",\n-                    obligation);\n-            }\n-        }\n-    }\n-\n-    fn vtable_builtin_data(&mut self,\n-                           obligation: &TraitObligation<'tcx>,\n-                           bound: ty::BuiltinBound,\n-                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n-                           -> VtableBuiltinData<PredicateObligation<'tcx>>\n-    {\n-        debug!(\"vtable_builtin_data(obligation={:?}, bound={:?}, nested={:?})\",\n-               obligation, bound, nested);\n+        debug!(\"confirm_builtin_candidate({:?}, {:?})\",\n+               obligation, has_nested);\n+\n+        let obligations = if has_nested {\n+            let trait_def = obligation.predicate.def_id();\n+            let conditions = match trait_def {\n+                _ if Some(trait_def) == self.tcx().lang_items.sized_trait() => {\n+                    self.sized_conditions(obligation)\n+                }\n+                _ if Some(trait_def) == self.tcx().lang_items.copy_trait() => {\n+                    self.copy_conditions(obligation)\n+                }\n+                _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n+            };\n+            let nested = match conditions {\n+                BuiltinImplConditions::Where(nested) => nested,\n+                _ => bug!(\"obligation {:?} had matched a builtin impl but now doesn't\",\n+                          obligation)\n+            };\n \n-        let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n-            Ok(def_id) => def_id,\n-            Err(_) => {\n-                bug!(\"builtin trait definition not found\");\n-            }\n+            self.collect_predicates_for_types(obligation, trait_def, nested)\n+        } else {\n+            vec![]\n         };\n \n-        let obligations = self.collect_predicates_for_types(obligation, trait_def, nested);\n-\n-        debug!(\"vtable_builtin_data: obligations={:?}\",\n+        debug!(\"confirm_builtin_candidate: obligations={:?}\",\n                obligations);\n-\n         VtableBuiltinData { nested: obligations }\n     }\n "}, {"sha": "8fcbc0629523d9efa62a8b63415704d4e2b9a924", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "patch": "@@ -329,7 +329,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         where F : FnMut(ty::BoundRegion) -> ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n-        debug!(\"replace_late_bound_regions({:?})\", value);\n         let mut replacer = RegionReplacer::new(self, &mut f);\n         let result = value.skip_binder().fold_with(&mut replacer);\n         (result, replacer.map)\n@@ -444,8 +443,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n-                debug!(\"RegionReplacer.fold_region({:?}) folding region (current_depth={})\",\n-                       r, self.current_depth);\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n                 if let ty::ReLateBound(debruijn1, br) = region {"}, {"sha": "179c83873762d659081d0bda5406cea0d486f0b6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "patch": "@@ -1722,6 +1722,10 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n+    /// HACK: instead of returning a list of types, this function can\n+    /// return a tuple. In that case, the result is Sized only if\n+    /// all elements of the tuple are Sized.\n+    ///\n     /// This is generally the `struct_tail` if this is a struct, or a\n     /// tuple of them if this is an enum.\n     ///\n@@ -1738,7 +1742,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             None => {\n                 let this = tcx.lookup_adt_def_master(self.did);\n                 this.calculate_sized_constraint_inner(tcx, &mut Vec::new());\n-                self.sized_constraint.unwrap(dep_node)\n+                self.sized_constraint(tcx)\n             }\n             Some(ty) => ty\n         }\n@@ -1756,6 +1760,10 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n     {\n         let tys : Vec<_> = tys.into_iter()\n             .map(|ty| self.sized_constraint_for_ty(tcx, stack, ty))\n+            .flat_map(|ty| match ty.sty {\n+                ty::TyTuple(ref tys) => tys.clone(),\n+                _ => vec![ty]\n+            })\n             .filter(|ty| *ty != tcx.types.bool)\n             .collect();\n \n@@ -1766,6 +1774,7 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n             _ => tcx.mk_tup(tys)\n         }\n     }\n+\n     fn sized_constraint_for_ty(\n         &'tcx self,\n         tcx: &ty::TyCtxt<'tcx>,"}, {"sha": "6682a0e2b4f4fa6b813bb278e22dfb4c808a626e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babb5df529ceef1cc8c12143d6dd4ab21188cc3e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "patch": "@@ -493,7 +493,7 @@ impl fmt::Debug for ty::BoundRegion {\n             BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n             BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n             BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}, {:?})\", did, name)\n+                write!(f, \"BrNamed({:?}:{:?}, {:?})\", did.krate, did.index, name)\n             }\n             BrEnv => \"BrEnv\".fmt(f),\n         }"}]}