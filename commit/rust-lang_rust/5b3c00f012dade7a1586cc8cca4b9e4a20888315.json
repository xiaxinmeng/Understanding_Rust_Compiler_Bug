{"sha": "5b3c00f012dade7a1586cc8cca4b9e4a20888315", "node_id": "C_kwDOAAsO6NoAKDViM2MwMGYwMTJkYWRlN2ExNTg2Y2M4Y2NhNGI5ZTRhMjA4ODgzMTU", "commit": {"author": {"name": "Skyler Calaman", "email": "54462713+Blckbrry-Pi@users.noreply.github.com", "date": "2021-11-16T14:18:49Z"}, "committer": {"name": "Skyler Calaman", "email": "54462713+Blckbrry-Pi@users.noreply.github.com", "date": "2021-11-16T14:18:49Z"}, "message": "Successfully generalize prevention of suggestions causing multiple mutable borrows.\n\nAlso add some more tests to check that it's working.", "tree": {"sha": "7393d88c1489fa78d45b97a70f7c271a91738d88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7393d88c1489fa78d45b97a70f7c271a91738d88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b3c00f012dade7a1586cc8cca4b9e4a20888315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b3c00f012dade7a1586cc8cca4b9e4a20888315", "html_url": "https://github.com/rust-lang/rust/commit/5b3c00f012dade7a1586cc8cca4b9e4a20888315", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b3c00f012dade7a1586cc8cca4b9e4a20888315/comments", "author": {"login": "Blckbrry-Pi", "id": 54462713, "node_id": "MDQ6VXNlcjU0NDYyNzEz", "avatar_url": "https://avatars.githubusercontent.com/u/54462713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blckbrry-Pi", "html_url": "https://github.com/Blckbrry-Pi", "followers_url": "https://api.github.com/users/Blckbrry-Pi/followers", "following_url": "https://api.github.com/users/Blckbrry-Pi/following{/other_user}", "gists_url": "https://api.github.com/users/Blckbrry-Pi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blckbrry-Pi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blckbrry-Pi/subscriptions", "organizations_url": "https://api.github.com/users/Blckbrry-Pi/orgs", "repos_url": "https://api.github.com/users/Blckbrry-Pi/repos", "events_url": "https://api.github.com/users/Blckbrry-Pi/events{/privacy}", "received_events_url": "https://api.github.com/users/Blckbrry-Pi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Blckbrry-Pi", "id": 54462713, "node_id": "MDQ6VXNlcjU0NDYyNzEz", "avatar_url": "https://avatars.githubusercontent.com/u/54462713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blckbrry-Pi", "html_url": "https://github.com/Blckbrry-Pi", "followers_url": "https://api.github.com/users/Blckbrry-Pi/followers", "following_url": "https://api.github.com/users/Blckbrry-Pi/following{/other_user}", "gists_url": "https://api.github.com/users/Blckbrry-Pi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blckbrry-Pi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blckbrry-Pi/subscriptions", "organizations_url": "https://api.github.com/users/Blckbrry-Pi/orgs", "repos_url": "https://api.github.com/users/Blckbrry-Pi/repos", "events_url": "https://api.github.com/users/Blckbrry-Pi/events{/privacy}", "received_events_url": "https://api.github.com/users/Blckbrry-Pi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e20e300f6c54f9139452d27a9559b4ba524e4c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e20e300f6c54f9139452d27a9559b4ba524e4c5", "html_url": "https://github.com/rust-lang/rust/commit/3e20e300f6c54f9139452d27a9559b4ba524e4c5"}], "stats": {"total": 103, "additions": 84, "deletions": 19}, "files": [{"sha": "aeecf226b2d314a5b469148406efe4ffdd525a19", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 64, "deletions": 18, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5b3c00f012dade7a1586cc8cca4b9e4a20888315/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3c00f012dade7a1586cc8cca4b9e4a20888315/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=5b3c00f012dade7a1586cc8cca4b9e4a20888315", "patch": "@@ -3,8 +3,9 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local_id, CaptureKind};\n+use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local, path_to_local_id, CaptureKind};\n use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n@@ -174,15 +175,23 @@ struct IterFunctionVisitor<'b, 'a> {\n     illegal_mutable_capture_ids: HirIdSet,\n     current_mutably_captured_ids: HirIdSet,\n     cx: &'a LateContext<'b>,\n-    uses: Vec<IterFunction>,\n+    uses: Vec<Option<IterFunction>>,\n+    hir_id_uses_map: FxHashMap<HirId, usize>,\n+    current_statement_hir_id: Option<HirId>,\n     seen_other: bool,\n     target: HirId,\n }\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     fn visit_block(&mut self, block: &'txc Block<'tcx>) {\n-        for elem in block.stmts.iter().filter_map(get_expr_from_stmt).chain(block.expr) {\n-            self.current_mutably_captured_ids = HirIdSet::default();\n-            self.visit_expr(elem);\n+        for (expr, hir_id) in block\n+            .stmts\n+            .iter()\n+            .filter_map(get_expr_and_hir_id_from_stmt)\n+            .chain(block.expr.map(|expr| (expr, None)))\n+        {\n+            self.current_statement_hir_id = hir_id;\n+            self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(expr));\n+            self.visit_expr(expr);\n         }\n     }\n \n@@ -202,28 +211,53 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n                     .next()\n                     .is_none()\n                 {\n+                    if let Some(hir_id) = self.current_statement_hir_id {\n+                        self.hir_id_uses_map.insert(hir_id, self.uses.len());\n+                    }\n                     match &*method_name.ident.name.as_str() {\n-                        \"into_iter\" => self.uses.push(IterFunction {\n+                        \"into_iter\" => self.uses.push(Some(IterFunction {\n                             func: IterFunctionKind::IntoIter,\n                             span: expr.span,\n-                        }),\n-                        \"len\" => self.uses.push(IterFunction {\n+                        })),\n+                        \"len\" => self.uses.push(Some(IterFunction {\n                             func: IterFunctionKind::Len,\n                             span: expr.span,\n-                        }),\n-                        \"is_empty\" => self.uses.push(IterFunction {\n+                        })),\n+                        \"is_empty\" => self.uses.push(Some(IterFunction {\n                             func: IterFunctionKind::IsEmpty,\n                             span: expr.span,\n-                        }),\n-                        \"contains\" => self.uses.push(IterFunction {\n+                        })),\n+                        \"contains\" => self.uses.push(Some(IterFunction {\n                             func: IterFunctionKind::Contains(args[0].span),\n                             span: expr.span,\n-                        }),\n-                        _ => self.seen_other = true,\n+                        })),\n+                        _ => {\n+                            self.seen_other = true;\n+                            if let Some(hir_id) = self.current_statement_hir_id {\n+                                self.hir_id_uses_map.remove(&hir_id);\n+                            }\n+                        },\n                     }\n                 }\n                 return;\n             }\n+\n+            if let Some(hir_id) = path_to_local(recv) {\n+                if let Some(index) = self.hir_id_uses_map.remove(&hir_id) {\n+                    if self\n+                        .illegal_mutable_capture_ids\n+                        .intersection(&self.current_mutably_captured_ids)\n+                        .next()\n+                        .is_none()\n+                    {\n+                        if let Some(hir_id) = self.current_statement_hir_id {\n+                            self.hir_id_uses_map.insert(hir_id, index);\n+                        }\n+                    } else {\n+                        self.uses[index] = None;\n+                    }\n+                }\n+            }\n         }\n         // Check if the collection is used for anything else\n         if path_to_local_id(expr, self.target) {\n@@ -239,11 +273,17 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     }\n }\n \n-fn get_expr_from_stmt<'v>(stmt: &'v Stmt<'v>) -> Option<&'v Expr<'v>> {\n+fn get_expr_and_hir_id_from_stmt<'v>(stmt: &'v Stmt<'v>) -> Option<(&'v Expr<'v>, Option<HirId>)> {\n     match stmt.kind {\n-        StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some(expr),\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some((expr, None)),\n         StmtKind::Item(..) => None,\n-        StmtKind::Local(Local { init, .. }) => *init,\n+        StmtKind::Local(Local { init, pat, .. }) => {\n+            if let PatKind::Binding(_, hir_id, ..) = pat.kind {\n+                init.map(|init_expr| (init_expr, Some(hir_id)))\n+            } else {\n+                init.map(|init_expr| (init_expr, None))\n+            }\n+        },\n     }\n }\n \n@@ -284,9 +324,15 @@ fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n         cx,\n         current_mutably_captured_ids: HirIdSet::default(),\n         illegal_mutable_capture_ids: captured_ids,\n+        hir_id_uses_map: FxHashMap::default(),\n+        current_statement_hir_id: None,\n     };\n     visitor.visit_block(block);\n-    if visitor.seen_other { None } else { Some(visitor.uses) }\n+    if visitor.seen_other {\n+        None\n+    } else {\n+        Some(visitor.uses.into_iter().flatten().collect())\n+    }\n }\n \n #[allow(rustc::usage_of_ty_tykind)]"}, {"sha": "1f11d1f8d563c2bcb213f6924ac169512950d762", "filename": "tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5b3c00f012dade7a1586cc8cca4b9e4a20888315/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3c00f012dade7a1586cc8cca4b9e4a20888315/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=5b3c00f012dade7a1586cc8cca4b9e4a20888315", "patch": "@@ -79,13 +79,32 @@ mod issue7110 {\n mod issue7975 {\n     use super::*;\n \n-    fn shouldnt_lint() -> Vec<()> {\n+    fn direct_mapping_with_used_mutable_reference() -> Vec<()> {\n         let test_vec: Vec<()> = vec![];\n         let mut vec_2: Vec<()> = vec![];\n         let mut_ref = &mut vec_2;\n         let collected_vec: Vec<_> = test_vec.into_iter().map(|_| mut_ref.push(())).collect();\n         collected_vec.into_iter().map(|_| mut_ref.push(())).collect()\n     }\n+\n+    fn indirectly_mapping_with_used_mutable_reference() -> Vec<()> {\n+        let test_vec: Vec<()> = vec![];\n+        let mut vec_2: Vec<()> = vec![];\n+        let mut_ref = &mut vec_2;\n+        let collected_vec: Vec<_> = test_vec.into_iter().map(|_| mut_ref.push(())).collect();\n+        let iter = collected_vec.into_iter();\n+        iter.map(|_| mut_ref.push(())).collect()\n+    }\n+\n+    fn indirect_collect_after_indirect_mapping_with_used_mutable_reference() -> Vec<()> {\n+        let test_vec: Vec<()> = vec![];\n+        let mut vec_2: Vec<()> = vec![];\n+        let mut_ref = &mut vec_2;\n+        let collected_vec: Vec<_> = test_vec.into_iter().map(|_| mut_ref.push(())).collect();\n+        let iter = collected_vec.into_iter();\n+        let mapped_iter = iter.map(|_| mut_ref.push(()));\n+        mapped_iter.collect()\n+    }\n }\n \n fn allow_test() {"}]}