{"sha": "9d3ebd6a57b51f02788331f56681e8f593d82e60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkM2ViZDZhNTdiNTFmMDI3ODgzMzFmNTY2ODFlOGY1OTNkODJlNjA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-20T00:29:14Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-20T00:29:14Z"}, "message": "Implement dynamic GEP enough to permit expr_field to work on tup(T,T,T).", "tree": {"sha": "f3c6ea5aeafedbd73c966b80d6901474b77e6302", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3c6ea5aeafedbd73c966b80d6901474b77e6302"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3ebd6a57b51f02788331f56681e8f593d82e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3ebd6a57b51f02788331f56681e8f593d82e60", "html_url": "https://github.com/rust-lang/rust/commit/9d3ebd6a57b51f02788331f56681e8f593d82e60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3ebd6a57b51f02788331f56681e8f593d82e60/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35d53b7eb17c17ac492aa67f843c94e8db1731e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/35d53b7eb17c17ac492aa67f843c94e8db1731e1", "html_url": "https://github.com/rust-lang/rust/commit/35d53b7eb17c17ac492aa67f843c94e8db1731e1"}], "stats": {"total": 141, "additions": 139, "deletions": 2}, "files": [{"sha": "0e039d657e190088121a82f08ad1e8d1c70fe147", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=9d3ebd6a57b51f02788331f56681e8f593d82e60", "patch": "@@ -392,6 +392,7 @@ TEST_XFAILS_BOOT :=  $(TASK_XFAILS) \\\n                     test/run-pass/vec-slice.rs \\\n                     test/run-pass/fn-lval.rs \\\n                     test/run-pass/generic-recursive-tag.rs \\\n+                    test/run-pass/generic-tup.rs \\\n                     test/run-pass/iter-ret.rs \\\n                     test/run-pass/lib-io.rs \\\n                     test/run-pass/mlist-cycle.rs \\\n@@ -440,6 +441,7 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         fact.rs \\\n                         generic-fn-infer.rs \\\n                         generic-drop-glue.rs \\\n+                        generic-tup.rs \\\n                         hello.rs \\\n                         int.rs \\\n                         i32-sub.rs \\"}, {"sha": "a96c92cf9b6b67c64572e30f1e9249d56a7c17dd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 104, "deletions": 2, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9d3ebd6a57b51f02788331f56681e8f593d82e60", "patch": "@@ -732,6 +732,108 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n     }\n }\n \n+// Replacement for the LLVM 'GEP' instruction when field-indexing into a\n+// tuple-like structure (tup, rec, tag) with a static index. This one is\n+// driven off ty.struct and knows what to do when it runs into a ty_param\n+// stuck in the middle of the thing it's GEP'ing into. Much like size_of and\n+// align_of, above.\n+\n+fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n+                ValueRef base, vec[int] ixs) -> ValueRef {\n+\n+    check (ty.type_is_tup_like(t));\n+\n+    // It might be a static-known type. Handle this.\n+\n+    if (! ty.type_has_dynamic_size(t)) {\n+        let vec[ValueRef] v = vec();\n+        for (int i in ixs) {\n+            v += C_int(i);\n+        }\n+        ret cx.build.GEP(base, v);\n+    }\n+\n+    // It is a dynamic-containing type that, if we convert directly to an LLVM\n+    // TypeRef, will be all wrong; there's no proper LLVM type to represent\n+    // it, and the lowering function will stick in i8* values for each\n+    // ty_param, which is not right; the ty_params are all of some dynamic\n+    // size.\n+    //\n+    // What we must do instead is sadder. We must look through the indices\n+    // manually and split the input type into a prefix and a target. We then\n+    // measure the prefix size, bump the input pointer by that amount, and\n+    // cast to a pointer-to-target type.\n+\n+\n+    // Given a type, an index vector and an element number N in that vector,\n+    // calculate index X and the type that results by taking the first X-1\n+    // elements of the type and splitting the Xth off. Return the prefix as\n+    // well as the innermost Xth type.\n+\n+    fn split_type(@ty.t t, vec[int] ixs, uint n)\n+        -> rec(vec[@ty.t] prefix, @ty.t target) {\n+\n+        let uint len = _vec.len[int](ixs);\n+\n+        // We don't support 0-index or 1-index GEPs. The former is nonsense\n+        // and the latter would only be meaningful if we supported non-0\n+        // values for the 0th index (we don't).\n+\n+        check (len > 1u);\n+\n+        if (n == 0u) {\n+            // Since we're starting from a value that's a pointer to a\n+            // *single* structure, the first index (in GEP-ese) should just be\n+            // 0, to yield the pointee.\n+            check (ixs.(n) == 0);\n+            ret split_type(t, ixs, n+1u);\n+        }\n+\n+        check (n < len);\n+\n+        let int ix = ixs.(n);\n+        let vec[@ty.t] prefix = vec();\n+        let int i = 0;\n+        while (i < ix) {\n+            append[@ty.t](prefix, ty.get_element_type(t, i as uint));\n+            i +=1 ;\n+        }\n+\n+        auto selected = ty.get_element_type(t, i as uint);\n+\n+        if (n == len-1u) {\n+            // We are at the innermost index.\n+            ret rec(prefix=prefix, target=selected);\n+\n+        } else {\n+            // Not the innermost index; call self recursively to dig deeper.\n+            // Once we get an inner result, append it current prefix and\n+            // return to caller.\n+            auto inner = split_type(selected, ixs, n+1u);\n+            prefix += inner.prefix;\n+            ret rec(prefix=prefix with inner);\n+        }\n+    }\n+\n+    // We make a fake prefix tuple-type here; luckily for measuring sizes\n+    // the tuple parens are associative so it doesn't matter that we've\n+    // flattened the incoming structure.\n+\n+    auto s = split_type(t, ixs, 0u);\n+    auto prefix_ty = ty.plain_ty(ty.ty_tup(s.prefix));\n+    auto sz = size_of(cx, prefix_ty);\n+    auto raw = cx.build.PointerCast(base, T_ptr(T_i8()));\n+    auto bumped = cx.build.GEP(raw, vec(sz));\n+    alt (s.target.struct) {\n+        case (ty.ty_param(_)) { ret bumped; }\n+        case (_) {\n+            auto ty = T_ptr(type_of(cx.fcx.ccx, s.target));\n+            ret cx.build.PointerCast(bumped, ty);\n+        }\n+    }\n+}\n+\n+\n fn trans_malloc_inner(@block_ctxt cx, TypeRef llptr_ty) -> result {\n     auto llbody_ty = lib.llvm.llvm.LLVMGetElementType(llptr_ty);\n     // FIXME: need a table to collect tydesc globals.\n@@ -1969,12 +2071,12 @@ impure fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     alt (t.struct) {\n         case (ty.ty_tup(?fields)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n-            auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n+            auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n             ret lval_mem(r.bcx, v);\n         }\n         case (ty.ty_rec(?fields)) {\n             let uint ix = ty.field_idx(cx.fcx.ccx.sess, sp, field, fields);\n-            auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n+            auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n             ret lval_mem(r.bcx, v);\n         }\n         case (ty.ty_obj(?methods)) {"}, {"sha": "182e25219c32d69f28b4bba7751ae560525a89a0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=9d3ebd6a57b51f02788331f56681e8f593d82e60", "patch": "@@ -361,6 +361,29 @@ fn type_is_structural(@t ty) -> bool {\n     fail;\n }\n \n+fn type_is_tup_like(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_tup(_)) { ret true; }\n+        case (ty_rec(_)) { ret true; }\n+        case (ty_tag(_)) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+fn get_element_type(@t ty, uint i) -> @t {\n+    check (type_is_tup_like(ty));\n+    alt (ty.struct) {\n+        case (ty_tup(?tys)) {\n+            ret tys.(i);\n+        }\n+        case (ty_rec(?flds)) {\n+            ret flds.(i).ty;\n+        }\n+    }\n+    fail;\n+}\n+\n fn type_is_boxed(@t ty) -> bool {\n     alt (ty.struct) {\n         case (ty_str) { ret true; }"}, {"sha": "29a66371f115bd13299cfcbf410eda4849e90a7f", "filename": "src/test/run-pass/generic-tup.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3ebd6a57b51f02788331f56681e8f593d82e60/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=9d3ebd6a57b51f02788331f56681e8f593d82e60", "patch": "@@ -0,0 +1,10 @@\n+\n+fn get_third[T](&tup(T,T,T) t) -> T {\n+  ret t._2;\n+}\n+\n+fn main() {\n+  log get_third(tup(1,2,3));\n+  check (get_third(tup(1,2,3)) == 3);\n+  check (get_third(tup(5u8,6u8,7u8)) == 7u8);\n+}\n\\ No newline at end of file"}]}