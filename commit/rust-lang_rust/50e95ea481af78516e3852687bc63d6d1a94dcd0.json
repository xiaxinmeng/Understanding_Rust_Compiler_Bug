{"sha": "50e95ea481af78516e3852687bc63d6d1a94dcd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZTk1ZWE0ODFhZjc4NTE2ZTM4NTI2ODdiYzYzZDZkMWE5NGRjZDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-21T16:19:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-08T17:55:10Z"}, "message": "Fix pretty printer, which was ignoring `ref` in irrefutable patterns", "tree": {"sha": "126e3267076971e00667adf71c8799dc91f86fb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/126e3267076971e00667adf71c8799dc91f86fb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50e95ea481af78516e3852687bc63d6d1a94dcd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50e95ea481af78516e3852687bc63d6d1a94dcd0", "html_url": "https://github.com/rust-lang/rust/commit/50e95ea481af78516e3852687bc63d6d1a94dcd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50e95ea481af78516e3852687bc63d6d1a94dcd0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "682e7467dd0c646a7d7bc1fd617e9629c98f82a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/682e7467dd0c646a7d7bc1fd617e9629c98f82a1", "html_url": "https://github.com/rust-lang/rust/commit/682e7467dd0c646a7d7bc1fd617e9629c98f82a1"}], "stats": {"total": 67, "additions": 26, "deletions": 41}, "files": [{"sha": "73ee8768ca30207587e3789059b1a0866e9df0fc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/50e95ea481af78516e3852687bc63d6d1a94dcd0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50e95ea481af78516e3852687bc63d6d1a94dcd0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=50e95ea481af78516e3852687bc63d6d1a94dcd0", "patch": "@@ -147,7 +147,7 @@ pub fn ty_to_str(ty: &ast::Ty, intr: @ident_interner) -> ~str {\n }\n \n pub fn pat_to_str(pat: &ast::pat, intr: @ident_interner) -> ~str {\n-    to_str(pat, print_irrefutable_pat, intr)\n+    to_str(pat, print_pat, intr)\n }\n \n pub fn expr_to_str(e: &ast::expr, intr: @ident_interner) -> ~str {\n@@ -1240,7 +1240,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n-                print_refutable_pat(s, *p);\n+                print_pat(s, *p);\n             }\n             space(s.s);\n             match arm.guard {\n@@ -1434,7 +1434,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n }\n \n pub fn print_local_decl(s: @ps, loc: &ast::local) {\n-    print_irrefutable_pat(s, loc.node.pat);\n+    print_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, \":\"); print_type(s, &loc.node.ty); }\n@@ -1521,20 +1521,7 @@ pub fn print_path(s: @ps, path: &ast::Path, colons_before_params: bool) {\n     print_path_(s, path, colons_before_params, &None)\n }\n \n-pub fn print_bounded_path(s: @ps, path: &ast::Path,\n-                          bounds: &Option<OptVec<ast::TyParamBound>>) {\n-    print_path_(s, path, false, bounds)\n-}\n-\n-pub fn print_irrefutable_pat(s: @ps, pat: &ast::pat) {\n-    print_pat(s, pat, false)\n-}\n-\n-pub fn print_refutable_pat(s: @ps, pat: &ast::pat) {\n-    print_pat(s, pat, true)\n-}\n-\n-pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, pat: &ast::pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n@@ -1543,20 +1530,18 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n     match pat.node {\n       ast::pat_wild => word(s.s, \"_\"),\n       ast::pat_ident(binding_mode, ref path, sub) => {\n-          if refutable {\n-              match binding_mode {\n-                  ast::bind_by_ref(mutbl) => {\n-                      word_nbsp(s, \"ref\");\n-                      print_mutability(s, mutbl);\n-                  }\n-                  ast::bind_infer => {}\n+          match binding_mode {\n+              ast::bind_by_ref(mutbl) => {\n+                  word_nbsp(s, \"ref\");\n+                  print_mutability(s, mutbl);\n               }\n+              ast::bind_infer => {}\n           }\n           print_path(s, path, true);\n           match sub {\n               Some(p) => {\n                   word(s.s, \"@\");\n-                  print_pat(s, p, refutable);\n+                  print_pat(s, p);\n               }\n               None => ()\n           }\n@@ -1569,7 +1554,7 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n             if !args.is_empty() {\n               popen(s);\n               commasep(s, inconsistent, *args,\n-                       |s, &p| print_pat(s, p, refutable));\n+                       |s, &p| print_pat(s, p));\n               pclose(s);\n             } else { }\n           }\n@@ -1578,16 +1563,16 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n       ast::pat_struct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n-        fn print_field(s: @ps, f: &ast::field_pat, refutable: bool) {\n+        fn print_field(s: @ps, f: &ast::field_pat) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, \":\");\n-            print_pat(s, f.pat, refutable);\n+            print_pat(s, f.pat);\n             end(s);\n         }\n         fn get_span(f: &ast::field_pat) -> codemap::span { return f.pat.span; }\n         commasep_cmnt(s, consistent, *fields,\n-                      |s, f| print_field(s,f,refutable),\n+                      |s, f| print_field(s,f),\n                       get_span);\n         if etc {\n             if fields.len() != 0u { word_space(s, \",\"); }\n@@ -1597,23 +1582,23 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n       }\n       ast::pat_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p, refutable));\n+        commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p));\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n         pclose(s);\n       }\n       ast::pat_box(inner) => {\n           word(s.s, \"@\");\n-          print_pat(s, inner, refutable);\n+          print_pat(s, inner);\n       }\n       ast::pat_uniq(inner) => {\n           word(s.s, \"~\");\n-          print_pat(s, inner, refutable);\n+          print_pat(s, inner);\n       }\n       ast::pat_region(inner) => {\n           word(s.s, \"&\");\n-          print_pat(s, inner, refutable);\n+          print_pat(s, inner);\n       }\n       ast::pat_lit(e) => print_expr(s, e),\n       ast::pat_range(begin, end) => {\n@@ -1625,16 +1610,16 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n       ast::pat_vec(ref before, slice, ref after) => {\n         word(s.s, \"[\");\n         do commasep(s, inconsistent, *before) |s, &p| {\n-            print_pat(s, p, refutable);\n+            print_pat(s, p);\n         }\n         for slice.iter().advance |&p| {\n             if !before.is_empty() { word_space(s, \",\"); }\n             word(s.s, \"..\");\n-            print_pat(s, p, refutable);\n+            print_pat(s, p);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n         do commasep(s, inconsistent, *after) |s, &p| {\n-            print_pat(s, p, refutable);\n+            print_pat(s, p);\n         }\n         word(s.s, \"]\");\n       }\n@@ -1888,7 +1873,7 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n         word_space(s, \"mut\");\n     }\n     match input.ty.node {\n-      ast::ty_infer => print_irrefutable_pat(s, input.pat),\n+      ast::ty_infer => print_pat(s, input.pat),\n       _ => {\n         match input.pat.node {\n             ast::pat_ident(_, ref path, _) if\n@@ -1897,7 +1882,7 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n                 // Do nothing.\n             }\n             _ => {\n-                print_irrefutable_pat(s, input.pat);\n+                print_pat(s, input.pat);\n                 word(s.s, \":\");\n                 space(s.s);\n             }"}, {"sha": "919c4daeb253bbe1a8f67de3484b4f13357397d4", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50e95ea481af78516e3852687bc63d6d1a94dcd0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50e95ea481af78516e3852687bc63d6d1a94dcd0/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=50e95ea481af78516e3852687bc63d6d1a94dcd0", "patch": "@@ -56,8 +56,8 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   for mm.iter().advance |(&key, &val)| {\n-      pairs.push((key, pct(val, total)));\n+   for mm.iter().advance |(key, &val)| {\n+      pairs.push((copy *key, pct(val, total)));\n    }\n \n    let pairs_sorted = sortKV(pairs);"}, {"sha": "92344aae73e6da9fcdcefbf0556c750414609697", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50e95ea481af78516e3852687bc63d6d1a94dcd0/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50e95ea481af78516e3852687bc63d6d1a94dcd0/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=50e95ea481af78516e3852687bc63d6d1a94dcd0", "patch": "@@ -68,7 +68,7 @@ fn main() {\n     check_pp(ext_cx, *stmt, pprust::print_stmt, ~\"let x = 20;\");\n \n     let pat = quote_pat!(Some(_));\n-    check_pp(ext_cx, pat, pprust::print_refutable_pat, ~\"Some(_)\");\n+    check_pp(ext_cx, pat, pprust::print_pat, ~\"Some(_)\");\n \n }\n "}]}