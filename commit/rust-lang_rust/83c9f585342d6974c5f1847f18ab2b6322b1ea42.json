{"sha": "83c9f585342d6974c5f1847f18ab2b6322b1ea42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYzlmNTg1MzQyZDY5NzRjNWYxODQ3ZjE4YWIyYjYzMjJiMWVhNDI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-08T15:17:59Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T08:28:50Z"}, "message": "Rename dict to vtable throughout the compiler\n\nThe difference went away.", "tree": {"sha": "e3b73829750bf46921c7ddfc6004b643e9e26ef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b73829750bf46921c7ddfc6004b643e9e26ef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83c9f585342d6974c5f1847f18ab2b6322b1ea42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83c9f585342d6974c5f1847f18ab2b6322b1ea42", "html_url": "https://github.com/rust-lang/rust/commit/83c9f585342d6974c5f1847f18ab2b6322b1ea42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83c9f585342d6974c5f1847f18ab2b6322b1ea42/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4511f936b1b4766962d01a80f6887eecb30e89f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4511f936b1b4766962d01a80f6887eecb30e89f9", "html_url": "https://github.com/rust-lang/rust/commit/4511f936b1b4766962d01a80f6887eecb30e89f9"}], "stats": {"total": 330, "additions": 166, "deletions": 164}, "files": [{"sha": "584e04adfd865efe0eb44f34236758b3db77fca0", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -2,7 +2,7 @@\n import driver::session;\n import middle::trans::base;\n import middle::trans::common::{T_fn, T_i1, T_i8, T_i32,\n-                               T_int, T_nil, T_dict,\n+                               T_int, T_nil,\n                                T_opaque_vec, T_ptr,\n                                T_size_t, T_void};\n import lib::llvm::{type_names, ModuleRef, ValueRef, TypeRef};\n@@ -19,7 +19,6 @@ type upcalls =\n      create_shared_type_desc: ValueRef,\n      free_shared_type_desc: ValueRef,\n      get_type_desc: ValueRef,\n-     intern_dict: ValueRef,\n      vec_grow: ValueRef,\n      vec_push: ValueRef,\n      cmp_type: ValueRef,\n@@ -81,8 +80,6 @@ fn declare_upcalls(targ_cfg: @session::config,\n                  size_t, size_t,\n                  T_ptr(T_ptr(tydesc_type)), int_t],\n                 T_ptr(tydesc_type)),\n-          intern_dict:\n-              d(\"intern_dict\", [size_t, T_ptr(T_dict())], T_ptr(T_dict())),\n           vec_grow:\n               dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)), int_t]),\n           vec_push:"}, {"sha": "c9e7c0c5da17165e7801cd55234edfdd685fff9c", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -144,7 +144,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         time(time_passes, \"region resolution\",\n              bind middle::region::resolve_crate(sess, def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars, region_map);\n-    let (method_map, dict_map) =\n+    let (method_map, vtable_map) =\n         time(time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, impl_map, crate));\n     time(time_passes, \"const checking\",\n@@ -181,7 +181,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let maps = {mutbl_map: mutbl_map, copy_map: copy_map,\n                 last_uses: last_uses, impl_map: impl_map,\n-                method_map: method_map, dict_map: dict_map};\n+                method_map: method_map, vtable_map: vtable_map};\n \n     let (llmod, link_meta) =\n         time(time_passes, \"translation\","}, {"sha": "007b2ea2e0ccc31cefe1fa315914fd71f5f1620e", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -17,8 +17,8 @@ import std::smallintmap::map;\n import middle::trans::common::maps;\n import middle::{ty, typeck, last_use, ast_map};\n import middle::typeck::method_origin;\n-import middle::typeck::dict_res;\n-import middle::typeck::dict_origin;\n+import middle::typeck::vtable_res;\n+import middle::typeck::vtable_origin;\n import driver::session::session;\n import middle::freevars::freevar_entry;\n import c = common;\n@@ -506,40 +506,40 @@ impl of tr for last_use::is_last_use {\n }\n \n // ______________________________________________________________________\n-// Encoding and decoding dict_res\n+// Encoding and decoding vtable_res\n \n-fn encode_dict_res(ecx: @e::encode_ctxt,\n+fn encode_vtable_res(ecx: @e::encode_ctxt,\n                    ebml_w: ebml::writer,\n-                   dr: typeck::dict_res) {\n+                   dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic serialization of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written serialization routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    ebml_w.emit_from_vec(*dr) {|dict_origin|\n-        encode_dict_origin(ecx, ebml_w, dict_origin)\n+    ebml_w.emit_from_vec(*dr) {|vtable_origin|\n+        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     }\n }\n \n-fn encode_dict_origin(ecx: @e::encode_ctxt,\n+fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                       ebml_w: ebml::writer,\n-                      dict_origin: typeck::dict_origin) {\n-    ebml_w.emit_enum(\"dict_origin\") {||\n-        alt dict_origin {\n-          typeck::dict_static(def_id, tys, dict_res) {\n-            ebml_w.emit_enum_variant(\"dict_static\", 0u, 3u) {||\n+                      vtable_origin: typeck::vtable_origin) {\n+    ebml_w.emit_enum(\"vtable_origin\") {||\n+        alt vtable_origin {\n+          typeck::vtable_static(def_id, tys, vtable_res) {\n+            ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) {||\n                 ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_def_id(def_id)\n                 }\n                 ebml_w.emit_enum_variant_arg(1u) {||\n                     ebml_w.emit_tys(ecx, tys);\n                 }\n                 ebml_w.emit_enum_variant_arg(2u) {||\n-                    encode_dict_res(ecx, ebml_w, dict_res);\n+                    encode_vtable_res(ecx, ebml_w, vtable_res);\n                 }\n             }\n           }\n-          typeck::dict_param(pn, bn) {\n-            ebml_w.emit_enum_variant(\"dict_param\", 1u, 2u) {||\n+          typeck::vtable_param(pn, bn) {\n+            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) {||\n                 ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_uint(pn);\n                 }\n@@ -548,8 +548,8 @@ fn encode_dict_origin(ecx: @e::encode_ctxt,\n                 }\n             }\n           }\n-          typeck::dict_iface(def_id, tys) {\n-            ebml_w.emit_enum_variant(\"dict_iface\", 1u, 3u) {||\n+          typeck::vtable_iface(def_id, tys) {\n+            ebml_w.emit_enum_variant(\"vtable_iface\", 1u, 3u) {||\n                 ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_def_id(def_id)\n                 }\n@@ -564,29 +564,30 @@ fn encode_dict_origin(ecx: @e::encode_ctxt,\n }\n \n impl helpers for ebml::ebml_deserializer {\n-    fn read_dict_res(xcx: extended_decode_ctxt) -> typeck::dict_res {\n-        @self.read_to_vec {|| self.read_dict_origin(xcx) }\n+    fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n+        @self.read_to_vec {|| self.read_vtable_origin(xcx) }\n     }\n \n-    fn read_dict_origin(xcx: extended_decode_ctxt) -> typeck::dict_origin {\n-        self.read_enum(\"dict_origin\") {||\n+    fn read_vtable_origin(xcx: extended_decode_ctxt)\n+        -> typeck::vtable_origin {\n+        self.read_enum(\"vtable_origin\") {||\n             self.read_enum_variant {|i|\n                 alt check i {\n                   0u {\n-                    typeck::dict_static(\n+                    typeck::vtable_static(\n                         self.read_enum_variant_arg(0u) {||\n                             self.read_def_id(xcx)\n                         },\n                         self.read_enum_variant_arg(1u) {||\n                             self.read_tys(xcx)\n                         },\n                         self.read_enum_variant_arg(2u) {||\n-                            self.read_dict_res(xcx)\n+                            self.read_vtable_res(xcx)\n                         }\n                     )\n                   }\n                   1u {\n-                    typeck::dict_param(\n+                    typeck::vtable_param(\n                         self.read_enum_variant_arg(0u) {||\n                             self.read_uint()\n                         },\n@@ -596,7 +597,7 @@ impl helpers for ebml::ebml_deserializer {\n                     )\n                   }\n                   2u {\n-                    typeck::dict_iface(\n+                    typeck::vtable_iface(\n                         self.read_enum_variant_arg(0u) {||\n                             self.read_def_id(xcx)\n                         },\n@@ -786,11 +787,11 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    option::may(ccx.maps.dict_map.find(id)) {|dr|\n-        ebml_w.tag(c::tag_table_dict_map) {||\n+    option::may(ccx.maps.vtable_map.find(id)) {|dr|\n+        ebml_w.tag(c::tag_table_vtable_map) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n-                encode_dict_res(ecx, ebml_w, dr);\n+                encode_vtable_res(ecx, ebml_w, dr);\n             }\n         }\n     }\n@@ -883,9 +884,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert(id,\n                                            val_dsr.read_method_origin(xcx));\n-            } else if tag == (c::tag_table_dict_map as uint) {\n-                dcx.maps.dict_map.insert(id,\n-                                         val_dsr.read_dict_res(xcx));\n+            } else if tag == (c::tag_table_vtable_map as uint) {\n+                dcx.maps.vtable_map.insert(id,\n+                                         val_dsr.read_vtable_res(xcx));\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n                     #fmt[\"unknown tag found in side tables: %x\", tag]);"}, {"sha": "3d3a3fff48f393bc5681b618476cd0ab685e9115", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -98,7 +98,7 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_copy,\n     tag_table_last_use,\n     tag_table_method_map,\n-    tag_table_dict_map\n+    tag_table_vtable_map\n }\n \n // djb's cdb hashes."}, {"sha": "2cf565a9f976190c2171d0d817502313fadd79b0", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -757,7 +757,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     }\n \n     fcx.lltyparams = vec::map(vec::from_mut(lltydescs), {|d|\n-        {desc: d, dicts: none}\n+        {desc: d, vtables: none}\n     });\n \n     let bcx = top_scope_block(fcx, none);\n@@ -2051,7 +2051,7 @@ type generic_info = {item_type: ty::t,\n                      static_tis: [option<@tydesc_info>],\n                      tydescs: [ValueRef],\n                      param_bounds: @[ty::param_bounds],\n-                     origins: option<typeck::dict_res>};\n+                     origins: option<typeck::vtable_res>};\n \n enum generic_callee {\n     generic_full(generic_info),\n@@ -2107,17 +2107,17 @@ fn trans_external_path(cx: block, did: ast::def_id,\n }\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n-                  dicts: option<typeck::dict_res>)\n+                  vtables: option<typeck::vtable_res>)\n     -> option<{llfn: ValueRef, fty: ty::t}> {\n     let substs = vec::map(substs, {|t|\n         alt ty::get(t).struct {\n           ty::ty_box(mt) { ty::mk_opaque_box(ccx.tcx) }\n           _ { t }\n         }\n     });\n-    let hash_id = @{def: fn_id, substs: substs, dicts: alt dicts {\n-      some(os) { some_dicts(vec::map(*os, impl::vtable_id)) }\n-      none { no_dicts }\n+    let hash_id = @{def: fn_id, substs: substs, vtables: alt vtables {\n+      some(os) { some_vts(vec::map(*os, impl::vtable_id)) }\n+      none { no_vts }\n     }};\n     alt ccx.monomorphized.find(hash_id) {\n       some(val) { ret some(val); }\n@@ -2148,7 +2148,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     let lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n     ccx.monomorphized.insert(hash_id, {llfn: lldecl, fty: mono_ty});\n \n-    let psubsts = some({tys: substs, dicts: dicts, bounds: tpt.bounds});\n+    let psubsts = some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n     alt check map_node {\n       ast_map::node_item(i@@{node: ast::item_fn(decl, _, body), _}, _) {\n         set_inline_hint_if_appr(i.attrs, lldecl);\n@@ -2229,7 +2229,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n }\n \n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n-                  substs: option<([ty::t], typeck::dict_res)>)\n+                  substs: option<([ty::t], typeck::vtable_res)>)\n     -> lval_maybe_callee {\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n@@ -2249,16 +2249,17 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n        fn_id.crate == ast::local_crate &&\n        !vec::any(tys, {|t| ty::type_has_params(t)}) {\n         let mono = alt substs {\n-          some((stys, dicts)) {\n+          some((stys, vtables)) {\n             if (stys.len() + tys.len()) > 0u {\n-                monomorphic_fn(ccx, fn_id, stys + tys, some(dicts))\n+                monomorphic_fn(ccx, fn_id, stys + tys, some(vtables))\n             } else { none }\n           }\n           none {\n-            alt ccx.maps.dict_map.find(id) {\n-              some(dicts) {\n-                let rdicts = impl::resolve_vtables_in_fn_ctxt(bcx.fcx, dicts);\n-                monomorphic_fn(ccx, fn_id, tys, some(rdicts))\n+            alt ccx.maps.vtable_map.find(id) {\n+              some(vtables) {\n+                let rvtables = impl::resolve_vtables_in_fn_ctxt(\n+                    bcx.fcx, vtables);\n+                monomorphic_fn(ccx, fn_id, tys, some(rvtables))\n               }\n               none { monomorphic_fn(ccx, fn_id, tys, none) }\n             }\n@@ -2308,7 +2309,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                             static_tis: tis,\n                             tydescs: tydescs,\n                             param_bounds: tpt.bounds,\n-                            origins: ccx.maps.dict_map.find(id)});\n+                            origins: ccx.maps.vtable_map.find(id)});\n     }\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n@@ -2925,9 +2926,11 @@ fn invoke_(bcx: block, llfn: ValueRef, llargs: [ValueRef],\n     // cleanups to run\n     if bcx.unreachable { ret bcx; }\n     let normal_bcx = sub_block(bcx, \"normal return\");\n-    /*std::io::println(\"fn: \" + lib::llvm::type_to_str(bcx.ccx().tn, val_ty(llfn)));\n+    /*std::io::println(\"fn: \" + lib::llvm::type_to_str(bcx.ccx().tn,\n+                     val_ty(llfn)));\n     for a in llargs {\n-        std::io::println(\" a: \" + lib::llvm::type_to_str(bcx.ccx().tn, val_ty(a)));\n+        std::io::println(\" a: \" + lib::llvm::type_to_str(bcx.ccx().tn,\n+                         val_ty(a)));\n     }*/\n     invoker(bcx, llfn, llargs, normal_bcx.llbb, get_landing_pad(bcx));\n     ret normal_bcx;\n@@ -4001,22 +4004,22 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n     }\n     for bounds in tps_bounds {\n         let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n-        let dicts = none;\n+        let vtables = none;\n         arg_n += 1u;\n         for bound in *bounds {\n             alt bound {\n               ty::bound_iface(_) {\n-                let dict = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n+                let vtable = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n                 arg_n += 1u;\n-                dicts = some(alt dicts {\n-                    none { [dict] }\n-                    some(ds) { ds + [dict] }\n+                vtables = some(alt vtables {\n+                    none { [vtable] }\n+                    some(ds) { ds + [vtable] }\n                 });\n               }\n               _ {}\n             }\n         }\n-        cx.lltyparams += [{desc: lltydesc, dicts: dicts}];\n+        cx.lltyparams += [{desc: lltydesc, vtables: vtables}];\n     }\n \n     // Populate the llargs field of the function context with the ValueRefs"}, {"sha": "2f5f6da87c2445ffc2e01b814d559f40abbc5235", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -142,8 +142,8 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     let param_ptrs = [];\n     for tp in ty_params {\n         param_ptrs += [tydesc_ty];\n-        option::may(tp.dicts) {|dicts|\n-            for dict in dicts { param_ptrs += [tydesc_ty]; }\n+        option::may(tp.vtables) {|vtables|\n+            for vtable in vtables { param_ptrs += [tydesc_ty]; }\n         }\n     }\n \n@@ -289,9 +289,9 @@ fn store_environment(\n         let cloned_td = maybe_clone_tydesc(bcx, ck, tp.desc);\n         Store(bcx, cloned_td, GEPi(bcx, ty_params_slot, [0, off]));\n         off += 1;\n-        option::may(tp.dicts, {|dicts|\n-            for dict in dicts {\n-                let cast = PointerCast(bcx, dict, val_ty(cloned_td));\n+        option::may(tp.vtables, {|vtables|\n+            for vtable in vtables {\n+                let cast = PointerCast(bcx, vtable, val_ty(cloned_td));\n                 Store(bcx, cast, GEPi(bcx, ty_params_slot, [0, off]));\n                 off += 1;\n             }\n@@ -414,16 +414,16 @@ fn load_environment(enclosing_cx: block,\n     for tp in copy enclosing_cx.fcx.lltyparams {\n         let tydesc = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n         off += 1;\n-        let dicts = option::map(tp.dicts, {|dicts|\n+        let vtables = option::map(tp.vtables, {|vtables|\n             let rslt = [];\n-            for dict in dicts {\n-                let dict = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n-                rslt += [PointerCast(bcx, dict, T_ptr(T_dict()))];\n+            for vtable in vtables {\n+                let vtable = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n+                rslt += [PointerCast(bcx, vtable, T_ptr(T_vtable()))];\n                 off += 1;\n             }\n             rslt\n         });\n-        fcx.lltyparams += [{desc: tydesc, dicts: dicts}];\n+        fcx.lltyparams += [{desc: tydesc, vtables: vtables}];\n     }\n \n     // Populate the upvars from the environment.\n@@ -545,7 +545,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n \n     // Actually construct the closure\n     let {llbox, cdata_ty, bcx} = store_environment(\n-        bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n+        bcx, vec::map(lltydescs, {|d| {desc: d, vtables: none}}),\n         env_vals + vec::map(bound, {|x| env_expr(x, expr_ty(bcx, x))}),\n         ty::ck_box);\n \n@@ -816,25 +816,25 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let off = 0;\n     for param in param_bounds {\n         let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, off])),\n-            dicts = none;\n+            vtables = none;\n         llargs += [dsc];\n         off += 1;\n         for bound in *param {\n             alt bound {\n               ty::bound_iface(_) {\n-                let dict = Load(l_bcx, GEPi(l_bcx, param_record, [0, off]));\n-                dict = PointerCast(l_bcx, dict, T_ptr(T_dict()));\n-                llargs += [dict];\n+                let vtable = Load(l_bcx, GEPi(l_bcx, param_record, [0, off]));\n+                vtable = PointerCast(l_bcx, vtable, T_ptr(T_vtable()));\n+                llargs += [vtable];\n                 off += 1;\n-                dicts = some(alt dicts {\n-                  none { [dict] }\n-                  some(ds) { ds + [dict] }\n+                vtables = some(alt vtables {\n+                  none { [vtable] }\n+                  some(ds) { ds + [vtable] }\n                 });\n               }\n               _ {}\n             }\n         }\n-        fcx.lltyparams += [{desc: dsc, dicts: dicts}];\n+        fcx.lltyparams += [{desc: dsc, vtables: vtables}];\n     }\n \n     let a: uint = first_tp_arg; // retptr, env come first"}, {"sha": "7dce92d94d75252a328ed82f8d9a44f040031aa1", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -70,7 +70,7 @@ type maps = {\n     last_uses: middle::last_use::last_uses,\n     impl_map: middle::resolve::impl_map,\n     method_map: middle::typeck::method_map,\n-    dict_map: middle::typeck::dict_map\n+    vtable_map: middle::typeck::vtable_map\n };\n \n // Crate context.  Every crate we compile has one of these.\n@@ -122,10 +122,10 @@ type val_self_pair = {v: ValueRef, t: ty::t};\n \n enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n-type fn_ty_param = {desc: ValueRef, dicts: option<[ValueRef]>};\n+type fn_ty_param = {desc: ValueRef, vtables: option<[ValueRef]>};\n \n type param_substs = {tys: [ty::t],\n-                     dicts: option<typeck::dict_res>,\n+                     vtables: option<typeck::vtable_res>,\n                      bounds: @[ty::param_bounds]};\n \n // Function context.  Every LLVM function we create will have one of\n@@ -179,7 +179,7 @@ type fn_ctxt = @{\n     // Same as above, but for closure upvars\n     llupvars: hashmap<ast::node_id, ValueRef>,\n \n-    // A vector of incoming type descriptors and their associated iface dicts.\n+    // A vector of incoming type descriptors and their associated vtables.\n     mutable lltyparams: [fn_ty_param],\n \n     // Derived tydescs are tydescs created at runtime, for types that\n@@ -541,11 +541,11 @@ fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n \n-// A dict is, in reality, a vtable pointer followed by zero or more pointers\n-// to tydescs and other dicts that it closes over. But the types and number of\n-// those are rarely known to the code that needs to manipulate them, so they\n-// are described by this opaque type.\n-fn T_dict() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n+// A vtable is, in reality, a vtable pointer followed by zero or more pointers\n+// to tydescs and other vtables that it closes over. But the types and number\n+// of those are rarely known to the code that needs to manipulate them, so\n+// they are described by this opaque type.\n+fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n \n fn T_task(targ_cfg: @session::config) -> TypeRef {\n     let t = T_named_struct(\"task\");\n@@ -848,14 +848,14 @@ pure fn type_has_static_size(cx: @crate_ctxt, t: ty::t) -> bool {\n }\n \n // Used to identify cached monomorphized functions\n-enum mono_dicts { some_dicts([mono_id]), no_dicts }\n-type mono_id = @{def: ast::def_id, substs: [ty::t], dicts: mono_dicts};\n+enum mono_vtables { some_vts([mono_id]), no_vts }\n+type mono_id = @{def: ast::def_id, substs: [ty::t], vtables: mono_vtables};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let h = syntax::ast_util::hash_def_id(mi.def);\n     for ty in mi.substs { h = (h << 2u) + ty::type_id(ty); }\n-    alt mi.dicts {\n-      some_dicts(ds) { for d in ds { h = (h << 2u) + hash_mono_id(d); } }\n-      _ {}\n+    alt mi.vtables {\n+      some_vts(ds) { for d in ds { h = (h << 2u) + hash_mono_id(d); } }\n+      no_vts {}\n     }\n     h\n }"}, {"sha": "a48f4147ba36762408c2cd9885f1429fe726188d", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -67,27 +67,27 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n // Method callee where the method is statically known\n fn trans_static_callee(bcx: block, callee_id: ast::node_id,\n                        base: @ast::expr, did: ast::def_id,\n-                       substs: option<([ty::t], typeck::dict_res)>)\n+                       substs: option<([ty::t], typeck::vtable_res)>)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n     {env: self_env(val, node_id_type(bcx, base.id))\n      with lval_static_fn(bcx, did, callee_id, substs)}\n }\n \n-fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n+fn wrapper_fn_ty(ccx: @crate_ctxt, vtable_ty: TypeRef, fty: ty::t,\n                  tps: @[ty::param_bounds]) -> {ty: ty::t, llty: TypeRef} {\n     let bare_fn_ty = type_of_fn_from_ty(ccx, fty, *tps);\n     let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n-    {ty: fty, llty: T_fn([dict_ty] + inputs, output)}\n+    {ty: fty, llty: T_fn([vtable_ty] + inputs, output)}\n }\n \n-fn trans_vtable_callee(bcx: block, env: callee_env, dict: ValueRef,\n+fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n                        callee_id: ast::node_id, n_method: uint)\n     -> lval_maybe_callee {\n-    let bcx = bcx, ccx = bcx.ccx(), tcx = ccx.tcx;\n+    let bcx = bcx, ccx = bcx.ccx();\n     let fty = node_id_type(bcx, callee_id);\n     let llfty = type_of::type_of_fn_from_ty(ccx, fty, []);\n-    let vtable = PointerCast(bcx, dict,\n+    let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n     {bcx: bcx, val: mptr, kind: owned,\n@@ -112,34 +112,34 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               base: @ast::expr, iface_id: ast::def_id,\n                               n_method: uint, n_param: uint, n_bound: uint,\n                               substs: param_substs) -> lval_maybe_callee {\n-    alt find_dict_in_fn_ctxt(substs, n_param, n_bound) {\n-      typeck::dict_static(impl_did, tys, sub_origins) {\n+    alt find_vtable_in_fn_ctxt(substs, n_param, n_bound) {\n+      typeck::vtable_static(impl_did, tys, sub_origins) {\n         let tcx = bcx.tcx();\n         let mname = ty::iface_methods(tcx, iface_id)[n_method].ident;\n         let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n         ret trans_static_callee(bcx, callee_id, base, mth_id,\n                                 some((tys, sub_origins)));\n       }\n-      typeck::dict_iface(iid, tps) {\n+      typeck::vtable_iface(iid, tps) {\n         ret trans_iface_callee(bcx, base, callee_id, n_method);\n       }\n-      typeck::dict_param(n_param, n_bound) {\n-        fail \"dict_param left in monomorphized function's dict substs\";\n+      typeck::vtable_param(n_param, n_bound) {\n+        fail \"vtable_param left in monomorphized function's vtable substs\";\n       }\n     }\n }\n \n-// Method callee where the dict comes from a boxed iface\n+// Method callee where the vtable comes from a boxed iface\n fn trans_iface_callee(bcx: block, base: @ast::expr,\n                       callee_id: ast::node_id, n_method: uint)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n-    let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0, 0]),\n-                                     T_ptr(T_ptr(T_dict()))));\n+    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0, 0]),\n+                                     T_ptr(T_ptr(T_vtable()))));\n     let box = Load(bcx, GEPi(bcx, val, [0, 1]));\n     // FIXME[impl] I doubt this is alignment-safe\n     let self = GEPi(bcx, box, [0, abi::box_field_body]);\n-    trans_vtable_callee(bcx, self_env(self, expr_ty(bcx, base)), dict,\n+    trans_vtable_callee(bcx, self_env(self, expr_ty(bcx, base)), vtable,\n                         callee_id, n_method)\n }\n \n@@ -151,30 +151,30 @@ fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     {inputs: args, output: out_ty}\n }\n \n-fn find_dict_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n-    -> typeck::dict_origin {\n-    let dict_off = n_bound, i = 0u;\n-    // Dicts are stored in a flat array, finding the right one is\n+fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n+    -> typeck::vtable_origin {\n+    let vtable_off = n_bound, i = 0u;\n+    // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n     for bounds in *ps.bounds {\n         i += 1u;\n         if i >= n_param { break; }\n         for bound in *bounds {\n-            alt bound { ty::bound_iface(_) { dict_off += 1u; } _ {} }\n+            alt bound { ty::bound_iface(_) { vtable_off += 1u; } _ {} }\n         }\n     }\n-    option::get(ps.dicts)[dict_off]\n+    option::get(ps.vtables)[vtable_off]\n }\n \n-fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::dict_res)\n-    -> typeck::dict_res {\n+fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n+    -> typeck::vtable_res {\n     @vec::map(*vts, {|d| resolve_vtable_in_fn_ctxt(fcx, d)})\n }\n \n-fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::dict_origin)\n-    -> typeck::dict_origin {\n+fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n+    -> typeck::vtable_origin {\n     alt vt {\n-      typeck::dict_static(iid, tys, sub) {\n+      typeck::vtable_static(iid, tys, sub) {\n         let tys = alt fcx.param_substs {\n           some(substs) {\n             vec::map(tys, {|t|\n@@ -183,41 +183,41 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::dict_origin)\n           }\n           _ { tys }\n         };\n-        typeck::dict_static(iid, tys, resolve_vtables_in_fn_ctxt(fcx, sub))\n+        typeck::vtable_static(iid, tys, resolve_vtables_in_fn_ctxt(fcx, sub))\n       }\n-      typeck::dict_param(n_param, n_bound) {\n+      typeck::vtable_param(n_param, n_bound) {\n         alt check fcx.param_substs {\n           some(substs) {\n-            find_dict_in_fn_ctxt(substs, n_param, n_bound)\n+            find_vtable_in_fn_ctxt(substs, n_param, n_bound)\n           }\n         }\n       }\n       _ { vt }\n     }\n }\n \n-fn vtable_id(origin: typeck::dict_origin) -> mono_id {\n+fn vtable_id(origin: typeck::vtable_origin) -> mono_id {\n     alt check origin {\n-      typeck::dict_static(impl_id, substs, sub_dicts) {\n+      typeck::vtable_static(impl_id, substs, sub_vtables) {\n         @{def: impl_id, substs: substs,\n-          dicts: if (*sub_dicts).len() == 0u { no_dicts }\n-                 else { some_dicts(vec::map(*sub_dicts, vtable_id)) } }\n+          vtables: if (*sub_vtables).len() == 0u { no_vts }\n+                 else { some_vts(vec::map(*sub_vtables, vtable_id)) } }\n       }\n-      typeck::dict_iface(iface_id, substs) {\n-        @{def: iface_id, substs: substs, dicts: no_dicts}\n+      typeck::vtable_iface(iface_id, substs) {\n+        @{def: iface_id, substs: substs, vtables: no_vts}\n       }\n     }\n }\n \n-fn get_vtable(ccx: @crate_ctxt, origin: typeck::dict_origin)\n+fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n     -> ValueRef {\n     let hash_id = vtable_id(origin);\n     alt ccx.vtables.find(hash_id) {\n       some(val) { val }\n       none {\n         alt check origin {\n-          typeck::dict_static(id, substs, sub_dicts) {\n-            make_impl_vtable(ccx, id, substs, sub_dicts)\n+          typeck::vtable_static(id, substs, sub_vtables) {\n+            make_impl_vtable(ccx, id, substs, sub_vtables)\n           }\n         }\n       }\n@@ -236,7 +236,7 @@ fn make_vtable(ccx: @crate_ctxt, ptrs: [ValueRef]) -> ValueRef {\n }\n \n fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n-                    dicts: typeck::dict_res) -> ValueRef {\n+                    vtables: typeck::vtable_res) -> ValueRef {\n     let tcx = ccx.tcx;\n     let ifce_id = ty::ty_to_def_id(option::get(ty::impl_iface(tcx, impl_id)));\n     make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), {|im|\n@@ -246,7 +246,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n             C_null(type_of_fn_from_ty(ccx, fty, []))\n         } else {\n             let m_id = method_with_name(ccx, impl_id, im.ident);\n-            option::get(monomorphic_fn(ccx, m_id, substs, some(dicts))).llfn\n+            option::get(monomorphic_fn(ccx, m_id, substs, some(vtables))).llfn\n         }\n     }))\n }\n@@ -410,7 +410,7 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     let result = get_dest_addr(dest);\n     Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0, 1]),\n                                 T_ptr(val_ty(box))));\n-    let orig = ccx.maps.dict_map.get(id)[0];\n+    let orig = ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n     Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0, 0]),"}, {"sha": "417147fee95a2d1a01b796ebe15df07ca7f86c81", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -33,7 +33,7 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n         atys += [T_ptr(cx.tydesc_type)];\n         for bound in *bounds {\n             alt bound {\n-              ty::bound_iface(_) { atys += [T_ptr(T_dict())]; }\n+              ty::bound_iface(_) { atys += [T_ptr(T_vtable())]; }\n               _ {}\n             }\n         }"}, {"sha": "f301317198f88e1b731c460dec801750252c8555", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c9f585342d6974c5f1847f18ab2b6322b1ea42/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=83c9f585342d6974c5f1847f18ab2b6322b1ea42", "patch": "@@ -18,7 +18,8 @@ import syntax::print::pprust::*;\n \n export check_crate;\n export method_map, method_origin, method_static, method_param, method_iface;\n-export dict_map, dict_res, dict_origin, dict_static, dict_param, dict_iface;\n+export vtable_map, vtable_res, vtable_origin, vtable_static, vtable_param,\n+       vtable_iface;\n \n enum method_origin {\n     method_static(ast::def_id),\n@@ -29,14 +30,14 @@ enum method_origin {\n type method_map = hashmap<ast::node_id, method_origin>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n-type dict_res = @[dict_origin];\n-enum dict_origin {\n-    dict_static(ast::def_id, [ty::t], dict_res),\n+type vtable_res = @[vtable_origin];\n+enum vtable_origin {\n+    vtable_static(ast::def_id, [ty::t], vtable_res),\n     // Param number, bound number\n-    dict_param(uint, uint),\n-    dict_iface(ast::def_id, [ty::t]),\n+    vtable_param(uint, uint),\n+    vtable_iface(ast::def_id, [ty::t]),\n }\n-type dict_map = hashmap<ast::node_id, dict_res>;\n+type vtable_map = hashmap<ast::node_id, vtable_res>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n@@ -46,7 +47,7 @@ enum self_info { self_impl(ty::t) }\n type crate_ctxt = {mutable self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n                    method_map: method_map,\n-                   dict_map: dict_map,\n+                   vtable_map: vtable_map,\n                    // Not at all sure it's right to put these here\n                    /* node_id for the class this fn is in --\n                       none if it's not in a class */\n@@ -3186,7 +3187,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // If we have an enclosing function scope, our type variables will be\n     // resolved when the enclosing scope finishes up.\n     if option::is_none(old_fcx) {\n-        dict::resolve_in_block(fcx, body);\n+        vtable::resolve_in_block(fcx, body);\n         writeback::resolve_type_vars_in_block(fcx, body);\n     }\n }\n@@ -3309,7 +3310,7 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n }\n \n-mod dict {\n+mod vtable {\n     fn has_iface_bounds(tps: [ty::param_bounds]) -> bool {\n         vec::any(tps, {|bs|\n             vec::any(*bs, {|b|\n@@ -3318,16 +3319,16 @@ mod dict {\n         })\n     }\n \n-    fn lookup_dicts(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n+    fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                     bounds: @[ty::param_bounds], tys: [ty::t])\n-        -> dict_res {\n+        -> vtable_res {\n         let tcx = fcx.ccx.tcx, result = [], i = 0u;\n         for ty in tys {\n             for bound in *bounds[i] {\n                 alt bound {\n                   ty::bound_iface(i_ty) {\n                     let i_ty = ty::substitute_type_params(tcx, tys, i_ty);\n-                    result += [lookup_dict(fcx, isc, sp, ty, i_ty)];\n+                    result += [lookup_vtable(fcx, isc, sp, ty, i_ty)];\n                   }\n                   _ {}\n                 }\n@@ -3337,8 +3338,8 @@ mod dict {\n         @result\n     }\n \n-    fn lookup_dict(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n-                   ty: ty::t, iface_ty: ty::t) -> dict_origin {\n+    fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n+                   ty: ty::t, iface_ty: ty::t) -> vtable_origin {\n         let tcx = fcx.ccx.tcx;\n         let (iface_id, iface_tps) = alt check ty::get(iface_ty).struct {\n             ty::ty_iface(did, tps) { (did, tps) }\n@@ -3352,7 +3353,7 @@ mod dict {\n                   ty::bound_iface(ity) {\n                     alt check ty::get(ity).struct {\n                       ty::ty_iface(idid, _) {\n-                        if iface_id == idid { ret dict_param(n, n_bound); }\n+                        if iface_id == idid { ret vtable_param(n, n_bound); }\n                       }\n                     }\n                     n_bound += 1u;\n@@ -3362,7 +3363,7 @@ mod dict {\n             }\n           }\n           ty::ty_iface(did, tps) if iface_id == did {\n-            ret dict_iface(did, tps);\n+            ret vtable_iface(did, tps);\n           }\n           _ {\n             let found = none;\n@@ -3394,9 +3395,9 @@ mod dict {\n                                                   im.did);\n                                 let params = vec::map(vars, {|t|\n                                     fixup_ty(fcx, sp, t)});\n-                                let subres = lookup_dicts(fcx, isc, sp, im_bs,\n-                                                          params);\n-                                found = some(dict_static(im.did, params,\n+                                let subres = lookup_vtables(fcx, isc, sp,\n+                                                            im_bs, params);\n+                                found = some(vtable_static(im.did, params,\n                                                          subres));\n                             }\n                           }\n@@ -3452,7 +3453,7 @@ mod dict {\n                 let item_ty = ty::lookup_item_type(cx.tcx, did);\n                 if has_iface_bounds(*item_ty.bounds) {\n                     let impls = cx.impl_map.get(ex.id);\n-                    cx.dict_map.insert(ex.id, lookup_dicts(\n+                    cx.vtable_map.insert(ex.id, lookup_vtables(\n                         fcx, impls, ex.span, item_ty.bounds, ts));\n                 }\n               }\n@@ -3473,7 +3474,7 @@ mod dict {\n                     };\n                     let ts = ty::node_id_to_type_params(cx.tcx, callee_id);\n                     let iscs = cx.impl_map.get(ex.id);\n-                    cx.dict_map.insert(callee_id, lookup_dicts(\n+                    cx.vtable_map.insert(callee_id, lookup_vtables(\n                         fcx, iscs, ex.span, bounds, ts));\n                 }\n               }\n@@ -3485,9 +3486,9 @@ mod dict {\n             alt ty::get(target_ty).struct {\n               ty::ty_iface(_, _) {\n                 let impls = cx.impl_map.get(ex.id);\n-                let dict = lookup_dict(fcx, impls, ex.span,\n+                let vtable = lookup_vtable(fcx, impls, ex.span,\n                                        expr_ty(cx.tcx, src), target_ty);\n-                cx.dict_map.insert(ex.id, @[dict]);\n+                cx.vtable_map.insert(ex.id, @[vtable]);\n               }\n               _ {}\n             }\n@@ -3512,13 +3513,13 @@ mod dict {\n }\n \n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n-               crate: @ast::crate) -> (method_map, dict_map) {\n+               crate: @ast::crate) -> (method_map, vtable_map) {\n     collect::collect_item_types(tcx, crate);\n \n     let ccx = @{mutable self_infos: [],\n                 impl_map: impl_map,\n                 method_map: std::map::int_hash(),\n-                dict_map: std::map::int_hash(),\n+                vtable_map: std::map::int_hash(),\n                 enclosing_class_id: none,\n                 enclosing_class: std::map::int_hash(),\n                 tcx: tcx};\n@@ -3529,7 +3530,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n     visit::visit_crate(*crate, (), visit);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();\n-    (ccx.method_map, ccx.dict_map)\n+    (ccx.method_map, ccx.vtable_map)\n }\n //\n // Local Variables:"}]}