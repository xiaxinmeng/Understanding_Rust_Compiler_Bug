{"sha": "afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYTc0MDgwNDEwYzFlYmE0Y2QyM2RkZDhlMmFjM2Q2YWQxNDQxZTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-01-02T18:31:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-01-03T13:14:55Z"}, "message": "use PlaceRef more consistently instead of loosely coupled local+projection", "tree": {"sha": "027e71c779c9f58520d93b2f433faf8565538b9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/027e71c779c9f58520d93b2f433faf8565538b9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "html_url": "https://github.com/rust-lang/rust/commit/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "929f66af9bf587383ed6010403e738e79dfac0d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/929f66af9bf587383ed6010403e738e79dfac0d6", "html_url": "https://github.com/rust-lang/rust/commit/929f66af9bf587383ed6010403e738e79dfac0d6"}], "stats": {"total": 172, "additions": 61, "deletions": 111}, "files": [{"sha": "b1e372afc6501c5f4011f1cceb70746d3ae74bd3", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "patch": "@@ -104,7 +104,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     ) {\n         let cx = self.fx.cx;\n \n-        if let &[ref proj_base @ .., elem] = place_ref.projection {\n+        if let Some((place_base, elem)) = place_ref.last_projection() {\n             let mut base_context = if context.is_mutating_use() {\n                 PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             } else {\n@@ -119,8 +119,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 )\n             );\n             if is_consume {\n-                let base_ty =\n-                    mir::Place::ty_from(place_ref.local, proj_base, self.fx.mir, cx.tcx());\n+                let base_ty = mir::PlaceRef::ty(&place_base, self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(base_ty);\n \n                 // ZSTs don't require any actual memory access.\n@@ -175,11 +174,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 base_context = context;\n             }\n \n-            self.process_place(\n-                &mir::PlaceRef { local: place_ref.local, projection: proj_base },\n-                base_context,\n-                location,\n-            );\n+            self.process_place(&place_base, base_context, location);\n             // HACK(eddyb) this emulates the old `visit_projection_elem`, this\n             // entire `visit_place`-like `process_place` method should be rewritten,\n             // now that we have moved to the \"slice of projections\" representation."}, {"sha": "af05319ae157e7f5afd68adbb220a0eabc10e948", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, self.mir, tcx);\n+        let place_ty = mir::PlaceRef::ty(&place_ref, self.mir, tcx);\n         self.monomorphize(place_ty.ty)\n     }\n }"}, {"sha": "fab2f2c97e4ae13487f625c5fa135df9e7950f8c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "patch": "@@ -1745,18 +1745,14 @@ impl<'tcx> Place<'tcx> {\n \n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n-    //\n-    // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n+    #[inline(always)]\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n-        match self.as_ref() {\n-            PlaceRef { local, projection: [] }\n-            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(local),\n-            _ => None,\n-        }\n+        self.as_ref().local_or_deref_local()\n     }\n \n     /// If this place represents a local variable like `_X` with no\n     /// projections, return `Some(_X)`.\n+    #[inline(always)]\n     pub fn as_local(&self) -> Option<Local> {\n         self.as_ref().as_local()\n     }\n@@ -1770,6 +1766,7 @@ impl<'tcx> Place<'tcx> {\n     /// As a concrete example, given the place a.b.c, this would yield:\n     /// - (a, .b)\n     /// - (a.b, .c)\n+    ///\n     /// Given a place without projections, the iterator is empty.\n     pub fn iter_projections(\n         self,\n@@ -1790,8 +1787,6 @@ impl From<Local> for Place<'_> {\n impl<'tcx> PlaceRef<'tcx> {\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n-    //\n-    // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match *self {\n             PlaceRef { local, projection: [] }\n@@ -1808,6 +1803,14 @@ impl<'tcx> PlaceRef<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    pub fn last_projection(&self) -> Option<(PlaceRef<'tcx>, PlaceElem<'tcx>)> {\n+        if let &[ref proj_base @ .., elem] = self.projection {\n+            Some((PlaceRef { local: self.local, projection: proj_base }, elem))\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl Debug for Place<'_> {"}, {"sha": "0bb09e26f03e8a64508c44d8d14371333d93a020", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "patch": "@@ -293,9 +293,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            let ty =\n-                Place::ty_from(used_place.local, used_place.projection, self.body, self.infcx.tcx)\n-                    .ty;\n+            let ty = PlaceRef::ty(&used_place, self.body, self.infcx.tcx).ty;\n             let needs_note = match ty.kind() {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck(id.expect_local());\n@@ -732,8 +730,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> (String, String, String, String) {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n-        let union_ty = |place_base, place_projection| {\n-            let ty = Place::ty_from(place_base, place_projection, self.body, self.infcx.tcx).ty;\n+        let union_ty = |place_base| {\n+            let ty = PlaceRef::ty(&place_base, self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n \n@@ -751,15 +749,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // field access to a union. If we find that, then we will keep the place of the\n                 // union being accessed and the field that was being accessed so we can check the\n                 // second borrowed place for the same union and a access to a different field.\n-                let Place { local, projection } = first_borrowed_place;\n-\n-                let mut cursor = projection.as_ref();\n-                while let [proj_base @ .., elem] = cursor {\n-                    cursor = proj_base;\n-\n+                for (place_base, elem) in first_borrowed_place.iter_projections().rev() {\n                     match elem {\n-                        ProjectionElem::Field(field, _) if union_ty(local, proj_base).is_some() => {\n-                            return Some((PlaceRef { local, projection: proj_base }, field));\n+                        ProjectionElem::Field(field, _) if union_ty(place_base).is_some() => {\n+                            return Some((place_base, field));\n                         }\n                         _ => {}\n                     }\n@@ -769,23 +762,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let Place { local, ref projection } = second_borrowed_place;\n-\n-                let mut cursor = &projection[..];\n-                while let [proj_base @ .., elem] = cursor {\n-                    cursor = proj_base;\n-\n+                for (place_base, elem) in second_borrowed_place.iter_projections().rev() {\n                     if let ProjectionElem::Field(field, _) = elem {\n-                        if let Some(union_ty) = union_ty(local, proj_base) {\n-                            if field != target_field\n-                                && local == target_base.local\n-                                && proj_base == target_base.projection\n-                            {\n+                        if let Some(union_ty) = union_ty(place_base) {\n+                            if field != target_field && place_base == target_base {\n                                 return Some((\n-                                    self.describe_any_place(PlaceRef {\n-                                        local,\n-                                        projection: proj_base,\n-                                    }),\n+                                    self.describe_any_place(place_base),\n                                     self.describe_any_place(first_borrowed_place.as_ref()),\n                                     self.describe_any_place(second_borrowed_place.as_ref()),\n                                     union_ty.to_string(),"}, {"sha": "006e05072a7a9f627bb1a08724eb91b919c3c8b9", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 24, "deletions": 50, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "patch": "@@ -1740,20 +1740,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         self.check_if_full_path_is_moved(location, desired_action, place_span, flow_state);\n \n-        if let [base_proj @ .., ProjectionElem::Subslice { from, to, from_end: false }] =\n-            place_span.0.projection\n+        if let Some((place_base, ProjectionElem::Subslice { from, to, from_end: false })) =\n+            place_span.0.last_projection()\n         {\n-            let place_ty =\n-                Place::ty_from(place_span.0.local, base_proj, self.body(), self.infcx.tcx);\n+            let place_ty = PlaceRef::ty(&place_base, self.body(), self.infcx.tcx);\n             if let ty::Array(..) = place_ty.ty.kind() {\n-                let array_place = PlaceRef { local: place_span.0.local, projection: base_proj };\n                 self.check_if_subslice_element_is_moved(\n                     location,\n                     desired_action,\n-                    (array_place, place_span.1),\n+                    (place_base, place_span.1),\n                     maybe_uninits,\n-                    *from,\n-                    *to,\n+                    from,\n+                    to,\n                 );\n                 return;\n             }\n@@ -1825,10 +1823,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n \n         // None case => assigning to `x` does not require `x` be initialized.\n-        let mut cursor = &*place.projection.as_ref();\n-        while let [proj_base @ .., elem] = cursor {\n-            cursor = proj_base;\n-\n+        for (place_base, elem) in place.iter_projections().rev() {\n             match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n                 ProjectionElem::ConstantIndex { .. } |\n@@ -1843,10 +1838,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ProjectionElem::Deref => {\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n-                        (PlaceRef {\n-                            local: place.local,\n-                            projection: proj_base,\n-                        }, span), flow_state);\n+                        (place_base, span), flow_state);\n                     // (base initialized; no need to\n                     // recur further)\n                     break;\n@@ -1862,15 +1854,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(place.local, proj_base, self.body(), tcx).ty;\n+                    let base_ty = PlaceRef::ty(&place_base, self.body(), tcx).ty;\n                     match base_ty.kind() {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n-                                (PlaceRef {\n-                                    local: place.local,\n-                                    projection: proj_base,\n-                                }, span), flow_state);\n+                                (place_base, span), flow_state);\n \n                             // (base initialized; no need to\n                             // recur further)\n@@ -1880,10 +1869,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Once `let s; s.x = V; read(s.x);`,\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n-                            check_parent_of_field(self, location, PlaceRef {\n-                                local: place.local,\n-                                projection: proj_base,\n-                            }, span, flow_state);\n+                            check_parent_of_field(self, location, place_base, span, flow_state);\n \n                             // rust-lang/rust#21232, #54499, #54986: during period where we reject\n                             // partial initialization, do not complain about unnecessary `mut` on\n@@ -1965,9 +1951,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::Adt(def, _) =\n-                    Place::ty_from(base.local, base.projection, this.body(), tcx).ty.kind()\n-                {\n+                if let ty::Adt(def, _) = PlaceRef::ty(&base, this.body(), tcx).ty.kind() {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(location, this.body)\n@@ -2162,9 +2146,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         place: PlaceRef<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) -> Result<RootPlace<'tcx>, PlaceRef<'tcx>> {\n-        match place {\n-            PlaceRef { local, projection: [] } => {\n-                let local = &self.body.local_decls[local];\n+        match place.last_projection() {\n+            None => {\n+                let local = &self.body.local_decls[place.local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n@@ -2186,11 +2170,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }),\n                 }\n             }\n-            PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n+            Some((place_base, elem)) => {\n                 match elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty =\n-                            Place::ty_from(place.local, proj_base, self.body(), self.infcx.tcx).ty;\n+                        let base_ty = PlaceRef::ty(&place_base, self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.kind() {\n@@ -2208,10 +2191,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             _ => LocalMutationIsAllowed::Yes,\n                                         };\n \n-                                        self.is_mutable(\n-                                            PlaceRef { local: place.local, projection: proj_base },\n-                                            mode,\n-                                        )\n+                                        self.is_mutable(place_base, mode)\n                                     }\n                                 }\n                             }\n@@ -2229,10 +2209,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n-                            _ if base_ty.is_box() => self.is_mutable(\n-                                PlaceRef { local: place.local, projection: proj_base },\n-                                is_local_mutation_allowed,\n-                            ),\n+                            _ if base_ty.is_box() => {\n+                                self.is_mutable(place_base, is_local_mutation_allowed)\n+                            }\n                             // Deref should only be for reference, pointers or boxes\n                             _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n                         }\n@@ -2286,10 +2265,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     //     });\n                                     // }\n                                     // ```\n-                                    let _ = self.is_mutable(\n-                                        PlaceRef { local: place.local, projection: proj_base },\n-                                        is_local_mutation_allowed,\n-                                    )?;\n+                                    let _ =\n+                                        self.is_mutable(place_base, is_local_mutation_allowed)?;\n                                     Ok(RootPlace {\n                                         place_local: place.local,\n                                         place_projection: place.projection,\n@@ -2298,10 +2275,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 }\n                             }\n                         } else {\n-                            self.is_mutable(\n-                                PlaceRef { local: place.local, projection: proj_base },\n-                                is_local_mutation_allowed,\n-                            )\n+                            self.is_mutable(place_base, is_local_mutation_allowed)\n                         }\n                     }\n                 }"}, {"sha": "cf04c55eb68c512b21f0260dd7786db8ccb40f06", "filename": "compiler/rustc_mir/src/borrow_check/prefixes.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs?ref=afa74080410c1eba4cd23ddd8e2ac3d6ad1441e3", "patch": "@@ -10,7 +10,7 @@\n use super::MirBorrowckCtxt;\n \n use rustc_hir as hir;\n-use rustc_middle::mir::{Body, Place, PlaceRef, ProjectionElem};\n+use rustc_middle::mir::{Body, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, TyCtxt};\n \n pub trait IsPrefixOf<'tcx> {\n@@ -67,32 +67,31 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n         // downcasts here, but may return a base of a downcast).\n \n         'cursor: loop {\n-            match &cursor {\n-                PlaceRef { local: _, projection: [] } => {\n+            match cursor.last_projection() {\n+                None => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n-                PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n+                Some((cursor_base, elem)) => {\n                     match elem {\n                         ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n                             // FIXME: add union handling\n-                            self.next =\n-                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n+                            self.next = Some(cursor_base);\n                             return Some(cursor);\n                         }\n                         ProjectionElem::Downcast(..)\n                         | ProjectionElem::Subslice { .. }\n                         | ProjectionElem::ConstantIndex { .. }\n                         | ProjectionElem::Index(_) => {\n-                            cursor = PlaceRef { local: cursor.local, projection: proj_base };\n+                            cursor = cursor_base;\n                             continue 'cursor;\n                         }\n                         ProjectionElem::Deref => {\n                             // (handled below)\n                         }\n                     }\n \n-                    assert_eq!(*elem, ProjectionElem::Deref);\n+                    assert_eq!(elem, ProjectionElem::Deref);\n \n                     match self.kind {\n                         PrefixSet::Shallow => {\n@@ -105,8 +104,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         PrefixSet::All => {\n                             // All prefixes: just blindly enqueue the base\n                             // of the projection.\n-                            self.next =\n-                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n+                            self.next = Some(cursor_base);\n                             return Some(cursor);\n                         }\n                         PrefixSet::Supporting => {\n@@ -119,7 +117,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.local, proj_base, self.body, self.tcx).ty;\n+                    let ty = PlaceRef::ty(&cursor_base, self.body, self.tcx).ty;\n                     match ty.kind() {\n                         ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n@@ -129,14 +127,12 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         }\n \n                         ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Mut) => {\n-                            self.next =\n-                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n+                            self.next = Some(cursor_base);\n                             return Some(cursor);\n                         }\n \n                         ty::Adt(..) if ty.is_box() => {\n-                            self.next =\n-                                Some(PlaceRef { local: cursor.local, projection: proj_base });\n+                            self.next = Some(cursor_base);\n                             return Some(cursor);\n                         }\n "}]}