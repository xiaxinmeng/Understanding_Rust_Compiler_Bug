{"sha": "aa1267f630e01d19dcd9247ffb3a795aba0df461", "node_id": "C_kwDOAAsO6NoAKGFhMTI2N2Y2MzBlMDFkMTlkY2Q5MjQ3ZmZiM2E3OTVhYmEwZGY0NjE", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2023-01-21T00:00:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-17T09:36:12Z"}, "message": "Preprocess dominator tree to answer queries in O(1)", "tree": {"sha": "728c396cd52dd432451924923edf2210be8a52f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/728c396cd52dd432451924923edf2210be8a52f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa1267f630e01d19dcd9247ffb3a795aba0df461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1267f630e01d19dcd9247ffb3a795aba0df461", "html_url": "https://github.com/rust-lang/rust/commit/aa1267f630e01d19dcd9247ffb3a795aba0df461", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa1267f630e01d19dcd9247ffb3a795aba0df461/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c64870fa67f0227f40f6adc25a6944e95c2959f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c64870fa67f0227f40f6adc25a6944e95c2959f", "html_url": "https://github.com/rust-lang/rust/commit/6c64870fa67f0227f40f6adc25a6944e95c2959f"}], "stats": {"total": 192, "additions": 137, "deletions": 55}, "files": [{"sha": "2d8cbea8bacc15eb53ae3b55014bff9e570e7ca0", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=aa1267f630e01d19dcd9247ffb3a795aba0df461", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if self.unwind_edge_count <= 1 {\n             return;\n         }\n-        let doms = self.body.basic_blocks.dominators();\n+        let dom_tree = self.body.basic_blocks.dominator_tree();\n         let mut post_contract_node = FxHashMap::default();\n         // Reusing the allocation across invocations of the closure\n         let mut dom_path = vec![];\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 if let Some(root) = post_contract_node.get(&bb) {\n                     break *root;\n                 }\n-                let parent = doms.immediate_dominator(bb).unwrap();\n+                let parent = dom_tree.immediate_dominator(bb).unwrap();\n                 dom_path.push(bb);\n                 if !self.body.basic_blocks[parent].is_cleanup {\n                     break bb;"}, {"sha": "5d6a1de1d21c8b49548f218af74bcf5f15ced9e5", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 95, "deletions": 12, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=aa1267f630e01d19dcd9247ffb3a795aba0df461", "patch": "@@ -26,7 +26,7 @@ rustc_index::newtype_index! {\n     struct PreorderIndex {}\n }\n \n-pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n+pub fn dominator_tree<G: ControlFlowGraph>(graph: G) -> DominatorTree<G::Node> {\n     // compute the post order index (rank) for each node\n     let mut post_order_rank = IndexVec::from_elem_n(0, graph.num_nodes());\n \n@@ -244,7 +244,7 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n \n     let start_node = graph.start_node();\n     immediate_dominators[start_node] = None;\n-    Dominators { start_node, post_order_rank, immediate_dominators }\n+    DominatorTree { start_node, post_order_rank, immediate_dominators }\n }\n \n /// Evaluate the link-eval virtual forest, providing the currently minimum semi\n@@ -309,16 +309,18 @@ fn compress(\n \n /// Tracks the list of dominators for each node.\n #[derive(Clone, Debug)]\n-pub struct Dominators<N: Idx> {\n+pub struct DominatorTree<N: Idx> {\n     start_node: N,\n     post_order_rank: IndexVec<N, usize>,\n     // Even though we track only the immediate dominator of each node, it's\n     // possible to get its full list of dominators by looking up the dominator\n     // of each dominator. (See the `impl Iterator for Iter` definition).\n+    //\n+    // Note: immediate_dominators[root] is Some(root)!\n     immediate_dominators: IndexVec<N, Option<N>>,\n }\n \n-impl<Node: Idx> Dominators<Node> {\n+impl<Node: Idx> DominatorTree<Node> {\n     /// Returns true if node is reachable from the start node.\n     pub fn is_reachable(&self, node: Node) -> bool {\n         node == self.start_node || self.immediate_dominators[node].is_some()\n@@ -333,12 +335,7 @@ impl<Node: Idx> Dominators<Node> {\n     /// See the `impl Iterator for Iter` definition to understand how this works.\n     pub fn dominators(&self, node: Node) -> Iter<'_, Node> {\n         assert!(self.is_reachable(node), \"node {node:?} is not reachable\");\n-        Iter { dominators: self, node: Some(node) }\n-    }\n-\n-    pub fn dominates(&self, dom: Node, node: Node) -> bool {\n-        // FIXME -- could be optimized by using post-order-rank\n-        self.dominators(node).any(|n| n == dom)\n+        Iter { dom_tree: self, node: Some(node) }\n     }\n \n     /// Provide deterministic ordering of nodes such that, if any two nodes have a dominator\n@@ -351,7 +348,7 @@ impl<Node: Idx> Dominators<Node> {\n }\n \n pub struct Iter<'dom, Node: Idx> {\n-    dominators: &'dom Dominators<Node>,\n+    dom_tree: &'dom DominatorTree<Node>,\n     node: Option<Node>,\n }\n \n@@ -360,10 +357,96 @@ impl<'dom, Node: Idx> Iterator for Iter<'dom, Node> {\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(node) = self.node {\n-            self.node = self.dominators.immediate_dominator(node);\n+            self.node = self.dom_tree.immediate_dominator(node);\n             Some(node)\n         } else {\n             None\n         }\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub struct Dominators<Node: Idx> {\n+    time: IndexVec<Node, Time>,\n+}\n+\n+/// Describes the number of vertices discovered at the time when processing of a particular vertex\n+/// started and when it finished. Both values are zero for unreachable vertices.\n+#[derive(Copy, Clone, Default, Debug)]\n+struct Time {\n+    start: u32,\n+    finish: u32,\n+}\n+\n+impl<Node: Idx> Dominators<Node> {\n+    pub fn dummy() -> Self {\n+        Self { time: Default::default() }\n+    }\n+\n+    /// Returns true if `a` dominates `b`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `b` is unreachable.\n+    pub fn dominates(&self, a: Node, b: Node) -> bool {\n+        let a = self.time[a];\n+        let b = self.time[b];\n+        assert!(b.start != 0, \"node {b:?} is not reachable\");\n+        a.start <= b.start && b.finish <= a.finish\n+    }\n+}\n+\n+pub fn dominators<N: Idx>(tree: &DominatorTree<N>) -> Dominators<N> {\n+    let DominatorTree { start_node, ref immediate_dominators, post_order_rank: _ } = *tree;\n+\n+    // Transpose the dominator tree edges, so that child nodes of vertex v are stored in\n+    // node[edges[v].start..edges[y].end].\n+    let mut edges: IndexVec<N, std::ops::Range<u32>> =\n+        IndexVec::from_elem(0..0, immediate_dominators);\n+    for &idom in immediate_dominators.iter() {\n+        if let Some(idom) = idom {\n+            edges[idom].end += 1;\n+        }\n+    }\n+    let mut m = 0;\n+    for e in edges.iter_mut() {\n+        m += e.end;\n+        e.start = m;\n+        e.end = m;\n+    }\n+    let mut node = IndexVec::from_elem_n(Idx::new(0), m.try_into().unwrap());\n+    for (i, &idom) in immediate_dominators.iter_enumerated() {\n+        if let Some(idom) = idom {\n+            edges[idom].start -= 1;\n+            node[edges[idom].start] = i;\n+        }\n+    }\n+\n+    // Perform a depth-first search of the dominator tree. Record the number of vertices discovered\n+    // when vertex v is discovered first as time[v].start, and when its processing is finished as\n+    // time[v].finish.\n+    let mut time: IndexVec<N, Time> = IndexVec::from_elem(Time::default(), immediate_dominators);\n+    let mut stack = Vec::new();\n+\n+    let mut discovered = 1;\n+    stack.push(start_node);\n+    time[start_node].start = discovered;\n+\n+    while let Some(&i) = stack.last() {\n+        let e = &mut edges[i];\n+        if e.start == e.end {\n+            // Finish processing vertex i.\n+            time[i].finish = discovered;\n+            stack.pop();\n+        } else {\n+            let j = node[e.start];\n+            e.start += 1;\n+            // Start processing vertex j.\n+            discovered += 1;\n+            time[j].start = discovered;\n+            stack.push(j);\n+        }\n+    }\n+\n+    Dominators { time }\n+}"}, {"sha": "61a21724ddadba39659c61bc9d8a1bced4b3353a", "filename": "compiler/rustc_data_structures/src/graph/dominators/tests.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs?ref=aa1267f630e01d19dcd9247ffb3a795aba0df461", "patch": "@@ -6,8 +6,8 @@ use super::super::tests::TestGraph;\n fn diamond() {\n     let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n \n-    let dominators = dominators(&graph);\n-    let immediate_dominators = &dominators.immediate_dominators;\n+    let tree = dominator_tree(&graph);\n+    let immediate_dominators = &tree.immediate_dominators;\n     assert_eq!(immediate_dominators[0], None);\n     assert_eq!(immediate_dominators[1], Some(0));\n     assert_eq!(immediate_dominators[2], Some(0));\n@@ -22,8 +22,8 @@ fn paper() {\n         &[(6, 5), (6, 4), (5, 1), (4, 2), (4, 3), (1, 2), (2, 3), (3, 2), (2, 1)],\n     );\n \n-    let dominators = dominators(&graph);\n-    let immediate_dominators = &dominators.immediate_dominators;\n+    let dom_tree = dominator_tree(&graph);\n+    let immediate_dominators = &dom_tree.immediate_dominators;\n     assert_eq!(immediate_dominators[0], None); // <-- note that 0 is not in graph\n     assert_eq!(immediate_dominators[1], Some(6));\n     assert_eq!(immediate_dominators[2], Some(6));\n@@ -41,15 +41,15 @@ fn paper_slt() {\n         &[(1, 2), (1, 3), (2, 3), (2, 7), (3, 4), (3, 6), (4, 5), (5, 4), (6, 7), (7, 8), (8, 5)],\n     );\n \n-    dominators(&graph);\n+    dominator_tree(&graph);\n }\n \n #[test]\n fn immediate_dominator() {\n     let graph = TestGraph::new(1, &[(1, 2), (2, 3)]);\n-    let dominators = dominators(&graph);\n-    assert_eq!(dominators.immediate_dominator(0), None);\n-    assert_eq!(dominators.immediate_dominator(1), None);\n-    assert_eq!(dominators.immediate_dominator(2), Some(1));\n-    assert_eq!(dominators.immediate_dominator(3), Some(2));\n+    let tree = dominator_tree(&graph);\n+    assert_eq!(tree.immediate_dominator(0), None);\n+    assert_eq!(tree.immediate_dominator(1), None);\n+    assert_eq!(tree.immediate_dominator(2), Some(1));\n+    assert_eq!(tree.immediate_dominator(3), Some(2));\n }"}, {"sha": "f5157e18e6d2f5c0bbe604dd05b7fa21b0dd78c1", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=aa1267f630e01d19dcd9247ffb3a795aba0df461", "patch": "@@ -3,6 +3,7 @@ use crate::mir::{BasicBlock, BasicBlockData, Successors, Terminator, TerminatorK\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n+use rustc_data_structures::graph::dominators::{dominator_tree, DominatorTree};\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::OnceCell;\n@@ -41,8 +42,12 @@ impl<'tcx> BasicBlocks<'tcx> {\n         *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n+    pub fn dominator_tree(&self) -> DominatorTree<BasicBlock> {\n+        dominator_tree(&self)\n+    }\n+\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(&self)\n+        dominators(&self.dominator_tree())\n     }\n \n     /// Returns predecessors for each basic block."}, {"sha": "0126310e9ffc78c3ce544aec33514ad57a4af805", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=aa1267f630e01d19dcd9247ffb3a795aba0df461", "patch": "@@ -2,13 +2,14 @@ use super::Error;\n \n use itertools::Itertools;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::dominators::{self, Dominators};\n+use rustc_data_structures::graph::dominators::{self, DominatorTree, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors, WithNumNodes, WithStartNode};\n use rustc_index::bit_set::BitSet;\n use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n \n+use std::cmp::Ordering;\n use std::ops::{Index, IndexMut};\n \n const ID_SEPARATOR: &str = \",\";\n@@ -24,6 +25,7 @@ pub(super) struct CoverageGraph {\n     bb_to_bcb: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n     pub successors: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n     pub predecessors: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n+    dominator_tree: Option<DominatorTree<BasicCoverageBlock>>,\n     dominators: Option<Dominators<BasicCoverageBlock>>,\n }\n \n@@ -66,9 +68,17 @@ impl CoverageGraph {\n             }\n         }\n \n-        let mut basic_coverage_blocks =\n-            Self { bcbs, bb_to_bcb, successors, predecessors, dominators: None };\n-        let dominators = dominators::dominators(&basic_coverage_blocks);\n+        let mut basic_coverage_blocks = Self {\n+            bcbs,\n+            bb_to_bcb,\n+            successors,\n+            predecessors,\n+            dominator_tree: None,\n+            dominators: None,\n+        };\n+        let dominator_tree = dominators::dominator_tree(&basic_coverage_blocks);\n+        let dominators = dominators::dominators(&dominator_tree);\n+        basic_coverage_blocks.dominator_tree = Some(dominator_tree);\n         basic_coverage_blocks.dominators = Some(dominators);\n         basic_coverage_blocks\n     }\n@@ -212,8 +222,12 @@ impl CoverageGraph {\n     }\n \n     #[inline(always)]\n-    pub fn dominators(&self) -> &Dominators<BasicCoverageBlock> {\n-        self.dominators.as_ref().unwrap()\n+    pub fn rank_partial_cmp(\n+        &self,\n+        a: BasicCoverageBlock,\n+        b: BasicCoverageBlock,\n+    ) -> Option<Ordering> {\n+        self.dominator_tree.as_ref().unwrap().rank_partial_cmp(a, b)\n     }\n }\n \n@@ -650,26 +664,6 @@ pub(super) fn find_loop_backedges(\n     let mut backedges = IndexVec::from_elem_n(Vec::<BasicCoverageBlock>::new(), num_bcbs);\n \n     // Identify loops by their backedges.\n-    //\n-    // The computational complexity is bounded by: n(s) x d where `n` is the number of\n-    // `BasicCoverageBlock` nodes (the simplified/reduced representation of the CFG derived from the\n-    // MIR); `s` is the average number of successors per node (which is most likely less than 2, and\n-    // independent of the size of the function, so it can be treated as a constant);\n-    // and `d` is the average number of dominators per node.\n-    //\n-    // The average number of dominators depends on the size and complexity of the function, and\n-    // nodes near the start of the function's control flow graph typically have less dominators\n-    // than nodes near the end of the CFG. Without doing a detailed mathematical analysis, I\n-    // think the resulting complexity has the characteristics of O(n log n).\n-    //\n-    // The overall complexity appears to be comparable to many other MIR transform algorithms, and I\n-    // don't expect that this function is creating a performance hot spot, but if this becomes an\n-    // issue, there may be ways to optimize the `dominates` algorithm (as indicated by an\n-    // existing `FIXME` comment in that code), or possibly ways to optimize it's usage here, perhaps\n-    // by keeping track of results for visited `BasicCoverageBlock`s if they can be used to short\n-    // circuit downstream `dominates` checks.\n-    //\n-    // For now, that kind of optimization seems unnecessarily complicated.\n     for (bcb, _) in basic_coverage_blocks.iter_enumerated() {\n         for &successor in &basic_coverage_blocks.successors[bcb] {\n             if basic_coverage_blocks.dominates(successor, bcb) {"}, {"sha": "97dd1dd09a25a8787815fb7e2fd99d5a36b493b3", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=aa1267f630e01d19dcd9247ffb3a795aba0df461", "patch": "@@ -345,7 +345,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                         // before the dominated equal spans). When later comparing two spans in\n                         // order, the first will either dominate the second, or they will have no\n                         // dominator relationship.\n-                        self.basic_coverage_blocks.dominators().rank_partial_cmp(a.bcb, b.bcb)\n+                        self.basic_coverage_blocks.rank_partial_cmp(a.bcb, b.bcb)\n                     }\n                 } else {\n                     // Sort hi() in reverse order so shorter spans are attempted after longer spans."}, {"sha": "a5b3873533c22bdb027c57492ec245441465cb25", "filename": "compiler/rustc_mir_transform/src/ctfe_limit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1267f630e01d19dcd9247ffb3a795aba0df461/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs?ref=aa1267f630e01d19dcd9247ffb3a795aba0df461", "patch": "@@ -2,7 +2,7 @@\n //! (thus indicating there is a loop in the CFG), or whose terminator is a function call.\n use crate::MirPass;\n \n-use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::graph::dominators::DominatorTree;\n use rustc_middle::mir::{\n     BasicBlock, BasicBlockData, Body, Statement, StatementKind, TerminatorKind,\n };\n@@ -13,7 +13,7 @@ pub struct CtfeLimit;\n impl<'tcx> MirPass<'tcx> for CtfeLimit {\n     #[instrument(skip(self, _tcx, body))]\n     fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let doms = body.basic_blocks.dominators();\n+        let doms = body.basic_blocks.dominator_tree();\n         let indices: Vec<BasicBlock> = body\n             .basic_blocks\n             .iter_enumerated()\n@@ -39,7 +39,7 @@ impl<'tcx> MirPass<'tcx> for CtfeLimit {\n }\n \n fn has_back_edge(\n-    doms: &Dominators<BasicBlock>,\n+    doms: &DominatorTree<BasicBlock>,\n     node: BasicBlock,\n     node_data: &BasicBlockData<'_>,\n ) -> bool {"}]}