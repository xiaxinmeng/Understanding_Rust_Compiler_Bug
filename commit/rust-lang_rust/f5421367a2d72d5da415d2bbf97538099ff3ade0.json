{"sha": "f5421367a2d72d5da415d2bbf97538099ff3ade0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NDIxMzY3YTJkNzJkNWRhNDE1ZDJiYmY5NzUzODA5OWZmM2FkZTA=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-05-27T15:00:11Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-05-27T15:15:32Z"}, "message": "Docs: impls of PartialEq/PartialOrd/Ord must agree", "tree": {"sha": "c226dc98d38063c18e3f65e91c87e95fde06b1dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c226dc98d38063c18e3f65e91c87e95fde06b1dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5421367a2d72d5da415d2bbf97538099ff3ade0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5421367a2d72d5da415d2bbf97538099ff3ade0", "html_url": "https://github.com/rust-lang/rust/commit/f5421367a2d72d5da415d2bbf97538099ff3ade0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5421367a2d72d5da415d2bbf97538099ff3ade0/comments", "author": null, "committer": null, "parents": [{"sha": "0aeb9c12979e6da753701a798d04105b6b1a8c28", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aeb9c12979e6da753701a798d04105b6b1a8c28", "html_url": "https://github.com/rust-lang/rust/commit/0aeb9c12979e6da753701a798d04105b6b1a8c28"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "0094804631b08e468498af41df0e148447c25d4b", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5421367a2d72d5da415d2bbf97538099ff3ade0/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5421367a2d72d5da415d2bbf97538099ff3ade0/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=f5421367a2d72d5da415d2bbf97538099ff3ade0", "patch": "@@ -42,8 +42,11 @@\n //! // instead of a max-heap.\n //! impl Ord for State {\n //!     fn cmp(&self, other: &State) -> Ordering {\n-//!         // Notice that the we flip the ordering here\n+//!         // Notice that the we flip the ordering on costs.\n+//!         // In case of a tie we compare positions - this step is necessary\n+//!         // to make implementations of `PartialEq` and `Ord` consistent.\n //!         other.cost.cmp(&self.cost)\n+//!             .then_with(|| self.position.cmp(&other.position))\n //!     }\n //! }\n //!"}, {"sha": "d523e40b49ed53301f3e38c0932cd1cb73d7673f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5421367a2d72d5da415d2bbf97538099ff3ade0/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5421367a2d72d5da415d2bbf97538099ff3ade0/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=f5421367a2d72d5da415d2bbf97538099ff3ade0", "patch": "@@ -67,6 +67,10 @@ use self::Ordering::*;\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n+/// each other. It's easy to accidentally make them disagree by deriving some\n+/// of the traits and manually implementing others.\n+///\n /// An example implementation for a domain in which two books are considered\n /// the same book if their ISBN matches, even if the formats differ:\n ///\n@@ -343,6 +347,10 @@ impl Ordering {\n /// Then you must define an implementation for `cmp()`. You may find it useful to use\n /// `cmp()` on your type's fields.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// Here's an example where you want to sort people by height only, disregarding `id`\n /// and `name`:\n ///\n@@ -431,15 +439,19 @@ impl PartialOrd for Ordering {\n ///\n /// ## How can I implement `PartialOrd`?\n ///\n-/// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n-/// from default implementations.\n+/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n+/// generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n ///\n /// `PartialOrd` requires your type to be `PartialEq`.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n ///\n /// ```"}]}