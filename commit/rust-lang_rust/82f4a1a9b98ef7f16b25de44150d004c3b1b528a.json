{"sha": "82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZjRhMWE5Yjk4ZWY3ZjE2YjI1ZGU0NDE1MGQwMDRjM2IxYjUyOGE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-22T10:41:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-22T11:16:24Z"}, "message": "get rid of ConstPropUnsupported; use ZST marker structs instead", "tree": {"sha": "449668a65f8bed64d681cc2bcce924d6ce55d0bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/449668a65f8bed64d681cc2bcce924d6ce55d0bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "html_url": "https://github.com/rust-lang/rust/commit/82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5574b1df577f737373b42cbf364b6cab2dfa5960", "url": "https://api.github.com/repos/rust-lang/rust/commits/5574b1df577f737373b42cbf364b6cab2dfa5960", "html_url": "https://github.com/rust-lang/rust/commit/5574b1df577f737373b42cbf364b6cab2dfa5960"}], "stats": {"total": 87, "additions": 63, "deletions": 24}, "files": [{"sha": "39df803bbea3010cdc475133679ee97cebc24f30", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "patch": "@@ -164,7 +164,7 @@ impl dyn Any {\n         // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get `TypeId` of the type in the trait object.\n+        // Get `TypeId` of the type in the trait object (`self`).\n         let concrete = self.type_id();\n \n         // Compare both `TypeId`s on equality."}, {"sha": "fd7f5361214f490e3198fc03cabb56199be6ae26", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "patch": "@@ -14,7 +14,10 @@ use rustc_hir as hir;\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n use rustc_span::{def_id::DefId, Pos, Span};\n-use std::{any::Any, fmt};\n+use std::{\n+    any::{Any, TypeId},\n+    fmt, mem,\n+};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n@@ -451,9 +454,6 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-    /// When const-prop encounters a situation it does not support, it raises this error.\n-    /// This must not allocate for performance reasons (hence `str`, not `String`).\n-    ConstPropUnsupported(&'static str),\n     /// Accessing an unsupported foreign static.\n     ReadForeignStatic(DefId),\n     /// Could not find MIR for a function.\n@@ -472,9 +472,6 @@ impl fmt::Debug for UnsupportedOpInfo {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ConstPropUnsupported(ref msg) => {\n-                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg)\n-            }\n             ReadForeignStatic(did) => {\n                 write!(f, \"tried to read from foreign (extern) static {:?}\", did)\n             }\n@@ -516,6 +513,35 @@ impl fmt::Debug for ResourceExhaustionInfo {\n     }\n }\n \n+/// A trait for machine-specific errors (or other \"machine stop\" conditions).\n+pub trait MachineStopType: Any + fmt::Debug + Send {}\n+impl MachineStopType for String {}\n+\n+// Copy-pasted from `any.rs`; there does not seem to be a way to re-use that.\n+impl dyn MachineStopType {\n+    pub fn is<T: Any>(&self) -> bool {\n+        // Get `TypeId` of the type this function is instantiated with.\n+        let t = TypeId::of::<T>();\n+\n+        // Get `TypeId` of the type in the trait object (`self`).\n+        let concrete = self.type_id();\n+\n+        // Compare both `TypeId`s on equality.\n+        t == concrete\n+    }\n+\n+    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n+        if self.is::<T>() {\n+            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on\n+            // that check for memory safety because `Any` is implemented for all types; no other\n+            // impls can exist as they would conflict with our impl.\n+            unsafe { Some(&*(self as *const dyn MachineStopType as *const T)) }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n     UndefinedBehavior(UndefinedBehaviorInfo),\n@@ -529,7 +555,7 @@ pub enum InterpError<'tcx> {\n     ResourceExhaustion(ResourceExhaustionInfo),\n     /// Stop execution for a machine-controlled reason. This is never raised by\n     /// the core engine itself.\n-    MachineStop(Box<dyn Any + Send>),\n+    MachineStop(Box<dyn MachineStopType>),\n }\n \n pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n@@ -549,7 +575,7 @@ impl fmt::Debug for InterpError<'_> {\n             InvalidProgram(ref msg) => write!(f, \"{:?}\", msg),\n             UndefinedBehavior(ref msg) => write!(f, \"{:?}\", msg),\n             ResourceExhaustion(ref msg) => write!(f, \"{:?}\", msg),\n-            MachineStop(_) => bug!(\"unhandled MachineStop\"),\n+            MachineStop(ref msg) => write!(f, \"{:?}\", msg),\n         }\n     }\n }\n@@ -560,8 +586,9 @@ impl InterpError<'_> {\n     /// waste of resources.\n     pub fn allocates(&self) -> bool {\n         match self {\n-            InterpError::MachineStop(_)\n-            | InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n+            // Zero-sized boxes to not allocate.\n+            InterpError::MachineStop(b) => mem::size_of_val(&**b) > 0,\n+            InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_)) => true,"}, {"sha": "35876c8e95ab5aea278fc747011cb1f24f50b897", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "patch": "@@ -92,8 +92,8 @@ mod value;\n \n pub use self::error::{\n     struct_error, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled, FrameInfo,\n-    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, ResourceExhaustionInfo,\n-    UndefinedBehaviorInfo, UnsupportedOpInfo,\n+    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n+    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUndef};"}, {"sha": "687bacfdc1b837977b9601d433e601a1344e1a2b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f4a1a9b98ef7f16b25de44150d004c3b1b528a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=82f4a1a9b98ef7f16b25de44150d004c3b1b528a", "patch": "@@ -4,7 +4,7 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n \n-use rustc::mir::interpret::{InterpResult, Scalar};\n+use rustc::mir::interpret::{InterpResult, MachineStopType, Scalar};\n use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -192,7 +192,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        throw_unsup!(ConstPropUnsupported(\"calling intrinsics isn't supported in ConstProp\"))\n+        #[derive(Debug)]\n+        struct ConstPropIntrinsic;\n+        impl MachineStopType for ConstPropIntrinsic {}\n+        throw_machine_stop!(ConstPropIntrinsic)\n     }\n \n     fn assert_panic(\n@@ -204,7 +207,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        throw_unsup!(ConstPropUnsupported(\"ptr-to-int casts aren't supported in ConstProp\"))\n+        throw_unsup!(ReadPointerAsBytes)\n     }\n \n     fn binary_ptr_op(\n@@ -213,11 +216,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n+        #[derive(Debug)]\n+        struct ConstPropPtrOp;\n+        impl MachineStopType for ConstPropPtrOp {}\n         // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_unsup!(ConstPropUnsupported(\n-            \"pointer arithmetic or comparisons aren't supported \\\n-            in ConstProp\"\n-        ))\n+        throw_machine_stop!(ConstPropPtrOp)\n     }\n \n     #[inline(always)]\n@@ -240,7 +243,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        throw_unsup!(ConstPropUnsupported(\"can't const prop `box` keyword\"))\n+        #[derive(Debug)]\n+        struct ConstPropBox;\n+        impl MachineStopType for ConstPropBox {}\n+        throw_machine_stop!(ConstPropBox)\n     }\n \n     fn access_local(\n@@ -251,7 +257,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         let l = &frame.locals[local];\n \n         if l.value == LocalValue::Uninitialized {\n-            throw_unsup!(ConstPropUnsupported(\"tried to access an uninitialized local\"));\n+            #[derive(Debug)]\n+            struct ConstPropUninitLocal;\n+            impl MachineStopType for ConstPropUninitLocal {}\n+            throw_machine_stop!(ConstPropUninitLocal)\n         }\n \n         l.access()\n@@ -261,10 +270,13 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _memory_extra: &(),\n         allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n     ) -> InterpResult<'tcx> {\n+        #[derive(Debug)]\n+        struct ConstPropGlobalMem;\n+        impl MachineStopType for ConstPropGlobalMem {}\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n         // the memory behind that in the future), then we can't const prop it\n         if allocation.mutability == Mutability::Mut || allocation.relocations().len() > 0 {\n-            throw_unsup!(ConstPropUnsupported(\"can't eval mutable statics in ConstProp\"));\n+            throw_machine_stop!(ConstPropGlobalMem)\n         }\n \n         Ok(())"}]}