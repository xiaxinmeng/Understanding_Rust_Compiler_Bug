{"sha": "1316422a7c2ef26e9da78fa23f170407b1cb39bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMTY0MjJhN2MyZWYyNmU5ZGE3OGZhMjNmMTcwNDA3YjFjYjM5YmI=", "commit": {"author": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2020-12-28T13:41:15Z"}, "committer": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2021-01-23T07:40:24Z"}, "message": "Add diagnostic for filter_map followed by next", "tree": {"sha": "1eea156207bcc920f0573ef51d7f6ad4fe03299d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eea156207bcc920f0573ef51d7f6ad4fe03299d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1316422a7c2ef26e9da78fa23f170407b1cb39bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1316422a7c2ef26e9da78fa23f170407b1cb39bb", "html_url": "https://github.com/rust-lang/rust/commit/1316422a7c2ef26e9da78fa23f170407b1cb39bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1316422a7c2ef26e9da78fa23f170407b1cb39bb/comments", "author": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eab5db20edd9604ba5d489fa8c6430eb7bac6610", "url": "https://api.github.com/repos/rust-lang/rust/commits/eab5db20edd9604ba5d489fa8c6430eb7bac6610", "html_url": "https://github.com/rust-lang/rust/commit/eab5db20edd9604ba5d489fa8c6430eb7bac6610"}], "stats": {"total": 165, "additions": 150, "deletions": 15}, "files": [{"sha": "f7fd3e237cf918a494f691caf610e63108d8c058", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=1316422a7c2ef26e9da78fa23f170407b1cb39bb", "patch": "@@ -5,5 +5,14 @@ pub use hir_expand::diagnostics::{\n };\n pub use hir_ty::diagnostics::{\n     IncorrectCase, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n-    NoSuchField, RemoveThisSemicolon,\n+    NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n };\n+\n+// PHIL:\n+// hir/src/diagnostics.rs - just pub uses the type from hir_ty::diagnostics (DONE)\n+// hir_ty/src/diagnostics.rs - defines the type (DONE)\n+// hir_ty/src/diagnostics.rs - plus a test (DONE) <--- one example found, need to copy the not-applicable tests from the assist version\n+// ide/src/diagnostics.rs - define handler for when this diagnostic is raised (DONE)\n+\n+// ide/src/diagnostics/fixes.rs - pulls in type from hir, and impls DiagnosticWithFix (TODO)\n+// hir_ty/src/diagnostics/expr.rs - do the real work (TODO)"}, {"sha": "b4cf81c1081743c1251c2a808b07779d82764eef", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=1316422a7c2ef26e9da78fa23f170407b1cb39bb", "patch": "@@ -247,7 +247,7 @@ impl Diagnostic for RemoveThisSemicolon {\n \n // Diagnostic: break-outside-of-loop\n //\n-// This diagnostic is triggered if `break` keyword is used outside of a loop.\n+// This diagnostic is triggered if the `break` keyword is used outside of a loop.\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub file: HirFileId,\n@@ -271,7 +271,7 @@ impl Diagnostic for BreakOutsideOfLoop {\n \n // Diagnostic: missing-unsafe\n //\n-// This diagnostic is triggered if operation marked as `unsafe` is used outside of `unsafe` function or block.\n+// This diagnostic is triggered if an operation marked as `unsafe` is used outside of an `unsafe` function or block.\n #[derive(Debug)]\n pub struct MissingUnsafe {\n     pub file: HirFileId,\n@@ -295,7 +295,7 @@ impl Diagnostic for MissingUnsafe {\n \n // Diagnostic: mismatched-arg-count\n //\n-// This diagnostic is triggered if function is invoked with an incorrect amount of arguments.\n+// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n     pub file: HirFileId,\n@@ -347,7 +347,7 @@ impl fmt::Display for CaseType {\n \n // Diagnostic: incorrect-ident-case\n //\n-// This diagnostic is triggered if item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n+// This diagnostic is triggered if an item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n #[derive(Debug)]\n pub struct IncorrectCase {\n     pub file: HirFileId,\n@@ -386,6 +386,31 @@ impl Diagnostic for IncorrectCase {\n     }\n }\n \n+// Diagnostic: replace-filter-map-next-with-find-map\n+//\n+// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n+#[derive(Debug)]\n+pub struct ReplaceFilterMapNextWithFindMap {\n+    pub file: HirFileId,\n+    pub filter_map_expr: AstPtr<ast::Expr>,\n+    pub next_expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"replace-filter-map-next-with-find-map\")\n+    }\n+    fn message(&self) -> String {\n+        \"replace filter_map(..).next() with find_map(..)\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.filter_map_expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n@@ -644,4 +669,19 @@ fn foo() { break; }\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn replace_missing_filter_next_with_find_map() {\n+        check_diagnostics(\n+            r#\"\n+            fn foo() {\n+            let m = [1, 2, 3]\n+                .iter()\n+                .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+                .next();\n+                //^^^ Replace .filter_map(..).next() with .find_map(..)\n+            }\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "170d23178d221a73d4c6774afb4d7767305c884b", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=1316422a7c2ef26e9da78fa23f170407b1cb39bb", "patch": "@@ -24,6 +24,8 @@ pub(crate) use hir_def::{\n     LocalFieldId, VariantId,\n };\n \n+use super::ReplaceFilterMapNextWithFindMap;\n+\n pub(super) struct ExprValidator<'a, 'b: 'a> {\n     owner: DefWithBodyId,\n     infer: Arc<InferenceResult>,\n@@ -39,7 +41,18 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         ExprValidator { owner, infer, sink }\n     }\n \n+    fn bar() {\n+        // LOOK FOR THIS\n+        let m = [1, 2, 3]\n+            .iter()\n+            .filter_map(|x| if *x == 2 { Some(4) } else { None })\n+            .next();\n+    }\n+\n     pub(super) fn validate_body(&mut self, db: &dyn HirDatabase) {\n+        // DO NOT MERGE: just getting something working for now\n+        self.check_for_filter_map_next(db);\n+\n         let body = db.body(self.owner.into());\n \n         for (id, expr) in body.exprs.iter() {\n@@ -150,20 +163,58 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n-    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) -> Option<()> {\n+    fn check_for_filter_map_next(&mut self, db: &dyn HirDatabase) {\n+        let body = db.body(self.owner.into());\n+        let mut prev = None;\n+\n+        for (id, expr) in body.exprs.iter() {\n+            if let Expr::MethodCall { receiver, method_name, args, .. } = expr {\n+                let method_name_hack_do_not_merge = format!(\"{}\", method_name);\n+\n+                if method_name_hack_do_not_merge == \"filter_map\" && args.len() == 1 {\n+                    prev = Some((id, args[0]));\n+                    continue;\n+                }\n+\n+                if method_name_hack_do_not_merge == \"next\" {\n+                    if let Some((filter_map_id, filter_map_args)) = prev {\n+                        if *receiver == filter_map_id {\n+                            let (_, source_map) = db.body_with_source_map(self.owner.into());\n+                            if let (Ok(filter_map_source_ptr), Ok(next_source_ptr)) = (\n+                                source_map.expr_syntax(filter_map_id),\n+                                source_map.expr_syntax(id),\n+                            ) {\n+                                self.sink.push(ReplaceFilterMapNextWithFindMap {\n+                                    file: filter_map_source_ptr.file_id,\n+                                    filter_map_expr: filter_map_source_ptr.value,\n+                                    next_expr: next_source_ptr.value,\n+                                });\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            prev = None;\n+        }\n+    }\n+\n+    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) {\n         // Check that the number of arguments matches the number of parameters.\n \n         // FIXME: Due to shortcomings in the current type system implementation, only emit this\n         // diagnostic if there are no type mismatches in the containing function.\n         if self.infer.type_mismatches.iter().next().is_some() {\n-            return None;\n+            return;\n         }\n \n         let is_method_call = matches!(expr, Expr::MethodCall { .. });\n         let (sig, args) = match expr {\n             Expr::Call { callee, args } => {\n                 let callee = &self.infer.type_of_expr[*callee];\n-                let sig = callee.callable_sig(db)?;\n+                let sig = match callee.callable_sig(db) {\n+                    Some(sig) => sig,\n+                    None => return,\n+                };\n                 (sig, args.clone())\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n@@ -175,22 +226,25 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     // if the receiver is of unknown type, it's very likely we\n                     // don't know enough to correctly resolve the method call.\n                     // This is kind of a band-aid for #6975.\n-                    return None;\n+                    return;\n                 }\n \n                 // FIXME: note that we erase information about substs here. This\n                 // is not right, but, luckily, doesn't matter as we care only\n                 // about the number of params\n-                let callee = self.infer.method_resolution(call_id)?;\n+                let callee = match self.infer.method_resolution(call_id) {\n+                    Some(callee) => callee,\n+                    None => return,\n+                };\n                 let sig = db.callable_item_signature(callee.into()).value;\n \n                 (sig, args)\n             }\n-            _ => return None,\n+            _ => return,\n         };\n \n         if sig.is_varargs {\n-            return None;\n+            return;\n         }\n \n         let params = sig.params();\n@@ -213,8 +267,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                 });\n             }\n         }\n-\n-        None\n     }\n \n     fn validate_match("}, {"sha": "8607139ba3cbb1d9190b2b8be7dec21545a22f55", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=1316422a7c2ef26e9da78fa23f170407b1cb39bb", "patch": "@@ -136,6 +136,9 @@ pub(crate) fn diagnostics(\n         .on::<hir::diagnostics::IncorrectCase, _>(|d| {\n             res.borrow_mut().push(warning_with_fix(d, &sema));\n         })\n+        .on::<hir::diagnostics::ReplaceFilterMapNextWithFindMap, _>(|d| {\n+            res.borrow_mut().push(warning_with_fix(d, &sema));\n+        })\n         .on::<hir::diagnostics::InactiveCode, _>(|d| {\n             // If there's inactive code somewhere in a macro, don't propagate to the call-site.\n             if d.display_source().file_id.expansion_info(db).is_some() {"}, {"sha": "eafbac43aa93fb6909f417938cb1d04ddbdb2f11", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1316422a7c2ef26e9da78fa23f170407b1cb39bb/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=1316422a7c2ef26e9da78fa23f170407b1cb39bb", "patch": "@@ -4,7 +4,7 @@ use hir::{\n     db::AstDatabase,\n     diagnostics::{\n         Diagnostic, IncorrectCase, MissingFields, MissingOkOrSomeInTailExpr, NoSuchField,\n-        RemoveThisSemicolon, UnresolvedModule,\n+        RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnresolvedModule,\n     },\n     HasSource, HirDisplay, InFile, Semantics, VariantDef,\n };\n@@ -144,6 +144,37 @@ impl DiagnosticWithFix for IncorrectCase {\n     }\n }\n \n+// Bugs:\n+//  * Action is applicable for both iter() and filter_map() rows\n+//  * Action deletes the entire method chain\n+impl DiagnosticWithFix for ReplaceFilterMapNextWithFindMap {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+\n+        let next_expr = self.next_expr.to_node(&root);\n+        let next_expr_range = next_expr.syntax().text_range();\n+\n+        let filter_map_expr = self.filter_map_expr.to_node(&root);\n+        let filter_map_expr_range = filter_map_expr.syntax().text_range();\n+\n+        let edit = TextEdit::delete(next_expr_range);\n+\n+        // This is the entire method chain, including the array literal\n+        eprintln!(\"NEXT EXPR: {:#?}\", next_expr);\n+        // This is the entire method chain except for the final next()\n+        eprintln!(\"FILTER MAP EXPR: {:#?}\", filter_map_expr);\n+\n+        let source_change =\n+            SourceFileEdit { file_id: self.file.original_file(sema.db), edit }.into();\n+\n+        Some(Fix::new(\n+            \"Replace filter_map(..).next() with find_map()\",\n+            source_change,\n+            filter_map_expr_range,\n+        ))\n+    }\n+}\n+\n fn missing_record_expr_field_fix(\n     sema: &Semantics<RootDatabase>,\n     usage_file_id: FileId,"}]}