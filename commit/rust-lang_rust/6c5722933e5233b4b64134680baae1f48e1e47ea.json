{"sha": "6c5722933e5233b4b64134680baae1f48e1e47ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNTcyMjkzM2U1MjMzYjRiNjQxMzQ2ODBiYWFlMWY0OGUxZTQ3ZWE=", "commit": {"author": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-28T17:17:07Z"}, "committer": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-28T17:17:07Z"}, "message": "Fix typos - looked into the papers handling of timestamps, after looking into it again, it seems the paper only increments the timestamp after release operations, so changed to approximation of that implementation.", "tree": {"sha": "1a2754e1e534bbdaf22cce7a13109a9db546508e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a2754e1e534bbdaf22cce7a13109a9db546508e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c5722933e5233b4b64134680baae1f48e1e47ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5722933e5233b4b64134680baae1f48e1e47ea", "html_url": "https://github.com/rust-lang/rust/commit/6c5722933e5233b4b64134680baae1f48e1e47ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c5722933e5233b4b64134680baae1f48e1e47ea/comments", "author": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55fc552d9900e2f53ad4302da9387da32d7bcf8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/55fc552d9900e2f53ad4302da9387da32d7bcf8d", "html_url": "https://github.com/rust-lang/rust/commit/55fc552d9900e2f53ad4302da9387da32d7bcf8d"}], "stats": {"total": 72, "additions": 26, "deletions": 46}, "files": [{"sha": "49332721fcbd11757b57c9c9216b7721b5212285", "filename": "src/data_race.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6c5722933e5233b4b64134680baae1f48e1e47ea/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5722933e5233b4b64134680baae1f48e1e47ea/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=6c5722933e5233b4b64134680baae1f48e1e47ea", "patch": "@@ -39,21 +39,14 @@\n //!\n //! The timestamps used in the data-race detector assign each sequence of non-atomic operations\n //! followed by a single atomic or concurrent operation a single timestamp.\n-//! Write, Read, Write, ThreadJoin will be represented by a single timestamp value on a thread\n+//! Write, Read, Write, ThreadJoin will be represented by a single timestamp value on a thread.\n //! This is because extra increment operations between the operations in the sequence are not\n //! required for accurate reporting of data-race values.\n //!\n-//! If the timestamp was not incremented after the atomic operation, then data-races would not be detected:\n-//!  Example - this should report a data-race but does not:\n-//!   t1: (x,0), atomic[release A],                    t1=(x+1, 0  ), write(var B),\n-//!   t2: (0,y)                   , atomic[acquire A], t2=(x+1, y+1),             ,write(var B)\n-//!\n-//! The timestamp is not incremented before an atomic operation, since the result is indistinguishable\n-//! from the value not being incremented.\n-//!    t: (x, 0), atomic[release _], (x + 1, 0) || (0, y), atomic[acquire _], (x, _)\n-//! vs t: (x, 0), atomic[release _], (x + 1, 0) || (0, y), atomic[acquire _], (x+1, _)\n-//! Both result in the sequence on thread x up to and including the atomic release as happening\n-//! before the acquire.\n+//! As per the paper a threads timestamp is only incremented after a release operation is performed\n+//! so some atomic operations that only perform acquires do not increment the timestamp, due to shared\n+//! code some atomic operations may increment the timestamp when not necessary but this has no effect\n+//! on the data-race detection code.\n //!\n //! FIXME:\n //! currently we have our own local copy of the currently active thread index and names, this is due\n@@ -516,7 +509,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         Ok(old)\n     }\n \n-    /// Perform an atomic compare and exchange at a given memory location\n+    /// Perform an atomic compare and exchange at a given memory location.\n     /// On success an atomic RMW operation is performed and on failure\n     /// only an atomic read occurs.\n     fn atomic_compare_exchange_scalar(\n@@ -640,7 +633,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                     // Either Release | AcqRel | SeqCst\n                     clocks.apply_release_fence();\n                 }\n-                Ok(())\n+                \n+                // Increment timestamp if hase release semantics\n+                Ok(atomic != AtomicFenceOp::Acquire)\n             })\n         } else {\n             Ok(())\n@@ -651,9 +646,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n /// Vector clock metadata for a logical memory allocation.\n #[derive(Debug, Clone)]\n pub struct VClockAlloc {\n-    /// Range of Vector clocks, this gives each byte a potentially\n-    /// unqiue set of vector clocks, but merges identical information\n-    /// together for improved efficiency.\n+    /// Assigning each byte a MemoryCellClocks.\n     alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n \n     // Pointer to global state.\n@@ -935,10 +928,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                                 true,\n                                 place_ptr,\n                                 size,\n-                            );\n+                            ).map(|_| true);\n                         }\n                     }\n-                    Ok(())\n+\n+                    // This conservatively assumes all operations have release semantics\n+                    Ok(true)\n                 })?;\n \n                 // Log changes to atomic memory.\n@@ -1159,6 +1154,7 @@ impl GlobalState {\n         created.join_with(current);\n \n         // Advance both threads after the synchronized operation.\n+        // Both operations are considered to have release semantics.\n         current.increment_clock(current_index);\n         created.increment_clock(created_index);\n     }\n@@ -1185,11 +1181,9 @@ impl GlobalState {\n \n         // The join thread happens-before the current thread\n         // so update the current vector clock.\n+        // Is not a release operation so the clock is not incremented.\n         current.clock.join(join_clock);\n \n-        // Increment clocks after atomic operation.\n-        current.increment_clock(current_index);\n-\n         // Check the number of active threads, if the value is 1\n         // then test for potentially disabling multi-threaded execution.\n         let active_threads = self.active_thread_count.get();\n@@ -1287,13 +1281,14 @@ impl GlobalState {\n     /// operation may create.\n     fn maybe_perform_sync_operation<'tcx>(\n         &self,\n-        op: impl FnOnce(VectorIdx, RefMut<'_, ThreadClockSet>) -> InterpResult<'tcx>,\n+        op: impl FnOnce(VectorIdx, RefMut<'_, ThreadClockSet>) -> InterpResult<'tcx, bool>,\n     ) -> InterpResult<'tcx> {\n         if self.multi_threaded.get() {\n             let (index, clocks) = self.current_thread_state_mut();\n-            op(index, clocks)?;\n-            let (_, mut clocks) = self.current_thread_state_mut();\n-            clocks.increment_clock(index);\n+            if op(index, clocks)? {\n+                let (_, mut clocks) = self.current_thread_state_mut();\n+                clocks.increment_clock(index);\n+            }\n         }\n         Ok(())\n     }\n@@ -1313,10 +1308,11 @@ impl GlobalState {\n \n     /// Acquire a lock, express that the previous call of\n     /// `validate_lock_release` must happen before this.\n+    /// As this is an acquire operation, the thread timestamp is not\n+    /// incremented.\n     pub fn validate_lock_acquire(&self, lock: &VClock, thread: ThreadId) {\n-        let (index, mut clocks) = self.load_thread_state_mut(thread);\n+        let (_, mut clocks) = self.load_thread_state_mut(thread);\n         clocks.clock.join(&lock);\n-        clocks.increment_clock(index);\n     }\n \n     /// Release a lock handle, express that this happens-before\n@@ -1335,8 +1331,8 @@ impl GlobalState {\n     /// any subsequent calls to `validate_lock_acquire` as well\n     /// as any previous calls to this function after any\n     /// `validate_lock_release` calls.\n-    /// For normal locks this should be equivalent to `validate_lock_release`\n-    /// this function only exists for joining over the set of concurrent readers\n+    /// For normal locks this should be equivalent to `validate_lock_release`.\n+    /// This function only exists for joining over the set of concurrent readers\n     /// in a read-write lock and should not be used for anything else.\n     pub fn validate_lock_release_shared(&self, lock: &mut VClock, thread: ThreadId) {\n         let (index, mut clocks) = self.load_thread_state_mut(thread);"}, {"sha": "868c72289a1a0ce401cb21963cc5ae6771bec9f4", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c5722933e5233b4b64134680baae1f48e1e47ea/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5722933e5233b4b64134680baae1f48e1e47ea/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=6c5722933e5233b4b64134680baae1f48e1e47ea", "patch": "@@ -62,8 +62,6 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // mutex implementation, it may not need to be atomic.\n     ecx.read_scalar_at_offset_atomic(\n         mutex_op, offset, ecx.machine.layouts.i32,\n         AtomicReadOp::Relaxed\n@@ -76,8 +74,6 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     kind: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // mutex implementation, it may not need to be atomic.\n     ecx.write_scalar_at_offset_atomic(\n         mutex_op, offset, kind, ecx.machine.layouts.i32,\n         AtomicWriteOp::Relaxed\n@@ -88,8 +84,6 @@ fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // mutex implementation, it may not need to be atomic.\n     ecx.read_scalar_at_offset_atomic(\n         mutex_op, 4, ecx.machine.layouts.u32, \n         AtomicReadOp::Relaxed\n@@ -101,8 +95,6 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n     mutex_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // mutex implementation, it may not need to be atomic.\n     ecx.write_scalar_at_offset_atomic(\n         mutex_op, 4, id, ecx.machine.layouts.u32,\n         AtomicWriteOp::Relaxed\n@@ -135,8 +127,6 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: OpTy<'tcx, Tag>,\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // rw-lock implementation, it may not need to be atomic.\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     ecx.read_scalar_at_offset_atomic(\n         rwlock_op, 4, ecx.machine.layouts.u32,\n@@ -149,8 +139,6 @@ fn rwlock_set_id<'mir, 'tcx: 'mir>(\n     rwlock_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // rw-lock implementation, it may not need to be atomic.\n     ecx.write_scalar_at_offset_atomic(\n         rwlock_op, 4, id, ecx.machine.layouts.u32,\n         AtomicWriteOp::Relaxed\n@@ -207,8 +195,6 @@ fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // cond-var implementation, it may not need to be atomic.\n     ecx.read_scalar_at_offset_atomic(\n         cond_op, 4, ecx.machine.layouts.u32,\n         AtomicReadOp::Relaxed\n@@ -220,8 +206,6 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n     cond_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    //FIXME: this has been made atomic to fix data-race reporting inside the internal\n-    // cond-var implementation, it may not need to be atomic.\n     ecx.write_scalar_at_offset_atomic(\n         cond_op, 4, id, ecx.machine.layouts.u32,\n         AtomicWriteOp::Relaxed"}]}