{"sha": "50c0192c64241d723066add22c53d472e2b9cba9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYzAxOTJjNjQyNDFkNzIzMDY2YWRkMjJjNTNkNDcyZTJiOWNiYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-11T11:17:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-11T11:17:37Z"}, "message": "Auto merge of #73235 - Dylan-DPC:rollup-zp8oxhg, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #72380 (Fix `is_const_context`, update `check_for_cast`)\n - #72941 (Ensure stack when building MIR for matches)\n - #72976 (Clean up E0642 explanation)\n - #73080 (doc/rustdoc: Fix incorrect external_doc feature flag)\n - #73155 (save_analysis: better handle paths and functions signature)\n - #73164 (Add new E0762 error code)\n - #73172 (Fix more clippy warnings)\n - #73181 (Automatically prioritize unsoundness issues)\n - #73183 (Support proc macros in intra doc link resolution)\n - #73208 (Fix doctest template)\n - #73219 (x.py: with --json-output, forward cargo's JSON)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "06315ed68a5156efe6d78d5a39c7054172c07a05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06315ed68a5156efe6d78d5a39c7054172c07a05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50c0192c64241d723066add22c53d472e2b9cba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50c0192c64241d723066add22c53d472e2b9cba9", "html_url": "https://github.com/rust-lang/rust/commit/50c0192c64241d723066add22c53d472e2b9cba9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50c0192c64241d723066add22c53d472e2b9cba9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ddf48053e83f4949d00dcaf6eb8d9e28fc6bb95", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ddf48053e83f4949d00dcaf6eb8d9e28fc6bb95", "html_url": "https://github.com/rust-lang/rust/commit/3ddf48053e83f4949d00dcaf6eb8d9e28fc6bb95"}, {"sha": "ba0a8d2ee79e966d270690b7154bd3bfe2ba61aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba0a8d2ee79e966d270690b7154bd3bfe2ba61aa", "html_url": "https://github.com/rust-lang/rust/commit/ba0a8d2ee79e966d270690b7154bd3bfe2ba61aa"}], "stats": {"total": 6222, "additions": 5807, "deletions": 415}, "files": [{"sha": "c09b73b042013ca77f3105bda1528fe40cc71a37", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -983,7 +983,13 @@ pub fn stream_cargo(\n     for line in stdout.lines() {\n         let line = t!(line);\n         match serde_json::from_str::<CargoMessage<'_>>(&line) {\n-            Ok(msg) => cb(msg),\n+            Ok(msg) => {\n+                if builder.config.json_output {\n+                    // Forward JSON to stdout.\n+                    println!(\"{}\", line);\n+                }\n+                cb(msg)\n+            }\n             // If this was informational, just print it out and continue\n             Err(_) => println!(\"{}\", line),\n         }"}, {"sha": "18010bebcf0e773315655165328e48cd1be793d9", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -416,7 +416,7 @@ without including it in your main documentation. For example, you could write th\n `lib.rs` to test your README as part of your doctests:\n \n ```rust,ignore\n-#![feature(extern_doc)]\n+#![feature(external_doc)]\n \n #[doc(include=\"../README.md\")]\n #[cfg(doctest)]"}, {"sha": "fe131de66f152bb3174dff2f5a18292b74a37009", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -3309,7 +3309,8 @@ Basic usage:\n \n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n-assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\",\n+$EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "15ae12ebf10e3ac7a2d913f2410d360cae70ea71", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -392,7 +392,7 @@ impl TokenStream {\n                         break;\n                     }\n                 }\n-                token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n+                token_trees = out.into_iter().map(TokenTree::Token).collect();\n                 if token_trees.len() != 1 {\n                     debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n                 }"}, {"sha": "79d16a318d21be92b4ee55a2644529de8700c0ba", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -1237,10 +1237,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                             ) => {\n                                                 assert!(!*late);\n                                                 let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                                let msg = &format!(\n-                                                    \"use `lateout` instead of \\\n-                                                     `out` to avoid conflict\"\n-                                                );\n+                                                let msg = \"use `lateout` instead of \\\n+                                                     `out` to avoid conflict\";\n                                                 err.span_help(out_op_sp, msg);\n                                             }\n                                             _ => {}"}, {"sha": "6127fcc5a4bee17210d1ada8fa2c4b12169a7abd", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -457,7 +457,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n \n                 let mut chars = arg.format.ty.chars();\n                 let mut modifier = chars.next();\n-                if !chars.next().is_none() {\n+                if chars.next().is_some() {\n                     let span = arg\n                         .format\n                         .ty_span"}, {"sha": "11ec62f96ed38d60179f5c37c357ab74eee9f954", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     .tcx()\n                     .destructure_const(ty::ParamEnv::reveal_all().and(&c))\n                     .fields\n-                    .into_iter()\n+                    .iter()\n                     .map(|field| {\n                         if let Some(prim) = field.val.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);"}, {"sha": "285242647b38d5dd770998f52396758135e22a57", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -440,6 +440,7 @@ E0754: include_str!(\"./error_codes/E0754.md\"),\n E0758: include_str!(\"./error_codes/E0758.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n E0761: include_str!(\"./error_codes/E0761.md\"),\n+E0762: include_str!(\"./error_codes/E0762.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "c790aa154bde933247e1fed9d5df1a7809dd3794", "filename": "src/librustc_error_codes/error_codes/E0642.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0642.md", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0642.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0642.md?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -1,6 +1,6 @@\n Trait methods currently cannot take patterns as arguments.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0642\n trait Foo {"}, {"sha": "b01ded4a86616eba3664c40e47f6da2f2830a78d", "filename": "src/librustc_error_codes/error_codes/E0762.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0762.md", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0762.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0762.md?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -0,0 +1,13 @@\n+A character literal wasn't ended with a quote.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0762\n+static C: char = '\u25cf; // error!\n+```\n+\n+To fix this error, add the missing quote:\n+\n+```\n+static C: char = '\u25cf'; // ok!\n+```"}, {"sha": "265ba59cccb2aff70a7ce6449b179805909a3bad", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -159,14 +159,10 @@ impl AnnotateSnippetEmitterWriter {\n                             // FIXME(#59346): Not really sure when `fold` should be true or false\n                             fold: false,\n                             annotations: annotations\n-                                .into_iter()\n+                                .iter()\n                                 .map(|annotation| SourceAnnotation {\n                                     range: (annotation.start_col, annotation.end_col),\n-                                    label: annotation\n-                                        .label\n-                                        .as_ref()\n-                                        .map(|s| s.as_str())\n-                                        .unwrap_or_default(),\n+                                    label: annotation.label.as_deref().unwrap_or_default(),\n                                     annotation_type: annotation_type_for_level(*level),\n                                 })\n                                 .collect(),"}, {"sha": "da8956ccb4da483d08091253a6c9b222754b3f79", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -227,6 +227,28 @@ pub fn path_to_string(segment: &hir::Path<'_>) -> String {\n     to_string(NO_ANN, |s| s.print_path(segment, false))\n }\n \n+pub fn fn_to_string(\n+    decl: &hir::FnDecl<'_>,\n+    header: hir::FnHeader,\n+    name: Option<Symbol>,\n+    generics: &hir::Generics<'_>,\n+    vis: &hir::Visibility<'_>,\n+    arg_names: &[Ident],\n+    body_id: Option<hir::BodyId>,\n+) -> String {\n+    to_string(NO_ANN, |s| s.print_fn(decl, header, name, generics, vis, arg_names, body_id))\n+}\n+\n+pub fn enum_def_to_string(\n+    enum_definition: &hir::EnumDef<'_>,\n+    generics: &hir::Generics<'_>,\n+    name: Symbol,\n+    span: rustc_span::Span,\n+    visibility: &hir::Visibility<'_>,\n+) -> String {\n+    to_string(NO_ANN, |s| s.print_enum_def(enum_definition, generics, name, span, visibility))\n+}\n+\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) {\n         self.s.cbox(u);"}, {"sha": "81cb306d26444da71bb248e35fcf1ca88e53505a", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let error_code = error_code.into();\n         let mut err = self.tcx.sess.struct_span_err_with_code(\n             local_visitor.target_span,\n-            &format!(\"type annotations needed\"),\n+            \"type annotations needed\",\n             error_code,\n         );\n "}, {"sha": "45aee2b39654d197a5814be79114601d0ac76614", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -77,8 +77,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        let mut type_param_span: MultiSpan =\n-            visitor.types.iter().cloned().collect::<Vec<_>>().into();\n+        let mut type_param_span: MultiSpan = visitor.types.to_vec().into();\n         for &span in &visitor.types {\n             type_param_span.push_span_label(\n                 span,"}, {"sha": "200e7acf802353f98efdb6f4793085605bef043b", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -187,9 +187,9 @@ pub fn strip_shebang(input: &str) -> Option<usize> {\n             // Ok, this is a shebang but if the next non-whitespace token is `[` or maybe\n             // a doc comment (due to `TokenKind::(Line,Block)Comment` ambiguity at lexer level),\n             // then it may be valid Rust code, so consider it Rust code.\n-            let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).filter(|tok|\n+            let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).find(|tok|\n                 !matches!(tok, TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment { .. })\n-            ).next();\n+            );\n             if next_non_whitespace_token != Some(TokenKind::OpenBracket) {\n                 // No other choice than to consider this a shebang.\n                 return Some(2 + first_line_tail.len());"}, {"sha": "b1dafb3c885858dff5adfca40e4c63d65aebbdf4", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -335,6 +335,16 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    pub fn enclosing_body_owner(&self, hir_id: HirId) -> HirId {\n+        for (parent, _) in self.parent_iter(hir_id) {\n+            if let Some(body) = self.maybe_body_owned_by(parent) {\n+                return self.body_owner(body);\n+            }\n+        }\n+\n+        bug!(\"no `enclosing_body_owner` for hir_id `{}`\", hir_id);\n+    }\n+\n     /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n@@ -537,18 +547,8 @@ impl<'hir> Map<'hir> {\n \n     /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n     /// Used exclusively for diagnostics, to avoid suggestion function calls.\n-    pub fn is_const_context(&self, hir_id: HirId) -> bool {\n-        let parent_id = self.get_parent_item(hir_id);\n-        match self.get(parent_id) {\n-            Node::Item(&Item { kind: ItemKind::Const(..) | ItemKind::Static(..), .. })\n-            | Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. })\n-            | Node::ImplItem(&ImplItem { kind: ImplItemKind::Const(..), .. })\n-            | Node::AnonConst(_) => true,\n-            Node::Item(&Item { kind: ItemKind::Fn(ref sig, ..), .. }) => {\n-                sig.header.constness == Constness::Const\n-            }\n-            _ => false,\n-        }\n+    pub fn is_inside_const_context(&self, hir_id: HirId) -> bool {\n+        self.body_const_context(self.local_def_id(self.enclosing_body_owner(hir_id))).is_some()\n     }\n \n     /// Whether `hir_id` corresponds to a `mod` or a crate."}, {"sha": "4d4b6fb9386db306c018cbc87e544ff000447a2e", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let closure_id = hir.as_local_hir_id(self.mir_def_id);\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n-        let item_id = hir.get_parent_item(fn_call_id);\n+        let item_id = hir.enclosing_body_owner(fn_call_id);\n         let mut look_at_return = true;\n         // If we can detect the expression to be an `fn` call where the closure was an argument,\n         // we point at the `fn` definition argument..."}, {"sha": "2c0a40b4c543c8e146b94b422827a66667a081e1", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -309,9 +309,7 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n-        .and_then(|place| {\n-            Ok(RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n-        })\n+        .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n             let err = error_to_const_error(&ecx, error);\n             // errors in statics are always emitted as fatal errors"}, {"sha": "043b2d0d1703e260977a00f8627cfee836021342", "filename": "src/librustc_mir/transform/check_packed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Ftransform%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Ftransform%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_packed_ref.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n                     lint_root,\n                     source_info.span,\n                     |lint| {\n-                        lint.build(&format!(\"reference to packed field is unaligned\",))\n+                        lint.build(\"reference to packed field is unaligned\")\n                             .note(\n                                 \"fields of packed structs are not properly aligned, and creating \\\n                                 a misaligned reference is undefined behavior (even if that \\"}, {"sha": "1f3d7bb7cc6f41c2ab16dcf425667893c323462f", "filename": "src/librustc_mir/transform/nrvo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -111,7 +111,7 @@ fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n         copied_to_return_place = Some(returned_local);\n     }\n \n-    return copied_to_return_place;\n+    copied_to_return_place\n }\n \n fn find_local_assigned_to_return_place(\n@@ -136,7 +136,7 @@ fn find_local_assigned_to_return_place(\n         }\n     }\n \n-    return None;\n+    None\n }\n \n // If this statement is an assignment of an unprojected local to the return place,"}, {"sha": "61f9c281559b70f8cdbb034fa991c5c7cd33e02c", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -99,7 +99,7 @@ fn get_arm_identity_info<'a, 'tcx>(stmts: &'a [Statement<'tcx>]) -> Option<ArmId\n     fn try_eat<'a, 'tcx>(\n         stmt_iter: &mut StmtIter<'a, 'tcx>,\n         test: impl Fn(&'a Statement<'tcx>) -> bool,\n-        mut action: impl FnMut(usize, &'a Statement<'tcx>) -> (),\n+        mut action: impl FnMut(usize, &'a Statement<'tcx>),\n     ) {\n         while stmt_iter.peek().map(|(_, stmt)| test(stmt)).unwrap_or(false) {\n             let (idx, stmt) = stmt_iter.next().unwrap();\n@@ -271,7 +271,7 @@ fn optimization_applies<'tcx>(\n     }\n \n     // Verify the assigment chain consists of the form b = a; c = b; d = c; etc...\n-    if opt_info.field_tmp_assignments.len() == 0 {\n+    if opt_info.field_tmp_assignments.is_empty() {\n         trace!(\"NO: no assignments found\");\n     }\n     let mut last_assigned_to = opt_info.field_tmp_assignments[0].1;"}, {"sha": "19948196f256fdf6c31e118fa06b9c1f8bf2bc74", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -10,7 +10,7 @@ use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::{fx::{FxHashMap, FxHashSet}, stack::ensure_sufficient_stack};\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::middle::region;\n@@ -909,30 +909,32 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             split_or_candidate |= self.simplify_candidate(candidate);\n         }\n \n-        if split_or_candidate {\n-            // At least one of the candidates has been split into subcandidates.\n-            // We need to change the candidate list to include those.\n-            let mut new_candidates = Vec::new();\n+        ensure_sufficient_stack(|| {\n+            if split_or_candidate {\n+                // At least one of the candidates has been split into subcandidates.\n+                // We need to change the candidate list to include those.\n+                let mut new_candidates = Vec::new();\n \n-            for candidate in candidates {\n-                candidate.visit_leaves(|leaf_candidate| new_candidates.push(leaf_candidate));\n+                for candidate in candidates {\n+                    candidate.visit_leaves(|leaf_candidate| new_candidates.push(leaf_candidate));\n+                }\n+                self.match_simplified_candidates(\n+                    span,\n+                    start_block,\n+                    otherwise_block,\n+                    &mut *new_candidates,\n+                    fake_borrows,\n+                );\n+            } else {\n+                self.match_simplified_candidates(\n+                    span,\n+                    start_block,\n+                    otherwise_block,\n+                    candidates,\n+                    fake_borrows,\n+                );\n             }\n-            self.match_simplified_candidates(\n-                span,\n-                start_block,\n-                otherwise_block,\n-                &mut *new_candidates,\n-                fake_borrows,\n-            );\n-        } else {\n-            self.match_simplified_candidates(\n-                span,\n-                start_block,\n-                otherwise_block,\n-                candidates,\n-                fake_borrows,\n-            );\n-        };\n+        });\n     }\n \n     fn match_simplified_candidates("}, {"sha": "84b3335a0f628d7f865ed736c60de8ca06814369", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -325,7 +325,15 @@ impl<'a> StringReader<'a> {\n         let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n-                    self.fatal_span_(start, suffix_start, \"unterminated character literal\").raise()\n+                    self.sess\n+                        .span_diagnostic\n+                        .struct_span_fatal_with_code(\n+                            self.mk_sp(start, suffix_start),\n+                            \"unterminated character literal\",\n+                            error_code!(E0762),\n+                        )\n+                        .emit();\n+                    FatalError.raise();\n                 }\n                 (token::Char, Mode::Char, 1, 1) // ' '\n             }\n@@ -401,7 +409,7 @@ impl<'a> StringReader<'a> {\n         let content_end = suffix_start - BytePos(postfix_len);\n         let id = self.symbol_from_to(content_start, content_end);\n         self.validate_literal_escape(mode, content_start, content_end);\n-        return (lit_kind, id);\n+        (lit_kind, id)\n     }\n \n     pub fn pos(&self) -> BytePos {"}, {"sha": "8792605c08d38a4092f15fdffe5c258f282af0b6", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -936,7 +936,7 @@ impl<'a> Parser<'a> {\n         } else if !sm.is_multiline(self.prev_token.span.until(self.token.span)) {\n             // The current token is in the same line as the prior token, not recoverable.\n         } else if [token::Comma, token::Colon].contains(&self.token.kind)\n-            && &self.prev_token.kind == &token::CloseDelim(token::Paren)\n+            && self.prev_token.kind == token::CloseDelim(token::Paren)\n         {\n             // Likely typo: The current token is on a new line and is expected to be\n             // `.`, `;`, `?`, or an operator after a close delimiter token."}, {"sha": "47ae92c48bd88dce1277adb8d348326d69646aba", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -193,7 +193,7 @@ impl TokenCursor {\n                         tree,\n                         self.stack.len()\n                     );\n-                    collecting.buf.push(tree.clone().into())\n+                    collecting.buf.push(tree.clone())\n                 }\n             }\n \n@@ -675,7 +675,7 @@ impl<'a> Parser<'a> {\n                             // If this was a missing `@` in a binding pattern\n                             // bail with a suggestion\n                             // https://github.com/rust-lang/rust/issues/72373\n-                            if self.prev_token.is_ident() && &self.token.kind == &token::DotDot {\n+                            if self.prev_token.is_ident() && self.token.kind == token::DotDot {\n                                 let msg = format!(\n                                     \"if you meant to bind the contents of \\\n                                     the rest of the array pattern into `{}`, use `@`\",\n@@ -1193,7 +1193,7 @@ impl<'a> Parser<'a> {\n         let mut collected_tokens = if let Some(collecting) = self.token_cursor.collecting.take() {\n             collecting.buf\n         } else {\n-            let msg = format!(\"our vector went away?\");\n+            let msg = \"our vector went away?\";\n             debug!(\"collect_tokens: {}\", msg);\n             self.sess.span_diagnostic.delay_span_bug(self.token.span, &msg);\n             // This can happen due to a bad interaction of two unrelated recovery mechanisms"}, {"sha": "e2bfcf18edb1731fe219a58b2d22bac0f7c12f48", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -232,7 +232,7 @@ impl ExprVisitor<'tcx> {\n         // size).\n         if let Some((in_expr, Some(in_asm_ty))) = tied_input {\n             if in_asm_ty != asm_ty {\n-                let msg = &format!(\"incompatible types for asm inout argument\");\n+                let msg = \"incompatible types for asm inout argument\";\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n                 err.span_label(\n                     in_expr.span,"}, {"sha": "fbde6bfd9aae61f7df61ef26c268ec76e7fd56c4", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -20,7 +20,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir_pretty::{bounds_to_string, generic_params_to_string, ty_to_string};\n+use rustc_hir_pretty::{bounds_to_string, fn_to_string, generic_params_to_string, ty_to_string};\n use rustc_middle::hir::map::Map;\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n@@ -199,23 +199,23 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.dumper.compilation_opts(data);\n     }\n \n-    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n-        for seg in path.segments {\n+    fn write_segments(&mut self, segments: impl IntoIterator<Item = &'tcx hir::PathSegment<'tcx>>) {\n+        for seg in segments {\n             if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n                 self.dumper.dump_ref(data);\n             }\n         }\n     }\n \n+    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n+        self.write_segments(path.segments)\n+    }\n+\n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n     fn write_sub_paths_truncated(&mut self, path: &'tcx hir::Path<'tcx>) {\n         if let [segments @ .., _] = path.segments {\n-            for seg in segments {\n-                if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n-                    self.dumper.dump_ref(data);\n-                }\n-            }\n+            self.write_segments(segments)\n         }\n     }\n \n@@ -276,7 +276,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 }\n                 v.process_generic_params(&generics, &method_data.qualname, hir_id);\n \n-                method_data.value = crate::make_signature(&sig.decl, &generics);\n+                method_data.value =\n+                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, vis, &[], None);\n                 method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n \n                 v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, hir_id), method_data);\n@@ -643,7 +644,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.nest_tables(map.local_def_id(item.hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n-                v.process_path(trait_ref.hir_ref_id, &trait_ref.path);\n+                v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n             }\n             v.process_generic_params(generics, \"\", item.hir_id);\n             for impl_item in impl_items {\n@@ -746,7 +747,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::Path<'tcx>) {\n+    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n         let path_data = self.save_ctxt.get_path_data(id, path);\n         if let Some(path_data) = path_data {\n             self.dumper.dump_ref(path_data);\n@@ -760,14 +761,30 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_path(&mut self, id: hir::HirId, path: &'tcx hir::Path<'tcx>) {\n-        if self.span.filter_generated(path.span) {\n+    fn process_path(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n+        let span = match path {\n+            hir::QPath::Resolved(_, path) => path.span,\n+            hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+        };\n+        if self.span.filter_generated(span) {\n             return;\n         }\n         self.dump_path_ref(id, path);\n \n         // Type arguments\n-        for seg in path.segments {\n+        let segments = match path {\n+            hir::QPath::Resolved(ty, path) => {\n+                if let Some(ty) = ty {\n+                    self.visit_ty(ty);\n+                }\n+                path.segments\n+            }\n+            hir::QPath::TypeRelative(ty, segment) => {\n+                self.visit_ty(ty);\n+                std::slice::from_ref(*segment)\n+            }\n+        };\n+        for seg in segments {\n             if let Some(ref generic_args) = seg.args {\n                 for arg in generic_args.args {\n                     if let hir::GenericArg::Type(ref ty) = arg {\n@@ -777,7 +794,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n         }\n \n-        self.write_sub_paths_truncated(path);\n+        if let hir::QPath::Resolved(_, path) = path {\n+            self.write_sub_paths_truncated(path);\n+        }\n     }\n \n     fn process_struct_lit(\n@@ -931,9 +950,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         for (id, ref path) in collector.collected_paths {\n-            if let hir::QPath::Resolved(_, path) = path {\n-                self.process_path(id, path);\n-            }\n+            self.process_path(id, path);\n         }\n     }\n \n@@ -1135,7 +1152,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_bounds(&mut self, bounds: hir::GenericBounds<'tcx>) {\n         for bound in bounds {\n             if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n-                self.process_path(trait_ref.trait_ref.hir_ref_id, &trait_ref.trait_ref.path)\n+                self.process_path(\n+                    trait_ref.trait_ref.hir_ref_id,\n+                    &hir::QPath::Resolved(None, &trait_ref.trait_ref.path),\n+                )\n             }\n         }\n     }\n@@ -1330,13 +1350,16 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         self.process_macro_use(t.span);\n         match t.kind {\n-            hir::TyKind::Path(hir::QPath::Resolved(_, path)) => {\n+            hir::TyKind::Path(ref path) => {\n                 if generated_code(t.span) {\n                     return;\n                 }\n \n                 if let Some(id) = self.lookup_def_id(t.hir_id) {\n-                    let sub_span = path.segments.last().unwrap().ident.span;\n+                    let sub_span = match path {\n+                        hir::QPath::Resolved(_, path) => path.segments.last().unwrap().ident.span,\n+                        hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+                    };\n                     let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n                         kind: RefKind::Type,\n@@ -1345,8 +1368,10 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                     });\n                 }\n \n-                self.write_sub_paths_truncated(path);\n-                intravisit::walk_path(self, path);\n+                if let hir::QPath::Resolved(_, path) = path {\n+                    self.write_sub_paths_truncated(path);\n+                }\n+                intravisit::walk_qpath(self, path, t.hir_id, t.span);\n             }\n             hir::TyKind::Array(ref ty, ref anon_const) => {\n                 self.visit_ty(ty);\n@@ -1355,6 +1380,10 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                     v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }\n+            hir::TyKind::Def(item_id, _) => {\n+                let item = self.tcx.hir().item(item_id.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(item_id.id), |v| v.visit_item(item));\n+            }\n             _ => intravisit::walk_ty(self, t),\n         }\n     }\n@@ -1432,8 +1461,8 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n         self.visit_expr(&arm.body);\n     }\n \n-    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n-        self.process_path(id, p);\n+    fn visit_qpath(&mut self, path: &'tcx hir::QPath<'tcx>, id: hir::HirId, _: Span) {\n+        self.process_path(id, path);\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {"}, {"sha": "8a456c903ecdfef473b0a50355ebbc088f346598", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -13,11 +13,11 @@ use rustc_ast::ast::{self};\n use rustc_ast::util::comments::strip_doc_comment_decoration;\n use rustc_ast_pretty::pprust::attribute_to_string;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorOf, DefKind as HirDefKind, Res};\n+use rustc_hir::def::{DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n-use rustc_hir_pretty::ty_to_string;\n+use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::ExternCrate;\n use rustc_middle::middle::privacy::AccessLevels;\n@@ -135,7 +135,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(ref decl, arg_names, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n@@ -144,7 +144,23 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(decl, generics),\n+                    value: fn_to_string(\n+                        decl,\n+                        hir::FnHeader {\n+                            // functions in extern block are implicitly unsafe\n+                            unsafety: hir::Unsafety::Unsafe,\n+                            // functions in extern block cannot be const\n+                            constness: hir::Constness::NotConst,\n+                            abi: self.tcx.hir().get_foreign_abi(item.hir_id),\n+                            // functions in extern block cannot be async\n+                            asyncness: hir::IsAsync::NotAsync,\n+                        },\n+                        Some(item.ident.name),\n+                        generics,\n+                        &item.vis,\n+                        arg_names,\n+                        None,\n+                    ),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n@@ -191,7 +207,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(&sig.decl, generics),\n+                    value: fn_to_string(\n+                        sig.decl,\n+                        sig.header,\n+                        Some(item.ident.name),\n+                        generics,\n+                        &item.vis,\n+                        &[],\n+                        None,\n+                    ),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n@@ -268,13 +292,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            hir::ItemKind::Enum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, ref generics) => {\n                 let name = item.ident.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n-                let variants_str =\n-                    def.variants.iter().map(|v| v.ident.to_string()).collect::<Vec<_>>().join(\", \");\n-                let value = format!(\"{}::{{{}}}\", name, variants_str);\n+                let value =\n+                    enum_def_to_string(def, generics, item.ident.name, item.span, &item.vis);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n                     id: id_from_def_id(def_id),\n@@ -579,7 +602,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(null_id),\n                 }))\n             }\n-            hir::ExprKind::Path(hir::QPath::Resolved(_, path)) => {\n+            hir::ExprKind::Path(ref path) => {\n                 self.get_path_data(expr.hir_id, path).map(Data::RefData)\n             }\n             _ => {\n@@ -631,8 +654,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: hir::HirId, path: &hir::Path<'_>) -> Option<Ref> {\n-        path.segments.last().and_then(|seg| {\n+    pub fn get_path_data(&self, id: hir::HirId, path: &hir::QPath<'_>) -> Option<Ref> {\n+        let segment = match path {\n+            hir::QPath::Resolved(_, path) => path.segments.last(),\n+            hir::QPath::TypeRelative(_, segment) => Some(*segment),\n+        };\n+        segment.and_then(|seg| {\n             self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))\n         })\n     }\n@@ -681,20 +708,16 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Def(HirDefKind::ConstParam, def_id) => {\n                 Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(def_id) })\n             }\n-            Res::Def(HirDefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                // This is a reference to a tuple struct where the def_id points\n+            Res::Def(HirDefKind::Ctor(_, ..), def_id) => {\n+                // This is a reference to a tuple struct or an enum variant where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n-                // def, so adjust to point to the tuple struct itself.\n+                // def, so adjust to point to the tuple struct or enum variant itself.\n                 let parent_def_id = self.tcx.parent(def_id).unwrap();\n                 Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(parent_def_id) })\n             }\n-            Res::Def(\n-                HirDefKind::Static\n-                | HirDefKind::Const\n-                | HirDefKind::AssocConst\n-                | HirDefKind::Ctor(..),\n-                _,\n-            ) => Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) }),\n+            Res::Def(HirDefKind::Static | HirDefKind::Const | HirDefKind::AssocConst, _) => {\n+                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) })\n+            }\n             Res::Def(HirDefKind::AssocFn, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n@@ -844,31 +867,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n }\n \n-fn make_signature(decl: &hir::FnDecl<'_>, generics: &hir::Generics<'_>) -> String {\n-    let mut sig = \"fn \".to_owned();\n-    if !generics.params.is_empty() {\n-        sig.push('<');\n-        sig.push_str(\n-            &generics\n-                .params\n-                .iter()\n-                .map(|param| param.name.ident().to_string())\n-                .collect::<Vec<_>>()\n-                .join(\", \"),\n-        );\n-        sig.push_str(\"> \");\n-    }\n-    sig.push('(');\n-    sig.push_str(&decl.inputs.iter().map(ty_to_string).collect::<Vec<_>>().join(\", \"));\n-    sig.push(')');\n-    match decl.output {\n-        hir::FnRetTy::DefaultReturn(_) => sig.push_str(\" -> ()\"),\n-        hir::FnRetTy::Return(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n-    }\n-\n-    sig\n-}\n-\n // An AST visitor for collecting paths (e.g., the names of structs) and formal\n // variables (idents) from patterns.\n struct PathCollector<'l> {"}, {"sha": "5f337f5f77033ab064d9919dfc4ef16126f41f6b", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -281,6 +281,22 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                     })\n                 }\n             }\n+            hir::TyKind::Path(hir::QPath::TypeRelative(ty, segment)) => {\n+                let nested_ty = ty.make(offset + 1, id, scx)?;\n+                let prefix = format!(\"<{}>::\", nested_ty.text,);\n+\n+                let name = path_segment_to_string(segment);\n+                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n+                let id = id_from_def_id(res.def_id());\n+\n+                let start = offset + prefix.len();\n+                let end = start + name.len();\n+                Ok(Signature {\n+                    text: prefix + &name,\n+                    defs: vec![],\n+                    refs: vec![SigElement { id, start, end }],\n+                })\n+            }\n             hir::TyKind::TraitObject(bounds, ..) => {\n                 // FIXME recurse into bounds\n                 let bounds: Vec<hir::GenericBound<'_>> = bounds\n@@ -308,11 +324,11 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n                 Ok(replace_text(nested_ty, text))\n             }\n-            hir::TyKind::Typeof(_)\n-            | hir::TyKind::Infer\n-            | hir::TyKind::Def(..)\n-            | hir::TyKind::Path(..)\n-            | hir::TyKind::Err => Err(\"Ty\"),\n+            hir::TyKind::Def(item_id, _) => {\n+                let item = scx.tcx.hir().item(item_id.id);\n+                item.make(offset, Some(item_id.id), scx)\n+            }\n+            hir::TyKind::Typeof(_) | hir::TyKind::Infer | hir::TyKind::Err => Err(\"Ty\"),\n         }\n     }\n }"}, {"sha": "7ac886989853f3e84c12e3818d2ba9c6fb3a5b24", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 189, "deletions": 207, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -15,6 +15,8 @@ use rustc_span::Span;\n \n use super::method::probe;\n \n+use std::fmt;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n@@ -670,16 +672,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n-            // Shouldn't suggest `.into()` on `const`s.\n-            // FIXME(estebank): modify once we decide to suggest `as` casts\n-            return false;\n-        }\n         if self.tcx.sess.source_map().is_imported(expr.span) {\n             // Ignore if span is from within a macro.\n             return false;\n         }\n \n+        let src = if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+            src\n+        } else {\n+            return false;\n+        };\n+\n         // If casting this expression to a given numeric type would be appropriate in case of a type\n         // mismatch.\n         //\n@@ -708,6 +711,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             String::new()\n         };\n+\n         if let hir::ExprKind::Call(path, args) = &expr.kind {\n             if let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n                 (&path.kind, args.len())\n@@ -749,222 +753,200 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             checked_ty, expected_ty,\n         );\n \n-        let needs_paren = expr.precedence().order() < (PREC_POSTFIX as i8);\n-\n-        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n-            let cast_suggestion = format!(\n-                \"{}{}{}{} as {}\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-                expected_ty,\n-            );\n-            let try_into_suggestion = format!(\n-                \"{}{}{}{}.try_into().unwrap()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let into_suggestion = format!(\n-                \"{}{}{}{}.into()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let suffix_suggestion = format!(\n-                \"{}{}{}{}\",\n-                if needs_paren { \"(\" } else { \"\" },\n-                if let (ty::Int(_) | ty::Uint(_), ty::Float(_)) =\n-                    (&expected_ty.kind, &checked_ty.kind,)\n-                {\n-                    // Remove fractional part from literal, for example `42.0f32` into `42`\n-                    let src = src.trim_end_matches(&checked_ty.to_string());\n-                    src.split('.').next().unwrap()\n+        let with_opt_paren: fn(&dyn fmt::Display) -> String =\n+            if expr.precedence().order() < PREC_POSTFIX {\n+                |s| format!(\"({})\", s)\n+            } else {\n+                |s| s.to_string()\n+            };\n+\n+        let cast_suggestion = format!(\"{}{} as {}\", prefix, with_opt_paren(&src), expected_ty);\n+        let try_into_suggestion = format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n+        let into_suggestion = format!(\"{}{}.into()\", prefix, with_opt_paren(&src));\n+        let suffix_suggestion = with_opt_paren(&format_args!(\n+            \"{}{}\",\n+            if matches!(\n+                (&expected_ty.kind, &checked_ty.kind),\n+                (ty::Int(_) | ty::Uint(_), ty::Float(_))\n+            ) {\n+                // Remove fractional part from literal, for example `42.0f32` into `42`\n+                let src = src.trim_end_matches(&checked_ty.to_string());\n+                src.split('.').next().unwrap()\n+            } else {\n+                src.trim_end_matches(&checked_ty.to_string())\n+            },\n+            expected_ty,\n+        ));\n+        let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n+            if let hir::ExprKind::Lit(lit) = &expr.kind { lit.node.is_suffixed() } else { false }\n+        };\n+\n+        let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n+        let suggest_to_change_suffix_or_into =\n+            |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+                let msg = if literal_is_ty_suffixed(expr) {\n+                    &lit_msg\n+                } else if in_const_context {\n+                    // Do not recommend `into` or `try_into` in const contexts.\n+                    return;\n+                } else if is_fallible {\n+                    &try_msg\n                 } else {\n-                    src.trim_end_matches(&checked_ty.to_string())\n-                },\n-                expected_ty,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n-                if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                    lit.node.is_suffixed()\n+                    &msg\n+                };\n+                let suggestion = if literal_is_ty_suffixed(expr) {\n+                    suffix_suggestion.clone()\n+                } else if is_fallible {\n+                    try_into_suggestion\n                 } else {\n-                    false\n-                }\n+                    into_suggestion.clone()\n+                };\n+                err.span_suggestion(expr.span, msg, suggestion, Applicability::MachineApplicable);\n             };\n \n-            let suggest_to_change_suffix_or_into =\n-                |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+        match (&expected_ty.kind, &checked_ty.kind) {\n+            (&ty::Int(ref exp), &ty::Int(ref found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if exp < found => true,\n+                    (None, Some(8 | 16)) => false,\n+                    (None, _) | (_, None) => true,\n+                    _ => false,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if exp < found => true,\n+                    (None, Some(8 | 16)) => false,\n+                    (None, _) | (_, None) => true,\n+                    _ => false,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Int(exp), &ty::Uint(found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if found < exp => false,\n+                    (None, Some(8)) => false,\n+                    _ => true,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Uint(_), &ty::Int(_)) => {\n+                suggest_to_change_suffix_or_into(err, true);\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Float(ref found)) => {\n+                if found.bit_width() < exp.bit_width() {\n+                    suggest_to_change_suffix_or_into(err, false);\n+                } else if literal_is_ty_suffixed(expr) {\n                     err.span_suggestion(\n                         expr.span,\n-                        if literal_is_ty_suffixed(expr) {\n-                            &lit_msg\n-                        } else if is_fallible {\n-                            &try_msg\n-                        } else {\n-                            &msg\n-                        },\n-                        if literal_is_ty_suffixed(expr) {\n-                            suffix_suggestion.clone()\n-                        } else if is_fallible {\n-                            try_into_suggestion\n-                        } else {\n-                            into_suggestion.clone()\n-                        },\n+                        &lit_msg,\n+                        suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n-                };\n-\n-            match (&expected_ty.kind, &checked_ty.kind) {\n-                (&ty::Int(ref exp), &ty::Int(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Int(exp), &ty::Uint(found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if found < exp => false,\n-                        (None, Some(8)) => false,\n-                        _ => true,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(_), &ty::Int(_)) => {\n-                    suggest_to_change_suffix_or_into(err, true);\n-                    true\n-                }\n-                (&ty::Float(ref exp), &ty::Float(ref found)) => {\n-                    if found.bit_width() < exp.bit_width() {\n-                        suggest_to_change_suffix_or_into(err, false);\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `f64` to `f32`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, producing the closest possible value\", cast_msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                } else if can_cast {\n+                    // Missing try_into implementation for `f64` to `f32`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, producing the closest possible value\", cast_msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n-                    if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `{float}` to `{integer}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, rounding the float towards zero\", msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n+                if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if can_cast {\n+                    // Missing try_into implementation for `{float}` to `{integer}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, rounding the float towards zero\", msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n-                    // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer,\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n+                // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer,\n                                  rounded if necessary\",\n-                                cast_msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                            cast_msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Int(ref found)) => {\n-                    // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                &msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer, \\\n-                                 rounded if necessary\",\n-                                &msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Int(ref found)) => {\n+                // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            &msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer, \\\n+                                rounded if necessary\",\n+                            &msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                _ => false,\n+                true\n             }\n-        } else {\n-            false\n+            _ => false,\n         }\n     }\n }"}, {"sha": "18846813c458fcf2deb97cc9f9c50f6e444e9b75", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -5091,7 +5091,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n             return;\n         }\n@@ -5128,7 +5128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         // Handle #68197.\n \n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n             return false;\n         }"}, {"sha": "f0900c34a4ba3dbcab473d92f4a3c8e25b85e986", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -126,7 +126,7 @@ impl<'a> SourceCollector<'a> {\n             &self.scx.themes,\n         );\n         self.scx.fs.write(&cur, v.as_bytes())?;\n-        self.scx.local_sources.insert(p.clone(), href);\n+        self.scx.local_sources.insert(p, href);\n         Ok(())\n     }\n }"}, {"sha": "f5b2f1bb5b17844a6f89e1fd700b129deddd26af", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint;\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -122,6 +123,42 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    /// Resolves a string as a macro.\n+    fn macro_resolve(&self, path_str: &str, parent_id: Option<hir::HirId>) -> Option<Res> {\n+        let cx = self.cx;\n+        let path = ast::Path::from_ident(Ident::from_str(path_str));\n+        cx.enter_resolver(|resolver| {\n+            if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n+                &path,\n+                None,\n+                &ParentScope::module(resolver.graph_root()),\n+                false,\n+                false,\n+            ) {\n+                if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n+                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                }\n+            }\n+            if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+            }\n+            if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n+                let module_id = cx.tcx.hir().local_def_id(module_id);\n+                if let Ok((_, res)) =\n+                    resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n+                {\n+                    // don't resolve builtins like `#[derive]`\n+                    if let Res::Def(..) = res {\n+                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                        return Some(res);\n+                    }\n+                }\n+            } else {\n+                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+            }\n+            None\n+        })\n+    }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve(\n@@ -371,6 +408,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n }\n \n+/// Check for resolve collisions between a trait and its derive\n+///\n+/// These are common and we should just resolve to the trait in that case\n+fn is_derive_trait_collision<T>(ns: &PerNS<Option<(Res, T)>>) -> bool {\n+    if let PerNS {\n+        type_ns: Some((Res::Def(DefKind::Trait, _), _)),\n+        macro_ns: Some((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n+        ..\n+    } = *ns\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_hir_id = if item.is_mod() {\n@@ -451,7 +504,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             ..\n                         },\n                     ..\n-                })) => segments.first().and_then(|seg| Some(seg.ident.to_string())),\n+                })) => segments.first().map(|seg| seg.ident.to_string()),\n                 Some(hir::Node::Item(hir::Item {\n                     ident, kind: hir::ItemKind::Enum(..), ..\n                 }))\n@@ -532,6 +585,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 } else if link.starts_with(\"macro@\") {\n                     kind = Some(MacroNS);\n                     link.trim_start_matches(\"macro@\")\n+                } else if link.starts_with(\"derive@\") {\n+                    kind = Some(MacroNS);\n+                    link.trim_start_matches(\"derive@\")\n                 } else if link.ends_with('!') {\n                     kind = Some(MacroNS);\n                     link.trim_end_matches('!')\n@@ -614,8 +670,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                     None => {\n                         // Try everything!\n-                        let candidates = PerNS {\n-                            macro_ns: macro_resolve(cx, path_str)\n+                        let mut candidates = PerNS {\n+                            macro_ns: self\n+                                .macro_resolve(path_str, base_node)\n                                 .map(|res| (res, extra_fragment.clone())),\n                             type_ns: match self.resolve(\n                                 path_str,\n@@ -668,10 +725,16 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             continue;\n                         }\n \n-                        let is_unambiguous = candidates.clone().present_items().count() == 1;\n-                        if is_unambiguous {\n+                        let len = candidates.clone().present_items().count();\n+\n+                        if len == 1 {\n                             candidates.present_items().next().unwrap()\n+                        } else if len == 2 && is_derive_trait_collision(&candidates) {\n+                            candidates.type_ns.unwrap()\n                         } else {\n+                            if is_derive_trait_collision(&candidates) {\n+                                candidates.macro_ns = None;\n+                            }\n                             ambiguity_error(\n                                 cx,\n                                 &item,\n@@ -684,7 +747,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(MacroNS) => {\n-                        if let Some(res) = macro_resolve(cx, path_str) {\n+                        if let Some(res) = self.macro_resolve(path_str, base_node) {\n                             (res, extra_fragment)\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -727,28 +790,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n-/// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    let path = ast::Path::from_ident(Ident::from_str(path_str));\n-    cx.enter_resolver(|resolver| {\n-        if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path,\n-            None,\n-            &ParentScope::module(resolver.graph_root()),\n-            false,\n-            false,\n-        ) {\n-            if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-            }\n-        }\n-        if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-            return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-        }\n-        None\n-    })\n-}\n-\n fn build_diagnostic(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -916,7 +957,7 @@ fn ambiguity_error(\n                             Res::Def(DefKind::AssocFn | DefKind::Fn, _) => {\n                                 (\"add parentheses\", format!(\"{}()\", path_str))\n                             }\n-                            Res::Def(DefKind::Macro(..), _) => {\n+                            Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n                                 (\"add an exclamation mark\", format!(\"{}!\", path_str))\n                             }\n                             _ => {\n@@ -930,6 +971,9 @@ fn ambiguity_error(\n                                     (Res::Def(DefKind::Mod, _), _) => \"module\",\n                                     (_, TypeNS) => \"type\",\n                                     (_, ValueNS) => \"value\",\n+                                    (Res::Def(DefKind::Macro(MacroKind::Derive), _), MacroNS) => {\n+                                        \"derive\"\n+                                    }\n                                     (_, MacroNS) => \"macro\",\n                                 };\n "}, {"sha": "04a431d99026e8f7c4478af244d3042042450c0e", "filename": "src/test/rustdoc/auxiliary/intra-link-proc-macro-macro.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-proc-macro-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-proc-macro-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-proc-macro-macro.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -0,0 +1,35 @@\n+// force-host\n+// no-prefer-dynamic\n+// compile-flags: --crate-type proc-macro\n+\n+#![crate_type=\"proc-macro\"]\n+#![crate_name=\"intra_link_proc_macro_macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(DeriveA)]\n+pub fn a_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(DeriveB)]\n+pub fn b_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(DeriveTrait)]\n+pub fn trait_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn attr_a(input: TokenStream, _args: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn attr_b(input: TokenStream, _args: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "7b6ea5d60f8530d0045f3904be1b296205c9624b", "filename": "src/test/rustdoc/intra-link-proc-macro.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Frustdoc%2Fintra-link-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Frustdoc%2Fintra-link-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-proc-macro.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -0,0 +1,27 @@\n+// aux-build:intra-link-proc-macro-macro.rs\n+// build-aux-docs\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+extern crate intra_link_proc_macro_macro;\n+\n+\n+pub use intra_link_proc_macro_macro::{DeriveA, attr_a};\n+use intra_link_proc_macro_macro::{DeriveB, attr_b};\n+\n+// @has intra_link_proc_macro/struct.Foo.html\n+// @has - '//a/@href' '../intra_link_proc_macro/derive.DeriveA.html'\n+// @has - '//a/@href' '../intra_link_proc_macro/attr.attr_a.html'\n+// @has - '//a/@href' '../intra_link_proc_macro/trait.DeriveTrait.html'\n+// @has - '//a/@href' '../intra_link_proc_macro_macro/derive.DeriveB.html'\n+// @has - '//a/@href' '../intra_link_proc_macro_macro/attr.attr_b.html'\n+/// Link to [DeriveA], [attr_a], [DeriveB], [attr_b], [DeriveTrait]\n+pub struct Foo;\n+\n+// @has intra_link_proc_macro/struct.Bar.html\n+// @has - '//a/@href' '../intra_link_proc_macro/derive.DeriveA.html'\n+// @has - '//a/@href' '../intra_link_proc_macro/attr.attr_a.html'\n+/// Link to [deriveA](derive@DeriveA) [attr](macro@attr_a)\n+pub struct Bar;\n+\n+// this should not cause ambiguity errors\n+pub trait DeriveTrait {}"}, {"sha": "9834a99b79a0e019527cbe34c9aab39a3abeb477", "filename": "src/test/ui/consts/enum-discr-type-err.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -11,10 +11,6 @@ LL | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n-   |\n-LL |             $( $v = $s::V.try_into().unwrap(), )*\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/enum-discr-type-err.rs:18:21\n@@ -29,10 +25,6 @@ LL | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n-   |\n-LL |             $( $v = $s::V.try_into().unwrap(), )*\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2603c944207d0ce6f83221725b85a6e9ca08d790", "filename": "src/test/ui/issues/issue-31910.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -3,11 +3,6 @@ error[E0308]: mismatched types\n    |\n LL |     X = Trait::Number,\n    |         ^^^^^^^^^^^^^ expected `isize`, found `i32`\n-   |\n-help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n-   |\n-LL |     X = Trait::Number.try_into().unwrap(),\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "aa796bcf5a0f38e2af8762400f77800d715f3452", "filename": "src/test/ui/issues/issue-72933-match-stack-overflow.rs", "status": "added", "additions": 5208, "deletions": 0, "changes": 5208, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fissues%2Fissue-72933-match-stack-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fissues%2Fissue-72933-match-stack-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72933-match-stack-overflow.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9"}, {"sha": "d7f18e19b41bd417282ab314dadbc43a7a29fa0a", "filename": "src/test/ui/numeric/const-scope.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -3,6 +3,11 @@ error[E0308]: mismatched types\n    |\n LL | const C: i32 = 1i8;\n    |                ^^^ expected `i32`, found `i8`\n+   |\n+help: change the type of the numeric literal from `i8` to `i32`\n+   |\n+LL | const C: i32 = 1i32;\n+   |                ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/const-scope.rs:2:15\n@@ -17,6 +22,11 @@ LL |     let c: i32 = 1i8;\n    |            ---   ^^^ expected `i32`, found `i8`\n    |            |\n    |            expected due to this\n+   |\n+help: change the type of the numeric literal from `i8` to `i32`\n+   |\n+LL |     let c: i32 = 1i32;\n+   |                  ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/const-scope.rs:6:17"}, {"sha": "fec4421c48a7c90d84e07579965085d4c9d5d6bd", "filename": "src/test/ui/parser/lex-bad-char-literals-4.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-4.stderr?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -1,8 +1,9 @@\n-error: unterminated character literal\n+error[E0762]: unterminated character literal\n   --> $DIR/lex-bad-char-literals-4.rs:4:5\n    |\n LL |     '\u25cf\n    |     ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0762`."}, {"sha": "70ee8087b5163266424d6bb260462d49665b6e1f", "filename": "src/test/ui/parser/lex-bad-char-literals-7.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-7.stderr?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -10,11 +10,12 @@ error: empty unicode escape (must have at least 1 hex digit)\n LL |     let _: char = '\\u{}';\n    |                    ^^^^\n \n-error: unterminated character literal\n+error[E0762]: unterminated character literal\n   --> $DIR/lex-bad-char-literals-7.rs:11:13\n    |\n LL |     let _ = ' hello // here's a comment\n    |             ^^^^^^^^\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0762`."}, {"sha": "7e30491f0bdbcdddc62a1b8b0e33f995df3ca32e", "filename": "src/test/ui/repeat_count.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.rs?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -22,6 +22,9 @@ fn main() {\n     let f = [0_usize; -1_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`, found `isize`\n+    let f = [0; 4u8];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`, found `u8`\n     struct G {\n         g: (),\n     }"}, {"sha": "6a081e23d9d375f6dfe51cbada2b04e0275f1398", "filename": "src/test/ui/repeat_count.stderr", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/src%2Ftest%2Fui%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.stderr?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -29,7 +29,7 @@ LL |     let e = [0; \"foo\"];\n    |                 ^^^^^ expected `usize`, found `&str`\n \n error[E0308]: mismatched types\n-  --> $DIR/repeat_count.rs:28:17\n+  --> $DIR/repeat_count.rs:31:17\n    |\n LL |     let g = [0; G { g: () }];\n    |                 ^^^^^^^^^^^ expected `usize`, found struct `main::G`\n@@ -39,24 +39,25 @@ error[E0308]: mismatched types\n    |\n LL |     let f = [0; -4_isize];\n    |                 ^^^^^^^^ expected `usize`, found `isize`\n-   |\n-help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n-   |\n-LL |     let f = [0; (-4_isize).try_into().unwrap()];\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/repeat_count.rs:22:23\n    |\n LL |     let f = [0_usize; -1_isize];\n    |                       ^^^^^^^^ expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/repeat_count.rs:25:17\n+   |\n+LL |     let f = [0; 4u8];\n+   |                 ^^^ expected `usize`, found `u8`\n    |\n-help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n+help: change the type of the numeric literal from `u8` to `usize`\n    |\n-LL |     let f = [0_usize; (-1_isize).try_into().unwrap()];\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let f = [0; 4usize];\n+   |                 ^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0308, E0435.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "833d390f1a26c7da6ec64d597a237a5392e1e918", "filename": "triagebot.toml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50c0192c64241d723066add22c53d472e2b9cba9/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50c0192c64241d723066add22c53d472e2b9cba9/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=50c0192c64241d723066add22c53d472e2b9cba9", "patch": "@@ -58,10 +58,16 @@ label = \"O-ARM\"\n \n [prioritize]\n label = \"I-prioritize\"\n-prioritize_on = [\"regression-from-stable-to-stable\", \"regression-from-stable-to-beta\", \"regression-from-stable-to-nightly\"]\n+prioritize_on = [\n+    \"regression-from-stable-to-stable\",\n+    \"regression-from-stable-to-beta\",\n+    \"regression-from-stable-to-nightly\",\n+    \"I-unsound \ud83d\udca5\",\n+]\n exclude_labels = [\n     \"P-*\",\n     \"T-infra\",\n     \"T-release\",\n+    \"requires-nightly\",\n ]\n zulip_stream = 227806"}]}