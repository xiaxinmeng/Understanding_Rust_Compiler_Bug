{"sha": "31e9ed5d6cf567557d2219add7afedae93aaf2a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZTllZDVkNmNmNTY3NTU3ZDIyMTlhZGQ3YWZlZGFlOTNhYWYyYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-12T10:58:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-12T10:58:33Z"}, "message": "Auto merge of #34778 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\n- Successful merges: #34736, #34737, #34740, #34742, #34749, #34750, #34770\n- Failed merges: #33951", "tree": {"sha": "532d8e1dd03867f528770c6e0dbf426266d4b28f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/532d8e1dd03867f528770c6e0dbf426266d4b28f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e9ed5d6cf567557d2219add7afedae93aaf2a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e9ed5d6cf567557d2219add7afedae93aaf2a5", "html_url": "https://github.com/rust-lang/rust/commit/31e9ed5d6cf567557d2219add7afedae93aaf2a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e9ed5d6cf567557d2219add7afedae93aaf2a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "html_url": "https://github.com/rust-lang/rust/commit/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d"}, {"sha": "23d5f5652c9297643ed149634c245eaf9967a871", "url": "https://api.github.com/repos/rust-lang/rust/commits/23d5f5652c9297643ed149634c245eaf9967a871", "html_url": "https://github.com/rust-lang/rust/commit/23d5f5652c9297643ed149634c245eaf9967a871"}], "stats": {"total": 376, "additions": 357, "deletions": 19}, "files": [{"sha": "666d0946ecc80a3eac3e25a9764bb34b097bd85b", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=31e9ed5d6cf567557d2219add7afedae93aaf2a5", "patch": "@@ -336,7 +336,7 @@ could annotate it on the function declaration:\n \n ```rust,ignore\n fn call_with_ref<'a, F>(some_closure:F) -> i32\n-    where F: Fn(&'a 32) -> i32 {\n+    where F: Fn(&'a i32) -> i32 {\n ```\n \n However this presents a problem with in our case. When you specify the explicit\n@@ -350,7 +350,7 @@ of the closure we can use Higher-Ranked Trait Bounds with the `for<...>` syntax:\n \n ```ignore\n fn call_with_ref<F>(some_closure:F) -> i32\n-    where F: for<'a> Fn(&'a 32) -> i32 {\n+    where F: for<'a> Fn(&'a i32) -> i32 {\n ```\n \n This lets the Rust compiler find the minimum lifetime to invoke our closure and"}, {"sha": "b3073f5e526033271c855588b8fb343d40d63bb5", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=31e9ed5d6cf567557d2219add7afedae93aaf2a5", "patch": "@@ -2633,7 +2633,7 @@ comma:\n \n There are several forms of struct expressions. A _struct expression_\n consists of the [path](#paths) of a [struct item](#structs), followed by\n-a brace-enclosed list of one or more comma-separated name-value pairs,\n+a brace-enclosed list of zero or more comma-separated name-value pairs,\n providing the field values of a new instance of the struct. A field name\n can be any identifier, and is separated from its value expression by a colon.\n The location denoted by a struct field is mutable if and only if the\n@@ -2652,10 +2652,12 @@ The following are examples of struct expressions:\n \n ```\n # struct Point { x: f64, y: f64 }\n+# struct NothingInMe { }\n # struct TuplePoint(f64, f64);\n # mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10.0, y: 20.0};\n+NothingInMe {};\n TuplePoint(10.0, 20.0);\n let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n some_fn::<Cookie>(Cookie);"}, {"sha": "7ba5ca30941f476f01f7957325b1cd361ab43e27", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=31e9ed5d6cf567557d2219add7afedae93aaf2a5", "patch": "@@ -249,6 +249,14 @@ impl<T: ?Sized> Box<T> {\n     /// This function is unsafe because improper use may lead to\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let ptr = Box::into_raw(x);\n+    /// let x = unsafe { Box::from_raw(ptr) };\n+    /// ```\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n@@ -266,9 +274,8 @@ impl<T: ?Sized> Box<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let seventeen = Box::new(17);\n-    /// let raw = Box::into_raw(seventeen);\n-    /// let boxed_again = unsafe { Box::from_raw(raw) };\n+    /// let x = Box::new(5);\n+    /// let ptr = Box::into_raw(x);\n     /// ```\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n@@ -399,6 +406,24 @@ impl Box<Any> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(value: Box<Any>) {\n+    ///     if let Ok(string) = value.downcast::<String>() {\n+    ///         println!(\"String ({}): {}\", string.len(), string);\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let my_string = \"Hello World\".to_string();\n+    ///     print_if_string(Box::new(my_string));\n+    ///     print_if_string(Box::new(0i8));\n+    /// }\n+    /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n@@ -419,6 +444,24 @@ impl Box<Any + Send> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(value: Box<Any + Send>) {\n+    ///     if let Ok(string) = value.downcast::<String>() {\n+    ///         println!(\"String ({}): {}\", string.len(), string);\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let my_string = \"Hello World\".to_string();\n+    ///     print_if_string(Box::new(my_string));\n+    ///     print_if_string(Box::new(0i8));\n+    /// }\n+    /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n         <Box<Any>>::downcast(self).map_err(|s| unsafe {\n             // reapply the Send marker"}, {"sha": "a452be2565b655e14597eed0116d65386bc53210", "filename": "src/libcore/any.rs", "status": "modified", "additions": 158, "deletions": 2, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=31e9ed5d6cf567557d2219add7afedae93aaf2a5", "patch": "@@ -92,6 +92,23 @@ use marker::{Reflect, Sized};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: Reflect + 'static {\n     /// Gets the `TypeId` of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_type_id)]\n+    ///\n+    /// use std::any::{Any, TypeId};\n+    ///\n+    /// fn is_string(s: &Any) -> bool {\n+    ///     TypeId::of::<String>() == s.get_type_id()\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(is_string(&0), false);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"get_type_id\",\n                reason = \"this method will likely be replaced by an associated static\",\n                issue = \"27745\")]\n@@ -125,7 +142,26 @@ impl fmt::Debug for Any + Send {\n }\n \n impl Any {\n-    /// Returns true if the boxed type is the same as `T`\n+    /// Returns true if the boxed type is the same as `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn is_string(s: &Any) {\n+    ///     if s.is::<String>() {\n+    ///         println!(\"It's a string!\");\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     is_string(&0);\n+    ///     is_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n@@ -141,6 +177,25 @@ impl Any {\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(s: &Any) {\n+    ///     if let Some(string) = s.downcast_ref::<String>() {\n+    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     print_if_string(&0);\n+    ///     print_if_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n@@ -159,6 +214,29 @@ impl Any {\n \n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn modify_if_u32(s: &mut Any) {\n+    ///     if let Some(num) = s.downcast_mut::<u32>() {\n+    ///         *num = 42;\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let mut x = 10u32;\n+    ///     let mut s = \"starlord\".to_owned();\n+    ///\n+    ///     modify_if_u32(&mut x);\n+    ///     modify_if_u32(&mut s);\n+    ///\n+    ///     assert_eq!(x, 42);\n+    ///     assert_eq!(&s, \"starlord\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n@@ -178,20 +256,81 @@ impl Any {\n \n impl Any+Send {\n     /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn is_string(s: &(Any + Send)) {\n+    ///     if s.is::<String>() {\n+    ///         println!(\"It's a string!\");\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     is_string(&0);\n+    ///     is_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n         Any::is::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(s: &(Any + Send)) {\n+    ///     if let Some(string) = s.downcast_ref::<String>() {\n+    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     print_if_string(&0);\n+    ///     print_if_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         Any::downcast_ref::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn modify_if_u32(s: &mut (Any+ Send)) {\n+    ///     if let Some(num) = s.downcast_mut::<u32>() {\n+    ///         *num = 42;\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let mut x = 10u32;\n+    ///     let mut s = \"starlord\".to_owned();\n+    ///\n+    ///     modify_if_u32(&mut x);\n+    ///     modify_if_u32(&mut s);\n+    ///\n+    ///     assert_eq!(x, 42);\n+    ///     assert_eq!(&s, \"starlord\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n@@ -220,7 +359,24 @@ pub struct TypeId {\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n-    /// instantiated with\n+    /// instantiated with.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_type_id)]\n+    ///\n+    /// use std::any::{Any, TypeId};\n+    ///\n+    /// fn is_string(s: &Any) -> bool {\n+    ///     TypeId::of::<String>() == s.get_type_id()\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(is_string(&0), false);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn of<T: ?Sized + Reflect + 'static>() -> TypeId {\n         TypeId {"}, {"sha": "65cb1aaaff6fd1e729d0e9a4ceb9a09ca57269a8", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=31e9ed5d6cf567557d2219add7afedae93aaf2a5", "patch": "@@ -237,6 +237,17 @@ impl<T:Copy> Cell<T> {\n     ///\n     /// This call borrows `Cell` mutably (at compile-time) which guarantees\n     /// that we possess the only reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let mut c = Cell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(c.get(), 6);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n@@ -388,6 +399,22 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// The returned value can be dispatched on to determine if a call to\n     /// `borrow` or `borrow_mut` would succeed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(borrow_state)]\n+    ///\n+    /// use std::cell::{BorrowState, RefCell};\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// match c.borrow_state() {\n+    ///     BorrowState::Writing => println!(\"Cannot be borrowed\"),\n+    ///     BorrowState::Reading => println!(\"Cannot be borrowed mutably\"),\n+    ///     BorrowState::Unused => println!(\"Can be borrowed (mutably as well)\"),\n+    /// }\n+    /// ```\n     #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n     #[inline]\n     pub fn borrow_state(&self) -> BorrowState {\n@@ -498,6 +525,17 @@ impl<T: ?Sized> RefCell<T> {\n     /// This can be used to circumvent `RefCell`'s safety checks.\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(as_unsafe_cell)]\n+    ///\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    /// let c = unsafe { c.as_unsafe_cell() };\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n     pub unsafe fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n@@ -508,6 +546,17 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// This call borrows `RefCell` mutably (at compile-time) so there is no\n     /// need for dynamic checks.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let mut c = RefCell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(c, RefCell::new(6));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {"}, {"sha": "1459420cdc00ce0b4f446ee5169ba36808f27070", "filename": "src/libstd/error.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=31e9ed5d6cf567557d2219add7afedae93aaf2a5", "patch": "@@ -66,10 +66,80 @@ pub trait Error: Debug + Display + Reflect {\n     /// The description should not contain newlines or sentence-ending\n     /// punctuation, to facilitate embedding in larger user-facing\n     /// strings.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::error::Error;\n+    ///\n+    /// match \"xc\".parse::<u32>() {\n+    ///     Err(e) => {\n+    ///         println!(\"Error: {}\", e.description());\n+    ///     }\n+    ///     _ => println!(\"No error\"),\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn description(&self) -> &str;\n \n     /// The lower-level cause of this error, if any.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::error::Error;\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct SuperError {\n+    ///     side: SuperErrorSideKick,\n+    /// }\n+    ///\n+    /// impl fmt::Display for SuperError {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"SuperError is here!\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Error for SuperError {\n+    ///     fn description(&self) -> &str {\n+    ///         \"I'm the superhero of errors!\"\n+    ///     }\n+    ///\n+    ///     fn cause(&self) -> Option<&Error> {\n+    ///         Some(&self.side)\n+    ///     }\n+    /// }\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct SuperErrorSideKick;\n+    ///\n+    /// impl fmt::Display for SuperErrorSideKick {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"SuperErrorSideKick is here!\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Error for SuperErrorSideKick {\n+    ///     fn description(&self) -> &str {\n+    ///         \"I'm SuperError side kick!\"\n+    ///     }\n+    /// }\n+    ///\n+    /// fn get_super_error() -> Result<(), SuperError> {\n+    ///     Err(SuperError { side: SuperErrorSideKick })\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     match get_super_error() {\n+    ///         Err(e) => {\n+    ///             println!(\"Error: {}\", e.description());\n+    ///             println!(\"Caused by: {}\", e.cause().unwrap());\n+    ///         }\n+    ///         _ => println!(\"No error\"),\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cause(&self) -> Option<&Error> { None }\n "}, {"sha": "16bc81de78ecf6debe8f6371eedf905779e5f3b9", "filename": "src/libstd/process.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9ed5d6cf567557d2219add7afedae93aaf2a5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=31e9ed5d6cf567557d2219add7afedae93aaf2a5", "patch": "@@ -27,8 +27,9 @@ use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// Representation of a running or exited child process.\n ///\n /// This structure is used to represent and manage child processes. A child\n-/// process is created via the `Command` struct, which configures the spawning\n-/// process and can itself be constructed using a builder-style interface.\n+/// process is created via the [`Command`] struct, which configures the\n+/// spawning process and can itself be constructed using a builder-style\n+/// interface.\n ///\n /// # Examples\n ///\n@@ -48,13 +49,18 @@ use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n ///\n /// # Note\n ///\n-/// Take note that there is no implementation of\n-/// [`Drop`](../../core/ops/trait.Drop.html) for child processes, so if you\n-/// do not ensure the `Child` has exited then it will continue to run, even\n-/// after the `Child` handle to the child process has gone out of scope.\n+/// Take note that there is no implementation of [`Drop`] for child processes,\n+/// so if you do not ensure the `Child` has exited then it will continue to\n+/// run, even after the `Child` handle to the child process has gone out of\n+/// scope.\n ///\n-/// Calling `wait` (or other functions that wrap around it) will make the\n-/// parent process wait until the child has actually exited before continuing.\n+/// Calling [`wait`][`wait`] (or other functions that wrap around it) will make\n+/// the parent process wait until the child has actually exited before\n+/// continuing.\n+///\n+/// [`Command`]: struct.Command.html\n+/// [`Drop`]: ../../core/ops/trait.Drop.html\n+/// [`wait`]: #method.wait\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n     handle: imp::Process,\n@@ -91,7 +97,11 @@ impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n \n-/// A handle to a child process's stdin\n+/// A handle to a child process's stdin. This struct is used in the [`stdin`]\n+/// field on [`Child`].\n+///\n+/// [`Child`]: struct.Child.html\n+/// [`stdin`]: struct.Child.html#structfield.stdin\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe\n@@ -122,7 +132,11 @@ impl FromInner<AnonPipe> for ChildStdin {\n     }\n }\n \n-/// A handle to a child process's stdout\n+/// A handle to a child process's stdout. This struct is used in the [`stdout`]\n+/// field on [`Child`].\n+///\n+/// [`Child`]: struct.Child.html\n+/// [`stdout`]: struct.Child.html#structfield.stdout\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n     inner: AnonPipe\n@@ -152,7 +166,11 @@ impl FromInner<AnonPipe> for ChildStdout {\n     }\n }\n \n-/// A handle to a child process's stderr\n+/// A handle to a child process's stderr. This struct is used in the [`stderr`]\n+/// field on [`Child`].\n+///\n+/// [`Child`]: struct.Child.html\n+/// [`stderr`]: struct.Child.html#structfield.stderr\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n     inner: AnonPipe"}]}