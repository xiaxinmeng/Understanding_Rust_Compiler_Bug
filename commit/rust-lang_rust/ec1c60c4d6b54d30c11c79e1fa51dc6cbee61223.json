{"sha": "ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMWM2MGM0ZDZiNTRkMzBjMTFjNzllMWZhNTFkYzZjYmVlNjEyMjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-20T04:27:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-23T01:00:48Z"}, "message": "rustc: Implement generic cross-crate trait inheritance", "tree": {"sha": "2293497b531a961542b589656f4711968d888983", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2293497b531a961542b589656f4711968d888983"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "html_url": "https://github.com/rust-lang/rust/commit/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "705afcd8445819c3f0493aa2befbe4788d9bb5ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/705afcd8445819c3f0493aa2befbe4788d9bb5ce", "html_url": "https://github.com/rust-lang/rust/commit/705afcd8445819c3f0493aa2befbe4788d9bb5ce"}], "stats": {"total": 251, "additions": 206, "deletions": 45}, "files": [{"sha": "bbc324fbdff4c4b270f944fbc512bcaa999e5f32", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -24,6 +24,7 @@ export get_enum_variants;\n export get_impls_for_mod;\n export get_trait_methods;\n export get_provided_trait_methods;\n+export get_supertraits;\n export get_method_names_if_trait;\n export get_type_name_if_impl;\n export get_static_methods_if_impl;\n@@ -122,6 +123,12 @@ fn get_provided_trait_methods(tcx: ty::ctxt, def: ast::def_id) ->\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n+fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n+    let cstore = tcx.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_supertraits(cdata, def.node, tcx)\n+}\n+\n fn get_method_names_if_trait(cstore: cstore::CStore, def: ast::def_id)\n     -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n "}, {"sha": "bc6a8da96b89a9dcf06370627019aa914b88adb2", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -43,6 +43,7 @@ export get_crate_vers;\n export get_impls_for_mod;\n export get_trait_methods;\n export get_provided_trait_methods;\n+export get_supertraits;\n export get_method_names_if_trait;\n export get_type_name_if_impl;\n export get_item_attrs;\n@@ -771,6 +772,16 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n     return move result;\n }\n \n+/// Returns the supertraits of the given trait.\n+fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n+    let results = dvec::DVec();\n+    let item_doc = lookup_item(id, cdata.data);\n+    for ebml::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n+        results.push(doc_type(trait_doc, tcx, cdata));\n+    }\n+    return dvec::unwrap(move results);\n+}\n+\n // If the item in question is a trait, returns its set of methods and\n // their self types. Otherwise, returns none. This overlaps in an\n // annoying way with get_trait_methods."}, {"sha": "8c4c4232b00244001854fa8c9a94e9c406e881f4", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -20,6 +20,7 @@ use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n \n export ProvidedMethodSource;\n+export InstantiatedTraitRef;\n export TyVid, IntVid, FnVid, RegionVid, vid;\n export br_hashmap;\n export is_instantiable;\n@@ -66,13 +67,15 @@ export sequence_element_type;\n export stmt_node_id;\n export sty;\n export subst, subst_tps, substs_is_noop, substs_to_str, substs;\n+export subst_substs;\n export t;\n export new_ty_hash;\n export enum_variants, substd_enum_variants, enum_is_univariant;\n export trait_methods, store_trait_methods, impl_traits;\n export enum_variant_with_id;\n export ty_dtor;\n export ty_param_bounds_and_ty;\n+export ty_param_substs_and_ty;\n export ty_bool, mk_bool, type_is_bool;\n export ty_bot, mk_bot, type_is_bot;\n export ty_box, mk_box, mk_imm_box, type_is_box, type_is_boxed;\n@@ -191,6 +194,7 @@ export region_variance, rv_covariant, rv_invariant, rv_contravariant;\n export opt_region_variance;\n export determine_inherited_purity;\n export provided_trait_methods;\n+export trait_supertraits;\n export AutoAdjustment;\n export AutoRef, AutoRefKind, AutoSlice, AutoPtr;\n \n@@ -321,6 +325,11 @@ struct ProvidedMethodSource {\n     impl_id: ast::def_id\n }\n \n+struct InstantiatedTraitRef {\n+    def_id: ast::def_id,\n+    tpt: ty_param_substs_and_ty\n+}\n+\n type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: HashMap<intern_key, t_box>,\n@@ -364,7 +373,8 @@ type ctxt =\n       normalized_cache: HashMap<t, t>,\n       lang_items: middle::lang_items::LanguageItems,\n       legacy_boxed_traits: HashMap<node_id, ()>,\n-      provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>};\n+      provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n+      supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>};\n \n enum tbox_flag {\n     has_params = 1,\n@@ -819,6 +829,8 @@ type ty_param_bounds_and_ty = {bounds: @~[param_bounds],\n                                region_param: Option<region_variance>,\n                                ty: t};\n \n+type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n+\n type type_cache = HashMap<ast::def_id, ty_param_bounds_and_ty>;\n \n type constness_cache = HashMap<ast::def_id, const_eval::constness>;\n@@ -888,7 +900,8 @@ fn mk_ctxt(s: session::Session,\n       normalized_cache: new_ty_hash(),\n       lang_items: move lang_items,\n       legacy_boxed_traits: HashMap(),\n-      provided_method_sources: HashMap()}\n+      provided_method_sources: HashMap(),\n+      supertraits: HashMap()}\n }\n \n \n@@ -1486,6 +1499,16 @@ fn subst(cx: ctxt,\n     }\n }\n \n+// Performs substitutions on a set of substitutions (result = super(sub)) to\n+// yield a new set of substitutions. This is used in trait inheritance.\n+fn subst_substs(cx: ctxt, super: &substs, sub: &substs) -> substs {\n+    {\n+        self_r: super.self_r,\n+        self_ty: super.self_ty.map(|typ| subst(cx, sub, *typ)),\n+        tps: super.tps.map(|typ| subst(cx, sub, *typ))\n+    }\n+}\n+\n // Type utilities\n \n fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n@@ -3365,6 +3388,35 @@ fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     }\n }\n \n+fn trait_supertraits(cx: ctxt, id: ast::def_id) -> @~[InstantiatedTraitRef] {\n+    // Check the cache.\n+    match cx.supertraits.find(id) {\n+        Some(instantiated_trait_info) => { return instantiated_trait_info; }\n+        None => {}  // Continue.\n+    }\n+\n+    // Not in the cache. It had better be in the metadata, which means it\n+    // shouldn't be local.\n+    assert !is_local(id);\n+\n+    // Get the supertraits out of the metadata and create the\n+    // InstantiatedTraitRef for each.\n+    let result = dvec::DVec();\n+    for csearch::get_supertraits(cx, id).each |trait_type| {\n+        match get(*trait_type).sty {\n+            ty_trait(def_id, substs, _) => {\n+                result.push(InstantiatedTraitRef {\n+                    def_id: def_id,\n+                    tpt: { substs: substs, ty: *trait_type }\n+                });\n+            }\n+            _ => cx.sess.bug(~\"trait_supertraits: trait ref wasn't a trait\")\n+        }\n+    }\n+\n+    // Unwrap and return the result.\n+    return @dvec::unwrap(move result);\n+}\n \n fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n     match cx.trait_method_cache.find(id) {"}, {"sha": "afb13cf52abcd4bb3cc7125a29c4e41a249c156b", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -51,7 +51,7 @@ use syntax::codemap::span;\n use pat_util::{pat_is_variant, pat_id_map, PatIdMap};\n use middle::ty;\n use middle::ty::{arg, field, node_type_table, mk_nil, ty_param_bounds_and_ty};\n-use middle::ty::{vstore_uniq};\n+use middle::ty::{ty_param_substs_and_ty, vstore_uniq};\n use std::smallintmap;\n use std::map;\n use std::map::HashMap;\n@@ -174,8 +174,6 @@ impl vtable_origin {\n \n type vtable_map = HashMap<ast::node_id, vtable_res>;\n \n-type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n-\n type crate_ctxt_ = {// A mapping from method call sites to traits that have\n                     // that method.\n                     trait_map: resolve::TraitMap,"}, {"sha": "eb28d06fdea7ba73e5849f094a68d112cece9fc2", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -313,45 +313,73 @@ impl LookupContext {\n                 }\n             };\n \n-            let trait_methods = ty::trait_methods(tcx, trait_id);\n-            let pos = {\n-                // FIXME #3453 can't use trait_methods.position\n-                match vec::position(*trait_methods,\n-                                    |m| (m.self_ty != ast::sty_static &&\n-                                         m.ident == self.m_name))\n-                {\n-                    Some(pos) => pos,\n-                    None => {\n-                        loop; // check next bound\n-                    }\n+            // Loop over the trait and all of its supertraits.\n+            let worklist = dvec::DVec();\n+            worklist.push((trait_id, move bound_substs));\n+\n+            let mut i = 0;\n+            while i < worklist.len() {\n+                let (trait_id, bound_substs) = worklist[i];\n+                i += 1;\n+\n+                // Replace any appearance of `self` with the type of the\n+                // generic parameter itself.  Note that this is the only\n+                // case where this replacement is necessary: in all other\n+                // cases, we are either invoking a method directly from an\n+                // impl or class (where the self type is not permitted),\n+                // or from a trait type (in which case methods that refer\n+                // to self are not permitted).\n+                let rcvr_ty = ty::mk_param(tcx, param_ty.idx,\n+                                           param_ty.def_id);\n+                let rcvr_substs = {self_ty: Some(rcvr_ty), ..bound_substs};\n+\n+                // Add all the supertraits of this trait to the worklist.\n+                debug!(\"finding supertraits for %d:%d\", trait_id.crate,\n+                       trait_id.node);\n+                let instantiated_trait_refs = ty::trait_supertraits(\n+                    tcx, trait_id);\n+                for instantiated_trait_refs.each |instantiated_trait_ref| {\n+                    debug!(\"adding supertrait\");\n+\n+                    let new_substs = ty::subst_substs(\n+                        tcx,\n+                        &instantiated_trait_ref.tpt.substs,\n+                        &rcvr_substs);\n+\n+                    worklist.push(\n+                        (instantiated_trait_ref.def_id, new_substs));\n                 }\n-            };\n-            let method = &trait_methods[pos];\n-\n-            // Replace any appearance of `self` with the type of the\n-            // generic parameter itself.  Note that this is the only\n-            // case where this replacement is necessary: in all other\n-            // cases, we are either invoking a method directly from an\n-            // impl or class (where the self type is not permitted),\n-            // or from a trait type (in which case methods that refer\n-            // to self are not permitted).\n-            let rcvr_ty = ty::mk_param(tcx, param_ty.idx, param_ty.def_id);\n-            let rcvr_substs = {self_ty: Some(rcvr_ty), ..bound_substs};\n-\n-            let (rcvr_ty, rcvr_substs) =\n-                self.create_rcvr_ty_and_substs_for_method(\n-                    method.self_ty, rcvr_ty, move rcvr_substs);\n-\n-            self.inherent_candidates.push(Candidate {\n-                rcvr_ty: rcvr_ty,\n-                rcvr_substs: rcvr_substs,\n-                num_method_tps: method.tps.len(),\n-                self_mode: get_mode_from_self_type(method.self_ty),\n-                origin: method_param({trait_id:trait_id,\n-                                      method_num:pos,\n-                                      param_num:param_ty.idx,\n-                                      bound_num:this_bound_idx})\n-            });\n+\n+                let trait_methods = ty::trait_methods(tcx, trait_id);\n+                let pos = {\n+                    // FIXME #3453 can't use trait_methods.position\n+                    match vec::position(*trait_methods,\n+                                        |m| (m.self_ty != ast::sty_static &&\n+                                             m.ident == self.m_name))\n+                    {\n+                        Some(pos) => pos,\n+                        None => {\n+                            loop; // check next trait or bound\n+                        }\n+                    }\n+                };\n+                let method = &trait_methods[pos];\n+\n+                let (rcvr_ty, rcvr_substs) =\n+                    self.create_rcvr_ty_and_substs_for_method(\n+                        method.self_ty, rcvr_ty, move rcvr_substs);\n+\n+                self.inherent_candidates.push(Candidate {\n+                    rcvr_ty: rcvr_ty,\n+                    rcvr_substs: rcvr_substs,\n+                    num_method_tps: method.tps.len(),\n+                    self_mode: get_mode_from_self_type(method.self_ty),\n+                    origin: method_param({trait_id:trait_id,\n+                                          method_num:pos,\n+                                          param_num:param_ty.idx,\n+                                          bound_num:this_bound_idx})\n+                });\n+            }\n         }\n     }\n "}, {"sha": "7e1696549e150c281b19aafc1376807e1cc18496", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -23,7 +23,7 @@ are represented as `ty_param()` instances.\n use astconv::{ast_conv, ty_of_fn_decl, ty_of_arg, ast_ty_to_ty};\n use ast_util::trait_method_to_ty_method;\n use rscope::*;\n-use ty::{FnTyBase, FnMeta, FnSig};\n+use ty::{FnTyBase, FnMeta, FnSig, InstantiatedTraitRef};\n use util::common::pluralize;\n use util::ppaux::bound_to_str;\n \n@@ -239,6 +239,21 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n     }\n }\n \n+fn ensure_supertraits(ccx: @crate_ctxt,\n+                      id: ast::node_id,\n+                      rp: Option<ty::region_variance>,\n+                      trait_refs: &[@ast::trait_ref]) {\n+    if ccx.tcx.supertraits.contains_key(local_def(id)) { return; }\n+\n+    let instantiated = dvec::DVec();\n+    for trait_refs.each |trait_ref| {\n+        let (did, tpt) = instantiate_trait_ref(ccx, *trait_ref, rp);\n+        instantiated.push(InstantiatedTraitRef { def_id: did, tpt: tpt });\n+    }\n+    ccx.tcx.supertraits.insert(local_def(id),\n+                               @dvec::unwrap(move instantiated));\n+}\n+\n /**\n  * Checks that a method from an impl/class conforms to the signature of\n  * the same method as declared in the trait.\n@@ -462,12 +477,13 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n             check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n         }\n       }\n-      ast::item_trait(tps, _, trait_methods) => {\n+      ast::item_trait(tps, supertraits, trait_methods) => {\n         let tpt = ty_of_item(ccx, it);\n         debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n                it.id, ty_to_str(tcx, tpt.ty));\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         ensure_trait_methods(ccx, it.id, tpt.ty);\n+        ensure_supertraits(ccx, it.id, rp, supertraits);\n \n         let (_, provided_methods) = split_trait_methods(trait_methods);\n         let {bounds, _} = mk_substs(ccx, tps, rp);"}, {"sha": "1608a332fe5a84b961cc1cb05b0e711d3b2fa1f3", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -0,0 +1,9 @@\n+pub trait MyNum : Add<self,self>, Sub<self,self>, Mul<self,self> {\n+}\n+\n+pub impl int : MyNum {\n+    pure fn add(other: &int) -> int { self + *other }\n+    pure fn sub(other: &int) -> int { self - *other }\n+    pure fn mul(other: &int) -> int { self * *other }\n+}\n+"}, {"sha": "a38a834fb726319cb05ed91108faa5abf347e68a", "filename": "src/test/run-pass/trait-inheritance-overloading-xc-exe.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -0,0 +1,19 @@\n+// xfail-fast - check-fast doesn't understand aux-build\n+// aux-build:trait_inheritance_overloading_xc.rs\n+\n+extern mod trait_inheritance_overloading_xc;\n+use trait_inheritance_overloading_xc::MyNum;\n+\n+fn f<T:Copy MyNum>(x: T, y: T) -> (T, T, T) {\n+    return (x + y, x - y, x * y);\n+}\n+\n+fn main() {\n+    let (x, y) = (3, 5);\n+    let (a, b, c) = f(x, y);\n+    assert a == 8;\n+    assert b == -2;\n+    assert c == 15;\n+}\n+\n+"}, {"sha": "4014cd2c623870fdbe97b0580f27913ee163cc60", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "patch": "@@ -0,0 +1,21 @@\n+trait MyNum : Add<self,self>, Sub<self,self>, Mul<self,self> {\n+}\n+\n+impl int : MyNum {\n+    pure fn add(other: &int) -> int { self + *other }\n+    pure fn sub(other: &int) -> int { self - *other }\n+    pure fn mul(other: &int) -> int { self * *other }\n+}\n+\n+fn f<T:Copy MyNum>(x: T, y: T) -> (T, T, T) {\n+    return (x + y, x - y, x * y);\n+}\n+\n+fn main() {\n+    let (x, y) = (3, 5);\n+    let (a, b, c) = f(x, y);\n+    assert a == 8;\n+    assert b == -2;\n+    assert c == 15;\n+}\n+"}]}