{"sha": "62e583d4cfc1a5c9135bff3f2bb9414cfac6882d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZTU4M2Q0Y2ZjMWE1YzkxMzViZmYzZjJiYjk0MTRjZmFjNjg4MmQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "github4395871230gnr48oli-obk.de", "date": "2015-05-01T16:43:36Z"}, "committer": {"name": "Oliver Schneider", "email": "github4395871230gnr48oli-obk.de", "date": "2015-05-01T20:28:58Z"}, "message": "split main function and test function into their own files\n\nsmall modifications to make executable and test compile properly", "tree": {"sha": "511563b3a406d783c4fc1a1fa905466219aa3720", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/511563b3a406d783c4fc1a1fa905466219aa3720"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d", "html_url": "https://github.com/rust-lang/rust/commit/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d/comments", "author": null, "committer": null, "parents": [{"sha": "e6e7ce178f39b837e1b2b8dff33d587780a2a37e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e7ce178f39b837e1b2b8dff33d587780a2a37e", "html_url": "https://github.com/rust-lang/rust/commit/e6e7ce178f39b837e1b2b8dff33d587780a2a37e"}], "stats": {"total": 214, "additions": 116, "deletions": 98}, "files": [{"sha": "67b2e6316a61869e85939a1b30c7912f58033c31", "filename": "src/bin/rustfmt.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=62e583d4cfc1a5c9135bff3f2bb9414cfac6882d", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(exit_status)]\n+\n+extern crate rustfmt;\n+\n+use rustfmt::{WriteMode, run};\n+\n+fn main() {\n+    let args: Vec<_> = std::env::args().collect();\n+    //run(args, WriteMode::Display);\n+    run(args, WriteMode::Overwrite);\n+    std::env::set_exit_status(0);\n+\n+    // TODO unit tests\n+    // let fmt = ListFormatting {\n+    //     tactic: ListTactic::Horizontal,\n+    //     separator: \",\",\n+    //     trailing_separator: SeparatorTactic::Vertical,\n+    //     indent: 2,\n+    //     h_width: 80,\n+    //     v_width: 100,\n+    // };\n+    // let inputs = vec![(format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new())];\n+    // let s = write_list(&inputs, &fmt);\n+    // println!(\"  {}\", s);\n+}"}, {"sha": "e22a0861390c0355b37c4b31ae06373fe68a0c20", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 98, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=62e583d4cfc1a5c9135bff3f2bb9414cfac6882d", "patch": "@@ -14,8 +14,6 @@\n #![feature(collections)]\n #![feature(str_char)]\n \n-#![cfg_attr(not(test), feature(exit_status))]\n-\n // TODO we're going to allocate a whole bunch of temp Strings, is it worth\n // keeping some scratch mem for this and running our own StrPool?\n // TODO for lint violations of names, emit a refactor script\n@@ -244,102 +242,7 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n     }\n }\n \n-fn run(args: Vec<String>, write_mode: WriteMode) {\n+pub fn run(args: Vec<String>, write_mode: WriteMode) {\n     let mut call_ctxt = RustFmtCalls { input_path: None, write_mode: write_mode };\n     rustc_driver::run_compiler(&args, &mut call_ctxt);\n }\n-\n-#[cfg(not(test))]\n-fn main() {\n-    let args: Vec<_> = std::env::args().collect();\n-    //run(args, WriteMode::Display);\n-    run(args, WriteMode::Overwrite);\n-    std::env::set_exit_status(0);\n-\n-    // TODO unit tests\n-    // let fmt = ListFormatting {\n-    //     tactic: ListTactic::Horizontal,\n-    //     separator: \",\",\n-    //     trailing_separator: SeparatorTactic::Vertical,\n-    //     indent: 2,\n-    //     h_width: 80,\n-    //     v_width: 100,\n-    // };\n-    // let inputs = vec![(format!(\"foo\"), String::new()),\n-    //                   (format!(\"foo\"), String::new()),\n-    //                   (format!(\"foo\"), String::new()),\n-    //                   (format!(\"foo\"), String::new()),\n-    //                   (format!(\"foo\"), String::new()),\n-    //                   (format!(\"foo\"), String::new()),\n-    //                   (format!(\"foo\"), String::new()),\n-    //                   (format!(\"foo\"), String::new())];\n-    // let s = write_list(&inputs, &fmt);\n-    // println!(\"  {}\", s);\n-}\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use std::collections::HashMap;\n-    use std::fs;\n-    use std::io::Read;\n-    use std::sync::atomic;\n-    use super::*;\n-    use super::run;\n-\n-    // For now, the only supported regression tests are idempotent tests - the input and\n-    // output must match exactly.\n-    // FIXME(#28) would be good to check for error messages and fail on them, or at least report.\n-    #[test]\n-    fn idempotent_tests() {\n-        println!(\"Idempotent tests:\");\n-        FAILURES.store(0, atomic::Ordering::Relaxed);\n-\n-        // Get all files in the tests/idem directory\n-        let files = fs::read_dir(\"tests/idem\").unwrap();\n-        // For each file, run rustfmt and collect the output\n-        let mut count = 0;\n-        for entry in files {\n-            let path = entry.unwrap().path();\n-            let file_name = path.to_str().unwrap();\n-            println!(\"Testing '{}'...\", file_name);\n-            run(vec![\"rustfmt\".to_owned(), file_name.to_owned()], WriteMode::Return(HANDLE_RESULT));\n-            count += 1;\n-        }\n-        // And also dogfood ourselves!\n-        println!(\"Testing 'src/main.rs'...\");\n-        run(vec![\"rustfmt\".to_string(), \"src/main.rs\".to_string()],\n-            WriteMode::Return(HANDLE_RESULT));\n-        count += 1;\n-\n-        // Display results\n-        let fails = FAILURES.load(atomic::Ordering::Relaxed);\n-        println!(\"Ran {} idempotent tests; {} failures.\", count, fails);\n-        assert!(fails == 0, \"{} idempotent tests failed\", fails);\n-    }\n-\n-    // 'global' used by sys_tests and handle_result.\n-    static FAILURES: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n-    // Ick, just needed to get a &'static to handle_result.\n-    static HANDLE_RESULT: &'static Fn(HashMap<String, String>) = &handle_result;\n-\n-    // Compare output to input.\n-    fn handle_result(result: HashMap<String, String>) {\n-        let mut fails = 0;\n-\n-        for file_name in result.keys() {\n-            let mut f = fs::File::open(file_name).unwrap();\n-            let mut text = String::new();\n-            f.read_to_string(&mut text).unwrap();\n-            if result[file_name] != text {\n-                fails += 1;\n-                println!(\"Mismatch in {}.\", file_name);\n-                println!(\"{}\", result[file_name]);\n-            }\n-        }\n-\n-        if fails > 0 {\n-            FAILURES.fetch_add(1, atomic::Ordering::Relaxed);\n-        }\n-    }\n-}"}, {"sha": "a82d326087eb4fbd1600c5aacbeb24ef08d0c987", "filename": "tests/idem.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d/tests%2Fidem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62e583d4cfc1a5c9135bff3f2bb9414cfac6882d/tests%2Fidem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem.rs?ref=62e583d4cfc1a5c9135bff3f2bb9414cfac6882d", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate rustfmt;\n+\n+use std::collections::HashMap;\n+use std::fs;\n+use std::io::Read;\n+use std::sync::atomic;\n+use rustfmt::*;\n+\n+// For now, the only supported regression tests are idempotent tests - the input and\n+// output must match exactly.\n+// FIXME(#28) would be good to check for error messages and fail on them, or at least report.\n+#[test]\n+fn idempotent_tests() {\n+    println!(\"Idempotent tests:\");\n+    FAILURES.store(0, atomic::Ordering::Relaxed);\n+\n+    // Get all files in the tests/idem directory\n+    let files = fs::read_dir(\"tests/idem\").unwrap();\n+    // For each file, run rustfmt and collect the output\n+    let mut count = 0;\n+    for entry in files {\n+        let path = entry.unwrap().path();\n+        let file_name = path.to_str().unwrap();\n+        println!(\"Testing '{}'...\", file_name);\n+        run(vec![\"rustfmt\".to_owned(), file_name.to_owned()], WriteMode::Return(HANDLE_RESULT));\n+        count += 1;\n+    }\n+    // And also dogfood ourselves!\n+    println!(\"Testing 'src/lib.rs'...\");\n+    run(vec![\"rustfmt\".to_string(), \"src/lib.rs\".to_string()],\n+        WriteMode::Return(HANDLE_RESULT));\n+    count += 1;\n+\n+    // Display results\n+    let fails = FAILURES.load(atomic::Ordering::Relaxed);\n+    println!(\"Ran {} idempotent tests; {} failures.\", count, fails);\n+    assert!(fails == 0, \"{} idempotent tests failed\", fails);\n+}\n+\n+// 'global' used by sys_tests and handle_result.\n+static FAILURES: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+// Ick, just needed to get a &'static to handle_result.\n+static HANDLE_RESULT: &'static Fn(HashMap<String, String>) = &handle_result;\n+\n+// Compare output to input.\n+fn handle_result(result: HashMap<String, String>) {\n+    let mut fails = 0;\n+\n+    for file_name in result.keys() {\n+        let mut f = fs::File::open(file_name).unwrap();\n+        let mut text = String::new();\n+        f.read_to_string(&mut text).unwrap();\n+        if result[file_name] != text {\n+            fails += 1;\n+            println!(\"Mismatch in {}.\", file_name);\n+            println!(\"{}\", result[file_name]);\n+        }\n+    }\n+\n+    if fails > 0 {\n+        FAILURES.fetch_add(1, atomic::Ordering::Relaxed);\n+    }\n+}\n\\ No newline at end of file"}]}