{"sha": "3261b6eece84161355bac8dad8427af5221cbf0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNjFiNmVlY2U4NDE2MTM1NWJhYzhkYWQ4NDI3YWY1MjIxY2JmMGQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-07-05T20:57:53Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:10Z"}, "message": "WIP: adding context to macros", "tree": {"sha": "daedbde8731d4ed6ed2c11b5e1c00add5aaef03e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daedbde8731d4ed6ed2c11b5e1c00add5aaef03e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3261b6eece84161355bac8dad8427af5221cbf0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3261b6eece84161355bac8dad8427af5221cbf0d", "html_url": "https://github.com/rust-lang/rust/commit/3261b6eece84161355bac8dad8427af5221cbf0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3261b6eece84161355bac8dad8427af5221cbf0d/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2", "html_url": "https://github.com/rust-lang/rust/commit/34f31e296191f7c4cfcad8c81bf6bca00a32d9e2"}], "stats": {"total": 26, "additions": 16, "deletions": 10}, "files": [{"sha": "317294938152a3e0aea4503a861a7f64e1a1f741", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3261b6eece84161355bac8dad8427af5221cbf0d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3261b6eece84161355bac8dad8427af5221cbf0d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3261b6eece84161355bac8dad8427af5221cbf0d", "patch": "@@ -472,7 +472,7 @@ pub enum BlockCheckMode {\n     UnsafeBlock,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct Expr {\n     id: NodeId,\n     node: Expr_,"}, {"sha": "228a9ba03a2710ca8602c91348bb3e55d337ec47", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3261b6eece84161355bac8dad8427af5221cbf0d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3261b6eece84161355bac8dad8427af5221cbf0d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3261b6eece84161355bac8dad8427af5221cbf0d", "patch": "@@ -603,7 +603,7 @@ fn expand_non_macro_stmt (exts: SyntaxEnv,\n }\n \n // a visitor that extracts the pat_ident paths\n-// from a given pattern and puts them in a mutable\n+// from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n #[deriving(Clone)]\n struct NewNameFinderContext {\n@@ -748,15 +748,14 @@ impl Visitor<()> for NewNameFinderContext {\n     }\n }\n \n-// a visitor that extracts the path exprs from\n-// a crate/expression/whatever and puts them in a mutable\n+// a visitor that extracts the paths\n+// from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n #[deriving(Clone)]\n struct NewPathExprFinderContext {\n     path_accumulator: @mut ~[ast::Path],\n }\n \n-\n // XXX : YIKES a lot of boilerplate again....\n impl Visitor<()> for NewPathExprFinderContext {\n \n@@ -875,7 +874,7 @@ impl Visitor<()> for NewPathExprFinderContext {\n }\n \n // return a visitor that extracts the pat_ident paths\n-// from a given pattern and puts them in a mutable\n+// from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n pub fn new_name_finder(idents: @mut ~[ast::Ident]) -> @mut Visitor<()> {\n     let context = @mut NewNameFinderContext {\n@@ -913,6 +912,7 @@ pub fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n     make_fold(f_pre)\n }\n \n+// expand a block. pushes a new exts_frame, then calls expand_block_elts\n pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     _cx: @ExtCtxt,\n                     blk: &Block,\n@@ -924,7 +924,7 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n                      expand_block_elts(*extsbox, blk, fld))\n }\n \n-\n+// expand the elements of a block.\n pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: @ast_fold) -> Block {\n     let block_info = get_block_info(exts);\n     let pending_renames = block_info.pending_renames;\n@@ -949,6 +949,7 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: @ast_fold) -> Block {\n }\n \n // rename_fold should never return \"None\".\n+// (basically, just .get() with a better message...)\n fn mustbesome<T>(val : Option<T>) -> T {\n     match val {\n         Some(v) => v,\n@@ -971,8 +972,8 @@ pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n }\n \n // FIXME (#2247): this is a moderately bad kludge to inject some macros into\n-// the default compilation environment. It would be much nicer to use\n-// a mechanism like syntax_quote to ensure hygiene.\n+// the default compilation environment in that it injects strings, rather than\n+// syntax elements.\n \n pub fn std_macros() -> @str {\n     return\n@@ -1453,6 +1454,10 @@ pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n         |ast::Ident{name, ctxt}, _| {\n         ast::Ident{name:name,ctxt:cf.f(ctxt)}\n     };\n+    // we've also got to pick up macro invocations; they can\n+    // appear as exprs, stmts, items, and types. urg, it's going\n+    // to be easier just to add a fold_mac, I think.\n+    //let fold_ex : @\n     @AstFoldFns{\n         fold_ident : fi,\n         // check that it works, then add the fold_expr clause....\n@@ -1631,14 +1636,15 @@ mod test {\n \n         // try a double-rename, with pending_renames.\n         let a3_name = gensym(\"a3\");\n+        // a context that renames from (\"a\",empty) to \"a2\" :\n         let ctxt2 = new_rename(ast::Ident::new(a_name),a2_name,EMPTY_CTXT);\n         let pending_renames = @mut ~[(ast::Ident::new(a_name),a2_name),\n                                      (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)];\n         let double_renamed = renames_to_fold(pending_renames).fold_crate(item_ast);\n         let varrefs = @mut ~[];\n         visit::walk_crate(&mut new_path_finder(varrefs), &double_renamed, ());\n         match varrefs {\n-            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n+            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a3_name),\n             _ => assert_eq!(0,1)\n         }\n     }"}]}