{"sha": "75965030c7f97f9e2be9d76e522c61d3a6e1f074", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OTY1MDMwYzdmOTdmOWUyYmU5ZDc2ZTUyMmM2MWQzYTZlMWYwNzQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-05T18:14:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-05T18:14:55Z"}, "message": "Merge pull request #3251 from rust-lang-nursery/relicense-rewrite\n\n[do not merge] Relicensing rewrite", "tree": {"sha": "25569199bfe30baf70db02b17a09b2d5d51838c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25569199bfe30baf70db02b17a09b2d5d51838c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75965030c7f97f9e2be9d76e522c61d3a6e1f074", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbt6ofCRBK7hj4Ov3rIwAAdHIIAKJIbcH1Ir93zxhIXxTX7EDx\nnnlIdoOVDTsagdfULF0D72+AMGLgn/k5c3tnUwDdDJm484eQWy9e5H8DYCbThoFQ\nr7oCnEWo447WLFXAiUSwUujcRovkniMZVxjNAQPFe3OJpMAylMGFEotrK7JBtBLu\nSNAEgU2hgKBTUKeKwNxsWDpqieX+ne3/DIQpmvNtKS+RM8duaQAAGmgEl89deMin\n2ReHG/JQD3gs3V6aDL6gsIXQLah+0xI1TUZPQpdkAVjJc1WrXdMfGqlpN/6DXFLJ\nL/Ci+fm+lk7ELM3TGG6qezmKsg9mGnEUnzIvUdX+AxvIRijZybesZNF6UawtzI0=\n=9GME\n-----END PGP SIGNATURE-----\n", "payload": "tree 25569199bfe30baf70db02b17a09b2d5d51838c1\nparent 87f6d9e7f94af1e2c192a68c997e6b247bba5d06\nparent 8407957ec64b94740f86d2079dc2d433f7f85e6a\nauthor Manish Goregaokar <manishsmail@gmail.com> 1538763295 +0200\ncommitter GitHub <noreply@github.com> 1538763295 +0200\n\nMerge pull request #3251 from rust-lang-nursery/relicense-rewrite\n\n[do not merge] Relicensing rewrite"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75965030c7f97f9e2be9d76e522c61d3a6e1f074", "html_url": "https://github.com/rust-lang/rust/commit/75965030c7f97f9e2be9d76e522c61d3a6e1f074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75965030c7f97f9e2be9d76e522c61d3a6e1f074/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87f6d9e7f94af1e2c192a68c997e6b247bba5d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/87f6d9e7f94af1e2c192a68c997e6b247bba5d06", "html_url": "https://github.com/rust-lang/rust/commit/87f6d9e7f94af1e2c192a68c997e6b247bba5d06"}, {"sha": "8407957ec64b94740f86d2079dc2d433f7f85e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8407957ec64b94740f86d2079dc2d433f7f85e6a", "html_url": "https://github.com/rust-lang/rust/commit/8407957ec64b94740f86d2079dc2d433f7f85e6a"}], "stats": {"total": 833, "additions": 370, "deletions": 463}, "files": [{"sha": "3779b09ecf33405b8b6a4521d702b18abcb56369", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75965030c7f97f9e2be9d76e522c61d3a6e1f074/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75965030c7f97f9e2be9d76e522c61d3a6e1f074/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=75965030c7f97f9e2be9d76e522c61d3a6e1f074", "patch": "@@ -328,6 +328,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box strings::StringAdd);\n     reg.register_early_lint_pass(box returns::ReturnPass);\n     reg.register_late_lint_pass(box methods::Pass);\n+    reg.register_late_lint_pass(box map_clone::Pass);\n     reg.register_late_lint_pass(box shadow::Pass);\n     reg.register_late_lint_pass(box types::LetPass);\n     reg.register_late_lint_pass(box types::UnitCmp);\n@@ -346,7 +347,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box needless_borrow::NeedlessBorrow);\n     reg.register_late_lint_pass(box needless_borrowed_ref::NeedlessBorrowedRef);\n     reg.register_late_lint_pass(box no_effect::Pass);\n-    reg.register_late_lint_pass(box map_clone::Pass);\n     reg.register_late_lint_pass(box temporary_assignment::Pass);\n     reg.register_late_lint_pass(box transmute::Transmute);\n     reg.register_late_lint_pass(\n@@ -792,6 +792,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         returns::NEEDLESS_RETURN,\n         strings::STRING_LIT_AS_BYTES,\n         types::FN_TO_NUMERIC_CAST,\n+        types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n         types::IMPLICIT_HASHER,\n         types::LET_UNIT_VALUE,\n         unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n@@ -921,7 +922,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         transmute::WRONG_TRANSMUTE,\n         types::ABSURD_EXTREME_COMPARISONS,\n         types::CAST_PTR_ALIGNMENT,\n-        types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n         types::UNIT_CMP,\n         unicode::ZERO_WIDTH_SPACE,\n         unused_io_amount::UNUSED_IO_AMOUNT,"}, {"sha": "e16a8af7641f5bc42b88d1c2e16eebcacf5d573d", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 71, "deletions": 113, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/75965030c7f97f9e2be9d76e522c61d3a6e1f074/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75965030c7f97f9e2be9d76e522c61d3a6e1f074/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=75965030c7f97f9e2be9d76e522c61d3a6e1f074", "patch": "@@ -1,140 +1,98 @@\n+use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::syntax::source_map::Span;\n+use crate::utils::paths;\n+use crate::utils::{\n+    in_macro, match_trait_method, match_type,\n+    remove_blocks, snippet,\n+    span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n-use crate::rustc::hir::*;\n-use crate::rustc::ty;\n-use crate::syntax::ast;\n-use crate::utils::{get_arg_ident, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n-            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n+use crate::syntax::ast::Ident;\n \n-/// **What it does:** Checks for mapping `clone()` over an iterator.\n+#[derive(Clone)]\n+pub struct Pass;\n+\n+/// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests\n+/// `iterator.cloned()` instead\n ///\n-/// **Why is this bad?** It makes the code less readable than using the\n-/// `.cloned()` adapter.\n+/// **Why is this bad?** Readability, this can be written more concisely\n ///\n-/// **Known problems:** Sometimes `.cloned()` requires stricter trait\n-/// bound than `.map(|e| e.clone())` (which works because of the coercion).\n-/// See [#498](https://github.com/rust-lang-nursery/rust-clippy/issues/498).\n+/// **Known problems:** None.\n ///\n /// **Example:**\n+///\n+/// ```rust\n+/// let x = vec![42, 43];\n+/// let y = x.iter();\n+/// let z = y.map(|i| *i);\n+/// ```\n+///\n+/// The correct use would be:\n+///\n /// ```rust\n-/// x.map(|e| e.clone());\n+/// let x = vec![42, 43];\n+/// let y = x.iter();\n+/// let z = y.cloned();\n /// ```\n declare_clippy_lint! {\n     pub MAP_CLONE,\n     style,\n-    \"using `.map(|x| x.clone())` to clone an iterator or option's contents\"\n+    \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct Pass;\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MAP_CLONE)\n+    }\n+}\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        // call to .map()\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n-            if method.ident.name == \"map\" && args.len() == 2 {\n-                match args[1].node {\n-                    ExprKind::Closure(_, ref decl, closure_eid, _, _) => {\n-                        let body = cx.tcx.hir.body(closure_eid);\n-                        let closure_expr = remove_blocks(&body.value);\n-                        if_chain! {\n-                            // nothing special in the argument, besides reference bindings\n-                            // (e.g. .map(|&x| x) )\n-                            if let Some(first_arg) = iter_input_pats(decl, body).next();\n-                            if let Some(arg_ident) = get_arg_ident(&first_arg.pat);\n-                            // the method is being called on a known type (option or iterator)\n-                            if let Some(type_name) = get_type_name(cx, expr, &args[0]);\n-                            then {\n-                                // We know that body.arguments is not empty at this point\n-                                let ty = cx.tables.pat_ty(&body.arguments[0].pat);\n-                                // look for derefs, for .map(|x| *x)\n-                                if only_derefs(cx, &*closure_expr, arg_ident) &&\n-                                    // .cloned() only removes one level of indirection, don't lint on more\n-                                    walk_ptrs_ty_depth(cx.tables.pat_ty(&first_arg.pat)).1 == 1\n-                                {\n-                                    // the argument is not an &mut T\n-                                    if let ty::Ref(_, _, mutbl) = ty.sty {\n-                                        if mutbl == MutImmutable {\n-                                            span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                                \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                                using `.cloned()`\", type_name),\n-                                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                                        }\n-                                    }\n-                                }\n-                                // explicit clone() calls ( .map(|x| x.clone()) )\n-                                else if let ExprKind::MethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n-                                    if clone_call.ident.name == \"clone\" &&\n-                                        clone_args.len() == 1 &&\n-                                        match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_name(cx, &clone_args[0], arg_ident)\n-                                    {\n-                                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                            using `.cloned()`\", type_name),\n-                                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                                    }\n-                                }\n-                            }\n-                        }\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n+        if in_macro(e.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let hir::ExprKind::MethodCall(ref method, _, ref args) = e.node;\n+            if args.len() == 2;\n+            if method.ident.as_str() == \"map\";\n+            let ty = cx.tables.expr_ty(&args[0]);\n+            if match_type(cx, ty, &paths::OPTION) || match_trait_method(cx, e, &paths::ITERATOR);\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].node;\n+            let closure_body = cx.tcx.hir.body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+            then {\n+                match closure_body.arguments[0].pat.node {\n+                    hir::PatKind::Ref(ref inner, _) => if let hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) = inner.node {\n+                        lint(cx, e.span, args[0].span, name, closure_expr);\n                     },\n-                    ExprKind::Path(ref path) => if match_qpath(path, &paths::CLONE) {\n-                        let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n-                        span_help_and_lint(\n-                            cx,\n-                            MAP_CLONE,\n-                            expr.span,\n-                            &format!(\n-                                \"you seem to be using .map() to clone the contents of an \\\n-                                 {}, consider using `.cloned()`\",\n-                                type_name\n-                            ),\n-                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")),\n-                        );\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => match closure_expr.node {\n+                        hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => lint(cx, e.span, args[0].span, name, inner),\n+                        hir::ExprKind::MethodCall(ref method, _, ref obj) => if method.ident.as_str() == \"clone\" && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n+                            lint(cx, e.span, args[0].span, name, &obj[0]);\n+                        }\n+                        _ => {},\n                     },\n-                    _ => (),\n+                    _ => {},\n                 }\n             }\n         }\n     }\n }\n \n-fn expr_eq_name(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n-    match expr.node {\n-        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-            let arg_segment = [\n-                PathSegment {\n-                    ident: id,\n-                    args: None,\n-                    infer_types: true,\n-                },\n-            ];\n-            !path.is_global() && SpanlessEq::new(cx).eq_path_segments(&path.segments[..], &arg_segment)\n-        },\n-        _ => false,\n-    }\n-}\n-\n-fn get_type_name(cx: &LateContext<'_, '_>, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n-    if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        Some(\"iterator\")\n-    } else if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(arg)), &paths::OPTION) {\n-        Some(\"Option\")\n-    } else {\n-        None\n-    }\n-}\n-\n-fn only_derefs(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n-    match expr.node {\n-        ExprKind::Unary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n-        _ => expr_eq_name(cx, expr, id),\n-    }\n-}\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MAP_CLONE)\n+fn lint(cx: &LateContext<'_, '_>, replace: Span, root: Span, name: Ident, path: &hir::Expr) {\n+    if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.node {\n+        if path.segments.len() == 1 && path.segments[0].ident == name {\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_CLONE,\n+                replace,\n+                \"You are using an explicit closure for cloning elements\",\n+                \"Consider calling the dedicated `cloned` method\",\n+                format!(\"{}.cloned()\", snippet(cx, root, \"..\")),\n+            )\n+        }\n     }\n }"}, {"sha": "2e66008838093cbb909ee7963f6ac02835bb8dd3", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 76, "deletions": 57, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/75965030c7f97f9e2be9d76e522c61d3a6e1f074/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75965030c7f97f9e2be9d76e522c61d3a6e1f074/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=75965030c7f97f9e2be9d76e522c61d3a6e1f074", "patch": "@@ -701,57 +701,76 @@ declare_clippy_lint! {\n     \"cast to the same type, e.g. `x as i32` where `x: i32`\"\n }\n \n-/// **What it does:** Checks for casts of a function pointer to a numeric type not enough to store address.\n+/// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n+/// more-strictly-aligned pointer\n ///\n-/// **Why is this bad?** Casting a function pointer to not eligible type could truncate the address value.\n+/// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n+/// behavior.\n ///\n /// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n-/// fn test_fn() -> i16;\n-/// let _ = test_fn as i32\n+/// let _ = (&1u8 as *const u8) as *const u16;\n+/// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n /// ```\n declare_clippy_lint! {\n-    pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+    pub CAST_PTR_ALIGNMENT,\n     correctness,\n-    \"cast function pointer to the numeric type with value truncation\"\n+    \"cast from a pointer to a more-strictly-aligned pointer\"\n }\n \n-/// **What it does:** Checks for casts of a function pointer to a numeric type except `usize`.\n+/// **What it does:** Checks for casts of function pointers to something other than usize\n ///\n-/// **Why is this bad?** Casting a function pointer to something other than `usize` is not a good style.\n+/// **Why is this bad?**\n+/// Casting a function pointer to anything other than usize/isize is not portable across\n+/// architectures, because you end up losing bits if the target type is too small or end up with a\n+/// bunch of extra bits that waste space and add more instructions to the final binary than\n+/// strictly necessary for the problem\n ///\n-/// **Known problems:** None.\n+/// Casting to isize also doesn't make sense since there are no signed addresses.\n+///\n+/// **Example**\n ///\n-/// **Example:**\n /// ```rust\n-/// fn test_fn() -> i16;\n-/// let _ = test_fn as i128\n+/// // Bad\n+/// fn fun() -> i32 {}\n+/// let a = fun as i64;\n+///\n+/// // Good\n+/// fn fun2() -> i32 {}\n+/// let a = fun2 as usize;\n /// ```\n declare_clippy_lint! {\n     pub FN_TO_NUMERIC_CAST,\n     style,\n-    \"cast function pointer to the numeric type\"\n+    \"casting a function pointer to a numeric type other than usize\"\n }\n \n-/// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n-/// more-strictly-aligned pointer\n+/// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n+/// store address.\n ///\n-/// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n-/// behavior.\n+/// **Why is this bad?**\n+/// Such a cast discards some bits of the function's address. If this is intended, it would be more\n+/// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n+/// a comment) to perform the truncation.\n ///\n-/// **Known problems:** None.\n+/// **Example**\n ///\n-/// **Example:**\n /// ```rust\n-/// let _ = (&1u8 as *const u8) as *const u16;\n-/// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+/// // Bad\n+/// fn fn1() -> i16 { 1 };\n+/// let _ = fn1 as i32;\n+///\n+/// // Better: Cast to usize first, then comment with the reason for the truncation\n+/// fn fn2() -> i16 { 1 };\n+/// let fn_ptr = fn2 as usize;\n+/// let fn_ptr_truncated = fn_ptr as i32;\n /// ```\n declare_clippy_lint! {\n-    pub CAST_PTR_ALIGNMENT,\n-    correctness,\n-    \"cast from a pointer to a more-strictly-aligned pointer\"\n+    pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+    style,\n+    \"casting a function pointer to a numeric type not wide enough to store the address\"\n }\n \n /// Returns the size in bits of an integral type.\n@@ -948,8 +967,7 @@ impl LintPass for CastPass {\n             CAST_LOSSLESS,\n             UNNECESSARY_CAST,\n             CAST_PTR_ALIGNMENT,\n-            FN_TO_NUMERIC_CAST,\n-            FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+            FN_TO_NUMERIC_CAST\n         )\n     }\n }\n@@ -958,6 +976,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Cast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n+            lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n             if let ExprKind::Lit(ref lit) = ex.node {\n                 use crate::syntax::ast::{LitIntType, LitKind};\n                 match lit.node {\n@@ -1034,37 +1053,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                 }\n             }\n \n-            match &cast_from.sty {\n-                ty::FnDef(..) |\n-                ty::FnPtr(..) => {\n-                    if cast_to.is_numeric() && cast_to.sty != ty::Uint(UintTy::Usize){\n-                        let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-                        let pointer_nbits = cx.tcx.data_layout.pointer_size.bits();\n-                        if to_nbits < pointer_nbits || (to_nbits == pointer_nbits && cast_to.is_signed()) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-                                expr.span,\n-                                &format!(\"casting a `{}` to `{}` may truncate the function address value.\", cast_from, cast_to),\n-                                \"if you need the address of the function, consider\",\n-                                format!(\"{} as usize\", &snippet(cx, ex.span, \"x\"))\n-                            );\n-                        } else {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                FN_TO_NUMERIC_CAST,\n-                                expr.span,\n-                                &format!(\"casting a `{}` to `{}` is bad style.\", cast_from, cast_to),\n-                                \"if you need the address of the function, consider\",\n-                                format!(\"{} as usize\", &snippet(cx, ex.span, \"x\"))\n-                            );\n-\n-                        };\n-                    }\n-                }\n-                _ => ()\n-            }\n-\n             if_chain!{\n                 if let ty::RawPtr(from_ptr_ty) = &cast_from.sty;\n                 if let ty::RawPtr(to_ptr_ty) = &cast_to.sty;\n@@ -1089,6 +1077,37 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     }\n }\n \n+fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    match cast_from.sty {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let from_snippet = snippet(cx, cast_expr.span, \"x\");\n+\n+            let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n+            if to_nbits < cx.tcx.data_layout.pointer_size.bits() {\n+                span_lint_and_sugg(\n+                    cx,\n+                    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+                    expr.span,\n+                    &format!(\"casting function pointer `{}` to `{}`, which truncates the value\", from_snippet, cast_to),\n+                    \"try\",\n+                    format!(\"{} as usize\", from_snippet)\n+                );\n+\n+            } else if cast_to.sty != ty::Uint(UintTy::Usize) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    FN_TO_NUMERIC_CAST,\n+                    expr.span,\n+                    &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n+                    \"try\",\n+                    format!(\"{} as usize\", from_snippet)\n+                );\n+            }\n+        },\n+        _ => {}\n+    }\n+}\n+\n /// **What it does:** Checks for types used in structs, parameters and `let`\n /// declarations above a certain complexity threshold.\n ///"}, {"sha": "fc8aa19dcf037c0b14025a0e24e6949994fc9fbd", "filename": "tests/ui/fn_to_numeric_cast.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Ffn_to_numeric_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Ffn_to_numeric_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn_to_numeric_cast.rs?ref=75965030c7f97f9e2be9d76e522c61d3a6e1f074", "patch": "@@ -0,0 +1,50 @@\n+// only-64bit\n+#![feature(tool_lints)]\n+\n+#![warn(clippy::fn_to_numeric_cast, clippy::fn_to_numeric_cast_with_truncation)]\n+\n+fn foo() -> String { String::new() }\n+\n+fn test_function_to_numeric_cast() {\n+    let _ = foo as i8;\n+    let _ = foo as i16;\n+    let _ = foo as i32;\n+    let _ = foo as i64;\n+    let _ = foo as i128;\n+    let _ = foo as isize;\n+\n+    let _ = foo as u8;\n+    let _ = foo as u16;\n+    let _ = foo as u32;\n+    let _ = foo as u64;\n+    let _ = foo as u128;\n+\n+    // Casting to usize is OK and should not warn\n+    let _ = foo as usize;\n+}\n+\n+fn test_function_var_to_numeric_cast() {\n+    let abc: fn() -> String = foo;\n+\n+    let _ = abc as i8;\n+    let _ = abc as i16;\n+    let _ = abc as i32;\n+    let _ = abc as i64;\n+    let _ = abc as i128;\n+    let _ = abc as isize;\n+\n+    let _ = abc as u8;\n+    let _ = abc as u16;\n+    let _ = abc as u32;\n+    let _ = abc as u64;\n+    let _ = abc as u128;\n+\n+    // Casting to usize is OK and should not warn\n+    let _ = abc as usize;\n+}\n+\n+fn fn_with_fn_args(f: fn(i32) -> i32) -> i32 {\n+    f as i32\n+}\n+\n+fn main() {}"}, {"sha": "29320f0d8ed8886668107cb4decc84254ff86f37", "filename": "tests/ui/fn_to_numeric_cast.stderr", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Ffn_to_numeric_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Ffn_to_numeric_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn_to_numeric_cast.stderr?ref=75965030c7f97f9e2be9d76e522c61d3a6e1f074", "patch": "@@ -0,0 +1,144 @@\n+error: casting function pointer `foo` to `i8`, which truncates the value\n+ --> $DIR/fn_to_numeric_cast.rs:9:13\n+  |\n+9 |     let _ = foo as i8;\n+  |             ^^^^^^^^^ help: try: `foo as usize`\n+  |\n+  = note: `-D clippy::fn-to-numeric-cast-with-truncation` implied by `-D warnings`\n+\n+error: casting function pointer `foo` to `i16`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:10:13\n+   |\n+10 |     let _ = foo as i16;\n+   |             ^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `i32`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:11:13\n+   |\n+11 |     let _ = foo as i32;\n+   |             ^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `i64`\n+  --> $DIR/fn_to_numeric_cast.rs:12:13\n+   |\n+12 |     let _ = foo as i64;\n+   |             ^^^^^^^^^^ help: try: `foo as usize`\n+   |\n+   = note: `-D clippy::fn-to-numeric-cast` implied by `-D warnings`\n+\n+error: casting function pointer `foo` to `i128`\n+  --> $DIR/fn_to_numeric_cast.rs:13:13\n+   |\n+13 |     let _ = foo as i128;\n+   |             ^^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `isize`\n+  --> $DIR/fn_to_numeric_cast.rs:14:13\n+   |\n+14 |     let _ = foo as isize;\n+   |             ^^^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `u8`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:16:13\n+   |\n+16 |     let _ = foo as u8;\n+   |             ^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `u16`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:17:13\n+   |\n+17 |     let _ = foo as u16;\n+   |             ^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `u32`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:18:13\n+   |\n+18 |     let _ = foo as u32;\n+   |             ^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `u64`\n+  --> $DIR/fn_to_numeric_cast.rs:19:13\n+   |\n+19 |     let _ = foo as u64;\n+   |             ^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `foo` to `u128`\n+  --> $DIR/fn_to_numeric_cast.rs:20:13\n+   |\n+20 |     let _ = foo as u128;\n+   |             ^^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: casting function pointer `abc` to `i8`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:29:13\n+   |\n+29 |     let _ = abc as i8;\n+   |             ^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `i16`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:30:13\n+   |\n+30 |     let _ = abc as i16;\n+   |             ^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `i32`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:31:13\n+   |\n+31 |     let _ = abc as i32;\n+   |             ^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `i64`\n+  --> $DIR/fn_to_numeric_cast.rs:32:13\n+   |\n+32 |     let _ = abc as i64;\n+   |             ^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `i128`\n+  --> $DIR/fn_to_numeric_cast.rs:33:13\n+   |\n+33 |     let _ = abc as i128;\n+   |             ^^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `isize`\n+  --> $DIR/fn_to_numeric_cast.rs:34:13\n+   |\n+34 |     let _ = abc as isize;\n+   |             ^^^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `u8`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:36:13\n+   |\n+36 |     let _ = abc as u8;\n+   |             ^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `u16`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:37:13\n+   |\n+37 |     let _ = abc as u16;\n+   |             ^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `u32`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:38:13\n+   |\n+38 |     let _ = abc as u32;\n+   |             ^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `u64`\n+  --> $DIR/fn_to_numeric_cast.rs:39:13\n+   |\n+39 |     let _ = abc as u64;\n+   |             ^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `abc` to `u128`\n+  --> $DIR/fn_to_numeric_cast.rs:40:13\n+   |\n+40 |     let _ = abc as u128;\n+   |             ^^^^^^^^^^^ help: try: `abc as usize`\n+\n+error: casting function pointer `f` to `i32`, which truncates the value\n+  --> $DIR/fn_to_numeric_cast.rs:47:5\n+   |\n+47 |     f as i32\n+   |     ^^^^^^^^ help: try: `f as usize`\n+\n+error: aborting due to 23 previous errors\n+"}, {"sha": "11a5316a367e0ca441f543500951c4da49b958be", "filename": "tests/ui/map_clone.rs", "status": "modified", "additions": 6, "deletions": 102, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.rs?ref=75965030c7f97f9e2be9d76e522c61d3a6e1f074", "patch": "@@ -1,105 +1,9 @@\n #![feature(tool_lints)]\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(clippy::missing_docs_in_private_items)]\n \n-\n-#![warn(clippy::map_clone)]\n-\n-#![allow(clippy::clone_on_copy, unused)]\n-\n-use std::ops::Deref;\n-\n-fn map_clone_iter() {\n-    let x = [1,2,3];\n-    x.iter().map(|y| y.clone());\n-\n-    x.iter().map(|&y| y);\n-\n-    x.iter().map(|y| *y);\n-\n-    x.iter().map(|y| { y.clone() });\n-\n-    x.iter().map(|&y| { y });\n-\n-    x.iter().map(|y| { *y });\n-\n-    x.iter().map(Clone::clone);\n-\n-}\n-\n-fn map_clone_option() {\n-    let x = Some(4);\n-    x.as_ref().map(|y| y.clone());\n-\n-    x.as_ref().map(|&y| y);\n-\n-    x.as_ref().map(|y| *y);\n-\n+fn main() {\n+    let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();\n+    let _: Vec<String> = vec![String::new()].iter().map(|x| x.clone()).collect();\n+    let _: Vec<u32> = vec![42, 43].iter().map(|&x| x).collect();\n }\n-\n-fn not_linted_option() {\n-    let x = Some(5);\n-\n-    // Not linted: other statements\n-    x.as_ref().map(|y| {\n-        println!(\"y: {}\", y);\n-        y.clone()\n-    });\n-\n-    // Not linted: argument bindings\n-    let x = Some((6, 7));\n-    x.map(|(y, _)| y.clone());\n-\n-    // Not linted: cloning something else\n-    x.map(|y| y.0.clone());\n-\n-    // Not linted: no dereferences\n-    x.map(|y| y);\n-\n-    // Not linted: multiple dereferences\n-    let _: Option<(i32, i32)> = x.as_ref().as_ref().map(|&&x| x);\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Wrapper<T>(T);\n-impl<T> Wrapper<T> {\n-    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Wrapper<U> {\n-        Wrapper(f(self.0))\n-    }\n-}\n-\n-fn map_clone_other() {\n-    let eight = 8;\n-    let x = Wrapper(&eight);\n-\n-    // Not linted: not a linted type\n-    x.map(|y| y.clone());\n-    x.map(|&y| y);\n-    x.map(|y| *y);\n-}\n-\n-#[derive(Copy, Clone)]\n-struct UnusualDeref;\n-static NINE: i32 = 9;\n-\n-impl Deref for UnusualDeref {\n-    type Target = i32;\n-    fn deref(&self) -> &i32 { &NINE }\n-}\n-\n-fn map_clone_deref() {\n-    let x = Some(UnusualDeref);\n-    let _: Option<UnusualDeref> = x.as_ref().map(|y| *y);\n-\n-\n-    // Not linted: using deref conversion\n-    let _: Option<i32> = x.map(|y| *y);\n-\n-    // Not linted: using regular deref but also deref conversion\n-    let _: Option<i32> = x.as_ref().map(|y| **y);\n-}\n-\n-// stuff that used to be a false positive\n-fn former_false_positive() {\n-    vec![1].iter_mut().map(|x| *x); // #443\n-}\n-\n-fn main() { }"}, {"sha": "e80983cdbf7f05023b9d33083d1eff73b53fb993", "filename": "tests/ui/map_clone.stderr", "status": "modified", "additions": 21, "deletions": 101, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Fmap_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75965030c7f97f9e2be9d76e522c61d3a6e1f074/tests%2Fui%2Fmap_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.stderr?ref=75965030c7f97f9e2be9d76e522c61d3a6e1f074", "patch": "@@ -1,102 +1,22 @@\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:12:5\n-   |\n-12 |     x.iter().map(|y| y.clone());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::map-clone` implied by `-D warnings`\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:14:5\n-   |\n-14 |     x.iter().map(|&y| y);\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:16:5\n-   |\n-16 |     x.iter().map(|y| *y);\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:18:5\n-   |\n-18 |     x.iter().map(|y| { y.clone() });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:20:5\n-   |\n-20 |     x.iter().map(|&y| { y });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:22:5\n-   |\n-22 |     x.iter().map(|y| { *y });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:24:5\n-   |\n-24 |     x.iter().map(Clone::clone);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:30:5\n-   |\n-30 |     x.as_ref().map(|y| y.clone());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:32:5\n-   |\n-32 |     x.as_ref().map(|&y| y);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:34:5\n-   |\n-34 |     x.as_ref().map(|y| *y);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:90:35\n-   |\n-90 |     let _: Option<UnusualDeref> = x.as_ref().map(|y| *y);\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: aborting due to 11 previous errors\n+error: You are using an explicit closure for cloning elements\n+ --> $DIR/map_clone.rs:6:22\n+  |\n+6 |     let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();\n+  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![5_i8; 6].iter().cloned()`\n+  |\n+  = note: `-D clippy::map-clone` implied by `-D warnings`\n+\n+error: You are using an explicit closure for cloning elements\n+ --> $DIR/map_clone.rs:7:26\n+  |\n+7 |     let _: Vec<String> = vec![String::new()].iter().map(|x| x.clone()).collect();\n+  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![String::new()].iter().cloned()`\n+\n+error: You are using an explicit closure for cloning elements\n+ --> $DIR/map_clone.rs:8:23\n+  |\n+8 |     let _: Vec<u32> = vec![42, 43].iter().map(|&x| x).collect();\n+  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider calling the dedicated `cloned` method: `vec![42, 43].iter().cloned()`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "8387586c3e94a9ad30ab697a01d1d1c05b2dde93", "filename": "tests/ui/types_fn_to_int.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/87f6d9e7f94af1e2c192a68c997e6b247bba5d06/tests%2Fui%2Ftypes_fn_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87f6d9e7f94af1e2c192a68c997e6b247bba5d06/tests%2Fui%2Ftypes_fn_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypes_fn_to_int.rs?ref=87f6d9e7f94af1e2c192a68c997e6b247bba5d06", "patch": "@@ -1,22 +0,0 @@\n-enum Foo {\n-    A(usize),\n-    B\n-}\n-\n-fn bar() -> i32 {\n-    0i32\n-}\n-\n-fn main() {\n-    let x = Foo::A;\n-    let _y = x as i32;\n-    let _y1 = Foo::A as i32;\n-    let _y = x as u32;\n-    let _z = bar as u32;\n-    let _y = bar as i64;\n-    let _y = bar as u64;\n-    let _z = Foo::A as i128;\n-    let _z = Foo::A as u128;\n-    let _z = bar as i128;\n-    let _z = bar as u128;\n-}"}, {"sha": "a06809b9bfd6d1a7fe3e033a39b6c689d38dee77", "filename": "tests/ui/types_fn_to_int.stderr", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/87f6d9e7f94af1e2c192a68c997e6b247bba5d06/tests%2Fui%2Ftypes_fn_to_int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87f6d9e7f94af1e2c192a68c997e6b247bba5d06/tests%2Fui%2Ftypes_fn_to_int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypes_fn_to_int.stderr?ref=87f6d9e7f94af1e2c192a68c997e6b247bba5d06", "patch": "@@ -1,66 +0,0 @@\n-error: casting a `fn(usize) -> Foo {Foo::A}` to `i32` may truncate the function address value.\n-  --> $DIR/types_fn_to_int.rs:12:14\n-   |\n-12 |     let _y = x as i32;\n-   |              ^^^^^^^^ help: if you need the address of the function, consider: `x as usize`\n-   |\n-   = note: #[deny(clippy::fn_to_numeric_cast_with_truncation)] on by default\n-\n-error: casting a `fn(usize) -> Foo {Foo::A}` to `i32` may truncate the function address value.\n-  --> $DIR/types_fn_to_int.rs:13:15\n-   |\n-13 |     let _y1 = Foo::A as i32;\n-   |               ^^^^^^^^^^^^^ help: if you need the address of the function, consider: `Foo::A as usize`\n-\n-error: casting a `fn(usize) -> Foo {Foo::A}` to `u32` may truncate the function address value.\n-  --> $DIR/types_fn_to_int.rs:14:14\n-   |\n-14 |     let _y = x as u32;\n-   |              ^^^^^^^^ help: if you need the address of the function, consider: `x as usize`\n-\n-error: casting a `fn() -> i32 {bar}` to `u32` may truncate the function address value.\n-  --> $DIR/types_fn_to_int.rs:15:14\n-   |\n-15 |     let _z = bar as u32;\n-   |              ^^^^^^^^^^ help: if you need the address of the function, consider: `bar as usize`\n-\n-error: casting a `fn() -> i32 {bar}` to `i64` may truncate the function address value.\n-  --> $DIR/types_fn_to_int.rs:16:14\n-   |\n-16 |     let _y = bar as i64;\n-   |              ^^^^^^^^^^ help: if you need the address of the function, consider: `bar as usize`\n-\n-error: casting a `fn() -> i32 {bar}` to `u64` is bad style.\n-  --> $DIR/types_fn_to_int.rs:17:14\n-   |\n-17 |     let _y = bar as u64;\n-   |              ^^^^^^^^^^ help: if you need the address of the function, consider: `bar as usize`\n-   |\n-   = note: `-D clippy::fn-to-numeric-cast` implied by `-D warnings`\n-\n-error: casting a `fn(usize) -> Foo {Foo::A}` to `i128` is bad style.\n-  --> $DIR/types_fn_to_int.rs:18:14\n-   |\n-18 |     let _z = Foo::A as i128;\n-   |              ^^^^^^^^^^^^^^ help: if you need the address of the function, consider: `Foo::A as usize`\n-\n-error: casting a `fn(usize) -> Foo {Foo::A}` to `u128` is bad style.\n-  --> $DIR/types_fn_to_int.rs:19:14\n-   |\n-19 |     let _z = Foo::A as u128;\n-   |              ^^^^^^^^^^^^^^ help: if you need the address of the function, consider: `Foo::A as usize`\n-\n-error: casting a `fn() -> i32 {bar}` to `i128` is bad style.\n-  --> $DIR/types_fn_to_int.rs:20:14\n-   |\n-20 |     let _z = bar as i128;\n-   |              ^^^^^^^^^^^ help: if you need the address of the function, consider: `bar as usize`\n-\n-error: casting a `fn() -> i32 {bar}` to `u128` is bad style.\n-  --> $DIR/types_fn_to_int.rs:21:14\n-   |\n-21 |     let _z = bar as u128;\n-   |              ^^^^^^^^^^^ help: if you need the address of the function, consider: `bar as usize`\n-\n-error: aborting due to 10 previous errors\n-"}]}