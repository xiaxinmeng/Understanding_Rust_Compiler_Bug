{"sha": "f76f8ce63bc160b127356c01624bbc8442844c22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NmY4Y2U2M2JjMTYwYjEyNzM1NmMwMTYyNGJiYzg0NDI4NDRjMjI=", "commit": {"author": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-10-13T01:12:26Z"}, "committer": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-10-13T01:12:26Z"}, "message": "Correct fcntl behavior", "tree": {"sha": "b75dd6de7a2deb83770317722ceb6b2714ed8e94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75dd6de7a2deb83770317722ceb6b2714ed8e94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f76f8ce63bc160b127356c01624bbc8442844c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f76f8ce63bc160b127356c01624bbc8442844c22", "html_url": "https://github.com/rust-lang/rust/commit/f76f8ce63bc160b127356c01624bbc8442844c22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f76f8ce63bc160b127356c01624bbc8442844c22/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73fae1b28b3a12a5c22df71fc7be5fdb5f66e67", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73fae1b28b3a12a5c22df71fc7be5fdb5f66e67", "html_url": "https://github.com/rust-lang/rust/commit/d73fae1b28b3a12a5c22df71fc7be5fdb5f66e67"}], "stats": {"total": 17, "additions": 11, "deletions": 6}, "files": [{"sha": "4d93ca4fd31b785cc23168451126f67ae88acd6a", "filename": "src/shims/fs.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f76f8ce63bc160b127356c01624bbc8442844c22/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f76f8ce63bc160b127356c01624bbc8442844c22/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=f76f8ce63bc160b127356c01624bbc8442844c22", "patch": "@@ -9,7 +9,6 @@ use crate::*;\n \n pub struct FileHandle {\n     file: File,\n-    flag: i32,\n }\n \n pub struct FileHandler {\n@@ -79,13 +78,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let o_cloexec = this.eval_libc_i32(\"O_CLOEXEC\")?;\n         if flag & o_cloexec != 0 {\n-            // This flag is a noop for now because `std` already sets it.\n+            // We do not need to do anything for this flag because `std` already sets it.\n+            // (Technically we do not support *not* setting this flag, but we ignore that.)\n             mirror |= o_cloexec;\n         }\n         // If `flag` is not equal to `mirror`, there is an unsupported option enabled in `flag`,\n         // then we throw an error.\n         if flag != mirror {\n-            throw_unsup_format!(\"unsupported flags {:#x}\", flag);\n+            throw_unsup_format!(\"unsupported flags {:#x}\", flag & !mirror);\n         }\n \n         let path_bytes = this\n@@ -97,7 +97,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let fd = options.open(path).map(|file| {\n             let mut fh = &mut this.machine.file_handler;\n             fh.low += 1;\n-            fh.handles.insert(fh.low, FileHandle { file, flag });\n+            fh.handles.insert(fh.low, FileHandle { file });\n             fh.low\n         });\n \n@@ -108,7 +108,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         fd_op: OpTy<'tcx, Tag>,\n         cmd_op: OpTy<'tcx, Tag>,\n-        _arg_op: Option<OpTy<'tcx, Tag>>,\n+        _arg1_op: Option<OpTy<'tcx, Tag>>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -120,7 +120,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let cmd = this.read_scalar(cmd_op)?.to_i32()?;\n         // We only support getting the flags for a descriptor\n         if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n-            this.get_handle_and(fd, |handle| Ok(handle.flag))\n+            // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n+            // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n+            // always sets this flag when opening a file. However we still need to check that the\n+            // file itself is open.\n+            this.get_handle_and(fd, |_| Ok(0))?;\n+            this.eval_libc_i32(\"FD_CLOEXEC\")\n         } else {\n             throw_unsup_format!(\"The {:#x} command is not supported for `fcntl`)\", cmd);\n         }"}]}