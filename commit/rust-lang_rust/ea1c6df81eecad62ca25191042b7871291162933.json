{"sha": "ea1c6df81eecad62ca25191042b7871291162933", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMWM2ZGY4MWVlY2FkNjJjYTI1MTkxMDQyYjc4NzEyOTExNjI5MzM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-11T13:10:47Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-13T14:43:32Z"}, "message": "rustc: stop interning CodeExtent, it's small enough.", "tree": {"sha": "1b15aa95ddebd7d614f822d570757103f5420795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b15aa95ddebd7d614f822d570757103f5420795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea1c6df81eecad62ca25191042b7871291162933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea1c6df81eecad62ca25191042b7871291162933", "html_url": "https://github.com/rust-lang/rust/commit/ea1c6df81eecad62ca25191042b7871291162933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea1c6df81eecad62ca25191042b7871291162933/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da8b6e276e6894c3926610c1350e0d62ca83fdc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/da8b6e276e6894c3926610c1350e0d62ca83fdc7", "html_url": "https://github.com/rust-lang/rust/commit/da8b6e276e6894c3926610c1350e0d62ca83fdc7"}], "stats": {"total": 559, "additions": 239, "deletions": 320}, "files": [{"sha": "c1c195852f9492bddfe2406446ce1a4b78698b22", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -10,6 +10,7 @@\n \n use rustc_data_structures::graph;\n use cfg::*;\n+use middle::region::CodeExtent;\n use ty::{self, TyCtxt};\n use syntax::ast;\n use syntax::ptr::P;\n@@ -586,8 +587,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         scope_id: ast::NodeId,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = self.tcx.node_extent(from_expr.id);\n-        let target_scope = self.tcx.node_extent(scope_id);\n+        let mut scope = CodeExtent::Misc(from_expr.id);\n+        let target_scope = CodeExtent::Misc(scope_id);\n         let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n             data.exiting_scopes.push(scope.node_id());"}, {"sha": "3bbac8d6a64259ec513d70afbccb2dd5cc27c0b6", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'t\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -428,24 +428,24 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtentData\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use middle::region::CodeExtentData;\n+        use middle::region::CodeExtent;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            CodeExtentData::Misc(node_id) |\n-            CodeExtentData::DestructionScope(node_id) => {\n+            CodeExtent::Misc(node_id) |\n+            CodeExtent::DestructionScope(node_id) => {\n                 node_id.hash_stable(hcx, hasher);\n             }\n-            CodeExtentData::CallSiteScope(body_id) |\n-            CodeExtentData::ParameterScope(body_id) => {\n+            CodeExtent::CallSiteScope(body_id) |\n+            CodeExtent::ParameterScope(body_id) => {\n                 body_id.hash_stable(hcx, hasher);\n             }\n-            CodeExtentData::Remainder(block_remainder) => {\n+            CodeExtent::Remainder(block_remainder) => {\n                 block_remainder.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "c07b3b3c4be90bd445a407d1d901ef1289ce843b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -151,19 +151,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let scope_decorated_tag = match *scope {\n-                    region::CodeExtentData::Misc(_) => tag,\n-                    region::CodeExtentData::CallSiteScope(_) => {\n+                let scope_decorated_tag = match scope {\n+                    region::CodeExtent::Misc(_) => tag,\n+                    region::CodeExtent::CallSiteScope(_) => {\n                         \"scope of call-site for function\"\n                     }\n-                    region::CodeExtentData::ParameterScope(_) => {\n+                    region::CodeExtent::ParameterScope(_) => {\n                         \"scope of function body\"\n                     }\n-                    region::CodeExtentData::DestructionScope(_) => {\n+                    region::CodeExtent::DestructionScope(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::CodeExtentData::Remainder(r) => {\n+                    region::CodeExtent::Remainder(r) => {\n                         new_string = format!(\"block suffix following statement {}\",\n                                              r.first_statement_index);\n                         &new_string[..]"}, {"sha": "1ecc277c7ca4d27dd407cfc9ff39b1f910c5ecdb", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -1324,7 +1324,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_regions_and_report_errors(&self,\n                                              region_context: DefId,\n-                                             region_map: &RegionMaps<'tcx>,\n+                                             region_map: &RegionMaps,\n                                              free_regions: &FreeRegionMap<'tcx>) {\n         let region_rels = RegionRelations::new(self.tcx,\n                                                region_context,"}, {"sha": "cce253c1a1a43b8e77b73e5d5e66bf02e005d25b", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -124,20 +124,20 @@ struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     graph_name: String,\n     region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n     map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FxHashMap<Node<'tcx>, usize>,\n+    node_ids: FxHashMap<Node, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n-enum Node<'tcx> {\n+enum Node {\n     RegionVid(ty::RegionVid),\n-    Region(ty::RegionKind<'tcx>),\n+    Region(ty::RegionKind),\n }\n \n // type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n enum Edge<'tcx> {\n     Constraint(Constraint<'tcx>),\n-    EnclScope(CodeExtent<'tcx>, CodeExtent<'tcx>),\n+    EnclScope(CodeExtent, CodeExtent),\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n@@ -176,7 +176,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node<'tcx>;\n+    type Node = Node;\n     type Edge = Edge<'tcx>;\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(&*self.graph_name).unwrap()\n@@ -209,7 +209,7 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn constraint_to_nodes<'tcx>(c: &Constraint<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n+fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     match *c {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n@@ -222,7 +222,7 @@ fn constraint_to_nodes<'tcx>(c: &Constraint<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n     }\n }\n \n-fn edge_to_nodes<'tcx>(e: &Edge<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n+fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n     match *e {\n         Edge::Constraint(ref c) => constraint_to_nodes(c),\n         Edge::EnclScope(sub, sup) => {\n@@ -233,9 +233,9 @@ fn edge_to_nodes<'tcx>(e: &Edge<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n }\n \n impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node<'tcx>;\n+    type Node = Node;\n     type Edge = Edge<'tcx>;\n-    fn nodes(&self) -> dot::Nodes<Node<'tcx>> {\n+    fn nodes(&self) -> dot::Nodes<Node> {\n         let mut set = FxHashSet();\n         for node in self.node_ids.keys() {\n             set.insert(*node);\n@@ -250,12 +250,12 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n-    fn source(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n+    fn source(&self, edge: &Edge<'tcx>) -> Node {\n         let (n1, _) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n-    fn target(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n+    fn target(&self, edge: &Edge<'tcx>) -> Node {\n         let (_, n2) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2"}, {"sha": "99b140f690a4848cda6ee003634a45f7cb321ed9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -271,7 +271,7 @@ enum PassArgs {\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n-               region_maps: &'a RegionMaps<'tcx>,\n+               region_maps: &'a RegionMaps,\n                infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> Self\n     {\n@@ -283,7 +283,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n                         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        region_maps: &'a RegionMaps<'tcx>,\n+                        region_maps: &'a RegionMaps,\n                         options: mc::MemCategorizationOptions)\n                -> Self\n     {"}, {"sha": "6a21bdc19e0915b2ade6bf1ebb69e59a0e9a8d92", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -35,7 +35,7 @@ pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub context: DefId,\n \n     /// region maps for the given context\n-    pub region_maps: &'a RegionMaps<'tcx>,\n+    pub region_maps: &'a RegionMaps,\n \n     /// free-region relationships\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         context: DefId,\n-        region_maps: &'a RegionMaps<'tcx>,\n+        region_maps: &'a RegionMaps,\n         free_regions: &'a FreeRegionMap<'tcx>,\n     ) -> Self {\n         Self {"}, {"sha": "d0adf51d79e68675a59672003c9c96b4d31a54f6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -290,7 +290,7 @@ impl ast_node for hir::Pat {\n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    pub region_maps: &'a RegionMaps<'tcx>,\n+    pub region_maps: &'a RegionMaps,\n     options: MemCategorizationOptions,\n }\n \n@@ -406,15 +406,15 @@ impl MutabilityCategory {\n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     /// Context should be the `DefId` we use to fetch region-maps.\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               region_maps: &'a RegionMaps<'tcx>)\n+               region_maps: &'a RegionMaps)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext::with_options(infcx,\n                                                region_maps,\n                                                MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        region_maps: &'a RegionMaps<'tcx>,\n+                        region_maps: &'a RegionMaps,\n                         options: MemCategorizationOptions)\n                         -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext {\n@@ -839,7 +839,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn temporary_scope(&self, id: ast::NodeId) -> (ty::Region<'tcx>, ty::Region<'tcx>)\n     {\n         let (scope, old_scope) =\n-            self.region_maps.old_and_new_temporary_scope(self.tcx(), id);\n+            self.region_maps.old_and_new_temporary_scope(id);\n         (self.tcx().mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic"}, {"sha": "331683381a431e7c58a93d9266fb728ab8c7131a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 96, "deletions": 136, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -22,7 +22,6 @@ use ty;\n \n use std::mem;\n use std::rc::Rc;\n-use serialize;\n use syntax::codemap;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -35,11 +34,6 @@ use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use mir::transform::MirSource;\n \n-pub type CodeExtent<'tcx> = &'tcx CodeExtentData;\n-\n-impl<'tcx> serialize::UseSpecializedEncodable for CodeExtent<'tcx> {}\n-impl<'tcx> serialize::UseSpecializedDecodable for CodeExtent<'tcx> {}\n-\n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n ///\n@@ -102,7 +96,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for CodeExtent<'tcx> {}\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n-pub enum CodeExtentData {\n+pub enum CodeExtent {\n     Misc(ast::NodeId),\n \n     // extent of the call-site for a function or closure (outlives\n@@ -131,9 +125,9 @@ pub enum CodeExtentData {\n /// * the subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n-///   includes EXPR_1 as well, then do not use `CodeExtentData::Remainder`,\n+///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n ///   but instead another `CodeExtent` that encompasses the whole block,\n-///   e.g. `CodeExtentData::Misc`.\n+///   e.g. `CodeExtent::Misc`.\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n@@ -144,21 +138,21 @@ pub struct BlockRemainder {\n     pub first_statement_index: u32,\n }\n \n-impl CodeExtentData {\n+impl CodeExtent {\n     /// Returns a node id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n-            CodeExtentData::Misc(node_id) => node_id,\n+            CodeExtent::Misc(node_id) => node_id,\n \n             // These cases all return rough approximations to the\n             // precise extent denoted by `self`.\n-            CodeExtentData::Remainder(br) => br.block,\n-            CodeExtentData::DestructionScope(node_id) => node_id,\n-            CodeExtentData::CallSiteScope(body_id) |\n-            CodeExtentData::ParameterScope(body_id) => body_id.node_id,\n+            CodeExtent::Remainder(br) => br.block,\n+            CodeExtent::DestructionScope(node_id) => node_id,\n+            CodeExtent::CallSiteScope(body_id) |\n+            CodeExtent::ParameterScope(body_id) => body_id.node_id,\n         }\n     }\n \n@@ -169,12 +163,12 @@ impl CodeExtentData {\n         match hir_map.find(self.node_id()) {\n             Some(hir_map::NodeBlock(ref blk)) => {\n                 match *self {\n-                    CodeExtentData::CallSiteScope(_) |\n-                    CodeExtentData::ParameterScope(_) |\n-                    CodeExtentData::Misc(_) |\n-                    CodeExtentData::DestructionScope(_) => Some(blk.span),\n+                    CodeExtent::CallSiteScope(_) |\n+                    CodeExtent::ParameterScope(_) |\n+                    CodeExtent::Misc(_) |\n+                    CodeExtent::DestructionScope(_) => Some(blk.span),\n \n-                    CodeExtentData::Remainder(r) => {\n+                    CodeExtent::Remainder(r) => {\n                         assert_eq!(r.block, blk.id);\n                         // Want span for extent starting after the\n                         // indexed statement and ending at end of\n@@ -197,7 +191,7 @@ impl CodeExtentData {\n }\n \n /// The region maps encode information about region relationships.\n-pub struct RegionMaps<'tcx> {\n+pub struct RegionMaps {\n     /// If not empty, this body is the root of this region hierarchy.\n     root_body: Option<hir::BodyId>,\n \n@@ -212,29 +206,29 @@ pub struct RegionMaps<'tcx> {\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n+    scope_map: FxHashMap<CodeExtent, CodeExtent>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: NodeMap<CodeExtent<'tcx>>,\n+    var_map: NodeMap<CodeExtent>,\n \n     /// maps from a node-id to the associated destruction scope (if any)\n-    destruction_scopes: NodeMap<CodeExtent<'tcx>>,\n+    destruction_scopes: NodeMap<CodeExtent>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n     /// to the cleanup scope id. For rvalues not present in this\n     /// table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n-    rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n+    rvalue_scopes: NodeMap<CodeExtent>,\n \n     /// Records the value of rvalue scopes before they were shrunk by\n     /// #36082, for error reporting.\n     ///\n     /// FIXME: this should be temporary. Remove this by 1.18.0 or\n     /// so.\n-    shrunk_rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n+    shrunk_rvalue_scopes: NodeMap<CodeExtent>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -250,7 +244,7 @@ pub struct RegionMaps<'tcx> {\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub struct Context<'tcx> {\n+pub struct Context {\n     /// the root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n@@ -260,19 +254,19 @@ pub struct Context<'tcx> {\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: Option<CodeExtent<'tcx>>,\n+    var_parent: Option<CodeExtent>,\n \n     /// region parent of expressions etc\n-    parent: Option<CodeExtent<'tcx>>,\n+    parent: Option<CodeExtent>,\n }\n \n struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Generated maps:\n-    region_maps: &'a mut RegionMaps<'tcx>,\n+    region_maps: &'a mut RegionMaps,\n \n-    cx: Context<'tcx>,\n+    cx: Context,\n \n     map: &'a hir_map::Map<'tcx>,\n \n@@ -300,7 +294,7 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n }\n \n \n-impl<'tcx> RegionMaps<'tcx> {\n+impl<'tcx> RegionMaps {\n     pub fn new() -> Self {\n         RegionMaps {\n             root_body: None,\n@@ -315,8 +309,8 @@ impl<'tcx> RegionMaps<'tcx> {\n     }\n \n     pub fn record_code_extent(&mut self,\n-                              child: CodeExtent<'tcx>,\n-                              parent: Option<CodeExtent<'tcx>>) {\n+                              child: CodeExtent,\n+                              parent: Option<CodeExtent>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n \n         if let Some(p) = parent {\n@@ -325,24 +319,24 @@ impl<'tcx> RegionMaps<'tcx> {\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let &CodeExtentData::DestructionScope(n) = child {\n+        if let CodeExtent::DestructionScope(n) = child {\n             self.destruction_scopes.insert(n, child);\n         }\n     }\n \n-    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent<'tcx>, CodeExtent<'tcx>) {\n+    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent, CodeExtent) {\n         for (&child, &parent) in &self.scope_map {\n             e(child, parent)\n         }\n     }\n \n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent<'tcx>) {\n-        for (child, parent) in self.var_map.iter() {\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent) {\n+        for (child, &parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n-    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent<'tcx>> {\n+    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n@@ -366,48 +360,46 @@ impl<'tcx> RegionMaps<'tcx> {\n         }\n     }\n \n-    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n+    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n+    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n-    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n+    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.shrunk_rvalue_scopes.insert(var, lifetime);\n     }\n \n-    pub fn opt_encl_scope(&self, id: CodeExtent<'tcx>) -> Option<CodeExtent<'tcx>> {\n+    pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.scope_map.get(&id).cloned()\n     }\n \n     #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: CodeExtent<'tcx>) -> CodeExtent<'tcx> {\n+    pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent<'tcx> {\n+    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n         match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope2<'a, 'gcx: 'tcx>(&self,\n-                                            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            expr_id: ast::NodeId)\n-                                            -> (Option<CodeExtent<'tcx>>, bool) {\n-        let temporary_scope = self.temporary_scope(tcx, expr_id);\n+    pub fn temporary_scope2(&self, expr_id: ast::NodeId)\n+                            -> (Option<CodeExtent>, bool) {\n+        let temporary_scope = self.temporary_scope(expr_id);\n         let was_shrunk = match self.shrunk_rvalue_scopes.get(&expr_id) {\n             Some(&s) => {\n                 info!(\"temporary_scope2({:?}, scope={:?}, shrunk={:?})\",\n@@ -420,23 +412,18 @@ impl<'tcx> RegionMaps<'tcx> {\n         (temporary_scope, was_shrunk)\n     }\n \n-    pub fn old_and_new_temporary_scope<'a, 'gcx: 'tcx>(&self,\n-                                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                       expr_id: ast::NodeId)\n-                                                       -> (Option<CodeExtent<'tcx>>,\n-                                                           Option<CodeExtent<'tcx>>)\n+    pub fn old_and_new_temporary_scope(&self, expr_id: ast::NodeId)\n+                                       -> (Option<CodeExtent>,\n+                                           Option<CodeExtent>)\n     {\n-        let temporary_scope = self.temporary_scope(tcx, expr_id);\n+        let temporary_scope = self.temporary_scope(expr_id);\n         (temporary_scope,\n          self.shrunk_rvalue_scopes\n              .get(&expr_id).cloned()\n              .or(temporary_scope))\n     }\n \n-    pub fn temporary_scope<'a, 'gcx: 'tcx>(&self,\n-                                           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                           expr_id: ast::NodeId)\n-                                           -> Option<CodeExtent<'tcx>> {\n+    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -449,11 +436,11 @@ impl<'tcx> RegionMaps<'tcx> {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = tcx.node_extent(expr_id);\n+        let mut id = CodeExtent::Misc(expr_id);\n \n-        while let Some(&p) = self.scope_map.get(id) {\n-            match *p {\n-                CodeExtentData::DestructionScope(..) => {\n+        while let Some(&p) = self.scope_map.get(&id) {\n+            match p {\n+                CodeExtent::DestructionScope(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n                     return Some(id);\n@@ -466,7 +453,7 @@ impl<'tcx> RegionMaps<'tcx> {\n         return None;\n     }\n \n-    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind<'tcx> {\n+    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n@@ -508,19 +495,19 @@ impl<'tcx> RegionMaps<'tcx> {\n     /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n     /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n     pub fn nearest_common_ancestor(&self,\n-                                   scope_a: CodeExtent<'tcx>,\n-                                   scope_b: CodeExtent<'tcx>)\n-                                   -> CodeExtent<'tcx> {\n+                                   scope_a: CodeExtent,\n+                                   scope_b: CodeExtent)\n+                                   -> CodeExtent {\n         if scope_a == scope_b { return scope_a; }\n \n         /// [1] The initial values for `a_buf` and `b_buf` are not used.\n         /// The `ancestors_of` function will return some prefix that\n         /// is re-initialized with new values (or else fallback to a\n         /// heap-allocated vector).\n         let mut a_buf: [CodeExtent; 32] = [scope_a /* [1] */; 32];\n-        let mut a_vec: Vec<CodeExtent<'tcx>> = vec![];\n+        let mut a_vec: Vec<CodeExtent> = vec![];\n         let mut b_buf: [CodeExtent; 32] = [scope_b /* [1] */; 32];\n-        let mut b_vec: Vec<CodeExtent<'tcx>> = vec![];\n+        let mut b_vec: Vec<CodeExtent> = vec![];\n         let scope_map = &self.scope_map;\n         let a_ancestors = ancestors_of(scope_map, scope_a, &mut a_buf, &mut a_vec);\n         let b_ancestors = ancestors_of(scope_map, scope_b, &mut b_buf, &mut b_vec);\n@@ -544,8 +531,8 @@ impl<'tcx> RegionMaps<'tcx> {\n             let a_root_scope = a_ancestors[a_index];\n             let b_root_scope = a_ancestors[a_index];\n             return match (a_root_scope, b_root_scope) {\n-                (&CodeExtentData::DestructionScope(a_root_id),\n-                 &CodeExtentData::DestructionScope(b_root_id)) => {\n+                (CodeExtent::DestructionScope(a_root_id),\n+                 CodeExtent::DestructionScope(b_root_id)) => {\n                     if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -576,19 +563,19 @@ impl<'tcx> RegionMaps<'tcx> {\n             }\n         }\n \n-        fn ancestors_of<'a, 'tcx>(scope_map: &FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n-                                  scope: CodeExtent<'tcx>,\n-                                  buf: &'a mut [CodeExtent<'tcx>; 32],\n-                                  vec: &'a mut Vec<CodeExtent<'tcx>>)\n-                                  -> &'a [CodeExtent<'tcx>] {\n+        fn ancestors_of<'a, 'tcx>(scope_map: &FxHashMap<CodeExtent, CodeExtent>,\n+                                  scope: CodeExtent,\n+                                  buf: &'a mut [CodeExtent; 32],\n+                                  vec: &'a mut Vec<CodeExtent>)\n+                                  -> &'a [CodeExtent] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut scope = scope;\n \n             let mut i = 0;\n             while i < 32 {\n                 buf[i] = scope;\n                 match scope_map.get(&scope) {\n-                    Some(superscope) => scope = superscope,\n+                    Some(&superscope) => scope = superscope,\n                     _ => return &buf[..i+1]\n                 }\n                 i += 1;\n@@ -599,7 +586,7 @@ impl<'tcx> RegionMaps<'tcx> {\n             loop {\n                 vec.push(scope);\n                 match scope_map.get(&scope) {\n-                    Some(superscope) => scope = superscope,\n+                    Some(&superscope) => scope = superscope,\n                     _ => return &*vec\n                 }\n             }\n@@ -610,7 +597,7 @@ impl<'tcx> RegionMaps<'tcx> {\n     /// returns the outermost `CodeExtent` that the region outlives.\n     pub fn early_free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        br: &ty::EarlyBoundRegion)\n-                                       -> CodeExtent<'tcx> {\n+                                       -> CodeExtent {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n@@ -627,13 +614,13 @@ impl<'tcx> RegionMaps<'tcx> {\n             self.root_body.unwrap()\n         });\n \n-        tcx.intern_code_extent(CodeExtentData::CallSiteScope(body_id))\n+        CodeExtent::CallSiteScope(body_id)\n     }\n \n     /// Assuming that the provided region was defined within this `RegionMaps`,\n     /// returns the outermost `CodeExtent` that the region outlives.\n     pub fn free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n-                                 -> CodeExtent<'tcx> {\n+                                 -> CodeExtent {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n                 tcx.parent_def_id(def_id).unwrap()\n@@ -646,9 +633,7 @@ impl<'tcx> RegionMaps<'tcx> {\n         assert_eq!(param_owner, fr.scope);\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let body_id = tcx.hir.body_owned_by(param_owner_id);\n-\n-        tcx.intern_code_extent(CodeExtentData::CallSiteScope(body_id))\n+        CodeExtent::CallSiteScope(tcx.hir.body_owned_by(param_owner_id))\n     }\n }\n \n@@ -671,7 +656,6 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n-    let block_extent = visitor.new_node_extent_with_dtor(blk.id);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n@@ -698,11 +682,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     // `other_argument()` has run and also the call to `quux(..)`\n     // itself has returned.\n \n-    visitor.cx = Context {\n-        root_id: prev_cx.root_id,\n-        var_parent: Some(block_extent),\n-        parent: Some(block_extent),\n-    };\n+    visitor.enter_node_extent_with_dtor(blk.id);\n+    visitor.cx.var_parent = visitor.cx.parent;\n \n     {\n         // This block should be kept approximately in sync with\n@@ -718,17 +699,13 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // has the previous subscope in the block as a parent,\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n-                let stmt_extent = visitor.new_code_extent(\n-                    CodeExtentData::Remainder(BlockRemainder {\n+                visitor.enter_code_extent(\n+                    CodeExtent::Remainder(BlockRemainder {\n                         block: blk.id,\n                         first_statement_index: i as u32\n                     })\n                 );\n-                visitor.cx = Context {\n-                    root_id: prev_cx.root_id,\n-                    var_parent: Some(stmt_extent),\n-                    parent: Some(stmt_extent),\n-                };\n+                visitor.cx.var_parent = visitor.cx.parent;\n             }\n             visitor.visit_stmt(statement)\n         }\n@@ -749,7 +726,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n-    visitor.new_node_extent(pat.id);\n+    visitor.record_code_extent(CodeExtent::Misc(pat.id));\n \n     // If this is a binding then record the lifetime of that binding.\n     if let PatKind::Binding(..) = pat.node {\n@@ -769,20 +746,20 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n     // statement plus its destructors, and thus the extent for which\n     // regions referenced by the destructors need to survive.\n     visitor.terminating_scopes.insert(stmt_id);\n-    let stmt_extent = visitor.new_node_extent_with_dtor(stmt_id);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = Some(stmt_extent);\n+    visitor.enter_node_extent_with_dtor(stmt_id);\n+\n     intravisit::walk_stmt(visitor, stmt);\n+\n     visitor.cx.parent = prev_parent;\n }\n \n fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = Some(expr_extent);\n+    visitor.enter_node_extent_with_dtor(expr.id);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n@@ -822,7 +799,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             }\n \n             hir::ExprMatch(..) => {\n-                visitor.cx.var_parent = Some(expr_extent);\n+                visitor.cx.var_parent = visitor.cx.parent;\n             }\n \n             hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n@@ -1009,7 +986,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n         visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         expr: &hir::Expr,\n-        blk_id: CodeExtent<'tcx>)\n+        blk_id: CodeExtent)\n     {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n@@ -1059,7 +1036,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n-                                     blk_scope: CodeExtent<'tcx>,\n+                                     blk_scope: CodeExtent,\n                                      is_shrunk: bool) {\n         let mut expr = expr;\n         loop {\n@@ -1092,43 +1069,28 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n-    pub fn intern_code_extent(&mut self,\n-                              data: CodeExtentData,\n-                              parent: Option<CodeExtent<'tcx>>)\n-                              -> CodeExtent<'tcx> {\n-        let code_extent = self.tcx.intern_code_extent(data);\n-        self.region_maps.record_code_extent(code_extent, parent);\n-        code_extent\n-    }\n-\n-    pub fn intern_node(&mut self,\n-                       n: ast::NodeId,\n-                       parent: Option<CodeExtent<'tcx>>) -> CodeExtent<'tcx> {\n-        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n-    }\n-\n     /// Records the current parent (if any) as the parent of `child_scope`.\n-    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent<'tcx> {\n+    fn record_code_extent(&mut self, child_scope: CodeExtent) {\n         let parent = self.cx.parent;\n-        self.intern_code_extent(child_scope, parent)\n+        self.region_maps.record_code_extent(child_scope, parent);\n     }\n \n-    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent<'tcx> {\n-        self.new_code_extent(CodeExtentData::Misc(child_scope))\n+    /// Records the current parent (if any) as the parent of `child_scope`,\n+    /// and sets `child_scope` as the new current parent.\n+    fn enter_code_extent(&mut self, child_scope: CodeExtent) {\n+        self.record_code_extent(child_scope);\n+        self.cx.parent = Some(child_scope);\n     }\n \n-    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent<'tcx> {\n+    fn enter_node_extent_with_dtor(&mut self, id: ast::NodeId) {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n         // account for the destruction scope representing the extent of\n         // the destructors that run immediately after it completes.\n         if self.terminating_scopes.contains(&id) {\n-            let ds = self.new_code_extent(\n-                CodeExtentData::DestructionScope(id));\n-            self.intern_node(id, Some(ds))\n-        } else {\n-            self.new_node_extent(id)\n+            self.enter_code_extent(CodeExtent::DestructionScope(id));\n         }\n+        self.enter_code_extent(CodeExtent::Misc(id));\n     }\n }\n \n@@ -1165,10 +1127,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         }\n         self.cx.root_id = Some(body_id.node_id);\n \n-        self.cx.parent = Some(self.new_code_extent(\n-            CodeExtentData::CallSiteScope(body_id)));\n-        self.cx.parent = Some(self.new_code_extent(\n-            CodeExtentData::ParameterScope(body_id)));\n+        self.enter_code_extent(CodeExtent::CallSiteScope(body_id));\n+        self.enter_code_extent(CodeExtent::ParameterScope(body_id));\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n@@ -1203,7 +1163,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n }\n \n fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Rc<RegionMaps<'tcx>>\n+    -> Rc<RegionMaps>\n {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {"}, {"sha": "b9355c264b3ef49d85c7f1d392645d7b3c6ef3ee", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -21,7 +21,6 @@ use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n-use middle::region::{CodeExtent, CodeExtentData};\n use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n@@ -99,7 +98,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n     type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    region: RefCell<FxHashSet<Interned<'tcx, RegionKind<'tcx>>>>,\n+    region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n }\n@@ -548,8 +547,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n \n-    code_extent_interner: RefCell<FxHashSet<CodeExtent<'tcx>>>,\n-\n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n     /// error reporting, and so is lazily initialised and generally\n@@ -651,32 +648,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n-    pub fn node_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n-        self.intern_code_extent(CodeExtentData::Misc(n))\n-    }\n-\n-    pub fn call_site_extent(self, fn_id: ast::NodeId) -> CodeExtent<'gcx> {\n-        self.intern_code_extent(CodeExtentData::CallSiteScope(\n-            self.hir.body_owned_by(fn_id)))\n-    }\n-\n-    pub fn parameter_extent(self, fn_id: ast::NodeId) -> CodeExtent<'gcx> {\n-        self.intern_code_extent(CodeExtentData::ParameterScope(\n-            self.hir.body_owned_by(fn_id)))\n-    }\n-\n-    pub fn intern_code_extent(self, data: CodeExtentData) -> CodeExtent<'gcx> {\n-        if let Some(st) = self.code_extent_interner.borrow().get(&data) {\n-            return st;\n-        }\n-\n-        let interned = self.global_interners.arena.alloc(data);\n-        if let Some(prev) = self.code_extent_interner.borrow_mut().replace(interned) {\n-            bug!(\"Tried to overwrite interned code-extent: {:?}\", prev)\n-        }\n-        interned\n-    }\n-\n     pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n@@ -764,7 +735,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_interner: RefCell::new(FxHashSet()),\n-            code_extent_interner: RefCell::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n@@ -1106,8 +1076,8 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<RegionKind<'tcx>> for Interned<'tcx, RegionKind<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a RegionKind<'tcx> {\n+impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n+    fn borrow<'a>(&'a self) -> &'a RegionKind {\n         &self.0\n     }\n }\n@@ -1206,7 +1176,7 @@ direct_interners!('tcx,\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n-    }) -> RegionKind<'tcx>\n+    }) -> RegionKind\n );\n \n macro_rules! slice_interners {"}, {"sha": "6de3c018bda0ebe8223760d6d7eb282553712540", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -536,7 +536,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // regions. See comment on `shift_regions_through_binders` method in\n // `subst.rs` for more details.\n \n-pub fn shift_region<'tcx>(region: ty::RegionKind<'tcx>, amount: u32) -> ty::RegionKind<'tcx> {\n+pub fn shift_region(region: ty::RegionKind, amount: u32) -> ty::RegionKind {\n     match region {\n         ty::ReLateBound(debruijn, br) => {\n             ty::ReLateBound(debruijn.shifted(amount), br)"}, {"sha": "1fd9e8f73756e830ca1d0f238107770f03464348", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -801,7 +801,7 @@ define_maps! { <'tcx>\n     /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n     /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n     /// fn item.\n-    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps<'tcx>>,\n+    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n \n     [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n "}, {"sha": "6ca401d27ac72c13937b1795e4b90e09603fa259", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -24,6 +24,7 @@ use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n+use middle::region::CodeExtent;\n use mir::Mir;\n use traits;\n use ty;\n@@ -2435,7 +2436,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n-        self.mk_region(ty::ReScope(self.node_extent(id)))\n+        self.mk_region(ty::ReScope(CodeExtent::Misc(id)))\n     }\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`"}, {"sha": "cfbf1244db3ad70202effe2891a277185b44150f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -684,7 +684,7 @@ pub struct DebruijnIndex {\n     pub depth: u32,\n }\n \n-pub type Region<'tcx> = &'tcx RegionKind<'tcx>;\n+pub type Region<'tcx> = &'tcx RegionKind;\n \n /// Representation of regions.\n ///\n@@ -743,7 +743,7 @@ pub type Region<'tcx> = &'tcx RegionKind<'tcx>;\n /// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable)]\n-pub enum RegionKind<'tcx> {\n+pub enum RegionKind {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n     // parameters are substituted.\n@@ -761,7 +761,7 @@ pub enum RegionKind<'tcx> {\n     /// A concrete region naming some statically determined extent\n     /// (e.g. an expression or sequence of statements) within the\n     /// current function.\n-    ReScope(region::CodeExtent<'tcx>),\n+    ReScope(region::CodeExtent),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n@@ -906,7 +906,7 @@ impl DebruijnIndex {\n }\n \n /// Region utilities\n-impl<'tcx> RegionKind<'tcx> {\n+impl RegionKind {\n     pub fn is_late_bound(&self) -> bool {\n         match *self {\n             ty::ReLateBound(..) => true,\n@@ -929,7 +929,7 @@ impl<'tcx> RegionKind<'tcx> {\n     }\n \n     /// Returns the depth of `self` from the (1-based) binding level `depth`\n-    pub fn from_depth(&self, depth: u32) -> RegionKind<'tcx> {\n+    pub fn from_depth(&self, depth: u32) -> RegionKind {\n         match *self {\n             ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n                 depth: debruijn.depth - (depth - 1)"}, {"sha": "8ca699339d36ecedca7a92a3e785b51fffb248bf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -458,7 +458,7 @@ impl fmt::Debug for ty::BoundRegion {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::RegionKind<'tcx> {\n+impl fmt::Debug for ty::RegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n@@ -510,7 +510,7 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::RegionKind<'tcx> {\n+impl<'tcx> fmt::Display for ty::RegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n             return write!(f, \"{:?}\", *self);"}, {"sha": "eeb5a3fb957fa481f7a2ad4dc15f80b77f529950", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -232,7 +232,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent<'tcx>, mut op: F) -> bool where\n+    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Like `each_issued_loan()`, but only considers loans that are\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn each_in_scope_loan_affecting_path<F>(&self,\n-                                            scope: region::CodeExtent<'tcx>,\n+                                            scope: region::CodeExtent,\n                                             loan_path: &LoanPath<'tcx>,\n                                             mut op: F)\n                                             -> bool where\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let mut ret = UseOk;\n \n         self.each_in_scope_loan_affecting_path(\n-            self.tcx().node_extent(expr_id), use_path, |loan| {\n+            region::CodeExtent::Misc(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -822,7 +822,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = self.tcx().node_extent(assignment_id);\n+            let scope = region::CodeExtent::Misc(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "5fc5682a60b456c38ba9f22e5745839b3e3cd6b5", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -24,7 +24,7 @@ use syntax_pos::Span;\n type R = Result<(),()>;\n \n pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope: region::CodeExtent<'tcx>,\n+                                    item_scope: region::CodeExtent,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n@@ -52,7 +52,7 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the scope of the function body for the enclosing item\n-    item_scope: region::CodeExtent<'tcx>,\n+    item_scope: region::CodeExtent,\n \n     span: Span,\n     cause: euv::LoanCause,"}, {"sha": "4cfee36359cd7576522dc4a871cbf339741b5d24", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -45,7 +45,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         bccx: bccx,\n         infcx: &infcx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.node_extent(body.node_id),\n+        item_ub: region::CodeExtent::Misc(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -66,7 +66,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n-    item_ub: region::CodeExtent<'tcx>,\n+    item_ub: region::CodeExtent,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n@@ -376,7 +376,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = self.tcx().node_extent(borrow_id);\n+                let borrow_scope = region::CodeExtent::Misc(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n@@ -455,9 +455,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn compute_gen_scope(&self,\n-                             borrow_scope: region::CodeExtent<'tcx>,\n-                             loan_scope: region::CodeExtent<'tcx>)\n-                             -> region::CodeExtent<'tcx> {\n+                             borrow_scope: region::CodeExtent,\n+                             loan_scope: region::CodeExtent)\n+                             -> region::CodeExtent {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n@@ -470,8 +470,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent<'tcx>, lp: &LoanPath<'tcx>)\n-                              -> region::CodeExtent<'tcx> {\n+    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath<'tcx>)\n+                              -> region::CodeExtent {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,"}, {"sha": "99df1431265084b80f8307a2c3734f1f28b922dd", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -208,7 +208,7 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     // Some in `borrowck_fn` and cleared later\n     tables: &'a ty::TypeckTables<'tcx>,\n \n-    region_maps: Rc<RegionMaps<'tcx>>,\n+    region_maps: Rc<RegionMaps>,\n \n     owner_def_id: DefId,\n }\n@@ -228,13 +228,13 @@ pub struct Loan<'tcx> {\n     /// cases, notably method arguments, the loan may be introduced\n     /// only later, once it comes into scope.  See also\n     /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::CodeExtent<'tcx>,\n+    gen_scope: region::CodeExtent,\n \n     /// kill_scope indicates when the loan goes out of scope.  This is\n     /// either when the lifetime expires or when the local variable\n     /// which roots the loan-path goes out of scope, whichever happens\n     /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::CodeExtent<'tcx>,\n+    kill_scope: region::CodeExtent,\n     span: Span,\n     cause: euv::LoanCause,\n }\n@@ -334,12 +334,12 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n }\n \n impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent<'tcx> {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n             LpVar(local_id) => bccx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                bccx.tcx.node_extent(block_id)\n+                region::CodeExtent::Misc(block_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(bccx),"}, {"sha": "a18f91a9ee391408f069981f119d09ead357e618", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -70,7 +70,7 @@ struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: &'a ty::ParameterEnvironment<'tcx>,\n-    region_maps: &'a RegionMaps<'tcx>,\n+    region_maps: &'a RegionMaps,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {"}, {"sha": "e2cbc480715fb66d590be7a5311b9a52e9bf3277", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -17,7 +17,6 @@ use rustc_resolve::MakeGlobMap;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region::{CodeExtent, RegionMaps};\n-use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n use rustc::ty::subst::{Kind, Subst};\n@@ -45,7 +44,7 @@ use rustc::hir;\n \n struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n-    region_maps: &'a mut RegionMaps<'tcx>,\n+    region_maps: &'a mut RegionMaps,\n }\n \n struct RH<'a> {\n@@ -168,8 +167,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: CodeExtent<'tcx>) {\n-        let me = self.tcx().intern_code_extent(CodeExtentData::Misc(rh.id));\n+    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: CodeExtent) {\n+        let me = CodeExtent::Misc(rh.id);\n         self.region_maps.record_code_extent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, me);\n@@ -181,7 +180,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // children of 1, etc\n \n         let node = ast::NodeId::from_u32;\n-        let dscope = self.tcx().intern_code_extent(CodeExtentData::DestructionScope(node(1)));\n+        let dscope = CodeExtent::DestructionScope(node(1));\n         self.region_maps.record_code_extent(dscope, None);\n         self.create_region_hierarchy(&RH {\n                                          id: node(1),\n@@ -327,7 +326,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(self.tcx().node_extent(ast::NodeId::from_u32(id)));\n+        let r = ty::ReScope(CodeExtent::Misc(ast::NodeId::from_u32(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n "}, {"sha": "819095e262832b207b9f689014c2e805cbc455b4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -21,7 +21,6 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n-use rustc::middle::region;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -360,12 +359,6 @@ impl<'a, 'tcx> SpecializedDecoder<ty::Region<'tcx>> for DecodeContext<'a, 'tcx>\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<region::CodeExtent<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<region::CodeExtent<'tcx>, Self::Error> {\n-        Ok(self.tcx().intern_code_extent(Decodable::decode(self)?))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n         Ok(self.tcx().mk_type_list((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)"}, {"sha": "a368021443292b36a844039ab75b37333721c6c5", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// The operand is known to be live until the end of `scope`.\n     pub fn as_operand<M>(&mut self,\n                          block: BasicBlock,\n-                         scope: Option<CodeExtent<'tcx>>,\n+                         scope: Option<CodeExtent>,\n                          expr: M) -> BlockAnd<Operand<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -49,7 +49,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n-                       scope: Option<CodeExtent<'tcx>>,\n+                       scope: Option<CodeExtent>,\n                        expr: Expr<'tcx>)\n                        -> BlockAnd<Operand<'tcx>> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);"}, {"sha": "7b29cd970d7d4447c852d0feaa39542afc77d0a6", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent<'tcx>>, expr: M)\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent>, expr: M)\n                         -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n-                      scope: Option<CodeExtent<'tcx>>,\n+                      scope: Option<CodeExtent>,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);"}, {"sha": "a334923546fb2df76a8c4ccb73cd242bf11ae6ab", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self,\n                       block: BasicBlock,\n-                      temp_lifetime: Option<CodeExtent<'tcx>>,\n+                      temp_lifetime: Option<CodeExtent>,\n                       expr: M)\n                       -> BlockAnd<Lvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_temp(&mut self,\n                     mut block: BasicBlock,\n-                    temp_lifetime: Option<CodeExtent<'tcx>>,\n+                    temp_lifetime: Option<CodeExtent>,\n                     expr: Expr<'tcx>)\n                     -> BlockAnd<Lvalue<'tcx>> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);"}, {"sha": "fb173e2487bff0c5091fb68566f4a5975f16b9f3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -338,8 +338,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.hir.span(fn_id);\n     let mut builder = Builder::new(hir.clone(), span, arguments.len(), return_ty);\n \n-    let call_site_extent = tcx.call_site_extent(fn_id);\n-    let arg_extent = tcx.parameter_extent(fn_id);\n+    let call_site_extent = CodeExtent::CallSiteScope(body.id());\n+    let arg_extent = CodeExtent::ParameterScope(body.id());\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n@@ -480,7 +480,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n-                     argument_extent: CodeExtent<'tcx>,\n+                     argument_extent: CodeExtent,\n                      ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {"}, {"sha": "ae47f4c42442041fe47241444d4c796fb5a91c39", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -87,7 +87,7 @@ should go to.\n */\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n-use rustc::middle::region::{CodeExtent, CodeExtentData};\n+use rustc::middle::region::CodeExtent;\n use rustc::middle::lang_items;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::subst::{Kind, Subst};\n@@ -102,7 +102,7 @@ pub struct Scope<'tcx> {\n     visibility_scope: VisibilityScope,\n \n     /// the extent of this scope within source code.\n-    extent: CodeExtent<'tcx>,\n+    extent: CodeExtent,\n \n     /// Whether there's anything to do for the cleanup path, that is,\n     /// when unwinding through this scope. This includes destructors,\n@@ -137,7 +137,7 @@ pub struct Scope<'tcx> {\n     free: Option<FreeData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FxHashMap<(BasicBlock, CodeExtent<'tcx>), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -180,7 +180,7 @@ struct FreeData<'tcx> {\n #[derive(Clone, Debug)]\n pub struct BreakableScope<'tcx> {\n     /// Extent of the loop\n-    pub extent: CodeExtent<'tcx>,\n+    pub extent: CodeExtent,\n     /// Where the body of the loop begins. `None` if block\n     pub continue_block: Option<BasicBlock>,\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n@@ -271,7 +271,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self,\n-                          extent: CodeExtent<'tcx>,\n+                          extent: CodeExtent,\n                           mut block: BasicBlock,\n                           f: F)\n                           -> BlockAnd<R>\n@@ -289,7 +289,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent<'tcx>) {\n+    pub fn push_scope(&mut self, extent: CodeExtent) {\n         debug!(\"push_scope({:?})\", extent);\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n@@ -306,7 +306,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n     pub fn pop_scope(&mut self,\n-                     extent: CodeExtent<'tcx>,\n+                     extent: CodeExtent,\n                      mut block: BasicBlock)\n                      -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n-                      extent: CodeExtent<'tcx>,\n+                      extent: CodeExtent,\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n         debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n@@ -391,7 +391,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_breakable_scope(&mut self,\n                            span: Span,\n-                           label: CodeExtent<'tcx>)\n+                           label: CodeExtent)\n                            -> &mut BreakableScope<'tcx> {\n         // find the loop-scope with the correct id\n         self.breakable_scopes.iter_mut()\n@@ -411,20 +411,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Returns the extent of the scope which should be exited by a\n     /// return.\n-    pub fn extent_of_return_scope(&self) -> CodeExtent<'tcx> {\n+    pub fn extent_of_return_scope(&self) -> CodeExtent {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match *self.scopes[1].extent {\n-            CodeExtentData::ParameterScope(_) => true,\n+        assert!(match self.scopes[1].extent {\n+            CodeExtent::ParameterScope(_) => true,\n             _ => false,\n         });\n         self.scopes[1].extent\n     }\n \n     /// Returns the topmost active scope, which is known to be alive until\n     /// the next scope expression.\n-    pub fn topmost_scope(&self) -> CodeExtent<'tcx> {\n+    pub fn topmost_scope(&self) -> CodeExtent {\n         self.scopes.last().expect(\"topmost_scope: no scopes present\").extent\n     }\n \n@@ -434,7 +434,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// `extent`.\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n-                         extent: CodeExtent<'tcx>,\n+                         extent: CodeExtent,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n@@ -524,7 +524,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// There may only be one \u201cfree\u201d scheduled in any given scope.\n     pub fn schedule_box_free(&mut self,\n                              span: Span,\n-                             extent: CodeExtent<'tcx>,\n+                             extent: CodeExtent,\n                              value: &Lvalue<'tcx>,\n                              item_ty: Ty<'tcx>) {\n         for scope in self.scopes.iter_mut().rev() {"}, {"sha": "920da30611633d64d66bd5ef18f3003f18d04adf", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -11,7 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n-use rustc::middle::region::{BlockRemainder, CodeExtentData};\n+use rustc::middle::region::{BlockRemainder, CodeExtent};\n use rustc::hir;\n use syntax::ast;\n \n@@ -24,7 +24,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: cx.tcx.node_extent(self.id),\n+            extent: CodeExtent::Misc(self.id),\n             span: self.span,\n             stmts: stmts,\n             expr: self.expr.to_ref(),\n@@ -44,7 +44,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n-                        scope: cx.tcx.node_extent(id),\n+                        scope: CodeExtent::Misc(id),\n                         expr: expr.to_ref(),\n                     },\n                 })))\n@@ -55,19 +55,17 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         // ignore for purposes of the MIR\n                     }\n                     hir::DeclLocal(ref local) => {\n-                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                        let remainder_extent = CodeExtent::Remainder(BlockRemainder {\n                             block: block_id,\n                             first_statement_index: index as u32,\n                         });\n-                        let remainder_extent =\n-                            cx.tcx.intern_code_extent(remainder_extent);\n \n                         let pattern = Pattern::from_hir(cx.tcx, cx.tables(), &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n-                                init_scope: cx.tcx.node_extent(id),\n+                                init_scope: CodeExtent::Misc(id),\n                                 pattern: pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n@@ -84,7 +82,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.id);\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, block.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(block.id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime: temp_lifetime,"}, {"sha": "b180d982e86b669c9be4c517efa98d2a7503e454", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -25,8 +25,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, self.id);\n-        let expr_extent = cx.tcx.node_extent(self.id);\n+        let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(self.id);\n+        let expr_extent = CodeExtent::Misc(self.id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -237,7 +237,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -609,7 +609,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: cx.tcx.node_extent(target_id),\n+                    label: CodeExtent::Misc(target_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -620,7 +620,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: cx.tcx.node_extent(loop_id),\n+                    label: CodeExtent::Misc(loop_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -685,7 +685,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.node_extent(value.id),\n+                value_extents: CodeExtent::Misc(value.id),\n             }\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n@@ -706,7 +706,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n     let callee = cx.tables().method_map[&method_call];\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n@@ -790,7 +790,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -965,7 +965,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let (temp_lifetime, was_shrunk) =\n-                cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+                cx.region_maps.temporary_scope2(expr.id);\n             argrefs.extend(args.iter()\n                 .map(|arg| {\n                     let arg_ty = cx.tables().expr_ty_adjusted(arg);\n@@ -1017,7 +1017,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n     let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n@@ -1042,7 +1042,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: closure_expr.id,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, closure_expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,"}, {"sha": "9ffce18fe150e0c8b52ac54df9164910d5631345", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -35,7 +35,7 @@ use std::rc::Rc;\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    pub region_maps: Rc<RegionMaps<'tcx>>,\n+    pub region_maps: Rc<RegionMaps>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks."}, {"sha": "1af9d722599e6e7663e035aa47659a31969d8415", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -32,7 +32,7 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n-    pub extent: CodeExtent<'tcx>,\n+    pub extent: CodeExtent,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n@@ -53,7 +53,7 @@ pub struct Stmt<'tcx> {\n pub enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n-        scope: CodeExtent<'tcx>,\n+        scope: CodeExtent,\n \n         /// expression being evaluated in this statement\n         expr: ExprRef<'tcx>,\n@@ -62,11 +62,11 @@ pub enum StmtKind<'tcx> {\n     Let {\n         /// scope for variables bound in this let; covers this and\n         /// remaining statements in block\n-        remainder_scope: CodeExtent<'tcx>,\n+        remainder_scope: CodeExtent,\n \n         /// scope for the initialization itself; might be used as\n         /// lifetime of temporaries\n-        init_scope: CodeExtent<'tcx>,\n+        init_scope: CodeExtent,\n \n         /// let <PAT> = ...\n         pattern: Pattern<'tcx>,\n@@ -97,7 +97,7 @@ pub struct Expr<'tcx> {\n \n     /// lifetime of this expression if it should be spilled into a\n     /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<CodeExtent<'tcx>>,\n+    pub temp_lifetime: Option<CodeExtent>,\n \n     /// whether this temp lifetime was shrunk by #36082.\n     pub temp_lifetime_was_shrunk: bool,\n@@ -112,12 +112,12 @@ pub struct Expr<'tcx> {\n #[derive(Clone, Debug)]\n pub enum ExprKind<'tcx> {\n     Scope {\n-        extent: CodeExtent<'tcx>,\n+        extent: CodeExtent,\n         value: ExprRef<'tcx>,\n     },\n     Box {\n         value: ExprRef<'tcx>,\n-        value_extents: CodeExtent<'tcx>,\n+        value_extents: CodeExtent,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,\n@@ -210,11 +210,11 @@ pub enum ExprKind<'tcx> {\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: CodeExtent<'tcx>,\n+        label: CodeExtent,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: CodeExtent<'tcx>,\n+        label: CodeExtent,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "e029332559635663b46b12b696e9a466aa25dea2", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -270,7 +270,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     span: Span,\n-    scope: region::CodeExtent<'tcx>)\n+    scope: region::CodeExtent)\n     -> Result<(), ErrorReported>\n {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\","}, {"sha": "70d2867c08ce624df82e9b7e068b07e7b2476e4d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -88,6 +88,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin};\n+use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -560,12 +561,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir.as_local_node_id(def_id);\n         let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n-        let implicit_region_bound = item_id.and_then(|id| {\n-            if body_id.is_some() {\n-                Some(tcx.mk_region(ty::ReScope(tcx.call_site_extent(id))))\n-            } else {\n-                None\n-            }\n+        let implicit_region_bound = body_id.map(|body| {\n+            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body)))\n         });\n \n         Inherited {"}, {"sha": "754bd288bfaa70c995624c1358dbc3ffcd7e284f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -178,15 +178,15 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n \n-    pub region_maps: Rc<RegionMaps<'tcx>>,\n+    pub region_maps: Rc<RegionMaps>,\n \n     free_region_map: FreeRegionMap<'tcx>,\n \n     // id of innermost fn body id\n     body_id: ast::NodeId,\n \n     // call_site scope of innermost fn\n-    call_site_scope: Option<CodeExtent<'tcx>>,\n+    call_site_scope: Option<CodeExtent>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n@@ -224,8 +224,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent<'tcx>>)\n-                           -> Option<CodeExtent<'tcx>> {\n+    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>)\n+                           -> Option<CodeExtent> {\n         mem::replace(&mut self.call_site_scope, call_site_scope)\n     }\n \n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = self.tcx.call_site_extent(id);\n+        let call_site = CodeExtent::CallSiteScope(body_id);\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(self.tcx.node_extent(body_id.node_id), &body.arguments);\n+        self.link_fn_args(CodeExtent::Misc(body_id.node_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -877,7 +877,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = self.tcx.node_extent(call_expr.id);\n+        let callee_scope = CodeExtent::Misc(call_expr.id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -1030,7 +1030,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(self.tcx.node_extent(index_expr.id));\n+        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1110,7 +1110,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_args(&self, body_scope: CodeExtent<'tcx>, args: &[hir::Arg]) {\n+    fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n         let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n         for arg in args {\n@@ -1176,7 +1176,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// must outlive `callee_scope`.\n     fn link_by_ref(&self,\n                    expr: &hir::Expr,\n-                   callee_scope: CodeExtent<'tcx>) {\n+                   callee_scope: CodeExtent) {\n         debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n                expr, callee_scope);\n         let mc = mc::MemCategorizationContext::new(self, &self.region_maps);"}, {"sha": "61f941e57b2d8c6a61481e6ba7c819d0ded0604d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea1c6df81eecad62ca25191042b7871291162933/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ea1c6df81eecad62ca25191042b7871291162933", "patch": "@@ -820,7 +820,7 @@ impl Clean<Lifetime> for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> Clean<Option<Lifetime>> for ty::RegionKind<'tcx> {\n+impl Clean<Option<Lifetime>> for ty::RegionKind {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),"}]}