{"sha": "cd7f3ad22eb480426306be78e2ca9f09497edd34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkN2YzYWQyMmViNDgwNDI2MzA2YmU3OGUyY2E5ZjA5NDk3ZWRkMzQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-20T01:24:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-20T04:33:15Z"}, "message": "syntax: Removing some bad copies", "tree": {"sha": "aea53ccedcf9f57a0982067f03675fa04fe67a7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aea53ccedcf9f57a0982067f03675fa04fe67a7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd7f3ad22eb480426306be78e2ca9f09497edd34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd7f3ad22eb480426306be78e2ca9f09497edd34", "html_url": "https://github.com/rust-lang/rust/commit/cd7f3ad22eb480426306be78e2ca9f09497edd34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd7f3ad22eb480426306be78e2ca9f09497edd34/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "251d0c4557a2f484a6fce1b91e217034b5c82dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/251d0c4557a2f484a6fce1b91e217034b5c82dd3", "html_url": "https://github.com/rust-lang/rust/commit/251d0c4557a2f484a6fce1b91e217034b5c82dd3"}], "stats": {"total": 137, "additions": 69, "deletions": 68}, "files": [{"sha": "9973c9558c9683d2e71fa09bf6f329c6f2fc5c45", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=cd7f3ad22eb480426306be78e2ca9f09497edd34", "patch": "@@ -65,7 +65,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: Conv) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: &Conv) -> @ast::expr {\n         fn make_flags(cx: @ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n@@ -139,7 +139,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: ~str, cnv: Conv,\n+    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: ~str, cnv: &Conv,\n                       arg: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n@@ -148,11 +148,11 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         return mk_call_global(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: Conv, arg: @ast::expr) ->\n+    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv, arg: @ast::expr) ->\n        @ast::expr {\n         // FIXME: Move validation code into core::extfmt (Issue #2249)\n \n-        fn is_signed_type(cnv: Conv) -> bool {\n+        fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {\n               TyInt(s) => match s {\n                 Signed => return true,\n@@ -220,7 +220,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                        mk_addr_of(cx, sp, arg))\n         }\n     }\n-    fn log_conv(c: Conv) {\n+    fn log_conv(c: &Conv) {\n         match c.param {\n           Some(p) => { debug!(\"param: %s\", p.to_str()); }\n           _ => debug!(\"param: none\")\n@@ -285,12 +285,12 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                                   ~\"for the given format string\");\n             }\n             debug!(\"Building conversion:\");\n-            log_conv(/*bad*/ copy *conv);\n+            log_conv(conv);\n             let arg_expr = args[n];\n             let c_expr = make_new_conv(\n                 cx,\n                 fmt_sp,\n-                /*bad*/ copy *conv,\n+                conv,\n                 arg_expr\n             );\n             piece_exprs.push(c_expr);"}, {"sha": "98208bf9f7668ecaa41fcc279da55b60c918a3d1", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=cd7f3ad22eb480426306be78e2ca9f09497edd34", "patch": "@@ -220,7 +220,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n         if col < len {\n             s1 = str::slice(s, col, len);\n         } else { s1 = ~\"\"; }\n-    } else { s1 = /*bad*/ copy s; }\n+    } else { s1 = s; }\n     debug!(\"pushing line: %s\", s1);\n     lines.push(s1);\n }\n@@ -357,8 +357,8 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(&tok) {\n             let s = get_str_from(rdr, bstart);\n-            literals.push(lit {lit: /*bad*/ copy s, pos: sp.lo});\n             debug!(\"tok lit: %s\", s);\n+            literals.push(lit {lit: s, pos: sp.lo});\n         } else {\n             debug!(\"tok: %s\", token::to_str(rdr.interner, &tok));\n         }"}, {"sha": "45e09e4c29eabb78c7c4af040367a758d2d5ccec", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cd7f3ad22eb480426306be78e2ca9f09497edd34", "patch": "@@ -1438,7 +1438,7 @@ pub impl Parser {\n                     let (s, z) = p.parse_sep_and_zerok();\n                     tt_seq(\n                         mk_sp(sp.lo ,p.span.hi),\n-                        /*bad*/ copy seq.node,\n+                        seq.node,\n                         s,\n                         z\n                     )\n@@ -1855,7 +1855,7 @@ pub impl Parser {\n         // Turn on the restriction to stop at | or || so we can parse\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n-        match /*bad*/ copy e.node {\n+        match e.node {\n             expr_call(f, args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n@@ -2129,7 +2129,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let mut pat;\n-        match copy *self.token {\n+        match *self.token {\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n           token::AT => {\n             self.bump();\n@@ -2237,7 +2237,7 @@ pub impl Parser {\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n           }\n-          copy tok => {\n+          tok => {\n             if !is_ident_or_path(&tok)\n                 || self.is_keyword(&~\"true\")\n                 || self.is_keyword(&~\"false\")\n@@ -3341,6 +3341,7 @@ pub impl Parser {\n                                             VIEW_ITEMS_AND_ITEMS_ALLOWED,\n                                             true);\n         let mut items: ~[@item] = starting_items;\n+        let attrs_remaining_len = attrs_remaining.len();\n \n         // looks like this code depends on the invariant that\n         // outer attributes can't occur on view items (or macros\n@@ -3349,7 +3350,7 @@ pub impl Parser {\n         while *self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n-                attrs = vec::append(/*bad*/ copy attrs_remaining, attrs);\n+                attrs = attrs_remaining + attrs;\n                 first = false;\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n@@ -3378,7 +3379,7 @@ pub impl Parser {\n             debug!(\"parse_mod_items: attrs=%?\", attrs);\n         }\n \n-        if first && attrs_remaining.len() > 0u {\n+        if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n             self.fatal(~\"expected item\");\n         }"}, {"sha": "4021598c4666598424257c68ca8ff404d8008065", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7f3ad22eb480426306be78e2ca9f09497edd34/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cd7f3ad22eb480426306be78e2ca9f09497edd34", "patch": "@@ -134,7 +134,7 @@ pub fn print_crate(cm: @CodeMap,\n }\n \n pub fn print_crate_(s: @ps, &&crate: @ast::crate) {\n-    print_mod(s, crate.node.module, crate.node.attrs);\n+    print_mod(s, &crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n }\n@@ -310,7 +310,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, ~\"*/\");\n }\n \n-pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n+pub fn commasep<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -321,7 +321,7 @@ pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n }\n \n \n-pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN),\n+pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n                          get_span: &fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n@@ -340,20 +340,20 @@ pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN),\n     end(s);\n }\n \n-pub fn commasep_exprs(s: @ps, b: breaks, exprs: ~[@ast::expr]) {\n+pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n     fn expr_span(&&expr: @ast::expr) -> codemap::span { return expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-pub fn print_mod(s: @ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n+pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n     }\n     for _mod.items.each |item| { print_item(s, *item); }\n }\n \n-pub fn print_foreign_mod(s: @ps, nmod: ast::foreign_mod,\n+pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n                          attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each |vitem| {\n@@ -376,12 +376,12 @@ pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n-    match /*bad*/ copy ty.node {\n+    match ty.node {\n       ast::ty_nil => word(s.s, ~\"()\"),\n       ast::ty_bot => word(s.s, ~\"!\"),\n-      ast::ty_box(mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n-      ast::ty_uniq(mt) => { word(s.s, ~\"~\"); print_mt(s, mt); }\n-      ast::ty_vec(mt) => {\n+      ast::ty_box(ref mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n+      ast::ty_uniq(ref mt) => { word(s.s, ~\"~\"); print_mt(s, mt); }\n+      ast::ty_vec(ref mt) => {\n         word(s.s, ~\"[\");\n         match mt.mutbl {\n           ast::m_mutbl => word_space(s, ~\"mut\"),\n@@ -391,15 +391,15 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n         print_type(s, mt.ty);\n         word(s.s, ~\"]\");\n       }\n-      ast::ty_ptr(mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n-      ast::ty_rptr(lifetime, mt) => {\n+      ast::ty_ptr(ref mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n+      ast::ty_rptr(lifetime, ref mt) => {\n           word(s.s, ~\"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n       }\n-      ast::ty_tup(elts) => {\n+      ast::ty_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, elts, print_type);\n+        commasep(s, inconsistent, *elts, print_type);\n         if elts.len() == 1 {\n             word(s.s, ~\",\");\n         }\n@@ -416,7 +416,7 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n                       None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n-      ast::ty_fixed_length_vec(mt, v) => {\n+      ast::ty_fixed_length_vec(ref mt, v) => {\n         word(s.s, ~\"[\");\n         match mt.mutbl {\n             ast::m_mutbl => word_space(s, ~\"mut\"),\n@@ -443,7 +443,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    match /*bad*/ copy item.node {\n+    match item.node {\n       ast::foreign_item_fn(ref decl, purity, ref generics) => {\n         print_fn(s, decl, Some(purity), item.ident, generics, None,\n                  ast::inherited);\n@@ -469,7 +469,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n-    match /*bad*/ copy item.node {\n+    match item.node {\n       ast::item_const(ty, expr) => {\n         head(s, visibility_qualified(item.vis, ~\"const\"));\n         print_ident(s, item.ident);\n@@ -497,15 +497,15 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n-      ast::item_mod(_mod) => {\n+      ast::item_mod(ref _mod) => {\n         head(s, visibility_qualified(item.vis, ~\"mod\"));\n         print_ident(s, item.ident);\n         nbsp(s);\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_foreign_mod(nmod) => {\n+      ast::item_foreign_mod(ref nmod) => {\n         head(s, visibility_qualified(item.vis, ~\"extern\"));\n         print_string(s, *s.intr.get(nmod.abi));\n         nbsp(s);\n@@ -767,15 +767,15 @@ pub fn print_tts(s: @ps, &&tts: &[ast::token_tree]) {\n \n pub fn print_variant(s: @ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n-    match /*bad*/ copy v.node.kind {\n-        ast::tuple_variant_kind(args) => {\n+    match v.node.kind {\n+        ast::tuple_variant_kind(ref args) => {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n                 fn print_variant_arg(s: @ps, arg: ast::variant_arg) {\n                     print_type(s, arg.ty);\n                 }\n-                commasep(s, consistent, args, print_variant_arg);\n+                commasep(s, consistent, *args, print_variant_arg);\n                 pclose(s);\n             }\n         }\n@@ -1103,7 +1103,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n     (s.ann.pre)(ann_node);\n-    match /*bad*/ copy expr.node {\n+    match expr.node {\n         ast::expr_vstore(e, v) => match v {\n             ast::expr_vstore_fixed(_) => {\n                 print_expr(s, e);\n@@ -1115,14 +1115,14 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                 print_expr(s, e);\n             }\n         },\n-      ast::expr_vec(exprs, mutbl) => {\n+      ast::expr_vec(ref exprs, mutbl) => {\n         ibox(s, indent_unit);\n         word(s.s, ~\"[\");\n         if mutbl == ast::m_mutbl {\n             word(s.s, ~\"mut\");\n-            if vec::len(exprs) > 0u { nbsp(s); }\n+            if exprs.len() > 0u { nbsp(s); }\n         }\n-        commasep_exprs(s, inconsistent, exprs);\n+        commasep_exprs(s, inconsistent, *exprs);\n         word(s.s, ~\"]\");\n         end(s);\n       }\n@@ -1159,29 +1159,29 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         }\n         word(s.s, ~\"}\");\n       }\n-      ast::expr_tup(exprs) => {\n+      ast::expr_tup(ref exprs) => {\n         popen(s);\n-        commasep_exprs(s, inconsistent, exprs);\n+        commasep_exprs(s, inconsistent, *exprs);\n         if exprs.len() == 1 {\n             word(s.s, ~\",\");\n         }\n         pclose(s);\n       }\n-      ast::expr_call(func, args, sugar) => {\n-        let mut base_args = copy args;\n+      ast::expr_call(func, ref args, sugar) => {\n+        let mut base_args = copy *args;\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n-      ast::expr_method_call(func, ident, tys, args, sugar) => {\n-        let mut base_args = copy args;\n+      ast::expr_method_call(func, ident, ref tys, ref args, sugar) => {\n+        let mut base_args = copy *args;\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         word(s.s, ~\".\");\n         print_ident(s, ident);\n-        if vec::len(tys) > 0u {\n+        if tys.len() > 0u {\n             word(s.s, ~\"::<\");\n-            commasep(s, inconsistent, tys, print_type);\n+            commasep(s, inconsistent, *tys, print_type);\n             word(s.s, ~\">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n@@ -1356,13 +1356,13 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         word_space(s, ~\"=\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_field(expr, id, tys) => {\n+      ast::expr_field(expr, id, ref tys) => {\n         print_expr(s, expr);\n         word(s.s, ~\".\");\n         print_ident(s, id);\n-        if vec::len(tys) > 0u {\n+        if tys.len() > 0u {\n             word(s.s, ~\"::<\");\n-            commasep(s, inconsistent, tys, print_type);\n+            commasep(s, inconsistent, *tys, print_type);\n             word(s.s, ~\">\");\n         }\n       }\n@@ -1454,15 +1454,15 @@ pub fn print_local_decl(s: @ps, loc: @ast::local) {\n \n pub fn print_decl(s: @ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n-    match /*bad*/ copy decl.node {\n-      ast::decl_local(locs) => {\n+    match decl.node {\n+      ast::decl_local(ref locs) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_nbsp(s, ~\"let\");\n \n         // if any are mut, all are mut\n-        if vec::any(locs, |l| l.node.is_mutbl) {\n-            fail_unless!(vec::all(locs, |l| l.node.is_mutbl));\n+        if locs.any(|l| l.node.is_mutbl) {\n+            fail_unless!(locs.all(|l| l.node.is_mutbl));\n             word_nbsp(s, ~\"mut\");\n         }\n \n@@ -1479,7 +1479,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n               _ => ()\n             }\n         }\n-        commasep(s, consistent, locs, print_local);\n+        commasep(s, consistent, *locs, print_local);\n         end(s);\n       }\n       ast::decl_item(item) => print_item(s, item)\n@@ -1539,7 +1539,7 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n     (s.ann.pre)(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n-    match /*bad*/ copy pat.node {\n+    match pat.node {\n       ast::pat_wild => word(s.s, ~\"_\"),\n       ast::pat_ident(binding_mode, path, sub) => {\n           if refutable {\n@@ -1563,14 +1563,14 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n               None => ()\n           }\n       }\n-      ast::pat_enum(path, args_) => {\n+      ast::pat_enum(path, ref args_) => {\n         print_path(s, path, true);\n-        match args_ {\n+        match *args_ {\n           None => word(s.s, ~\"(*)\"),\n-          Some(args) => {\n+          Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n-              commasep(s, inconsistent, args,\n+              commasep(s, inconsistent, *args,\n                        |s, p| print_pat(s, p, refutable));\n               pclose(s);\n             } else { }\n@@ -1851,7 +1851,7 @@ pub fn print_view_path(s: @ps, &&vp: @ast::view_path) {\n     }\n }\n \n-pub fn print_view_paths(s: @ps, vps: ~[@ast::view_path]) {\n+pub fn print_view_paths(s: @ps, vps: &[@ast::view_path]) {\n     commasep(s, inconsistent, vps, print_view_path);\n }\n \n@@ -1860,7 +1860,7 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n-    match /*bad*/ copy item.node {\n+    match item.node {\n         ast::view_item_extern_mod(id, mta, _) => {\n             head(s, ~\"extern mod\");\n             print_ident(s, id);\n@@ -1871,9 +1871,9 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n             }\n         }\n \n-        ast::view_item_use(vps) => {\n+        ast::view_item_use(ref vps) => {\n             head(s, ~\"use\");\n-            print_view_paths(s, vps);\n+            print_view_paths(s, *vps);\n         }\n     }\n     word(s.s, ~\";\");\n@@ -1889,7 +1889,7 @@ pub fn print_mutability(s: @ps, mutbl: ast::mutability) {\n     }\n }\n \n-pub fn print_mt(s: @ps, mt: ast::mt) {\n+pub fn print_mt(s: @ps, mt: &ast::mt) {\n     print_mutability(s, mt.mutbl);\n     print_type(s, mt.ty);\n }\n@@ -1942,7 +1942,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n-    match /*bad*/ copy generics { Some(g) => print_generics(s, g), _ => () }\n+    match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n     popen(s);"}]}