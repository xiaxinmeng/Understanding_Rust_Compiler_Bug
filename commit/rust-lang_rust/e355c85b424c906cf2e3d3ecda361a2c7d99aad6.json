{"sha": "e355c85b424c906cf2e3d3ecda361a2c7d99aad6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNTVjODViNDI0YzkwNmNmMmUzZDNlY2RhMzYxYTJjN2Q5OWFhZDY=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-07-09T17:22:15Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-07-09T17:22:15Z"}, "message": "Use rewrite_assign_rhs for rewriting pattern in condition", "tree": {"sha": "6eb6f073430d4092206b59752a8462ead2ba3873", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eb6f073430d4092206b59752a8462ead2ba3873"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e355c85b424c906cf2e3d3ecda361a2c7d99aad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e355c85b424c906cf2e3d3ecda361a2c7d99aad6", "html_url": "https://github.com/rust-lang/rust/commit/e355c85b424c906cf2e3d3ecda361a2c7d99aad6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e355c85b424c906cf2e3d3ecda361a2c7d99aad6/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b897310d7965455c3ac4d199915f3241d3c4d7d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b897310d7965455c3ac4d199915f3241d3c4d7d8", "html_url": "https://github.com/rust-lang/rust/commit/b897310d7965455c3ac4d199915f3241d3c4d7d8"}], "stats": {"total": 74, "additions": 23, "deletions": 51}, "files": [{"sha": "febbeaf09d5fb20796ccf7780b19ff66de45c573", "filename": "src/expr.rs", "status": "modified", "additions": 23, "deletions": 51, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e355c85b424c906cf2e3d3ecda361a2c7d99aad6/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e355c85b424c906cf2e3d3ecda361a2c7d99aad6/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=e355c85b424c906cf2e3d3ecda361a2c7d99aad6", "patch": "@@ -1836,13 +1836,6 @@ impl Rewrite for ast::Arm {\n     }\n }\n \n-// A pattern is simple if it is very short or it is short-ish and just a path.\n-// E.g. `Foo::Bar` is simple, but `Foo(..)` is not.\n-fn pat_is_simple(pat_str: &str) -> bool {\n-    pat_str.len() <= 16 ||\n-        (pat_str.len() <= 24 && pat_str.chars().all(|c| c.is_alphabetic() || c == ':'))\n-}\n-\n // The `if ...` guard on a match arm.\n fn rewrite_guard(\n     context: &RewriteContext,\n@@ -1906,55 +1899,34 @@ fn rewrite_pat_expr(\n     shape: Shape,\n ) -> Option<String> {\n     debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, pat, expr);\n-    let mut pat_string = String::new();\n-    let mut result = match pat {\n-        Some(pat) => {\n-            let matcher = if matcher.is_empty() {\n-                matcher.to_owned()\n-            } else {\n-                format!(\"{} \", matcher)\n-            };\n-            let pat_shape =\n-                try_opt!(try_opt!(shape.offset_left(matcher.len())).sub_width(connector.len()));\n-            pat_string = try_opt!(pat.rewrite(context, pat_shape));\n-            format!(\"{}{}{}\", matcher, pat_string, connector)\n-        }\n-        None => String::new(),\n-    };\n-\n-    // Consider only the last line of the pat string.\n-    let extra_offset = extra_offset(&result, shape);\n-\n-    // The expression may (partially) fit on the current line.\n-    if shape.width > extra_offset + 1 {\n-        let spacer = if pat.is_some() { \" \" } else { \"\" };\n-\n-        let expr_shape = try_opt!(shape.offset_left(extra_offset + spacer.len()));\n-        let expr_rewrite = expr.rewrite(context, expr_shape);\n-\n-        if let Some(expr_string) = expr_rewrite {\n-            if pat.is_none() || pat_is_simple(&pat_string) || !expr_string.contains('\\n') {\n-                result.push_str(spacer);\n-                result.push_str(&expr_string);\n-                return Some(result);\n-            }\n-        }\n+    if let Some(pat) = pat {\n+        let matcher = if matcher.is_empty() {\n+            matcher.to_owned()\n+        } else {\n+            format!(\"{} \", matcher)\n+        };\n+        let pat_shape =\n+            try_opt!(try_opt!(shape.offset_left(matcher.len())).sub_width(connector.len()));\n+        let pat_string = try_opt!(pat.rewrite(context, pat_shape));\n+        let result = format!(\"{}{}{}\", matcher, pat_string, connector);\n+        return rewrite_assign_rhs(context, result, expr, shape);\n     }\n \n-    if pat.is_none() && keyword == \"if\" {\n-        return None;\n+    let expr_rw = expr.rewrite(context, shape);\n+    // The expression may (partially) fit on the current line.\n+    // We do not allow splitting between `if` and condition.\n+    if keyword == \"if\" || expr_rw.is_some() {\n+        return expr_rw;\n     }\n \n-    let nested_indent = shape.indent.block_only().block_indent(context.config);\n-\n     // The expression won't fit on the current line, jump to next.\n-    result.push('\\n');\n-    result.push_str(&nested_indent.to_string(context.config));\n-\n-    let expr_rewrite = expr.rewrite(&context, Shape::indented(nested_indent, context.config));\n-    result.push_str(&try_opt!(expr_rewrite));\n-\n-    Some(result)\n+    let nested_shape = shape\n+        .block()\n+        .block_indent(context.config.tab_spaces())\n+        .with_max_width(context.config);\n+    let nested_indent_str = nested_shape.indent.to_string(context.config);\n+    expr.rewrite(context, nested_shape)\n+        .map(|expr_rw| format!(\"\\n{}{}\", nested_indent_str, expr_rw))\n }\n \n fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Option<String> {"}]}