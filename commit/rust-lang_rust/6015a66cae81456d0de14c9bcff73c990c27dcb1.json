{"sha": "6015a66cae81456d0de14c9bcff73c990c27dcb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMTVhNjZjYWU4MTQ1NmQwZGUxNGM5YmNmZjczYzk5MGMyN2RjYjE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-17T20:00:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-18T17:57:59Z"}, "message": "Make rename reference search use ide_db::search directly", "tree": {"sha": "ba89c68ec2f88c8834766d635c4ba3827ca7ef2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba89c68ec2f88c8834766d635c4ba3827ca7ef2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6015a66cae81456d0de14c9bcff73c990c27dcb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6015a66cae81456d0de14c9bcff73c990c27dcb1", "html_url": "https://github.com/rust-lang/rust/commit/6015a66cae81456d0de14c9bcff73c990c27dcb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6015a66cae81456d0de14c9bcff73c990c27dcb1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6105dbfc2ee811f23255e74c45450c50cc155e85", "url": "https://api.github.com/repos/rust-lang/rust/commits/6105dbfc2ee811f23255e74c45450c50cc155e85", "html_url": "https://github.com/rust-lang/rust/commit/6105dbfc2ee811f23255e74c45450c50cc155e85"}], "stats": {"total": 374, "additions": 210, "deletions": 164}, "files": [{"sha": "4b4afd40c3c2c54ce51f9f5dbc1ae3ec2b8416df", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6015a66cae81456d0de14c9bcff73c990c27dcb1/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6015a66cae81456d0de14c9bcff73c990c27dcb1/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=6015a66cae81456d0de14c9bcff73c990c27dcb1", "patch": "@@ -140,7 +140,7 @@ impl DiagnosticWithFix for IncorrectCase {\n             rename_with_semantics(sema, file_position, &self.suggested_text).ok()?;\n \n         let label = format!(\"Rename to {}\", self.suggested_text);\n-        Some(Fix::new(&label, rename_changes.info, rename_changes.range))\n+        Some(Fix::new(&label, rename_changes.info, frange.range))\n     }\n }\n "}, {"sha": "c5010df0ab95ebd942bae83beff275f34fe0d07e", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 209, "deletions": 163, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/6015a66cae81456d0de14c9bcff73c990c27dcb1/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6015a66cae81456d0de14c9bcff73c990c27dcb1/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=6015a66cae81456d0de14c9bcff73c990c27dcb1", "patch": "@@ -1,23 +1,24 @@\n //! FIXME: write short doc here\n use std::fmt::{self, Display};\n \n-use hir::{Module, ModuleDef, ModuleSource, Semantics};\n+use either::Either;\n+use hir::{HasSource, InFile, Module, ModuleDef, ModuleSource, Semantics};\n use ide_db::{\n     base_db::{AnchoredPathBuf, FileId, FileRange},\n     defs::{Definition, NameClass, NameRefClass},\n     search::FileReference,\n     RootDatabase,\n };\n+use stdx::assert_never;\n use syntax::{\n-    algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    lex_single_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, T,\n+    lex_single_syntax_kind, AstNode, SyntaxKind, SyntaxNode, T,\n };\n use test_utils::mark;\n use text_edit::TextEdit;\n \n use crate::{\n-    FilePosition, FileSystemEdit, RangeInfo, ReferenceKind, ReferenceSearchResult, SourceChange,\n+    display::TryToNav, FilePosition, FileSystemEdit, RangeInfo, ReferenceKind, SourceChange,\n     TextRange,\n };\n \n@@ -47,13 +48,15 @@ pub(crate) fn prepare_rename(\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n-    if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n-        rename_mod(&sema, position, module, \"dummy\")\n-    } else {\n-        let RangeInfo { range, .. } = find_all_refs(&sema, position)?;\n-        Ok(RangeInfo::new(range, SourceChange::default()))\n+    let range = match &find_name_like(&sema, &syntax, position)\n+        .ok_or_else(|| format_err!(\"No references found at position\"))?\n+    {\n+        NameLike::Name(it) => it.syntax(),\n+        NameLike::NameRef(it) => it.syntax(),\n+        NameLike::Lifetime(it) => it.syntax(),\n     }\n-    .map(|info| RangeInfo::new(info.range, ()))\n+    .text_range();\n+    Ok(RangeInfo::new(range, ()))\n }\n \n pub(crate) fn rename(\n@@ -73,10 +76,11 @@ pub(crate) fn rename_with_semantics(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n \n-    if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n-        rename_mod(&sema, position, module, new_name)\n-    } else {\n-        rename_reference(&sema, position, new_name)\n+    let def = find_definition(sema, syntax, position)\n+        .ok_or_else(|| format_err!(\"No references found at position\"))?;\n+    match def {\n+        Definition::ModuleDef(ModuleDef::Module(module)) => rename_mod(&sema, module, new_name),\n+        def => rename_reference(sema, def, new_name),\n     }\n }\n \n@@ -87,12 +91,7 @@ pub(crate) fn will_rename_file(\n ) -> Option<SourceChange> {\n     let sema = Semantics::new(db);\n     let module = sema.to_module_def(file_id)?;\n-\n-    let decl = module.declaration_source(db)?;\n-    let range = decl.value.name()?.syntax().text_range();\n-\n-    let position = FilePosition { file_id: decl.file_id.original_file(db), offset: range.start() };\n-    let mut change = rename_mod(&sema, position, module, new_name_stem).ok()?.info;\n+    let mut change = rename_mod(&sema, module, new_name_stem).ok()?.info;\n     change.file_system_edits.clear();\n     Some(change)\n }\n@@ -124,40 +123,51 @@ fn check_identifier(new_name: &str) -> RenameResult<IdentifierKind> {\n     }\n }\n \n-fn find_module_at_offset(\n+enum NameLike {\n+    Name(ast::Name),\n+    NameRef(ast::NameRef),\n+    Lifetime(ast::Lifetime),\n+}\n+\n+fn find_name_like(\n     sema: &Semantics<RootDatabase>,\n-    position: FilePosition,\n     syntax: &SyntaxNode,\n-) -> Option<Module> {\n-    let ident = syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::IDENT)?;\n-\n-    let module = match_ast! {\n-        match (ident.parent()) {\n-            ast::NameRef(name_ref) => {\n-                match NameRefClass::classify(sema, &name_ref)? {\n-                    NameRefClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n-                    _ => return None,\n-                }\n-            },\n-            ast::Name(name) => {\n-                match NameClass::classify(&sema, &name)? {\n-                    NameClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n-                    _ => return None,\n-                }\n-            },\n-            _ => return None,\n-        }\n+    position: FilePosition,\n+) -> Option<NameLike> {\n+    let namelike = if let Some(name_ref) =\n+        sema.find_node_at_offset_with_descend::<ast::NameRef>(syntax, position.offset)\n+    {\n+        NameLike::NameRef(name_ref)\n+    } else if let Some(name) =\n+        sema.find_node_at_offset_with_descend::<ast::Name>(syntax, position.offset)\n+    {\n+        NameLike::Name(name)\n+    } else if let Some(lifetime) =\n+        sema.find_node_at_offset_with_descend::<ast::Lifetime>(syntax, position.offset)\n+    {\n+        NameLike::Lifetime(lifetime)\n+    } else {\n+        return None;\n     };\n-\n-    Some(module)\n+    Some(namelike)\n }\n \n-fn find_all_refs(\n+fn find_definition(\n     sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> RenameResult<RangeInfo<ReferenceSearchResult>> {\n-    crate::references::find_all_refs(sema, position, None)\n-        .ok_or_else(|| format_err!(\"No references found at position\"))\n+) -> Option<Definition> {\n+    let def = match find_name_like(sema, syntax, position)? {\n+        NameLike::Name(name) => NameClass::classify(sema, &name)?.referenced_or_defined(sema.db),\n+        NameLike::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref)?.referenced(sema.db),\n+        NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, &lifetime)\n+            .map(|class| NameRefClass::referenced(class, sema.db))\n+            .or_else(|| {\n+                NameClass::classify_lifetime(sema, &lifetime)\n+                    .map(|it| it.referenced_or_defined(sema.db))\n+            })?,\n+    };\n+    Some(def)\n }\n \n fn source_edit_from_references(\n@@ -231,7 +241,6 @@ fn edit_text_range_for_record_field_expr_or_pat(\n \n fn rename_mod(\n     sema: &Semantics<RootDatabase>,\n-    position: FilePosition,\n     module: Module,\n     new_name: &str,\n ) -> RenameResult<RangeInfo<SourceChange>> {\n@@ -241,62 +250,78 @@ fn rename_mod(\n \n     let mut source_change = SourceChange::default();\n \n-    let src = module.definition_source(sema.db);\n-    let file_id = src.file_id.original_file(sema.db);\n-    match src.value {\n-        ModuleSource::SourceFile(..) => {\n-            // mod is defined in path/to/dir/mod.rs\n-            let path = if module.is_mod_rs(sema.db) {\n-                format!(\"../{}/mod.rs\", new_name)\n-            } else {\n-                format!(\"{}.rs\", new_name)\n-            };\n-            let dst = AnchoredPathBuf { anchor: file_id, path };\n-            let move_file = FileSystemEdit::MoveFile { src: file_id, dst };\n-            source_change.push_file_system_edit(move_file);\n-        }\n-        ModuleSource::Module(..) => {}\n-    }\n-\n-    if let Some(src) = module.declaration_source(sema.db) {\n-        let file_id = src.file_id.original_file(sema.db);\n-        let name = src.value.name().unwrap();\n-        source_change.insert_source_edit(\n-            file_id,\n-            TextEdit::replace(name.syntax().text_range(), new_name.into()),\n-        );\n+    let InFile { file_id, value: def_source } = module.definition_source(sema.db);\n+    let file_id = file_id.original_file(sema.db);\n+    if let ModuleSource::SourceFile(..) = def_source {\n+        // mod is defined in path/to/dir/mod.rs\n+        let path = if module.is_mod_rs(sema.db) {\n+            format!(\"../{}/mod.rs\", new_name)\n+        } else {\n+            format!(\"{}.rs\", new_name)\n+        };\n+        let dst = AnchoredPathBuf { anchor: file_id, path };\n+        let move_file = FileSystemEdit::MoveFile { src: file_id, dst };\n+        source_change.push_file_system_edit(move_file);\n+    }\n+\n+    if let Some(InFile { file_id, value: decl_source }) = module.declaration_source(sema.db) {\n+        let file_id = file_id.original_file(sema.db);\n+        match decl_source.name() {\n+            Some(name) => source_change.insert_source_edit(\n+                file_id,\n+                TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n+            ),\n+            _ => unreachable!(),\n+        };\n     }\n-\n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n-    let ref_edits = refs.references().iter().map(|(&file_id, references)| {\n+    let def = Definition::ModuleDef(ModuleDef::Module(module));\n+    let usages = def.usages(sema).all();\n+    let ref_edits = usages.iter().map(|(&file_id, references)| {\n         source_edit_from_references(sema, file_id, references, new_name)\n     });\n     source_change.extend(ref_edits);\n \n-    Ok(RangeInfo::new(range, source_change))\n+    Ok(RangeInfo::new(TextRange::default(), source_change))\n }\n \n fn rename_to_self(\n     sema: &Semantics<RootDatabase>,\n-    position: FilePosition,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n-    let source_file = sema.parse(position.file_id);\n-    let syn = source_file.syntax();\n+    local: hir::Local,\n+) -> RenameResult<RangeInfo<SourceChange>> {\n+    if assert_never!(local.is_self(sema.db)) {\n+        bail!(\"rename_to_self invoked on self\");\n+    }\n+\n+    let fn_def = match local.parent(sema.db) {\n+        hir::DefWithBody::Function(func) => func,\n+        _ => bail!(\"Cannot rename non-param local to self\"),\n+    };\n+\n+    // FIXME: reimplement this on the hir instead\n+    // as of the time of this writing params in hir don't keep their names\n+    let fn_ast =\n+        fn_def.source(sema.db).ok_or(format_err!(\"Cannot rename non-param local to self\"))?.value;\n \n-    let (fn_def, fn_ast) = find_node_at_offset::<ast::Fn>(syn, position.offset)\n-        .and_then(|fn_ast| sema.to_def(&fn_ast).zip(Some(fn_ast)))\n-        .ok_or_else(|| format_err!(\"No surrounding method declaration found\"))?;\n-    let param_range = fn_ast\n+    let first_param_range = fn_ast\n         .param_list()\n         .and_then(|p| p.params().next())\n         .ok_or_else(|| format_err!(\"Method has no parameters\"))?\n         .syntax()\n         .text_range();\n-    if !param_range.contains(position.offset) {\n-        bail!(\"Only the first parameter can be self\");\n+    let InFile { file_id, value: local_source } = local.source(sema.db);\n+    match local_source {\n+        either::Either::Left(pat)\n+            if !first_param_range.contains_range(pat.syntax().text_range()) =>\n+        {\n+            bail!(\"Only the first parameter can be self\");\n+        }\n+        _ => (),\n     }\n \n-    let impl_block = find_node_at_offset::<ast::Impl>(syn, position.offset)\n+    let impl_block = fn_ast\n+        .syntax()\n+        .ancestors()\n+        .find_map(|node| ast::Impl::cast(node))\n         .and_then(|def| sema.to_def(&def))\n         .ok_or_else(|| format_err!(\"No impl block found for function\"))?;\n     if fn_def.self_param(sema.db).is_some() {\n@@ -320,33 +345,29 @@ fn rename_to_self(\n         bail!(\"Parameter type differs from impl block type\");\n     }\n \n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n-\n+    let def = Definition::Local(local);\n+    let usages = def.usages(sema).all();\n     let mut source_change = SourceChange::default();\n-    source_change.extend(refs.references().iter().map(|(&file_id, references)| {\n+    source_change.extend(usages.iter().map(|(&file_id, references)| {\n         source_edit_from_references(sema, file_id, references, \"self\")\n     }));\n     source_change.insert_source_edit(\n-        position.file_id,\n-        TextEdit::replace(param_range, String::from(self_param)),\n+        file_id.original_file(sema.db),\n+        TextEdit::replace(first_param_range, String::from(self_param)),\n     );\n \n-    Ok(RangeInfo::new(range, source_change))\n+    Ok(RangeInfo::new(TextRange::default(), source_change))\n }\n \n-fn text_edit_from_self_param(\n-    syn: &SyntaxNode,\n-    self_param: &ast::SelfParam,\n-    new_name: &str,\n-) -> Option<TextEdit> {\n+fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: &str) -> Option<TextEdit> {\n     fn target_type_name(impl_def: &ast::Impl) -> Option<String> {\n         if let Some(ast::Type::PathType(p)) = impl_def.self_ty() {\n             return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n         }\n         None\n     }\n \n-    let impl_def = find_node_at_offset::<ast::Impl>(syn, self_param.syntax().text_range().start())?;\n+    let impl_def = self_param.syntax().ancestors().find_map(|it| ast::Impl::cast(it))?;\n     let type_name = target_type_name(&impl_def)?;\n \n     let mut replacement_text = String::from(new_name);\n@@ -363,94 +384,119 @@ fn text_edit_from_self_param(\n \n fn rename_self_to_param(\n     sema: &Semantics<RootDatabase>,\n-    position: FilePosition,\n+    local: hir::Local,\n     new_name: &str,\n-    ident_kind: IdentifierKind,\n-    range: TextRange,\n-    refs: ReferenceSearchResult,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n-    match ident_kind {\n-        IdentifierKind::Lifetime => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-        IdentifierKind::ToSelf => {\n-            // no-op\n-            mark::hit!(rename_self_to_self);\n-            return Ok(RangeInfo::new(range, SourceChange::default()));\n+    identifier_kind: IdentifierKind,\n+) -> RenameResult<RangeInfo<SourceChange>> {\n+    let (file_id, self_param) = match local.source(sema.db) {\n+        InFile { file_id, value: Either::Right(self_param) } => (file_id, self_param),\n+        _ => {\n+            assert_never!(true, \"rename_self_to_param invoked on a non-self local\");\n+            bail!(\"rename_self_to_param invoked on a non-self local\");\n         }\n-        _ => (),\n-    }\n-    let source_file = sema.parse(position.file_id);\n-    let syn = source_file.syntax();\n-\n-    let fn_def = find_node_at_offset::<ast::Fn>(syn, position.offset)\n-        .ok_or_else(|| format_err!(\"No surrounding method declaration found\"))?;\n-\n-    let mut source_change = SourceChange::default();\n-    if let Some(self_param) = fn_def.param_list().and_then(|it| it.self_param()) {\n-        if self_param\n-            .syntax()\n-            .text_range()\n-            .contains_range(refs.declaration().nav.focus_or_full_range())\n-        {\n-            let edit = text_edit_from_self_param(syn, &self_param, new_name)\n-                .ok_or_else(|| format_err!(\"No target type found\"))?;\n-            source_change.insert_source_edit(position.file_id, edit);\n-\n-            source_change.extend(refs.references().iter().map(|(&file_id, references)| {\n-                source_edit_from_references(sema, file_id, &references, new_name)\n-            }));\n-\n-            if source_change.source_file_edits.len() > 1 && ident_kind == IdentifierKind::Underscore\n-            {\n-                bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n-            }\n+    };\n \n-            return Ok(RangeInfo::new(range, source_change));\n-        }\n+    let def = Definition::Local(local);\n+    let usages = def.usages(sema).all();\n+    let edit = text_edit_from_self_param(&self_param, new_name)\n+        .ok_or_else(|| format_err!(\"No target type found\"))?;\n+    if usages.len() > 1 && identifier_kind == IdentifierKind::Underscore {\n+        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n     }\n-    Err(format_err!(\"Method has no self param\"))\n+    let mut source_change = SourceChange::default();\n+    source_change.insert_source_edit(file_id.original_file(sema.db), edit);\n+    source_change.extend(usages.iter().map(|(&file_id, references)| {\n+        source_edit_from_references(sema, file_id, &references, new_name)\n+    }));\n+    Ok(RangeInfo::new(TextRange::default(), source_change))\n }\n \n fn rename_reference(\n     sema: &Semantics<RootDatabase>,\n-    position: FilePosition,\n+    def: Definition,\n     new_name: &str,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n+) -> RenameResult<RangeInfo<SourceChange>> {\n     let ident_kind = check_identifier(new_name)?;\n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n \n-    match (ident_kind, &refs.declaration.kind) {\n-        (IdentifierKind::ToSelf, ReferenceKind::Lifetime)\n-        | (IdentifierKind::Underscore, ReferenceKind::Lifetime)\n-        | (IdentifierKind::Ident, ReferenceKind::Lifetime) => {\n+    let def_is_lbl_or_lt = matches!(def,\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_))\n+        | Definition::Label(_)\n+    );\n+    match (ident_kind, def) {\n+        (IdentifierKind::ToSelf, _)\n+        | (IdentifierKind::Underscore, _)\n+        | (IdentifierKind::Ident, _)\n+            if def_is_lbl_or_lt =>\n+        {\n             mark::hit!(rename_not_a_lifetime_ident_ref);\n             bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n         }\n-        (IdentifierKind::Lifetime, ReferenceKind::Lifetime) => mark::hit!(rename_lifetime),\n+        (IdentifierKind::Lifetime, _) if def_is_lbl_or_lt => mark::hit!(rename_lifetime),\n         (IdentifierKind::Lifetime, _) => {\n             mark::hit!(rename_not_an_ident_ref);\n             bail!(\"Invalid name `{}`: not an identifier\", new_name)\n         }\n-        (_, ReferenceKind::SelfParam) => {\n+        (IdentifierKind::ToSelf, Definition::Local(local)) if local.is_self(sema.db) => {\n+            // no-op\n+            mark::hit!(rename_self_to_self);\n+            return Ok(RangeInfo::new(TextRange::default(), SourceChange::default()));\n+        }\n+        (ident_kind, Definition::Local(local)) if local.is_self(sema.db) => {\n             mark::hit!(rename_self_to_param);\n-            return rename_self_to_param(sema, position, new_name, ident_kind, range, refs);\n+            return rename_self_to_param(sema, local, new_name, ident_kind);\n         }\n-        (IdentifierKind::ToSelf, _) => {\n+        (IdentifierKind::ToSelf, Definition::Local(local)) => {\n             mark::hit!(rename_to_self);\n-            return rename_to_self(sema, position);\n-        }\n-        (IdentifierKind::Underscore, _) if !refs.references.is_empty() => {\n-            mark::hit!(rename_underscore_multiple);\n-            bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\")\n+            return rename_to_self(sema, local);\n         }\n+        (IdentifierKind::ToSelf, _) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n         (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n     }\n \n+    let usages = def.usages(sema).all();\n+    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n+        mark::hit!(rename_underscore_multiple);\n+        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+    }\n     let mut source_change = SourceChange::default();\n-    source_change.extend(refs.into_iter().map(|(file_id, references)| {\n+    source_change.extend(usages.iter().map(|(&file_id, references)| {\n         source_edit_from_references(sema, file_id, &references, new_name)\n     }));\n \n-    Ok(RangeInfo::new(range, source_change))\n+    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n+    source_change.insert_source_edit(file_id, edit);\n+    Ok(RangeInfo::new(TextRange::default(), source_change))\n+}\n+\n+fn source_edit_from_def(\n+    sema: &Semantics<RootDatabase>,\n+    def: Definition,\n+    new_name: &str,\n+) -> RenameResult<(FileId, TextEdit)> {\n+    let nav = def.try_to_nav(sema.db).unwrap();\n+\n+    let mut replacement_text = String::new();\n+    let mut repl_range = nav.focus_or_full_range();\n+    if let Definition::Local(local) = def {\n+        if let Either::Left(pat) = local.source(sema.db).value {\n+            if matches!(\n+                pat.syntax().parent().and_then(ast::RecordPatField::cast),\n+                Some(pat_field) if pat_field.name_ref().is_none()\n+            ) {\n+                replacement_text.push_str(\": \");\n+                replacement_text.push_str(new_name);\n+                repl_range = TextRange::new(\n+                    pat.syntax().text_range().end(),\n+                    pat.syntax().text_range().end(),\n+                );\n+            }\n+        }\n+    }\n+    if replacement_text.is_empty() {\n+        replacement_text.push_str(new_name);\n+    }\n+    let edit = TextEdit::replace(repl_range, replacement_text);\n+    Ok((nav.file_id, edit))\n }\n \n #[cfg(test)]\n@@ -872,7 +918,7 @@ mod foo$0;\n \"#,\n             expect![[r#\"\n                 RangeInfo {\n-                    range: 4..7,\n+                    range: 0..0,\n                     info: SourceChange {\n                         source_file_edits: {\n                             FileId(\n@@ -924,7 +970,7 @@ use crate::foo$0::FooContent;\n \"#,\n             expect![[r#\"\n                 RangeInfo {\n-                    range: 11..14,\n+                    range: 0..0,\n                     info: SourceChange {\n                         source_file_edits: {\n                             FileId(\n@@ -980,7 +1026,7 @@ mod fo$0o;\n \"#,\n             expect![[r#\"\n                 RangeInfo {\n-                    range: 4..7,\n+                    range: 0..0,\n                     info: SourceChange {\n                         source_file_edits: {\n                             FileId(\n@@ -1027,7 +1073,7 @@ mod outer { mod fo$0o; }\n \"#,\n             expect![[r#\"\n                 RangeInfo {\n-                    range: 16..19,\n+                    range: 0..0,\n                     info: SourceChange {\n                         source_file_edits: {\n                             FileId(\n@@ -1097,7 +1143,7 @@ pub mod foo$0;\n \"#,\n             expect![[r#\"\n                 RangeInfo {\n-                    range: 8..11,\n+                    range: 0..0,\n                     info: SourceChange {\n                         source_file_edits: {\n                             FileId("}]}