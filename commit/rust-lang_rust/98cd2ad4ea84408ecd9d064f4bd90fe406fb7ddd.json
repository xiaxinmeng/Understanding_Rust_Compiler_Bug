{"sha": "98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4Y2QyYWQ0ZWE4NDQwOGVjZDlkMDY0ZjRiZDkwZmU0MDZmYjdkZGQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-12T07:30:52Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-24T10:36:31Z"}, "message": "Move some methods from `Memory` to `Allocation`", "tree": {"sha": "54272f7a5cc10322e4d3725ed91b42c0ea2fbe11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54272f7a5cc10322e4d3725ed91b42c0ea2fbe11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd", "html_url": "https://github.com/rust-lang/rust/commit/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4632cf2a2e8c1720e3ae06920d945c4ac8ecbbd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4632cf2a2e8c1720e3ae06920d945c4ac8ecbbd3", "html_url": "https://github.com/rust-lang/rust/commit/4632cf2a2e8c1720e3ae06920d945c4ac8ecbbd3"}], "stats": {"total": 168, "additions": 84, "deletions": 84}, "files": [{"sha": "1a88a959b4eb056cfaf5146526dfc5a8a3635d72", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd", "patch": "@@ -49,6 +49,90 @@ pub struct Allocation<Tag=(),Extra=()> {\n     pub extra: Extra,\n }\n \n+/// Byte accessors\n+impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n+    /// The last argument controls whether we error out when there are undefined\n+    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// `get_bytes_with_undef_and_ptr` instead,\n+    ///\n+    /// This function also guarantees that the resulting pointer will remain stable\n+    /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n+    /// on that.\n+    fn get_bytes_internal(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        size: Size,\n+        align: Align,\n+        check_defined_and_ptr: bool,\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n+        self.check_align(ptr.into(), align)?;\n+        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n+\n+        if check_defined_and_ptr {\n+            self.check_defined(ptr, size)?;\n+            self.check_relocations(ptr, size)?;\n+        } else {\n+            // We still don't want relocations on the *edges*\n+            self.check_relocation_edges(ptr, size)?;\n+        }\n+\n+        let alloc = self.get(ptr.alloc_id)?;\n+        AllocationExtra::memory_read(alloc, ptr, size)?;\n+\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n+    }\n+\n+    #[inline]\n+    fn get_bytes(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        size: Size,\n+        align: Align\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(ptr, size, align, true)\n+    }\n+\n+    /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    /// However, this still checks that there are no relocations on the *edges*.\n+    #[inline]\n+    fn get_bytes_with_undef_and_ptr(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        size: Size,\n+        align: Align\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(ptr, size, align, false)\n+    }\n+\n+    /// Just calling this already marks everything as defined and removes relocations,\n+    /// so be sure to actually put data there!\n+    fn get_bytes_mut(\n+        &mut self,\n+        ptr: Pointer<M::PointerTag>,\n+        size: Size,\n+        align: Align,\n+    ) -> EvalResult<'tcx, &mut [u8]> {\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n+        self.check_align(ptr.into(), align)?;\n+        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n+\n+        self.mark_definedness(ptr, size, true)?;\n+        self.clear_relocations(ptr, size)?;\n+\n+        let alloc = self.get_mut(ptr.alloc_id)?;\n+        AllocationExtra::memory_written(alloc, ptr, size)?;\n+\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n+    }\n+}\n+\n pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Default + Clone {\n     /// Hook for performing extra checks on a memory read access.\n     ///"}, {"sha": "759892451bd9480623d695e953de39c7128dce1f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=98cd2ad4ea84408ecd9d064f4bd90fe406fb7ddd", "patch": "@@ -609,90 +609,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n }\n \n-/// Byte accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// The last argument controls whether we error out when there are undefined\n-    /// or pointer bytes.  You should never call this, call `get_bytes` or\n-    /// `get_bytes_with_undef_and_ptr` instead,\n-    ///\n-    /// This function also guarantees that the resulting pointer will remain stable\n-    /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n-    /// on that.\n-    fn get_bytes_internal(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        align: Align,\n-        check_defined_and_ptr: bool,\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n-\n-        if check_defined_and_ptr {\n-            self.check_defined(ptr, size)?;\n-            self.check_relocations(ptr, size)?;\n-        } else {\n-            // We still don't want relocations on the *edges*\n-            self.check_relocation_edges(ptr, size)?;\n-        }\n-\n-        let alloc = self.get(ptr.alloc_id)?;\n-        AllocationExtra::memory_read(alloc, ptr, size)?;\n-\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n-    }\n-\n-    #[inline]\n-    fn get_bytes(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        align: Align\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(ptr, size, align, true)\n-    }\n-\n-    /// It is the caller's responsibility to handle undefined and pointer bytes.\n-    /// However, this still checks that there are no relocations on the *edges*.\n-    #[inline]\n-    fn get_bytes_with_undef_and_ptr(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        align: Align\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(ptr, size, align, false)\n-    }\n-\n-    /// Just calling this already marks everything as defined and removes relocations,\n-    /// so be sure to actually put data there!\n-    fn get_bytes_mut(\n-        &mut self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        align: Align,\n-    ) -> EvalResult<'tcx, &mut [u8]> {\n-        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n-\n-        self.mark_definedness(ptr, size, true)?;\n-        self.clear_relocations(ptr, size)?;\n-\n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-        AllocationExtra::memory_written(alloc, ptr, size)?;\n-\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n-    }\n-}\n-\n /// Interning (for CTFE)\n impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n where"}]}