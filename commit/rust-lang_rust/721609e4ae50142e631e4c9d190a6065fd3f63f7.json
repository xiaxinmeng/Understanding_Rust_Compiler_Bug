{"sha": "721609e4ae50142e631e4c9d190a6065fd3f63f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMTYwOWU0YWU1MDE0MmU2MzFlNGM5ZDE5MGE2MDY1ZmQzZjYzZjc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-18T22:24:26Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-20T01:38:46Z"}, "message": "std::vec: implement a stable merge sort, deferring to insertion sort for\nvery small runs.\n\nThis uses a lot of unsafe code for speed, otherwise we would be having\nto sort by sorting lists of indices and then do a pile of swaps to put\neverything in the correct place.\n\nFixes #9819.", "tree": {"sha": "28f243db34bcff08c8e162a01e6d969b889ce77c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28f243db34bcff08c8e162a01e6d969b889ce77c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721609e4ae50142e631e4c9d190a6065fd3f63f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721609e4ae50142e631e4c9d190a6065fd3f63f7", "html_url": "https://github.com/rust-lang/rust/commit/721609e4ae50142e631e4c9d190a6065fd3f63f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721609e4ae50142e631e4c9d190a6065fd3f63f7/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3906823765b1ec241df4906527a990ec945c4392", "url": "https://api.github.com/repos/rust-lang/rust/commits/3906823765b1ec241df4906527a990ec945c4392", "html_url": "https://github.com/rust-lang/rust/commit/3906823765b1ec241df4906527a990ec945c4392"}], "stats": {"total": 349, "additions": 348, "deletions": 1}, "files": [{"sha": "7cdf155e6142607e1d20d548bb28606450b87c41", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 260, "deletions": 1, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/721609e4ae50142e631e4c9d190a6065fd3f63f7/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721609e4ae50142e631e4c9d190a6065fd3f63f7/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=721609e4ae50142e631e4c9d190a6065fd3f63f7", "patch": "@@ -1921,6 +1921,150 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n+fn merge_sort<T>(v: &mut [T], less_eq: |&T, &T| -> bool) {\n+    // warning: this wildly uses unsafe.\n+    static INSERTION: uint = 8;\n+\n+    let len = v.len();\n+\n+    // allocate some memory to use as scratch memory, we keep the\n+    // length 0 so we can keep shallow copies of the contents of `v`\n+    // without risking the dtors running on an object twice if\n+    // `less_eq` fails.\n+    let mut working_space = with_capacity(2 * len);\n+    // these both are buffers of length `len`.\n+    let mut buf_dat = working_space.as_mut_ptr();\n+    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n+\n+    // length `len`.\n+    let buf_v = v.as_ptr();\n+\n+    // step 1. sort short runs with insertion sort. This takes the\n+    // values from `v` and sorts them into `buf_dat`, leaving that\n+    // with sorted runs of length INSERTION.\n+\n+    // We could hardcode the sorting comparisons here, and we could\n+    // manipulate/step the pointers themselves, rather than repeatedly\n+    // .offset-ing.\n+    for start in range_step(0, len, INSERTION) {\n+        // start <= i <= len;\n+        for i in range(start, cmp::min(start + INSERTION, len)) {\n+            // j satisfies: start <= j <= i;\n+            let mut j = i as int;\n+            unsafe {\n+                // `i` is in bounds.\n+                let read_ptr = buf_v.offset(i as int);\n+\n+                // find where to insert, we need to do strict <,\n+                // rather than <=, to maintain stability.\n+\n+                // start <= j - 1 < len, so .offset(j - 1) is in\n+                // bounds.\n+                while j > start as int && !less_eq(&*buf_dat.offset(j - 1), &*read_ptr) {\n+                    j -= 1;\n+                }\n+\n+                // shift everything to the right, to make space to\n+                // insert this value.\n+\n+                // j + 1 could be `len` (for the last `i`), but in\n+                // that case, `i == j` so we don't copy. The\n+                // `.offset(j)` is always in bounds.\n+                ptr::copy_memory(buf_dat.offset(j + 1),\n+                                 buf_dat.offset(j),\n+                                 i - j as uint);\n+                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n+            }\n+        }\n+    }\n+\n+    // step 2. merge the sorted runs.\n+    let mut width = INSERTION;\n+    while width < len {\n+        // merge the sorted runs of length `width` in `buf_dat` two at\n+        // a time, placing the result in `buf_tmp`.\n+\n+        // 0 <= start <= len.\n+        for start in range_step(0, len, 2 * width) {\n+            // manipulate pointers directly for speed (rather than\n+            // using a `for` loop with `range` and `.offset` inside\n+            // that loop).\n+            unsafe {\n+                // the end of the first run & start of the\n+                // second. Offset of `len` is defined, since this is\n+                // precisely one byte past the end of the object.\n+                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n+                // end of the second. Similar reasoning to the above re safety.\n+                let right_end_idx = cmp::min(start + 2 * width, len);\n+                let right_end = buf_dat.offset(right_end_idx as int);\n+\n+                // the pointers to the elements under consideration\n+                // from the two runs.\n+\n+                // both of these are in bounds.\n+                let mut left = buf_dat.offset(start as int);\n+                let mut right = right_start;\n+\n+                // where we're putting the results, it is a run of\n+                // length `2*width`, so we step it once for each step\n+                // of either `left` or `right`.  `buf_tmp` has length\n+                // `len`, so these are in bounds.\n+                let mut out = buf_tmp.offset(start as int);\n+                let out_end = buf_tmp.offset(right_end_idx as int);\n+\n+                while out < out_end {\n+                    // Either the left or the right run are exhausted,\n+                    // so just copy the remainder from the other run\n+                    // and move on; this gives a huge speed-up (order\n+                    // of 25%) for mostly sorted vectors (the best\n+                    // case).\n+                    if left == right_start {\n+                        // the number remaining in this run.\n+                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, right, elems);\n+                        break;\n+                    } else if right == right_end {\n+                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, left, elems);\n+                        break;\n+                    }\n+\n+                    // check which side is smaller, and that's the\n+                    // next element for the new run.\n+\n+                    // `left < right_start` and `right < right_end`,\n+                    // so these are valid.\n+                    let to_copy = if less_eq(&*left, &*right) {\n+                        step(&mut left)\n+                    } else {\n+                        step(&mut right)\n+                    };\n+                    ptr::copy_nonoverlapping_memory(out, to_copy, 1);\n+                    step(&mut out);\n+                }\n+            }\n+        }\n+\n+        util::swap(&mut buf_dat, &mut buf_tmp);\n+\n+        width *= 2;\n+    }\n+\n+    // write the result to `v` in one go, so that there are never two copies\n+    // of the same object in `v`.\n+    unsafe {\n+        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), buf_dat, len);\n+    }\n+\n+    // increment the pointer, returning the old pointer.\n+    #[inline(always)]\n+    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+        *ptr = ptr.offset(1);\n+        old\n+    }\n+}\n+\n /// Extension methods for vectors such that their elements are\n /// mutable.\n pub trait MutableVector<'a, T> {\n@@ -2020,6 +2164,25 @@ pub trait MutableVector<'a, T> {\n     /// Reverse the order of elements in a vector, in place\n     fn reverse(self);\n \n+    /// Sort the vector, in place, using `less_eq` to compare `a <=\n+    /// b`.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [5, 4, 1, 3, 2];\n+    /// v.sort(|a, b| *a <= *b);\n+    /// assert_eq!(v, [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort(|a, b| *b <= *a);\n+    /// assert_eq!(v, [5, 4, 3, 2, 1]);\n+    /// ```\n+    fn sort(self, less_eq: |&T, &T| -> bool);\n+\n     /**\n      * Consumes `src` and moves as many elements as it can into `self`\n      * from the range [start,end).\n@@ -2164,6 +2327,11 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         }\n     }\n \n+    #[inline]\n+    fn sort(self, less_eq: |&T, &T| -> bool) {\n+        merge_sort(self, less_eq)\n+    }\n+\n     #[inline]\n     fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {\n         for (a, b) in self.mut_iter().zip(src.mut_slice(start, end).mut_iter()) {\n@@ -2692,6 +2860,7 @@ mod tests {\n     use vec::*;\n     use cmp::*;\n     use prelude::*;\n+    use rand::{Rng, task_rng};\n \n     fn square(n: uint) -> uint { n * n }\n \n@@ -3298,6 +3467,57 @@ mod tests {\n         assert!(v3.is_empty());\n     }\n \n+    #[test]\n+    fn test_sort() {\n+        for len in range(4u, 25) {\n+            for _ in range(0, 100) {\n+                let mut v = task_rng().gen_vec::<uint>(len);\n+                v.sort(|a,b| a <= b);\n+\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n+        }\n+\n+        // shouldn't fail/crash\n+        let mut v: [uint, .. 0] = [];\n+        v.sort(|a,b| a <= b);\n+\n+        let mut v = [0xDEADBEEF];\n+        v.sort(|a,b| a <= b);\n+        assert_eq!(v, [0xDEADBEEF]);\n+    }\n+\n+    #[test]\n+    fn test_sort_stability() {\n+        for len in range(4, 25) {\n+            for _ in range(0 , 10) {\n+                let mut counts = [0, .. 10];\n+\n+                // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n+                // where the first item of each tuple is random, but\n+                // the second item represents which occurrence of that\n+                // number this element is, i.e. the second elements\n+                // will occur in sorted order.\n+                let mut v = range(0, len).map(|_| {\n+                        let n = task_rng().gen::<uint>() % 10;\n+                        counts[n] += 1;\n+                        (n, counts[n])\n+                    }).to_owned_vec();\n+\n+                // only sort on the first element, so an unstable sort\n+                // may mix up the counts.\n+                v.sort(|&(a,_), &(b,_)| a <= b);\n+\n+                // this comparison includes the count (the second item\n+                // of the tuple), so elements with equal first items\n+                // will need to be ordered with increasing\n+                // counts... i.e. exactly asserting that this sort is\n+                // stable.\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_partition() {\n         assert_eq!((~[]).partition(|x: &int| *x < 3), (~[], ~[]));\n@@ -4124,7 +4344,8 @@ mod bench {\n     use vec::VectorVector;\n     use option::*;\n     use ptr;\n-    use rand::{weak_rng, Rng};\n+    use rand::{weak_rng, task_rng, Rng};\n+    use mem;\n \n     #[bench]\n     fn iterator(bh: &mut BenchHarness) {\n@@ -4325,4 +4546,42 @@ mod bench {\n                 }\n             })\n     }\n+\n+    fn sort_random_small(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[f64] = rng.gen_vec(5);\n+            v.sort(|a,b| *a <= *b);\n+        });\n+        bh.bytes = 5 * mem::size_of::<f64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_random_medium(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[f64] = rng.gen_vec(100);\n+            v.sort(|a,b| *a <= *b);\n+        });\n+        bh.bytes = 100 * mem::size_of::<f64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_random_large(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[f64] = rng.gen_vec(10000);\n+            v.sort(|a,b| *a <= *b);\n+        });\n+        bh.bytes = 10000 * mem::size_of::<f64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_sorted(bh: &mut BenchHarness) {\n+        let mut v = vec::from_fn(10000, |i| i);\n+        bh.iter(|| {\n+            v.sort(|a,b| *a <= *b);\n+        });\n+        bh.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    }\n }"}, {"sha": "bae101bf58a4e00d58f86476f24b39eece38652a", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/721609e4ae50142e631e4c9d190a6065fd3f63f7/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721609e4ae50142e631e4c9d190a6065fd3f63f7/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=721609e4ae50142e631e4c9d190a6065fd3f63f7", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rand::{task_rng, Rng};\n+\n+static MAX_LEN: uint = 20;\n+static mut drop_counts: [uint, .. MAX_LEN] = [0, .. MAX_LEN];\n+static mut clone_count: uint = 0;\n+\n+#[deriving(Rand, Ord)]\n+struct DropCounter { x: uint, clone_num: uint }\n+\n+impl Clone for DropCounter {\n+    fn clone(&self) -> DropCounter {\n+        let num = unsafe { clone_count };\n+        unsafe { clone_count += 1; }\n+        DropCounter {\n+            x: self.x,\n+            clone_num: num\n+        }\n+    }\n+}\n+\n+impl Drop for DropCounter {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Rand creates some with arbitrary clone_nums\n+            if self.clone_num < MAX_LEN {\n+                drop_counts[self.clone_num] += 1;\n+            }\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    // len can't go above 64.\n+    for len in range(2u, MAX_LEN) {\n+        for _ in range(0, 10) {\n+            let main = task_rng().gen_vec::<DropCounter>(len);\n+\n+            // work out the total number of comparisons required to sort\n+            // this array...\n+            let mut count = 0;\n+            main.clone().sort(|a, b| { count += 1; a <= b });\n+\n+            // ... and then fail on each and every single one.\n+            for fail_countdown in range(0, count) {\n+                // refresh the counters.\n+                unsafe {\n+                    drop_counts = [0, .. MAX_LEN];\n+                    clone_count = 0;\n+                }\n+\n+                let v = main.clone();\n+\n+                std::task::try(proc() {\n+                        let mut v = v;\n+                        let mut fail_countdown = fail_countdown;\n+                        v.sort(|a, b| {\n+                                if fail_countdown == 0 {\n+                                    fail!()\n+                                }\n+                                fail_countdown -= 1;\n+                                a <= b\n+                            })\n+                    });\n+\n+                // check that the number of things dropped is exactly\n+                // what we expect (i.e. the contents of `v`).\n+                unsafe {\n+                    for (i, &c) in drop_counts.iter().enumerate() {\n+                        let expected = if i < len {1} else {0};\n+                        assert!(c == expected,\n+                                \"found drop count == {} for i == {}, len == {}\",\n+                                c, i, len);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}]}