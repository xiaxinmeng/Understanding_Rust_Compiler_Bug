{"sha": "d2ff829433222f563425f3f7b13d20002e0708fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZmY4Mjk0MzMyMjJmNTYzNDI1ZjNmN2IxM2QyMDAwMmUwNzA4ZmQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-11-30T14:12:41Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-25T20:29:29Z"}, "message": "Update variances_of", "tree": {"sha": "14711a81c714c7665ec1489d860866f0d16182eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14711a81c714c7665ec1489d860866f0d16182eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ff829433222f563425f3f7b13d20002e0708fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ff829433222f563425f3f7b13d20002e0708fd", "html_url": "https://github.com/rust-lang/rust/commit/d2ff829433222f563425f3f7b13d20002e0708fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ff829433222f563425f3f7b13d20002e0708fd/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f024196dd5468aeb684ac7437dc51dbf84dab67d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f024196dd5468aeb684ac7437dc51dbf84dab67d", "html_url": "https://github.com/rust-lang/rust/commit/f024196dd5468aeb684ac7437dc51dbf84dab67d"}], "stats": {"total": 55, "additions": 29, "deletions": 26}, "files": [{"sha": "c4435070ba6c7a2dd9631e7f8ed7dae09519f401", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=d2ff829433222f563425f3f7b13d20002e0708fd", "patch": "@@ -102,6 +102,14 @@ impl<'tcx> Arena<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn alloc_slice<T: Copy>(&self, value: &[T]) -> &mut [T] {\n+        if value.len() == 0 {\n+            return &mut []\n+        }\n+        self.dropless.alloc_slice(value)\n+    }\n+\n     pub fn alloc_from_iter<\n         T: ArenaAllocatable,\n         I: IntoIterator<Item = T>"}, {"sha": "fbe79925a88db1a688066a4d5840bd924dacce9a", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=d2ff829433222f563425f3f7b13d20002e0708fd", "patch": "@@ -245,13 +245,13 @@ rustc_queries! {\n \n         /// Get a map with the variance of every item; use `item_variance`\n         /// instead.\n-        query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap> {\n+        query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap<'tcx>> {\n             desc { \"computing the variances for items in this crate\" }\n         }\n \n         /// Maps from def-id of a type or region parameter to its\n         /// (inferred) variance.\n-        query variances_of(_: DefId) -> Lrc<Vec<ty::Variance>> {}\n+        query variances_of(_: DefId) -> &'tcx [ty::Variance] {}\n     }\n \n     TypeChecking {"}, {"sha": "0b862db89a6b658c0d1c4681aed3a88424879b26", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d2ff829433222f563425f3f7b13d20002e0708fd", "patch": "@@ -330,15 +330,11 @@ pub enum Variance {\n /// `tcx.variances_of()` to get the variance for a *particular*\n /// item.\n #[derive(HashStable)]\n-pub struct CrateVariancesMap {\n+pub struct CrateVariancesMap<'tcx> {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics. If an item has no generics, it will have no\n     /// entry.\n-    pub variances: FxHashMap<DefId, Lrc<Vec<ty::Variance>>>,\n-\n-    /// An empty vector, useful for cloning.\n-    #[stable_hasher(ignore)]\n-    pub empty_variance: Lrc<Vec<ty::Variance>>,\n+    pub variances: FxHashMap<DefId, &'tcx [ty::Variance]>,\n }\n \n impl Variance {"}, {"sha": "601226182ed6277f5276ae5580ddc063ef6218e5", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d2ff829433222f563425f3f7b13d20002e0708fd", "patch": "@@ -60,7 +60,7 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n                b_subst);\n \n         let opt_variances = self.tcx().variances_of(item_def_id);\n-        relate_substs(self, Some(&opt_variances), a_subst, b_subst)\n+        relate_substs(self, Some(opt_variances), a_subst, b_subst)\n     }\n \n     /// Switch variance for the purpose of relating `a` and `b`.\n@@ -122,7 +122,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                        variances: Option<&Vec<ty::Variance>>,\n+                                        variances: Option<&[ty::Variance]>,\n                                         a_subst: SubstsRef<'tcx>,\n                                         b_subst: SubstsRef<'tcx>)\n                                         -> RelateResult<'tcx, SubstsRef<'tcx>>"}, {"sha": "483fd64245b0b87f2156eb6ba8cf11324d4ce317", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d2ff829433222f563425f3f7b13d20002e0708fd", "patch": "@@ -106,7 +106,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let _ = cdata;\n         tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n     }\n-    variances_of => { Lrc::new(cdata.get_item_variances(def_id.index)) }\n+    variances_of => { tcx.arena.alloc_from_iter(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {\n         let mut result = vec![];\n         cdata.each_child_of_item(def_id.index,"}, {"sha": "88ee1d79f5435dd165bc30e1402a1c191f5915fa", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=d2ff829433222f563425f3f7b13d20002e0708fd", "patch": "@@ -36,7 +36,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n-                             -> Lrc<CrateVariancesMap> {\n+                             -> Lrc<CrateVariancesMap<'tcx>> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n@@ -45,7 +45,7 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n }\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n-                          -> Lrc<Vec<ty::Variance>> {\n+                          -> &'tcx [ty::Variance] {\n     let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant.\n@@ -88,6 +88,6 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n \n     let crate_map = tcx.crate_variances(LOCAL_CRATE);\n     crate_map.variances.get(&item_def_id)\n-                       .unwrap_or(&crate_map.empty_variance)\n-                       .clone()\n+                       .map(|p| *p)\n+                       .unwrap_or(&[])\n }"}, {"sha": "8edf3c52ccc221807d34fdeb65cf6f04f63b11ae", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff829433222f563425f3f7b13d20002e0708fd/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=d2ff829433222f563425f3f7b13d20002e0708fd", "patch": "@@ -8,7 +8,6 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n \n use super::constraints::*;\n use super::terms::*;\n@@ -23,7 +22,9 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext<'_, '_>) -> ty::CrateVariancesMap {\n+pub fn solve_constraints<'tcx>(\n+    constraints_cx: ConstraintContext<'_, 'tcx>\n+) -> ty::CrateVariancesMap<'tcx> {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n     let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n@@ -41,9 +42,8 @@ pub fn solve_constraints(constraints_cx: ConstraintContext<'_, '_>) -> ty::Crate\n     };\n     solutions_cx.solve();\n     let variances = solutions_cx.create_map();\n-    let empty_variance = Lrc::new(Vec::new());\n \n-    ty::CrateVariancesMap { variances, empty_variance }\n+    ty::CrateVariancesMap { variances }\n }\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn enforce_const_invariance(&self, generics: &ty::Generics, variances: &mut Vec<ty::Variance>) {\n+    fn enforce_const_invariance(&self, generics: &ty::Generics, variances: &mut [ty::Variance]) {\n         let tcx = self.terms_cx.tcx;\n \n         // Make all const parameters invariant.\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn create_map(&self) -> FxHashMap<DefId, Lrc<Vec<ty::Variance>>> {\n+    fn create_map(&self) -> FxHashMap<DefId, &'tcx [ty::Variance]> {\n         let tcx = self.terms_cx.tcx;\n \n         let solutions = &self.solutions;\n@@ -103,22 +103,21 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             let generics = tcx.generics_of(def_id);\n             let count = generics.count();\n \n-            let mut variances = solutions[start..(start + count)].to_vec();\n-            debug!(\"id={} variances={:?}\", id, variances);\n+            let variances = tcx.arena.alloc_slice(&solutions[start..(start + count)]);\n \n             // Const parameters are always invariant.\n-            self.enforce_const_invariance(generics, &mut variances);\n+            self.enforce_const_invariance(generics, variances);\n \n             // Functions are permitted to have unused generic parameters: make those invariant.\n             if let ty::FnDef(..) = tcx.type_of(def_id).sty {\n-                for variance in &mut variances {\n+                for variance in variances.iter_mut() {\n                     if *variance == ty::Bivariant {\n                         *variance = ty::Invariant;\n                     }\n                 }\n             }\n \n-            (def_id, Lrc::new(variances))\n+            (def_id, &*variances)\n         }).collect()\n     }\n "}]}