{"sha": "dc14a108ae25fb135ea47fd683de87d1da5fc49e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMTRhMTA4YWUyNWZiMTM1ZWE0N2ZkNjgzZGU4N2QxZGE1ZmM0OWU=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-11-24T23:08:40Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-30T14:17:27Z"}, "message": "Fix intrinsics and expand tests", "tree": {"sha": "7a0b83f63ee5065aaaa6f6fed4e7fd8b14bdf413", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a0b83f63ee5065aaaa6f6fed4e7fd8b14bdf413"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc14a108ae25fb135ea47fd683de87d1da5fc49e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc14a108ae25fb135ea47fd683de87d1da5fc49e", "html_url": "https://github.com/rust-lang/rust/commit/dc14a108ae25fb135ea47fd683de87d1da5fc49e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc14a108ae25fb135ea47fd683de87d1da5fc49e/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ec09187c5d75a49659a82882a97cc93baff5af", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ec09187c5d75a49659a82882a97cc93baff5af", "html_url": "https://github.com/rust-lang/rust/commit/85ec09187c5d75a49659a82882a97cc93baff5af"}], "stats": {"total": 138, "additions": 84, "deletions": 54}, "files": [{"sha": "274709f28ea8947f8b2401a7467d9a678c22e6f6", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 68, "deletions": 54, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/dc14a108ae25fb135ea47fd683de87d1da5fc49e/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc14a108ae25fb135ea47fd683de87d1da5fc49e/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=dc14a108ae25fb135ea47fd683de87d1da5fc49e", "patch": "@@ -24,10 +24,15 @@\n \n #![allow(non_camel_case_types, unused_variables)]\n \n-\n #[cfg(any(target_pointer_width=\"32\", target_pointer_width=\"16\"))]\n pub mod reimpls {\n+\n     #![allow(unused_comparisons)]\n+\n+    use core::intrinsics::unchecked_div;\n+    use core::intrinsics::unchecked_rem;\n+    use core::ptr;\n+\n     // C API is expected to tolerate some amount of size mismatch in ABI. Hopefully the amount of\n     // handling is sufficient for bootstrapping.\n     #[cfg(stage0)]\n@@ -112,26 +117,27 @@ pub mod reimpls {\n     pub extern fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n         unsafe {\n         if !rem.is_null() {\n-            *rem = n % d;\n+            *rem = unchecked_rem(n, d);\n         }\n-        n / d\n+        unchecked_div(n, d)\n         }\n     }\n \n     #[cfg(not(stage0))]\n     #[export_name=\"__udivmodti4\"]\n     pub extern fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+        // Translated from Figure 3-40 of The PowerPC Compiler Writer's Guide\n         unsafe {\n-        // NOTE X is unknown, K != 0\n+        // special cases, X is unknown, K != 0\n         if n.high() == 0 {\n             if d.high() == 0 {\n                 // 0 X\n                 // ---\n                 // 0 X\n                 if !rem.is_null() {\n-                    *rem = u128::from(n.low() % d.low());\n+                    *rem = u128::from(unchecked_rem(n.low(), d.low()));\n                 }\n-                return u128::from(n.low() / d.low());\n+                return u128::from(unchecked_div(n.low(), d.low()));\n             } else {\n                 // 0 X\n                 // ---\n@@ -152,17 +158,20 @@ pub mod reimpls {\n                 // K X\n                 // ---\n                 // 0 0\n-                unimplemented()\n+                if !rem.is_null() {\n+                    *rem = u128::from(unchecked_rem(n.high(), d.low()));\n+                }\n+                return u128::from(unchecked_div(n.high(), d.low()));\n             }\n \n             if n.low() == 0 {\n                 // K 0\n                 // ---\n                 // K 0\n                 if !rem.is_null() {\n-                    *rem = u128::from_parts(0, n.high() % d.high());\n+                    *rem = u128::from_parts(0, unchecked_rem(n.high(), d.high()));\n                 }\n-                return u128::from(n.high() / d.high());\n+                return u128::from(unchecked_div(n.high(), d.high()));\n             }\n \n             // K K\n@@ -176,6 +185,9 @@ pub mod reimpls {\n                 return u128::from(n.high() >> d.high().trailing_zeros());\n             }\n \n+            // K K\n+            // ---\n+            // K 0\n             sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n \n             // D > N\n@@ -188,8 +200,8 @@ pub mod reimpls {\n \n             sr += 1;\n \n-            // 1 <= sr <= u32::bits() - 1\n-            q = n << (128 - sr);\n+            // 1 <= sr <= u64::bits() - 1\n+            q = n << (64 - sr);\n             r = n >> sr;\n         } else {\n             if d.high() == 0 {\n@@ -214,6 +226,10 @@ pub mod reimpls {\n                 // 2 <= sr <= u64::bits() - 1\n                 q = n << (128 - sr);\n                 r = n >> sr;\n+                // FIXME the C compiler-rt implementation has something here\n+                // that looks like a speed optimisation.\n+                // It would be worth a try to port it to Rust too and\n+                // compare the speed.\n             } else {\n                 // K X\n                 // ---\n@@ -292,23 +308,17 @@ pub mod reimpls {\n         let sb = b.signum();\n         let a = a.abs();\n         let b = b.abs();\n-        let sr = sa ^ sb;\n-        unsafe {\n-            let mut r = ::core::mem::zeroed();\n-            if sa == -1 {\n-                -(u128_div_mod(a as u128_, b as u128_, &mut r) as i128_)\n-            } else {\n-                u128_div_mod(a as u128_, b as u128_, &mut r) as i128_\n-            }\n+        let sr = sa * sb; // sign of quotient\n+        if sr == -1 {\n+            -(u128_div_mod(a as u128_, b as u128_, ptr::null_mut()) as i128_)\n+        } else {\n+            u128_div_mod(a as u128_, b as u128_, ptr::null_mut()) as i128_\n         }\n     }\n \n     #[export_name=\"__udivti3\"]\n     pub extern fn u128_div(a: u128_, b: u128_) -> u128_ {\n-        unsafe {\n-            let mut r = ::core::mem::zeroed();\n-            u128_div_mod(a, b, &mut r)\n-        }\n+        u128_div_mod(a, b, ptr::null_mut())\n     }\n \n     macro_rules! mulo {\n@@ -329,37 +339,32 @@ pub mod reimpls {\n                 return result;\n             }\n \n-            let bits = ::core::mem::size_of::<$ty>() * 8;\n-            let sa = a >> (bits - 1);\n-            let abs_a = (a ^ sa) - sa;\n-            let sb = b >> (bits - 1);\n-            let abs_b = (b ^ sb) - sb;\n+            let sa = a.signum();\n+            let abs_a = a.abs();\n+            let sb = b.signum();\n+            let abs_b = b.abs();\n             if abs_a < 2 || abs_b < 2 {\n                 return result;\n             }\n+            unsafe {\n             if sa == sb {\n-                if abs_a > <$ty>::max_value() / abs_b {\n+                if abs_a > unchecked_div(<$ty>::max_value(), abs_b) {\n                     *overflow = 1;\n                 }\n             } else {\n-                if abs_a > <$ty>::min_value() / -abs_b {\n+                if abs_a > unchecked_div(<$ty>::min_value(), -abs_b) {\n                     *overflow = 1;\n                 }\n             }\n+            }\n             result\n         }}\n     }\n \n     // FIXME: i32 here should be c_int.\n     #[export_name=\"__muloti4\"]\n     pub extern fn i128_mul_oflow(a: i128_, b: i128_, o: &mut i32) -> i128_ {\n-        if let Some(v) = (a as i64).checked_mul(b as i64) {\n-            *o = 0;\n-            v as i128_\n-        } else {\n-            *o = 1;\n-            0\n-        }\n+        mulo!(a, b, o, i128_)\n     }\n \n     pub trait LargeInt {\n@@ -407,7 +412,7 @@ pub mod reimpls {\n             self as u64\n         }\n         fn high(self) -> u64 {\n-            unsafe { *(&self as *const u128 as *const u64) }\n+            unsafe { *(&self as *const u128 as *const u64).offset(1) }\n         }\n         fn from_parts(low: u64, high: u64) -> u128 {\n             #[repr(C, packed)] struct Parts(u64, u64);\n@@ -423,45 +428,49 @@ pub mod reimpls {\n             self as u64\n         }\n         fn high(self) -> i64 {\n-            unsafe { *(&self as *const i128 as *const i64) }\n+            unsafe { *(&self as *const i128 as *const i64).offset(1) }\n         }\n         fn from_parts(low: u64, high: i64) -> i128 {\n             u128::from_parts(low, high as u64) as i128\n         }\n     }\n \n     macro_rules! mul {\n-        ($a:expr, $b:expr, $ty: ty) => {{\n+        ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = ::core::mem::size_of::<$ty>() * 8;\n-            let half_bits = bits / 4;\n+            let half_bits = (::core::mem::size_of::<$tyh>() * 8) / 2;\n             let lower_mask = !0 >> half_bits;\n             let mut low = (a.low() & lower_mask) * (b.low() & lower_mask);\n             let mut t = low >> half_bits;\n             low &= lower_mask;\n             t += (a.low() >> half_bits) * (b.low() & lower_mask);\n             low += (t & lower_mask) << half_bits;\n-            let mut high = t >> half_bits;\n+            let mut high = (t >> half_bits) as $tyh;\n             t = low >> half_bits;\n             low &= lower_mask;\n             t += (b.low() >> half_bits) * (a.low() & lower_mask);\n             low += (t & lower_mask) << half_bits;\n-            high += t >> half_bits;\n-            high += (a.low() >> half_bits) * (b.low() >> half_bits);\n+            high += (t >> half_bits) as $tyh;\n+            high += ((a.low() >> half_bits) * (b.low() >> half_bits)) as $tyh;\n             high = high\n                 .wrapping_add(a.high()\n-                .wrapping_mul(b.low())\n-                .wrapping_add(a.low()\n-                .wrapping_mul(b.high())));\n+                .wrapping_mul(b.low() as $tyh))\n+                .wrapping_add((a.low() as $tyh)\n+                .wrapping_mul(b.high()));\n             <$ty>::from_parts(low, high)\n         }}\n     }\n \n+    #[cfg(stage0)]\n+    #[export_name=\"__multi3\"]\n+    pub extern fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        (a as i64 * b as i64) as i128_\n+    }\n \n+    #[cfg(not(stage0))]\n     #[export_name=\"__multi3\"]\n-    pub extern fn u128_mul(a: u128_, b: u128_) -> u128_ {\n-        (a as u64 * b as u64) as u128_\n-        // mul!(a, b, u128_)\n+    pub extern fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        mul!(a, b, i128_, i64)\n     }\n \n     trait FloatStuff: Sized {\n@@ -471,6 +480,7 @@ pub mod reimpls {\n         const MAX_EXP: i32;\n         const EXP_MASK: Self::ToBytes;\n         const MANTISSA_MASK: Self::ToBytes;\n+        const MANTISSA_LEAD_BIT: Self::ToBytes;\n \n         fn to_bytes(self) -> Self::ToBytes;\n         fn get_exponent(self) -> i32;\n@@ -480,8 +490,9 @@ pub mod reimpls {\n         type ToBytes = u32;\n         const MANTISSA_BITS: u32 = 23;\n         const MAX_EXP: i32 = 127;\n-        const MANTISSA_MASK: u32 = 0x007F_FFFF;\n         const EXP_MASK: u32 = 0x7F80_0000;\n+        const MANTISSA_MASK: u32 = 0x007F_FFFF;\n+        const MANTISSA_LEAD_BIT: u32 = 0x0080_0000;\n \n         fn to_bytes(self) -> u32 { unsafe { ::core::mem::transmute(self) } }\n         fn get_exponent(self) -> i32 {\n@@ -495,6 +506,7 @@ pub mod reimpls {\n         const MAX_EXP: i32 = 1023;\n         const EXP_MASK: u64 = 0x7FF0_0000_0000_0000;\n         const MANTISSA_MASK: u64 = 0x000F_FFFF_FFFF_FFFF;\n+        const MANTISSA_LEAD_BIT: u64 = 0x0010_0000_0000_0000;\n \n         fn to_bytes(self) -> u64 { unsafe { ::core::mem::transmute(self) } }\n         fn get_exponent(self) -> i32 {\n@@ -508,7 +520,8 @@ pub mod reimpls {\n             let repr = $from.to_bytes();\n             let sign = $from.signum();\n             let exponent = $from.get_exponent();\n-            let mantissa = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n             if sign == -1.0 || exponent < 0 { return 0; }\n             if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n                 return !0;\n@@ -537,7 +550,8 @@ pub mod reimpls {\n             let repr = $from.to_bytes();\n             let sign = $from.signum();\n             let exponent = $from.get_exponent();\n-            let mantissa = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n \n             if exponent < 0 { return 0; }\n             if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {"}, {"sha": "4799f0d68bf2cacb1e3dfd3745d1af415ccd2344", "filename": "src/test/run-pass/i128.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc14a108ae25fb135ea47fd683de87d1da5fc49e/src%2Ftest%2Frun-pass%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc14a108ae25fb135ea47fd683de87d1da5fc49e/src%2Ftest%2Frun-pass%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi128.rs?ref=dc14a108ae25fb135ea47fd683de87d1da5fc49e", "patch": "@@ -18,6 +18,9 @@ fn main() {\n     let y: i128 = -2;\n     assert_eq!(!1, y);\n     let z: i128 = 0xABCD_EF;\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z * -z, 0x734C_C2F2_A521);\n     assert_eq!(-z * -z * -z * -z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n     assert_eq!(-z + -z + -z + -z, -0x2AF3_7BC);\n     let k: i128 = -0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210;\n@@ -38,6 +41,10 @@ fn main() {\n     assert_eq!(k as i64, -0xFEDC_BA98_7654_3210);\n     assert_eq!(k as u128, 0xFEDC_BA98_7654_3210_0123_4567_89AB_CDF0);\n     assert_eq!(-k as u128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((-z as f64) as i128, -z);\n+    assert_eq!((-z as f32) as i128, -z);\n+    assert_eq!((-z as f64 * 16.0) as i128, -z * 16);\n+    assert_eq!((-z as f32 * 16.0) as i128, -z * 16);\n     // formatting\n     let j: i128 = -(1 << 67);\n     assert_eq!(\"-147573952589676412928\", format!(\"{}\", j));"}, {"sha": "bd6ff46e8f478d4b35e39c2b399c3356bbd394f4", "filename": "src/test/run-pass/u128.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc14a108ae25fb135ea47fd683de87d1da5fc49e/src%2Ftest%2Frun-pass%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc14a108ae25fb135ea47fd683de87d1da5fc49e/src%2Ftest%2Frun-pass%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu128.rs?ref=dc14a108ae25fb135ea47fd683de87d1da5fc49e", "patch": "@@ -23,6 +23,7 @@ fn main() {\n                y &\n                0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFF);\n     let z: u128 = 0xABCD_EF;\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n     assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n     assert_eq!(z + z + z + z, 0x2AF3_7BC);\n     let k: u128 = 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210;\n@@ -34,6 +35,7 @@ fn main() {\n     assert_eq!(0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n     assert_eq!(0, k % 42);\n     assert_eq!(15, z % 42);\n+    assert_eq!(0x169D_A8020_CEC18, k % 0x3ACB_FE49_FF24_AC);\n     assert_eq!(0x91A2_B3C4_D5E6_F7, k >> 65);\n     assert_eq!(0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n     assert!(k > z);\n@@ -43,6 +45,13 @@ fn main() {\n     assert_eq!(z as u64, 0xABCD_EF);\n     assert_eq!(k as u64, 0xFEDC_BA98_7654_3210);\n     assert_eq!(k as i128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((z as f64) as u128, z);\n+    assert_eq!((z as f32) as u128, z);\n+    assert_eq!((z as f64 * 16.0) as u128, z * 16);\n+    assert_eq!((z as f32 * 16.0) as u128, z * 16);\n+    let l :u128 = 432 << 100;\n+    assert_eq!((l as f32) as u128, l);\n+    assert_eq!((l as f64) as u128, l);\n     // formatting\n     let j: u128 = 1 << 67;\n     assert_eq!(\"147573952589676412928\", format!(\"{}\", j));"}]}