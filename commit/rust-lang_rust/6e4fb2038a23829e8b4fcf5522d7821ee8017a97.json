{"sha": "6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "node_id": "C_kwDOAAsO6NoAKDZlNGZiMjAzOGEyMzgyOWU4YjRmY2Y1NTIyZDc4MjFlZTgwMTdhOTc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-14T23:18:39Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-31T11:47:22Z"}, "message": "Make lowering pull-based.", "tree": {"sha": "228c7a1257510af119622dcbaa282fd9f2dabca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/228c7a1257510af119622dcbaa282fd9f2dabca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "html_url": "https://github.com/rust-lang/rust/commit/6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e4fb2038a23829e8b4fcf5522d7821ee8017a97/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41902f2859e8c23a8b903c187bd20ba780a78c31", "url": "https://api.github.com/repos/rust-lang/rust/commits/41902f2859e8c23a8b903c187bd20ba780a78c31", "html_url": "https://github.com/rust-lang/rust/commit/41902f2859e8c23a8b903c187bd20ba780a78c31"}], "stats": {"total": 175, "additions": 120, "deletions": 55}, "files": [{"sha": "b4dea3aca5275ea89b461e2fc69e6e2ba712cd97", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 62, "deletions": 46, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6e4fb2038a23829e8b4fcf5522d7821ee8017a97/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e4fb2038a23829e8b4fcf5522d7821ee8017a97/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "patch": "@@ -1,16 +1,16 @@\n use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n-use super::{ImplTraitContext, ImplTraitPosition};\n+use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use crate::{Arena, FnDeclKind};\n \n use rustc_ast::ptr::P;\n-use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n+use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::Idx;\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -23,6 +23,7 @@ use std::mem;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n+    pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'lowering>>,\n }\n \n /// When we have a ty alias we *may* have two where clauses. To give the best diagnostics, we set the span\n@@ -45,7 +46,7 @@ fn add_ty_alias_where_clause(\n     }\n }\n \n-impl ItemLowerer<'_, '_, '_> {\n+impl<'a, 'hir> ItemLowerer<'_, 'a, 'hir> {\n     /// Clears (and restores) the `in_scope_lifetimes` field. Used when\n     /// visiting nested items, which never inherit in-scope lifetimes\n     /// from their surrounding environment.\n@@ -73,10 +74,9 @@ impl ItemLowerer<'_, '_, '_> {\n     /// for them.\n     fn with_parent_item_lifetime_defs(\n         &mut self,\n-        parent_item: LocalDefId,\n+        parent_hir: &'hir hir::Item<'hir>,\n         f: impl FnOnce(&mut Self),\n     ) {\n-        let parent_hir = self.lctx.owners[parent_item].unwrap().node().expect_item();\n         let parent_generics = match parent_hir.kind {\n             hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n@@ -98,65 +98,81 @@ impl ItemLowerer<'_, '_, '_> {\n         self.lctx.in_scope_lifetimes = old_in_scope_lifetimes;\n     }\n \n-    fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n+    fn with_trait_impl_ref(\n+        &mut self,\n+        impl_ref: &Option<hir::TraitRef<'_>>,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n         let old = self.lctx.is_in_trait_impl;\n         self.lctx.is_in_trait_impl = impl_ref.is_some();\n         let ret = f(self);\n         self.lctx.is_in_trait_impl = old;\n         ret\n     }\n-}\n \n-impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n-    fn visit_attribute(&mut self, _: &'a Attribute) {\n-        // We do not want to lower expressions that appear in attributes,\n-        // as they are not accessible to the rest of the HIR.\n+    pub(super) fn lower_node(\n+        &mut self,\n+        def_id: LocalDefId,\n+    ) -> hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>> {\n+        self.lctx.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+        if let hir::MaybeOwner::Phantom = self.lctx.owners[def_id] {\n+            let node = self.ast_index[def_id];\n+            match node {\n+                AstOwner::NonOwner => {}\n+                AstOwner::Crate(c) => self.lower_crate(c),\n+                AstOwner::Item(item) => self.lower_item(item),\n+                AstOwner::AssocItem(item, ctxt) => self.lower_assoc_item(item, ctxt),\n+                AstOwner::ForeignItem(item) => self.lower_foreign_item(item),\n+            }\n+        }\n+\n+        self.lctx.owners[def_id]\n     }\n \n-    fn visit_item(&mut self, item: &'a Item) {\n-        let hir_id = self.without_in_scope_lifetime_defs(|this| {\n-            this.lctx.with_hir_id_owner(item.id, |lctx| {\n-                let node = lctx.lower_item(item);\n-                hir::OwnerNode::Item(node)\n-            })\n-        });\n+    fn lower_crate(&mut self, c: &'a Crate) {\n+        debug_assert_eq!(self.lctx.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n \n-        self.with_parent_item_lifetime_defs(hir_id, |this| match item.kind {\n-            ItemKind::Impl(box Impl { ref of_trait, .. }) => {\n-                this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n-            }\n-            _ => visit::walk_item(this, item),\n-        })\n+        self.lctx.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n+            let module = lctx.lower_mod(&c.items, c.spans.inner_span);\n+            lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n+            hir::OwnerNode::Crate(lctx.arena.alloc(module))\n+        });\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'a>, sp: Span, _: NodeId) {\n-        match fk {\n-            FnKind::Fn(FnCtxt::Foreign, _, sig, _, _) => {\n-                self.visit_fn_header(&sig.header);\n-                visit::walk_fn_decl(self, &sig.decl);\n-                // Don't visit the foreign function body even if it has one, since lowering the\n-                // body would have no meaning and will have already been caught as a parse error.\n-            }\n-            _ => visit::walk_fn(self, fk, sp),\n-        }\n+    fn lower_item(&mut self, item: &'a Item) {\n+        self.without_in_scope_lifetime_defs(|this| {\n+            this.lctx.with_hir_id_owner(item.id, |lctx| hir::OwnerNode::Item(lctx.lower_item(item)))\n+        });\n     }\n \n-    fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        debug!(in_scope_lifetimes = ?self.lctx.in_scope_lifetimes);\n-        self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n-            AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n-            AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n-        });\n+    fn lower_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+        let def_id = self.lctx.resolver.local_def_id(item.id);\n \n-        visit::walk_assoc_item(self, item, ctxt);\n+        let do_lower = |lctx: &mut LoweringContext<'_, '_>| {\n+            lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n+                AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n+                AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n+            });\n+        };\n+\n+        let parent_id = {\n+            let parent = self.lctx.resolver.definitions().def_key(def_id).parent;\n+            let local_def_index = parent.unwrap();\n+            LocalDefId { local_def_index }\n+        };\n+        let parent_hir = self.lower_node(parent_id).unwrap().node().expect_item();\n+        self.with_parent_item_lifetime_defs(parent_hir, |this| match parent_hir.kind {\n+            hir::ItemKind::Impl(hir::Impl { ref of_trait, .. }) => {\n+                this.with_trait_impl_ref(of_trait, |this| do_lower(this.lctx))\n+            }\n+            _ => do_lower(this.lctx),\n+        });\n     }\n \n-    fn visit_foreign_item(&mut self, item: &'a ForeignItem) {\n+    fn lower_foreign_item(&mut self, item: &'a ForeignItem) {\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item))\n         });\n-\n-        visit::walk_foreign_item(self, item);\n     }\n }\n "}, {"sha": "4142020471abd781cedd5714b484b646b7da33d9", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6e4fb2038a23829e8b4fcf5522d7821ee8017a97/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e4fb2038a23829e8b4fcf5522d7821ee8017a97/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6e4fb2038a23829e8b4fcf5522d7821ee8017a97", "patch": "@@ -332,6 +332,59 @@ impl FnDeclKind {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+enum AstOwner<'a> {\n+    NonOwner,\n+    Crate(&'a ast::Crate),\n+    Item(&'a ast::Item),\n+    AssocItem(&'a ast::AssocItem, visit::AssocCtxt),\n+    ForeignItem(&'a ast::ForeignItem),\n+}\n+\n+fn index_crate<'a>(\n+    resolver: &dyn ResolverAstLowering,\n+    krate: &'a Crate,\n+) -> IndexVec<LocalDefId, AstOwner<'a>> {\n+    let mut indexer = Indexer { resolver, index: IndexVec::new() };\n+    indexer.index.ensure_contains_elem(CRATE_DEF_ID, || AstOwner::NonOwner);\n+    indexer.index[CRATE_DEF_ID] = AstOwner::Crate(krate);\n+    visit::walk_crate(&mut indexer, krate);\n+    return indexer.index;\n+\n+    struct Indexer<'s, 'a> {\n+        resolver: &'s dyn ResolverAstLowering,\n+        index: IndexVec<LocalDefId, AstOwner<'a>>,\n+    }\n+\n+    impl<'a> visit::Visitor<'a> for Indexer<'_, 'a> {\n+        fn visit_attribute(&mut self, _: &'a Attribute) {\n+            // We do not want to lower expressions that appear in attributes,\n+            // as they are not accessible to the rest of the HIR.\n+        }\n+\n+        fn visit_item(&mut self, item: &'a ast::Item) {\n+            let def_id = self.resolver.local_def_id(item.id);\n+            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n+            self.index[def_id] = AstOwner::Item(item);\n+            visit::walk_item(self, item)\n+        }\n+\n+        fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: visit::AssocCtxt) {\n+            let def_id = self.resolver.local_def_id(item.id);\n+            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n+            self.index[def_id] = AstOwner::AssocItem(item, ctxt);\n+            visit::walk_assoc_item(self, item, ctxt);\n+        }\n+\n+        fn visit_foreign_item(&mut self, item: &'a ast::ForeignItem) {\n+            let def_id = self.resolver.local_def_id(item.id);\n+            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n+            self.index[def_id] = AstOwner::ForeignItem(item);\n+            visit::walk_foreign_item(self, item);\n+        }\n+    }\n+}\n+\n /// Compute the hash for the HIR of the full crate.\n /// This hash will then be part of the crate_hash which is stored in the metadata.\n fn compute_hir_hash(\n@@ -363,6 +416,8 @@ pub fn lower_crate<'a, 'hir>(\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n+    let ast_index = index_crate(resolver, krate);\n+\n     let owners =\n         IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, resolver.definitions().def_index_count());\n     let mut lctx = LoweringContext {\n@@ -395,15 +450,9 @@ pub fn lower_crate<'a, 'hir>(\n         allow_into_future: Some([sym::into_future][..].into()),\n     };\n \n-    // Lower the root module manually.\n-    debug_assert_eq!(lctx.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n-    lctx.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n-        let module = lctx.lower_mod(&krate.items, krate.spans.inner_span);\n-        lctx.lower_attrs(hir::CRATE_HIR_ID, &krate.attrs);\n-        hir::OwnerNode::Crate(lctx.arena.alloc(module))\n-    });\n-\n-    visit::walk_crate(&mut item::ItemLowerer { lctx: &mut lctx }, krate);\n+    for def_id in ast_index.indices() {\n+        item::ItemLowerer { lctx: &mut lctx, ast_index: &ast_index }.lower_node(def_id);\n+    }\n     let owners = lctx.owners;\n \n     let hir_hash = compute_hir_hash(resolver, &owners);"}]}