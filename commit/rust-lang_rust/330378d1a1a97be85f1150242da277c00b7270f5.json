{"sha": "330378d1a1a97be85f1150242da277c00b7270f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMDM3OGQxYTFhOTdiZTg1ZjExNTAyNDJkYTI3N2MwMGI3MjcwZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-24T20:25:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-24T20:25:36Z"}, "message": "auto merge of #7996 : erickt/rust/cleanup-strs, r=erickt\n\nThis is a cleanup pull request that does:\r\n\r\n* removes `os::as_c_charp`\r\n* moves `str::as_buf` and `str::as_c_str` into `StrSlice`\r\n* converts some functions from `StrSlice::as_buf` to `StrSlice::as_c_str`\r\n* renames `StrSlice::as_buf` to `StrSlice::as_imm_buf` (and adds `StrSlice::as_mut_buf` to match `vec.rs`.\r\n* renames `UniqueStr::as_bytes_with_null_consume` to `UniqueStr::to_bytes`\r\n* and other misc cleanups and minor optimizations", "tree": {"sha": "290425cb36216f5d219ffc616fb6fc42646dd48c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/290425cb36216f5d219ffc616fb6fc42646dd48c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/330378d1a1a97be85f1150242da277c00b7270f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/330378d1a1a97be85f1150242da277c00b7270f5", "html_url": "https://github.com/rust-lang/rust/commit/330378d1a1a97be85f1150242da277c00b7270f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/330378d1a1a97be85f1150242da277c00b7270f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766eb950c6e7cdbab89e15200d0bd2dfee58e25e", "url": "https://api.github.com/repos/rust-lang/rust/commits/766eb950c6e7cdbab89e15200d0bd2dfee58e25e", "html_url": "https://github.com/rust-lang/rust/commit/766eb950c6e7cdbab89e15200d0bd2dfee58e25e"}, {"sha": "9a950802ed01ac2e7d7e04cb9df0519245551393", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a950802ed01ac2e7d7e04cb9df0519245551393", "html_url": "https://github.com/rust-lang/rust/commit/9a950802ed01ac2e7d7e04cb9df0519245551393"}], "stats": {"total": 846, "additions": 380, "deletions": 466}, "files": [{"sha": "7d2a0658969ab7cc62ea8273fc0c5d3d85c61432", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -194,7 +194,7 @@ mod test {\n \n     #[test]\n     fn test_interface_unwrap() {\n-        let mut f = from_value(~\"fail\");\n+        let f = from_value(~\"fail\");\n         assert_eq!(f.unwrap(), ~\"fail\");\n     }\n "}, {"sha": "6c9f9857a881abfed1b48c23eb0072853d0c6465", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -457,7 +457,7 @@ pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n     if vals.is_empty() { return None::<~str>; }\n     return match vals[0] { Val(ref s) => Some::<~str>((*s).clone()),\n-                           _      => Some::<~str>(str::to_owned(def)) }\n+                           _      => Some::<~str>(def.to_owned()) }\n }\n \n #[deriving(Eq)]\n@@ -497,10 +497,10 @@ pub mod groups {\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup { short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup { short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Yes,\n                 occur: Req};\n     }\n@@ -510,10 +510,10 @@ pub mod groups {\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Yes,\n                 occur: Optional};\n     }\n@@ -523,10 +523,10 @@ pub mod groups {\n                    desc: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n                 hint: ~\"\",\n-                desc: str::to_owned(desc),\n+                desc: desc.to_owned(),\n                 hasarg: No,\n                 occur: Optional};\n     }\n@@ -536,10 +536,10 @@ pub mod groups {\n                       desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Maybe,\n                 occur: Optional};\n     }\n@@ -552,10 +552,10 @@ pub mod groups {\n                     desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n         assert!(len == 1 || len == 0);\n-        return OptGroup {short_name: str::to_owned(short_name),\n-                long_name: str::to_owned(long_name),\n-                hint: str::to_owned(hint),\n-                desc: str::to_owned(desc),\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: hint.to_owned(),\n+                desc: desc.to_owned(),\n                 hasarg: Yes,\n                 occur: Multi};\n     }\n@@ -678,7 +678,7 @@ pub mod groups {\n             row\n         });\n \n-        return str::to_owned(brief) +\n+        return brief.to_owned() +\n                \"\\n\\nOptions:\\n\" +\n                rows.collect::<~[~str]>().connect(\"\\n\") +\n                \"\\n\\n\";"}, {"sha": "08e1c240a4c65378f8e486b44f31ef80b5390876", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -32,7 +32,7 @@ pub mod rustrt {\n \n /// Add a line to history\n pub unsafe fn add_history(line: &str) -> bool {\n-    do str::as_c_str(line) |buf| {\n+    do line.as_c_str |buf| {\n         rustrt::linenoiseHistoryAdd(buf) == 1 as c_int\n     }\n }\n@@ -44,21 +44,21 @@ pub unsafe fn set_history_max_len(len: int) -> bool {\n \n /// Save line history to a file\n pub unsafe fn save_history(file: &str) -> bool {\n-    do str::as_c_str(file) |buf| {\n+    do file.as_c_str |buf| {\n         rustrt::linenoiseHistorySave(buf) == 1 as c_int\n     }\n }\n \n /// Load line history from a file\n pub unsafe fn load_history(file: &str) -> bool {\n-    do str::as_c_str(file) |buf| {\n+    do file.as_c_str |buf| {\n         rustrt::linenoiseHistoryLoad(buf) == 1 as c_int\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n pub unsafe fn read(prompt: &str) -> Option<~str> {\n-    do str::as_c_str(prompt) |buf| {\n+    do prompt.as_c_str |buf| {\n         let line = rustrt::linenoise(buf);\n \n         if line.is_null() { None }\n@@ -80,7 +80,7 @@ pub unsafe fn complete(cb: CompletionCb) {\n \n             unsafe {\n                 do cb(str::raw::from_c_str(line)) |suggestion| {\n-                    do str::as_c_str(suggestion) |buf| {\n+                    do suggestion.as_c_str |buf| {\n                         rustrt::linenoiseAddCompletion(completions, buf);\n                     }\n                 }"}, {"sha": "114ab6702ae24b2fa7f2a5a426c2790d571ce785", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -545,7 +545,7 @@ priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n         String(s) => {\n             match op {\n                 FormatString => {\n-                    let mut s = s.as_bytes_with_null_consume();\n+                    let mut s = s.to_bytes_with_null();\n                     s.pop(); // remove the null\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);"}, {"sha": "b1c07e83f52c7a3336246246c528dfe314e35abb", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -1027,7 +1027,7 @@ mod tests {\n \n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              Ok(ref tm) => tm.strftime(format) == str::to_owned(s),\n+              Ok(ref tm) => tm.strftime(format) == s.to_owned(),\n               Err(e) => fail!(e)\n             }\n         }"}, {"sha": "d932dc80d518742c847b5884217b6a2c23ddd4c7", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -76,9 +76,9 @@ pub fn WriteOutputFile(sess: Session,\n         OptLevel: c_int,\n         EnableSegmentedStacks: bool) {\n     unsafe {\n-        do str::as_c_str(Triple) |Triple| {\n-            do str::as_c_str(Feature) |Feature| {\n-                do str::as_c_str(Output) |Output| {\n+        do Triple.as_c_str |Triple| {\n+            do Feature.as_c_str |Feature| {\n+                do Output.as_c_str |Output| {\n                     let result = llvm::LLVMRustWriteOutputFile(\n                             PM,\n                             M,\n@@ -263,16 +263,16 @@ pub mod write {\n                   output_type_bitcode => {\n                     if opts.optimize != session::No {\n                         let filename = output.with_filetype(\"no-opt.bc\");\n-                        str::as_c_str(filename.to_str(), |buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                        });\n+                        do filename.to_str().as_c_str |buf| {\n+                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                        }\n                     }\n                   }\n                   _ => {\n                     let filename = output.with_filetype(\"bc\");\n-                    str::as_c_str(filename.to_str(), |buf| {\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                    });\n+                    do filename.to_str().as_c_str |buf| {\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                    }\n                   }\n                 }\n             }\n@@ -333,9 +333,9 @@ pub mod write {\n                     // Always output the bitcode file with --save-temps\n \n                     let filename = output.with_filetype(\"opt.bc\");\n-                    str::as_c_str(filename.to_str(), |buf| {\n+                    do filename.to_str().as_c_str |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                    });\n+                    };\n                     // Save the assembly file if -S is used\n                     if output_type == output_type_assembly {\n                         WriteOutputFile(\n@@ -391,13 +391,15 @@ pub mod write {\n \n             if output_type == output_type_llvm_assembly {\n                 // Given options \"-S --emit-llvm\": output LLVM assembly\n-                str::as_c_str(output.to_str(), |buf_o| {\n-                    llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o)});\n+                do output.to_str().as_c_str |buf_o| {\n+                    llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o);\n+                }\n             } else {\n                 // If only a bitcode file is asked for by using the\n                 // '--emit-llvm' flag, then output it here\n-                str::as_c_str(output.to_str(),\n-                            |buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) );\n+                do output.to_str().as_c_str |buf| {\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                }\n             }\n \n             llvm::LLVMDisposeModule(llmod);"}, {"sha": "7b4db63c6ed7a3b244469c6a4c9c76ff4147ef27", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str;\n use std::io;\n \n use driver::session::{OptLevel, No, Less, Aggressive};\n@@ -174,7 +173,7 @@ pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~s\n }\n \n pub fn create_pass(name:&str) -> Option<PassRef> {\n-    do str::as_c_str(name) |s| {\n+    do name.as_c_str |s| {\n         unsafe {\n             let p = llvm::LLVMCreatePass(s);\n             if p.is_null() {"}, {"sha": "f3bca7a6ab373dd59a89d285a0cd1ee4bb5f5151", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -12,7 +12,6 @@\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ushort};\n use std::option;\n-use std::str;\n \n use middle::trans::type_::Type;\n \n@@ -2287,10 +2286,9 @@ pub struct TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let lltd =\n-        str::as_c_str(string_rep, |buf| unsafe {\n-            llvm::LLVMCreateTargetData(buf)\n-        });\n+    let lltd = do string_rep.as_c_str |buf| {\n+        unsafe { llvm::LLVMCreateTargetData(buf) }\n+    };\n \n     TargetData {\n         lltd: lltd,"}, {"sha": "6017b804b578009be30ad91b02154da842a1012b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -12,7 +12,6 @@\n use std::option;\n use std::os;\n use std::result;\n-use std::str;\n \n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n@@ -83,7 +82,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     @FileSearchImpl {\n         sysroot: sysroot,\n         addl_lib_search_paths: addl_lib_search_paths,\n-        target_triple: str::to_owned(target_triple)\n+        target_triple: target_triple.to_owned()\n     } as @FileSearch\n }\n \n@@ -110,7 +109,7 @@ pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {\n     Path(libdir()).push_many([~\"rustc\",\n-                              str::to_owned(target_triple),\n+                              target_triple.to_owned(),\n                               libdir()])\n }\n "}, {"sha": "481d27f6944be2cb703cf476c0553410d74be41d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -80,7 +80,7 @@ fn libname(cx: &Context) -> (~str, ~str) {\n         os_freebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n \n-    (str::to_owned(dll_prefix), str::to_owned(dll_suffix))\n+    (dll_prefix.to_owned(), dll_suffix.to_owned())\n }\n \n fn find_library_crate_aux(\n@@ -186,9 +186,9 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n fn get_metadata_section(os: os,\n                         filename: &Path) -> Option<@~[u8]> {\n     unsafe {\n-        let mb = str::as_c_str(filename.to_str(), |buf| {\n+        let mb = do filename.to_str().as_c_str |buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-        });\n+        };\n         if mb as int == 0 { return option::None::<@~[u8]>; }\n         let of = match mk_object_file(mb) {\n             option::Some(of) => of,"}, {"sha": "9f302ee6676ff835c376504d284a7d4af3055adf", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -21,7 +21,6 @@ use middle::ty;\n \n use middle::trans::type_::Type;\n \n-use std::str;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n@@ -123,8 +122,8 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         ast::asm_intel => lib::llvm::AD_Intel\n     };\n \n-    let r = do str::as_c_str(ia.asm) |a| {\n-        do str::as_c_str(constraints) |c| {\n+    let r = do ia.asm.as_c_str |a| {\n+        do constraints.as_c_str |c| {\n             InlineAsmCall(bcx, a, c, inputs, output, ia.volatile, ia.alignstack, dialect)\n         }\n     };"}, {"sha": "d3ae69b23dae4e55b922af70052b9576d36eda0e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -70,7 +70,6 @@ use std::hashmap::{HashMap, HashSet};\n use std::int;\n use std::io;\n use std::libc::c_uint;\n-use std::str;\n use std::uint;\n use std::vec;\n use std::local_data;\n@@ -549,11 +548,11 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess.opts.save_temps {\n-        let _: () = str::as_c_str(s, |buf| {\n+        do s.as_c_str |buf| {\n             unsafe {\n                 llvm::LLVMSetValueName(v, buf)\n             }\n-        });\n+        }\n     }\n }\n \n@@ -1580,16 +1579,18 @@ pub struct BasicBlocks {\n pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        str::as_c_str(\"static_allocas\",\n-                      |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n+        do \"static_allocas\".as_c_str | buf| {\n+            llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n+        }\n     }\n }\n \n pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        str::as_c_str(\"return\",\n-                      |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n+        do \"return\".as_c_str |buf| {\n+            llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n+        }\n     }\n }\n \n@@ -2356,11 +2357,11 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             };\n             decl_cdecl_fn(ccx.llmod, main_name, llfty)\n         };\n-        let llbb = str::as_c_str(\"top\", |buf| {\n+        let llbb = do \"top\".as_c_str |buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n             }\n-        });\n+        };\n         let bld = ccx.builder.B;\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n@@ -2460,9 +2461,9 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                 exprt = m == ast::m_mutbl;\n                 unsafe {\n                     let llty = llvm::LLVMTypeOf(v);\n-                    let g = str::as_c_str(s, |buf| {\n+                    let g = do s.as_c_str |buf| {\n                         llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n-                    });\n+                    };\n                     ccx.item_symbols.insert(i.id, s);\n                     g\n                 }\n@@ -2521,7 +2522,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                 ast::foreign_item_static(*) => {\n                     let typ = ty::node_id_to_type(ccx.tcx, ni.id);\n                     let ident = token::ident_to_str(&ni.ident);\n-                    let g = do str::as_c_str(ident) |buf| {\n+                    let g = do ident.as_c_str |buf| {\n                         unsafe {\n                             let ty = type_of(ccx, typ);\n                             llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n@@ -2621,11 +2622,11 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n             let s = mangle_exported_name(ccx, p, ty::mk_int()).to_managed();\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n-            let discrim_gvar = str::as_c_str(s, |buf| {\n+            let discrim_gvar = do s.as_c_str |buf| {\n                 unsafe {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 }\n-            });\n+            };\n             unsafe {\n                 llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n                 llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n@@ -2762,7 +2763,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n \n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n-    let gc_metadata = do str::as_c_str(gc_metadata_name) |buf| {\n+    let gc_metadata = do gc_metadata_name.as_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n         }\n@@ -2825,11 +2826,11 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = Type::array(&int_type, n_subcrates as u64);\n     let maptype = Type::struct_([Type::i32(), Type::i8p(), int_type, arrtype], false);\n-    let map = str::as_c_str(sym_name, |buf| {\n+    let map = do sym_name.as_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n         }\n-    });\n+    };\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n     return map;\n }\n@@ -2844,11 +2845,11 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n                       cdata.name,\n                       cstore::get_crate_vers(cstore, i),\n                       cstore::get_crate_hash(cstore, i));\n-        let cr = str::as_c_str(nm, |buf| {\n+        let cr = do nm.as_c_str |buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n             }\n-        });\n+        };\n         subcrates.push(p2i(ccx, cr));\n         i += 1;\n     }\n@@ -2907,16 +2908,16 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::Crate) {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct([llmeta]);\n-    let mut llglobal = str::as_c_str(\"rust_metadata\", |buf| {\n+    let mut llglobal = do \"rust_metadata\".as_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n         }\n-    });\n+    };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        str::as_c_str(cx.sess.targ_cfg.target_strs.meta_sect_name, |buf| {\n+        do cx.sess.targ_cfg.target_strs.meta_sect_name.as_c_str |buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n-        });\n+        };\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n         let t_ptr_i8 = Type::i8p();\n@@ -2935,7 +2936,7 @@ fn mk_global(ccx: &CrateContext,\n              internal: bool)\n           -> ValueRef {\n     unsafe {\n-        let llglobal = do str::as_c_str(name) |buf| {\n+        let llglobal = do name.as_c_str |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(llglobal, llval);"}, {"sha": "1c9161163cc5b71eda17ea3f9bbec3a7bffb6b8a", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -20,7 +20,6 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_char};\n-use std::str;\n use std::vec;\n use syntax::codemap::span;\n \n@@ -424,9 +423,9 @@ impl Builder {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                str::as_c_str(\n-                    name,\n-                    |c| llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c))\n+                do name.as_c_str |c| {\n+                    llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c)\n+                }\n             }\n         }\n     }\n@@ -896,9 +895,9 @@ impl Builder {\n             let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n             let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n             let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-            let T: ValueRef = str::as_c_str(\"llvm.trap\", |buf| {\n+            let T: ValueRef = do \"llvm.trap\".as_c_str |buf| {\n                 llvm::LLVMGetNamedFunction(M, buf)\n-            });\n+            };\n             assert!((T as int != 0));\n             let args: &[ValueRef] = [];\n             self.count_insn(\"trap\");"}, {"sha": "713939a5d83192da1d1ff5488c51aea1d81472a2", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -783,15 +783,6 @@ pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n     }\n }\n \n-// Returns a Plain Old LLVM String:\n-pub fn C_postr(s: &str) -> ValueRef {\n-    unsafe {\n-        do s.as_c_str |buf| {\n-            llvm::LLVMConstStringInContext(base::task_llcx(), buf, s.len() as c_uint, False)\n-        }\n-    }\n-}\n-\n pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n     unsafe {\n         let mut i = 0u;\n@@ -839,14 +830,6 @@ pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n-    unsafe {\n-        return llvm::LLVMConstStringInContext(base::task_llcx(),\n-            cast::transmute(vec::raw::to_ptr(bytes)),\n-            bytes.len() as c_uint, False);\n-    }\n-}\n-\n pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n     unsafe {\n         llvm::LLVMGetParam(fndecl, param as c_uint)"}, {"sha": "15793ea747f3fd5d8ebdf7f512f554b9e363b9eb", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -31,7 +31,6 @@ use util::ppaux::{Repr, ty_to_str};\n use middle::trans::type_::Type;\n \n use std::libc::c_uint;\n-use std::str;\n use syntax::{ast, ast_util, ast_map};\n \n pub fn const_lit(cx: &mut CrateContext, e: &ast::expr, lit: ast::lit)\n@@ -513,7 +512,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               ast::expr_vec(ref es, ast::m_imm) => {\n                 let (cv, sz, llunitty) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n-                let gv = do str::as_c_str(\"const\") |name| {\n+                let gv = do \"const\".as_c_str |name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n                 };\n                 llvm::LLVMSetInitializer(gv, cv);"}, {"sha": "78544c1c6c4fc1c6c9d2f986d8ad512cd7f163ad", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -28,7 +28,6 @@ use middle::trans::type_::Type;\n \n use std::hash;\n use std::hashmap::{HashMap, HashSet};\n-use std::str;\n use std::local_data;\n use syntax::ast;\n \n@@ -125,13 +124,11 @@ impl CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);\n-            let llmod = str::as_c_str(name, |buf| {\n-                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-            });\n+            let llmod = name.as_c_str(|buf| llvm::LLVMModuleCreateWithNameInContext(buf, llcx));\n             let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n             let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            str::as_c_str(data_layout, |buf| llvm::LLVMSetDataLayout(llmod, buf));\n-            str::as_c_str(targ_triple, |buf| llvm::LLVMSetTarget(llmod, buf));\n+            data_layout.as_c_str(|buf| llvm::LLVMSetDataLayout(llmod, buf));\n+            targ_triple.as_c_str(|buf| llvm::LLVMSetTarget(llmod, buf));\n             let targ_cfg = sess.targ_cfg;\n \n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);"}, {"sha": "2b6c1d8241860e4477305b9f48678139ea561344", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -27,7 +27,6 @@ use util::ppaux;\n \n use middle::trans::type_::Type;\n \n-use std::str;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_map::path_mod;\n@@ -251,9 +250,9 @@ pub fn trans_log(log_ex: &ast::expr,\n             ccx, modpath, \"loglevel\");\n         let global;\n         unsafe {\n-            global = str::as_c_str(s, |buf| {\n+            global = do s.as_c_str |buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n-            });\n+            };\n             llvm::LLVMSetGlobalConstant(global, False);\n             llvm::LLVMSetInitializer(global, C_null(Type::i32()));\n             lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);"}, {"sha": "cc690f070ccfcf5d4e8cfaae5983a538daf09593", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -65,7 +65,6 @@ use util::ppaux::ty_to_str;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n-use std::str::as_c_str;\n use std::vec;\n use syntax::codemap::span;\n use syntax::{ast, codemap, ast_util, ast_map};\n@@ -159,7 +158,7 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: @ast::Local) -> DIVaria\n         Some(_) => lexical_block_metadata(bcx)\n     };\n \n-    let var_metadata = do as_c_str(name) |name| {\n+    let var_metadata = do name.as_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateLocalVariable(\n                 DIB(cx),\n@@ -225,7 +224,7 @@ pub fn create_argument_metadata(bcx: @mut Block, arg: &ast::arg, span: span) ->\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n-            let var_metadata = do as_c_str(name) |name| {\n+            let var_metadata = do name.as_c_str |name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateLocalVariable(\n                         DIB(cx),\n@@ -353,8 +352,8 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n     };\n \n     let fn_metadata =\n-        do as_c_str(cx.sess.str_of(ident)) |name| {\n-        do as_c_str(cx.sess.str_of(ident)) |linkage| {\n+        do cx.sess.str_of(ident).as_c_str |name| {\n+        do cx.sess.str_of(ident).as_c_str |linkage| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFunction(\n                     DIB(cx),\n@@ -401,11 +400,11 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n \n-    do as_c_str(crate_name) |crate_name| {\n-    do as_c_str(work_dir) |work_dir| {\n-    do as_c_str(producer) |producer| {\n-    do as_c_str(\"\") |flags| {\n-    do as_c_str(\"\") |split_name| {\n+    do crate_name.as_c_str |crate_name| {\n+    do work_dir.as_c_str |work_dir| {\n+    do producer.as_c_str |producer| {\n+    do \"\".as_c_str |flags| {\n+    do \"\".as_c_str |split_name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n                 DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n@@ -432,8 +431,8 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         };\n \n     let file_metadata =\n-        do as_c_str(file_name) |file_name| {\n-        do as_c_str(work_dir) |work_dir| {\n+        do file_name.as_c_str |file_name| {\n+        do work_dir.as_c_str |work_dir| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n             }\n@@ -521,7 +520,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = do as_c_str(name) |name| {\n+    let ty_metadata = do name.as_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -542,7 +541,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = ty_to_str(cx.tcx, pointer_type);\n-    let ptr_metadata = do as_c_str(name) |name| {\n+    let ptr_metadata = do name.as_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n                 DIB(cx),\n@@ -1037,7 +1036,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n \n     let name = ty_to_str(cx.tcx, t);\n-    let metadata = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| {\n+    let metadata = do fmt!(\"NYI<%s>\", name).as_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),"}, {"sha": "75f553f397177fe6f8c9ffeec86309c64e08acad", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -38,7 +38,6 @@ use util::ppaux::ty_to_short_str;\n use middle::trans::type_::Type;\n \n use std::libc::c_uint;\n-use std::str;\n use syntax::ast;\n \n pub fn trans_free(cx: @mut Block, v: ValueRef) -> @mut Block {\n@@ -657,11 +656,11 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n-    let gvar = str::as_c_str(name, |buf| {\n+    let gvar = do name.as_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }\n-    });\n+    };\n     let inf = @mut tydesc_info {\n         ty: t,\n         tydesc: gvar,"}, {"sha": "60367fd9aa644a6ebc795b1df19c586f8cbce8ac", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -380,10 +380,10 @@ pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n pub fn link_exe(src: &Path, dest: &Path) -> bool {\n-    use std::{libc, str};\n+    use std::libc;\n     unsafe {\n-        do str::as_c_str(src.to_str()) |src_buf| {\n-            do str::as_c_str(dest.to_str()) |dest_buf| {\n+        do src.to_str().as_c_str |src_buf| {\n+            do dest.to_str().as_c_str |dest_buf| {\n                 libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n                     libc::chmod(dest_buf, 755) == 0 as libc::c_int\n             }"}, {"sha": "05a5184ccbac8f7be7e6949a2316aa8cc6ad66c5", "filename": "src/libstd/io.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -63,7 +63,7 @@ use iterator::IteratorUtil;\n use ptr;\n use result;\n use str;\n-use str::StrSlice;\n+use str::{StrSlice, OwnedStr};\n use to_str::ToStr;\n use uint;\n use vec;\n@@ -763,7 +763,7 @@ impl<T:Reader> ReaderUtil for T {\n     fn read_lines(&self) -> ~[~str] {\n         do vec::build |push| {\n             for self.each_line |line| {\n-                push(str::to_owned(line));\n+                push(line.to_owned());\n             }\n         }\n     }\n@@ -1031,17 +1031,16 @@ pub fn stdin() -> @Reader {\n }\n \n pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n-    unsafe {\n-        let f = os::as_c_charp(path.to_str(), |pathbuf| {\n-            os::as_c_charp(\"r\", |modebuf|\n-                libc::fopen(pathbuf, modebuf)\n-            )\n-        });\n-        return if f as uint == 0u { result::Err(~\"error opening \"\n-                                                + path.to_str()) }\n-        else {\n-            result::Ok(FILE_reader(f, true))\n+    let f = do path.to_str().as_c_str |pathbuf| {\n+        do \"r\".as_c_str |modebuf| {\n+            unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n         }\n+    };\n+\n+    if f as uint == 0u {\n+        result::Err(~\"error opening \" + path.to_str())\n+    } else {\n+        result::Ok(FILE_reader(f, true))\n     }\n }\n \n@@ -1282,7 +1281,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n         }\n     }\n     let fd = unsafe {\n-        do os::as_c_charp(path.to_str()) |pathbuf| {\n+        do path.to_str().as_c_str |pathbuf| {\n             libc::open(pathbuf, fflags,\n                        (S_IRUSR | S_IWUSR) as c_int)\n         }\n@@ -1567,8 +1566,8 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n // FIXME: fileflags // #2004\n pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n     unsafe {\n-        let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n-            do os::as_c_charp(\"w\") |modebuf| {\n+        let f = do path.to_str().as_c_str |pathbuf| {\n+            do \"w\".as_c_str |modebuf| {\n                 libc::fopen(pathbuf, modebuf)\n             }\n         };"}, {"sha": "c4fee90826651838f64ae108e4bbfd8c3b9a13ef", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -50,7 +50,6 @@ use iterator::Iterator;\n use str::StrSlice;\n use clone::DeepClone;\n \n-#[cfg(test)] use str;\n #[cfg(test)] use iterator::IteratorUtil;\n \n /// The option type\n@@ -446,10 +445,10 @@ fn test_unwrap_ptr() {\n #[test]\n fn test_unwrap_str() {\n     let x = ~\"test\";\n-    let addr_x = str::as_buf(x, |buf, _len| buf);\n+    let addr_x = x.as_imm_buf(|buf, _len| buf);\n     let opt = Some(x);\n     let y = opt.unwrap();\n-    let addr_y = str::as_buf(y, |buf, _len| buf);\n+    let addr_y = y.as_imm_buf(|buf, _len| buf);\n     assert_eq!(addr_x, addr_y);\n }\n "}, {"sha": "142021be471ae7c697c7821c74daee30cd167069", "filename": "src/libstd/os.rs", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -87,13 +87,8 @@ pub fn getcwd() -> Path {\n \n // FIXME: move these to str perhaps? #2620\n \n-pub fn as_c_charp<T>(s: &str, f: &fn(*c_char) -> T) -> T {\n-    str::as_c_str(s, |b| f(b as *c_char))\n-}\n-\n-pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool)\n-    -> Option<~str> {\n-    let mut buf = vec::from_elem(TMPBUF_SZ, 0u8 as c_char);\n+pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool) -> Option<~str> {\n+    let mut buf = [0 as c_char, .. TMPBUF_SZ];\n     do buf.as_mut_buf |b, sz| {\n         if f(b, sz as size_t) {\n             unsafe {\n@@ -247,12 +242,11 @@ pub fn env() -> ~[(~str,~str)] {\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n         do with_env_lock {\n-            let s = str::as_c_str(n, |s| libc::getenv(s));\n+            let s = n.as_c_str(|s| libc::getenv(s as *libc::c_char));\n             if ptr::null::<u8>() == cast::transmute(s) {\n-                None::<~str>\n+                None\n             } else {\n-                let s = cast::transmute(s);\n-                Some::<~str>(str::raw::from_buf(s))\n+                Some(str::raw::from_buf(cast::transmute(s)))\n             }\n         }\n     }\n@@ -281,8 +275,8 @@ pub fn getenv(n: &str) -> Option<~str> {\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n         do with_env_lock {\n-            do str::as_c_str(n) |nbuf| {\n-                do str::as_c_str(v) |vbuf| {\n+            do n.to_str().as_c_str |nbuf| {\n+                do v.to_str().as_c_str |vbuf| {\n                     libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n                 }\n             }\n@@ -313,7 +307,7 @@ pub fn unsetenv(n: &str) {\n     fn _unsetenv(n: &str) {\n         unsafe {\n             do with_env_lock {\n-                do str::as_c_str(n) |nbuf| {\n+                do n.to_str().as_c_str |nbuf| {\n                     libc::funcs::posix01::unistd::unsetenv(nbuf);\n                 }\n             }\n@@ -335,10 +329,10 @@ pub fn unsetenv(n: &str) {\n }\n \n pub fn fdopen(fd: c_int) -> *FILE {\n-    unsafe {\n-        return do as_c_charp(\"r\") |modebuf| {\n+    do \"r\".as_c_str |modebuf| {\n+        unsafe {\n             libc::fdopen(fd, modebuf)\n-        };\n+        }\n     }\n }\n \n@@ -469,9 +463,9 @@ pub fn self_exe_path() -> Option<Path> {\n             use libc::funcs::posix01::unistd::readlink;\n \n             let mut path_str = str::with_capacity(TMPBUF_SZ);\n-            let len = do str::as_c_str(path_str) |buf| {\n+            let len = do path_str.as_c_str |buf| {\n                 let buf = buf as *mut c_char;\n-                do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n+                do \"/proc/self/exe\".as_c_str |proc_self_buf| {\n                     readlink(proc_self_buf, buf, TMPBUF_SZ as size_t)\n                 }\n             };\n@@ -602,7 +596,7 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {\n     unsafe {\n-        do str::as_c_str(p.to_str()) |buf| {\n+        do p.to_str().as_c_str |buf| {\n             rustrt::rust_path_is_dir(buf) != 0 as c_int\n         }\n     }\n@@ -611,7 +605,7 @@ pub fn path_is_dir(p: &Path) -> bool {\n /// Indicates whether a path exists\n pub fn path_exists(p: &Path) -> bool {\n     unsafe {\n-        do str::as_c_str(p.to_str()) |buf| {\n+        do p.to_str().as_c_str |buf| {\n             rustrt::rust_path_exists(buf) != 0 as c_int\n         }\n     }\n@@ -654,9 +648,9 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n \n     #[cfg(unix)]\n     fn mkdir(p: &Path, mode: c_int) -> bool {\n-        unsafe {\n-            do as_c_charp(p.to_str()) |c| {\n-                libc::mkdir(c, mode as libc::mode_t) == (0 as c_int)\n+        do p.to_str().as_c_str |buf| {\n+            unsafe {\n+                libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n             }\n         }\n     }\n@@ -830,10 +824,10 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn rmdir(p: &Path) -> bool {\n-        unsafe {\n-            return do as_c_charp(p.to_str()) |buf| {\n+        do p.to_str().as_c_str |buf| {\n+            unsafe {\n                 libc::rmdir(buf) == (0 as c_int)\n-            };\n+            }\n         }\n     }\n }\n@@ -855,10 +849,10 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n-        unsafe {\n-            return do as_c_charp(p.to_str()) |buf| {\n+        do p.to_str().as_c_str |buf| {\n+            unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n-            };\n+            }\n         }\n     }\n }\n@@ -883,8 +877,8 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n     #[cfg(unix)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n         unsafe {\n-            let istream = do as_c_charp(from.to_str()) |fromp| {\n-                do as_c_charp(\"rb\") |modebuf| {\n+            let istream = do from.to_str().as_c_str |fromp| {\n+                do \"rb\".as_c_str |modebuf| {\n                     libc::fopen(fromp, modebuf)\n                 }\n             };\n@@ -895,8 +889,8 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             let from_mode = from.get_mode().expect(\"copy_file: couldn't get permissions \\\n                                                     for source file\");\n \n-            let ostream = do as_c_charp(to.to_str()) |top| {\n-                do as_c_charp(\"w+b\") |modebuf| {\n+            let ostream = do to.to_str().as_c_str |top| {\n+                do \"w+b\".as_c_str |modebuf| {\n                     libc::fopen(top, modebuf)\n                 }\n             };\n@@ -928,7 +922,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             fclose(ostream);\n \n             // Give the new file the old file's permissions\n-            if do str::as_c_str(to.to_str()) |to_buf| {\n+            if do to.to_str().as_c_str |to_buf| {\n                 libc::chmod(to_buf, from_mode as libc::mode_t)\n             } != 0 {\n                 return false; // should be a condition...\n@@ -955,9 +949,9 @@ pub fn remove_file(p: &Path) -> bool {\n     #[cfg(unix)]\n     fn unlink(p: &Path) -> bool {\n         unsafe {\n-            return do as_c_charp(p.to_str()) |buf| {\n+            do p.to_str().as_c_str |buf| {\n                 libc::unlink(buf) == (0 as c_int)\n-            };\n+            }\n         }\n     }\n }\n@@ -1294,7 +1288,7 @@ pub fn glob(pattern: &str) -> ~[Path] {\n     }\n \n     let mut g = default_glob_t();\n-    do str::as_c_str(pattern) |c_pattern| {\n+    do pattern.as_c_str |c_pattern| {\n         unsafe { libc::glob(c_pattern, 0, ptr::null(), &mut g) }\n     };\n     do(|| {\n@@ -1703,7 +1697,7 @@ mod tests {\n     use libc;\n     use option::Some;\n     use option;\n-    use os::{as_c_charp, env, getcwd, getenv, make_absolute, real_args};\n+    use os::{env, getcwd, getenv, make_absolute, real_args};\n     use os::{remove_file, setenv, unsetenv};\n     use os;\n     use path::Path;\n@@ -1941,8 +1935,8 @@ mod tests {\n           let out = tempdir.push(\"out.txt\");\n \n           /* Write the temp input file */\n-            let ostream = do as_c_charp(in.to_str()) |fromp| {\n-                do as_c_charp(\"w+b\") |modebuf| {\n+            let ostream = do in.to_str().as_c_str |fromp| {\n+                do \"w+b\".as_c_str |modebuf| {\n                     libc::fopen(fromp, modebuf)\n                 }\n           };\n@@ -2020,16 +2014,16 @@ mod tests {\n            }\n         }\n \n-        let p = tmpdir().push(\"mmap_file.tmp\");\n+        let path = tmpdir().push(\"mmap_file.tmp\");\n         let size = page_size() * 2;\n-        remove_file(&p);\n+        remove_file(&path);\n \n         let fd = unsafe {\n-            let fd = do as_c_charp(p.to_str()) |path| {\n+            let fd = do path.to_str().as_c_str |path| {\n                 open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n             };\n             lseek_(fd, size);\n-            do as_c_charp(\"x\") |x| {\n+            do \"x\".as_c_str |x| {\n                 assert!(write(fd, x as *c_void, 1) == 1);\n             }\n             fd"}, {"sha": "ef7a055b0e790652b0a61b59d5352564813fe743", "filename": "src/libstd/path.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -23,7 +23,6 @@ use iterator::IteratorUtil;\n use libc;\n use option::{None, Option, Some};\n use str::{OwnedStr, Str, StrSlice, StrVector};\n-use str;\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n use vec::{OwnedVector, ImmutableVector};\n@@ -342,13 +341,11 @@ mod stat {\n #[cfg(target_os = \"win32\")]\n impl WindowsPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n-        unsafe {\n-             do str::as_c_str(self.to_str()) |buf| {\n-                let mut st = stat::arch::default_stat();\n-                match libc::stat(buf, &mut st) {\n-                    0 => Some(st),\n-                    _ => None,\n-                }\n+        do self.to_str().as_c_str |buf| {\n+            let mut st = stat::arch::default_stat();\n+            match unsafe { libc::stat(buf, &mut st) } {\n+                0 => Some(st),\n+                _ => None,\n             }\n         }\n     }\n@@ -378,13 +375,11 @@ impl WindowsPath {\n #[cfg(not(target_os = \"win32\"))]\n impl PosixPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n-        unsafe {\n-             do str::as_c_str(self.to_str()) |buf| {\n-                let mut st = stat::arch::default_stat();\n-                match libc::stat(buf, &mut st) {\n-                    0 => Some(st),\n-                    _ => None,\n-                }\n+        do self.to_str().as_c_str |buf| {\n+            let mut st = stat::arch::default_stat();\n+            match unsafe { libc::stat(buf as *libc::c_char, &mut st) } {\n+                0 => Some(st),\n+                _ => None,\n             }\n         }\n     }\n@@ -458,13 +453,11 @@ impl PosixPath {\n #[cfg(unix)]\n impl PosixPath {\n     pub fn lstat(&self) -> Option<libc::stat> {\n-        unsafe {\n-            do str::as_c_str(self.to_str()) |buf| {\n-                let mut st = stat::arch::default_stat();\n-                match libc::lstat(buf, &mut st) {\n-                    0 => Some(st),\n-                    _ => None,\n-                }\n+        do self.to_str().as_c_str |buf| {\n+            let mut st = stat::arch::default_stat();\n+            match unsafe { libc::lstat(buf, &mut st) } {\n+                0 => Some(st),\n+                _ => None,\n             }\n         }\n     }"}, {"sha": "0d9446bcfca7d476d669bab39fea7fb3b4bd731e", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -62,7 +62,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n-pub use str::{Str, StrVector, StrSlice, OwnedStr, StrUtil, NullTerminatedStr};\n+pub use str::{Str, StrVector, StrSlice, OwnedStr, NullTerminatedStr};\n pub use from_str::{FromStr};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};"}, {"sha": "29564bd9728d7b8ee2641c444848824ffb50f33a", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -461,17 +461,13 @@ pub mod ptr_tests {\n \n     #[test]\n     fn test_position() {\n-        use str::as_c_str;\n         use libc::c_char;\n \n         let s = ~\"hello\";\n         unsafe {\n-            assert!(2u == as_c_str(s, |p| position(p,\n-                                                   |c| *c == 'l' as c_char)));\n-            assert!(4u == as_c_str(s, |p| position(p,\n-                                                   |c| *c == 'o' as c_char)));\n-            assert!(5u == as_c_str(s, |p| position(p,\n-                                                   |c| *c == 0 as c_char)));\n+            assert!(2u == s.as_c_str(|p| position(p, |c| *c == 'l' as c_char)));\n+            assert!(4u == s.as_c_str(|p| position(p, |c| *c == 'o' as c_char)));\n+            assert!(5u == s.as_c_str(|p| position(p, |c| *c == 0 as c_char)));\n         }\n     }\n \n@@ -480,9 +476,9 @@ pub mod ptr_tests {\n         let s0 = ~\"hello\";\n         let s1 = ~\"there\";\n         let s2 = ~\"thing\";\n-        do str::as_c_str(s0) |p0| {\n-            do str::as_c_str(s1) |p1| {\n-                do str::as_c_str(s2) |p2| {\n+        do s0.as_c_str |p0| {\n+            do s1.as_c_str |p1| {\n+                do s2.as_c_str |p2| {\n                     let v = ~[p0, p1, p2, null()];\n                     do v.as_imm_buf |vp, len| {\n                         assert_eq!(unsafe { buf_len(vp) }, 3u);"}, {"sha": "1a468fcf215d744fcee37f73fc60eb8652bd3043", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -16,7 +16,7 @@ use managed::raw::BoxRepr;\n use option::{Option, None, Some};\n use uint;\n use str;\n-use str::OwnedStr;\n+use str::{OwnedStr, StrSlice};\n use sys;\n use vec::ImmutableVector;\n \n@@ -76,7 +76,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n-            do str::as_buf(msg) |msg_p, _| {\n+            do msg.as_c_str |msg_p| {\n                 sys::begin_unwind_(msg_p as *c_char, file, line);\n             }\n         }\n@@ -92,7 +92,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n                     sep = \" and at \";\n                 }\n             }\n-            do str::as_buf(msg) |msg_p, _| {\n+            do msg.as_c_str |msg_p| {\n                 sys::begin_unwind_(msg_p as *c_char, file, line)\n             }\n         }\n@@ -231,7 +231,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n             let br = borrow_list.pop();\n             if br.box != a || br.file != file || br.line != line {\n                 let err = fmt!(\"wrong borrow found, br=%?\", br);\n-                do str::as_buf(err) |msg_p, _| {\n+                do err.as_c_str |msg_p| {\n                     sys::begin_unwind_(msg_p as *c_char, file, line)\n                 }\n             }"}, {"sha": "11d11daebc254be912a0b2a25048db789b12874a", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -46,17 +46,15 @@ impl Logger for StdErrLogger {\n /// per-module global logging flags based on the logging spec\n pub fn init(crate_map: *u8) {\n     use os;\n-    use str;\n+    use str::StrSlice;\n     use ptr;\n     use option::{Some, None};\n \n     let log_spec = os::getenv(\"RUST_LOG\");\n     match log_spec {\n         Some(spec) => {\n-            do str::as_c_str(spec) |s| {\n-                unsafe {\n-                    rust_update_log_settings(crate_map, s);\n-                }\n+            do spec.as_c_str |buf| {\n+                unsafe { rust_update_log_settings(crate_map, buf) }\n             }\n         }\n         None => {"}, {"sha": "1f27a5776842abb08fd096c5ea42ca78770fe8f6", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -382,12 +382,12 @@ pub unsafe fn as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6 {\n }\n \n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n-    do str::as_c_str(ip) |ip_buf| {\n+    do ip.as_c_str |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }\n pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n-    do str::as_c_str(ip) |ip_buf| {\n+    do ip.as_c_str |ip_buf| {\n         rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }"}, {"sha": "2a8d29214fae9e5bb78be28bc43b8a2dae721445", "filename": "src/libstd/run.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -23,7 +23,6 @@ use option::{Some, None};\n use os;\n use prelude::*;\n use ptr;\n-use str;\n use task;\n use vec::ImmutableVector;\n \n@@ -507,7 +506,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         do with_envp(env) |envp| {\n             do with_dirp(dir) |dirp| {\n-                do str::as_c_str(cmd) |cmdp| {\n+                do cmd.as_c_str |cmdp| {\n                     let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  0, envp, dirp, &mut si, &mut pi);\n@@ -696,12 +695,12 @@ fn spawn_process_os(prog: &str, args: &[~str],\n #[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: &fn(**libc::c_char) -> T) -> T {\n-    let mut argptrs = ~[str::as_c_str(prog, |b| b)];\n+    let mut argptrs = ~[prog.as_c_str(|b| b)];\n     let mut tmps = ~[];\n     for args.iter().advance |arg| {\n         let t = @(*arg).clone();\n         tmps.push(t);\n-        argptrs.push(str::as_c_str(*t, |b| b));\n+        argptrs.push(t.as_c_str(|b| b));\n     }\n     argptrs.push(ptr::null());\n     argptrs.as_imm_buf(|buf, _len| cb(buf))\n@@ -723,7 +722,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n                 &(ref k, ref v) => {\n                     let kv = @fmt!(\"%s=%s\", *k, *v);\n                     tmps.push(kv);\n-                    ptrs.push(str::as_c_str(*kv, |b| b));\n+                    ptrs.push(kv.as_c_str(|b| b));\n                 }\n             }\n         }\n@@ -747,7 +746,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n         let mut blk = ~[];\n         for es.iter().advance |pair| {\n             let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n-            blk.push_all(kv.as_bytes_with_null_consume());\n+            blk.push_all(kv.to_bytes_with_null());\n         }\n         blk.push(0);\n         blk.as_imm_buf(|p, _len|\n@@ -761,7 +760,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n fn with_dirp<T>(d: Option<&Path>,\n                 cb: &fn(*libc::c_char) -> T) -> T {\n     match d {\n-      Some(dir) => str::as_c_str(dir.to_str(), cb),\n+      Some(dir) => dir.to_str().as_c_str(cb),\n       None => cb(ptr::null())\n     }\n }"}, {"sha": "636bbc48f8eb42100bb4441a153e0b2ee3ecac73", "filename": "src/libstd/str.rs", "status": "modified", "additions": 152, "deletions": 178, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -17,7 +17,6 @@\n  */\n \n use at_vec;\n-use cast::transmute;\n use cast;\n use char;\n use char::Char;\n@@ -33,7 +32,7 @@ use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n use vec;\n-use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector};\n+use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n \n /*\n Section: Conditions\n@@ -121,23 +120,17 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     }\n }\n \n-/// Copy a slice into a new unique str\n-#[inline]\n-pub fn to_owned(s: &str) -> ~str {\n-    unsafe { raw::slice_bytes_owned(s, 0, s.len()) }\n-}\n-\n impl ToStr for ~str {\n     #[inline]\n-    fn to_str(&self) -> ~str { to_owned(*self) }\n+    fn to_str(&self) -> ~str { self.to_owned() }\n }\n impl<'self> ToStr for &'self str {\n     #[inline]\n-    fn to_str(&self) -> ~str { to_owned(*self) }\n+    fn to_str(&self) -> ~str { self.to_owned() }\n }\n impl ToStr for @str {\n     #[inline]\n-    fn to_str(&self) -> ~str { to_owned(*self) }\n+    fn to_str(&self) -> ~str { self.to_owned() }\n }\n \n /**\n@@ -187,15 +180,13 @@ impl<'self, S: Str> StrVector for &'self [S] {\n \n         let len = self.iter().transform(|s| s.as_slice().len()).sum();\n \n-        let mut s = ~\"\";\n-\n-        s.reserve(len);\n+        let mut s = with_capacity(len);\n \n         unsafe {\n-            do as_buf(s) |buf, _| {\n-                let mut buf = ::cast::transmute_mut_unsafe(buf);\n+            do s.as_mut_buf |buf, _| {\n+                let mut buf = buf;\n                 for self.iter().advance |ss| {\n-                    do as_buf(ss.as_slice()) |ssbuf, sslen| {\n+                    do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n                         buf = buf.offset(sslen);\n@@ -223,12 +214,12 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         s.reserve(len);\n \n         unsafe {\n-            do as_buf(s) |buf, _| {\n-                do as_buf(sep) |sepbuf, seplen| {\n+            do s.as_mut_buf |buf, _| {\n+                do sep.as_imm_buf |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n                     let mut buf = ::cast::transmute_mut_unsafe(buf);\n                     for self.iter().advance |ss| {\n-                        do as_buf(ss.as_slice()) |ssbuf, sslen| {\n+                        do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n                             if first {\n                                 first = false;\n@@ -534,8 +525,8 @@ Section: Comparing strings\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do as_buf(a) |ap, alen| {\n-        do as_buf(b) |bp, blen| {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -551,8 +542,8 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n #[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do as_buf(a) |ap, alen| {\n-        do as_buf(b) |bp, blen| {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -685,6 +676,7 @@ pub fn from_utf16(v: &[u16]) -> ~str {\n  * Allocates a new string with the specified capacity. The string returned is\n  * the empty string, but has capacity for much more.\n  */\n+#[inline]\n pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n     buf.reserve(capacity);\n@@ -774,75 +766,13 @@ static TAG_THREE_B: uint = 224u;\n static MAX_THREE_B: uint = 65536u;\n static TAG_FOUR_B: uint = 240u;\n \n-/**\n- * A dummy trait to hold all the utility methods that we implement on strings.\n- */\n-pub trait StrUtil {\n-    /**\n-     * Work with the byte buffer of a string as a null-terminated C string.\n-     *\n-     * Allows for unsafe manipulation of strings, which is useful for foreign\n-     * interop. This is similar to `str::as_buf`, but guarantees null-termination.\n-     * If the given slice is not already null-terminated, this function will\n-     * allocate a temporary, copy the slice, null terminate it, and pass\n-     * that instead.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * let s = \"PATH\".as_c_str(|path| libc::getenv(path));\n-     * ~~~\n-     */\n-    fn as_c_str<T>(self, f: &fn(*libc::c_char) -> T) -> T;\n-}\n-\n-impl<'self> StrUtil for &'self str {\n-    #[inline]\n-    fn as_c_str<T>(self, f: &fn(*libc::c_char) -> T) -> T {\n-        do as_buf(self) |buf, len| {\n-            // NB: len includes the trailing null.\n-            assert!(len > 0);\n-            if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n-                to_owned(self).as_c_str(|s| f(s))\n-            } else {\n-                f(buf as *libc::c_char)\n-            }\n-        }\n-    }\n-}\n-\n-/**\n- * Deprecated. Use the `as_c_str` method on strings instead.\n- */\n-#[inline]\n-pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n-    s.as_c_str(f)\n-}\n-\n-/**\n- * Work with the byte buffer and length of a slice.\n- *\n- * The given length is one byte longer than the 'official' indexable\n- * length of the string. This is to permit probing the byte past the\n- * indexable area for a null byte, as is the case in slices pointing\n- * to full strings, or suffixes of them.\n- */\n-#[inline]\n-pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n-    unsafe {\n-        let v : *(*u8,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len)\n-    }\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     use cast;\n     use libc;\n     use ptr;\n     use str::raw;\n-    use str::{as_buf, is_utf8};\n+    use str::{is_utf8};\n     use vec;\n     use vec::MutableVector;\n \n@@ -920,33 +850,6 @@ pub mod raw {\n         ::cast::transmute(v)\n     }\n \n-    /**\n-     * Takes a bytewise (not UTF-8) slice from a string.\n-     *\n-     * Returns the substring from [`begin`..`end`).\n-     *\n-     * # Failure\n-     *\n-     * If begin is greater than end.\n-     * If end is greater than the length of the string.\n-     */\n-    pub unsafe fn slice_bytes_owned(s: &str, begin: uint, end: uint) -> ~str {\n-        do as_buf(s) |sbuf, n| {\n-            assert!((begin <= end));\n-            assert!((end <= n));\n-\n-            let mut v = vec::with_capacity(end - begin + 1u);\n-            do v.as_imm_buf |vbuf, _vlen| {\n-                let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n-                let src = ptr::offset(sbuf, begin);\n-                ptr::copy_memory(vbuf, src, end - begin);\n-            }\n-            vec::raw::set_len(&mut v, end - begin);\n-            v.push(0u8);\n-            ::cast::transmute(v)\n-        }\n-    }\n-\n     /**\n      * Takes a bytewise (not UTF-8) slice from a string.\n      *\n@@ -959,7 +862,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n-        do as_buf(s) |sbuf, n| {\n+        do s.as_imm_buf |sbuf, n| {\n              assert!((begin <= end));\n              assert!((end <= n));\n \n@@ -972,8 +875,7 @@ pub mod raw {\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         let new_len = s.len() + 1;\n         s.reserve_at_least(new_len);\n-        do as_buf(*s) |buf, len| {\n-            let buf: *mut u8 = ::cast::transmute(buf);\n+        do s.as_mut_buf |buf, len| {\n             *ptr::mut_offset(buf, len) = b;\n         }\n         set_len(&mut *s, new_len);\n@@ -1000,7 +902,7 @@ pub mod raw {\n         let len = s.len();\n         assert!((len > 0u));\n         let b = s[0];\n-        *s = raw::slice_bytes_owned(*s, 1u, len);\n+        *s = s.slice(1, len).to_owned();\n         return b;\n     }\n \n@@ -1193,7 +1095,7 @@ impl<'self> Str for @str {\n impl<'self> Container for &'self str {\n     #[inline]\n     fn len(&self) -> uint {\n-        do as_buf(*self) |_p, n| { n - 1u }\n+        do self.as_imm_buf |_p, n| { n - 1u }\n     }\n     #[inline]\n     fn is_empty(&self) -> bool {\n@@ -1287,6 +1189,9 @@ pub trait StrSlice<'self> {\n     fn lev_distance(&self, t: &str) -> uint;\n \n     fn subslice_offset(&self, inner: &str) -> uint;\n+\n+    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n+    fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T;\n }\n \n /// Extension methods for strings\n@@ -1669,7 +1574,21 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Copy a slice into a new unique str\n     #[inline]\n-    fn to_owned(&self) -> ~str { to_owned(*self) }\n+    fn to_owned(&self) -> ~str {\n+        do self.as_imm_buf |src, len| {\n+            assert!(len > 0);\n+            unsafe {\n+                let mut v = vec::with_capacity(len);\n+\n+                do v.as_mut_buf |dst, _| {\n+                    ptr::copy_memory(dst, src, len - 1);\n+                }\n+                vec::raw::set_len(&mut v, len - 1);\n+                v.push(0u8);\n+                ::cast::transmute(v)\n+            }\n+        }\n+    }\n \n     #[inline]\n     fn to_managed(&self) -> @str {\n@@ -1909,15 +1828,14 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n-        do as_buf(*self) |buf, len| {\n-            let mut ret = ~\"\";\n+        do self.as_imm_buf |buf, len| {\n             // ignore the NULL terminator\n             let len = len - 1;\n-            ret.reserve(nn * len);\n+            let mut ret = with_capacity(nn * len);\n \n             unsafe {\n-                do as_buf(ret) |rbuf, _len| {\n-                    let mut rbuf = ::cast::transmute_mut_unsafe(rbuf);\n+                do ret.as_mut_buf |rbuf, _len| {\n+                    let mut rbuf = rbuf;\n \n                     for nn.times {\n                         ptr::copy_memory(rbuf, buf, len);\n@@ -2010,8 +1928,8 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn subslice_offset(&self, inner: &str) -> uint {\n-        do as_buf(*self) |a, a_len| {\n-            do as_buf(inner) |b, b_len| {\n+        do self.as_imm_buf |a, a_len| {\n+            do inner.as_imm_buf |b, b_len| {\n                 let a_start: uint;\n                 let a_end: uint;\n                 let b_start: uint;\n@@ -2027,6 +1945,47 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /**\n+     * Work with the byte buffer and length of a slice.\n+     *\n+     * The given length is one byte longer than the 'official' indexable\n+     * length of the string. This is to permit probing the byte past the\n+     * indexable area for a null byte, as is the case in slices pointing\n+     * to full strings, or suffixes of them.\n+     */\n+    #[inline]\n+    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n+        let v: &[u8] = unsafe { cast::transmute(*self) };\n+        v.as_imm_buf(f)\n+    }\n+\n+    /**\n+     * Work with the byte buffer of a string as a null-terminated C string.\n+     *\n+     * Allows for unsafe manipulation of strings, which is useful for foreign\n+     * interop. This is similar to `str::as_buf`, but guarantees null-termination.\n+     * If the given slice is not already null-terminated, this function will\n+     * allocate a temporary, copy the slice, null terminate it, and pass\n+     * that instead.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * let s = \"PATH\".as_c_str(|path| libc::getenv(path));\n+     * ~~~\n+     */\n+    #[inline]\n+    fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+        do self.as_imm_buf |buf, len| {\n+            // NB: len includes the trailing null.\n+            assert!(len > 0);\n+            if unsafe { *(ptr::offset(buf, len - 1)) != 0 } {\n+                self.to_owned().as_c_str(|s| f(s))\n+            } else {\n+                f(buf as *libc::c_char)\n+            }\n+        }\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -2069,12 +2028,23 @@ pub trait OwnedStr {\n     fn pop_char(&mut self) -> char;\n     fn shift_char(&mut self) -> char;\n     fn unshift_char(&mut self, ch: char);\n-    fn append(&self, rhs: &str) -> ~str; // FIXME #4850: this should consume self.\n+    fn append(self, rhs: &str) -> ~str;\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n+    fn to_bytes_with_null(self) -> ~[u8];\n \n-    fn as_bytes_with_null_consume(self) -> ~[u8];\n+    /**\n+     * Work with the mutable byte buffer and length of a slice.\n+     *\n+     * The given length is one byte longer than the 'official' indexable\n+     * length of the string. This is to permit probing the byte past the\n+     * indexable area for a null byte, as is the case in slices pointing\n+     * to full strings, or suffixes of them.\n+     *\n+     * Make sure any mutations to this buffer keep this string valid UTF8.\n+     */\n+    fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T;\n }\n \n impl OwnedStr for ~str {\n@@ -2085,8 +2055,8 @@ impl OwnedStr for ~str {\n             let llen = self.len();\n             let rlen = rhs.len();\n             self.reserve(llen + rlen);\n-            do as_buf(*self) |lbuf, _llen| {\n-                do as_buf(rhs) |rbuf, _rlen| {\n+            do self.as_imm_buf |lbuf, _llen| {\n+                do rhs.as_imm_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n                     let dst = ::cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n@@ -2103,8 +2073,8 @@ impl OwnedStr for ~str {\n             let llen = self.len();\n             let rlen = rhs.len();\n             self.reserve_at_least(llen + rlen);\n-            do as_buf(*self) |lbuf, _llen| {\n-                do as_buf(rhs) |rbuf, _rlen| {\n+            do self.as_imm_buf |lbuf, _llen| {\n+                do rhs.as_imm_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n                     let dst = ::cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n@@ -2127,8 +2097,7 @@ impl OwnedStr for ~str {\n             let new_len = len + nb;\n             self.reserve_at_least(new_len);\n             let off = len;\n-            do as_buf(*self) |buf, _len| {\n-                let buf: *mut u8 = ::cast::transmute(buf);\n+            do self.as_mut_buf |buf, _len| {\n                 match nb {\n                     1u => {\n                         *ptr::mut_offset(buf, off) = code as u8;\n@@ -2178,7 +2147,7 @@ impl OwnedStr for ~str {\n      */\n     fn shift_char(&mut self) -> char {\n         let CharRange {ch, next} = self.char_range_at(0u);\n-        *self = unsafe { raw::slice_bytes_owned(*self, next, self.len()) };\n+        *self = self.slice(next, self.len()).to_owned();\n         return ch;\n     }\n \n@@ -2193,11 +2162,10 @@ impl OwnedStr for ~str {\n \n     /// Concatenate two strings together.\n     #[inline]\n-    fn append(&self, rhs: &str) -> ~str {\n-        // FIXME #4850: this should consume self, but that causes segfaults\n-        let mut v = self.clone();\n-        v.push_str_no_overallocate(rhs);\n-        v\n+    fn append(self, rhs: &str) -> ~str {\n+        let mut new_str = self;\n+        new_str.push_str_no_overallocate(rhs);\n+        new_str\n     }\n \n     /**\n@@ -2263,15 +2231,21 @@ impl OwnedStr for ~str {\n     /// Convert to a vector of bytes. This does not allocate a new\n     /// string, and includes the null terminator.\n     #[inline]\n-    fn as_bytes_with_null_consume(self) -> ~[u8] {\n+    fn to_bytes_with_null(self) -> ~[u8] {\n         unsafe { ::cast::transmute(self) }\n     }\n+\n+    #[inline]\n+    fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T {\n+        let v: &mut ~[u8] = unsafe { cast::transmute(self) };\n+        v.as_mut_buf(f)\n+    }\n }\n \n impl Clone for ~str {\n     #[inline]\n     fn clone(&self) -> ~str {\n-        to_owned(*self)\n+        self.to_owned()\n     }\n }\n \n@@ -3065,17 +3039,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_bytes_with_null_consume() {\n+    fn test_to_bytes_with_null() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = ~[\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n             184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n             109, 0\n         ];\n-        assert_eq!((~\"\").as_bytes_with_null_consume(), ~[0]);\n-        assert_eq!((~\"abc\").as_bytes_with_null_consume(),\n+        assert_eq!((~\"\").to_bytes_with_null(), ~[0]);\n+        assert_eq!((~\"abc\").to_bytes_with_null(),\n                    ~['a' as u8, 'b' as u8, 'c' as u8, 0]);\n-        assert_eq!(s.as_bytes_with_null_consume(), v);\n+        assert_eq!(s.to_bytes_with_null(), v);\n     }\n \n     #[test]\n@@ -3090,45 +3064,45 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_buf() {\n-        let a = \"Abcdefg\";\n-        let b = as_buf(a, |buf, _l| {\n-            assert_eq!(unsafe { *buf }, 65u8);\n-            100\n-        });\n-        assert_eq!(b, 100);\n-    }\n+    fn test_as_imm_buf() {\n+        do \"\".as_imm_buf |buf, len| {\n+            assert_eq!(len, 1);\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 0);\n+            }\n+        }\n \n-    #[test]\n-    fn test_as_buf_small() {\n-        let a = \"A\";\n-        let b = as_buf(a, |buf, _l| {\n-            assert_eq!(unsafe { *buf }, 65u8);\n-            100\n-        });\n-        assert_eq!(b, 100);\n+        do \"hello\".as_imm_buf |buf, len| {\n+            assert_eq!(len, 6);\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n+                assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n+                assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n+                assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n+                assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n+                assert_eq!(*ptr::offset(buf, 5), 0);\n+            }\n+        }\n     }\n \n     #[test]\n-    fn test_as_buf2() {\n-        unsafe {\n-            let s = ~\"hello\";\n-            let sb = as_buf(s, |b, _l| b);\n-            let s_cstr = raw::from_buf(sb);\n-            assert_eq!(s_cstr, s);\n+    fn test_as_c_str() {\n+        let a = ~\"\";\n+        do a.as_c_str |buf| {\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 0);\n+            }\n         }\n-    }\n \n-    #[test]\n-    fn test_as_buf_3() {\n         let a = ~\"hello\";\n-        do as_buf(a) |buf, len| {\n+        do a.as_c_str |buf| {\n             unsafe {\n-                assert_eq!(a[0], 'h' as u8);\n-                assert_eq!(*buf, 'h' as u8);\n-                assert_eq!(len, 6u);\n-                assert_eq!(*ptr::offset(buf,4u), 'o' as u8);\n-                assert_eq!(*ptr::offset(buf,5u), 0u8);\n+                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n         }\n     }"}, {"sha": "28cd2345aab300ab0b136b8f0ff3b240f5471994", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -18,6 +18,7 @@ use io;\n use libc;\n use libc::{c_char, size_t};\n use repr;\n+use str::StrSlice;\n use str;\n use unstable::intrinsics;\n \n@@ -122,27 +123,19 @@ pub trait FailWithCause {\n \n impl FailWithCause for ~str {\n     fn fail_with(cause: ~str, file: &'static str, line: uint) -> ! {\n-        do str::as_buf(cause) |msg_buf, _msg_len| {\n-            do str::as_buf(file) |file_buf, _file_len| {\n-                unsafe {\n-                    let msg_buf = cast::transmute(msg_buf);\n-                    let file_buf = cast::transmute(file_buf);\n-                    begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n-                }\n+        do cause.as_c_str |msg_buf| {\n+            do file.as_c_str |file_buf| {\n+                begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n             }\n         }\n     }\n }\n \n impl FailWithCause for &'static str {\n     fn fail_with(cause: &'static str, file: &'static str, line: uint) -> ! {\n-        do str::as_buf(cause) |msg_buf, _msg_len| {\n-            do str::as_buf(file) |file_buf, _file_len| {\n-                unsafe {\n-                    let msg_buf = cast::transmute(msg_buf);\n-                    let file_buf = cast::transmute(file_buf);\n-                    begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n-                }\n+        do cause.as_c_str |msg_buf| {\n+            do file.as_c_str |file_buf| {\n+                begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n             }\n         }\n     }"}, {"sha": "d96681ae803002ead44633ed89ead3c91e21a64e", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -56,8 +56,8 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n                          index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n-    do str::as_buf(msg) |p, _len| {\n-        fail_(p as *c_char, file, line);\n+    do msg.as_c_str |buf| {\n+        fail_(buf, file, line);\n     }\n }\n "}, {"sha": "5f8a2796248ec43c2606241c403cceb141bd4231", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -87,6 +87,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n }\n \n /// Creates a new vector with a capacity of `capacity`\n+#[inline]\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     unsafe {\n         if contains_managed::<T>() {\n@@ -1691,7 +1692,7 @@ pub trait MutableVector<'self, T> {\n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n     unsafe fn unsafe_set(&self, index: uint, val: T);\n \n-    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U;\n+    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U;\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n@@ -1783,12 +1784,9 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n \n     /// Similar to `as_imm_buf` but passing a `*mut T`\n     #[inline]\n-    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U {\n-        unsafe {\n-            let v : *(*mut T,uint) = transmute(self);\n-            let (buf,len) = *v;\n-            f(buf, len / sys::nonzero_size_of::<T>())\n-        }\n+    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n+        let (buf, len): (*mut T, uint) = unsafe { transmute(self) };\n+        f(buf, len / sys::nonzero_size_of::<T>())\n     }\n \n }"}, {"sha": "9775f1ef45a7475730489d632dffa06984f9f66a", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -20,11 +20,11 @@ mod libc {\n }\n \n fn atol(s: ~str) -> int {\n-    return str::as_buf(s, { |x, _len| unsafe { libc::atol(x) } });\n+    s.as_imm_buf(|x, _len| unsafe { libc::atol(x) })\n }\n \n fn atoll(s: ~str) -> i64 {\n-    return str::as_buf(s, { |x, _len| unsafe { libc::atoll(x) } });\n+    s.as_imm_buf(|x, _len| unsafe { libc::atoll(x) })\n }\n \n pub fn main() {"}, {"sha": "38f36dd258b7acde112eb972d96eaebab173f3fc", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -26,7 +26,7 @@ mod libc {\n fn strlen(str: ~str) -> uint {\n     unsafe {\n         // C string is terminated with a zero\n-        let bytes = str.as_bytes_with_null_consume();\n+        let bytes = str.to_bytes_with_null();\n         return libc::my_strlen(vec::raw::to_ptr(bytes));\n     }\n }"}, {"sha": "db73aac2eae4e1c2e6cef315f501a9630aae7041", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -23,16 +23,14 @@ impl Drop for r {\n               cast::transmute::<*r, uint>(self),\n               cast::transmute::<**int, uint>(&(self.v)),\n               cast::transmute::<*int, uint>(self.v));\n-            let v2: ~int = cast::transmute(self.v);\n+            let _v2: ~int = cast::transmute(self.v);\n         }\n     }\n }\n \n fn r(v: *int) -> r {\n-    unsafe {\n-        r {\n-            v: v\n-        }\n+    r {\n+        v: v\n     }\n }\n \n@@ -52,7 +50,7 @@ pub fn main() {\n         let i2p = cast::transmute_copy(&i2);\n         cast::forget(i2);\n \n-        let mut x1 = @mut t(Node{\n+        let x1 = @mut t(Node{\n             next: None,\n               r: {\n               let rs = r(i1p);\n@@ -64,7 +62,7 @@ pub fn main() {\n                cast::transmute::<@mut t, uint>(x1),\n                cast::transmute::<*r, uint>(&x1.r));\n \n-        let mut x2 = @mut t(Node{\n+        let x2 = @mut t(Node{\n             next: None,\n               r: {\n               let rs = r(i2p);"}, {"sha": "42908a339d200dbea1210087747f71cbaeebfaa7", "filename": "src/test/run-pass/struct-order-of-eval-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -14,5 +14,5 @@ struct S { f0: ~str, f1: int }\n \n pub fn main() {\n     let s = ~\"Hello, world!\";\n-    let _s = S { f0: str::to_owned(s), ..S { f0: s, f1: 23 } };\n+    let _s = S { f0: s.to_owned(), ..S { f0: s, f1: 23 } };\n }"}, {"sha": "b6851a728882a94fe4fafe912ef436f7b7722505", "filename": "src/test/run-pass/struct-order-of-eval-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330378d1a1a97be85f1150242da277c00b7270f5/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs?ref=330378d1a1a97be85f1150242da277c00b7270f5", "patch": "@@ -14,5 +14,5 @@ struct S { f0: ~str, f1: ~str }\n \n pub fn main() {\n     let s = ~\"Hello, world!\";\n-    let _s = S { f1: str::to_owned(s), f0: s };\n+    let _s = S { f1: s.to_owned(), f0: s };\n }"}]}