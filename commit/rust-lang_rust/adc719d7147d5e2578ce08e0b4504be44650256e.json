{"sha": "adc719d7147d5e2578ce08e0b4504be44650256e", "node_id": "C_kwDOAAsO6NoAKGFkYzcxOWQ3MTQ3ZDVlMjU3OGNlMDhlMGI0NTA0YmU0NDY1MDI1NmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-05T22:44:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-05T22:44:59Z"}, "message": "Auto merge of #112324 - matthiaskrgr:rollup-qscmi3c, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #112081 (Avoid ICE on `#![doc(test(...)]` with literal parameter)\n - #112196 (Resolve vars in result from `scrape_region_constraints`)\n - #112303 (Normalize in infcx instead of globally for `Option::as_deref` suggestion)\n - #112316 (Ensure space is inserted after keyword in `unused_delims`)\n - #112318 (Merge method, type and const object safety checks)\n - #112322 (Don't mention `IMPLIED_BOUNDS_ENTAILMENT` if signatures reference error)\n\nFailed merges:\n\n - #112251 (rustdoc: convert `if let Some()` that always matches to variable)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e9c83e9ca6e6fdb862d664eddeb5cb3cfd87f42e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c83e9ca6e6fdb862d664eddeb5cb3cfd87f42e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adc719d7147d5e2578ce08e0b4504be44650256e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adc719d7147d5e2578ce08e0b4504be44650256e", "html_url": "https://github.com/rust-lang/rust/commit/adc719d7147d5e2578ce08e0b4504be44650256e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adc719d7147d5e2578ce08e0b4504be44650256e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6d4725c76f3b526c74454bc51afdf6daf133506", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d4725c76f3b526c74454bc51afdf6daf133506", "html_url": "https://github.com/rust-lang/rust/commit/e6d4725c76f3b526c74454bc51afdf6daf133506"}, {"sha": "dcdd867a5298b5e5aedb77dc6b38862aa1867a44", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcdd867a5298b5e5aedb77dc6b38862aa1867a44", "html_url": "https://github.com/rust-lang/rust/commit/dcdd867a5298b5e5aedb77dc6b38862aa1867a44"}], "stats": {"total": 500, "additions": 364, "deletions": 136}, "files": [{"sha": "95517f01414751db734c963b4c162121b9e993d3", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -1601,7 +1601,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n-                                .filter(|item| tcx.opt_rpitit_info(item.def_id).is_none())\n+                                .filter(|item| item.opt_rpitit_info.is_none())\n                                 .map(|item| item.def_id),\n                         );\n                     }\n@@ -1643,6 +1643,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n+        // `dyn Trait<Assoc = Foo>` desugars to (not Rust syntax) `dyn Trait where <Self as Trait>::Assoc = Foo`.\n+        // So every `Projection` clause is an `Assoc = Foo` bound. `associated_types` contains all associated\n+        // types's `DefId`, so the following loop removes all the `DefIds` of the associated types that have a\n+        // corresponding `Projection` clause\n         for (projection_bound, _) in &projection_bounds {\n             for def_ids in associated_types.values_mut() {\n                 def_ids.remove(&projection_bound.projection_def_id());"}, {"sha": "dce31975dbc5de5f27c0aa2a33093305f2fddbda", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -302,7 +302,7 @@ fn compare_method_predicate_entailment<'tcx>(\n         return Err(emitted);\n     }\n \n-    if check_implied_wf == CheckImpliedWfMode::Check {\n+    if check_implied_wf == CheckImpliedWfMode::Check && !(impl_sig, trait_sig).references_error() {\n         // We need to check that the impl's args are well-formed given\n         // the hybrid param-env (impl + trait method where-clauses).\n         ocx.register_obligation(traits::Obligation::new(\n@@ -1216,7 +1216,7 @@ fn compare_number_of_generics<'tcx>(\n     // has mismatched type or const generic arguments, then the method that it's\n     // inheriting the generics from will also have mismatched arguments, and\n     // we'll report an error for that instead. Delay a bug for safety, though.\n-    if tcx.opt_rpitit_info(trait_.def_id).is_some() {\n+    if trait_.opt_rpitit_info.is_some() {\n         return Err(tcx.sess.delay_span_bug(\n             rustc_span::DUMMY_SP,\n             \"errors comparing numbers of generics of trait/impl functions were not emitted\",\n@@ -2006,7 +2006,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     // A synthetic impl Trait for RPITIT desugaring has no HIR, which we currently use to get the\n     // span for an impl's associated type. Instead, for these, use the def_span for the synthesized\n     // associated type.\n-    let impl_ty_span = if tcx.opt_rpitit_info(impl_ty.def_id).is_some() {\n+    let impl_ty_span = if impl_ty.opt_rpitit_info.is_some() {\n         tcx.def_span(impl_ty_def_id)\n     } else {\n         match tcx.hir().get_by_def_id(impl_ty_def_id) {"}, {"sha": "c9e74896ac08e252987770393a75b8e78d33e2b0", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -188,7 +188,7 @@ fn missing_items_err(\n     full_impl_span: Span,\n ) {\n     let missing_items =\n-        missing_items.iter().filter(|trait_item| tcx.opt_rpitit_info(trait_item.def_id).is_none());\n+        missing_items.iter().filter(|trait_item| trait_item.opt_rpitit_info.is_none());\n \n     let missing_items_msg = missing_items\n         .clone()"}, {"sha": "04df23c736b0dfe2ce50e94a7ab43c75381c7da7", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -556,6 +556,7 @@ trait UnusedDelimLint {\n         followed_by_block: bool,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n+        is_kw: bool,\n     );\n \n     fn is_expr_delims_necessary(\n@@ -624,6 +625,7 @@ trait UnusedDelimLint {\n         ctx: UnusedDelimsCtx,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n+        is_kw: bool,\n     ) {\n         // If `value` has `ExprKind::Err`, unused delim lint can be broken.\n         // For example, the following code caused ICE.\n@@ -667,7 +669,7 @@ trait UnusedDelimLint {\n             left_pos.is_some_and(|s| s >= value.span.lo()),\n             right_pos.is_some_and(|s| s <= value.span.hi()),\n         );\n-        self.emit_unused_delims(cx, value.span, spans, ctx.into(), keep_space);\n+        self.emit_unused_delims(cx, value.span, spans, ctx.into(), keep_space, is_kw);\n     }\n \n     fn emit_unused_delims(\n@@ -677,6 +679,7 @@ trait UnusedDelimLint {\n         spans: Option<(Span, Span)>,\n         msg: &str,\n         keep_space: (bool, bool),\n+        is_kw: bool,\n     ) {\n         let primary_span = if let Some((lo, hi)) = spans {\n             if hi.is_empty() {\n@@ -690,7 +693,7 @@ trait UnusedDelimLint {\n         let suggestion = spans.map(|(lo, hi)| {\n             let sm = cx.sess().source_map();\n             let lo_replace =\n-                    if keep_space.0 &&\n+                    if (keep_space.0 || is_kw) &&\n                         let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(' ') {\n                         \" \"\n                         } else {\n@@ -720,15 +723,15 @@ trait UnusedDelimLint {\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use rustc_ast::ExprKind::*;\n-        let (value, ctx, followed_by_block, left_pos, right_pos) = match e.kind {\n+        let (value, ctx, followed_by_block, left_pos, right_pos, is_kw) = match e.kind {\n             // Do not lint `unused_braces` in `if let` expressions.\n             If(ref cond, ref block, _)\n                 if !matches!(cond.kind, Let(_, _, _))\n                     || Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX =>\n             {\n                 let left = e.span.lo() + rustc_span::BytePos(2);\n                 let right = block.span.lo();\n-                (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right), true)\n             }\n \n             // Do not lint `unused_braces` in `while let` expressions.\n@@ -738,27 +741,27 @@ trait UnusedDelimLint {\n             {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 let right = block.span.lo();\n-                (cond, UnusedDelimsCtx::WhileCond, true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::WhileCond, true, Some(left), Some(right), true)\n             }\n \n             ForLoop(_, ref cond, ref block, ..) => {\n-                (cond, UnusedDelimsCtx::ForIterExpr, true, None, Some(block.span.lo()))\n+                (cond, UnusedDelimsCtx::ForIterExpr, true, None, Some(block.span.lo()), true)\n             }\n \n             Match(ref head, _) if Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n-                (head, UnusedDelimsCtx::MatchScrutineeExpr, true, Some(left), None)\n+                (head, UnusedDelimsCtx::MatchScrutineeExpr, true, Some(left), None, true)\n             }\n \n             Ret(Some(ref value)) => {\n                 let left = e.span.lo() + rustc_span::BytePos(3);\n-                (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None)\n+                (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None, true)\n             }\n \n-            Index(_, ref value) => (value, UnusedDelimsCtx::IndexExpr, false, None, None),\n+            Index(_, ref value) => (value, UnusedDelimsCtx::IndexExpr, false, None, None, false),\n \n             Assign(_, ref value, _) | AssignOp(.., ref value) => {\n-                (value, UnusedDelimsCtx::AssignedValue, false, None, None)\n+                (value, UnusedDelimsCtx::AssignedValue, false, None, None, false)\n             }\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {\n@@ -778,12 +781,20 @@ trait UnusedDelimLint {\n                     return;\n                 }\n                 for arg in args_to_check {\n-                    self.check_unused_delims_expr(cx, arg, ctx, false, None, None);\n+                    self.check_unused_delims_expr(cx, arg, ctx, false, None, None, false);\n                 }\n                 return;\n             }\n         };\n-        self.check_unused_delims_expr(cx, &value, ctx, followed_by_block, left_pos, right_pos);\n+        self.check_unused_delims_expr(\n+            cx,\n+            &value,\n+            ctx,\n+            followed_by_block,\n+            left_pos,\n+            right_pos,\n+            is_kw,\n+        );\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n@@ -794,7 +805,7 @@ trait UnusedDelimLint {\n                         None => UnusedDelimsCtx::AssignedValue,\n                         Some(_) => UnusedDelimsCtx::AssignedValueLetElse,\n                     };\n-                    self.check_unused_delims_expr(cx, init, ctx, false, None, None);\n+                    self.check_unused_delims_expr(cx, init, ctx, false, None, None, false);\n                 }\n             }\n             StmtKind::Expr(ref expr) => {\n@@ -805,6 +816,7 @@ trait UnusedDelimLint {\n                     false,\n                     None,\n                     None,\n+                    false,\n                 );\n             }\n             _ => {}\n@@ -824,6 +836,7 @@ trait UnusedDelimLint {\n                 false,\n                 None,\n                 None,\n+                false,\n             );\n         }\n     }\n@@ -879,6 +892,7 @@ impl UnusedDelimLint for UnusedParens {\n         followed_by_block: bool,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n+        is_kw: bool,\n     ) {\n         match value.kind {\n             ast::ExprKind::Paren(ref inner) => {\n@@ -893,7 +907,7 @@ impl UnusedDelimLint for UnusedParens {\n                                 _,\n                             ) if node.lazy()))\n                 {\n-                    self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                    self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos, is_kw)\n                 }\n             }\n             ast::ExprKind::Let(_, ref expr, _) => {\n@@ -904,6 +918,7 @@ impl UnusedDelimLint for UnusedParens {\n                     followed_by_block,\n                     None,\n                     None,\n+                    false,\n                 );\n             }\n             _ => {}\n@@ -942,7 +957,7 @@ impl UnusedParens {\n                 .span\n                 .find_ancestor_inside(value.span)\n                 .map(|inner| (value.span.with_hi(inner.lo()), value.span.with_lo(inner.hi())));\n-            self.emit_unused_delims(cx, value.span, spans, \"pattern\", keep_space);\n+            self.emit_unused_delims(cx, value.span, spans, \"pattern\", keep_space, false);\n         }\n     }\n }\n@@ -967,6 +982,7 @@ impl EarlyLintPass for UnusedParens {\n                     true,\n                     None,\n                     None,\n+                    true,\n                 );\n                 for stmt in &block.stmts {\n                     <Self as UnusedDelimLint>::check_stmt(self, cx, stmt);\n@@ -985,6 +1001,7 @@ impl EarlyLintPass for UnusedParens {\n                         false,\n                         None,\n                         None,\n+                        true,\n                     );\n                 }\n             }\n@@ -1043,6 +1060,7 @@ impl EarlyLintPass for UnusedParens {\n                     false,\n                     None,\n                     None,\n+                    false,\n                 );\n             }\n             ast::TyKind::Paren(r) => {\n@@ -1057,7 +1075,7 @@ impl EarlyLintPass for UnusedParens {\n                             .find_ancestor_inside(ty.span)\n                             .map(|r| (ty.span.with_hi(r.lo()), ty.span.with_lo(r.hi())));\n \n-                        self.emit_unused_delims(cx, ty.span, spans, \"type\", (false, false));\n+                        self.emit_unused_delims(cx, ty.span, spans, \"type\", (false, false), false);\n                     }\n                 }\n                 self.with_self_ty_parens = false;\n@@ -1130,6 +1148,7 @@ impl UnusedDelimLint for UnusedBraces {\n         followed_by_block: bool,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n+        is_kw: bool,\n     ) {\n         match value.kind {\n             ast::ExprKind::Block(ref inner, None)\n@@ -1170,7 +1189,7 @@ impl UnusedDelimLint for UnusedBraces {\n                             && !value.span.from_expansion()\n                             && !inner.span.from_expansion()\n                         {\n-                            self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                            self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos, is_kw)\n                         }\n                     }\n                 }\n@@ -1183,6 +1202,7 @@ impl UnusedDelimLint for UnusedBraces {\n                     followed_by_block,\n                     None,\n                     None,\n+                    false,\n                 );\n             }\n             _ => {}\n@@ -1207,6 +1227,7 @@ impl EarlyLintPass for UnusedBraces {\n                 false,\n                 None,\n                 None,\n+                false,\n             );\n         }\n     }\n@@ -1220,6 +1241,7 @@ impl EarlyLintPass for UnusedBraces {\n                 false,\n                 None,\n                 None,\n+                false,\n             );\n         }\n     }\n@@ -1233,6 +1255,7 @@ impl EarlyLintPass for UnusedBraces {\n                 false,\n                 None,\n                 None,\n+                false,\n             );\n         }\n     }\n@@ -1247,6 +1270,7 @@ impl EarlyLintPass for UnusedBraces {\n                     false,\n                     None,\n                     None,\n+                    false,\n                 );\n             }\n \n@@ -1258,6 +1282,7 @@ impl EarlyLintPass for UnusedBraces {\n                     false,\n                     None,\n                     None,\n+                    false,\n                 );\n             }\n "}, {"sha": "e76f1614b93345dd3ed9ea2561d0b414be5fe99f", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -211,6 +211,8 @@ passes_doc_keyword_not_mod =\n passes_doc_keyword_only_impl =\n     `#[doc(keyword = \"...\")]` should be used on impl blocks\n \n+passes_doc_test_literal = `#![doc(test(...)]` does not take a literal\n+\n passes_doc_test_takes_list =\n     `#[doc(test(...)]` takes a list of attributes\n "}, {"sha": "c35c7da2664291d4e909eb4b04d07492011fa923", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -944,21 +944,28 @@ impl CheckAttrVisitor<'_> {\n         let mut is_valid = true;\n         if let Some(metas) = meta.meta_item_list() {\n             for i_meta in metas {\n-                match i_meta.name_or_empty() {\n-                    sym::attr | sym::no_crate_inject => {}\n-                    _ => {\n+                match (i_meta.name_or_empty(), i_meta.meta_item()) {\n+                    (sym::attr | sym::no_crate_inject, _) => {}\n+                    (_, Some(m)) => {\n                         self.tcx.emit_spanned_lint(\n                             INVALID_DOC_ATTRIBUTES,\n                             hir_id,\n                             i_meta.span(),\n                             errors::DocTestUnknown {\n-                                path: rustc_ast_pretty::pprust::path_to_string(\n-                                    &i_meta.meta_item().unwrap().path,\n-                                ),\n+                                path: rustc_ast_pretty::pprust::path_to_string(&m.path),\n                             },\n                         );\n                         is_valid = false;\n                     }\n+                    (_, None) => {\n+                        self.tcx.emit_spanned_lint(\n+                            INVALID_DOC_ATTRIBUTES,\n+                            hir_id,\n+                            i_meta.span(),\n+                            errors::DocTestLiteral,\n+                        );\n+                        is_valid = false;\n+                    }\n                 }\n             }\n         } else {"}, {"sha": "ae624dbc9c953b09e48ea236d36ce077f39bd1f2", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -281,6 +281,10 @@ pub struct DocTestUnknown {\n     pub path: String,\n }\n \n+#[derive(LintDiagnostic)]\n+#[diag(passes_doc_test_literal)]\n+pub struct DocTestLiteral;\n+\n #[derive(LintDiagnostic)]\n #[diag(passes_doc_test_takes_list)]\n pub struct DocTestTakesList;"}, {"sha": "80d0faca670a76f8930d66f17037c277ab0c5006", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -3592,8 +3592,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // Extract `<U as Deref>::Target` assoc type and check that it is `T`\n             && let Some(deref_target_did) = tcx.lang_items().deref_target()\n             && let projection = tcx.mk_projection(deref_target_did, tcx.mk_substs(&[ty::GenericArg::from(found_ty)]))\n-            && let Ok(deref_target) = tcx.try_normalize_erasing_regions(param_env, projection)\n-            && deref_target == target_ty\n+            && let InferOk { value: deref_target, obligations } = infcx.at(&ObligationCause::dummy(), param_env).normalize(projection)\n+            && obligations.iter().all(|obligation| infcx.predicate_must_hold_modulo_regions(obligation))\n+            && infcx.can_eq(param_env, deref_target, target_ty)\n         {\n             let help = if let hir::Mutability::Mut = needs_mut\n                 && let Some(deref_mut_did) = tcx.lang_items().deref_mut_trait()"}, {"sha": "b2771915eef8e1a7068a1439c60e99832131f392", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -115,15 +115,11 @@ fn object_safety_violations_for_trait(\n     tcx: TyCtxt<'_>,\n     trait_def_id: DefId,\n ) -> Vec<ObjectSafetyViolation> {\n-    // Check methods for violations.\n+    // Check assoc items for violations.\n     let mut violations: Vec<_> = tcx\n         .associated_items(trait_def_id)\n         .in_definition_order()\n-        .filter(|item| item.kind == ty::AssocKind::Fn)\n-        .filter_map(|&item| {\n-            object_safety_violation_for_method(tcx, trait_def_id, item)\n-                .map(|(code, span)| ObjectSafetyViolation::Method(item.name, code, span))\n-        })\n+        .filter_map(|&item| object_safety_violation_for_assoc_item(tcx, trait_def_id, item))\n         .collect();\n \n     // Check the trait itself.\n@@ -145,30 +141,6 @@ fn object_safety_violations_for_trait(\n         violations.push(ObjectSafetyViolation::SupertraitNonLifetimeBinder(spans));\n     }\n \n-    violations.extend(\n-        tcx.associated_items(trait_def_id)\n-            .in_definition_order()\n-            .filter(|item| item.kind == ty::AssocKind::Const)\n-            .map(|item| {\n-                let ident = item.ident(tcx);\n-                ObjectSafetyViolation::AssocConst(ident.name, ident.span)\n-            }),\n-    );\n-\n-    if !tcx.features().generic_associated_types_extended {\n-        violations.extend(\n-            tcx.associated_items(trait_def_id)\n-                .in_definition_order()\n-                .filter(|item| item.kind == ty::AssocKind::Type)\n-                .filter(|item| !tcx.generics_of(item.def_id).params.is_empty())\n-                .filter(|item| tcx.opt_rpitit_info(item.def_id).is_none())\n-                .map(|item| {\n-                    let ident = item.ident(tcx);\n-                    ObjectSafetyViolation::GAT(ident.name, ident.span)\n-                }),\n-        );\n-    }\n-\n     debug!(\n         \"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n         trait_def_id, violations\n@@ -401,34 +373,54 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     })\n }\n \n-/// Returns `Some(_)` if this method makes the containing trait not object safe.\n-fn object_safety_violation_for_method(\n+/// Returns `Some(_)` if this item makes the containing trait not object safe.\n+#[instrument(level = \"debug\", skip(tcx), ret)]\n+fn object_safety_violation_for_assoc_item(\n     tcx: TyCtxt<'_>,\n     trait_def_id: DefId,\n-    method: ty::AssocItem,\n-) -> Option<(MethodViolationCode, Span)> {\n-    debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n-    // Any method that has a `Self : Sized` requisite is otherwise\n+    item: ty::AssocItem,\n+) -> Option<ObjectSafetyViolation> {\n+    // Any item that has a `Self : Sized` requisite is otherwise\n     // exempt from the regulations.\n-    if generics_require_sized_self(tcx, method.def_id) {\n+    if generics_require_sized_self(tcx, item.def_id) {\n         return None;\n     }\n \n-    let violation = virtual_call_violation_for_method(tcx, trait_def_id, method);\n-    // Get an accurate span depending on the violation.\n-    violation.map(|v| {\n-        let node = tcx.hir().get_if_local(method.def_id);\n-        let span = match (&v, node) {\n-            (MethodViolationCode::ReferencesSelfInput(Some(span)), _) => *span,\n-            (MethodViolationCode::UndispatchableReceiver(Some(span)), _) => *span,\n-            (MethodViolationCode::ReferencesImplTraitInTrait(span), _) => *span,\n-            (MethodViolationCode::ReferencesSelfOutput, Some(node)) => {\n-                node.fn_decl().map_or(method.ident(tcx).span, |decl| decl.output.span())\n+    match item.kind {\n+        // Associated consts are never object safe, as they can't have `where` bounds yet at all,\n+        // and associated const bounds in trait objects aren't a thing yet either.\n+        ty::AssocKind::Const => {\n+            Some(ObjectSafetyViolation::AssocConst(item.name, item.ident(tcx).span))\n+        }\n+        ty::AssocKind::Fn => virtual_call_violation_for_method(tcx, trait_def_id, item).map(|v| {\n+            let node = tcx.hir().get_if_local(item.def_id);\n+            // Get an accurate span depending on the violation.\n+            let span = match (&v, node) {\n+                (MethodViolationCode::ReferencesSelfInput(Some(span)), _) => *span,\n+                (MethodViolationCode::UndispatchableReceiver(Some(span)), _) => *span,\n+                (MethodViolationCode::ReferencesImplTraitInTrait(span), _) => *span,\n+                (MethodViolationCode::ReferencesSelfOutput, Some(node)) => {\n+                    node.fn_decl().map_or(item.ident(tcx).span, |decl| decl.output.span())\n+                }\n+                _ => item.ident(tcx).span,\n+            };\n+\n+            ObjectSafetyViolation::Method(item.name, v, span)\n+        }),\n+        // Associated types can only be object safe if they have `Self: Sized` bounds.\n+        ty::AssocKind::Type => {\n+            if !tcx.features().generic_associated_types_extended\n+                && !tcx.generics_of(item.def_id).params.is_empty()\n+                && item.opt_rpitit_info.is_none()\n+            {\n+                Some(ObjectSafetyViolation::GAT(item.name, item.ident(tcx).span))\n+            } else {\n+                // We will permit associated types if they are explicitly mentioned in the trait object.\n+                // We can't check this here, as here we only check if it is guaranteed to not be possible.\n+                None\n             }\n-            _ => method.ident(tcx).span,\n-        };\n-        (v, span)\n-    })\n+        }\n+    }\n }\n \n /// Returns `Some(_)` if this method cannot be called on a trait"}, {"sha": "8b0973021bcc83ef7463bf711553bc49461491fd", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -5,6 +5,7 @@ use crate::traits::ObligationCtxt;\n use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::ty::{TyCtxt, TypeFoldable};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n \n@@ -24,9 +25,10 @@ impl<F> CustomTypeOp<F> {\n     }\n }\n \n-impl<'tcx, F, R: fmt::Debug> super::TypeOp<'tcx> for CustomTypeOp<F>\n+impl<'tcx, F, R> super::TypeOp<'tcx> for CustomTypeOp<F>\n where\n     F: FnOnce(&ObligationCtxt<'_, 'tcx>) -> Result<R, NoSolution>,\n+    R: fmt::Debug + TypeFoldable<TyCtxt<'tcx>>,\n {\n     type Output = R;\n     /// We can't do any custom error reporting for `CustomTypeOp`, so\n@@ -57,12 +59,16 @@ impl<F> fmt::Debug for CustomTypeOp<F> {\n \n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n-pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n+pub fn scrape_region_constraints<'tcx, Op, R>(\n     infcx: &InferCtxt<'tcx>,\n     op: impl FnOnce(&ObligationCtxt<'_, 'tcx>) -> Result<R, NoSolution>,\n     name: &'static str,\n     span: Span,\n-) -> Result<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>), ErrorGuaranteed> {\n+) -> Result<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>), ErrorGuaranteed>\n+where\n+    R: TypeFoldable<TyCtxt<'tcx>>,\n+    Op: super::TypeOp<'tcx, Output = R>,\n+{\n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n     // end of each custom type op, we scrape out the region\n@@ -91,6 +97,9 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         }\n     })?;\n \n+    // Next trait solver performs operations locally, and normalize goals should resolve vars.\n+    let value = infcx.resolve_vars_if_possible(value);\n+\n     let region_obligations = infcx.take_registered_region_obligations();\n     let region_constraint_data = infcx.take_and_reset_region_constraints();\n     let region_constraints = query_response::make_query_region_constraints("}, {"sha": "a06a1afcb3f2ff468de46f3bc1ebe9bc5ae5d11a", "filename": "tests/ui/attributes/doc-test-literal.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fattributes%2Fdoc-test-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fattributes%2Fdoc-test-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Fdoc-test-literal.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -0,0 +1,7 @@\n+#![deny(warnings)]\n+\n+#![doc(test(\"\"))]\n+//~^ ERROR `#![doc(test(...)]` does not take a literal\n+//~^^ WARN this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+\n+fn main() {}"}, {"sha": "ebee09994ba9fa95fb3beb97bc00dcca5ab866f4", "filename": "tests/ui/attributes/doc-test-literal.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fattributes%2Fdoc-test-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fattributes%2Fdoc-test-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Fdoc-test-literal.stderr?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -0,0 +1,17 @@\n+error: `#![doc(test(...)]` does not take a literal\n+  --> $DIR/doc-test-literal.rs:3:13\n+   |\n+LL | #![doc(test(\"\"))]\n+   |             ^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n+note: the lint level is defined here\n+  --> $DIR/doc-test-literal.rs:1:9\n+   |\n+LL | #![deny(warnings)]\n+   |         ^^^^^^^^\n+   = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(warnings)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "203d512e39812e6e671e7de48e3e6b1f80455b84", "filename": "tests/ui/implied-bounds/references-err.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fimplied-bounds%2Freferences-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fimplied-bounds%2Freferences-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Freferences-err.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -0,0 +1,22 @@\n+trait Identity {\n+    type Identity;\n+}\n+impl<T> Identity for T {\n+    type Identity = T;\n+}\n+\n+trait Trait {\n+    type Assoc: Identity;\n+    fn tokenize(&self) -> <Self::Assoc as Identity>::Identity;\n+}\n+\n+impl Trait for () {\n+    type Assoc = DoesNotExist;\n+    //~^ ERROR cannot find type `DoesNotExist` in this scope\n+\n+    fn tokenize(&self) -> <Self::Assoc as Identity>::Identity {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6076eea3c75faeb6b1990841a421c088cf42c875", "filename": "tests/ui/implied-bounds/references-err.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fimplied-bounds%2Freferences-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fimplied-bounds%2Freferences-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Freferences-err.stderr?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `DoesNotExist` in this scope\n+  --> $DIR/references-err.rs:14:18\n+   |\n+LL |     type Assoc = DoesNotExist;\n+   |                  ^^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "9a9f129ec3ab659edbdfcbf1dc17779b5e924e8d", "filename": "tests/ui/issues/issue-13167.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fissues%2Fissue-13167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fissues%2Fissue-13167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-13167.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // pretty-expanded FIXME #23616\n+// revisions: current next\n+//[next] compile-flags: -Ztrait-solver=next\n \n use std::slice;\n "}, {"sha": "27410d4c3b08e24c536daf8369361b235a29146b", "filename": "tests/ui/issues/issue-15734.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fissues%2Fissue-15734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fissues%2Fissue-15734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-15734.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n-// If `Index` used an associated type for its output, this test would\n-// work more smoothly.\n+// revisions: current next\n+//[next] compile-flags: -Ztrait-solver=next\n \n use std::ops::Index;\n "}, {"sha": "bafac05d8daa74612acaff8fa3c93e3ad9181407", "filename": "tests/ui/lint/lint-unnecessary-parens.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Flint%2Flint-unnecessary-parens.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Flint%2Flint-unnecessary-parens.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-unnecessary-parens.fixed?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -35,6 +35,14 @@ pub fn passes_unused_parens_lint() -> &'static (dyn Trait) {\n     panic!()\n }\n \n+pub fn parens_with_keyword(e: &[()]) -> i32 {\n+    if true {} //~ ERROR unnecessary parentheses around `if`\n+    while true {} //~ ERROR unnecessary parentheses around `while`\n+    for _ in e {} //~ ERROR unnecessary parentheses around `for`\n+    match 1 { _ => ()} //~ ERROR unnecessary parentheses around `match`\n+    return 1; //~ ERROR unnecessary parentheses around `return` value\n+}\n+\n macro_rules! baz {\n     ($($foo:expr),+) => {\n         ($($foo),*)"}, {"sha": "ce537a4dc1da0ebcd476fc5e2ccbedcb9e18ddbf", "filename": "tests/ui/lint/lint-unnecessary-parens.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Flint%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Flint%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-unnecessary-parens.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -35,6 +35,14 @@ pub fn passes_unused_parens_lint() -> &'static (dyn Trait) {\n     panic!()\n }\n \n+pub fn parens_with_keyword(e: &[()]) -> i32 {\n+    if(true) {} //~ ERROR unnecessary parentheses around `if`\n+    while(true) {} //~ ERROR unnecessary parentheses around `while`\n+    for _ in(e) {} //~ ERROR unnecessary parentheses around `for`\n+    match(1) { _ => ()} //~ ERROR unnecessary parentheses around `match`\n+    return(1); //~ ERROR unnecessary parentheses around `return` value\n+}\n+\n macro_rules! baz {\n     ($($foo:expr),+) => {\n         ($($foo),*)"}, {"sha": "2ad07530f8c8dc1d908371b095ddf6e1b68bb901", "filename": "tests/ui/lint/lint-unnecessary-parens.stderr", "status": "modified", "additions": 73, "deletions": 13, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-unnecessary-parens.stderr?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -63,8 +63,68 @@ LL -     (5)\n LL +     5\n    |\n \n+error: unnecessary parentheses around `if` condition\n+  --> $DIR/lint-unnecessary-parens.rs:39:7\n+   |\n+LL |     if(true) {}\n+   |       ^    ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     if(true) {}\n+LL +     if true {}\n+   |\n+\n+error: unnecessary parentheses around `while` condition\n+  --> $DIR/lint-unnecessary-parens.rs:40:10\n+   |\n+LL |     while(true) {}\n+   |          ^    ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     while(true) {}\n+LL +     while true {}\n+   |\n+\n+error: unnecessary parentheses around `for` iterator expression\n+  --> $DIR/lint-unnecessary-parens.rs:41:13\n+   |\n+LL |     for _ in(e) {}\n+   |             ^ ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     for _ in(e) {}\n+LL +     for _ in e {}\n+   |\n+\n+error: unnecessary parentheses around `match` scrutinee expression\n+  --> $DIR/lint-unnecessary-parens.rs:42:10\n+   |\n+LL |     match(1) { _ => ()}\n+   |          ^ ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     match(1) { _ => ()}\n+LL +     match 1 { _ => ()}\n+   |\n+\n+error: unnecessary parentheses around `return` value\n+  --> $DIR/lint-unnecessary-parens.rs:43:11\n+   |\n+LL |     return(1);\n+   |           ^ ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -     return(1);\n+LL +     return 1;\n+   |\n+\n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:44:31\n+  --> $DIR/lint-unnecessary-parens.rs:52:31\n    |\n LL | pub const CONST_ITEM: usize = (10);\n    |                               ^  ^\n@@ -76,7 +136,7 @@ LL + pub const CONST_ITEM: usize = 10;\n    |\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:45:33\n+  --> $DIR/lint-unnecessary-parens.rs:53:33\n    |\n LL | pub static STATIC_ITEM: usize = (10);\n    |                                 ^  ^\n@@ -88,7 +148,7 @@ LL + pub static STATIC_ITEM: usize = 10;\n    |\n \n error: unnecessary parentheses around function argument\n-  --> $DIR/lint-unnecessary-parens.rs:49:9\n+  --> $DIR/lint-unnecessary-parens.rs:57:9\n    |\n LL |     bar((true));\n    |         ^    ^\n@@ -100,7 +160,7 @@ LL +     bar(true);\n    |\n \n error: unnecessary parentheses around `if` condition\n-  --> $DIR/lint-unnecessary-parens.rs:51:8\n+  --> $DIR/lint-unnecessary-parens.rs:59:8\n    |\n LL |     if (true) {}\n    |        ^    ^\n@@ -112,7 +172,7 @@ LL +     if true {}\n    |\n \n error: unnecessary parentheses around `while` condition\n-  --> $DIR/lint-unnecessary-parens.rs:52:11\n+  --> $DIR/lint-unnecessary-parens.rs:60:11\n    |\n LL |     while (true) {}\n    |           ^    ^\n@@ -124,7 +184,7 @@ LL +     while true {}\n    |\n \n error: unnecessary parentheses around `match` scrutinee expression\n-  --> $DIR/lint-unnecessary-parens.rs:53:11\n+  --> $DIR/lint-unnecessary-parens.rs:61:11\n    |\n LL |     match (true) {\n    |           ^    ^\n@@ -136,7 +196,7 @@ LL +     match true {\n    |\n \n error: unnecessary parentheses around `let` scrutinee expression\n-  --> $DIR/lint-unnecessary-parens.rs:56:16\n+  --> $DIR/lint-unnecessary-parens.rs:64:16\n    |\n LL |     if let 1 = (1) {}\n    |                ^ ^\n@@ -148,7 +208,7 @@ LL +     if let 1 = 1 {}\n    |\n \n error: unnecessary parentheses around `let` scrutinee expression\n-  --> $DIR/lint-unnecessary-parens.rs:57:19\n+  --> $DIR/lint-unnecessary-parens.rs:65:19\n    |\n LL |     while let 1 = (2) {}\n    |                   ^ ^\n@@ -160,7 +220,7 @@ LL +     while let 1 = 2 {}\n    |\n \n error: unnecessary parentheses around method argument\n-  --> $DIR/lint-unnecessary-parens.rs:73:24\n+  --> $DIR/lint-unnecessary-parens.rs:81:24\n    |\n LL |     X { y: false }.foo((true));\n    |                        ^    ^\n@@ -172,7 +232,7 @@ LL +     X { y: false }.foo(true);\n    |\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:75:18\n+  --> $DIR/lint-unnecessary-parens.rs:83:18\n    |\n LL |     let mut _a = (0);\n    |                  ^ ^\n@@ -184,7 +244,7 @@ LL +     let mut _a = 0;\n    |\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:76:10\n+  --> $DIR/lint-unnecessary-parens.rs:84:10\n    |\n LL |     _a = (0);\n    |          ^ ^\n@@ -196,7 +256,7 @@ LL +     _a = 0;\n    |\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:77:11\n+  --> $DIR/lint-unnecessary-parens.rs:85:11\n    |\n LL |     _a += (1);\n    |           ^ ^\n@@ -207,5 +267,5 @@ LL -     _a += (1);\n LL +     _a += 1;\n    |\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "5febbbe392b245b99786e22aae1e6be9164a1070", "filename": "tests/ui/mismatched_types/suggest-option-asderef-inference-var.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-inference-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-inference-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-inference-var.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -0,0 +1,9 @@\n+fn deref_int(a: &i32) -> i32 {\n+    *a\n+}\n+\n+fn main() {\n+    // https://github.com/rust-lang/rust/issues/112293\n+    let _has_inference_vars: Option<i32> = Some(0).map(deref_int);\n+    //~^ ERROR type mismatch in function arguments\n+}"}, {"sha": "71c4729e31038204480ddf243fd5878373d074a2", "filename": "tests/ui/mismatched_types/suggest-option-asderef-inference-var.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-inference-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-inference-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-inference-var.stderr?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -0,0 +1,24 @@\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef-inference-var.rs:7:56\n+   |\n+LL | fn deref_int(a: &i32) -> i32 {\n+   | ---------------------------- found signature defined here\n+...\n+LL |     let _has_inference_vars: Option<i32> = Some(0).map(deref_int);\n+   |                                                    --- ^^^^^^^^^ expected due to this\n+   |                                                    |\n+   |                                                    required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn({integer}) -> _`\n+              found function signature `for<'a> fn(&'a i32) -> _`\n+note: required by a bound in `Option::<T>::map`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: do not borrow the argument\n+   |\n+LL - fn deref_int(a: &i32) -> i32 {\n+LL + fn deref_int(a: i32) -> i32 {\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "ac0831ce655080ebb7ca8979bb7ac466a79962b2", "filename": "tests/ui/mismatched_types/suggest-option-asderef-unfixable.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -10,10 +10,6 @@ fn no_args() -> Option<()> {\n     Some(())\n }\n \n-fn generic_ref<T>(_: &T) -> Option<()> {\n-    Some(())\n-}\n-\n extern \"C\" fn takes_str_but_wrong_abi(_: &str) -> Option<()> {\n     Some(())\n }\n@@ -33,8 +29,6 @@ fn main() {\n     //~^ ERROR expected a `FnOnce<(String,)>` closure, found `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n     let _ = produces_string().and_then(no_args);\n     //~^ ERROR function is expected to take 1 argument, but it takes 0 arguments\n-    let _ = produces_string().and_then(generic_ref);\n-    //~^ ERROR type mismatch in function arguments\n     let _ = Some(TypeWithoutDeref).and_then(takes_str_but_too_many_refs);\n     //~^ ERROR type mismatch in function arguments\n }"}, {"sha": "ecfbd27b180e67105abc64a425a0399f0fb6e386", "filename": "tests/ui/mismatched_types/suggest-option-asderef-unfixable.stderr", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -1,5 +1,5 @@\n error[E0631]: type mismatch in function arguments\n-  --> $DIR/suggest-option-asderef-unfixable.rs:28:40\n+  --> $DIR/suggest-option-asderef-unfixable.rs:24:40\n    |\n LL | fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n    | ------------------------------------------------------ found signature defined here\n@@ -15,7 +15,7 @@ note: required by a bound in `Option::<T>::and_then`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n \n error[E0277]: expected a `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n-  --> $DIR/suggest-option-asderef-unfixable.rs:30:40\n+  --> $DIR/suggest-option-asderef-unfixable.rs:26:40\n    |\n LL |     let _ = produces_string().and_then(takes_str_but_wrong_abi);\n    |                               -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n@@ -27,7 +27,7 @@ note: required by a bound in `Option::<T>::and_then`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n \n error[E0277]: expected a `FnOnce<(String,)>` closure, found `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n-  --> $DIR/suggest-option-asderef-unfixable.rs:32:40\n+  --> $DIR/suggest-option-asderef-unfixable.rs:28:40\n    |\n LL |     let _ = produces_string().and_then(takes_str_but_unsafe);\n    |                               -------- ^^^^^^^^^^^^^^^^^^^^ call the function in a closure: `|| unsafe { /* code */ }`\n@@ -40,7 +40,7 @@ note: required by a bound in `Option::<T>::and_then`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n \n error[E0593]: function is expected to take 1 argument, but it takes 0 arguments\n-  --> $DIR/suggest-option-asderef-unfixable.rs:34:40\n+  --> $DIR/suggest-option-asderef-unfixable.rs:30:40\n    |\n LL | fn no_args() -> Option<()> {\n    | -------------------------- takes 0 arguments\n@@ -54,28 +54,7 @@ note: required by a bound in `Option::<T>::and_then`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n \n error[E0631]: type mismatch in function arguments\n-  --> $DIR/suggest-option-asderef-unfixable.rs:36:40\n-   |\n-LL | fn generic_ref<T>(_: &T) -> Option<()> {\n-   | -------------------------------------- found signature defined here\n-...\n-LL |     let _ = produces_string().and_then(generic_ref);\n-   |                               -------- ^^^^^^^^^^^ expected due to this\n-   |                               |\n-   |                               required by a bound introduced by this call\n-   |\n-   = note: expected function signature `fn(String) -> _`\n-              found function signature `for<'a> fn(&'a _) -> _`\n-note: required by a bound in `Option::<T>::and_then`\n-  --> $SRC_DIR/core/src/option.rs:LL:COL\n-help: do not borrow the argument\n-   |\n-LL - fn generic_ref<T>(_: &T) -> Option<()> {\n-LL + fn generic_ref<T>(_: T) -> Option<()> {\n-   |\n-\n-error[E0631]: type mismatch in function arguments\n-  --> $DIR/suggest-option-asderef-unfixable.rs:38:45\n+  --> $DIR/suggest-option-asderef-unfixable.rs:32:45\n    |\n LL | fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n    | ------------------------------------------------------ found signature defined here\n@@ -90,7 +69,7 @@ LL |     let _ = Some(TypeWithoutDeref).and_then(takes_str_but_too_many_refs);\n note: required by a bound in `Option::<T>::and_then`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0277, E0593, E0631.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "5c42ece3c5d094faf55cda01ad56cf4be372c8e7", "filename": "tests/ui/mismatched_types/suggest-option-asderef.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -16,6 +16,11 @@ fn generic<T>(_: T) -> Option<()> {\n     Some(())\n }\n \n+fn generic_ref<T>(_: T) -> Option<()> {\n+    //~^ HELP do not borrow the argument\n+    Some(())\n+}\n+\n fn main() {\n     let _: Option<()> = produces_string().as_deref().and_then(takes_str);\n     //~^ ERROR type mismatch in function arguments\n@@ -27,4 +32,8 @@ fn main() {\n     //~^ ERROR type mismatch in function arguments\n     //~| HELP call `Option::as_deref_mut()` first\n     let _ = produces_string().and_then(generic);\n+\n+    let _ = produces_string().as_deref().and_then(generic_ref);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n }"}, {"sha": "a5278b8fb16184095ff9aa8953251cfe4ebaed20", "filename": "tests/ui/mismatched_types/suggest-option-asderef.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -16,6 +16,11 @@ fn generic<T>(_: T) -> Option<()> {\n     Some(())\n }\n \n+fn generic_ref<T>(_: &T) -> Option<()> {\n+    //~^ HELP do not borrow the argument\n+    Some(())\n+}\n+\n fn main() {\n     let _: Option<()> = produces_string().and_then(takes_str);\n     //~^ ERROR type mismatch in function arguments\n@@ -27,4 +32,8 @@ fn main() {\n     //~^ ERROR type mismatch in function arguments\n     //~| HELP call `Option::as_deref_mut()` first\n     let _ = produces_string().and_then(generic);\n+\n+    let _ = produces_string().and_then(generic_ref);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n }"}, {"sha": "01341603dde3fc6f1ed52729b7ecc670c53d61d2", "filename": "tests/ui/mismatched_types/suggest-option-asderef.stderr", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -1,5 +1,5 @@\n error[E0631]: type mismatch in function arguments\n-  --> $DIR/suggest-option-asderef.rs:20:52\n+  --> $DIR/suggest-option-asderef.rs:25:52\n    |\n LL | fn takes_str(_: &str) -> Option<()> {\n    | ----------------------------------- found signature defined here\n@@ -19,7 +19,7 @@ LL |     let _: Option<()> = produces_string().as_deref().and_then(takes_str);\n    |                                          +++++++++++\n \n error[E0631]: type mismatch in function arguments\n-  --> $DIR/suggest-option-asderef.rs:23:55\n+  --> $DIR/suggest-option-asderef.rs:28:55\n    |\n LL | fn takes_str(_: &str) -> Option<()> {\n    | ----------------------------------- found signature defined here\n@@ -39,7 +39,7 @@ LL |     let _: Option<Option<()>> = produces_string().as_deref().map(takes_str)\n    |                                                  +++++++++++\n \n error[E0631]: type mismatch in function arguments\n-  --> $DIR/suggest-option-asderef.rs:26:55\n+  --> $DIR/suggest-option-asderef.rs:31:55\n    |\n LL | fn takes_str_mut(_: &mut str) -> Option<()> {\n    | ------------------------------------------- found signature defined here\n@@ -58,6 +58,31 @@ help: call `Option::as_deref_mut()` first\n LL |     let _: Option<Option<()>> = produces_string().as_deref_mut().map(takes_str_mut);\n    |                                                  +++++++++++++++\n \n-error: aborting due to 3 previous errors\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef.rs:36:40\n+   |\n+LL | fn generic_ref<T>(_: &T) -> Option<()> {\n+   | -------------------------------------- found signature defined here\n+...\n+LL |     let _ = produces_string().and_then(generic_ref);\n+   |                               -------- ^^^^^^^^^^^ expected due to this\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a _) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: do not borrow the argument\n+   |\n+LL - fn generic_ref<T>(_: &T) -> Option<()> {\n+LL + fn generic_ref<T>(_: T) -> Option<()> {\n+   |\n+help: call `Option::as_deref()` first\n+   |\n+LL |     let _ = produces_string().as_deref().and_then(generic_ref);\n+   |                              +++++++++++\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0631`."}, {"sha": "015b72367f1d740f19c1a3ee192c425e105fe58f", "filename": "tests/ui/nll/issue-53119.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fnll%2Fissue-53119.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc719d7147d5e2578ce08e0b4504be44650256e/tests%2Fui%2Fnll%2Fissue-53119.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-53119.rs?ref=adc719d7147d5e2578ce08e0b4504be44650256e", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// revisions: current next\n+//[next] compile-flags: -Ztrait-solver=next\n \n use std::ops::Deref;\n "}]}