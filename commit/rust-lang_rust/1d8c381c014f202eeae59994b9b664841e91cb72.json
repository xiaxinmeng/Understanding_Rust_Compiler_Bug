{"sha": "1d8c381c014f202eeae59994b9b664841e91cb72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOGMzODFjMDE0ZjIwMmVlYWU1OTk5NGI5YjY2NDg0MWU5MWNiNzI=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-23T20:56:07Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-23T23:14:47Z"}, "message": "Upgrades the coverage map to Version 4\n\nChanges the coverage map injected into binaries compiled with\n`-Zinstrument-coverage` to LLVM Coverage Mapping Format, Version 4 (from\nVersion 3). Note, binaries compiled with this version will require LLVM\ntools from at least LLVM Version 11.", "tree": {"sha": "de0e8a07e39a98efff17451086877681b65cb5b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de0e8a07e39a98efff17451086877681b65cb5b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d8c381c014f202eeae59994b9b664841e91cb72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d8c381c014f202eeae59994b9b664841e91cb72", "html_url": "https://github.com/rust-lang/rust/commit/1d8c381c014f202eeae59994b9b664841e91cb72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d8c381c014f202eeae59994b9b664841e91cb72/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40624dde6cdfad2576b4d795c97583188a814884", "url": "https://api.github.com/repos/rust-lang/rust/commits/40624dde6cdfad2576b4d795c97583188a814884", "html_url": "https://github.com/rust-lang/rust/commit/40624dde6cdfad2576b4d795c97583188a814884"}], "stats": {"total": 335, "additions": 203, "deletions": 132}, "files": [{"sha": "a6372a77a70ad1c443b255a011f43ffbec887d66", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 97, "deletions": 104, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -4,7 +4,7 @@ use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n-use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n+use rustc_codegen_ssa::traits::ConstMethods;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n@@ -38,46 +38,50 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let mut mapgen = CoverageMapGenerator::new();\n \n     // Encode coverage mappings and generate function records\n-    let mut function_records = Vec::<&'ll llvm::Value>::new();\n-    let coverage_mappings_buffer = llvm::build_byte_buffer(|coverage_mappings_buffer| {\n-        for (instance, function_coverage) in function_coverage_map.into_iter() {\n-            debug!(\"Generate coverage map for: {:?}\", instance);\n-\n-            let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n-            let function_source_hash = function_coverage.source_hash();\n-            let (expressions, counter_regions) =\n-                function_coverage.get_expressions_and_counter_regions();\n-\n-            let old_len = coverage_mappings_buffer.len();\n-            mapgen.write_coverage_mappings(expressions, counter_regions, coverage_mappings_buffer);\n-            let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n-            debug_assert!(\n-                mapping_data_size > 0,\n-                \"Every `FunctionCoverage` should have at least one counter\"\n-            );\n-\n-            let function_record = mapgen.make_function_record(\n-                cx,\n-                mangled_function_name,\n-                function_source_hash,\n-                mapping_data_size,\n-            );\n-            function_records.push(function_record);\n-        }\n-    });\n+    let mut function_data = Vec::new();\n+    for (instance, function_coverage) in function_coverage_map.into_iter() {\n+        debug!(\"Generate coverage map for: {:?}\", instance);\n+\n+        let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n+        let function_source_hash = function_coverage.source_hash();\n+        let (expressions, counter_regions) =\n+            function_coverage.get_expressions_and_counter_regions();\n+\n+        let coverage_mapping_buffer = llvm::build_byte_buffer(|coverage_mapping_buffer| {\n+            mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);\n+        });\n+        debug_assert!(\n+            coverage_mapping_buffer.len() > 0,\n+            \"Every `FunctionCoverage` should have at least one counter\"\n+        );\n+\n+        function_data.push((mangled_function_name, function_source_hash, coverage_mapping_buffer));\n+    }\n \n     // Encode all filenames referenced by counters/expressions in this module\n     let filenames_buffer = llvm::build_byte_buffer(|filenames_buffer| {\n         coverageinfo::write_filenames_section_to_buffer(&mapgen.filenames, filenames_buffer);\n     });\n \n+    let filenames_size = filenames_buffer.len();\n+    let filenames_val = cx.const_bytes(&filenames_buffer[..]);\n+    let filenames_ref = coverageinfo::hash_bytes(filenames_buffer);\n+\n     // Generate the LLVM IR representation of the coverage map and store it in a well-known global\n-    mapgen.save_generated_coverage_map(\n-        cx,\n-        function_records,\n-        filenames_buffer,\n-        coverage_mappings_buffer,\n-    );\n+    let cov_data_val = mapgen.generate_coverage_map(cx, filenames_size, filenames_val);\n+\n+    for (mangled_function_name, function_source_hash, coverage_mapping_buffer) in function_data {\n+        save_function_record(\n+            cx,\n+            mangled_function_name,\n+            function_source_hash,\n+            filenames_ref,\n+            coverage_mapping_buffer,\n+        );\n+    }\n+\n+    // Save the coverage data value to LLVM IR\n+    coverageinfo::save_cov_data_to_mod(cx, cov_data_val);\n }\n \n struct CoverageMapGenerator {\n@@ -92,12 +96,12 @@ impl CoverageMapGenerator {\n     /// Using the `expressions` and `counter_regions` collected for the current function, generate\n     /// the `mapping_regions` and `virtual_file_mapping`, and capture any new filenames. Then use\n     /// LLVM APIs to encode the `virtual_file_mapping`, `expressions`, and `mapping_regions` into\n-    /// the given `coverage_mappings` byte buffer, compliant with the LLVM Coverage Mapping format.\n-    fn write_coverage_mappings(\n+    /// the given `coverage_mapping` byte buffer, compliant with the LLVM Coverage Mapping format.\n+    fn write_coverage_mapping(\n         &mut self,\n         expressions: Vec<CounterExpression>,\n         counter_regions: impl Iterator<Item = (Counter, &'a CodeRegion)>,\n-        coverage_mappings_buffer: &RustString,\n+        coverage_mapping_buffer: &RustString,\n     ) {\n         let mut counter_regions = counter_regions.collect::<Vec<_>>();\n         if counter_regions.is_empty() {\n@@ -145,89 +149,78 @@ impl CoverageMapGenerator {\n             virtual_file_mapping,\n             expressions,\n             mapping_regions,\n-            coverage_mappings_buffer,\n+            coverage_mapping_buffer,\n         );\n     }\n \n-    /// Generate and return the function record `Value`\n-    fn make_function_record(\n-        &mut self,\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        mangled_function_name: String,\n-        function_source_hash: u64,\n-        mapping_data_size: usize,\n-    ) -> &'ll llvm::Value {\n-        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n-        let name_ref_val = cx.const_u64(name_ref);\n-        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n-        let func_hash_val = cx.const_u64(function_source_hash);\n-        cx.const_struct(\n-            &[name_ref_val, mapping_data_size_val, func_hash_val],\n-            /*packed=*/ true,\n-        )\n-    }\n-\n-    /// Combine the filenames and coverage mappings buffers, construct coverage map header and the\n-    /// array of function records, and combine everything into the complete coverage map. Save the\n-    /// coverage map data into the LLVM IR as a static global using a specific, well-known section\n-    /// and name.\n-    fn save_generated_coverage_map(\n+    /// Construct coverage map header and the array of function records, and combine them into the\n+    /// coverage map. Save the coverage map data into the LLVM IR as a static global using a\n+    /// specific, well-known section and name.\n+    fn generate_coverage_map(\n         self,\n         cx: &CodegenCx<'ll, 'tcx>,\n-        function_records: Vec<&'ll llvm::Value>,\n-        filenames_buffer: Vec<u8>,\n-        mut coverage_mappings_buffer: Vec<u8>,\n-    ) {\n-        // Concatenate the encoded filenames and encoded coverage mappings, and add additional zero\n-        // bytes as-needed to ensure 8-byte alignment.\n-        let mut coverage_size = coverage_mappings_buffer.len();\n-        let filenames_size = filenames_buffer.len();\n-        let remaining_bytes =\n-            (filenames_size + coverage_size) % coverageinfo::COVMAP_VAR_ALIGN_BYTES;\n-        if remaining_bytes > 0 {\n-            let pad = coverageinfo::COVMAP_VAR_ALIGN_BYTES - remaining_bytes;\n-            coverage_mappings_buffer.append(&mut [0].repeat(pad));\n-            coverage_size += pad;\n-        }\n-        let filenames_and_coverage_mappings = [filenames_buffer, coverage_mappings_buffer].concat();\n-        let filenames_and_coverage_mappings_val =\n-            cx.const_bytes(&filenames_and_coverage_mappings[..]);\n-\n+        filenames_size: usize,\n+        filenames_val: &'ll llvm::Value,\n+    ) -> &'ll llvm::Value {\n         debug!(\n-            \"cov map: n_records = {}, filenames_size = {}, coverage_size = {}, 0-based version = {}\",\n-            function_records.len(),\n+            \"cov map: filenames_size = {}, 0-based version = {}\",\n             filenames_size,\n-            coverage_size,\n             coverageinfo::mapping_version()\n         );\n \n-        // Create the coverage data header\n-        let n_records_val = cx.const_u32(function_records.len() as u32);\n+        // Create the coverage data header (Note, fields 0 and 2 are now always zero,\n+        // as of `llvm::coverage::CovMapVersion::Version4`.\n+        let zero_was_n_records_val = cx.const_u32(0);\n         let filenames_size_val = cx.const_u32(filenames_size as u32);\n-        let coverage_size_val = cx.const_u32(coverage_size as u32);\n+        let zero_was_coverage_size_val = cx.const_u32(0 as u32);\n         let version_val = cx.const_u32(coverageinfo::mapping_version());\n         let cov_data_header_val = cx.const_struct(\n-            &[n_records_val, filenames_size_val, coverage_size_val, version_val],\n+            &[zero_was_n_records_val, filenames_size_val, zero_was_coverage_size_val, version_val],\n             /*packed=*/ false,\n         );\n \n-        // Create the function records array\n-        let name_ref_from_u64 = cx.type_i64();\n-        let mapping_data_size_from_u32 = cx.type_i32();\n-        let func_hash_from_u64 = cx.type_i64();\n-        let function_record_ty = cx.type_struct(\n-            &[name_ref_from_u64, mapping_data_size_from_u32, func_hash_from_u64],\n-            /*packed=*/ true,\n-        );\n-        let function_records_val = cx.const_array(function_record_ty, &function_records[..]);\n-\n         // Create the complete LLVM coverage data value to add to the LLVM IR\n-        let cov_data_val = cx.const_struct(\n-            &[cov_data_header_val, function_records_val, filenames_and_coverage_mappings_val],\n-            /*packed=*/ false,\n-        );\n-\n-        // Save the coverage data value to LLVM IR\n-        coverageinfo::save_map_to_mod(cx, cov_data_val);\n+        cx.const_struct(&[cov_data_header_val, filenames_val], /*packed=*/ false)\n     }\n }\n+\n+/// Construct a function record and combine it with the function's coverage mapping data.\n+/// Save the function record into the LLVM IR as a static global using a\n+/// specific, well-known section and name.\n+fn save_function_record(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    mangled_function_name: String,\n+    function_source_hash: u64,\n+    filenames_ref: u64,\n+    coverage_mapping_buffer: Vec<u8>,\n+) {\n+    // Concatenate the encoded coverage mappings\n+    let coverage_mapping_size = coverage_mapping_buffer.len();\n+    let coverage_mapping_val = cx.const_bytes(&coverage_mapping_buffer[..]);\n+\n+    let func_name_hash = coverageinfo::hash_str(&mangled_function_name);\n+    let func_name_hash_val = cx.const_u64(func_name_hash);\n+    let coverage_mapping_size_val = cx.const_u32(coverage_mapping_size as u32);\n+    let func_hash_val = cx.const_u64(function_source_hash);\n+    let filenames_ref_val = cx.const_u64(filenames_ref);\n+    let func_record_val = cx.const_struct(\n+        &[\n+            func_name_hash_val,\n+            coverage_mapping_size_val,\n+            func_hash_val,\n+            filenames_ref_val,\n+            coverage_mapping_val,\n+        ],\n+        /*packed=*/ true,\n+    );\n+\n+    // At the present time, the coverage map for Rust assumes every instrumented function `is_used`.\n+    // Note that Clang marks functions as \"unused\" in `CodeGenPGO::emitEmptyCounterMapping`. (See:\n+    // https://github.com/rust-lang/llvm-project/blob/de02a75e398415bad4df27b4547c25b896c8bf3b/clang%2Flib%2FCodeGen%2FCodeGenPGO.cpp#L877-L878\n+    // for example.)\n+    //\n+    // It's not yet clear if or how this may be applied to Rust in the future, but the `is_used`\n+    // argument is available and handled similarly.\n+    let is_used = true;\n+    coverageinfo::save_func_record_to_mod(cx, func_name_hash, func_record_val, is_used);\n+}"}, {"sha": "e777f363eb0842ee25be12f5254eb986a7b54dea", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -23,7 +23,7 @@ use tracing::debug;\n \n pub mod mapgen;\n \n-const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n+const VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n@@ -177,17 +177,20 @@ pub(crate) fn write_mapping_to_buffer(\n         );\n     }\n }\n+pub(crate) fn hash_str(strval: &str) -> u64 {\n+    let strval = CString::new(strval).expect(\"null error converting hashable str to C string\");\n+    unsafe { llvm::LLVMRustCoverageHashCString(strval.as_ptr()) }\n+}\n \n-pub(crate) fn compute_hash(name: &str) -> u64 {\n-    let name = CString::new(name).expect(\"null error converting hashable name to C string\");\n-    unsafe { llvm::LLVMRustCoverageComputeHash(name.as_ptr()) }\n+pub(crate) fn hash_bytes(bytes: Vec<u8>) -> u64 {\n+    unsafe { llvm::LLVMRustCoverageHashByteArray(bytes.as_ptr().cast(), bytes.len()) }\n }\n \n pub(crate) fn mapping_version() -> u32 {\n     unsafe { llvm::LLVMRustCoverageMappingVersion() }\n }\n \n-pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n+pub(crate) fn save_cov_data_to_mod<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     cov_data_val: &'ll llvm::Value,\n ) {\n@@ -198,16 +201,51 @@ pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n     debug!(\"covmap var name: {:?}\", covmap_var_name);\n \n     let covmap_section_name = llvm::build_string(|s| unsafe {\n-        llvm::LLVMRustCoverageWriteSectionNameToString(cx.llmod, s);\n+        llvm::LLVMRustCoverageWriteMapSectionNameToString(cx.llmod, s);\n     })\n     .expect(\"Rust Coverage section name failed UTF-8 conversion\");\n     debug!(\"covmap section name: {:?}\", covmap_section_name);\n \n     let llglobal = llvm::add_global(cx.llmod, cx.val_ty(cov_data_val), &covmap_var_name);\n     llvm::set_initializer(llglobal, cov_data_val);\n     llvm::set_global_constant(llglobal, true);\n-    llvm::set_linkage(llglobal, llvm::Linkage::InternalLinkage);\n+    llvm::set_linkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::set_section(llglobal, &covmap_section_name);\n-    llvm::set_alignment(llglobal, COVMAP_VAR_ALIGN_BYTES);\n+    llvm::set_alignment(llglobal, VAR_ALIGN_BYTES);\n+    cx.add_used_global(llglobal);\n+}\n+\n+pub(crate) fn save_func_record_to_mod<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func_name_hash: u64,\n+    func_record_val: &'ll llvm::Value,\n+    is_used: bool,\n+) {\n+    // Assign a name to the function record. This is used to merge duplicates.\n+    //\n+    // In LLVM, a \"translation unit\" (effectively, a `Crate` in Rust) can describe functions that\n+    // are included-but-not-used. If (or when) Rust generates functions that are\n+    // included-but-not-used, note that a dummy description for a function included-but-not-used\n+    // in a Crate can be replaced by full description provided by a different Crate. The two kinds\n+    // of descriptions play distinct roles in LLVM IR; therefore, assign them different names (by\n+    // appending \"u\" to the end of the function record var name, to prevent `linkonce_odr` merging.\n+    let func_record_var_name =\n+        format!(\"__covrec_{:X}{}\", func_name_hash, if is_used { \"u\" } else { \"\" });\n+    debug!(\"function record var name: {:?}\", func_record_var_name);\n+\n+    let func_record_section_name = llvm::build_string(|s| unsafe {\n+        llvm::LLVMRustCoverageWriteFuncSectionNameToString(cx.llmod, s);\n+    })\n+    .expect(\"Rust Coverage function record section name failed UTF-8 conversion\");\n+    debug!(\"function record section name: {:?}\", func_record_section_name);\n+\n+    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(func_record_val), &func_record_var_name);\n+    llvm::set_initializer(llglobal, func_record_val);\n+    llvm::set_global_constant(llglobal, true);\n+    llvm::set_linkage(llglobal, llvm::Linkage::LinkOnceODRLinkage);\n+    llvm::set_visibility(llglobal, llvm::Visibility::Hidden);\n+    llvm::set_section(llglobal, &func_record_section_name);\n+    llvm::set_alignment(llglobal, VAR_ALIGN_BYTES);\n+    llvm::set_comdat(cx.llmod, llglobal, &func_record_var_name);\n     cx.add_used_global(llglobal);\n }"}, {"sha": "69a37dba0f1e62f174df6888f7845dbc2c61810c", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -1791,10 +1791,14 @@ extern \"C\" {\n \n     pub fn LLVMRustCoverageCreatePGOFuncNameVar(F: &'a Value, FuncName: *const c_char)\n     -> &'a Value;\n-    pub fn LLVMRustCoverageComputeHash(Name: *const c_char) -> u64;\n+    pub fn LLVMRustCoverageHashCString(StrVal: *const c_char) -> u64;\n+    pub fn LLVMRustCoverageHashByteArray(Bytes: *const c_char, NumBytes: size_t) -> u64;\n \n     #[allow(improper_ctypes)]\n-    pub fn LLVMRustCoverageWriteSectionNameToString(M: &Module, Str: &RustString);\n+    pub fn LLVMRustCoverageWriteMapSectionNameToString(M: &Module, Str: &RustString);\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteFuncSectionNameToString(M: &Module, Str: &RustString);\n \n     #[allow(improper_ctypes)]\n     pub fn LLVMRustCoverageWriteMappingVarNameToString(Str: &RustString);"}, {"sha": "fc40065a9664ea1c84e8917dea7da1fcfab1ca33", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -220,12 +220,24 @@ pub fn set_linkage(llglobal: &Value, linkage: Linkage) {\n     }\n }\n \n+pub fn set_visibility(llglobal: &Value, visibility: Visibility) {\n+    unsafe {\n+        LLVMRustSetVisibility(llglobal, visibility);\n+    }\n+}\n+\n pub fn set_alignment(llglobal: &Value, bytes: usize) {\n     unsafe {\n         ffi::LLVMSetAlignment(llglobal, bytes as c_uint);\n     }\n }\n \n+pub fn set_comdat(llmod: &Module, llglobal: &Value, name: &str) {\n+    unsafe {\n+        LLVMRustSetComdat(llmod, llglobal, name.as_ptr().cast(), name.len());\n+    }\n+}\n+\n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n pub fn get_param(llfn: &Value, index: c_uint) -> &Value {\n     unsafe {"}, {"sha": "6700482f2b7bd43bd490b5456f8a3cba70b8c0b5", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -3,7 +3,6 @@\n #include \"llvm/ProfileData/Coverage/CoverageMappingWriter.h\"\n #include \"llvm/ProfileData/InstrProf.h\"\n #include \"llvm/ADT/ArrayRef.h\"\n-#include \"llvm/Support/LEB128.h\"\n \n #include <iostream>\n \n@@ -13,15 +12,14 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n     const char* const Filenames[],\n     size_t FilenamesLen,\n     RustStringRef BufferOut) {\n-  // LLVM 11's CoverageFilenamesSectionWriter uses its new `Version4` format,\n-  // so we're manually writing the `Version3` format ourselves.\n-  RawRustStringOstream OS(BufferOut);\n-  encodeULEB128(FilenamesLen, OS);\n+  SmallVector<StringRef,32> FilenameRefs;\n   for (size_t i = 0; i < FilenamesLen; i++) {\n-    StringRef Filename(Filenames[i]);\n-    encodeULEB128(Filename.size(), OS);\n-    OS << Filename;\n+    FilenameRefs.push_back(StringRef(Filenames[i]));\n   }\n+  auto FilenamesWriter = coverage::CoverageFilenamesSectionWriter(\n+    makeArrayRef(FilenameRefs));\n+  RawRustStringOstream OS(BufferOut);\n+  FilenamesWriter.write(OS);\n }\n \n extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n@@ -45,26 +43,43 @@ extern \"C\" LLVMValueRef LLVMRustCoverageCreatePGOFuncNameVar(LLVMValueRef F, con\n   return wrap(createPGOFuncNameVar(*cast<Function>(unwrap(F)), FuncNameRef));\n }\n \n-extern \"C\" uint64_t LLVMRustCoverageComputeHash(const char *Name) {\n-  StringRef NameRef(Name);\n-  return IndexedInstrProf::ComputeHash(NameRef);\n+extern \"C\" uint64_t LLVMRustCoverageHashCString(const char *StrVal) {\n+  StringRef StrRef(StrVal);\n+  return IndexedInstrProf::ComputeHash(StrRef);\n+}\n+\n+extern \"C\" uint64_t LLVMRustCoverageHashByteArray(\n+    const char *Bytes,\n+    unsigned NumBytes) {\n+  StringRef StrRef(Bytes, NumBytes);\n+  return IndexedInstrProf::ComputeHash(StrRef);\n }\n \n-extern \"C\" void LLVMRustCoverageWriteSectionNameToString(LLVMModuleRef M,\n-                                                         RustStringRef Str) {\n+static void WriteSectionNameToString(LLVMModuleRef M,\n+                                     InstrProfSectKind SK,\n+                                     RustStringRef Str) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n-  auto name = getInstrProfSectionName(IPSK_covmap,\n-                                      TargetTriple.getObjectFormat());\n+  auto name = getInstrProfSectionName(SK, TargetTriple.getObjectFormat());\n   RawRustStringOstream OS(Str);\n   OS << name;\n }\n \n+extern \"C\" void LLVMRustCoverageWriteMapSectionNameToString(LLVMModuleRef M,\n+                                                            RustStringRef Str) {\n+  WriteSectionNameToString(M, IPSK_covmap, Str);\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteFuncSectionNameToString(LLVMModuleRef M,\n+                                                             RustStringRef Str) {\n+  WriteSectionNameToString(M, IPSK_covfun, Str);\n+}\n+\n extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n   auto name = getCoverageMappingVarName();\n   RawRustStringOstream OS(Str);\n   OS << name;\n }\n \n extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n-  return coverage::CovMapVersion::Version3;\n+  return coverage::CovMapVersion::Version4;\n }"}, {"sha": "e17f933932e6a0649265ff6276619990aea15426", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -1462,7 +1462,7 @@ extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n                                   const char *Name, size_t NameLen) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n   GlobalObject *GV = unwrap<GlobalObject>(V);\n-  if (!TargetTriple.isOSBinFormatMachO()) {\n+  if (TargetTriple.supportsCOMDAT()) {\n     StringRef NameRef(Name, NameLen);\n     GV->setComdat(unwrap(M)->getOrInsertComdat(NameRef));\n   }"}, {"sha": "b1368bdb79365d22a4dd1b17b4574c807edb0bfa", "filename": "src/test/run-make-fulldeps/coverage-llvmir-base/Makefile", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -12,10 +12,12 @@ ifeq ($(UNAME),Darwin)\n \tINSTR_PROF_DATA_SUFFIX=,regular,live_support\n \tDATA_SECTION_PREFIX=__DATA,\n \tLLVM_COV_SECTION_PREFIX=__LLVM_COV,\n+\tCOMDAT_IF_SUPPORTED=\n else\n \tINSTR_PROF_DATA_SUFFIX=\n \tDATA_SECTION_PREFIX=\n \tLLVM_COV_SECTION_PREFIX=\n+\tCOMDAT_IF_SUPPORTED=, comdat\n endif\n \n ifeq ($(LINK_DEAD_CODE),yes)\n@@ -29,24 +31,28 @@ ifdef IS_WINDOWS\n \t\t-check-prefixes=CHECK,WINDOWS \\\n \t\t-DPRIVATE_GLOBAL='internal global' \\\n \t\t-DDEFINE_INTERNAL='$(DEFINE_INTERNAL)' \\\n+\t\t-DCOMDAT_IF_SUPPORTED='$(COMDAT_IF_SUPPORTED)' \\\n \t\t-DINSTR_PROF_DATA='.lprfd$$M' \\\n \t\t-DINSTR_PROF_NAME='.lprfn$$M' \\\n \t\t-DINSTR_PROF_CNTS='.lprfc$$M' \\\n \t\t-DINSTR_PROF_VALS='.lprfv$$M' \\\n \t\t-DINSTR_PROF_VNODES='.lprfnd$$M' \\\n \t\t-DINSTR_PROF_COVMAP='.lcovmap$$M' \\\n+\t\t-DINSTR_PROF_COVFUN='.lcovfun$$M' \\\n \t\t-DINSTR_PROF_ORDERFILE='.lorderfile$$M'\n else\n \tLLVM_FILECHECK_OPTIONS=\\\n \t\t-check-prefixes=CHECK \\\n \t\t-DPRIVATE_GLOBAL='private global' \\\n \t\t-DDEFINE_INTERNAL='$(DEFINE_INTERNAL)' \\\n+\t\t-DCOMDAT_IF_SUPPORTED='$(COMDAT_IF_SUPPORTED)' \\\n \t\t-DINSTR_PROF_DATA='$(DATA_SECTION_PREFIX)__llvm_prf_data$(INSTR_PROF_DATA_SUFFIX)' \\\n \t\t-DINSTR_PROF_NAME='$(DATA_SECTION_PREFIX)__llvm_prf_names' \\\n \t\t-DINSTR_PROF_CNTS='$(DATA_SECTION_PREFIX)__llvm_prf_cnts' \\\n \t\t-DINSTR_PROF_VALS='$(DATA_SECTION_PREFIX)__llvm_prf_vals' \\\n \t\t-DINSTR_PROF_VNODES='$(DATA_SECTION_PREFIX)__llvm_prf_vnds' \\\n \t\t-DINSTR_PROF_COVMAP='$(LLVM_COV_SECTION_PREFIX)__llvm_covmap' \\\n+\t\t-DINSTR_PROF_COVFUN='$(LLVM_COV_SECTION_PREFIX)__llvm_covfun' \\\n \t\t-DINSTR_PROF_ORDERFILE='$(DATA_SECTION_PREFIX)__llvm_orderfile'\n endif\n "}, {"sha": "a312ec48e8498fb3bf8aa58907705c68942ae3fb", "filename": "src/test/run-make-fulldeps/coverage-llvmir-base/filecheck.testprog.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d8c381c014f202eeae59994b9b664841e91cb72/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1d8c381c014f202eeae59994b9b664841e91cb72/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt?ref=1d8c381c014f202eeae59994b9b664841e91cb72", "patch": "@@ -3,7 +3,10 @@\n \n WINDOWS:      $__llvm_profile_runtime_user = comdat any\n \n-CHECK:        @__llvm_coverage_mapping = internal constant\n+CHECK:        @__covrec_{{[A-F0-9]+}}u = linkonce_odr hidden constant\n+CHECK-SAME:   section \"[[INSTR_PROF_COVFUN]]\"[[COMDAT_IF_SUPPORTED]], align 8\n+\n+CHECK:        @__llvm_coverage_mapping = private constant\n CHECK-SAME:   section \"[[INSTR_PROF_COVMAP]]\", align 8\n \n WINDOWS:      @__llvm_profile_runtime = external global i32"}]}