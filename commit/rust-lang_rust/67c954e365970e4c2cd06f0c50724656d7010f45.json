{"sha": "67c954e365970e4c2cd06f0c50724656d7010f45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3Yzk1NGUzNjU5NzBlNGMyY2QwNmYwYzUwNzI0NjU2ZDcwMTBmNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T16:42:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T16:42:00Z"}, "message": "auto merge of #8566 : toddaaro/rust/idle-opt+cleaning, r=catamorphism,brson\n\nInstead of a furious storm of idle callbacks we just have one. This is a major performance gain - around 40% on my machine for the ping pong bench.\r\n\r\nAlso in this PR is a cleanup commit for the scheduler code. Was previously up as a separate PR, but bors load + imminent merge hell led me to roll them together. Was #8549.", "tree": {"sha": "d3b73e89a241ab0210e53d80b1846394139bf693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3b73e89a241ab0210e53d80b1846394139bf693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67c954e365970e4c2cd06f0c50724656d7010f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67c954e365970e4c2cd06f0c50724656d7010f45", "html_url": "https://github.com/rust-lang/rust/commit/67c954e365970e4c2cd06f0c50724656d7010f45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67c954e365970e4c2cd06f0c50724656d7010f45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f268128954fef84dcbcb7c9fe77e2a107e0bf69", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f268128954fef84dcbcb7c9fe77e2a107e0bf69", "html_url": "https://github.com/rust-lang/rust/commit/7f268128954fef84dcbcb7c9fe77e2a107e0bf69"}, {"sha": "e5ccf13668ed7b66d6efd9a1a03926e98546705d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5ccf13668ed7b66d6efd9a1a03926e98546705d", "html_url": "https://github.com/rust-lang/rust/commit/e5ccf13668ed7b66d6efd9a1a03926e98546705d"}], "stats": {"total": 688, "additions": 386, "deletions": 302}, "files": [{"sha": "e29c30ba0334ae2c92c2e47f1f9678679345c15e", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=67c954e365970e4c2cd06f0c50724656d7010f45", "patch": "@@ -24,22 +24,25 @@ pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n+pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n \n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n+    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n     fn callback_ms(&mut self, ms: u64, ~fn());\n     fn remote_callback(&mut self, ~fn()) -> ~RemoteCallbackObject;\n     /// The asynchronous I/O services. Not all event loops may provide one\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n \n pub trait RemoteCallback {\n-    /// Trigger the remote callback. Note that the number of times the callback\n-    /// is run is not guaranteed. All that is guaranteed is that, after calling 'fire',\n-    /// the callback will be called at least once, but multiple callbacks may be coalesced\n-    /// and callbacks may be called more often requested. Destruction also triggers the\n-    /// callback.\n+    /// Trigger the remote callback. Note that the number of times the\n+    /// callback is run is not guaranteed. All that is guaranteed is\n+    /// that, after calling 'fire', the callback will be called at\n+    /// least once, but multiple callbacks may be coalesced and\n+    /// callbacks may be called more often requested. Destruction also\n+    /// triggers the callback.\n     fn fire(&mut self);\n }\n "}, {"sha": "3f7f2b5d6533d3ff946a8355e1dd612573248d8c", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 280, "deletions": 287, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=67c954e365970e4c2cd06f0c50724656d7010f45", "patch": "@@ -23,18 +23,19 @@ use super::message_queue::MessageQueue;\n use rt::kill::BlockedTask;\n use rt::local_ptr;\n use rt::local::Local;\n-use rt::rtio::RemoteCallback;\n+use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n use rt::metrics::SchedMetrics;\n use borrow::{to_uint};\n use cell::Cell;\n use rand::{XorShiftRng, RngUtil};\n use iterator::{range};\n use vec::{OwnedVector};\n \n-/// The Scheduler is responsible for coordinating execution of Coroutines\n-/// on a single thread. When the scheduler is running it is owned by\n-/// thread local storage and the running task is owned by the\n-/// scheduler.\n+/// A scheduler is responsible for coordinating the execution of Tasks\n+/// on a single thread. The scheduler runs inside a slightly modified\n+/// Rust Task. When not running this task is stored in the scheduler\n+/// struct. The scheduler struct acts like a baton, all scheduling\n+/// actions are transfers of the baton.\n ///\n /// XXX: This creates too many callbacks to run_sched_once, resulting\n /// in too much allocation and too many events.\n@@ -64,43 +65,27 @@ pub struct Scheduler {\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n     event_loop: ~EventLoopObject,\n-    /// The scheduler runs on a special task.\n+    /// The scheduler runs on a special task. When it is not running\n+    /// it is stored here instead of the work queue.\n     sched_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n-    priv cleanup_job: Option<CleanupJob>,\n+    cleanup_job: Option<CleanupJob>,\n     metrics: SchedMetrics,\n     /// Should this scheduler run any task, or only pinned tasks?\n     run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n     /// them to.\n     friend_handle: Option<SchedHandle>,\n     /// A fast XorShift rng for scheduler use\n-    rng: XorShiftRng\n-\n-}\n-\n-pub struct SchedHandle {\n-    priv remote: ~RemoteCallbackObject,\n-    priv queue: MessageQueue<SchedMessage>,\n-    sched_id: uint\n-}\n-\n-pub enum SchedMessage {\n-    Wake,\n-    Shutdown,\n-    PinnedTask(~Task),\n-    TaskFromFriend(~Task)\n-}\n-\n-enum CleanupJob {\n-    DoNothing,\n-    GiveTask(~Task, UnsafeTaskReceiver)\n+    rng: XorShiftRng,\n+    /// A toggleable idle callback\n+    idle_callback: ~PausibleIdleCallback\n }\n \n impl Scheduler {\n \n-    pub fn sched_id(&self) -> uint { to_uint(self) }\n+    // * Initialization Functions\n \n     pub fn new(event_loop: ~EventLoopObject,\n                work_queue: WorkQueue<~Task>,\n@@ -114,8 +99,6 @@ impl Scheduler {\n \n     }\n \n-    // When you create a scheduler it isn't yet \"in\" a task, so the\n-    // task field is None.\n     pub fn new_special(event_loop: ~EventLoopObject,\n                        work_queue: WorkQueue<~Task>,\n                        work_queues: ~[WorkQueue<~Task>],\n@@ -124,6 +107,9 @@ impl Scheduler {\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n+        let mut event_loop = event_loop;\n+        let idle_callback = event_loop.pausible_idle_callback();\n+\n         Scheduler {\n             sleeper_list: sleeper_list,\n             message_queue: MessageQueue::new(),\n@@ -138,7 +124,8 @@ impl Scheduler {\n             metrics: SchedMetrics::new(),\n             run_anything: run_anything,\n             friend_handle: friend,\n-            rng: XorShiftRng::new()\n+            rng: XorShiftRng::new(),\n+            idle_callback: idle_callback\n         }\n     }\n \n@@ -151,6 +138,8 @@ impl Scheduler {\n     // scheduler task and bootstrap into it.\n     pub fn bootstrap(~self, task: ~Task) {\n \n+        let mut this = self;\n+\n         // Initialize the TLS key.\n         local_ptr::init_tls_key();\n \n@@ -161,10 +150,15 @@ impl Scheduler {\n         // task, put it in TLS.\n         Local::put::(sched_task);\n \n+        // Before starting our first task, make sure the idle callback\n+        // is active. As we do not start in the sleep state this is\n+        // important.\n+        this.idle_callback.start(Scheduler::run_sched_once);\n+\n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n         // scheduler and resume the provided task.\n-        self.resume_task_immediately(task);\n+        this.resume_task_immediately(task);\n \n         // Now we are back in the scheduler context, having\n         // successfully run the input task. Start by running the\n@@ -173,7 +167,6 @@ impl Scheduler {\n         let sched = Local::take::<Scheduler>();\n \n         rtdebug!(\"starting scheduler %u\", sched.sched_id());\n-\n         sched.run();\n \n         // Now that we are done with the scheduler, clean up the\n@@ -189,6 +182,9 @@ impl Scheduler {\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n         assert!(message.is_none());\n \n+        // Close the idle callback.\n+        stask.sched.get_mut_ref().idle_callback.close();\n+\n         stask.destroyed = true;\n     }\n \n@@ -198,11 +194,6 @@ impl Scheduler {\n \n         let mut self_sched = self;\n \n-        // Always run through the scheduler loop at least once so that\n-        // we enter the sleep state and can then be woken up by other\n-        // schedulers.\n-        self_sched.event_loop.callback(Scheduler::run_sched_once);\n-\n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n         // mutable reference to the event_loop to give it the \"run\"\n@@ -221,11 +212,11 @@ impl Scheduler {\n         }\n     }\n \n-    // One iteration of the scheduler loop, always run at least once.\n+    // * Execution Functions - Core Loop Logic\n \n     // The model for this function is that you continue through it\n     // until you either use the scheduler while performing a schedule\n-    // action, in which case you give it away and do not return, or\n+    // action, in which case you give it away and return early, or\n     // you reach the end and sleep. In the case that a scheduler\n     // action is performed the loop is evented such that this function\n     // is called again.\n@@ -235,41 +226,24 @@ impl Scheduler {\n         // already have a scheduler stored in our local task, so we\n         // start off by taking it. This is the only path through the\n         // scheduler where we get the scheduler this way.\n-        let sched = Local::take::<Scheduler>();\n+        let mut sched = Local::take::<Scheduler>();\n \n-        // Our first task is to read mail to see if we have important\n-        // messages.\n-\n-        // 1) A wake message is easy, mutate sched struct and return\n-        //    it.\n-        // 2) A shutdown is also easy, shutdown.\n-        // 3) A pinned task - we resume immediately and do not return\n-        //    here.\n-        // 4) A message from another scheduler with a non-homed task\n-        //    to run here.\n-\n-        let result = sched.interpret_message_queue();\n-        let sched = match result {\n-            Some(sched) => {\n-                // We did not resume a task, so we returned.\n-                sched\n-            }\n-            None => {\n-                return;\n-            }\n-        };\n+        // Assume that we need to continue idling unless we reach the\n+        // end of this function without performing an action.\n+        sched.idle_callback.resume();\n \n-        // Second activity is to try resuming a task from the queue.\n+        // First we check for scheduler messages, these are higher\n+        // priority than regular tasks.\n+        let sched = match sched.interpret_message_queue() {\n+            Some(sched) => sched,\n+            None => return\n+        };\n \n-        let result = sched.do_work();\n-        let mut sched = match result {\n-            Some(sched) => {\n-                // Failed to dequeue a task, so we return.\n-                sched\n-            }\n-            None => {\n-                return;\n-            }\n+        // This helper will use a randomized work-stealing algorithm\n+        // to find work.\n+        let mut sched = match sched.do_work() {\n+            Some(sched) => sched,\n+            None => return\n         };\n \n         // If we got here then there was no work to do.\n@@ -282,94 +256,47 @@ impl Scheduler {\n             sched.sleepy = true;\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n+            // Since we are sleeping, deactivate the idle callback.\n+            sched.idle_callback.pause();\n         } else {\n             rtdebug!(\"not sleeping, already doing so or no_sleep set\");\n+            // We may not be sleeping, but we still need to deactivate\n+            // the idle callback.\n+            sched.idle_callback.pause();\n         }\n \n         // Finished a cycle without using the Scheduler. Place it back\n         // in TLS.\n         Local::put(sched);\n     }\n \n-    pub fn make_handle(&mut self) -> SchedHandle {\n-        let remote = self.event_loop.remote_callback(Scheduler::run_sched_once);\n-\n-        return SchedHandle {\n-            remote: remote,\n-            queue: self.message_queue.clone(),\n-            sched_id: self.sched_id()\n-        };\n-    }\n-\n-    /// Schedule a task to be executed later.\n-    ///\n-    /// Pushes the task onto the work stealing queue and tells the\n-    /// event loop to run it later. Always use this instead of pushing\n-    /// to the work queue directly.\n-    pub fn enqueue_task(&mut self, task: ~Task) {\n-\n-        let this = self;\n-\n-        // We push the task onto our local queue clone.\n-        this.work_queue.push(task);\n-        this.event_loop.callback(Scheduler::run_sched_once);\n-\n-        // We've made work available. Notify a\n-        // sleeping scheduler.\n-\n-        // XXX: perf. Check for a sleeper without\n-        // synchronizing memory.  It's not critical\n-        // that we always find it.\n-\n-        // XXX: perf. If there's a sleeper then we\n-        // might as well just send it the task\n-        // directly instead of pushing it to the\n-        // queue. That is essentially the intent here\n-        // and it is less work.\n-        match this.sleeper_list.pop() {\n-            Some(handle) => {\n-                let mut handle = handle;\n-                handle.send(Wake)\n-            }\n-            None => { (/* pass */) }\n-        };\n-    }\n-\n-    /// As enqueue_task, but with the possibility for the blocked task to\n-    /// already have been killed.\n-    pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n-        do blocked_task.wake().map_move |task| {\n-            self.enqueue_task(task);\n-        };\n-    }\n-\n-    // * Scheduler-context operations\n-\n     // This function returns None if the scheduler is \"used\", or it\n-    // returns the still-available scheduler.\n+    // returns the still-available scheduler. At this point all\n+    // message-handling will count as a turn of work, and as a result\n+    // return None.\n     fn interpret_message_queue(~self) -> Option<~Scheduler> {\n \n         let mut this = self;\n         match this.message_queue.pop() {\n             Some(PinnedTask(task)) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n                 let mut task = task;\n                 task.give_home(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                return this.sched_schedule_task(task);\n+                this.process_task(task,\n+                                  Scheduler::resume_task_immediately_cl).map_move(Local::put);\n+                return None;\n             }\n             Some(Wake) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n                 this.sleepy = false;\n-                return Some(this);\n+                Local::put(this);\n+                return None;\n             }\n             Some(Shutdown) => {\n-                this.event_loop.callback(Scheduler::run_sched_once);\n+                rtdebug!(\"shutting down\");\n                 if this.sleepy {\n                     // There may be an outstanding handle on the\n                     // sleeper list.  Pop them all to make sure that's\n@@ -388,42 +315,28 @@ impl Scheduler {\n                 // event loop references we will shut down.\n                 this.no_sleep = true;\n                 this.sleepy = false;\n-                // YYY: Does a shutdown count as a \"use\" of the\n-                // scheduler? This seems to work - so I'm leaving it\n-                // this way despite not having a solid rational for\n-                // why I should return the scheduler here.\n-                return Some(this);\n+                Local::put(this);\n+                return None;\n             }\n             None => {\n                 return Some(this);\n             }\n         }\n     }\n \n-    /// Given an input Coroutine sends it back to its home scheduler.\n-    fn send_task_home(task: ~Task) {\n-        let mut task = task;\n-        let mut home = task.take_unwrap_home();\n-        match home {\n-            Sched(ref mut home_handle) => {\n-                home_handle.send(PinnedTask(task));\n-            }\n-            AnySched => {\n-                rtabort!(\"error: cannot send anysched task home\");\n-            }\n-        }\n-    }\n+    fn do_work(~self) -> Option<~Scheduler> {\n+        let mut this = self;\n \n-    /// Take a non-homed task we aren't allowed to run here and send\n-    /// it to the designated friend scheduler to execute.\n-    fn send_to_friend(&mut self, task: ~Task) {\n-        rtdebug!(\"sending a task to friend\");\n-        match self.friend_handle {\n-            Some(ref mut handle) => {\n-                handle.send(TaskFromFriend(task));\n+        rtdebug!(\"scheduler calling do work\");\n+        match this.find_work() {\n+            Some(task) => {\n+                rtdebug!(\"found some work! processing the task\");\n+                return this.process_task(task,\n+                                         Scheduler::resume_task_immediately_cl);\n             }\n             None => {\n-                rtabort!(\"tried to send task to a friend but scheduler has no friends\");\n+                rtdebug!(\"no work was found, returning the scheduler struct\");\n+                return Some(this);\n             }\n         }\n     }\n@@ -447,8 +360,8 @@ impl Scheduler {\n             None => {\n                 // Our naive stealing, try kinda hard.\n                 rtdebug!(\"scheduler trying to steal\");\n-                let _len = self.work_queues.len();\n-                return self.try_steals(2);\n+                let len = self.work_queues.len();\n+                return self.try_steals(len/2);\n             }\n         }\n     }\n@@ -462,7 +375,8 @@ impl Scheduler {\n             let work_queues = &mut self.work_queues;\n             match work_queues[index].steal() {\n                 Some(task) => {\n-                    rtdebug!(\"found task by stealing\"); return Some(task)\n+                    rtdebug!(\"found task by stealing\");\n+                    return Some(task)\n                 }\n                 None => ()\n             }\n@@ -471,8 +385,11 @@ impl Scheduler {\n         return None;\n     }\n \n-    // Given a task, execute it correctly.\n-    fn process_task(~self, task: ~Task) -> Option<~Scheduler> {\n+    // * Task Routing Functions - Make sure tasks send up in the right\n+    // place.\n+\n+    fn process_task(~self, task: ~Task,\n+                    schedule_fn: SchedulingFn) -> Option<~Scheduler> {\n         let mut this = self;\n         let mut task = task;\n \n@@ -489,15 +406,13 @@ impl Scheduler {\n                 } else {\n                     rtdebug!(\"running task here\");\n                     task.give_home(Sched(home_handle));\n-                    this.resume_task_immediately(task);\n-                    return None;\n+                    return schedule_fn(this, task);\n                 }\n             }\n             AnySched if this.run_anything => {\n                 rtdebug!(\"running anysched task here\");\n                 task.give_home(AnySched);\n-                this.resume_task_immediately(task);\n-                return None;\n+                return schedule_fn(this, task);\n             }\n             AnySched => {\n                 rtdebug!(\"sending task to friend\");\n@@ -508,98 +423,71 @@ impl Scheduler {\n         }\n     }\n \n-    // Bundle the helpers together.\n-    fn do_work(~self) -> Option<~Scheduler> {\n-        let mut this = self;\n-\n-        rtdebug!(\"scheduler calling do work\");\n-        match this.find_work() {\n-            Some(task) => {\n-                rtdebug!(\"found some work! processing the task\");\n-                return this.process_task(task);\n+    fn send_task_home(task: ~Task) {\n+        let mut task = task;\n+        let mut home = task.take_unwrap_home();\n+        match home {\n+            Sched(ref mut home_handle) => {\n+                home_handle.send(PinnedTask(task));\n             }\n-            None => {\n-                rtdebug!(\"no work was found, returning the scheduler struct\");\n-                return Some(this);\n+            AnySched => {\n+                        rtabort!(\"error: cannot send anysched task home\");\n             }\n         }\n     }\n \n-    /// Called by a running task to end execution, after which it will\n-    /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(~self) {\n-        // Similar to deschedule running task and then, but cannot go through\n-        // the task-blocking path. The task is already dying.\n-        let mut this = self;\n-        let stask = this.sched_task.take_unwrap();\n-        do this.change_task_context(stask) |sched, mut dead_task| {\n-            let coroutine = dead_task.coroutine.take_unwrap();\n-            coroutine.recycle(&mut sched.stack_pool);\n+    /// Take a non-homed task we aren't allowed to run here and send\n+    /// it to the designated friend scheduler to execute.\n+    fn send_to_friend(&mut self, task: ~Task) {\n+        rtdebug!(\"sending a task to friend\");\n+        match self.friend_handle {\n+            Some(ref mut handle) => {\n+                handle.send(TaskFromFriend(task));\n+            }\n+            None => {\n+                rtabort!(\"tried to send task to a friend but scheduler has no friends\");\n+            }\n         }\n     }\n \n-    // Scheduling a task requires a few checks to make sure the task\n-    // ends up in the appropriate location. The run_anything flag on\n-    // the scheduler and the home on the task need to be checked. This\n-    // helper performs that check. It takes a function that specifies\n-    // how to queue the the provided task if that is the correct\n-    // action. This is a \"core\" function that requires handling the\n-    // returned Option correctly.\n-\n-    pub fn schedule_task(~self, task: ~Task,\n-                         schedule_fn: ~fn(sched: ~Scheduler, task: ~Task))\n-        -> Option<~Scheduler> {\n-\n-        // is the task home?\n-        let is_home = task.is_home_no_tls(&self);\n+    /// Schedule a task to be executed later.\n+    ///\n+    /// Pushes the task onto the work stealing queue and tells the\n+    /// event loop to run it later. Always use this instead of pushing\n+    /// to the work queue directly.\n+    pub fn enqueue_task(&mut self, task: ~Task) {\n \n-        // does the task have a home?\n-        let homed = task.homed();\n+        let this = self;\n \n-        let mut this = self;\n+        // We push the task onto our local queue clone.\n+        this.work_queue.push(task);\n+        this.idle_callback.resume();\n \n-        if is_home || (!homed && this.run_anything) {\n-            // here we know we are home, execute now OR we know we\n-            // aren't homed, and that this sched doesn't care\n-            rtdebug!(\"task: %u is on ok sched, executing\", to_uint(task));\n-            schedule_fn(this, task);\n-            return None;\n-        } else if !homed && !this.run_anything {\n-            // the task isn't homed, but it can't be run here\n-            this.send_to_friend(task);\n-            return Some(this);\n-        } else {\n-            // task isn't home, so don't run it here, send it home\n-            Scheduler::send_task_home(task);\n-            return Some(this);\n-        }\n-    }\n+        // We've made work available. Notify a\n+        // sleeping scheduler.\n \n-    // There are two contexts in which schedule_task can be called:\n-    // inside the scheduler, and inside a task. These contexts handle\n-    // executing the task slightly differently. In the scheduler\n-    // context case we want to receive the scheduler as an input, and\n-    // manually deal with the option. In the task context case we want\n-    // to use TLS to find the scheduler, and deal with the option\n-    // inside the helper.\n-\n-    pub fn sched_schedule_task(~self, task: ~Task) -> Option<~Scheduler> {\n-        do self.schedule_task(task) |sched, next_task| {\n-            sched.resume_task_immediately(next_task);\n-        }\n+        // XXX: perf. Check for a sleeper without\n+        // synchronizing memory.  It's not critical\n+        // that we always find it.\n+        match this.sleeper_list.pop() {\n+            Some(handle) => {\n+                        let mut handle = handle;\n+                handle.send(Wake)\n+            }\n+            None => { (/* pass */) }\n+        };\n     }\n \n-    // Task context case - use TLS.\n-    pub fn run_task(task: ~Task) {\n-        let sched = Local::take::<Scheduler>();\n-        let opt = do sched.schedule_task(task) |sched, next_task| {\n-            do sched.switch_running_tasks_and_then(next_task) |sched, last_task| {\n-                sched.enqueue_blocked_task(last_task);\n-            }\n+    /// As enqueue_task, but with the possibility for the blocked task to\n+    /// already have been killed.\n+    pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n+        do blocked_task.wake().map_move |task| {\n+            self.enqueue_task(task);\n         };\n-        opt.map_move(Local::put);\n     }\n \n+    // * Core Context Switching Functions\n+\n     // The primary function for changing contexts. In the current\n     // design the scheduler is just a slightly modified GreenTask, so\n     // all context swaps are from Task to Task. The only difference\n@@ -629,7 +517,7 @@ impl Scheduler {\n \n         // The current task is placed inside an enum with the cleanup\n         // function. This enum is then placed inside the scheduler.\n-        this.enqueue_cleanup_job(GiveTask(current_task, f_opaque));\n+        this.cleanup_job = Some(CleanupJob::new(current_task, f_opaque));\n \n         // The scheduler is then placed inside the next task.\n         let mut next_task = next_task;\n@@ -645,12 +533,9 @@ impl Scheduler {\n                 transmute_mut_region(*next_task.sched.get_mut_ref());\n \n             let current_task: &mut Task = match sched.cleanup_job {\n-                Some(GiveTask(ref task, _)) => {\n+                Some(CleanupJob { task: ref task, _ }) => {\n                     transmute_mut_region(*transmute_mut_unsafe(task))\n                 }\n-                Some(DoNothing) => {\n-                    rtabort!(\"no next task\");\n-                }\n                 None => {\n                     rtabort!(\"no cleanup job\");\n                 }\n@@ -684,19 +569,42 @@ impl Scheduler {\n         }\n     }\n \n-    // Old API for task manipulation implemented over the new core\n-    // function.\n+    // Returns a mutable reference to both contexts involved in this\n+    // swap. This is unsafe - we are getting mutable internal\n+    // references to keep even when we don't own the tasks. It looks\n+    // kinda safe because we are doing transmutes before passing in\n+    // the arguments.\n+    pub fn get_contexts<'a>(current_task: &mut Task, next_task: &mut Task) ->\n+        (&'a mut Context, &'a mut Context) {\n+        let current_task_context =\n+            &mut current_task.coroutine.get_mut_ref().saved_context;\n+        let next_task_context =\n+                &mut next_task.coroutine.get_mut_ref().saved_context;\n+        unsafe {\n+            (transmute_mut_region(current_task_context),\n+             transmute_mut_region(next_task_context))\n+        }\n+    }\n+\n+    // * Context Swapping Helpers - Here be ugliness!\n \n-    pub fn resume_task_immediately(~self, task: ~Task) {\n+    pub fn resume_task_immediately(~self, task: ~Task) -> Option<~Scheduler> {\n         do self.change_task_context(task) |sched, stask| {\n             sched.sched_task = Some(stask);\n         }\n+        return None;\n     }\n \n+    fn resume_task_immediately_cl(sched: ~Scheduler,\n+                                  task: ~Task) -> Option<~Scheduler> {\n+        sched.resume_task_immediately(task)\n+    }\n+\n+\n     pub fn resume_blocked_task_immediately(~self, blocked_task: BlockedTask) {\n         match blocked_task.wake() {\n-            Some(task) => self.resume_task_immediately(task),\n-            None => Local::put(self),\n+            Some(task) => { self.resume_task_immediately(task); }\n+            None => Local::put(self)\n         };\n     }\n \n@@ -735,54 +643,75 @@ impl Scheduler {\n         }\n     }\n \n-    // A helper that looks up the scheduler and runs a task later by\n-    // enqueuing it.\n+    fn switch_task(sched: ~Scheduler, task: ~Task) -> Option<~Scheduler> {\n+        do sched.switch_running_tasks_and_then(task) |sched, last_task| {\n+            sched.enqueue_blocked_task(last_task);\n+        };\n+        return None;\n+    }\n+\n+    // * Task Context Helpers\n+\n+    /// Called by a running task to end execution, after which it will\n+    /// be recycled by the scheduler for reuse in a new task.\n+    pub fn terminate_current_task(~self) {\n+        // Similar to deschedule running task and then, but cannot go through\n+        // the task-blocking path. The task is already dying.\n+        let mut this = self;\n+        let stask = this.sched_task.take_unwrap();\n+        do this.change_task_context(stask) |sched, mut dead_task| {\n+            let coroutine = dead_task.coroutine.take_unwrap();\n+            coroutine.recycle(&mut sched.stack_pool);\n+        }\n+    }\n+\n+    pub fn run_task(task: ~Task) {\n+        let sched = Local::take::<Scheduler>();\n+        sched.process_task(task, Scheduler::switch_task).map_move(Local::put);\n+    }\n+\n     pub fn run_task_later(next_task: ~Task) {\n-        // We aren't performing a scheduler operation, so we want to\n-        // put the Scheduler back when we finish.\n         let next_task = Cell::new(next_task);\n         do Local::borrow::<Scheduler,()> |sched| {\n             sched.enqueue_task(next_task.take());\n         };\n     }\n \n-    // Returns a mutable reference to both contexts involved in this\n-    // swap. This is unsafe - we are getting mutable internal\n-    // references to keep even when we don't own the tasks. It looks\n-    // kinda safe because we are doing transmutes before passing in\n-    // the arguments.\n-    pub fn get_contexts<'a>(current_task: &mut Task, next_task: &mut Task) ->\n-        (&'a mut Context, &'a mut Context) {\n-        let current_task_context =\n-            &mut current_task.coroutine.get_mut_ref().saved_context;\n-        let next_task_context =\n-            &mut next_task.coroutine.get_mut_ref().saved_context;\n-        unsafe {\n-            (transmute_mut_region(current_task_context),\n-             transmute_mut_region(next_task_context))\n-        }\n-    }\n+    // * Utility Functions\n \n-    pub fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n-        self.cleanup_job = Some(job);\n-    }\n+    pub fn sched_id(&self) -> uint { to_uint(self) }\n \n     pub fn run_cleanup_job(&mut self) {\n-        rtdebug!(\"running cleanup job\");\n         let cleanup_job = self.cleanup_job.take_unwrap();\n-        match cleanup_job {\n-            DoNothing => { }\n-            GiveTask(task, f) => f.to_fn()(self, task)\n-        }\n+        cleanup_job.run(self);\n+    }\n+\n+    pub fn make_handle(&mut self) -> SchedHandle {\n+        let remote = self.event_loop.remote_callback(Scheduler::run_sched_once);\n+\n+        return SchedHandle {\n+            remote: remote,\n+            queue: self.message_queue.clone(),\n+            sched_id: self.sched_id()\n+        };\n     }\n }\n \n-// The cases for the below function.\n-enum ResumeAction {\n-    SendHome,\n-    Requeue,\n-    ResumeNow,\n-    Homeless\n+// Supporting types\n+\n+type SchedulingFn = ~fn(~Scheduler, ~Task) -> Option<~Scheduler>;\n+\n+pub enum SchedMessage {\n+    Wake,\n+    Shutdown,\n+    PinnedTask(~Task),\n+    TaskFromFriend(~Task)\n+}\n+\n+pub struct SchedHandle {\n+    priv remote: ~RemoteCallbackObject,\n+    priv queue: MessageQueue<SchedMessage>,\n+    sched_id: uint\n }\n \n impl SchedHandle {\n@@ -792,6 +721,25 @@ impl SchedHandle {\n     }\n }\n \n+struct CleanupJob {\n+    task: ~Task,\n+    f: UnsafeTaskReceiver\n+}\n+\n+impl CleanupJob {\n+    pub fn new(task: ~Task, f: UnsafeTaskReceiver) -> CleanupJob {\n+        CleanupJob {\n+            task: task,\n+            f: f\n+        }\n+    }\n+\n+    pub fn run(self, sched: &mut Scheduler) {\n+        let CleanupJob { task: task, f: f } = self;\n+        f.to_fn()(sched, task)\n+    }\n+}\n+\n // XXX: Some hacks to put a &fn in Scheduler without borrowck\n // complaining\n type UnsafeTaskReceiver = raw::Closure;\n@@ -1098,6 +1046,51 @@ mod test {\n         }\n     }\n \n+    // A regression test that the final message is always handled.\n+    // Used to deadlock because Shutdown was never recvd.\n+    #[test]\n+    fn no_missed_messages() {\n+        use rt::work_queue::WorkQueue;\n+        use rt::sleeper_list::SleeperList;\n+        use rt::stack::StackPool;\n+        use rt::uv::uvio::UvEventLoop;\n+        use rt::sched::{Shutdown, TaskFromFriend};\n+        use util;\n+\n+        do run_in_bare_thread {\n+            do stress_factor().times {\n+                let sleepers = SleeperList::new();\n+                let queue = WorkQueue::new();\n+                let queues = ~[queue.clone()];\n+\n+                let mut sched = ~Scheduler::new(\n+                    ~UvEventLoop::new(),\n+                    queue,\n+                    queues.clone(),\n+                    sleepers.clone());\n+\n+                let mut handle = sched.make_handle();\n+\n+                let sched = Cell::new(sched);\n+\n+                let thread = do Thread::start {\n+                    let mut sched = sched.take();\n+                    let bootstrap_task = ~Task::new_root(&mut sched.stack_pool, None, ||());\n+                    sched.bootstrap(bootstrap_task);\n+                };\n+\n+                let mut stack_pool = StackPool::new();\n+                let task = ~Task::new_root(&mut stack_pool, None, ||());\n+                handle.send(TaskFromFriend(task));\n+\n+                handle.send(Shutdown);\n+                util::ignore(handle);\n+\n+                thread.join();\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn multithreading() {\n         use rt::comm::*;"}, {"sha": "3b8eb87f8af29983126040ed71bbf8a3ae4cbb55", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=67c954e365970e4c2cd06f0c50724656d7010f45", "patch": "@@ -370,7 +370,7 @@ impl Coroutine {\n \n                 // Again - might work while safe, or it might not.\n                 do Local::borrow::<Scheduler,()> |sched| {\n-                    (sched).run_cleanup_job();\n+                    sched.run_cleanup_job();\n                 }\n \n                 // To call the run method on a task we need a direct"}, {"sha": "1f29830aa04f364e076dc4caa474ebded19da0f4", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=67c954e365970e4c2cd06f0c50724656d7010f45", "patch": "@@ -66,8 +66,7 @@ pub fn default_sched_threads() -> uint {\n pub fn dumb_println(s: &str) {\n     use io::WriterUtil;\n     let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-    dbg.write_str(s);\n-    dbg.write_str(\"\\n\");\n+    dbg.write_str(s + \"\\n\");\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "a21146620ca823ec8643adfdb84c00f31a391b38", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=67c954e365970e4c2cd06f0c50724656d7010f45", "patch": "@@ -48,6 +48,20 @@ impl IdleWatcher {\n         }\n     }\n \n+    pub fn restart(&mut self) {\n+        unsafe {\n+            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let data = idle_watcher.get_watcher_data();\n+            let cb: &IdleCallback = data.idle_cb.get_ref();\n+            let status = status_to_maybe_uv_error(idle_watcher, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n     pub fn stop(&mut self) {\n         // NB: Not resetting the Rust idle_cb to None here because `stop` is\n         // likely called from *within* the idle callback, causing a use after"}, {"sha": "078dce4f0c86829e30dc4d038ba7c62394197a59", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 82, "deletions": 7, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c954e365970e4c2cd06f0c50724656d7010f45/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=67c954e365970e4c2cd06f0c50724656d7010f45", "patch": "@@ -117,6 +117,15 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n+    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n+        let idle_watcher = IdleWatcher::new(self.uvio.uv_loop());\n+        return ~UvPausibleIdleCallback {\n+            watcher: idle_watcher,\n+            idle_flag: false,\n+            closed: false\n+        };\n+    }\n+\n     fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n         let mut timer =  TimerWatcher::new(self.uvio.uv_loop());\n         do timer.start(ms, 0) |timer, status| {\n@@ -135,6 +144,44 @@ impl EventLoop for UvEventLoop {\n     }\n }\n \n+pub struct UvPausibleIdleCallback {\n+    watcher: IdleWatcher,\n+    idle_flag: bool,\n+    closed: bool\n+}\n+\n+impl UvPausibleIdleCallback {\n+    #[inline]\n+    pub fn start(&mut self, f: ~fn()) {\n+        do self.watcher.start |_idle_watcher, _status| {\n+            f();\n+        };\n+        self.idle_flag = true;\n+    }\n+    #[inline]\n+    pub fn pause(&mut self) {\n+        if self.idle_flag == true {\n+            self.watcher.stop();\n+            self.idle_flag = false;\n+        }\n+    }\n+    #[inline]\n+    pub fn resume(&mut self) {\n+        if self.idle_flag == false {\n+            self.watcher.restart();\n+            self.idle_flag = true;\n+        }\n+    }\n+    #[inline]\n+    pub fn close(&mut self) {\n+        self.pause();\n+        if !self.closed {\n+            self.closed = true;\n+            self.watcher.close(||());\n+        }\n+    }\n+}\n+\n #[test]\n fn test_callback_run_once() {\n     do run_in_bare_thread {\n@@ -163,14 +210,39 @@ impl UvRemoteCallback {\n         let exit_flag_clone = exit_flag.clone();\n         let async = do AsyncWatcher::new(loop_) |watcher, status| {\n             assert!(status.is_none());\n+\n+            // The synchronization logic here is subtle. To review,\n+            // the uv async handle type promises that, after it is\n+            // triggered the remote callback is definitely called at\n+            // least once. UvRemoteCallback needs to maintain those\n+            // semantics while also shutting down cleanly from the\n+            // dtor. In our case that means that, when the\n+            // UvRemoteCallback dtor calls `async.send()`, here `f` is\n+            // always called later.\n+\n+            // In the dtor both the exit flag is set and the async\n+            // callback fired under a lock.  Here, before calling `f`,\n+            // we take the lock and check the flag. Because we are\n+            // checking the flag before calling `f`, and the flag is\n+            // set under the same lock as the send, then if the flag\n+            // is set then we're guaranteed to call `f` after the\n+            // final send.\n+\n+            // If the check was done after `f()` then there would be a\n+            // period between that call and the check where the dtor\n+            // could be called in the other thread, missing the final\n+            // callback while still destroying the handle.\n+\n+            let should_exit = unsafe {\n+                exit_flag_clone.with_imm(|&should_exit| should_exit)\n+            };\n+\n             f();\n-            unsafe {\n-                do exit_flag_clone.with_imm |&should_exit| {\n-                    if should_exit {\n-                        watcher.close(||());\n-                    }\n-                }\n+\n+            if should_exit {\n+                watcher.close(||());\n             }\n+\n         };\n         UvRemoteCallback {\n             async: async,\n@@ -219,7 +291,10 @@ mod test_remote {\n                 let tube_clone = tube_clone.clone();\n                 let tube_clone_cell = Cell::new(tube_clone);\n                 let remote = do sched.event_loop.remote_callback {\n-                    tube_clone_cell.take().send(1);\n+                    // This could be called multiple times\n+                    if !tube_clone_cell.is_empty() {\n+                        tube_clone_cell.take().send(1);\n+                    }\n                 };\n                 remote_cell.put_back(remote);\n             }"}]}