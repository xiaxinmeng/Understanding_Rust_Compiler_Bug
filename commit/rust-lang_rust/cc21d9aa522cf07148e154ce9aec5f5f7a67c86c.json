{"sha": "cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "node_id": "C_kwDOAAsO6NoAKGNjMjFkOWFhNTIyY2YwNzE0OGUxNTRjZTlhZWM1ZjVmN2E2N2M4NmM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-31T04:42:54Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-31T11:53:31Z"}, "message": "Don't compute inlining status of mono items in advance.\n\nWe record inlining status for mono items in `MonoItems`, and then\ntransfer it to `InliningMap`, for later use in\n`InliningMap::with_inlining_candidates`.\n\nBut we can just compute inlining status directly in\n`InliningMap::with_inlining_candidates`, because the mono item is right\nthere. There's no need to compute it in advance.\n\nThis commit changes the code to do that, removing the need for\n`MonoItems` and `InliningMap::inlines`. This does result in more calls\nto `instantiation_mode` (one per static occurrence) but the performance\neffect is negligible.", "tree": {"sha": "da5d54bb9a9b61573086a780a19b96b75c22340c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da5d54bb9a9b61573086a780a19b96b75c22340c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "html_url": "https://github.com/rust-lang/rust/commit/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e29821ff85a2a3000d226f99f62f89464028d5d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e29821ff85a2a3000d226f99f62f89464028d5d6", "html_url": "https://github.com/rust-lang/rust/commit/e29821ff85a2a3000d226f99f62f89464028d5d6"}], "stats": {"total": 83, "additions": 17, "deletions": 66}, "files": [{"sha": "09025c1ee3319fe2f07d1fde2a1cb208da233db5", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 13, "deletions": 63, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "patch": "@@ -179,7 +179,6 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::mir::interpret::{AllocId, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n@@ -220,78 +219,29 @@ pub struct InliningMap<'tcx> {\n     // The range selects elements within the `targets` vecs.\n     index: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n     targets: Vec<MonoItem<'tcx>>,\n-\n-    // Contains one bit per mono item in the `targets` field. That bit\n-    // is true if that mono item needs to be inlined into every CGU.\n-    inlines: GrowableBitSet<usize>,\n-}\n-\n-/// Struct to store mono items in each collecting and if they should\n-/// be inlined. We call `instantiation_mode` to get their inlining\n-/// status when inserting new elements, which avoids calling it in\n-/// `inlining_map.lock_mut()`. See the `collect_items_rec` implementation\n-/// below.\n-struct MonoItems<'tcx> {\n-    // If this is false, we do not need to compute whether items\n-    // will need to be inlined.\n-    compute_inlining: bool,\n-\n-    // The TyCtxt used to determine whether the a item should\n-    // be inlined.\n-    tcx: TyCtxt<'tcx>,\n-\n-    // The collected mono items. The bool field in each element\n-    // indicates whether this element should be inlined.\n-    items: Vec<(Spanned<MonoItem<'tcx>>, bool /*inlined*/)>,\n }\n \n-impl<'tcx> MonoItems<'tcx> {\n-    #[inline]\n-    fn push(&mut self, item: Spanned<MonoItem<'tcx>>) {\n-        self.extend([item]);\n-    }\n-\n-    #[inline]\n-    fn extend<T: IntoIterator<Item = Spanned<MonoItem<'tcx>>>>(&mut self, iter: T) {\n-        self.items.extend(iter.into_iter().map(|mono_item| {\n-            let inlined = if !self.compute_inlining {\n-                false\n-            } else {\n-                mono_item.node.instantiation_mode(self.tcx) == InstantiationMode::LocalCopy\n-            };\n-            (mono_item, inlined)\n-        }))\n-    }\n-}\n+type MonoItems<'tcx> = Vec<Spanned<MonoItem<'tcx>>>;\n \n impl<'tcx> InliningMap<'tcx> {\n     fn new() -> InliningMap<'tcx> {\n-        InliningMap {\n-            index: FxHashMap::default(),\n-            targets: Vec::new(),\n-            inlines: GrowableBitSet::with_capacity(1024),\n-        }\n+        InliningMap { index: FxHashMap::default(), targets: Vec::new() }\n     }\n \n     fn record_accesses<'a>(\n         &mut self,\n         source: MonoItem<'tcx>,\n-        new_targets: &'a [(Spanned<MonoItem<'tcx>>, bool)],\n+        new_targets: &'a [Spanned<MonoItem<'tcx>>],\n     ) where\n         'tcx: 'a,\n     {\n         let start_index = self.targets.len();\n         let new_items_count = new_targets.len();\n-        let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n-        self.inlines.ensure(new_items_count_total);\n \n-        for (i, (Spanned { node: mono_item, .. }, inlined)) in new_targets.into_iter().enumerate() {\n+        for Spanned { node: mono_item, .. } in new_targets.into_iter() {\n             self.targets.push(*mono_item);\n-            if *inlined {\n-                self.inlines.insert(i + start_index);\n-            }\n         }\n \n         let end_index = self.targets.len();\n@@ -300,13 +250,14 @@ impl<'tcx> InliningMap<'tcx> {\n \n     /// Internally iterate over all items referenced by `source` which will be\n     /// made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n+    pub fn with_inlining_candidates<F>(&self, tcx: TyCtxt<'tcx>, source: MonoItem<'tcx>, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>),\n     {\n         if let Some(range) = self.index.get(&source) {\n-            for (i, candidate) in self.targets[range.clone()].iter().enumerate() {\n-                if self.inlines.contains(range.start + i) {\n+            for candidate in self.targets[range.clone()].iter() {\n+                let is_inlined = candidate.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n+                if is_inlined {\n                     f(*candidate);\n                 }\n             }\n@@ -367,7 +318,7 @@ pub fn collect_crate_mono_items(\n #[instrument(skip(tcx, mode), level = \"debug\")]\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"collecting roots\");\n-    let mut roots = MonoItems { compute_inlining: false, tcx, items: Vec::new() };\n+    let mut roots = Vec::new();\n \n     {\n         let entry_fn = tcx.entry_fn(());\n@@ -393,9 +344,8 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip codegenning them.\n     roots\n-        .items\n         .into_iter()\n-        .filter_map(|(Spanned { node: mono_item, .. }, _)| {\n+        .filter_map(|Spanned { node: mono_item, .. }| {\n             mono_item.is_instantiable(tcx).then_some(mono_item)\n         })\n         .collect()\n@@ -417,7 +367,7 @@ fn collect_items_rec<'tcx>(\n         return;\n     }\n \n-    let mut neighbors = MonoItems { compute_inlining: true, tcx, items: Vec::new() };\n+    let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     //\n@@ -542,9 +492,9 @@ fn collect_items_rec<'tcx>(\n             formatted_item,\n         });\n     }\n-    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);\n+    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors);\n \n-    for (neighbour, _) in neighbors.items {\n+    for neighbour in neighbors {\n         collect_items_rec(tcx, neighbour, visited, recursion_depths, recursion_limit, inlining_map);\n     }\n "}, {"sha": "0bacb58383dc09e6bf745f8b594f76792850ad5e", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "patch": "@@ -424,7 +424,7 @@ fn place_inlined_mono_items<'tcx>(\n         // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n         for root in old_codegen_unit.items().keys() {\n-            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+            follow_inlining(cx.tcx, *root, cx.inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -478,6 +478,7 @@ fn place_inlined_mono_items<'tcx>(\n     return mono_item_placements;\n \n     fn follow_inlining<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n         mono_item: MonoItem<'tcx>,\n         inlining_map: &InliningMap<'tcx>,\n         visited: &mut FxHashSet<MonoItem<'tcx>>,\n@@ -486,8 +487,8 @@ fn place_inlined_mono_items<'tcx>(\n             return;\n         }\n \n-        inlining_map.with_inlining_candidates(mono_item, |target| {\n-            follow_inlining(target, inlining_map, visited);\n+        inlining_map.with_inlining_candidates(tcx, mono_item, |target| {\n+            follow_inlining(tcx, target, inlining_map, visited);\n         });\n     }\n }"}]}