{"sha": "4895699e884e9a2b0be90324dcd869ba86c4a5ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4OTU2OTllODg0ZTlhMmIwYmU5MDMyNGRjZDg2OWJhODZjNGE1ZWY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-10-09T22:38:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-09T22:38:54Z"}, "message": "Merge pull request #3083 from scampi/itemized_blocks\n\nHandle itemized blocks in comments", "tree": {"sha": "be9024812489cca99f1ae3b157bd1ba5ba571d56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be9024812489cca99f1ae3b157bd1ba5ba571d56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4895699e884e9a2b0be90324dcd869ba86c4a5ef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbvS3+CRBK7hj4Ov3rIwAAdHIIADoAyoL5zEbNiBlliKOXcoz6\nzQ9QVlgSYOkbHqIjLroZ+QF/dJlNb2wFPe/gYQMQXMdt20NCoWKJ+7WjUCb3H61+\newRjqmucNRhVdFPTNxvWrHhnBdUzDaEvm91YX43s398mrL98CWyN3hvMirZdOWfL\nIhzmPgm9gWnrioULhM8D3vc/wUIN+y8lwWYnn1+TpkPKUIUJUGOMdx4xIhaJxVdo\nUsRwQlGAEk7+CVpin3KsVv9+52GsdhJb+8OPKRM20/4waQkQw7mpJxkGviWFMSa4\nHHpiYYAf0b+Wu2ei+BaxLgqRnGlp/YAv9upWtnprHU3G9AUYXI02Oq37wD/ss/k=\n=Cppv\n-----END PGP SIGNATURE-----\n", "payload": "tree be9024812489cca99f1ae3b157bd1ba5ba571d56\nparent 839c4946e260ae98b8400f3590d7266222cd6286\nparent 375c87820f97c03fec4ec1a23803b00df1b1d5dc\nauthor Nick Cameron <nrc@ncameron.org> 1539124734 +1200\ncommitter GitHub <noreply@github.com> 1539124734 +1200\n\nMerge pull request #3083 from scampi/itemized_blocks\n\nHandle itemized blocks in comments"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4895699e884e9a2b0be90324dcd869ba86c4a5ef", "html_url": "https://github.com/rust-lang/rust/commit/4895699e884e9a2b0be90324dcd869ba86c4a5ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4895699e884e9a2b0be90324dcd869ba86c4a5ef/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "839c4946e260ae98b8400f3590d7266222cd6286", "url": "https://api.github.com/repos/rust-lang/rust/commits/839c4946e260ae98b8400f3590d7266222cd6286", "html_url": "https://github.com/rust-lang/rust/commit/839c4946e260ae98b8400f3590d7266222cd6286"}, {"sha": "375c87820f97c03fec4ec1a23803b00df1b1d5dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/375c87820f97c03fec4ec1a23803b00df1b1d5dc", "html_url": "https://github.com/rust-lang/rust/commit/375c87820f97c03fec4ec1a23803b00df1b1d5dc"}], "stats": {"total": 914, "additions": 818, "deletions": 96}, "files": [{"sha": "41301527653132279f745f2c1eec9eba6e23a085", "filename": "src/comment.rs", "status": "modified", "additions": 134, "deletions": 41, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -433,6 +433,58 @@ impl CodeBlockAttribute {\n     }\n }\n \n+/// Block that is formatted as an item.\n+///\n+/// An item starts with either a star `*` or a dash `-`. Different level of indentation are\n+/// handled.\n+struct ItemizedBlock {\n+    /// the number of whitespaces up to the item sigil\n+    indent: usize,\n+    /// the string that marks the start of an item\n+    opener: String,\n+    /// sequence of whitespaces to prefix new lines that are part of the item\n+    line_start: String,\n+}\n+\n+impl ItemizedBlock {\n+    /// Returns true if the line is formatted as an item\n+    fn is_itemized_line(line: &str) -> bool {\n+        let trimmed = line.trim_left();\n+        trimmed.starts_with(\"* \") || trimmed.starts_with(\"- \")\n+    }\n+\n+    /// Creates a new ItemizedBlock described with the given line.\n+    /// The `is_itemized_line` needs to be called first.\n+    fn new(line: &str) -> ItemizedBlock {\n+        let space_to_sigil = line.chars().take_while(|c| c.is_whitespace()).count();\n+        let indent = space_to_sigil + 2;\n+        ItemizedBlock {\n+            indent,\n+            opener: line[..indent].to_string(),\n+            line_start: \" \".repeat(indent),\n+        }\n+    }\n+\n+    /// Returns a `StringFormat` used for formatting the content of an item\n+    fn create_string_format<'a>(&'a self, fmt: &'a StringFormat) -> StringFormat<'a> {\n+        StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"\",\n+            line_end: \"\",\n+            shape: Shape::legacy(fmt.shape.width.saturating_sub(self.indent), Indent::empty()),\n+            trim_end: true,\n+            config: fmt.config,\n+        }\n+    }\n+\n+    /// Returns true if the line is part of the current itemized block\n+    fn in_block(&self, line: &str) -> bool {\n+        !ItemizedBlock::is_itemized_line(line)\n+            && self.indent <= line.chars().take_while(|c| c.is_whitespace()).count()\n+    }\n+}\n+\n fn rewrite_comment_inner(\n     orig: &str,\n     block_style: bool,\n@@ -493,15 +545,17 @@ fn rewrite_comment_inner(\n     let mut code_block_buffer = String::with_capacity(128);\n     let mut is_prev_line_multi_line = false;\n     let mut code_block_attr = None;\n+    let mut item_block_buffer = String::with_capacity(128);\n+    let mut item_block: Option<ItemizedBlock> = None;\n     let comment_line_separator = format!(\"{}{}\", indent_str, line_start);\n-    let join_code_block_with_comment_line_separator = |s: &str| {\n+    let join_block = |s: &str, sep: &str| {\n         let mut result = String::with_capacity(s.len() + 128);\n         let mut iter = s.lines().peekable();\n         while let Some(line) = iter.next() {\n             result.push_str(line);\n             result.push_str(match iter.peek() {\n-                Some(next_line) if next_line.is_empty() => comment_line_separator.trim_right(),\n-                Some(..) => &comment_line_separator,\n+                Some(next_line) if next_line.is_empty() => sep.trim_right(),\n+                Some(..) => &sep,\n                 None => \"\",\n             });\n         }\n@@ -511,7 +565,26 @@ fn rewrite_comment_inner(\n     for (i, (line, has_leading_whitespace)) in lines.enumerate() {\n         let is_last = i == count_newlines(orig);\n \n-        if let Some(ref attr) = code_block_attr {\n+        if let Some(ref ib) = item_block {\n+            if ib.in_block(&line) {\n+                item_block_buffer.push_str(&line);\n+                item_block_buffer.push('\\n');\n+                continue;\n+            }\n+            is_prev_line_multi_line = false;\n+            fmt.shape = Shape::legacy(max_chars, fmt_indent);\n+            let item_fmt = ib.create_string_format(&fmt);\n+            result.push_str(&comment_line_separator);\n+            result.push_str(&ib.opener);\n+            match rewrite_string(&item_block_buffer.replace(\"\\n\", \" \"), &item_fmt) {\n+                Some(s) => result.push_str(&join_block(\n+                    &s,\n+                    &format!(\"{}{}\", &comment_line_separator, ib.line_start),\n+                )),\n+                None => result.push_str(&join_block(&item_block_buffer, &comment_line_separator)),\n+            };\n+            item_block_buffer.clear();\n+        } else if let Some(ref attr) = code_block_attr {\n             if line.starts_with(\"```\") {\n                 let code_block = match attr {\n                     CodeBlockAttribute::Ignore | CodeBlockAttribute::Text => {\n@@ -529,7 +602,7 @@ fn rewrite_comment_inner(\n                 };\n                 if !code_block.is_empty() {\n                     result.push_str(&comment_line_separator);\n-                    result.push_str(&join_code_block_with_comment_line_separator(&code_block));\n+                    result.push_str(&join_block(&code_block, &comment_line_separator));\n                 }\n                 code_block_buffer.clear();\n                 result.push_str(&comment_line_separator);\n@@ -538,46 +611,42 @@ fn rewrite_comment_inner(\n             } else {\n                 code_block_buffer.push_str(&hide_sharp_behind_comment(line));\n                 code_block_buffer.push('\\n');\n-\n-                if is_last {\n-                    // There is a code block that is not properly enclosed by backticks.\n-                    // We will leave them untouched.\n-                    result.push_str(&comment_line_separator);\n-                    result.push_str(&join_code_block_with_comment_line_separator(\n-                        &trim_custom_comment_prefix(&code_block_buffer),\n-                    ));\n-                }\n             }\n+            continue;\n+        }\n \n+        code_block_attr = None;\n+        item_block = None;\n+        if line.starts_with(\"```\") {\n+            code_block_attr = Some(CodeBlockAttribute::new(&line[3..]))\n+        } else if config.wrap_comments() && ItemizedBlock::is_itemized_line(&line) {\n+            let ib = ItemizedBlock::new(&line);\n+            item_block_buffer.push_str(&line[ib.indent..]);\n+            item_block_buffer.push('\\n');\n+            item_block = Some(ib);\n             continue;\n-        } else {\n-            code_block_attr = if line.starts_with(\"```\") {\n-                Some(CodeBlockAttribute::new(&line[3..]))\n-            } else {\n-                None\n-            };\n+        }\n \n-            if result == opener {\n-                let force_leading_whitespace = opener == \"/* \" && count_newlines(orig) == 0;\n-                if !has_leading_whitespace && !force_leading_whitespace && result.ends_with(' ') {\n-                    result.pop();\n-                }\n-                if line.is_empty() {\n-                    continue;\n-                }\n-            } else if is_prev_line_multi_line && !line.is_empty() {\n-                result.push(' ')\n-            } else if is_last && line.is_empty() {\n-                // trailing blank lines are unwanted\n-                if !closer.is_empty() {\n-                    result.push_str(&indent_str);\n-                }\n-                break;\n-            } else {\n-                result.push_str(&comment_line_separator);\n-                if !has_leading_whitespace && result.ends_with(' ') {\n-                    result.pop();\n-                }\n+        if result == opener {\n+            let force_leading_whitespace = opener == \"/* \" && count_newlines(orig) == 0;\n+            if !has_leading_whitespace && !force_leading_whitespace && result.ends_with(' ') {\n+                result.pop();\n+            }\n+            if line.is_empty() {\n+                continue;\n+            }\n+        } else if is_prev_line_multi_line && !line.is_empty() {\n+            result.push(' ')\n+        } else if is_last && line.is_empty() {\n+            // trailing blank lines are unwanted\n+            if !closer.is_empty() {\n+                result.push_str(&indent_str);\n+            }\n+            break;\n+        } else {\n+            result.push_str(&comment_line_separator);\n+            if !has_leading_whitespace && result.ends_with(' ') {\n+                result.pop();\n             }\n         }\n \n@@ -631,6 +700,30 @@ fn rewrite_comment_inner(\n             is_prev_line_multi_line = false;\n         }\n     }\n+    if !code_block_buffer.is_empty() {\n+        // There is a code block that is not properly enclosed by backticks.\n+        // We will leave them untouched.\n+        result.push_str(&comment_line_separator);\n+        result.push_str(&join_block(\n+            &trim_custom_comment_prefix(&code_block_buffer),\n+            &comment_line_separator,\n+        ));\n+    }\n+    if !item_block_buffer.is_empty() {\n+        // the last few lines are part of an itemized block\n+        let ib = item_block.unwrap();\n+        fmt.shape = Shape::legacy(max_chars, fmt_indent);\n+        let item_fmt = ib.create_string_format(&fmt);\n+        result.push_str(&comment_line_separator);\n+        result.push_str(&ib.opener);\n+        match rewrite_string(&item_block_buffer.replace(\"\\n\", \" \"), &item_fmt) {\n+            Some(s) => result.push_str(&join_block(\n+                &s,\n+                &format!(\"{}{}\", &comment_line_separator, ib.line_start),\n+            )),\n+            None => result.push_str(&join_block(&item_block_buffer, &comment_line_separator)),\n+        };\n+    }\n \n     result.push_str(closer);\n     if result.ends_with(opener) && opener.ends_with(' ') {"}, {"sha": "2fe13db2139cf46d1077af470c9be1dacbedc2a4", "filename": "src/string.rs", "status": "modified", "additions": 367, "deletions": 47, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -64,7 +64,7 @@ impl<'a> StringFormat<'a> {\n \n     /// Like max_chars_with_indent but the indentation is not substracted.\n     /// This allows to fit more graphemes from the string on a line when\n-    /// SnippetState::Overflow.\n+    /// SnippetState::EndWithLineFeed.\n     fn max_chars_without_indent(&self) -> Option<usize> {\n         Some(self.config.max_width().checked_sub(self.line_end.len())?)\n     }\n@@ -73,7 +73,8 @@ impl<'a> StringFormat<'a> {\n pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String> {\n     let max_chars_with_indent = fmt.max_chars_with_indent()?;\n     let max_chars_without_indent = fmt.max_chars_without_indent()?;\n-    let indent = fmt.shape.indent.to_string_with_newline(fmt.config);\n+    let indent_with_newline = fmt.shape.indent.to_string_with_newline(fmt.config);\n+    let indent_without_newline = fmt.shape.indent.to_string(fmt.config);\n \n     // Strip line breaks.\n     // With this regex applied, all remaining whitespaces are significant\n@@ -95,26 +96,55 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     // Snip a line at a time from `stripped_str` until it is used up. Push the snippet\n     // onto result.\n     let mut cur_max_chars = max_chars_with_indent;\n+    let is_bareline_ok = fmt.line_start.is_empty() || is_whitespace(fmt.line_start);\n     loop {\n         // All the input starting at cur_start fits on the current line\n         if graphemes.len() - cur_start <= cur_max_chars {\n-            result.push_str(&graphemes[cur_start..].join(\"\"));\n+            for (i, grapheme) in graphemes[cur_start..].iter().enumerate() {\n+                if is_line_feed(grapheme) {\n+                    // take care of blank lines\n+                    result = trim_right_but_line_feed(fmt.trim_end, result);\n+                    result.push_str(\"\\n\");\n+                    if !is_bareline_ok && cur_start + i + 1 < graphemes.len() {\n+                        result.push_str(&indent_without_newline);\n+                        result.push_str(fmt.line_start);\n+                    }\n+                } else {\n+                    result.push_str(grapheme);\n+                }\n+            }\n+            result = trim_right_but_line_feed(fmt.trim_end, result);\n             break;\n         }\n \n         // The input starting at cur_start needs to be broken\n-        match break_string(cur_max_chars, fmt.trim_end, &graphemes[cur_start..]) {\n+        match break_string(\n+            cur_max_chars,\n+            fmt.trim_end,\n+            fmt.line_end,\n+            &graphemes[cur_start..],\n+        ) {\n             SnippetState::LineEnd(line, len) => {\n                 result.push_str(&line);\n                 result.push_str(fmt.line_end);\n-                result.push_str(&indent);\n+                result.push_str(&indent_with_newline);\n                 result.push_str(fmt.line_start);\n                 cur_max_chars = max_chars_with_indent;\n                 cur_start += len;\n             }\n-            SnippetState::Overflow(line, len) => {\n+            SnippetState::EndWithLineFeed(line, len) => {\n+                if line == \"\\n\" && fmt.trim_end {\n+                    result = result.trim_right().to_string();\n+                }\n                 result.push_str(&line);\n-                cur_max_chars = max_chars_without_indent;\n+                if is_bareline_ok {\n+                    // the next line can benefit from the full width\n+                    cur_max_chars = max_chars_without_indent;\n+                } else {\n+                    result.push_str(&indent_without_newline);\n+                    result.push_str(fmt.line_start);\n+                    cur_max_chars = max_chars_with_indent;\n+                }\n                 cur_start += len;\n             }\n             SnippetState::EndOfInput(line) => {\n@@ -128,6 +158,43 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     wrap_str(result, fmt.config.max_width(), fmt.shape)\n }\n \n+/// Returns the index to the end of the url if the given string includes an\n+/// URL or alike. Otherwise, returns None;\n+fn detect_url(s: &[&str], index: usize) -> Option<usize> {\n+    let start = match s[..=index].iter().rposition(|g| is_whitespace(g)) {\n+        Some(pos) => pos + 1,\n+        None => 0,\n+    };\n+    if s.len() < start + 8 {\n+        return None;\n+    }\n+    let prefix = s[start..start + 8].join(\"\");\n+    if prefix.starts_with(\"https://\")\n+        || prefix.starts_with(\"http://\")\n+        || prefix.starts_with(\"ftp://\")\n+        || prefix.starts_with(\"file://\")\n+    {\n+        match s[index..].iter().position(|g| is_whitespace(g)) {\n+            Some(pos) => Some(index + pos - 1),\n+            None => Some(s.len() - 1),\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Trims whitespaces to the right except for the line feed character.\n+fn trim_right_but_line_feed(trim_end: bool, result: String) -> String {\n+    let whitespace_except_line_feed = |c: char| c.is_whitespace() && c != '\\n';\n+    if trim_end && result.ends_with(whitespace_except_line_feed) {\n+        result\n+            .trim_right_matches(whitespace_except_line_feed)\n+            .to_string()\n+    } else {\n+        result\n+    }\n+}\n+\n /// Result of breaking a string so it fits in a line and the state it ended in.\n /// The state informs about what to do with the snippet and how to continue the breaking process.\n #[derive(Debug, PartialEq)]\n@@ -136,36 +203,46 @@ enum SnippetState {\n     EndOfInput(String),\n     /// The input could be broken and the returned snippet should be ended with a\n     /// `[StringFormat::line_end]`. The next snippet needs to be indented.\n+    ///\n     /// The returned string is the line to print out and the number is the length that got read in\n     /// the text being rewritten. That length may be greater than the returned string if trailing\n     /// whitespaces got trimmed.\n     LineEnd(String, usize),\n-    /// The input could be broken but the returned snippet should not be ended with a\n-    /// `[StringFormat::line_end]` because the whitespace is significant. Therefore, the next\n-    /// snippet should not be indented.\n-    Overflow(String, usize),\n+    /// The input could be broken but a newline is present that cannot be trimmed. The next snippet\n+    /// to be rewritten *could* use more width than what is specified by the given shape. For\n+    /// example with a multiline string, the next snippet does not need to be indented, allowing\n+    /// more characters to be fit within a line.\n+    ///\n+    /// The returned string is the line to print out and the number is the length that got read in\n+    /// the text being rewritten.\n+    EndWithLineFeed(String, usize),\n+}\n+\n+fn not_whitespace_except_line_feed(g: &str) -> bool {\n+    is_line_feed(g) || !is_whitespace(g)\n }\n \n /// Break the input string at a boundary character around the offset `max_chars`. A boundary\n /// character is either a punctuation or a whitespace.\n-fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetState {\n+fn break_string(max_chars: usize, trim_end: bool, line_end: &str, input: &[&str]) -> SnippetState {\n     let break_at = |index /* grapheme at index is included */| {\n-        // Take in any whitespaces to the left/right of `input[index]` and\n-        // check if there is a line feed, in which case whitespaces needs to be kept.\n-        let mut index_minus_ws = index;\n-        for (i, grapheme) in input[0..=index].iter().enumerate().rev() {\n-            if !is_whitespace(grapheme) {\n-                index_minus_ws = i;\n-                break;\n-            }\n-        }\n+        // Take in any whitespaces to the left/right of `input[index]` while\n+        // preserving line feeds\n+        let index_minus_ws = input[0..=index]\n+            .iter()\n+            .rposition(|grapheme| not_whitespace_except_line_feed(grapheme))\n+            .unwrap_or(index);\n         // Take into account newlines occuring in input[0..=index], i.e., the possible next new\n         // line. If there is one, then text after it could be rewritten in a way that the available\n         // space is fully used.\n         for (i, grapheme) in input[0..=index].iter().enumerate() {\n             if is_line_feed(grapheme) {\n-                if i < index_minus_ws || !trim_end {\n-                    return SnippetState::Overflow(input[0..=i].join(\"\").to_string(), i + 1);\n+                if i <= index_minus_ws {\n+                    let mut line = input[0..i].join(\"\");\n+                    if trim_end {\n+                        line = line.trim_right().to_string();\n+                    }\n+                    return SnippetState::EndWithLineFeed(format!(\"{}\\n\", line), i + 1);\n                 }\n                 break;\n             }\n@@ -174,11 +251,11 @@ fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetStat\n         let mut index_plus_ws = index;\n         for (i, grapheme) in input[index + 1..].iter().enumerate() {\n             if !trim_end && is_line_feed(grapheme) {\n-                return SnippetState::Overflow(\n+                return SnippetState::EndWithLineFeed(\n                     input[0..=index + 1 + i].join(\"\").to_string(),\n                     index + 2 + i,\n                 );\n-            } else if !is_whitespace(grapheme) {\n+            } else if not_whitespace_except_line_feed(grapheme) {\n                 index_plus_ws = index + i;\n                 break;\n             }\n@@ -198,6 +275,35 @@ fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetStat\n     };\n \n     // Find the position in input for breaking the string\n+    if line_end.is_empty()\n+        && trim_end\n+        && !is_whitespace(input[max_chars - 1])\n+        && is_whitespace(input[max_chars])\n+    {\n+        // At a breaking point already\n+        // The line won't invalidate the rewriting because:\n+        // - no extra space needed for the line_end character\n+        // - extra whitespaces to the right can be trimmed\n+        return break_at(max_chars - 1);\n+    }\n+    if let Some(url_index_end) = detect_url(input, max_chars) {\n+        let index_plus_ws = url_index_end + input[url_index_end..]\n+            .iter()\n+            .skip(1)\n+            .position(|grapheme| not_whitespace_except_line_feed(grapheme))\n+            .unwrap_or(0);\n+        return if trim_end {\n+            SnippetState::LineEnd(\n+                input[..=url_index_end].join(\"\").to_string(),\n+                index_plus_ws + 1,\n+            )\n+        } else {\n+            return SnippetState::LineEnd(\n+                input[..=index_plus_ws].join(\"\").to_string(),\n+                index_plus_ws + 1,\n+            );\n+        };\n+    }\n     match input[0..max_chars]\n         .iter()\n         .rposition(|grapheme| is_whitespace(grapheme))\n@@ -243,7 +349,7 @@ fn is_punctuation(grapheme: &str) -> bool {\n \n #[cfg(test)]\n mod test {\n-    use super::{break_string, rewrite_string, SnippetState, StringFormat};\n+    use super::{break_string, detect_url, rewrite_string, SnippetState, StringFormat};\n     use config::Config;\n     use shape::{Indent, Shape};\n     use unicode_segmentation::UnicodeSegmentation;\n@@ -260,11 +366,11 @@ mod test {\n         let string = \"Placerat felis. Mauris porta ante sagittis purus.\";\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n-            break_string(20, false, &graphemes[..]),\n+            break_string(20, false, \"\", &graphemes[..]),\n             SnippetState::LineEnd(\"Placerat felis. \".to_string(), 16)\n         );\n         assert_eq!(\n-            break_string(20, true, &graphemes[..]),\n+            break_string(20, true, \"\", &graphemes[..]),\n             SnippetState::LineEnd(\"Placerat felis.\".to_string(), 16)\n         );\n     }\n@@ -274,7 +380,7 @@ mod test {\n         let string = \"Placerat_felis._Mauris_porta_ante_sagittis_purus.\";\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n-            break_string(20, false, &graphemes[..]),\n+            break_string(20, false, \"\", &graphemes[..]),\n             SnippetState::LineEnd(\"Placerat_felis.\".to_string(), 15)\n         );\n     }\n@@ -284,11 +390,11 @@ mod test {\n         let string = \"Venenatis_tellus_vel_tellus. Aliquam aliquam dolor at justo.\";\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n-            break_string(20, false, &graphemes[..]),\n+            break_string(20, false, \"\", &graphemes[..]),\n             SnippetState::LineEnd(\"Venenatis_tellus_vel_tellus. \".to_string(), 29)\n         );\n         assert_eq!(\n-            break_string(20, true, &graphemes[..]),\n+            break_string(20, true, \"\", &graphemes[..]),\n             SnippetState::LineEnd(\"Venenatis_tellus_vel_tellus.\".to_string(), 29)\n         );\n     }\n@@ -298,7 +404,7 @@ mod test {\n         let string = \"Venenatis_tellus_vel_tellus\";\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n-            break_string(20, false, &graphemes[..]),\n+            break_string(20, false, \"\", &graphemes[..]),\n             SnippetState::EndOfInput(\"Venenatis_tellus_vel_tellus\".to_string())\n         );\n     }\n@@ -308,21 +414,21 @@ mod test {\n         let string = \"Neque in sem.      \\n      Pellentesque tellus augue.\";\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n-            break_string(15, false, &graphemes[..]),\n-            SnippetState::Overflow(\"Neque in sem.      \\n\".to_string(), 20)\n+            break_string(15, false, \"\", &graphemes[..]),\n+            SnippetState::EndWithLineFeed(\"Neque in sem.      \\n\".to_string(), 20)\n         );\n         assert_eq!(\n-            break_string(25, false, &graphemes[..]),\n-            SnippetState::Overflow(\"Neque in sem.      \\n\".to_string(), 20)\n+            break_string(25, false, \"\", &graphemes[..]),\n+            SnippetState::EndWithLineFeed(\"Neque in sem.      \\n\".to_string(), 20)\n         );\n-        // if `StringFormat::line_end` is true, then the line feed does not matter anymore\n+\n         assert_eq!(\n-            break_string(15, true, &graphemes[..]),\n-            SnippetState::LineEnd(\"Neque in sem.\".to_string(), 26)\n+            break_string(15, true, \"\", &graphemes[..]),\n+            SnippetState::LineEnd(\"Neque in sem.\".to_string(), 19)\n         );\n         assert_eq!(\n-            break_string(25, true, &graphemes[..]),\n-            SnippetState::LineEnd(\"Neque in sem.\".to_string(), 26)\n+            break_string(25, true, \"\", &graphemes[..]),\n+            SnippetState::EndWithLineFeed(\"Neque in sem.\\n\".to_string(), 20)\n         );\n     }\n \n@@ -331,11 +437,11 @@ mod test {\n         let string = \"Neque in sem.            Pellentesque tellus augue.\";\n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n-            break_string(20, false, &graphemes[..]),\n+            break_string(20, false, \"\", &graphemes[..]),\n             SnippetState::LineEnd(\"Neque in sem.            \".to_string(), 25)\n         );\n         assert_eq!(\n-            break_string(20, true, &graphemes[..]),\n+            break_string(20, true, \"\", &graphemes[..]),\n             SnippetState::LineEnd(\"Neque in sem.\".to_string(), 25)\n         );\n     }\n@@ -346,12 +452,12 @@ mod test {\n \n         let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n         assert_eq!(\n-            break_string(25, false, &graphemes[..]),\n-            SnippetState::Overflow(\"Nulla\\n\".to_string(), 6)\n+            break_string(25, false, \"\", &graphemes[..]),\n+            SnippetState::EndWithLineFeed(\"Nulla\\n\".to_string(), 6)\n         );\n         assert_eq!(\n-            break_string(25, true, &graphemes[..]),\n-            SnippetState::Overflow(\"Nulla\\n\".to_string(), 6)\n+            break_string(25, true, \"\", &graphemes[..]),\n+            SnippetState::EndWithLineFeed(\"Nulla\\n\".to_string(), 6)\n         );\n \n         let mut config: Config = Default::default();\n@@ -363,4 +469,218 @@ mod test {\n             Some(\"\\\"Nulla\\nconsequat erat at massa. \\\\\\n Vivamus id mi.\\\"\".to_string())\n         );\n     }\n+\n+    #[test]\n+    fn last_line_fit_with_trailing_whitespaces() {\n+        let string = \"Vivamus id mi.  \";\n+        let config: Config = Default::default();\n+        let mut fmt = StringFormat::new(Shape::legacy(25, Indent::empty()), &config);\n+\n+        fmt.trim_end = true;\n+        let rewritten_string = rewrite_string(string, &fmt);\n+        assert_eq!(rewritten_string, Some(\"\\\"Vivamus id mi.\\\"\".to_string()));\n+\n+        fmt.trim_end = false; // default value of trim_end\n+        let rewritten_string = rewrite_string(string, &fmt);\n+        assert_eq!(rewritten_string, Some(\"\\\"Vivamus id mi.  \\\"\".to_string()));\n+    }\n+\n+    #[test]\n+    fn last_line_fit_with_newline() {\n+        let string = \"Vivamus id mi.\\nVivamus id mi.\";\n+        let config: Config = Default::default();\n+        let fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"\",\n+            shape: Shape::legacy(100, Indent::from_width(&config, 4)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        let rewritten_string = rewrite_string(string, &fmt);\n+        assert_eq!(\n+            rewritten_string,\n+            Some(\"Vivamus id mi.\\n    // Vivamus id mi.\".to_string())\n+        );\n+    }\n+\n+    #[test]\n+    fn overflow_in_non_string_content() {\n+        let comment = \"Aenean metus.\\nVestibulum ac lacus. Vivamus porttitor\";\n+        let config: Config = Default::default();\n+        let fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"\",\n+            shape: Shape::legacy(30, Indent::from_width(&config, 8)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                \"Aenean metus.\\n        // Vestibulum ac lacus. Vivamus\\n        // porttitor\"\n+                    .to_string()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn overflow_in_non_string_content_with_line_end() {\n+        let comment = \"Aenean metus.\\nVestibulum ac lacus. Vivamus porttitor\";\n+        let config: Config = Default::default();\n+        let fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"@\",\n+            shape: Shape::legacy(30, Indent::from_width(&config, 8)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                \"Aenean metus.\\n        // Vestibulum ac lacus. Vivamus@\\n        // porttitor\"\n+                    .to_string()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn blank_line_with_non_empty_line_start() {\n+        let config: Config = Default::default();\n+        let mut fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"\",\n+            shape: Shape::legacy(30, Indent::from_width(&config, 4)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        let comment = \"Aenean metus. Vestibulum\\n\\nac lacus. Vivamus porttitor\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                \"Aenean metus. Vestibulum\\n    //\\n    // ac lacus. Vivamus porttitor\".to_string()\n+            )\n+        );\n+\n+        fmt.shape = Shape::legacy(15, Indent::from_width(&config, 4));\n+        let comment = \"Aenean\\n\\nmetus. Vestibulum ac lacus. Vivamus porttitor\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                r#\"Aenean\n+    //\n+    // metus. Vestibulum\n+    // ac lacus. Vivamus\n+    // porttitor\"#\n+                    .to_string()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn retain_blank_lines() {\n+        let config: Config = Default::default();\n+        let fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"\",\n+            shape: Shape::legacy(20, Indent::from_width(&config, 4)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        let comment = \"Aenean\\n\\nmetus. Vestibulum ac lacus.\\n\\n\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                \"Aenean\\n    //\\n    // metus. Vestibulum ac\\n    // lacus.\\n    //\\n\".to_string()\n+            )\n+        );\n+\n+        let comment = \"Aenean\\n\\nmetus. Vestibulum ac lacus.\\n\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\"Aenean\\n    //\\n    // metus. Vestibulum ac\\n    // lacus.\\n\".to_string())\n+        );\n+\n+        let comment = \"Aenean\\n        \\nmetus. Vestibulum ac lacus.\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\"Aenean\\n    //\\n    // metus. Vestibulum ac\\n    // lacus.\".to_string())\n+        );\n+    }\n+\n+    #[test]\n+    fn boundary_on_edge() {\n+        let config: Config = Default::default();\n+        let mut fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"\",\n+            shape: Shape::legacy(13, Indent::from_width(&config, 4)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        let comment = \"Aenean metus. Vestibulum ac lacus.\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\"Aenean metus.\\n    // Vestibulum ac\\n    // lacus.\".to_string())\n+        );\n+\n+        fmt.trim_end = false;\n+        let comment = \"Vestibulum ac lacus.\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\"Vestibulum \\n    // ac lacus.\".to_string())\n+        );\n+\n+        fmt.trim_end = true;\n+        fmt.line_end = \"\\\\\";\n+        let comment = \"Vestibulum ac lacus.\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\"Vestibulum\\\\\\n    // ac lacus.\".to_string())\n+        );\n+    }\n+\n+    #[test]\n+    fn detect_urls() {\n+        let string = \"aaa http://example.org something\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(detect_url(&graphemes, 8), Some(21));\n+\n+        let string = \"https://example.org something\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(detect_url(&graphemes, 0), Some(18));\n+\n+        let string = \"aaa ftp://example.org something\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(detect_url(&graphemes, 8), Some(20));\n+\n+        let string = \"aaa file://example.org something\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(detect_url(&graphemes, 8), Some(21));\n+\n+        let string = \"aaa http not an url\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(detect_url(&graphemes, 6), None);\n+\n+        let string = \"aaa file://example.org\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(detect_url(&graphemes, 8), Some(21));\n+    }\n }"}, {"sha": "dff9ee8a222448149fbdab57cf2de198dd6ba6f8", "filename": "tests/source/itemized-blocks/no_wrap.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Fno_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Fno_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fitemized-blocks%2Fno_wrap.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,46 @@\n+// rustfmt-normalize_comments: true\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could be reformatted something something something lots of text so that it could be reformatted something something something\n+//!\n+//! This example shows how to configure fern to output really nicely colored logs\n+//! - when the log level is error, the whole line is red\n+//! - when the log level is warn, the whole line is yellow\n+//! - when the log level is info, the level name is green and the rest of the line is white\n+//! - when the log level is debug, the whole line is white\n+//! - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor\n+fn func1() {}\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x =     42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x =     42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}, {"sha": "f99c2cc5ff9cf8ff851434b903dbfd06836eb07a", "filename": "tests/source/itemized-blocks/rewrite_fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Frewrite_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Frewrite_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fitemized-blocks%2Frewrite_fail.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,11 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 50\n+\n+// This example shows how to configure fern to output really nicely colored logs\n+// - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \n+//   - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \n+//     - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \n+//     - when the log level is info, the level name is green and the rest of the line is white\n+//   - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \n+//   - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \n+fn func1() {}"}, {"sha": "2eaaafbbc4aa622d091f4e3f69599d3dbf9c57d0", "filename": "tests/source/itemized-blocks/urls.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Furls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Furls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fitemized-blocks%2Furls.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,22 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 79\n+\n+//! CMSIS: Cortex Microcontroller Software Interface Standard\n+//!\n+//! The version 5 of the standard can be found at:\n+//!\n+//! http://arm-software.github.io/CMSIS_5/Core/html/index.html\n+//!\n+//! The API reference of the standard can be found at:\n+//!\n+//! - example -- http://example.org -- something something something something something something\n+//! - something something something something something something more -- http://example.org\n+//! - http://example.org/something/something/something/something/something/something and the rest\n+//! - Core function access -- http://arm-software.github.io/CMSIS_5/Core/html/group__Core__Register__gr.html\n+//! - Intrinsic functions for CPU instructions -- http://arm-software.github.io/CMSIS_5/Core/html/group__intrinsic__CPU__gr.html\n+//! - Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Vestibulum sem lacus, commodo vitae.\n+//!\n+//! The reference C implementation used as the base of this Rust port can be\n+//! found at\n+//!\n+//! https://github.com/ARM-software/CMSIS_5/blob/5.3.0/CMSIS/Core/Include/cmsis_gcc.h"}, {"sha": "5daba855e6bcc2eaef56147e73aa7d7c999775aa", "filename": "tests/source/itemized-blocks/wrap.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Fwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Fsource%2Fitemized-blocks%2Fwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fitemized-blocks%2Fwrap.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,54 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 50\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could be reformatted something something something lots of text so that it could be reformatted something something something\n+//!\n+//! This example shows how to configure fern to output really nicely colored logs\n+//! - when the log level is error, the whole line is red\n+//! - when the log level is warn, the whole line is yellow\n+//! - when the log level is info, the level name is green and the rest of the line is white\n+//! - when the log level is debug, the whole line is white\n+//! - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+// This example shows how to configure fern to output really nicely colored logs\n+// - when the log level is error, the whole line is red\n+//   - when the log level is warn, the whole line is yellow\n+//     - when the log level is info, the level name is green and the rest of the line is white\n+//   - when the log level is debug, the whole line is white\n+//   - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor\n+fn func1() {}\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x =     42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x =     42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}, {"sha": "82d171e6f6a69c6d5b50c38e718ba2ca8c1abcbf", "filename": "tests/target/comment5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fcomment5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fcomment5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment5.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -2,8 +2,8 @@\n // rustfmt-wrap_comments: true\n \n //@ special comment\n-//@ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec adiam\n-//@ lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam\n+//@ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec adiam lectus.\n+//@ Sed sit amet ipsum mauris. Maecenas congue ligula ac quam\n //@\n //@ foo\n fn test() {}"}, {"sha": "6bc355bc80768cbc87d6b0732ab8371db3ea059b", "filename": "tests/target/enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -145,8 +145,8 @@ pub enum Bencoding<'i> {\n     Int(i64),\n     List(Vec<Bencoding<'i>>),\n     /// A bencoded dict value. The first element the slice of bytes in the\n-    /// source that the dict is composed of. The second is the dict,\n-    /// decoded into an ordered map.\n+    /// source that the dict is composed of. The second is the dict, decoded\n+    /// into an ordered map.\n     // TODO make Dict \"structlike\" AKA name the two values.\n     Dict(&'i [u8], BTreeMap<&'i [u8], Bencoding<'i>>),\n }"}, {"sha": "c7151cf81ff9fca9f94b28a8b75ebd70e231c511", "filename": "tests/target/itemized-blocks/no_wrap.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Fno_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Fno_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fitemized-blocks%2Fno_wrap.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,46 @@\n+// rustfmt-normalize_comments: true\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could be reformatted something something something lots of text so that it could be reformatted something something something\n+//!\n+//! This example shows how to configure fern to output really nicely colored logs\n+//! - when the log level is error, the whole line is red\n+//! - when the log level is warn, the whole line is yellow\n+//! - when the log level is info, the level name is green and the rest of the line is white\n+//! - when the log level is debug, the whole line is white\n+//! - when the log level is trace, the whole line is gray (\"bright black\")\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor\n+fn func1() {}\n+\n+/// All the parameters ***except for `from_theater`*** should be inserted as sent by the remote\n+/// theater, ie. as passed to [`Theater::send`] on the remote actor:\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x = 42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x = 42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`], as reported by the remote theater by theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`], as requested by the remote theater\n+///  * `tag` is a tag that identifies the message type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}, {"sha": "a118ef6faa18487b869370d019a03413c7cfb6dd", "filename": "tests/target/itemized-blocks/rewrite_fail.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Frewrite_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Frewrite_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fitemized-blocks%2Frewrite_fail.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,14 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 50\n+\n+// This example shows how to configure fern to\n+// output really nicely colored logs\n+// - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+//   - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+//     - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+//     - when the log level is info, the level\n+//       name is green and the rest of the line is\n+//       white\n+//   - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+//   - aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+fn func1() {}"}, {"sha": "bc46ea47e164f0035a1b79a8beca1803dde86661", "filename": "tests/target/itemized-blocks/urls.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Furls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Furls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fitemized-blocks%2Furls.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,25 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 79\n+\n+//! CMSIS: Cortex Microcontroller Software Interface Standard\n+//!\n+//! The version 5 of the standard can be found at:\n+//!\n+//! http://arm-software.github.io/CMSIS_5/Core/html/index.html\n+//!\n+//! The API reference of the standard can be found at:\n+//!\n+//! - example -- http://example.org -- something something something something\n+//!   something something\n+//! - something something something something something something more -- http://example.org\n+//! - http://example.org/something/something/something/something/something/something\n+//!   and the rest\n+//! - Core function access -- http://arm-software.github.io/CMSIS_5/Core/html/group__Core__Register__gr.html\n+//! - Intrinsic functions for CPU instructions -- http://arm-software.github.io/CMSIS_5/Core/html/group__intrinsic__CPU__gr.html\n+//! - Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Vestibulum sem\n+//!   lacus, commodo vitae.\n+//!\n+//! The reference C implementation used as the base of this Rust port can be\n+//! found at\n+//!\n+//! https://github.com/ARM-software/CMSIS_5/blob/5.3.0/CMSIS/Core/Include/cmsis_gcc.h"}, {"sha": "08d8ca352612785eeeb074e0ae24e09871b586c7", "filename": "tests/target/itemized-blocks/wrap.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Fwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fitemized-blocks%2Fwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fitemized-blocks%2Fwrap.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -0,0 +1,91 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 50\n+\n+//! This is a list:\n+//!  * Outer\n+//!  * Outer\n+//!   * Inner\n+//!   * Inner with lots of text so that it could\n+//!     be reformatted something something\n+//!     something lots of text so that it could be\n+//!     reformatted something something something\n+//!\n+//! This example shows how to configure fern to\n+//! output really nicely colored logs\n+//! - when the log level is error, the whole line\n+//!   is red\n+//! - when the log level is warn, the whole line\n+//!   is yellow\n+//! - when the log level is info, the level name\n+//!   is green and the rest of the line is white\n+//! - when the log level is debug, the whole line\n+//!   is white\n+//! - when the log level is trace, the whole line\n+//!   is gray (\"bright black\")\n+\n+// This example shows how to configure fern to\n+// output really nicely colored logs\n+// - when the log level is error, the whole line\n+//   is red\n+//   - when the log level is warn, the whole line\n+//     is yellow\n+//     - when the log level is info, the level\n+//       name is green and the rest of the line is\n+//       white\n+//   - when the log level is debug, the whole line\n+//     is white\n+//   - when the log level is trace, the whole line\n+//     is gray (\"bright black\")\n+\n+/// All the parameters ***except for\n+/// `from_theater`*** should be inserted as sent\n+/// by the remote theater, ie. as passed to\n+/// [`Theater::send`] on the remote\n+/// actor:\n+///  * `from` is the sending (remote) [`ActorId`],\n+///    as reported by the remote theater by\n+///    theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`],\n+///    as requested by the remote theater\n+///  * `tag` is a tag that identifies the message\n+///    type\n+///  * `msg` is the (serialized) message\n+/// All the parameters ***except for\n+/// `from_theater`*** should be inserted as sent\n+/// by the remote theater, ie. as passed to\n+/// [`Theater::send`] on the remote\n+/// actor\n+fn func1() {}\n+\n+/// All the parameters ***except for\n+/// `from_theater`*** should be inserted as sent\n+/// by the remote theater, ie. as passed to\n+/// [`Theater::send`] on the remote\n+/// actor:\n+///  * `from` is the sending (remote) [`ActorId`],\n+///    as reported by the remote theater by\n+///    theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`],\n+///    as requested by the remote theater\n+///  * `tag` is a tag that identifies the message\n+///    type\n+///  * `msg` is the (serialized) message\n+/// ```\n+/// let x = 42;\n+/// ```\n+fn func2() {}\n+\n+/// Look:\n+///\n+/// ```\n+/// let x = 42;\n+/// ```\n+///  * `from` is the sending (remote) [`ActorId`],\n+///    as reported by the remote theater by\n+///    theater-specific means\n+///  * `to` is the receiving (local) [`ActorId`],\n+///    as requested by the remote theater\n+///  * `tag` is a tag that identifies the message\n+///    type\n+///  * `msg` is the (serialized) message\n+fn func3() {}"}, {"sha": "d3bc364c3504ae1c4f84cbc0c64f1a16ceea10ea", "filename": "tests/target/struct_lits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct_lits.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -40,8 +40,8 @@ fn main() {\n \n     A {\n         // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit\n-        // amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante\n-        // hendrerit. Donec et mollis dolor.\n+        // amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit.\n+        // Donec et mollis dolor.\n         first: item(),\n         // Praesent et diam eget libero egestas mattis sit amet vitae augue.\n         // Nam tincidunt congue enim, ut porta lorem lacinia consectetur."}, {"sha": "b29aafd05484a18da0f8b3ac17f62965b7d9639b", "filename": "tests/target/struct_lits_multiline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fstruct_lits_multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4895699e884e9a2b0be90324dcd869ba86c4a5ef/tests%2Ftarget%2Fstruct_lits_multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct_lits_multiline.rs?ref=4895699e884e9a2b0be90324dcd869ba86c4a5ef", "patch": "@@ -50,8 +50,8 @@ fn main() {\n \n     A {\n         // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit\n-        // amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante\n-        // hendrerit. Donec et mollis dolor.\n+        // amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit.\n+        // Donec et mollis dolor.\n         first: item(),\n         // Praesent et diam eget libero egestas mattis sit amet vitae augue.\n         // Nam tincidunt congue enim, ut porta lorem lacinia consectetur."}]}