{"sha": "941101a9cdcd45e674e8ef57201a99a9d454e89f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MTEwMWE5Y2RjZDQ1ZTY3NGU4ZWY1NzIwMWE5OWE5ZDQ1NGU4OWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-08T19:47:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T22:32:17Z"}, "message": "define ty and update parser for sendable lambdas", "tree": {"sha": "f02c79b4ec97cfe503b95cad9c29b9328a2a6b74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f02c79b4ec97cfe503b95cad9c29b9328a2a6b74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/941101a9cdcd45e674e8ef57201a99a9d454e89f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/941101a9cdcd45e674e8ef57201a99a9d454e89f", "html_url": "https://github.com/rust-lang/rust/commit/941101a9cdcd45e674e8ef57201a99a9d454e89f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/941101a9cdcd45e674e8ef57201a99a9d454e89f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "327ec89f693afcc901bbe3a82b0bb5b5eb1dc44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/327ec89f693afcc901bbe3a82b0bb5b5eb1dc44d", "html_url": "https://github.com/rust-lang/rust/commit/327ec89f693afcc901bbe3a82b0bb5b5eb1dc44d"}], "stats": {"total": 104, "additions": 97, "deletions": 7}, "files": [{"sha": "d369e818d479f714f0d9bf5df898a04438fc7192", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941101a9cdcd45e674e8ef57201a99a9d454e89f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941101a9cdcd45e674e8ef57201a99a9d454e89f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=941101a9cdcd45e674e8ef57201a99a9d454e89f", "patch": "@@ -980,6 +980,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n         alt proto {\n           ast::proto_block. { ast::kind_noncopyable }\n           ast::proto_shared(_) { ast::kind_copyable }\n+          ast::proto_send. { ast::kind_sendable }\n           ast::proto_bare. { ast::kind_sendable }\n         }\n       }"}, {"sha": "d9d5260416e825d8080ffd96ca45dce10ac2b2e6", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/941101a9cdcd45e674e8ef57201a99a9d454e89f/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941101a9cdcd45e674e8ef57201a99a9d454e89f/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=941101a9cdcd45e674e8ef57201a99a9d454e89f", "patch": "@@ -113,6 +113,7 @@ tag proto_sugar {\n \n tag proto {\n     proto_bare;\n+    proto_send;\n     proto_shared(proto_sugar);\n     proto_block;\n }\n@@ -198,7 +199,7 @@ tag expr_ {\n     expr_for(@local, @expr, blk);\n     expr_do_while(blk, @expr);\n     expr_alt(@expr, [arm]);\n-    expr_fn(_fn);\n+    expr_fn(_fn, @capture);\n     expr_block(blk);\n \n     /*\n@@ -233,6 +234,15 @@ tag expr_ {\n     expr_mac(mac);\n }\n \n+// At the moment, one can only capture local variables.\n+type capture_ = {\n+    is_send: bool,\n+    copies: [ident],\n+    moves: [ident]\n+};\n+\n+type capture = spanned<capture_>;\n+\n /*\n // Says whether this is a block the user marked as\n // \"unchecked\""}, {"sha": "e927ffbbeffad2b6f2e87d11d6da9a33c1c011f9", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 85, "deletions": 6, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/941101a9cdcd45e674e8ef57201a99a9d454e89f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941101a9cdcd45e674e8ef57201a99a9d454e89f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=941101a9cdcd45e674e8ef57201a99a9d454e89f", "patch": "@@ -14,6 +14,12 @@ tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; RESTRICT_NO_BAR_OP; }\n \n tag file_type { CRATE_FILE; SOURCE_FILE; }\n \n+tag fn_kw {\n+    fn_kw_fn;\n+    fn_kw_lambda;\n+    fn_kw_block;\n+};\n+\n type parse_sess = @{cm: codemap::codemap, mutable next_id: node_id};\n \n fn next_node_id(sess: parse_sess) -> node_id {\n@@ -536,7 +542,14 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if eat_word(p, \"block\") {\n         t = parse_ty_fn(ast::proto_block, p);\n     } else if eat_word(p, \"lambda\") {\n-        t = parse_ty_fn(ast::proto_shared(ast::sugar_sexy), p);\n+        if p.peek() == token::LBRACE { // lambda[send](...)\n+            expect(p, token::LBRACE);\n+            expect_word(p, \"send\");\n+            expect(p, token::RBRACE);\n+            t = parse_ty_fn(ast::proto_send, p);\n+        } else { // lambda(...)\n+            t = parse_ty_fn(ast::proto_shared(ast::sugar_sexy), p);\n+        }\n     } else if eat_word(p, \"obj\") {\n         t = parse_ty_obj(p);\n     } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n@@ -831,11 +844,11 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         */\n     } else if eat_word(p, \"fn\") {\n         let proto = parse_fn_anon_proto(p);\n-        ret parse_fn_expr(p, proto);\n+        ret parse_fn_expr(p, fn_kw_fn);\n     } else if eat_word(p, \"block\") {\n-        ret parse_fn_expr(p, ast::proto_block);\n+        ret parse_fn_expr(p, fn_kw_block);\n     } else if eat_word(p, \"lambda\") {\n-        ret parse_fn_expr(p, ast::proto_shared(ast::sugar_sexy));\n+        ret parse_fn_expr(p, fn_kw_lambda);\n     } else if eat_word(p, \"unchecked\") {\n         ret parse_block_expr(p, lo, ast::unchecked_blk);\n     } else if eat_word(p, \"unsafe\") {\n@@ -1274,12 +1287,78 @@ fn parse_if_expr(p: parser) -> @ast::expr {\n     }\n }\n \n-fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n+// Parses:\n+//\n+//   CC := [send; copy ID*; move ID*]\n+//\n+// where any part is optional and trailing ; is permitted.\n+fn parse_capture_clause(p: parser) -> (bool, @ast::capture) {\n+    fn expect_opt_trailing_semi(p: parser) {\n+        if !eat(p, token::SEMI) {\n+            if p.peek() != token::RBRACE {\n+                p.fatal(\"expecting ; or ]\");\n+            }\n+        }\n+    }\n+\n+    fn eat_ident_list(p: parser) -> [ast::ident] {\n+        let res = [];\n+        while true {\n+            alt p.peek() {\n+              token::IDENT(_, _) {\n+                res += parse_ident(p);\n+                if !eat(p, token::COMMA) {\n+                    ret res;\n+                }\n+              }\n+\n+              _ { ret res; }\n+            }\n+        }\n+    }\n+\n+    let is_send = false;\n+    let copies = [];\n+    let moves = [];\n+\n+    if p.peek() != token::LBRACE {\n+        ret (is_send, captures);\n+    }\n+\n+    expect(p, token::LBRACE);\n+    while p.peek() != token::RBRACE {\n+        if eat_word(p, \"send\") {\n+            is_send = true;\n+            expect_opt_trailing_semi(p);\n+        } else if eat_word(p, \"copy\") {\n+            copies += eat_ident_list();\n+            expect_opt_trailing_semi(p);\n+        } else if eat_word(p, \"move\") {\n+            moves += eat_ident_list();\n+            expect_opt_trailing_semi(p);\n+        } else {\n+            let s: str = \"expecting send, copy, or move clause\";\n+            p.fatal(s);\n+        }\n+    }\n+\n+    ret @{is_send: is_send, copies: copies, moves: moves};\n+}\n+\n+fn parse_fn_expr(p: parser, kw: fn_kw) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n+    let cap = parse_capture_clause(p);\n     let decl = parse_fn_decl(p, ast::impure_fn, ast::il_normal);\n     let body = parse_block(p);\n+    let proto = alt (kw, cap.is_send) {\n+      (fn_kw_fn., true) { ast::proto_bare }\n+      (fn_kw_lambda., true) { ast::proto_send }\n+      (fn_kw_lambda., false) { ast::proto_shared(ast::sugar_sexy) }\n+      (fn_kw_block., false) { ast::proto_block }\n+      (_, true) { p.fatal(\"only lambda can be declared sendable\"); }\n+    }\n     let _fn = {decl: decl, proto: proto, body: body};\n-    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn));\n+    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn, cap));\n }\n \n fn parse_fn_block_expr(p: parser) -> @ast::expr {"}]}