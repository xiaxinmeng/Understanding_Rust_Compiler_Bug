{"sha": "69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZmUzOWU4YThlNmE2NmQ5NzgzNmUzMDY4YTRiMWYxODNjNzllYTY=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-07-06T02:50:26Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-09-12T02:23:08Z"}, "message": "Add primitive documentation to libcore\n\nThis works by doing two things:\n- Adding links that are specific to the crate. Since not all primitive\n  items are defined in `core` (due to lang_items), these need to use\n  relative links and not intra-doc links.\n- Duplicating `primitive_docs` in both core and std. This allows not needing CARGO_PKG_NAME to build the standard library. It also adds a tidy check to make sure they stay the same.", "tree": {"sha": "ef123baaa1c9db0d8dfc066526e11e2df0da11ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef123baaa1c9db0d8dfc066526e11e2df0da11ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "html_url": "https://github.com/rust-lang/rust/commit/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c2b6ea37d7719a0370bd404030eef9702c1752c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2b6ea37d7719a0370bd404030eef9702c1752c", "html_url": "https://github.com/rust-lang/rust/commit/8c2b6ea37d7719a0370bd404030eef9702c1752c"}], "stats": {"total": 1425, "additions": 1394, "deletions": 31}, "files": [{"sha": "9dd0344c7c7b1c615993b70d6708fd549ba96ad2", "filename": "library/core/primitive_docs/box_into_raw.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fbox_into_raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fbox_into_raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fbox_into_raw.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/boxed/struct.Box.html#method.into_raw"}, {"sha": "4023e340a51829d9c5b9bd36b72922d746ae0d96", "filename": "library/core/primitive_docs/fs_file.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Ffs_file.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Ffs_file.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Ffs_file.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/fs/struct.File.html"}, {"sha": "7beda2cd39085ff19666391bf3ba0cc5a3e3a7da", "filename": "library/core/primitive_docs/io_bufread.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_bufread.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_bufread.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_bufread.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.BufRead.html"}, {"sha": "b7ecf5e273cea7bca8bbabee623f9fc390a3dfbb", "filename": "library/core/primitive_docs/io_read.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_read.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_read.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_read.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.Read.html"}, {"sha": "db0274d291c6f1567805ef557b4a004132fffda7", "filename": "library/core/primitive_docs/io_seek.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_seek.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_seek.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_seek.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.Seek.html"}, {"sha": "92a3b88a79c9c87d1dbb99af3ee8de6acf90c32f", "filename": "library/core/primitive_docs/io_write.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_write.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fio_write.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fio_write.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/io/trait.Write.html"}, {"sha": "4daa10ddbe2b2b0b78b91fb12af56699bbfbeff4", "filename": "library/core/primitive_docs/net_tosocketaddrs.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fnet_tosocketaddrs.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/net/trait.ToSocketAddrs.html"}, {"sha": "cae34d12d5249c6f72fecf85b68321c08651db20", "filename": "library/core/primitive_docs/process_exit.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fprocess_exit.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fprocess_exit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fprocess_exit.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/process/fn.exit.html"}, {"sha": "303dc07b1855df6df4c5743682362da1333febe0", "filename": "library/core/primitive_docs/string_string.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fstring_string.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fprimitive_docs%2Fstring_string.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fprimitive_docs%2Fstring_string.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+../std/string/struct.String.html"}, {"sha": "f14c2a4641627ec4378bad32c91e0b129bd6bbc7", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -2,7 +2,8 @@\n \n #[lang = \"bool\"]\n impl bool {\n-    /// Returns `Some(t)` if the `bool` is [`true`](keyword.true.html), or `None` otherwise.\n+    /// Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html),\n+    /// or `None` otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -18,7 +19,8 @@ impl bool {\n         if self { Some(t) } else { None }\n     }\n \n-    /// Returns `Some(f())` if the `bool` is [`true`](keyword.true.html), or `None` otherwise.\n+    /// Returns `Some(f())` if the `bool` is [`true`](../std/keyword.true.html),\n+    /// or `None` otherwise.\n     ///\n     /// # Examples\n     ///"}, {"sha": "07ffd065118858017c37926a29b1e0fafcea4865", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -96,7 +96,7 @@ impl char {\n     /// Converts a `u32` to a `char`.\n     ///\n     /// Note that all `char`s are valid [`u32`]s, and can be cast to one with\n-    /// [`as`](keyword.as.html):\n+    /// [`as`](../std/keyword.as.html):\n     ///\n     /// ```\n     /// let c = '\ud83d\udcaf';\n@@ -372,7 +372,7 @@ impl char {\n     /// println!(\"\\\\u{{2764}}\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\u2764'.escape_unicode().to_string(), \"\\\\u{2764}\");\n@@ -448,7 +448,7 @@ impl char {\n     /// println!(\"\\\\n\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\\n'.escape_debug().to_string(), \"\\\\n\");\n@@ -502,7 +502,7 @@ impl char {\n     /// println!(\"\\\\\\\"\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('\"'.escape_default().to_string(), \"\\\\\\\"\");\n@@ -937,7 +937,7 @@ impl char {\n     /// println!(\"i\\u{307}\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('C'.to_lowercase().to_string(), \"c\");\n@@ -1002,7 +1002,7 @@ impl char {\n     /// println!(\"SS\");\n     /// ```\n     ///\n-    /// Using [`to_string`](string/trait.ToString.html#tymethod.to_string):\n+    /// Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):\n     ///\n     /// ```\n     /// assert_eq!('c'.to_uppercase().to_string(), \"C\");"}, {"sha": "265ba9f1bb91b69d1fc9c2b162b4a18a03db34d9", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -130,6 +130,7 @@\n #![feature(decl_macro)]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]\n+#![feature(doc_primitive)]\n #![feature(exhaustive_patterns)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n@@ -355,3 +356,5 @@ pub mod arch {\n         /* compiler built-in */\n     }\n }\n+\n+include!(\"primitive_docs.rs\");"}, {"sha": "0de9126dab2fe5679ea2390903a0c1e3293e59a4", "filename": "library/core/src/primitive_docs.rs", "status": "added", "additions": 1307, "deletions": 0, "changes": 1307, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1,1307 @@\n+// `library/{std,core}/src/primitive_docs.rs` should have the same contents.\n+// These are different files so that relative links work properly without\n+// having to have `CARGO_PKG_NAME` set, but conceptually they should always be the same.\n+#[doc(primitive = \"bool\")]\n+#[doc(alias = \"true\")]\n+#[doc(alias = \"false\")]\n+/// The boolean type.\n+///\n+/// The `bool` represents a value, which could only be either [`true`] or [`false`]. If you cast\n+/// a `bool` into an integer, [`true`] will be 1 and [`false`] will be 0.\n+///\n+/// # Basic usage\n+///\n+/// `bool` implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc.,\n+/// which allow us to perform boolean operations using `&`, `|` and `!`.\n+///\n+/// [`if`] requires a `bool` value as its conditional. [`assert!`], which is an\n+/// important macro in testing, checks whether an expression is [`true`] and panics\n+/// if it isn't.\n+///\n+/// ```\n+/// let bool_val = true & false | false;\n+/// assert!(!bool_val);\n+/// ```\n+///\n+/// [`true`]: ../std/keyword.true.html\n+/// [`false`]: ../std/keyword.false.html\n+/// [`BitAnd`]: ops::BitAnd\n+/// [`BitOr`]: ops::BitOr\n+/// [`Not`]: ops::Not\n+/// [`if`]: ../std/keyword.if.html\n+///\n+/// # Examples\n+///\n+/// A trivial example of the usage of `bool`:\n+///\n+/// ```\n+/// let praise_the_borrow_checker = true;\n+///\n+/// // using the `if` conditional\n+/// if praise_the_borrow_checker {\n+///     println!(\"oh, yeah!\");\n+/// } else {\n+///     println!(\"what?!!\");\n+/// }\n+///\n+/// // ... or, a match pattern\n+/// match praise_the_borrow_checker {\n+///     true => println!(\"keep praising!\"),\n+///     false => println!(\"you should praise!\"),\n+/// }\n+/// ```\n+///\n+/// Also, since `bool` implements the [`Copy`] trait, we don't\n+/// have to worry about the move semantics (just like the integer and float primitives).\n+///\n+/// Now an example of `bool` cast to integer type:\n+///\n+/// ```\n+/// assert_eq!(true as i32, 1);\n+/// assert_eq!(false as i32, 0);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_bool {}\n+\n+#[doc(primitive = \"never\")]\n+#[doc(alias = \"!\")]\n+//\n+/// The `!` type, also called \"never\".\n+///\n+/// `!` represents the type of computations which never resolve to any value at all. For example,\n+/// the [`exit`] function `fn exit(code: i32) -> !` exits the process without ever returning, and\n+/// so returns `!`.\n+///\n+/// `break`, `continue` and `return` expressions also have type `!`. For example we are allowed to\n+/// write:\n+///\n+/// ```\n+/// #![feature(never_type)]\n+/// # fn foo() -> u32 {\n+/// let x: ! = {\n+///     return 123\n+/// };\n+/// # }\n+/// ```\n+///\n+/// Although the `let` is pointless here, it illustrates the meaning of `!`. Since `x` is never\n+/// assigned a value (because `return` returns from the entire function), `x` can be given type\n+/// `!`. We could also replace `return 123` with a `panic!` or a never-ending `loop` and this code\n+/// would still be valid.\n+///\n+/// A more realistic usage of `!` is in this code:\n+///\n+/// ```\n+/// # fn get_a_number() -> Option<u32> { None }\n+/// # loop {\n+/// let num: u32 = match get_a_number() {\n+///     Some(num) => num,\n+///     None => break,\n+/// };\n+/// # }\n+/// ```\n+///\n+/// Both match arms must produce values of type [`u32`], but since `break` never produces a value\n+/// at all we know it can never produce a value which isn't a [`u32`]. This illustrates another\n+/// behaviour of the `!` type - expressions with type `!` will coerce into any other type.\n+///\n+/// [`u32`]: prim@u32\n+#[doc = concat!(\"[`exit`]: \", include_str!(\"../primitive_docs/process_exit.md\"))]\n+///\n+/// # `!` and generics\n+///\n+/// ## Infallible errors\n+///\n+/// The main place you'll see `!` used explicitly is in generic code. Consider the [`FromStr`]\n+/// trait:\n+///\n+/// ```\n+/// trait FromStr: Sized {\n+///     type Err;\n+///     fn from_str(s: &str) -> Result<Self, Self::Err>;\n+/// }\n+/// ```\n+///\n+/// When implementing this trait for [`String`] we need to pick a type for [`Err`]. And since\n+/// converting a string into a string will never result in an error, the appropriate type is `!`.\n+/// (Currently the type actually used is an enum with no variants, though this is only because `!`\n+/// was added to Rust at a later date and it may change in the future.) With an [`Err`] type of\n+/// `!`, if we have to call [`String::from_str`] for some reason the result will be a\n+/// [`Result<String, !>`] which we can unpack like this:\n+///\n+/// ```\n+/// #![feature(exhaustive_patterns)]\n+/// use std::str::FromStr;\n+/// let Ok(s) = String::from_str(\"hello\");\n+/// ```\n+///\n+/// Since the [`Err`] variant contains a `!`, it can never occur. If the `exhaustive_patterns`\n+/// feature is present this means we can exhaustively match on [`Result<T, !>`] by just taking the\n+/// [`Ok`] variant. This illustrates another behaviour of `!` - it can be used to \"delete\" certain\n+/// enum variants from generic types like `Result`.\n+///\n+/// ## Infinite loops\n+///\n+/// While [`Result<T, !>`] is very useful for removing errors, `!` can also be used to remove\n+/// successes as well. If we think of [`Result<T, !>`] as \"if this function returns, it has not\n+/// errored,\" we get a very intuitive idea of [`Result<!, E>`] as well: if the function returns, it\n+/// *has* errored.\n+///\n+/// For example, consider the case of a simple web server, which can be simplified to:\n+///\n+/// ```ignore (hypothetical-example)\n+/// loop {\n+///     let (client, request) = get_request().expect(\"disconnected\");\n+///     let response = request.process();\n+///     response.send(client);\n+/// }\n+/// ```\n+///\n+/// Currently, this isn't ideal, because we simply panic whenever we fail to get a new connection.\n+/// Instead, we'd like to keep track of this error, like this:\n+///\n+/// ```ignore (hypothetical-example)\n+/// loop {\n+///     match get_request() {\n+///         Err(err) => break err,\n+///         Ok((client, request)) => {\n+///             let response = request.process();\n+///             response.send(client);\n+///         },\n+///     }\n+/// }\n+/// ```\n+///\n+/// Now, when the server disconnects, we exit the loop with an error instead of panicking. While it\n+/// might be intuitive to simply return the error, we might want to wrap it in a [`Result<!, E>`]\n+/// instead:\n+///\n+/// ```ignore (hypothetical-example)\n+/// fn server_loop() -> Result<!, ConnectionError> {\n+///     loop {\n+///         let (client, request) = get_request()?;\n+///         let response = request.process();\n+///         response.send(client);\n+///     }\n+/// }\n+/// ```\n+///\n+/// Now, we can use `?` instead of `match`, and the return type makes a lot more sense: if the loop\n+/// ever stops, it means that an error occurred. We don't even have to wrap the loop in an `Ok`\n+/// because `!` coerces to `Result<!, ConnectionError>` automatically.\n+///\n+/// [`String::from_str`]: str::FromStr::from_str\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n+/// [`FromStr`]: str::FromStr\n+///\n+/// # `!` and traits\n+///\n+/// When writing your own traits, `!` should have an `impl` whenever there is an obvious `impl`\n+/// which doesn't `panic!`. The reason is that functions returning an `impl Trait` where `!`\n+/// does not have an `impl` of `Trait` cannot diverge as their only possible code path. In other\n+/// words, they can't return `!` from every code path. As an example, this code doesn't compile:\n+///\n+/// ```compile_fail\n+/// use std::ops::Add;\n+///\n+/// fn foo() -> impl Add<u32> {\n+///     unimplemented!()\n+/// }\n+/// ```\n+///\n+/// But this code does:\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// fn foo() -> impl Add<u32> {\n+///     if true {\n+///         unimplemented!()\n+///     } else {\n+///         0\n+///     }\n+/// }\n+/// ```\n+///\n+/// The reason is that, in the first example, there are many possible types that `!` could coerce\n+/// to, because many types implement `Add<u32>`. However, in the second example,\n+/// the `else` branch returns a `0`, which the compiler infers from the return type to be of type\n+/// `u32`. Since `u32` is a concrete type, `!` can and will be coerced to it. See issue [#36375]\n+/// for more information on this quirk of `!`.\n+///\n+/// [#36375]: https://github.com/rust-lang/rust/issues/36375\n+///\n+/// As it turns out, though, most traits can have an `impl` for `!`. Take [`Debug`]\n+/// for example:\n+///\n+/// ```\n+/// #![feature(never_type)]\n+/// # use std::fmt;\n+/// # trait Debug {\n+/// #     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result;\n+/// # }\n+/// impl Debug for ! {\n+///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         *self\n+///     }\n+/// }\n+/// ```\n+///\n+/// Once again we're using `!`'s ability to coerce into any other type, in this case\n+/// [`fmt::Result`]. Since this method takes a `&!` as an argument we know that it can never be\n+/// called (because there is no value of type `!` for it to be called with). Writing `*self`\n+/// essentially tells the compiler \"We know that this code can never be run, so just treat the\n+/// entire function body as having type [`fmt::Result`]\". This pattern can be used a lot when\n+/// implementing traits for `!`. Generally, any trait which only has methods which take a `self`\n+/// parameter should have such an impl.\n+///\n+/// On the other hand, one trait which would not be appropriate to implement is [`Default`]:\n+///\n+/// ```\n+/// trait Default {\n+///     fn default() -> Self;\n+/// }\n+/// ```\n+///\n+/// Since `!` has no values, it has no default value either. It's true that we could write an\n+/// `impl` for this which simply panics, but the same is true for any type (we could `impl\n+/// Default` for (eg.) [`File`] by just making [`default()`] panic.)\n+///\n+#[doc = concat!(\"[`File`]: \", include_str!(\"../primitive_docs/fs_file.md\"))]\n+/// [`Debug`]: fmt::Debug\n+/// [`default()`]: Default::default\n+///\n+#[unstable(feature = \"never_type\", issue = \"35121\")]\n+mod prim_never {}\n+\n+#[doc(primitive = \"char\")]\n+/// A character type.\n+///\n+/// The `char` type represents a single character. More specifically, since\n+/// 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n+/// scalar value]', which is similar to, but not the same as, a '[Unicode code\n+/// point]'.\n+///\n+/// [Unicode scalar value]: https://www.unicode.org/glossary/#unicode_scalar_value\n+/// [Unicode code point]: https://www.unicode.org/glossary/#code_point\n+///\n+/// This documentation describes a number of methods and trait implementations on the\n+/// `char` type. For technical reasons, there is additional, separate\n+/// documentation in [the `std::char` module](char/index.html) as well.\n+///\n+/// # Representation\n+///\n+/// `char` is always four bytes in size. This is a different representation than\n+/// a given character would have as part of a [`String`]. For example:\n+///\n+/// ```\n+/// let v = vec!['h', 'e', 'l', 'l', 'o'];\n+///\n+/// // five elements times four bytes for each element\n+/// assert_eq!(20, v.len() * std::mem::size_of::<char>());\n+///\n+/// let s = String::from(\"hello\");\n+///\n+/// // five elements times one byte per element\n+/// assert_eq!(5, s.len() * std::mem::size_of::<u8>());\n+/// ```\n+///\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n+///\n+/// As always, remember that a human intuition for 'character' might not map to\n+/// Unicode's definitions. For example, despite looking similar, the '\u00e9'\n+/// character is one Unicode code point while 'e\u0301' is two Unicode code points:\n+///\n+/// ```\n+/// let mut chars = \"\u00e9\".chars();\n+/// // U+00e9: 'latin small letter e with acute'\n+/// assert_eq!(Some('\\u{00e9}'), chars.next());\n+/// assert_eq!(None, chars.next());\n+///\n+/// let mut chars = \"e\u0301\".chars();\n+/// // U+0065: 'latin small letter e'\n+/// assert_eq!(Some('\\u{0065}'), chars.next());\n+/// // U+0301: 'combining acute accent'\n+/// assert_eq!(Some('\\u{0301}'), chars.next());\n+/// assert_eq!(None, chars.next());\n+/// ```\n+///\n+/// This means that the contents of the first string above _will_ fit into a\n+/// `char` while the contents of the second string _will not_. Trying to create\n+/// a `char` literal with the contents of the second string gives an error:\n+///\n+/// ```text\n+/// error: character literal may only contain one codepoint: 'e\u0301'\n+/// let c = 'e\u0301';\n+///         ^^^\n+/// ```\n+///\n+/// Another implication of the 4-byte fixed size of a `char` is that\n+/// per-`char` processing can end up using a lot more memory:\n+///\n+/// ```\n+/// let s = String::from(\"love: \u2764\ufe0f\");\n+/// let v: Vec<char> = s.chars().collect();\n+///\n+/// assert_eq!(12, std::mem::size_of_val(&s[..]));\n+/// assert_eq!(32, std::mem::size_of_val(&v[..]));\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_char {}\n+\n+#[doc(primitive = \"unit\")]\n+#[doc(alias = \"(\")]\n+#[doc(alias = \")\")]\n+#[doc(alias = \"()\")]\n+//\n+/// The `()` type, also called \"unit\".\n+///\n+/// The `()` type has exactly one value `()`, and is used when there\n+/// is no other meaningful value that could be returned. `()` is most\n+/// commonly seen implicitly: functions without a `-> ...` implicitly\n+/// have return type `()`, that is, these are equivalent:\n+///\n+/// ```rust\n+/// fn long() -> () {}\n+///\n+/// fn short() {}\n+/// ```\n+///\n+/// The semicolon `;` can be used to discard the result of an\n+/// expression at the end of a block, making the expression (and thus\n+/// the block) evaluate to `()`. For example,\n+///\n+/// ```rust\n+/// fn returns_i64() -> i64 {\n+///     1i64\n+/// }\n+/// fn returns_unit() {\n+///     1i64;\n+/// }\n+///\n+/// let is_i64 = {\n+///     returns_i64()\n+/// };\n+/// let is_unit = {\n+///     returns_i64();\n+/// };\n+/// ```\n+///\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_unit {}\n+\n+#[doc(primitive = \"pointer\")]\n+#[doc(alias = \"ptr\")]\n+#[doc(alias = \"*\")]\n+#[doc(alias = \"*const\")]\n+#[doc(alias = \"*mut\")]\n+//\n+/// Raw, unsafe pointers, `*const T`, and `*mut T`.\n+///\n+/// *[See also the `std::ptr` module](ptr).*\n+///\n+/// Working with raw pointers in Rust is uncommon, typically limited to a few patterns.\n+/// Raw pointers can be unaligned or [`null`]. However, when a raw pointer is\n+/// dereferenced (using the `*` operator), it must be non-null and aligned.\n+///\n+/// Storing through a raw pointer using `*ptr = data` calls `drop` on the old value, so\n+/// [`write`] must be used if the type has drop glue and memory is not already\n+/// initialized - otherwise `drop` would be called on the uninitialized memory.\n+///\n+/// Use the [`null`] and [`null_mut`] functions to create null pointers, and the\n+/// [`is_null`] method of the `*const T` and `*mut T` types to check for null.\n+/// The `*const T` and `*mut T` types also define the [`offset`] method, for\n+/// pointer math.\n+///\n+/// # Common ways to create raw pointers\n+///\n+/// ## 1. Coerce a reference (`&T`) or mutable reference (`&mut T`).\n+///\n+/// ```\n+/// let my_num: i32 = 10;\n+/// let my_num_ptr: *const i32 = &my_num;\n+/// let mut my_speed: i32 = 88;\n+/// let my_speed_ptr: *mut i32 = &mut my_speed;\n+/// ```\n+///\n+/// To get a pointer to a boxed value, dereference the box:\n+///\n+/// ```\n+/// let my_num: Box<i32> = Box::new(10);\n+/// let my_num_ptr: *const i32 = &*my_num;\n+/// let mut my_speed: Box<i32> = Box::new(88);\n+/// let my_speed_ptr: *mut i32 = &mut *my_speed;\n+/// ```\n+///\n+/// This does not take ownership of the original allocation\n+/// and requires no resource management later,\n+/// but you must not use the pointer after its lifetime.\n+///\n+/// ## 2. Consume a box (`Box<T>`).\n+///\n+/// The [`into_raw`] function consumes a box and returns\n+/// the raw pointer. It doesn't destroy `T` or deallocate any memory.\n+///\n+/// ```\n+/// let my_speed: Box<i32> = Box::new(88);\n+/// let my_speed: *mut i32 = Box::into_raw(my_speed);\n+///\n+/// // By taking ownership of the original `Box<T>` though\n+/// // we are obligated to put it together later to be destroyed.\n+/// unsafe {\n+///     drop(Box::from_raw(my_speed));\n+/// }\n+/// ```\n+///\n+/// Note that here the call to [`drop`] is for clarity - it indicates\n+/// that we are done with the given value and it should be destroyed.\n+///\n+/// ## 3. Create it using `ptr::addr_of!`\n+///\n+/// Instead of coercing a reference to a raw pointer, you can use the macros\n+/// [`ptr::addr_of!`] (for `*const T`) and [`ptr::addr_of_mut!`] (for `*mut T`).\n+/// These macros allow you to create raw pointers to fields to which you cannot\n+/// create a reference (without causing undefined behaviour), such as an\n+/// unaligned field. This might be necessary if packed structs or uninitialized\n+/// memory is involved.\n+///\n+/// ```\n+/// #[derive(Debug, Default, Copy, Clone)]\n+/// #[repr(C, packed)]\n+/// struct S {\n+///     aligned: u8,\n+///     unaligned: u32,\n+/// }\n+/// let s = S::default();\n+/// let p = std::ptr::addr_of!(s.unaligned); // not allowed with coercion\n+/// ```\n+///\n+/// ## 4. Get it from C.\n+///\n+/// ```\n+/// # #![feature(rustc_private)]\n+/// extern crate libc;\n+///\n+/// use std::mem;\n+///\n+/// unsafe {\n+///     let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>()) as *mut i32;\n+///     if my_num.is_null() {\n+///         panic!(\"failed to allocate memory\");\n+///     }\n+///     libc::free(my_num as *mut libc::c_void);\n+/// }\n+/// ```\n+///\n+/// Usually you wouldn't literally use `malloc` and `free` from Rust,\n+/// but C APIs hand out a lot of pointers generally, so are a common source\n+/// of raw pointers in Rust.\n+///\n+/// [`null`]: ptr::null\n+/// [`null_mut`]: ptr::null_mut\n+/// [`is_null`]: pointer::is_null\n+/// [`offset`]: pointer::offset\n+#[doc = concat!(\"[`into_raw`]: \", include_str!(\"../primitive_docs/box_into_raw.md\"))]\n+/// [`drop`]: mem::drop\n+/// [`write`]: ptr::write\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_pointer {}\n+\n+#[doc(primitive = \"array\")]\n+#[doc(alias = \"[]\")]\n+#[doc(alias = \"[T;N]\")] // unfortunately, rustdoc doesn't have fuzzy search for aliases\n+#[doc(alias = \"[T; N]\")]\n+/// A fixed-size array, denoted `[T; N]`, for the element type, `T`, and the\n+/// non-negative compile-time constant size, `N`.\n+///\n+/// There are two syntactic forms for creating an array:\n+///\n+/// * A list with each element, i.e., `[x, y, z]`.\n+/// * A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.\n+///   The type of `x` must be [`Copy`].\n+///\n+/// Note that `[expr; 0]` is allowed, and produces an empty array.\n+/// This will still evaluate `expr`, however, and immediately drop the resulting value, so\n+/// be mindful of side effects.\n+///\n+/// Arrays of *any* size implement the following traits if the element type allows it:\n+///\n+/// - [`Copy`]\n+/// - [`Clone`]\n+/// - [`Debug`]\n+/// - [`IntoIterator`] (implemented for `[T; N]`, `&[T; N]` and `&mut [T; N]`)\n+/// - [`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`]\n+/// - [`Hash`]\n+/// - [`AsRef`], [`AsMut`]\n+/// - [`Borrow`], [`BorrowMut`]\n+///\n+/// Arrays of sizes from 0 to 32 (inclusive) implement the [`Default`] trait\n+/// if the element type allows it. As a stopgap, trait implementations are\n+/// statically generated up to size 32.\n+///\n+/// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n+/// an array. Indeed, this provides most of the API for working with arrays.\n+/// Slices have a dynamic size and do not coerce to arrays.\n+///\n+/// You can move elements out of an array with a [slice pattern]. If you want\n+/// one element, see [`mem::replace`].\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let mut array: [i32; 3] = [0; 3];\n+///\n+/// array[1] = 1;\n+/// array[2] = 2;\n+///\n+/// assert_eq!([1, 2], &array[1..]);\n+///\n+/// // This loop prints: 0 1 2\n+/// for x in array {\n+///     print!(\"{} \", x);\n+/// }\n+/// ```\n+///\n+/// You can also iterate over reference to the array's elements:\n+///\n+/// ```\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// for x in &array { }\n+/// ```\n+///\n+/// You can use a [slice pattern] to move elements out of an array:\n+///\n+/// ```\n+/// fn move_away(_: String) { /* Do interesting things. */ }\n+///\n+/// let [john, roa] = [\"John\".to_string(), \"Roa\".to_string()];\n+/// move_away(john);\n+/// move_away(roa);\n+/// ```\n+///\n+/// # Editions\n+///\n+/// Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call\n+/// `array.into_iter()` auto-referenced into a [slice iterator](slice::iter). Right now, the old\n+/// behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring\n+/// [`IntoIterator`] by value. In the future, the behavior on the 2015 and 2018 edition\n+/// might be made consistent to the behavior of later editions.\n+///\n+/// ```rust,edition2018\n+/// // Rust 2015 and 2018:\n+///\n+/// # #![allow(array_into_iter)] // override our `deny(warnings)`\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// // This creates a slice iterator, producing references to each value.\n+/// for item in array.into_iter().enumerate() {\n+///     let (i, x): (usize, &i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+///\n+/// // The `array_into_iter` lint suggests this change for future compatibility:\n+/// for item in array.iter().enumerate() {\n+///     let (i, x): (usize, &i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+///\n+/// // You can explicitly iterate an array by value using\n+/// // `IntoIterator::into_iter` or `std::array::IntoIter::new`:\n+/// for item in IntoIterator::into_iter(array).enumerate() {\n+///     let (i, x): (usize, i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+/// ```\n+///\n+/// Starting in the 2021 edition, `array.into_iter()` uses `IntoIterator` normally to iterate\n+/// by value, and `iter()` should be used to iterate by reference like previous editions.\n+///\n+/// ```rust,edition2021\n+/// // Rust 2021:\n+///\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// // This iterates by reference:\n+/// for item in array.iter().enumerate() {\n+///     let (i, x): (usize, &i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+///\n+/// // This iterates by value:\n+/// for item in array.into_iter().enumerate() {\n+///     let (i, x): (usize, i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+/// ```\n+///\n+/// Future language versions might start treating the `array.into_iter()`\n+/// syntax on editions 2015 and 2018 the same as on edition 2021. So code using\n+/// those older editions should still be written with this change in mind, to\n+/// prevent breakage in the future. The safest way to accomplish this is to\n+/// avoid the `into_iter` syntax on those editions. If an edition update is not\n+/// viable/desired, there are multiple alternatives:\n+/// * use `iter`, equivalent to the old behavior, creating references\n+/// * use [`IntoIterator::into_iter`], equivalent to the post-2021 behavior (Rust 1.53+)\n+/// * replace `for ... in array.into_iter() {` with `for ... in array {`,\n+///   equivalent to the post-2021 behavior (Rust 1.53+)\n+///\n+/// ```rust,edition2018\n+/// // Rust 2015 and 2018:\n+///\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// // This iterates by reference:\n+/// for item in array.iter() {\n+///     let x: &i32 = item;\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // This iterates by value:\n+/// for item in IntoIterator::into_iter(array) {\n+///     let x: i32 = item;\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // This iterates by value:\n+/// for item in array {\n+///     let x: i32 = item;\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // IntoIter can also start a chain.\n+/// // This iterates by value:\n+/// for item in IntoIterator::into_iter(array).enumerate() {\n+///     let (i, x): (usize, i32) = item;\n+///     println!(\"array[{}] = {}\", i, x);\n+/// }\n+/// ```\n+///\n+/// [slice]: prim@slice\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n+/// [`Borrow`]: borrow::Borrow\n+/// [`BorrowMut`]: borrow::BorrowMut\n+/// [slice pattern]: ../reference/patterns.html#slice-patterns\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_array {}\n+\n+#[doc(primitive = \"slice\")]\n+#[doc(alias = \"[\")]\n+#[doc(alias = \"]\")]\n+#[doc(alias = \"[]\")]\n+/// A dynamically-sized view into a contiguous sequence, `[T]`. Contiguous here\n+/// means that elements are laid out so that every element is the same\n+/// distance from its neighbors.\n+///\n+/// *[See also the `std::slice` module](crate::slice).*\n+///\n+/// Slices are a view into a block of memory represented as a pointer and a\n+/// length.\n+///\n+/// ```\n+/// // slicing a Vec\n+/// let vec = vec![1, 2, 3];\n+/// let int_slice = &vec[..];\n+/// // coercing an array to a slice\n+/// let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n+/// ```\n+///\n+/// Slices are either mutable or shared. The shared slice type is `&[T]`,\n+/// while the mutable slice type is `&mut [T]`, where `T` represents the element\n+/// type. For example, you can mutate the block of memory that a mutable slice\n+/// points to:\n+///\n+/// ```\n+/// let mut x = [1, 2, 3];\n+/// let x = &mut x[..]; // Take a full slice of `x`.\n+/// x[1] = 7;\n+/// assert_eq!(x, &[1, 7, 3]);\n+/// ```\n+///\n+/// As slices store the length of the sequence they refer to, they have twice\n+/// the size of pointers to [`Sized`](marker/trait.Sized.html) types.\n+/// Also see the reference on\n+/// [dynamically sized types](../reference/dynamically-sized-types.html).\n+///\n+/// ```\n+/// # use std::rc::Rc;\n+/// let pointer_size = std::mem::size_of::<&u8>();\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<&[u8]>());\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<*const [u8]>());\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<Box<[u8]>>());\n+/// assert_eq!(2 * pointer_size, std::mem::size_of::<Rc<[u8]>>());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_slice {}\n+\n+#[doc(primitive = \"str\")]\n+//\n+/// String slices.\n+///\n+/// *[See also the `std::str` module](crate::str).*\n+///\n+/// The `str` type, also called a 'string slice', is the most primitive string\n+/// type. It is usually seen in its borrowed form, `&str`. It is also the type\n+/// of string literals, `&'static str`.\n+///\n+/// String slices are always valid UTF-8.\n+///\n+/// # Examples\n+///\n+/// String literals are string slices:\n+///\n+/// ```\n+/// let hello = \"Hello, world!\";\n+///\n+/// // with an explicit type annotation\n+/// let hello: &'static str = \"Hello, world!\";\n+/// ```\n+///\n+/// They are `'static` because they're stored directly in the final binary, and\n+/// so will be valid for the `'static` duration.\n+///\n+/// # Representation\n+///\n+/// A `&str` is made up of two components: a pointer to some bytes, and a\n+/// length. You can look at these with the [`as_ptr`] and [`len`] methods:\n+///\n+/// ```\n+/// use std::slice;\n+/// use std::str;\n+///\n+/// let story = \"Once upon a time...\";\n+///\n+/// let ptr = story.as_ptr();\n+/// let len = story.len();\n+///\n+/// // story has nineteen bytes\n+/// assert_eq!(19, len);\n+///\n+/// // We can re-build a str out of ptr and len. This is all unsafe because\n+/// // we are responsible for making sure the two components are valid:\n+/// let s = unsafe {\n+///     // First, we build a &[u8]...\n+///     let slice = slice::from_raw_parts(ptr, len);\n+///\n+///     // ... and then convert that slice into a string slice\n+///     str::from_utf8(slice)\n+/// };\n+///\n+/// assert_eq!(s, Ok(story));\n+/// ```\n+///\n+/// [`as_ptr`]: str::as_ptr\n+/// [`len`]: str::len\n+///\n+/// Note: This example shows the internals of `&str`. `unsafe` should not be\n+/// used to get a string slice under normal circumstances. Use `as_str`\n+/// instead.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_str {}\n+\n+#[doc(primitive = \"tuple\")]\n+#[doc(alias = \"(\")]\n+#[doc(alias = \")\")]\n+#[doc(alias = \"()\")]\n+//\n+/// A finite heterogeneous sequence, `(T, U, ..)`.\n+///\n+/// Let's cover each of those in turn:\n+///\n+/// Tuples are *finite*. In other words, a tuple has a length. Here's a tuple\n+/// of length `3`:\n+///\n+/// ```\n+/// (\"hello\", 5, 'c');\n+/// ```\n+///\n+/// 'Length' is also sometimes called 'arity' here; each tuple of a different\n+/// length is a different, distinct type.\n+///\n+/// Tuples are *heterogeneous*. This means that each element of the tuple can\n+/// have a different type. In that tuple above, it has the type:\n+///\n+/// ```\n+/// # let _:\n+/// (&'static str, i32, char)\n+/// # = (\"hello\", 5, 'c');\n+/// ```\n+///\n+/// Tuples are a *sequence*. This means that they can be accessed by position;\n+/// this is called 'tuple indexing', and it looks like this:\n+///\n+/// ```rust\n+/// let tuple = (\"hello\", 5, 'c');\n+///\n+/// assert_eq!(tuple.0, \"hello\");\n+/// assert_eq!(tuple.1, 5);\n+/// assert_eq!(tuple.2, 'c');\n+/// ```\n+///\n+/// The sequential nature of the tuple applies to its implementations of various\n+/// traits. For example, in [`PartialOrd`] and [`Ord`], the elements are compared\n+/// sequentially until the first non-equal set is found.\n+///\n+/// For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).\n+///\n+/// # Trait implementations\n+///\n+/// If every type inside a tuple implements one of the following traits, then a\n+/// tuple itself also implements it.\n+///\n+/// * [`Clone`]\n+/// * [`Copy`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`Debug`]\n+/// * [`Default`]\n+/// * [`Hash`]\n+///\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only\n+/// implemented on tuples of arity 12 or less. In the future, this may change.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let tuple = (\"hello\", 5, 'c');\n+///\n+/// assert_eq!(tuple.0, \"hello\");\n+/// ```\n+///\n+/// Tuples are often used as a return type when you want to return more than\n+/// one value:\n+///\n+/// ```\n+/// fn calculate_point() -> (i32, i32) {\n+///     // Don't do a calculation, that's not the point of the example\n+///     (4, 5)\n+/// }\n+///\n+/// let point = calculate_point();\n+///\n+/// assert_eq!(point.0, 4);\n+/// assert_eq!(point.1, 5);\n+///\n+/// // Combining this with patterns can be nicer.\n+///\n+/// let (x, y) = calculate_point();\n+///\n+/// assert_eq!(x, 4);\n+/// assert_eq!(y, 5);\n+/// ```\n+///\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_tuple {}\n+\n+#[doc(primitive = \"f32\")]\n+/// A 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).\n+///\n+/// This type can represent a wide range of decimal numbers, like `3.5`, `27`,\n+/// `-113.75`, `0.0078125`, `34359738368`, `0`, `-1`. So unlike integer types\n+/// (such as `i32`), floating point types can represent non-integer numbers,\n+/// too.\n+///\n+/// However, being able to represent this wide range of numbers comes at the\n+/// cost of precision: floats can only represent some of the real numbers and\n+/// calculation with floats round to a nearby representable number. For example,\n+/// `5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results\n+/// in `0.20000000298023223876953125` since `0.2` cannot be exactly represented\n+/// as `f32`. Note, however, that printing floats with `println` and friends will\n+/// often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will\n+/// print `0.2`.\n+///\n+/// Additionally, `f32` can represent some special values:\n+///\n+/// - \u22120.0: IEEE 754 floating point numbers have a bit that indicates their sign, so \u22120.0 is a\n+///   possible value. For comparison \u22120.0 = +0.0, but floating point operations can carry\n+///   the sign bit through arithmetic operations. This means \u22120.0 \u00d7 +0.0 produces \u22120.0 and\n+///   a negative number rounded to a value smaller than a float can represent also produces \u22120.0.\n+/// - [\u221e](#associatedconstant.INFINITY) and\n+///   [\u2212\u221e](#associatedconstant.NEG_INFINITY): these result from calculations\n+///   like `1.0 / 0.0`.\n+/// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n+///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n+///   behavior: it is unequal to any float, including itself! It is also neither\n+///   smaller nor greater than any float, making it impossible to sort. Lastly,\n+///   it is considered infectious as almost all calculations where one of the\n+///   operands is NaN will also result in NaN.\n+///\n+/// For more information on floating point numbers, see [Wikipedia][wikipedia].\n+///\n+/// *[See also the `std::f32::consts` module](crate::f32::consts).*\n+///\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_f32 {}\n+\n+#[doc(primitive = \"f64\")]\n+/// A 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).\n+///\n+/// This type is very similar to [`f32`], but has increased\n+/// precision by using twice as many bits. Please see [the documentation for\n+/// `f32`][`f32`] or [Wikipedia on double precision\n+/// values][wikipedia] for more information.\n+///\n+/// *[See also the `std::f64::consts` module](crate::f64::consts).*\n+///\n+/// [`f32`]: prim@f32\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_f64 {}\n+\n+#[doc(primitive = \"i8\")]\n+//\n+/// The 8-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i8 {}\n+\n+#[doc(primitive = \"i16\")]\n+//\n+/// The 16-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i16 {}\n+\n+#[doc(primitive = \"i32\")]\n+//\n+/// The 32-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i32 {}\n+\n+#[doc(primitive = \"i64\")]\n+//\n+/// The 64-bit signed integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_i64 {}\n+\n+#[doc(primitive = \"i128\")]\n+//\n+/// The 128-bit signed integer type.\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+mod prim_i128 {}\n+\n+#[doc(primitive = \"u8\")]\n+//\n+/// The 8-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u8 {}\n+\n+#[doc(primitive = \"u16\")]\n+//\n+/// The 16-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u16 {}\n+\n+#[doc(primitive = \"u32\")]\n+//\n+/// The 32-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u32 {}\n+\n+#[doc(primitive = \"u64\")]\n+//\n+/// The 64-bit unsigned integer type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_u64 {}\n+\n+#[doc(primitive = \"u128\")]\n+//\n+/// The 128-bit unsigned integer type.\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+mod prim_u128 {}\n+\n+#[doc(primitive = \"isize\")]\n+//\n+/// The pointer-sized signed integer type.\n+///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_isize {}\n+\n+#[doc(primitive = \"usize\")]\n+//\n+/// The pointer-sized unsigned integer type.\n+///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_usize {}\n+\n+#[doc(primitive = \"reference\")]\n+#[doc(alias = \"&\")]\n+#[doc(alias = \"&mut\")]\n+//\n+/// References, both shared and mutable.\n+///\n+/// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n+/// operators on a value, or by using a [`ref`](../std/keyword.ref.html) or\n+/// <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> pattern.\n+///\n+/// For those familiar with pointers, a reference is just a pointer that is assumed to be\n+/// aligned, not null, and pointing to memory containing a valid value of `T` - for example,\n+/// <code>&[bool]</code> can only point to an allocation containing the integer values `1`\n+/// ([`true`](../std/keyword.true.html)) or `0` ([`false`](../std/keyword.false.html)), but\n+/// creating a <code>&[bool]</code> that points to an allocation containing\n+/// the value `3` causes undefined behaviour.\n+/// In fact, <code>[Option]\\<&T></code> has the same memory representation as a\n+/// nullable but aligned pointer, and can be passed across FFI boundaries as such.\n+///\n+/// In most cases, references can be used much like the original value. Field access, method\n+/// calling, and indexing work the same (save for mutability rules, of course). In addition, the\n+/// comparison operators transparently defer to the referent's implementation, allowing references\n+/// to be compared the same as owned values.\n+///\n+/// References have a lifetime attached to them, which represents the scope for which the borrow is\n+/// valid. A lifetime is said to \"outlive\" another one if its representative scope is as long or\n+/// longer than the other. The `'static` lifetime is the longest lifetime, which represents the\n+/// total life of the program. For example, string literals have a `'static` lifetime because the\n+/// text data is embedded into the binary of the program, rather than in an allocation that needs\n+/// to be dynamically managed.\n+///\n+/// `&mut T` references can be freely coerced into `&T` references with the same referent type, and\n+/// references with longer lifetimes can be freely coerced into references with shorter ones.\n+///\n+/// Reference equality by address, instead of comparing the values pointed to, is accomplished via\n+/// implicit reference-pointer coercion and raw pointer equality via [`ptr::eq`], while\n+/// [`PartialEq`] compares values.\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let five = 5;\n+/// let other_five = 5;\n+/// let five_ref = &five;\n+/// let same_five_ref = &five;\n+/// let other_five_ref = &other_five;\n+///\n+/// assert!(five_ref == same_five_ref);\n+/// assert!(five_ref == other_five_ref);\n+///\n+/// assert!(ptr::eq(five_ref, same_five_ref));\n+/// assert!(!ptr::eq(five_ref, other_five_ref));\n+/// ```\n+///\n+/// For more information on how to use references, see [the book's section on \"References and\n+/// Borrowing\"][book-refs].\n+///\n+/// [book-refs]: ../book/ch04-02-references-and-borrowing.html\n+///\n+/// # Trait implementations\n+///\n+/// The following traits are implemented for all `&T`, regardless of the type of its referent:\n+///\n+/// * [`Copy`]\n+/// * [`Clone`] \\(Note that this will not defer to `T`'s `Clone` implementation if it exists!)\n+/// * [`Deref`]\n+/// * [`Borrow`]\n+/// * [`Pointer`]\n+///\n+/// [`Deref`]: ops::Deref\n+/// [`Borrow`]: borrow::Borrow\n+/// [`Pointer`]: fmt::Pointer\n+///\n+/// `&mut T` references get all of the above except `Copy` and `Clone` (to prevent creating\n+/// multiple simultaneous mutable borrows), plus the following, regardless of the type of its\n+/// referent:\n+///\n+/// * [`DerefMut`]\n+/// * [`BorrowMut`]\n+///\n+/// [`DerefMut`]: ops::DerefMut\n+/// [`BorrowMut`]: borrow::BorrowMut\n+/// [bool]: prim@bool\n+///\n+/// The following traits are implemented on `&T` references if the underlying `T` also implements\n+/// that trait:\n+///\n+/// * All the traits in [`std::fmt`] except [`Pointer`] and [`fmt::Write`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`AsRef`]\n+/// * [`Fn`] \\(in addition, `&T` references get [`FnMut`] and [`FnOnce`] if `T: Fn`)\n+/// * [`Hash`]\n+/// * [`ToSocketAddrs`]\n+///\n+/// [`std::fmt`]: fmt\n+/// ['Pointer`]: fmt::Pointer\n+/// [`Hash`]: hash::Hash\n+#[doc = concat!(\"[`ToSocketAddrs`]: \", include_str!(\"../primitive_docs/net_tosocketaddrs.md\"))]\n+///\n+/// `&mut T` references get all of the above except `ToSocketAddrs`, plus the following, if `T`\n+/// implements that trait:\n+///\n+/// * [`AsMut`]\n+/// * [`FnMut`] \\(in addition, `&mut T` references get [`FnOnce`] if `T: FnMut`)\n+/// * [`fmt::Write`]\n+/// * [`Iterator`]\n+/// * [`DoubleEndedIterator`]\n+/// * [`ExactSizeIterator`]\n+/// * [`FusedIterator`]\n+/// * [`TrustedLen`]\n+/// * [`Send`] \\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)\n+/// * [`io::Write`]\n+/// * [`Read`]\n+/// * [`Seek`]\n+/// * [`BufRead`]\n+///\n+/// [`FusedIterator`]: iter::FusedIterator\n+/// [`TrustedLen`]: iter::TrustedLen\n+#[doc = concat!(\"[`Seek`]: \", include_str!(\"../primitive_docs/io_seek.md\"))]\n+#[doc = concat!(\"[`BufRead`]: \", include_str!(\"../primitive_docs/io_bufread.md\"))]\n+#[doc = concat!(\"[`Read`]: \", include_str!(\"../primitive_docs/io_read.md\"))]\n+#[doc = concat!(\"[`io::Write`]: \", include_str!(\"../primitive_docs/io_write.md\"))]\n+///\n+/// Note that due to method call deref coercion, simply calling a trait method will act like they\n+/// work on references as well as they do on owned values! The implementations described here are\n+/// meant for generic contexts, where the final type `T` is a type parameter or otherwise not\n+/// locally known.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_ref {}\n+\n+#[doc(primitive = \"fn\")]\n+//\n+/// Function pointers, like `fn(usize) -> bool`.\n+///\n+/// *See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].*\n+///\n+/// [`Fn`]: ops::Fn\n+/// [`FnMut`]: ops::FnMut\n+/// [`FnOnce`]: ops::FnOnce\n+///\n+/// Function pointers are pointers that point to *code*, not data. They can be called\n+/// just like functions. Like references, function pointers are, among other things, assumed to\n+/// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null\n+/// pointers, make your type [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers)\n+/// with your required signature.\n+///\n+/// ### Safety\n+///\n+/// Plain function pointers are obtained by casting either plain functions, or closures that don't\n+/// capture an environment:\n+///\n+/// ```\n+/// fn add_one(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// let ptr: fn(usize) -> usize = add_one;\n+/// assert_eq!(ptr(5), 6);\n+///\n+/// let clos: fn(usize) -> usize = |x| x + 5;\n+/// assert_eq!(clos(5), 10);\n+/// ```\n+///\n+/// In addition to varying based on their signature, function pointers come in two flavors: safe\n+/// and unsafe. Plain `fn()` function pointers can only point to safe functions,\n+/// while `unsafe fn()` function pointers can point to safe or unsafe functions.\n+///\n+/// ```\n+/// fn add_one(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// unsafe fn add_one_unsafely(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// let safe_ptr: fn(usize) -> usize = add_one;\n+///\n+/// //ERROR: mismatched types: expected normal fn, found unsafe fn\n+/// //let bad_ptr: fn(usize) -> usize = add_one_unsafely;\n+///\n+/// let unsafe_ptr: unsafe fn(usize) -> usize = add_one_unsafely;\n+/// let really_safe_ptr: unsafe fn(usize) -> usize = add_one;\n+/// ```\n+///\n+/// ### ABI\n+///\n+/// On top of that, function pointers can vary based on what ABI they use. This\n+/// is achieved by adding the `extern` keyword before the type, followed by the\n+/// ABI in question. The default ABI is \"Rust\", i.e., `fn()` is the exact same\n+/// type as `extern \"Rust\" fn()`. A pointer to a function with C ABI would have\n+/// type `extern \"C\" fn()`.\n+///\n+/// `extern \"ABI\" { ... }` blocks declare functions with ABI \"ABI\". The default\n+/// here is \"C\", i.e., functions declared in an `extern {...}` block have \"C\"\n+/// ABI.\n+///\n+/// For more information and a list of supported ABIs, see [the nomicon's\n+/// section on foreign calling conventions][nomicon-abi].\n+///\n+/// [nomicon-abi]: ../nomicon/ffi.html#foreign-calling-conventions\n+///\n+/// ### Variadic functions\n+///\n+/// Extern function declarations with the \"C\" or \"cdecl\" ABIs can also be *variadic*, allowing them\n+/// to be called with a variable number of arguments. Normal Rust functions, even those with an\n+/// `extern \"ABI\"`, cannot be variadic. For more information, see [the nomicon's section on\n+/// variadic functions][nomicon-variadic].\n+///\n+/// [nomicon-variadic]: ../nomicon/ffi.html#variadic-functions\n+///\n+/// ### Creating function pointers\n+///\n+/// When `bar` is the name of a function, then the expression `bar` is *not* a\n+/// function pointer. Rather, it denotes a value of an unnameable type that\n+/// uniquely identifies the function `bar`. The value is zero-sized because the\n+/// type already identifies the function. This has the advantage that \"calling\"\n+/// the value (it implements the `Fn*` traits) does not require dynamic\n+/// dispatch.\n+///\n+/// This zero-sized type *coerces* to a regular function pointer. For example:\n+///\n+/// ```rust\n+/// use std::mem;\n+///\n+/// fn bar(x: i32) {}\n+///\n+/// let not_bar_ptr = bar; // `not_bar_ptr` is zero-sized, uniquely identifying `bar`\n+/// assert_eq!(mem::size_of_val(&not_bar_ptr), 0);\n+///\n+/// let bar_ptr: fn(i32) = not_bar_ptr; // force coercion to function pointer\n+/// assert_eq!(mem::size_of_val(&bar_ptr), mem::size_of::<usize>());\n+///\n+/// let footgun = &bar; // this is a shared reference to the zero-sized type identifying `bar`\n+/// ```\n+///\n+/// The last line shows that `&bar` is not a function pointer either. Rather, it\n+/// is a reference to the function-specific ZST. `&bar` is basically never what you\n+/// want when `bar` is a function.\n+///\n+/// ### Traits\n+///\n+/// Function pointers implement the following traits:\n+///\n+/// * [`Clone`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`Hash`]\n+/// * [`Pointer`]\n+/// * [`Debug`]\n+///\n+/// [`Hash`]: hash::Hash\n+/// [`Pointer`]: fmt::Pointer\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n+/// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n+/// may change.\n+///\n+/// In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe*\n+/// function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`]. This works because these traits\n+/// are specially known to the compiler.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_fn {}"}, {"sha": "307b9c85bd67e70420276fc08d49b43c38bb0691", "filename": "library/std/primitive_docs/box_into_raw.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fbox_into_raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fbox_into_raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fbox_into_raw.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+Box::into_raw"}, {"sha": "13e4540835e61884929644f7aae4add33f648f07", "filename": "library/std/primitive_docs/fs_file.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Ffs_file.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Ffs_file.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Ffs_file.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+fs::File"}, {"sha": "bb688e3a5cc874cfa13c226493c3f50de382b2bf", "filename": "library/std/primitive_docs/io_bufread.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_bufread.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_bufread.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_bufread.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+io::BufRead"}, {"sha": "5118d7c4888ab24bc0f4be807b5cd8943bc2557d", "filename": "library/std/primitive_docs/io_read.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_read.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_read.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_read.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+io::Read"}, {"sha": "122e6df77b6d74cd5c6cd3a4c6d8c278f9bf76be", "filename": "library/std/primitive_docs/io_seek.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_seek.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_seek.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_seek.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+io::Seek"}, {"sha": "15dfc907a65553ccebac45fa8301d4b74960ee4a", "filename": "library/std/primitive_docs/io_write.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_write.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fio_write.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fio_write.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+io::Write"}, {"sha": "a01f318e887715479d074b29fa0a00d50e786f32", "filename": "library/std/primitive_docs/net_tosocketaddrs.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fnet_tosocketaddrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fnet_tosocketaddrs.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+net::ToSocketAddrs"}, {"sha": "565a71375cd0e58da40cfadb025a5d1c704f4f8c", "filename": "library/std/primitive_docs/process_exit.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fprocess_exit.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fprocess_exit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fprocess_exit.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+process::exit"}, {"sha": "ce7815ff91b9e50390753482015fda8f94d507fb", "filename": "library/std/primitive_docs/string_string.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fstring_string.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fprimitive_docs%2Fstring_string.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fprimitive_docs%2Fstring_string.md?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1 @@\n+string::String"}, {"sha": "0de9126dab2fe5679ea2390903a0c1e3293e59a4", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -1,3 +1,6 @@\n+// `library/{std,core}/src/primitive_docs.rs` should have the same contents.\n+// These are different files so that relative links work properly without\n+// having to have `CARGO_PKG_NAME` set, but conceptually they should always be the same.\n #[doc(primitive = \"bool\")]\n #[doc(alias = \"true\")]\n #[doc(alias = \"false\")]\n@@ -20,12 +23,12 @@\n /// assert!(!bool_val);\n /// ```\n ///\n-/// [`true`]: keyword.true.html\n-/// [`false`]: keyword.false.html\n+/// [`true`]: ../std/keyword.true.html\n+/// [`false`]: ../std/keyword.false.html\n /// [`BitAnd`]: ops::BitAnd\n /// [`BitOr`]: ops::BitOr\n /// [`Not`]: ops::Not\n-/// [`if`]: keyword.if.html\n+/// [`if`]: ../std/keyword.if.html\n ///\n /// # Examples\n ///\n@@ -103,7 +106,7 @@ mod prim_bool {}\n /// behaviour of the `!` type - expressions with type `!` will coerce into any other type.\n ///\n /// [`u32`]: prim@u32\n-/// [`exit`]: process::exit\n+#[doc = concat!(\"[`exit`]: \", include_str!(\"../primitive_docs/process_exit.md\"))]\n ///\n /// # `!` and generics\n ///\n@@ -188,7 +191,7 @@ mod prim_bool {}\n /// because `!` coerces to `Result<!, ConnectionError>` automatically.\n ///\n /// [`String::from_str`]: str::FromStr::from_str\n-/// [`String`]: string::String\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n /// [`FromStr`]: str::FromStr\n ///\n /// # `!` and traits\n@@ -264,15 +267,14 @@ mod prim_bool {}\n /// `impl` for this which simply panics, but the same is true for any type (we could `impl\n /// Default` for (eg.) [`File`] by just making [`default()`] panic.)\n ///\n-/// [`File`]: fs::File\n+#[doc = concat!(\"[`File`]: \", include_str!(\"../primitive_docs/fs_file.md\"))]\n /// [`Debug`]: fmt::Debug\n /// [`default()`]: Default::default\n ///\n #[unstable(feature = \"never_type\", issue = \"35121\")]\n mod prim_never {}\n \n #[doc(primitive = \"char\")]\n-//\n /// A character type.\n ///\n /// The `char` type represents a single character. More specifically, since\n@@ -304,7 +306,7 @@ mod prim_never {}\n /// assert_eq!(5, s.len() * std::mem::size_of::<u8>());\n /// ```\n ///\n-/// [`String`]: string/struct.String.html\n+#[doc = concat!(\"[`String`]: \", include_str!(\"../primitive_docs/string_string.md\"))]\n ///\n /// As always, remember that a human intuition for 'character' might not map to\n /// Unicode's definitions. For example, despite looking similar, the '\u00e9'\n@@ -499,7 +501,7 @@ mod prim_unit {}\n /// [`null_mut`]: ptr::null_mut\n /// [`is_null`]: pointer::is_null\n /// [`offset`]: pointer::offset\n-/// [`into_raw`]: Box::into_raw\n+#[doc = concat!(\"[`into_raw`]: \", include_str!(\"../primitive_docs/box_into_raw.md\"))]\n /// [`drop`]: mem::drop\n /// [`write`]: ptr::write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -581,9 +583,9 @@ mod prim_pointer {}\n /// # Editions\n ///\n /// Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call\n-/// `array.into_iter()` auto-referenced into a [slice iterator](slice::iter). Right now, the old behavior\n-/// is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring\n-/// `IntoIterator` by value. In the future, the behavior on the 2015 and 2018 edition\n+/// `array.into_iter()` auto-referenced into a [slice iterator](slice::iter). Right now, the old\n+/// behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring\n+/// [`IntoIterator`] by value. In the future, the behavior on the 2015 and 2018 edition\n /// might be made consistent to the behavior of later editions.\n ///\n /// ```rust,edition2018\n@@ -1042,15 +1044,15 @@ mod prim_usize {}\n /// References, both shared and mutable.\n ///\n /// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n-/// operators on a value, or by using a [`ref`](keyword.ref.html) or\n-/// <code>[ref](keyword.ref.html) [mut](keyword.mut.html)</code> pattern.\n+/// operators on a value, or by using a [`ref`](../std/keyword.ref.html) or\n+/// <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> pattern.\n ///\n /// For those familiar with pointers, a reference is just a pointer that is assumed to be\n /// aligned, not null, and pointing to memory containing a valid value of `T` - for example,\n /// <code>&[bool]</code> can only point to an allocation containing the integer values `1`\n-/// ([`true`](keyword.true.html)) or `0` ([`false`](keyword.false.html)), but creating a\n-/// <code>&[bool]</code> that points to an allocation containing the value `3` causes\n-/// undefined behaviour.\n+/// ([`true`](../std/keyword.true.html)) or `0` ([`false`](../std/keyword.false.html)), but\n+/// creating a <code>&[bool]</code> that points to an allocation containing\n+/// the value `3` causes undefined behaviour.\n /// In fact, <code>[Option]\\<&T></code> has the same memory representation as a\n /// nullable but aligned pointer, and can be passed across FFI boundaries as such.\n ///\n@@ -1117,6 +1119,7 @@ mod prim_usize {}\n ///\n /// [`DerefMut`]: ops::DerefMut\n /// [`BorrowMut`]: borrow::BorrowMut\n+/// [bool]: prim@bool\n ///\n /// The following traits are implemented on `&T` references if the underlying `T` also implements\n /// that trait:\n@@ -1134,7 +1137,7 @@ mod prim_usize {}\n /// [`std::fmt`]: fmt\n /// ['Pointer`]: fmt::Pointer\n /// [`Hash`]: hash::Hash\n-/// [`ToSocketAddrs`]: net::ToSocketAddrs\n+#[doc = concat!(\"[`ToSocketAddrs`]: \", include_str!(\"../primitive_docs/net_tosocketaddrs.md\"))]\n ///\n /// `&mut T` references get all of the above except `ToSocketAddrs`, plus the following, if `T`\n /// implements that trait:\n@@ -1155,9 +1158,10 @@ mod prim_usize {}\n ///\n /// [`FusedIterator`]: iter::FusedIterator\n /// [`TrustedLen`]: iter::TrustedLen\n-/// [`Seek`]: io::Seek\n-/// [`BufRead`]: io::BufRead\n-/// [`Read`]: io::Read\n+#[doc = concat!(\"[`Seek`]: \", include_str!(\"../primitive_docs/io_seek.md\"))]\n+#[doc = concat!(\"[`BufRead`]: \", include_str!(\"../primitive_docs/io_bufread.md\"))]\n+#[doc = concat!(\"[`Read`]: \", include_str!(\"../primitive_docs/io_read.md\"))]\n+#[doc = concat!(\"[`io::Write`]: \", include_str!(\"../primitive_docs/io_write.md\"))]\n ///\n /// Note that due to method call deref coercion, simply calling a trait method will act like they\n /// work on references as well as they do on owned values! The implementations described here are"}, {"sha": "e8da852a57e631fd32a5938a7a2e4c939e3a36d7", "filename": "src/test/rustdoc/auxiliary/primitive-doc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -1,5 +1,8 @@\n // compile-flags: --crate-type lib --edition 2018\n \n+#![feature(no_core)]\n+#![no_core]\n+\n #[doc(primitive = \"usize\")]\n /// This is the built-in type `usize`.\n mod usize {"}, {"sha": "709ffa18180660b8c3c63f38ed594bb24c529339", "filename": "src/test/rustdoc/cross-crate-primitive-doc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -1,9 +1,11 @@\n // aux-build:primitive-doc.rs\n // compile-flags: --extern-html-root-url=primitive_doc=../ -Z unstable-options\n-\n-#![no_std]\n+#![feature(no_core)]\n+#![no_core]\n \n extern crate primitive_doc;\n \n // @has 'cross_crate_primitive_doc/fn.foo.html' '//a[@href=\"../primitive_doc/primitive.usize.html\"]' 'usize'\n+// @has 'cross_crate_primitive_doc/fn.foo.html' '//a[@href=\"../primitive_doc/primitive.usize.html\"]' 'link'\n+/// [link](usize)\n pub fn foo() -> usize { 0 }"}, {"sha": "8d05a8e6e0136dc0ff2163873add8686595b522b", "filename": "src/test/rustdoc/primitive/no_std.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftest%2Frustdoc%2Fprimitive%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftest%2Frustdoc%2Fprimitive%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive%2Fno_std.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1,5 @@\n+#![no_std]\n+\n+// @has no_std/fn.foo.html '//a/[@href=\"{{channel}}/core/primitive.u8.html\"]' 'u8'\n+// Link to [u8]\n+pub fn foo() -> u8 {}"}, {"sha": "35809e599266c8111e6758f84307b1371838ea69", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -46,6 +46,7 @@ pub mod errors;\n pub mod extdeps;\n pub mod features;\n pub mod pal;\n+pub mod primitive_docs;\n pub mod style;\n pub mod target_specific_tests;\n pub mod ui_tests;"}, {"sha": "d555f7c8e34fffbaefb5158ddc5e2b815bf77ea3", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -71,6 +71,7 @@ fn main() {\n \n         // Checks that only make sense for the std libs.\n         check!(pal, &library_path);\n+        check!(primitive_docs, &library_path);\n \n         // Checks that need to be done for both the compiler and std libraries.\n         check!(unit_tests, &src_path);"}, {"sha": "8476650d9b5f726e0c2884add732f8667859cbdd", "filename": "src/tools/tidy/src/primitive_docs.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftools%2Ftidy%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fe39e8a8e6a66d97836e3068a4b1f183c79ea6/src%2Ftools%2Ftidy%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fprimitive_docs.rs?ref=69fe39e8a8e6a66d97836e3068a4b1f183c79ea6", "patch": "@@ -0,0 +1,17 @@\n+//! Tidy check to make sure `library/{std,core}/src/primitive_docs.rs` are the same file.  These are\n+//! different files so that relative links work properly without having to have `CARGO_PKG_NAME`\n+//! set, but conceptually they should always be the same.\n+\n+use std::path::Path;\n+\n+pub fn check(library_path: &Path, bad: &mut bool) {\n+    let std_name = \"std/src/primitive_docs.rs\";\n+    let core_name = \"core/src/primitive_docs.rs\";\n+    let std_contents = std::fs::read_to_string(library_path.join(std_name))\n+        .unwrap_or_else(|e| panic!(\"failed to read library/{}: {}\", std_name, e));\n+    let core_contents = std::fs::read_to_string(library_path.join(core_name))\n+        .unwrap_or_else(|e| panic!(\"failed to read library/{}: {}\", core_name, e));\n+    if std_contents != core_contents {\n+        tidy_error!(bad, \"library/{} and library/{} have different contents\", core_name, std_name);\n+    }\n+}"}]}