{"sha": "49f6166ef7825a39e980c0ba0904073379bb01e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZjYxNjZlZjc4MjVhMzllOTgwYzBiYTA5MDQwNzMzNzliYjAxZTY=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-06-26T01:52:41Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-06-26T01:52:41Z"}, "message": "Prepare for LLVM 11", "tree": {"sha": "302a88b9f8b6a34b9c37031ffd364cccd655fee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/302a88b9f8b6a34b9c37031ffd364cccd655fee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49f6166ef7825a39e980c0ba0904073379bb01e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49f6166ef7825a39e980c0ba0904073379bb01e6", "html_url": "https://github.com/rust-lang/rust/commit/49f6166ef7825a39e980c0ba0904073379bb01e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49f6166ef7825a39e980c0ba0904073379bb01e6/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50fc24d8a172a853b5dfe40702d6550e3b8562ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/50fc24d8a172a853b5dfe40702d6550e3b8562ba", "html_url": "https://github.com/rust-lang/rust/commit/50fc24d8a172a853b5dfe40702d6550e3b8562ba"}], "stats": {"total": 224, "additions": 167, "deletions": 57}, "files": [{"sha": "bb7d59e113c08a29fc9c61e26383c668adb577e7", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -24,6 +24,12 @@ fn main() {\n         \"InstrProfilingUtil.c\",\n         \"InstrProfilingValue.c\",\n         \"InstrProfilingWriter.c\",\n+        // This file was renamed in LLVM 10.\n+        \"InstrProfilingRuntime.cc\",\n+        \"InstrProfilingRuntime.cpp\",\n+        // These files were added in LLVM 11.\n+        \"InstrProfilingInternal.c\",\n+        \"InstrProfilingBiasVar.c\",\n     ];\n \n     if target.contains(\"msvc\") {\n@@ -69,14 +75,12 @@ fn main() {\n \n     let src_root = root.join(\"lib\").join(\"profile\");\n     for src in profile_sources {\n-        cfg.file(src_root.join(src));\n+        let path = src_root.join(src);\n+        if path.exists() {\n+            cfg.file(path);\n+        }\n     }\n \n-    // The file was renamed in LLVM 10.\n-    let old_runtime_path = src_root.join(\"InstrProfilingRuntime.cc\");\n-    let new_runtime_path = src_root.join(\"InstrProfilingRuntime.cpp\");\n-    cfg.file(if old_runtime_path.exists() { old_runtime_path } else { new_runtime_path });\n-\n     cfg.include(root.join(\"include\"));\n     cfg.warnings(false);\n     cfg.compile(\"profiler-rt\");"}, {"sha": "9764c9a102e8a43fd7541678b9cf4f5b5c1235dd", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -797,6 +797,7 @@ pub unsafe fn optimize_thin_module(\n         kind: ModuleKind::Regular,\n     };\n     {\n+        let target = &*module.module_llvm.tm;\n         let llmod = module.module_llvm.llmod();\n         save_temp_bitcode(&cgcx, &module, \"thin-lto-input\");\n \n@@ -833,7 +834,7 @@ pub unsafe fn optimize_thin_module(\n         {\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_rename\", thin_module.name());\n-            if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n+            if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod, target) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n             }\n@@ -865,7 +866,7 @@ pub unsafe fn optimize_thin_module(\n         {\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_import\", thin_module.name());\n-            if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n+            if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod, target) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n             }"}, {"sha": "7beb4fc897472a6a79db7a12127a458abf7ff32a", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -233,6 +233,8 @@ pub enum TypeKind {\n     Metadata = 14,\n     X86_MMX = 15,\n     Token = 16,\n+    ScalableVector = 17,\n+    BFloat = 18,\n }\n \n impl TypeKind {\n@@ -255,6 +257,8 @@ impl TypeKind {\n             TypeKind::Metadata => rustc_codegen_ssa::common::TypeKind::Metadata,\n             TypeKind::X86_MMX => rustc_codegen_ssa::common::TypeKind::X86_MMX,\n             TypeKind::Token => rustc_codegen_ssa::common::TypeKind::Token,\n+            TypeKind::ScalableVector => rustc_codegen_ssa::common::TypeKind::ScalableVector,\n+            TypeKind::BFloat => rustc_codegen_ssa::common::TypeKind::BFloat,\n         }\n     }\n }\n@@ -2141,10 +2145,18 @@ extern \"C\" {\n         PreservedSymbols: *const *const c_char,\n         PreservedSymbolsLen: c_uint,\n     ) -> Option<&'static mut ThinLTOData>;\n-    pub fn LLVMRustPrepareThinLTORename(Data: &ThinLTOData, Module: &Module) -> bool;\n+    pub fn LLVMRustPrepareThinLTORename(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+        Target: &TargetMachine,\n+    ) -> bool;\n     pub fn LLVMRustPrepareThinLTOResolveWeak(Data: &ThinLTOData, Module: &Module) -> bool;\n     pub fn LLVMRustPrepareThinLTOInternalize(Data: &ThinLTOData, Module: &Module) -> bool;\n-    pub fn LLVMRustPrepareThinLTOImport(Data: &ThinLTOData, Module: &Module) -> bool;\n+    pub fn LLVMRustPrepareThinLTOImport(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+        Target: &TargetMachine,\n+    ) -> bool;\n     pub fn LLVMRustGetThinLTOModuleImports(\n         Data: *const ThinLTOData,\n         ModuleNameCallback: ThinLTOModuleNameCallback,"}, {"sha": "432b2f3bdc3c174987221d051dde6c616d2f8be3", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -98,6 +98,8 @@ pub enum TypeKind {\n     Metadata,\n     X86_MMX,\n     Token,\n+    ScalableVector,\n+    BFloat,\n }\n \n // FIXME(mw): Anything that is produced via DepGraph::with_task() must implement"}, {"sha": "41b14714842fd0f9d588621f1057005e49e0d037", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 93, "deletions": 26, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -49,8 +49,10 @@ typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n \n DEFINE_STDCXX_CONVERSION_FUNCTIONS(Pass, LLVMPassRef)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)\n+#if LLVM_VERSION_LT(11, 0)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(PassManagerBuilder,\n                                    LLVMPassManagerBuilderRef)\n+#endif\n \n extern \"C\" void LLVMInitializePasses() {\n   PassRegistry &Registry = *PassRegistry::getPassRegistry();\n@@ -343,17 +345,17 @@ enum class LLVMRustPassBuilderOptLevel {\n static PassBuilder::OptimizationLevel fromRust(LLVMRustPassBuilderOptLevel Level) {\n   switch (Level) {\n   case LLVMRustPassBuilderOptLevel::O0:\n-    return PassBuilder::O0;\n+    return PassBuilder::OptimizationLevel::O0;\n   case LLVMRustPassBuilderOptLevel::O1:\n-    return PassBuilder::O1;\n+    return PassBuilder::OptimizationLevel::O1;\n   case LLVMRustPassBuilderOptLevel::O2:\n-    return PassBuilder::O2;\n+    return PassBuilder::OptimizationLevel::O2;\n   case LLVMRustPassBuilderOptLevel::O3:\n-    return PassBuilder::O3;\n+    return PassBuilder::OptimizationLevel::O3;\n   case LLVMRustPassBuilderOptLevel::Os:\n-    return PassBuilder::Os;\n+    return PassBuilder::OptimizationLevel::Os;\n   case LLVMRustPassBuilderOptLevel::Oz:\n-    return PassBuilder::Oz;\n+    return PassBuilder::OptimizationLevel::Oz;\n   default:\n     report_fatal_error(\"Bad PassBuilderOptLevel.\");\n   }\n@@ -796,8 +798,13 @@ LLVMRustOptimizeWithNewPassManager(\n   // We manually collect pipeline callbacks so we can apply them at O0, where the\n   // PassBuilder does not create a pipeline.\n   std::vector<std::function<void(ModulePassManager &)>> PipelineStartEPCallbacks;\n+#if LLVM_VERSION_GE(11, 0)\n+  std::vector<std::function<void(ModulePassManager &, PassBuilder::OptimizationLevel)>>\n+      OptimizerLastEPCallbacks;\n+#else\n   std::vector<std::function<void(FunctionPassManager &, PassBuilder::OptimizationLevel)>>\n       OptimizerLastEPCallbacks;\n+#endif\n \n   if (VerifyIR) {\n     PipelineStartEPCallbacks.push_back([VerifyIR](ModulePassManager &MPM) {\n@@ -811,6 +818,14 @@ LLVMRustOptimizeWithNewPassManager(\n           SanitizerOptions->SanitizeMemoryTrackOrigins,\n           SanitizerOptions->SanitizeMemoryRecover,\n           /*CompileKernel=*/false);\n+#if LLVM_VERSION_GE(11, 0)\n+      OptimizerLastEPCallbacks.push_back(\n+        [Options](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+          MPM.addPass(MemorySanitizerPass(Options));\n+          MPM.addPass(createModuleToFunctionPassAdaptor(MemorySanitizerPass(Options)));\n+        }\n+      );\n+#else\n #if LLVM_VERSION_GE(10, 0)\n       PipelineStartEPCallbacks.push_back([Options](ModulePassManager &MPM) {\n         MPM.addPass(MemorySanitizerPass(Options));\n@@ -821,9 +836,18 @@ LLVMRustOptimizeWithNewPassManager(\n           FPM.addPass(MemorySanitizerPass(Options));\n         }\n       );\n+#endif\n     }\n \n     if (SanitizerOptions->SanitizeThread) {\n+#if LLVM_VERSION_GE(11, 0)\n+      OptimizerLastEPCallbacks.push_back(\n+        [](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+          MPM.addPass(ThreadSanitizerPass());\n+          MPM.addPass(createModuleToFunctionPassAdaptor(ThreadSanitizerPass()));\n+        }\n+      );\n+#else\n #if LLVM_VERSION_GE(10, 0)\n       PipelineStartEPCallbacks.push_back([](ModulePassManager &MPM) {\n         MPM.addPass(ThreadSanitizerPass());\n@@ -834,9 +858,22 @@ LLVMRustOptimizeWithNewPassManager(\n           FPM.addPass(ThreadSanitizerPass());\n         }\n       );\n+#endif\n     }\n \n     if (SanitizerOptions->SanitizeAddress) {\n+#if LLVM_VERSION_GE(11, 0)\n+      OptimizerLastEPCallbacks.push_back(\n+        [SanitizerOptions](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+          MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n+          MPM.addPass(ModuleAddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover));\n+          MPM.addPass(createModuleToFunctionPassAdaptor(AddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover,\n+              /*UseAfterScope=*/true)));\n+        }\n+      );\n+#else\n       PipelineStartEPCallbacks.push_back([&](ModulePassManager &MPM) {\n         MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n       });\n@@ -853,21 +890,27 @@ LLVMRustOptimizeWithNewPassManager(\n               /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover));\n         }\n       );\n+#endif\n     }\n   }\n \n   ModulePassManager MPM(DebugPassManager);\n   if (!NoPrepopulatePasses) {\n-    if (OptLevel == PassBuilder::O0) {\n+    if (OptLevel == PassBuilder::OptimizationLevel::O0) {\n       for (const auto &C : PipelineStartEPCallbacks)\n         C(MPM);\n \n+#if LLVM_VERSION_GE(11, 0)\n+      for (const auto &C : OptimizerLastEPCallbacks)\n+        C(MPM, OptLevel);\n+#else\n       if (!OptimizerLastEPCallbacks.empty()) {\n         FunctionPassManager FPM(DebugPassManager);\n         for (const auto &C : OptimizerLastEPCallbacks)\n           C(FPM, OptLevel);\n         MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n       }\n+#endif\n \n       MPM.addPass(AlwaysInlinerPass(EmitLifetimeMarkers));\n \n@@ -892,12 +935,17 @@ LLVMRustOptimizeWithNewPassManager(\n         break;\n       case LLVMRustOptStage::PreLinkThinLTO:\n         MPM = PB.buildThinLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+#if LLVM_VERSION_GE(11, 0)\n+        for (const auto &C : OptimizerLastEPCallbacks)\n+          C(MPM, OptLevel);\n+#else\n         if (!OptimizerLastEPCallbacks.empty()) {\n           FunctionPassManager FPM(DebugPassManager);\n           for (const auto &C : OptimizerLastEPCallbacks)\n             C(FPM, OptLevel);\n           MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n         }\n+#endif\n         break;\n       case LLVMRustOptStage::PreLinkFatLTO:\n         MPM = PB.buildLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n@@ -994,10 +1042,10 @@ class RustAssemblyAnnotationWriter : public AssemblyAnnotationWriter {\n     const Value *Value;\n     if (const CallInst *CI = dyn_cast<CallInst>(I)) {\n       Name = \"call\";\n-      Value = CI->getCalledValue();\n+      Value = CI->getCalledOperand();\n     } else if (const InvokeInst* II = dyn_cast<InvokeInst>(I)) {\n       Name = \"invoke\";\n-      Value = II->getCalledValue();\n+      Value = II->getCalledOperand();\n     } else {\n       // Could demangle more operations, e. g.\n       // `store %place, @function`.\n@@ -1335,10 +1383,33 @@ LLVMRustFreeThinLTOData(LLVMRustThinLTOData *Data) {\n // `ProcessThinLTOModule` function. Here they're split up into separate steps\n // so rustc can save off the intermediate bytecode between each step.\n \n+#if LLVM_VERSION_GE(11, 0)\n+static bool\n+clearDSOLocalOnDeclarations(Module &Mod, TargetMachine &TM) {\n+  // When linking an ELF shared object, dso_local should be dropped. We\n+  // conservatively do this for -fpic.\n+  bool ClearDSOLocalOnDeclarations =\n+      TM.getTargetTriple().isOSBinFormatELF() &&\n+      TM.getRelocationModel() != Reloc::Static &&\n+      Mod.getPIELevel() == PIELevel::Default;\n+  return ClearDSOLocalOnDeclarations;\n+}\n+#endif\n+\n extern \"C\" bool\n-LLVMRustPrepareThinLTORename(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+LLVMRustPrepareThinLTORename(const LLVMRustThinLTOData *Data, LLVMModuleRef M,\n+                             LLVMTargetMachineRef TM) {\n   Module &Mod = *unwrap(M);\n-  if (renameModuleForThinLTO(Mod, Data->Index)) {\n+  TargetMachine &Target = *unwrap(TM);\n+\n+#if LLVM_VERSION_GE(11, 0)\n+  bool ClearDSOLocal = clearDSOLocalOnDeclarations(Mod, Target);\n+  bool error = renameModuleForThinLTO(Mod, Data->Index, ClearDSOLocal);\n+#else\n+  bool error = renameModuleForThinLTO(Mod, Data->Index);\n+#endif\n+\n+  if (error) {\n     LLVMRustSetLastError(\"renameModuleForThinLTO failed\");\n     return false;\n   }\n@@ -1362,8 +1433,10 @@ LLVMRustPrepareThinLTOInternalize(const LLVMRustThinLTOData *Data, LLVMModuleRef\n }\n \n extern \"C\" bool\n-LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M,\n+                             LLVMTargetMachineRef TM) {\n   Module &Mod = *unwrap(M);\n+  TargetMachine &Target = *unwrap(TM);\n \n   const auto &ImportList = Data->ImportLists.lookup(Mod.getModuleIdentifier());\n   auto Loader = [&](StringRef Identifier) {\n@@ -1399,7 +1472,12 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n \n     return MOrErr;\n   };\n+#if LLVM_VERSION_GE(11, 0)\n+  bool ClearDSOLocal = clearDSOLocalOnDeclarations(Mod, Target);\n+  FunctionImporter Importer(Data->Index, Loader, ClearDSOLocal);\n+#else\n   FunctionImporter Importer(Data->Index, Loader);\n+#endif\n   Expected<bool> Result = Importer.importFunctions(Mod, ImportList);\n   if (!Result) {\n     LLVMRustSetLastError(toString(Result.takeError()).c_str());\n@@ -1558,22 +1636,11 @@ LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n   }\n \n   // Use LLVM's built-in `DebugInfoFinder` to find a bunch of debuginfo and\n-  // process it recursively. Note that we specifically iterate over instructions\n-  // to ensure we feed everything into it.\n+  // process it recursively. Note that we used to specifically iterate over\n+  // instructions to ensure we feed everything into it, but `processModule`\n+  // started doing this the same way in LLVM 7 (commit d769eb36ab2b8).\n   DebugInfoFinder Finder;\n   Finder.processModule(*M);\n-  for (Function &F : M->functions()) {\n-    for (auto &FI : F) {\n-      for (Instruction &BI : FI) {\n-        if (auto Loc = BI.getDebugLoc())\n-          Finder.processLocation(*M, Loc);\n-        if (auto DVI = dyn_cast<DbgValueInst>(&BI))\n-          Finder.processValue(*M, DVI);\n-        if (auto DDI = dyn_cast<DbgDeclareInst>(&BI))\n-          Finder.processDeclare(*M, DDI);\n-      }\n-    }\n-  }\n \n   // After we've found all our debuginfo, rewrite all subprograms to point to\n   // the same `DICompileUnit`."}, {"sha": "063b6acc604ea543bf828ef7ca428157e9892aeb", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -1,5 +1,4 @@\n #include \"rustllvm.h\"\n-#include \"llvm/IR/CallSite.h\"\n #include \"llvm/IR/DebugInfoMetadata.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n@@ -214,50 +213,50 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n \n extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   Attribute Attr = Attribute::get(Call->getContext(), fromRust(RustAttr));\n-  Call.addAttribute(Index, Attr);\n+  Call->addAttribute(Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n                                                  unsigned Index,\n                                                  uint32_t Bytes) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addAlignmentAttr(Bytes);\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n+  Call->setAttributes(Call->getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n                                                        unsigned Index,\n                                                        uint64_t Bytes) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addDereferenceableAttr(Bytes);\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n+  Call->setAttributes(Call->getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n                                                              unsigned Index,\n                                                              uint64_t Bytes) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addDereferenceableOrNullAttr(Bytes);\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n+  Call->setAttributes(Call->getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustAddByValCallSiteAttr(LLVMValueRef Instr, unsigned Index,\n                                              LLVMTypeRef Ty) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n #if LLVM_VERSION_GE(9, 0)\n   Attribute Attr = Attribute::getWithByValType(Call->getContext(), unwrap(Ty));\n #else\n   Attribute Attr = Attribute::get(Call->getContext(), Attribute::ByVal);\n #endif\n-  Call.addAttribute(Index, Attr);\n+  Call->addAttribute(Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n@@ -336,20 +335,24 @@ extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n extern \"C\" LLVMValueRef\n LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef Source, const char *Name,\n                         LLVMAtomicOrdering Order) {\n-  LoadInst *LI = new LoadInst(unwrap(Source));\n+  Value *Ptr = unwrap(Source);\n+  Type *Ty = Ptr->getType()->getPointerElementType();\n+  LoadInst *LI = unwrap(B)->CreateLoad(Ty, Ptr, Name);\n   LI->setAtomic(fromRust(Order));\n-  return wrap(unwrap(B)->Insert(LI, Name));\n+  return wrap(LI);\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n                                                  LLVMValueRef V,\n                                                  LLVMValueRef Target,\n                                                  LLVMAtomicOrdering Order) {\n-  StoreInst *SI = new StoreInst(unwrap(V), unwrap(Target));\n+  StoreInst *SI = unwrap(B)->CreateStore(unwrap(V), unwrap(Target));\n   SI->setAtomic(fromRust(Order));\n-  return wrap(unwrap(B)->Insert(SI));\n+  return wrap(SI);\n }\n \n+// FIXME: Use the C-API LLVMBuildAtomicCmpXchg and LLVMSetWeak\n+// once we raise our minimum support to LLVM 10.\n extern \"C\" LLVMValueRef\n LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Target,\n                            LLVMValueRef Old, LLVMValueRef Source,\n@@ -965,8 +968,14 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateUnionType(\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateTemplateTypeParameter(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n     const char *Name, size_t NameLen, LLVMMetadataRef Ty) {\n+#if LLVM_VERSION_GE(11, 0)\n+  bool IsDefault = false; // FIXME: should we ever set this true?\n+  return wrap(Builder->createTemplateTypeParameter(\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIType>(Ty), IsDefault));\n+#else\n   return wrap(Builder->createTemplateTypeParameter(\n       unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIType>(Ty)));\n+#endif\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateNameSpace(\n@@ -1227,12 +1236,23 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n     return LLVMArrayTypeKind;\n   case Type::PointerTyID:\n     return LLVMPointerTypeKind;\n+#if LLVM_VERSION_GE(11, 0)\n+  case Type::FixedVectorTyID:\n+    return LLVMVectorTypeKind;\n+#else\n   case Type::VectorTyID:\n     return LLVMVectorTypeKind;\n+#endif\n   case Type::X86_MMXTyID:\n     return LLVMX86_MMXTypeKind;\n   case Type::TokenTyID:\n     return LLVMTokenTypeKind;\n+#if LLVM_VERSION_GE(11, 0)\n+  case Type::ScalableVectorTyID:\n+    return LLVMScalableVectorTypeKind;\n+  case Type::BFloatTyID:\n+    return LLVMBFloatTypeKind;\n+#endif\n   }\n   report_fatal_error(\"Unhandled TypeID.\");\n }\n@@ -1359,10 +1379,12 @@ extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n                                           OperandBundleDef *Bundle) {\n+  Value *Callee = unwrap(Fn);\n+  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n-      unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles));\n+      FTy, Callee, makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n@@ -1422,9 +1444,11 @@ LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n                     unsigned NumArgs, LLVMBasicBlockRef Then,\n                     LLVMBasicBlockRef Catch, OperandBundleDef *Bundle,\n                     const char *Name) {\n+  Value *Callee = unwrap(Fn);\n+  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n-  return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n+  return wrap(unwrap(B)->CreateInvoke(FTy, Callee, unwrap(Then), unwrap(Catch),\n                                       makeArrayRef(unwrap(Args), NumArgs),\n                                       Bundles, Name));\n }"}, {"sha": "433d32abd37c65b01de9d76180cce9209b564e1a", "filename": "src/test/codegen/sanitizer-recover.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -27,17 +27,17 @@\n // ASAN:               }\n //\n // MSAN-LABEL: define i32 @penguin(\n-// MSAN:         call void @__msan_warning_noreturn()\n+// MSAN:         call void @__msan_warning{{(_with_origin_noreturn\\(i32 0\\)|_noreturn\\(\\))}}\n // MSAN:         unreachable\n // MSAN:       }\n //\n // MSAN-RECOVER-LABEL: define i32 @penguin(\n-// MSAN-RECOVER:         call void @__msan_warning()\n+// MSAN-RECOVER:         call void @__msan_warning{{(_with_origin\\(i32 0\\)|\\(\\))}}\n // MSAN-RECOVER-NOT:     unreachable\n // MSAN-RECOVER:       }\n //\n // MSAN-RECOVER-LTO-LABEL: define i32 @penguin(\n-// MSAN-RECOVER-LTO:          call void @__msan_warning()\n+// MSAN-RECOVER-LTO:          call void @__msan_warning{{(_with_origin\\(i32 0\\)|\\(\\))}}\n // MSAN-RECOVER-LTO-NOT:      unreachable\n // MSAN-RECOVER-LTO:       }\n //"}, {"sha": "571e7a59113ada60bbe3af9097f4f36c99acbc2b", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f6166ef7825a39e980c0ba0904073379bb01e6/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=49f6166ef7825a39e980c0ba0904073379bb01e6", "patch": "@@ -263,7 +263,7 @@ impl EarlyProps {\n         }\n \n         fn version_to_int(version: &str) -> u32 {\n-            let version_without_suffix = version.split('-').next().unwrap();\n+            let version_without_suffix = version.trim_end_matches(\"git\").split('-').next().unwrap();\n             let components: Vec<u32> = version_without_suffix\n                 .split('.')\n                 .map(|s| s.parse().expect(\"Malformed version component\"))"}]}