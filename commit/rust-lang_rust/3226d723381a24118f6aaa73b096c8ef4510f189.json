{"sha": "3226d723381a24118f6aaa73b096c8ef4510f189", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMjZkNzIzMzgxYTI0MTE4ZjZhYWE3M2IwOTZjOGVmNDUxMGYxODk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-24T17:01:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-24T17:01:30Z"}, "message": "Rollup merge of #74367 - Neutron3529:patch-1, r=nagisa\n\nRearrange the pipeline of `pow` to gain efficiency\n\nThe check of the `exp` parameter seems useless if we execute the while-loop more than once.\nThe original implementation of `pow` function using one more comparison if the `exp==0` and may break the pipeline of the cpu, which may generate a slower code.\nThe performance gap between the old and the new implementation may be small, but IMO, at least the newer one looks more beautiful.\n\n---\n\nbench prog:\n```\n#![feature(test)]\nextern crate test;\n#[macro_export]macro_rules! timing{\n($a:expr)=>{let time=std::time::Instant::now();{$a;}print!(\"{:?} \",time.elapsed())};\n($a:expr,$b:literal)=>{let time=std::time::Instant::now();let mut a=0;for _ in 0..$b{a^=$a;}print!(\"{:?} {} \",time.elapsed(),a)}\n}\n#[inline]\npub fn pow_rust(x:i64, mut exp: u32) -> i64 {\n    let mut base = x;\n    let mut acc = 1;\n    while exp > 1 {\n        if (exp & 1) == 1 {\n            acc = acc * base;\n        }\n        exp /= 2;\n        base = base * base;\n    }\n    if exp == 1 {\n        acc = acc * base;\n    }\n    acc\n}\n#[inline]\npub fn pow_new(x:i64, mut exp: u32) -> i64 {\n    if exp==0{\n        1\n    }else{\n        let mut base = x;\n        let mut acc = 1;\n        while exp > 1 {\n            if (exp & 1) == 1 {\n                acc = acc * base;\n            }\n            exp >>= 1;\n            base = base * base;\n        }\n        acc * base\n    }\n}\n\nfn main(){\nlet a=2i64;\nlet b=1_u32;\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\n}\n```\nbench in my laptop:\n```\nneutron@Neutron:/me/rust$ rc commit.rs\nrustc commit.rs  && ./commit\n\n3.978419716s 0 4.079765171s 0 3.964630622s 0\n3.997127013s 0 4.260304804s 0 3.997638211s 0\n3.963195544s 0 4.11657718s 0 4.176054164s 0\n3.830128579s 0 3.980396122s 0 3.937258567s 0\n3.986055948s 0 4.127804162s 0 4.018943411s 0\n4.185568857s 0 4.217512517s 0 3.98313603s 0\n3.863018225s 0 4.030447988s 0 3.694878237s 0\n4.206987927s 0 4.137608047s 0 4.115564664s 0\nneutron@Neutron:/me/rust$ rc commit.rs -O\nrustc commit.rs -O && ./commit\n\n162.111993ms 0 165.107125ms 0 166.26924ms 0\n175.20479ms 0 205.062565ms 0 176.278791ms 0\n174.408975ms 0 166.526899ms 0 201.857604ms 0\n146.190062ms 0 168.592821ms 0 154.61411ms 0\n199.678912ms 0 168.411598ms 0 162.129996ms 0\n147.420765ms 0 209.759326ms 0 154.807907ms 0\n165.507134ms 0 188.476239ms 0 157.351524ms 0\n121.320123ms 0 126.401229ms 0 114.86428ms 0\n```", "tree": {"sha": "920dcf6d041558a4ee3148eecf721d376ae5ee8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/920dcf6d041558a4ee3148eecf721d376ae5ee8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3226d723381a24118f6aaa73b096c8ef4510f189", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGxPqCRBK7hj4Ov3rIwAAdHIIADglVJPah0MbdRyRE0tr5dqK\nLZGGbKaMz1+wDzrsrUJCchxp9EgojXNHtcCJ8OSBWClJQUcUjtj/lGFv3lyheU3L\nrOKgWjLgRP37zvKzef6ULism5WDtXauaof4T7rnNMZGBW9lK7BjJ8AUtrMWTj1Ak\nEuYJOAGn0QifTZfUjPIfRPdlWeFFEn/PxAikXOtsp5B2u7wI121epMaOvyEa3Vx2\nd53nBc6FLLPaKpvvV/kv3744L420VhzgBx0vJIkyjIqm7J8GTcpP9ebAuez5ohPr\nl0xyuSdecJc0EskEQMzaYWuENCvId7hAf1LEU0vjOZ2awJ93czkxS6RGuR3xDG8=\n=rq1a\n-----END PGP SIGNATURE-----\n", "payload": "tree 920dcf6d041558a4ee3148eecf721d376ae5ee8b\nparent dfedb84462ed2281877ec10253e659155213e7c8\nparent ef74e5084386f82b4285fd7d3630cf1088eebb3f\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595610090 -0700\ncommitter GitHub <noreply@github.com> 1595610090 -0700\n\nRollup merge of #74367 - Neutron3529:patch-1, r=nagisa\n\nRearrange the pipeline of `pow` to gain efficiency\n\nThe check of the `exp` parameter seems useless if we execute the while-loop more than once.\nThe original implementation of `pow` function using one more comparison if the `exp==0` and may break the pipeline of the cpu, which may generate a slower code.\nThe performance gap between the old and the new implementation may be small, but IMO, at least the newer one looks more beautiful.\n\n---\n\nbench prog:\n```\n#![feature(test)]\nextern crate test;\n#[macro_export]macro_rules! timing{\n($a:expr)=>{let time=std::time::Instant::now();{$a;}print!(\"{:?} \",time.elapsed())};\n($a:expr,$b:literal)=>{let time=std::time::Instant::now();let mut a=0;for _ in 0..$b{a^=$a;}print!(\"{:?} {} \",time.elapsed(),a)}\n}\n#[inline]\npub fn pow_rust(x:i64, mut exp: u32) -> i64 {\n    let mut base = x;\n    let mut acc = 1;\n    while exp > 1 {\n        if (exp & 1) == 1 {\n            acc = acc * base;\n        }\n        exp /= 2;\n        base = base * base;\n    }\n    if exp == 1 {\n        acc = acc * base;\n    }\n    acc\n}\n#[inline]\npub fn pow_new(x:i64, mut exp: u32) -> i64 {\n    if exp==0{\n        1\n    }else{\n        let mut base = x;\n        let mut acc = 1;\n        while exp > 1 {\n            if (exp & 1) == 1 {\n                acc = acc * base;\n            }\n            exp >>= 1;\n            base = base * base;\n        }\n        acc * base\n    }\n}\n\nfn main(){\nlet a=2i64;\nlet b=1_u32;\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\ntiming!(test::black_box(a).pow(test::black_box(b)),100000000);\ntiming!(pow_new(test::black_box(a),test::black_box(b)),100000000);\ntiming!(pow_rust(test::black_box(a),test::black_box(b)),100000000);\nprintln!();\n}\n```\nbench in my laptop:\n```\nneutron@Neutron:/me/rust$ rc commit.rs\nrustc commit.rs  && ./commit\n\n3.978419716s 0 4.079765171s 0 3.964630622s 0\n3.997127013s 0 4.260304804s 0 3.997638211s 0\n3.963195544s 0 4.11657718s 0 4.176054164s 0\n3.830128579s 0 3.980396122s 0 3.937258567s 0\n3.986055948s 0 4.127804162s 0 4.018943411s 0\n4.185568857s 0 4.217512517s 0 3.98313603s 0\n3.863018225s 0 4.030447988s 0 3.694878237s 0\n4.206987927s 0 4.137608047s 0 4.115564664s 0\nneutron@Neutron:/me/rust$ rc commit.rs -O\nrustc commit.rs -O && ./commit\n\n162.111993ms 0 165.107125ms 0 166.26924ms 0\n175.20479ms 0 205.062565ms 0 176.278791ms 0\n174.408975ms 0 166.526899ms 0 201.857604ms 0\n146.190062ms 0 168.592821ms 0 154.61411ms 0\n199.678912ms 0 168.411598ms 0 162.129996ms 0\n147.420765ms 0 209.759326ms 0 154.807907ms 0\n165.507134ms 0 188.476239ms 0 157.351524ms 0\n121.320123ms 0 126.401229ms 0 114.86428ms 0\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3226d723381a24118f6aaa73b096c8ef4510f189", "html_url": "https://github.com/rust-lang/rust/commit/3226d723381a24118f6aaa73b096c8ef4510f189", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3226d723381a24118f6aaa73b096c8ef4510f189/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfedb84462ed2281877ec10253e659155213e7c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfedb84462ed2281877ec10253e659155213e7c8", "html_url": "https://github.com/rust-lang/rust/commit/dfedb84462ed2281877ec10253e659155213e7c8"}, {"sha": "ef74e5084386f82b4285fd7d3630cf1088eebb3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef74e5084386f82b4285fd7d3630cf1088eebb3f", "html_url": "https://github.com/rust-lang/rust/commit/ef74e5084386f82b4285fd7d3630cf1088eebb3f"}], "stats": {"total": 145, "additions": 101, "deletions": 44}, "files": [{"sha": "8e9a90352280295f8346ae018e6783727f7575d7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3226d723381a24118f6aaa73b096c8ef4510f189/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3226d723381a24118f6aaa73b096c8ef4510f189/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=3226d723381a24118f6aaa73b096c8ef4510f189", "patch": "@@ -1095,6 +1095,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1105,15 +1108,11 @@ $EndFeature, \"\n                     exp /= 2;\n                     base = try_opt!(base.checked_mul(base));\n                 }\n-\n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = try_opt!(acc.checked_mul(base));\n-                }\n-\n-                Some(acc)\n+                Some(try_opt!(acc.checked_mul(base)))\n             }\n         }\n \n@@ -1622,6 +1621,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1633,14 +1635,11 @@ $EndFeature, \"\n                     base = base.wrapping_mul(base);\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc.wrapping_mul(base);\n-                }\n-\n-                acc\n+                acc.wrapping_mul(base)\n             }\n         }\n \n@@ -1989,6 +1988,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0 {\n+                    return (1,false);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -2007,16 +2009,13 @@ $EndFeature, \"\n                     overflown |= r.1;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    r = acc.overflowing_mul(base);\n-                    acc = r.0;\n-                    overflown |= r.1;\n-                }\n-\n-                (acc, overflown)\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n+                r\n             }\n         }\n \n@@ -2040,6 +2039,9 @@ $EndFeature, \"\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub const fn pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc = 1;\n \n@@ -2051,14 +2053,11 @@ $EndFeature, \"\n                     base = base * base;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc * base;\n-                }\n-\n-                acc\n+                acc * base\n             }\n         }\n \n@@ -3295,6 +3294,9 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3306,14 +3308,12 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\", $EndFeature, \"\n                     base = try_opt!(base.checked_mul(base));\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = try_opt!(acc.checked_mul(base));\n-                }\n \n-                Some(acc)\n+                Some(try_opt!(acc.checked_mul(base)))\n             }\n         }\n \n@@ -3704,6 +3704,9 @@ assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3715,14 +3718,11 @@ assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n                     base = base.wrapping_mul(base);\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc.wrapping_mul(base);\n-                }\n-\n-                acc\n+                acc.wrapping_mul(base)\n             }\n         }\n \n@@ -4029,6 +4029,9 @@ assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0{\n+                    return (1,false);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -4047,16 +4050,14 @@ assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n                     overflown |= r.1;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    r = acc.overflowing_mul(base);\n-                    acc = r.0;\n-                    overflown |= r.1;\n-                }\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n \n-                (acc, overflown)\n+                r\n             }\n         }\n \n@@ -4077,6 +4078,9 @@ Basic usage:\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n         pub const fn pow(self, mut exp: u32) -> Self {\n+            if exp == 0 {\n+                return 1;\n+            }\n             let mut base = self;\n             let mut acc = 1;\n \n@@ -4088,14 +4092,11 @@ Basic usage:\n                 base = base * base;\n             }\n \n+            // since exp!=0, finally the exp must be 1.\n             // Deal with the final bit of the exponent separately, since\n             // squaring the base afterwards is not necessary and may cause a\n             // needless overflow.\n-            if exp == 1 {\n-                acc = acc * base;\n-            }\n-\n-            acc\n+            acc * base\n         }\n     }\n "}, {"sha": "58a585669122ca3b7859cf19b9bef7525354d705", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3226d723381a24118f6aaa73b096c8ef4510f189/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3226d723381a24118f6aaa73b096c8ef4510f189/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=3226d723381a24118f6aaa73b096c8ef4510f189", "patch": "@@ -255,12 +255,43 @@ macro_rules! int_module {\n             #[test]\n             fn test_pow() {\n                 let mut r = 2 as $T;\n-\n                 assert_eq!(r.pow(2), 4 as $T);\n                 assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n+\n+                r = MAX;\n+                // use `^` to represent .pow() with no overflow.\n+                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n+                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n+                // thussaturating_pow the overflowing result is exactly 1.\n+                assert_eq!(r.wrapping_pow(2), 1 as $T);\n+                assert_eq!(r.checked_pow(2), None);\n+                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n+                assert_eq!(r.saturating_pow(2), MAX);\n+                //test for negative exponent.\n                 r = -2 as $T;\n                 assert_eq!(r.pow(2), 4 as $T);\n                 assert_eq!(r.pow(3), -8 as $T);\n+                assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(3), -8 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(3), Some(-8 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(3), (-8 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(3), -8 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n             }\n         }\n     };"}, {"sha": "b84a8a7d9f88ba3aee84214cc61ac21f764e9a56", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3226d723381a24118f6aaa73b096c8ef4510f189/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3226d723381a24118f6aaa73b096c8ef4510f189/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=3226d723381a24118f6aaa73b096c8ef4510f189", "patch": "@@ -184,6 +184,31 @@ macro_rules! uint_module {\n                 assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n                 assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n             }\n+\n+            #[test]\n+            fn test_pow() {\n+                let mut r = 2 as $T;\n+                assert_eq!(r.pow(2), 4 as $T);\n+                assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n+\n+                r = MAX;\n+                // use `^` to represent .pow() with no overflow.\n+                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n+                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n+                // thussaturating_pow the overflowing result is exactly 1.\n+                assert_eq!(r.wrapping_pow(2), 1 as $T);\n+                assert_eq!(r.checked_pow(2), None);\n+                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n+                assert_eq!(r.saturating_pow(2), MAX);\n+            }\n         }\n     };\n }"}]}