{"sha": "e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZjJkZmRlY2VjYTgwNTNlNjUyZWIwZmIyODZkYjlhZWYwZjgyZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-22T17:00:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-22T17:00:12Z"}, "message": "Auto merge of #32156 - pnkfelix:borrowck-on-mir-move-analysis, r=nikomatsakis\n\nMove analysis for MIR borrowck\n\nThis PR adds code for doing MIR-based gathering of the moves in a `fn` and the dataflow to determine where uninitialized locations flow to, analogous to how the same thing is done in `borrowck`.\n\nIt also adds a couple attributes to print out graphviz visualizations of the analyzed MIR that includes the dataflow analysis results.\n\ncc @nikomatsakis", "tree": {"sha": "9e313f060d8250a287a0674d6e22279ed579f771", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e313f060d8250a287a0674d6e22279ed579f771"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "html_url": "https://github.com/rust-lang/rust/commit/e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7bdfd4442f0bde3412f08336f75b9eabff4a938", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bdfd4442f0bde3412f08336f75b9eabff4a938", "html_url": "https://github.com/rust-lang/rust/commit/c7bdfd4442f0bde3412f08336f75b9eabff4a938"}, {"sha": "782c0cf4a2fb57492012f6093ad7b70be72f654d", "url": "https://api.github.com/repos/rust-lang/rust/commits/782c0cf4a2fb57492012f6093ad7b70be72f654d", "html_url": "https://github.com/rust-lang/rust/commit/782c0cf4a2fb57492012f6093ad7b70be72f654d"}], "stats": {"total": 2150, "additions": 2014, "deletions": 136}, "files": [{"sha": "54733083aaeb04510cb1f12c95c847fe292fb231", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -97,7 +97,7 @@ DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml rustc_front\\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t\t  \t  rustc_const_eval\n DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n-DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n+DEPS_rustc_borrowck := rustc rustc_front rustc_mir log graphviz syntax\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\"}, {"sha": "f1317e80b03439eab934b0e835c2de93b7a04ca5", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -62,15 +62,19 @@\n //!     dot::render(&edges, output).unwrap()\n //! }\n //!\n-//! impl<'a> dot::Labeller<'a, Nd, Ed> for Edges {\n+//! impl<'a> dot::Labeller<'a> for Edges {\n+//!     type Node = Nd;\n+//!     type Edge = Ed;\n //!     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example1\").unwrap() }\n //!\n //!     fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", *n)).unwrap()\n //!     }\n //! }\n //!\n-//! impl<'a> dot::GraphWalk<'a, Nd, Ed> for Edges {\n+//! impl<'a> dot::GraphWalk<'a> for Edges {\n+//!     type Node = Nd;\n+//!     type Edge = Ed;\n //!     fn nodes(&self) -> dot::Nodes<'a,Nd> {\n //!         // (assumes that |N| \\approxeq |E|)\n //!         let &Edges(ref v) = self;\n@@ -167,7 +171,9 @@\n //!     dot::render(&graph, output).unwrap()\n //! }\n //!\n-//! impl<'a> dot::Labeller<'a, Nd, Ed<'a>> for Graph {\n+//! impl<'a> dot::Labeller<'a> for Graph {\n+//!     type Node = Nd;\n+//!     type Edge = Ed<'a>;\n //!     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example2\").unwrap() }\n //!     fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n)).unwrap()\n@@ -180,7 +186,9 @@\n //!     }\n //! }\n //!\n-//! impl<'a> dot::GraphWalk<'a, Nd, Ed<'a>> for Graph {\n+//! impl<'a> dot::GraphWalk<'a> for Graph {\n+//!     type Node = Nd;\n+//!     type Edge = Ed<'a>;\n //!     fn nodes(&self) -> dot::Nodes<'a,Nd> { (0..self.nodes.len()).collect() }\n //!     fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> { self.edges.iter().collect() }\n //!     fn source(&self, e: &Ed) -> Nd { let & &(s,_) = e; s }\n@@ -225,7 +233,9 @@\n //!     dot::render(&graph, output).unwrap()\n //! }\n //!\n-//! impl<'a> dot::Labeller<'a, Nd<'a>, Ed<'a>> for Graph {\n+//! impl<'a> dot::Labeller<'a> for Graph {\n+//!     type Node = Nd<'a>;\n+//!     type Edge = Ed<'a>;\n //!     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example3\").unwrap() }\n //!     fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n.0)).unwrap()\n@@ -239,7 +249,9 @@\n //!     }\n //! }\n //!\n-//! impl<'a> dot::GraphWalk<'a, Nd<'a>, Ed<'a>> for Graph {\n+//! impl<'a> dot::GraphWalk<'a> for Graph {\n+//!     type Node = Nd<'a>;\n+//!     type Edge = Ed<'a>;\n //!     fn nodes(&'a self) -> dot::Nodes<'a,Nd<'a>> {\n //!         self.nodes.iter().map(|s| &s[..]).enumerate().collect()\n //!     }\n@@ -447,45 +459,48 @@ impl<'a> Id<'a> {\n /// The graph instance is responsible for providing the DOT compatible\n /// identifiers for the nodes and (optionally) rendered labels for the nodes and\n /// edges, as well as an identifier for the graph itself.\n-pub trait Labeller<'a,N,E> {\n+pub trait Labeller<'a> {\n+    type Node;\n+    type Edge;\n+\n     /// Must return a DOT compatible identifier naming the graph.\n     fn graph_id(&'a self) -> Id<'a>;\n \n     /// Maps `n` to a unique identifier with respect to `self`. The\n     /// implementor is responsible for ensuring that the returned name\n     /// is a valid DOT identifier.\n-    fn node_id(&'a self, n: &N) -> Id<'a>;\n+    fn node_id(&'a self, n: &Self::Node) -> Id<'a>;\n \n     /// Maps `n` to one of the [graphviz `shape` names][1]. If `None`\n     /// is returned, no `shape` attribute is specified.\n     ///\n     /// [1]: http://www.graphviz.org/content/node-shapes\n-    fn node_shape(&'a self, _node: &N) -> Option<LabelText<'a>> {\n+    fn node_shape(&'a self, _node: &Self::Node) -> Option<LabelText<'a>> {\n         None\n     }\n \n     /// Maps `n` to a label that will be used in the rendered output.\n     /// The label need not be unique, and may be the empty string; the\n     /// default is just the output from `node_id`.\n-    fn node_label(&'a self, n: &N) -> LabelText<'a> {\n+    fn node_label(&'a self, n: &Self::Node) -> LabelText<'a> {\n         LabelStr(self.node_id(n).name)\n     }\n \n     /// Maps `e` to a label that will be used in the rendered output.\n     /// The label need not be unique, and may be the empty string; the\n     /// default is in fact the empty string.\n-    fn edge_label(&'a self, e: &E) -> LabelText<'a> {\n+    fn edge_label(&'a self, e: &Self::Edge) -> LabelText<'a> {\n         let _ignored = e;\n         LabelStr(\"\".into_cow())\n     }\n \n     /// Maps `n` to a style that will be used in the rendered output.\n-    fn node_style(&'a self, _n: &N) -> Style {\n+    fn node_style(&'a self, _n: &Self::Node) -> Style {\n         Style::None\n     }\n \n     /// Maps `e` to a style that will be used in the rendered output.\n-    fn edge_style(&'a self, _e: &E) -> Style {\n+    fn edge_style(&'a self, _e: &Self::Edge) -> Style {\n         Style::None\n     }\n }\n@@ -596,15 +611,18 @@ pub type Edges<'a,E> = Cow<'a,[E]>;\n /// `Cow<[T]>` to leave implementors the freedom to create\n /// entirely new vectors or to pass back slices into internally owned\n /// vectors.\n-pub trait GraphWalk<'a, N: Clone, E: Clone> {\n+pub trait GraphWalk<'a> {\n+    type Node: Clone;\n+    type Edge: Clone;\n+\n     /// Returns all the nodes in this graph.\n-    fn nodes(&'a self) -> Nodes<'a, N>;\n+    fn nodes(&'a self) -> Nodes<'a, Self::Node>;\n     /// Returns all of the edges in this graph.\n-    fn edges(&'a self) -> Edges<'a, E>;\n+    fn edges(&'a self) -> Edges<'a, Self::Edge>;\n     /// The source node for `edge`.\n-    fn source(&'a self, edge: &E) -> N;\n+    fn source(&'a self, edge: &Self::Edge) -> Self::Node;\n     /// The target node for `edge`.\n-    fn target(&'a self, edge: &E) -> N;\n+    fn target(&'a self, edge: &Self::Edge) -> Self::Node;\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -622,28 +640,26 @@ pub fn default_options() -> Vec<RenderOption> {\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Simple wrapper around `render_opts` that passes a default set of options.)\n-pub fn render<'a,\n-              N: Clone + 'a,\n-              E: Clone + 'a,\n-              G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n-              W: Write>\n-    (g: &'a G,\n-     w: &mut W)\n-     -> io::Result<()> {\n+pub fn render<'a,N,E,G,W>(g: &'a G, w: &mut W) -> io::Result<()>\n+    where N: Clone + 'a,\n+          E: Clone + 'a,\n+          G: Labeller<'a, Node=N, Edge=E> + GraphWalk<'a, Node=N, Edge=E>,\n+          W: Write\n+{\n     render_opts(g, w, &[])\n }\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Main entry point for the library.)\n-pub fn render_opts<'a,\n-                   N: Clone + 'a,\n-                   E: Clone + 'a,\n-                   G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n-                   W: Write>\n-    (g: &'a G,\n-     w: &mut W,\n-     options: &[RenderOption])\n-     -> io::Result<()> {\n+pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n+                                   w: &mut W,\n+                                   options: &[RenderOption])\n+                                   -> io::Result<()>\n+    where N: Clone + 'a,\n+          E: Clone + 'a,\n+          G: Labeller<'a, Node=N, Edge=E> + GraphWalk<'a, Node=N, Edge=E>,\n+          W: Write\n+{\n     fn writeln<W: Write>(w: &mut W, arg: &[&str]) -> io::Result<()> {\n         for &s in arg {\n             try!(w.write_all(s.as_bytes()));\n@@ -858,7 +874,9 @@ mod tests {\n         Id::new(format!(\"N{}\", *n)).unwrap()\n     }\n \n-    impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n+    impl<'a> Labeller<'a> for LabelledGraph {\n+        type Node = Node;\n+        type Edge = &'a Edge;\n         fn graph_id(&'a self) -> Id<'a> {\n             Id::new(&self.name[..]).unwrap()\n         }\n@@ -882,7 +900,9 @@ mod tests {\n         }\n     }\n \n-    impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n+    impl<'a> Labeller<'a> for LabelledGraphWithEscStrs {\n+        type Node = Node;\n+        type Edge = &'a Edge;\n         fn graph_id(&'a self) -> Id<'a> {\n             self.graph.graph_id()\n         }\n@@ -901,7 +921,9 @@ mod tests {\n         }\n     }\n \n-    impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraph {\n+    impl<'a> GraphWalk<'a> for LabelledGraph {\n+        type Node = Node;\n+        type Edge = &'a Edge;\n         fn nodes(&'a self) -> Nodes<'a, Node> {\n             (0..self.node_labels.len()).collect()\n         }\n@@ -916,7 +938,9 @@ mod tests {\n         }\n     }\n \n-    impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n+    impl<'a> GraphWalk<'a> for LabelledGraphWithEscStrs {\n+        type Node = Node;\n+        type Edge = &'a Edge;\n         fn nodes(&'a self) -> Nodes<'a, Node> {\n             self.graph.nodes()\n         }"}, {"sha": "976a8c6dda0461f8e344acb22a5c87a2b7a3b850", "filename": "src/librustc/front/map/blocks.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -26,7 +26,8 @@ pub use self::Code::*;\n use front::map::{self, Node};\n use syntax::abi;\n use rustc_front::hir::{Block, FnDecl};\n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::{Attribute, Name, NodeId};\n+use syntax::attr::ThinAttributesExt;\n use rustc_front::hir as ast;\n use syntax::codemap::Span;\n use rustc_front::intravisit::FnKind;\n@@ -116,7 +117,8 @@ struct ItemFnParts<'a> {\n     generics: &'a ast::Generics,\n     body:     &'a Block,\n     id:       NodeId,\n-    span:     Span\n+    span:     Span,\n+    attrs:    &'a [Attribute],\n }\n \n /// These are all the components one can extract from a closure expr\n@@ -125,12 +127,13 @@ struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n     body: &'a Block,\n     id: NodeId,\n-    span: Span\n+    span: Span,\n+    attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span) -> ClosureParts<'a> {\n-        ClosureParts { decl: d, body: b, id: id, span: s }\n+    fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+        ClosureParts { decl: d, body: b, id: id, span: s, attrs: attrs }\n     }\n }\n \n@@ -165,37 +168,37 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn body(self) -> &'a Block {\n         self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Block, _|  body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Block, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n         self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n-                    |_, _, sig: &'a ast::MethodSig, _, _, _|  &sig.decl,\n+                    |_, _, sig: &'a ast::MethodSig, _, _, _, _|  &sig.decl,\n                     |c: ClosureParts<'a>| c.decl)\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(|i: ItemFnParts|     i.span,\n-                    |_, _, _: &'a ast::MethodSig, _, _, span| span,\n+                    |_, _, _: &'a ast::MethodSig, _, _, span, _| span,\n                     |c: ClosureParts|    c.span)\n     }\n \n     pub fn id(self) -> NodeId {\n         self.handle(|i: ItemFnParts|     i.id,\n-                    |id, _, _: &'a ast::MethodSig, _, _, _| id,\n+                    |id, _, _: &'a ast::MethodSig, _, _, _, _| id,\n                     |c: ClosureParts|    c.id)\n     }\n \n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n-            FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis)\n+            FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)\n         };\n-        let closure = |_: ClosureParts| {\n-            FnKind::Closure\n+        let closure = |c: ClosureParts<'a>| {\n+            FnKind::Closure(c.attrs)\n         };\n-        let method = |_, name: Name, sig: &'a ast::MethodSig, vis, _, _| {\n-            FnKind::Method(name, sig, vis)\n+        let method = |_, name: Name, sig: &'a ast::MethodSig, vis, _, _, attrs| {\n+            FnKind::Method(name, sig, vis, attrs)\n         };\n         self.handle(item, method, closure)\n     }\n@@ -207,7 +210,8 @@ impl<'a> FnLikeNode<'a> {\n                   &'a ast::MethodSig,\n                   Option<ast::Visibility>,\n                   &'a ast::Block,\n-                  Span)\n+                  Span,\n+                  &'a [Attribute])\n                   -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n@@ -224,20 +228,21 @@ impl<'a> FnLikeNode<'a> {\n                         abi: abi,\n                         vis: i.vis,\n                         constness: constness,\n-                        span: i.span\n+                        span: i.span,\n+                        attrs: &i.attrs,\n                     }),\n                 _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    method(ti.id, ti.name, sig, None, body, ti.span)\n+                    method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, ref body) => {\n-                        method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span)\n+                        method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")\n@@ -246,7 +251,11 @@ impl<'a> FnLikeNode<'a> {\n             }\n             map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, ref block) =>\n-                    closure(ClosureParts::new(&decl, &block, e.id, e.span)),\n+                    closure(ClosureParts::new(&decl,\n+                                              &block,\n+                                              e.id,\n+                                              e.span,\n+                                              e.attrs.as_attr_slice())),\n                 _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => panic!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "c9c712c2d6e105fd941d7055c84fa39c9e431e9b", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -52,7 +52,9 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n     }\n }\n \n-impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n+impl<'a, 'ast> dot::Labeller<'a> for LabelledCFG<'a, 'ast> {\n+    type Node = Node<'a>;\n+    type Edge = Edge<'a>;\n     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[..]).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n@@ -97,7 +99,9 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n     }\n }\n \n-impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for &'a cfg::CFG {\n+impl<'a> dot::GraphWalk<'a> for &'a cfg::CFG {\n+    type Node = Node<'a>;\n+    type Edge = Edge<'a>;\n     fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> {\n         let mut v = Vec::new();\n         self.graph.each_node(|i, nd| { v.push((i, nd)); true });\n@@ -116,8 +120,10 @@ impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for &'a cfg::CFG {\n     }\n }\n \n-impl<'a, 'ast> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast>\n+impl<'a, 'ast> dot::GraphWalk<'a> for LabelledCFG<'a, 'ast>\n {\n+    type Node = Node<'a>;\n+    type Edge = Edge<'a>;\n     fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }\n     fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.cfg.edges() }\n     fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.source(edge) }"}, {"sha": "b456291b17a0ac6c418aaffdd964d6999cb61ba0", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -1017,7 +1017,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             sp: Span,\n             fn_id: NodeId) {\n     match kind {\n-        FnKind::Closure => {}\n+        FnKind::Closure(_) => {}\n         _ => cx.param_env = ParameterEnvironment::for_item(cx.tcx, fn_id),\n     }\n "}, {"sha": "228a7d21007e50f28c236c7c063fc5151cef0cb1", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -226,10 +226,10 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n     };\n \n     match fn_like.kind() {\n-        FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _) => {\n+        FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _) => {\n             Some(fn_like)\n         }\n-        FnKind::Method(_, m, _) => {\n+        FnKind::Method(_, m, _, _) => {\n             if m.constness == hir::Constness::Const {\n                 Some(fn_like)\n             } else {"}, {"sha": "de3f7f1b0863b36114eb286669569f17a93fd35c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -653,7 +653,7 @@ fn set_bit(words: &mut [usize], bit: usize) -> bool {\n     let word = bit / usize_bits;\n     let bit_in_word = bit % usize_bits;\n     let bit_mask = 1 << bit_in_word;\n-    debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n+    debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n     let oldv = words[word];\n     let newv = oldv | bit_mask;\n     words[word] = newv;"}, {"sha": "d4ff4b797c839861d1cba34a989e4474d6bf96dc", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -82,9 +82,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 block: &'v hir::Block, span: Span, _: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n-            FnKind::ItemFn(_, _, unsafety, _, _, _) =>\n+            FnKind::ItemFn(_, _, unsafety, _, _, _, _) =>\n                 (true, unsafety == hir::Unsafety::Unsafe),\n-            FnKind::Method(_, sig, _) =>\n+            FnKind::Method(_, sig, _, _) =>\n                 (true, sig.unsafety == hir::Unsafety::Unsafe),\n             _ => (false, false),\n         };"}, {"sha": "23559e7b340ebf7cf3d25150edc4127acd313338", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -173,7 +173,9 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n+impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n+    type Node = Node;\n+    type Edge = Edge;\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(&*self.graph_name).unwrap()\n     }\n@@ -224,7 +226,9 @@ fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n     }\n }\n \n-impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n+impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n+    type Node = Node;\n+    type Edge = Edge;\n     fn nodes(&self) -> dot::Nodes<Node> {\n         let mut set = FnvHashSet();\n         for node in self.node_ids.keys() {"}, {"sha": "233e55cdbb5dde2afc897a2d4787655b8c62cea9", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                 intravisit::walk_fn(self, fk, fd, b, s);\n                 self.param_envs.pop();\n             }\n-            FnKind::Closure => {\n+            FnKind::Closure(..) => {\n                 intravisit::walk_fn(self, fk, fd, b, s);\n             }\n         }"}, {"sha": "b5ea365f880a2e3efc32ef4b1271642291a76ede", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -182,17 +182,17 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n         match fk {\n-            FnKind::ItemFn(_, generics, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n                     this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n                 })\n             }\n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n                     this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n                 })\n             }\n-            FnKind::Closure => {\n+            FnKind::Closure(_) => {\n                 self.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n             }\n         }\n@@ -471,16 +471,16 @@ impl<'a> LifetimeContext<'a> {\n                                  fn_id: ast::NodeId) {\n \n         match fk {\n-            FnKind::ItemFn(_, generics, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n                 intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(generics);\n             }\n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(&sig.generics);\n                 self.visit_explicit_self(&sig.explicit_self);\n             }\n-            FnKind::Closure => {\n+            FnKind::Closure(_) => {\n                 intravisit::walk_fn_decl(self, fd);\n             }\n         }"}, {"sha": "1476c3513dcf78eab1c2e9d1a6f366c4a62cb070", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -499,13 +499,13 @@ pub enum Lvalue<'tcx> {\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases\n /// `LvalueProjection` etc below.\n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Projection<'tcx, B, V> {\n     pub base: B,\n     pub elem: ProjectionElem<'tcx, V>,\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ProjectionElem<'tcx, V> {\n     Deref,\n     Field(Field, Ty<'tcx>),\n@@ -857,7 +857,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n@@ -877,7 +877,7 @@ impl<'tcx> Debug for TypedConstVal<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,"}, {"sha": "fdb97bd8d2d1852e298d88ae2337ddea5adf90ee", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -14,3 +14,4 @@ syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n rustc_front = { path = \"../librustc_front\" }\n+rustc_mir = { path = \"../librustc_mir\" }"}, {"sha": "a4aa7ae15744dcb0778eb7711e4470737d775098", "filename": "src/librustc_borrowck/bitslice.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fbitslice.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+/// `BitSlice` provides helper methods for treating a `[usize]`\n+/// as a bitvector.\n+pub trait BitSlice {\n+    fn clear_bit(&mut self, idx: usize) -> bool;\n+    fn set_bit(&mut self, idx: usize) -> bool;\n+    fn get_bit(&self, idx: usize) -> bool;\n+}\n+\n+impl BitSlice for [usize] {\n+    /// Clears bit at `idx` to 0; returns true iff this changed `self.`\n+    fn clear_bit(&mut self, idx: usize) -> bool {\n+        let words = self;\n+        debug!(\"clear_bit: words={} idx={}\",\n+               bits_to_string(words, words.len() * mem::size_of::<usize>()), bit_str(idx));\n+        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n+        debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n+        let oldv = words[word];\n+        let newv = oldv & !bit_mask;\n+        words[word] = newv;\n+        oldv != newv\n+    }\n+\n+    /// Sets bit at `idx` to 1; returns true iff this changed `self.`\n+    fn set_bit(&mut self, idx: usize) -> bool {\n+        let words = self;\n+        debug!(\"set_bit: words={} idx={}\",\n+               bits_to_string(words, words.len() * mem::size_of::<usize>()), bit_str(idx));\n+        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n+        debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n+        let oldv = words[word];\n+        let newv = oldv | bit_mask;\n+        words[word] = newv;\n+        oldv != newv\n+    }\n+\n+    /// Extracts value of bit at `idx` in `self`.\n+    fn get_bit(&self, idx: usize) -> bool {\n+        let words = self;\n+        let BitLookup { word, bit_mask, .. } = bit_lookup(idx);\n+        (words[word] & bit_mask) != 0\n+    }\n+}\n+\n+struct BitLookup {\n+    /// An index of the word holding the bit in original `[usize]` of query.\n+    word: usize,\n+    /// Index of the particular bit within the word holding the bit.\n+    bit_in_word: usize,\n+    /// Word with single 1-bit set corresponding to where the bit is located.\n+    bit_mask: usize,\n+}\n+\n+#[inline]\n+fn bit_lookup(bit: usize) -> BitLookup {\n+    let usize_bits = mem::size_of::<usize>() * 8;\n+    let word = bit / usize_bits;\n+    let bit_in_word = bit % usize_bits;\n+    let bit_mask = 1 << bit_in_word;\n+    BitLookup { word: word, bit_in_word: bit_in_word, bit_mask: bit_mask }\n+}\n+\n+\n+fn bit_str(bit: usize) -> String {\n+    let byte = bit >> 8;\n+    let lobits = 1 << (bit & 0xFF);\n+    format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n+}\n+\n+pub fn bits_to_string(words: &[usize], bytes: usize) -> String {\n+    let mut result = String::new();\n+    let mut sep = '[';\n+\n+    // Note: this is a little endian printout of bytes.\n+\n+    let mut i = 0;\n+    for &word in words.iter() {\n+        let mut v = word;\n+        for _ in 0..mem::size_of::<usize>() {\n+            let byte = v & 0xFF;\n+            if i >= bytes {\n+                assert!(byte == 0);\n+            } else {\n+                result.push(sep);\n+                result.push_str(&format!(\"{:02x}\", byte));\n+            }\n+            v >>= 8;\n+            i += 1;\n+            sep = '-';\n+        }\n+    }\n+    result.push(']');\n+    return result\n+}"}, {"sha": "aa885eb47424d8ade55971fa0bbe562ae3a77c15", "filename": "src/librustc_borrowck/borrowck/mir/abs_domain.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The move-analysis portion of borrowck needs to work in an abstract\n+//! domain of lifted Lvalues.  Most of the Lvalue variants fall into a\n+//! one-to-one mapping between the concrete and abstract (e.g. a\n+//! field-deref on a local-variable, `x.field`, has the same meaning\n+//! in both domains). Indexed-Projections are the exception: `a[x]`\n+//! needs to be treated as mapping to the same move path as `a[y]` as\n+//! well as `a[13]`, et cetera.\n+//!\n+//! (In theory the analysis could be extended to work with sets of\n+//! paths, so that `a[0]` and `a[13]` could be kept distinct, while\n+//! `a[x]` would still overlap them both. But that is not this\n+//! representation does today.)\n+\n+use rustc::mir::repr::{Lvalue, LvalueElem};\n+use rustc::mir::repr::{Operand, Projection, ProjectionElem};\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct AbstractOperand;\n+pub type AbstractProjection<'tcx> =\n+    Projection<'tcx, Lvalue<'tcx>, AbstractOperand>;\n+pub type AbstractElem<'tcx> =\n+    ProjectionElem<'tcx, AbstractOperand>;\n+\n+pub trait Lift {\n+    type Abstract;\n+    fn lift(&self) -> Self::Abstract;\n+}\n+impl<'tcx> Lift for Operand<'tcx> {\n+    type Abstract = AbstractOperand;\n+    fn lift(&self) -> Self::Abstract { AbstractOperand }\n+}\n+impl<'tcx> Lift for LvalueElem<'tcx> {\n+    type Abstract = AbstractElem<'tcx>;\n+    fn lift(&self) -> Self::Abstract {\n+        match *self {\n+            ProjectionElem::Deref =>\n+                ProjectionElem::Deref,\n+            ProjectionElem::Field(ref f, ty) =>\n+                ProjectionElem::Field(f.clone(), ty.clone()),\n+            ProjectionElem::Index(ref i) =>\n+                ProjectionElem::Index(i.lift()),\n+            ProjectionElem::ConstantIndex {offset,min_length,from_end} =>\n+                ProjectionElem::ConstantIndex {\n+                    offset: offset,\n+                    min_length: min_length,\n+                    from_end: from_end\n+                },\n+            ProjectionElem::Downcast(a, u) =>\n+                ProjectionElem::Downcast(a.clone(), u.clone()),\n+        }\n+    }\n+}"}, {"sha": "69aaae91c49fa38132a40669598cd4c225bab02a", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "added", "additions": 505, "deletions": 0, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -0,0 +1,505 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::attr::AttrMetaMethods;\n+\n+use rustc::middle::ty;\n+use rustc::mir::repr::{self, Mir};\n+\n+use std::io;\n+use std::mem;\n+use std::usize;\n+\n+use super::MirBorrowckCtxt;\n+use super::gather_moves::{Location, MoveData, MovePathData, MovePathIndex, MoveOutIndex, PathMap};\n+use super::graphviz;\n+use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n+\n+pub trait Dataflow {\n+    fn dataflow(&mut self);\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> Dataflow for MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn dataflow(&mut self) {\n+        self.build_gen_and_kill_sets();\n+        self.pre_dataflow_instrumentation().unwrap();\n+        self.propagate();\n+        self.post_dataflow_instrumentation().unwrap();\n+    }\n+}\n+\n+struct PropagationContext<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn>\n+    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n+{\n+    mbcx: &'c mut MirBorrowckCtxt<'b, 'a, 'tcx>,\n+    changed: bool,\n+    on_return: OnReturn\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn propagate(&mut self) {\n+        let mut temp = vec![0; self.flow_state.sets.words_per_block];\n+        let mut propcx = PropagationContext {\n+            mbcx: &mut *self,\n+            changed: true,\n+            on_return: |move_data, in_out, dest_lval| {\n+                let move_path_index = move_data.rev_lookup.find(dest_lval);\n+                on_all_children_bits(in_out,\n+                                     &move_data.path_map,\n+                                     &move_data.move_paths,\n+                                     move_path_index,\n+                                     &|in_out, mpi| {\n+                                         in_out.clear_bit(mpi.idx());\n+                                     });\n+            },\n+        };\n+        while propcx.changed {\n+            propcx.changed = false;\n+            propcx.reset(&mut temp);\n+            propcx.walk_cfg(&mut temp);\n+        }\n+    }\n+\n+    fn build_gen_and_kill_sets(&mut self) {\n+        // First we need to build the gen- and kill-sets. The\n+        // gather_moves information provides a high-level mapping from\n+        // mir-locations to the MoveOuts (and those correspond\n+        // directly to gen-sets here). But we still need to figure out\n+        // the kill-sets.\n+\n+        let move_data = &self.flow_state.operator;\n+        let move_paths = &move_data.move_paths;\n+        let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+\n+        for bb in self.mir.all_basic_blocks() {\n+            let &repr::BasicBlockData { ref statements,\n+                                        ref terminator,\n+                                        is_cleanup: _ } =\n+                self.mir.basic_block_data(bb);\n+\n+            let mut sets = self.flow_state.sets.for_block(bb.index());\n+            for (j, stmt) in statements.iter().enumerate() {\n+                let loc = Location { block: bb, index: j };\n+                debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n+                       stmt, loc, &loc_map[loc]);\n+                for move_index in &loc_map[loc] {\n+                    // Every path deinitialized by a *particular move*\n+                    // has corresponding bit, \"gen'ed\" (i.e. set)\n+                    // here, in dataflow vector\n+                    zero_to_one(&mut sets.gen_set, *move_index);\n+                }\n+                match stmt.kind {\n+                    repr::StatementKind::Assign(ref lvalue, _) => {\n+                        // assigning into this `lvalue` kills all\n+                        // MoveOuts from it, and *also* all MoveOuts\n+                        // for children and associated fragment sets.\n+                        let move_path_index = rev_lookup.find(lvalue);\n+\n+                        on_all_children_bits(sets.kill_set,\n+                                             path_map,\n+                                             move_paths,\n+                                             move_path_index,\n+                                             &|kill_set, mpi| {\n+                                                 kill_set.set_bit(mpi.idx());\n+                                             });\n+                    }\n+                }\n+            }\n+\n+            let loc = Location { block: bb, index: statements.len() };\n+            debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n+                   terminator, loc, &loc_map[loc]);\n+            for move_index in &loc_map[loc] {\n+                zero_to_one(&mut sets.gen_set, *move_index);\n+            }\n+        }\n+\n+        fn zero_to_one(gen_set: &mut [usize], move_index: MoveOutIndex) {\n+            let retval = gen_set.set_bit(move_index.idx());\n+            assert!(retval);\n+        }\n+    }\n+}\n+\n+fn on_all_children_bits<Each>(set: &mut [usize],\n+                              path_map: &PathMap,\n+                              move_paths: &MovePathData,\n+                              move_path_index: MovePathIndex,\n+                              each_child: &Each)\n+    where Each: Fn(&mut [usize], MoveOutIndex)\n+{\n+    // 1. invoke `each_child` callback for all moves that directly\n+    //    influence path for `move_path_index`\n+    for move_index in &path_map[move_path_index] {\n+        each_child(set, *move_index);\n+    }\n+\n+    // 2. for each child of the path (that is named in this\n+    //    function), recur.\n+    //\n+    // (Unnamed children are irrelevant to dataflow; by\n+    // definition they have no associated moves.)\n+    let mut next_child_index = move_paths[move_path_index].first_child;\n+    while let Some(child_index) = next_child_index {\n+        on_all_children_bits(set, path_map, move_paths, child_index, each_child);\n+        next_child_index = move_paths[child_index].next_sibling;\n+    }\n+}\n+\n+impl<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn> PropagationContext<'c, 'b, 'a, 'tcx, OnReturn>\n+    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n+{\n+    fn reset(&mut self, bits: &mut [usize]) {\n+        let e = if self.mbcx.flow_state.operator.initial_value() {usize::MAX} else {0};\n+        for b in bits {\n+            *b = e;\n+        }\n+    }\n+\n+    fn walk_cfg(&mut self, in_out: &mut [usize]) {\n+        let &mut MirBorrowckCtxt { ref mir, ref mut flow_state, .. } = self.mbcx;\n+        for (idx, bb) in mir.basic_blocks.iter().enumerate() {\n+            {\n+                let sets = flow_state.sets.for_block(idx);\n+                debug_assert!(in_out.len() == sets.on_entry.len());\n+                in_out.clone_from_slice(sets.on_entry);\n+                bitwise(in_out, sets.gen_set, &Union);\n+                bitwise(in_out, sets.kill_set, &Subtract);\n+            }\n+            flow_state.propagate_bits_into_graph_successors_of(in_out,\n+                                                               &mut self.changed,\n+                                                               bb,\n+                                                               &self.on_return);\n+        }\n+    }\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn pre_dataflow_instrumentation(&self) -> io::Result<()> {\n+        self.if_attr_meta_name_found(\n+            \"borrowck_graphviz_preflow\",\n+            |this, path: &str| {\n+                graphviz::print_borrowck_graph_to(this, \"preflow\", path)\n+            })\n+    }\n+\n+    fn post_dataflow_instrumentation(&self) -> io::Result<()> {\n+        self.if_attr_meta_name_found(\n+            \"borrowck_graphviz_postflow\",\n+            |this, path: &str| {\n+                graphviz::print_borrowck_graph_to(this, \"postflow\", path)\n+            })\n+    }\n+\n+    fn if_attr_meta_name_found<F>(&self,\n+                                  name: &str,\n+                                  callback: F) -> io::Result<()>\n+        where F: for <'aa, 'bb> FnOnce(&'aa Self, &'bb str) -> io::Result<()>\n+    {\n+        for attr in self.attributes {\n+            if attr.check_name(\"rustc_mir\") {\n+                let items = attr.meta_item_list();\n+                for item in items.iter().flat_map(|l| l.iter()) {\n+                    if item.check_name(name) {\n+                        if let Some(s) = item.value_str() {\n+                            return callback(self, &s);\n+                        } else {\n+                            self.bcx.tcx.sess.span_err(\n+                                item.span,\n+                                &format!(\"{} attribute requires a path\", item.name()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+/// Maps each block to a set of bits\n+#[derive(Clone, Debug)]\n+struct Bits {\n+    bits: Vec<usize>,\n+}\n+\n+impl Bits {\n+    fn new(init_word: usize, num_words: usize) -> Self {\n+        Bits { bits: vec![init_word; num_words] }\n+    }\n+}\n+\n+pub struct DataflowState<O: BitDenotation>\n+{\n+    /// All the sets for the analysis. (Factored into its\n+    /// own structure so that we can borrow it mutably\n+    /// on its own separate from other fields.)\n+    pub sets: AllSets,\n+\n+    /// operator used to initialize, combine, and interpret bits.\n+    operator: O,\n+}\n+\n+pub struct AllSets {\n+    /// Analysis bitwidth for each block.\n+    bits_per_block: usize,\n+\n+    /// Number of words associated with each block entry\n+    /// equal to bits_per_block / usize::BITS, rounded up.\n+    words_per_block: usize,\n+\n+    /// For each block, bits generated by executing the statements in\n+    /// the block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    gen_sets: Bits,\n+\n+    /// For each block, bits killed by executing the statements in the\n+    /// block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    kill_sets: Bits,\n+\n+    /// For each block, bits valid on entry to the block.\n+    on_entry_sets: Bits,\n+}\n+\n+pub struct BlockSets<'a> {\n+    on_entry: &'a mut [usize],\n+    gen_set: &'a mut [usize],\n+    kill_set: &'a mut [usize],\n+}\n+\n+impl AllSets {\n+    pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n+    pub fn bytes_per_block(&self) -> usize { (self.bits_per_block + 7) / 8 }\n+    pub fn for_block(&mut self, block_idx: usize) -> BlockSets {\n+        let offset = self.words_per_block * block_idx;\n+        let range = offset..(offset + self.words_per_block);\n+        BlockSets {\n+            on_entry: &mut self.on_entry_sets.bits[range.clone()],\n+            gen_set: &mut self.gen_sets.bits[range.clone()],\n+            kill_set: &mut self.kill_sets.bits[range],\n+        }\n+    }\n+\n+    fn lookup_set_for<'a>(&self, sets: &'a Bits, block_idx: usize) -> &'a [usize] {\n+        let offset = self.words_per_block * block_idx;\n+        &sets.bits[offset..(offset + self.words_per_block)]\n+    }\n+    pub fn gen_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.gen_sets, block_idx)\n+    }\n+    pub fn kill_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.kill_sets, block_idx)\n+    }\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.on_entry_sets, block_idx)\n+    }\n+}\n+\n+impl<O: BitDenotation> DataflowState<O> {\n+    fn each_bit<F>(&self, words: &[usize], mut f: F)\n+        where F: FnMut(usize) {\n+        //! Helper for iterating over the bits in a bitvector.\n+\n+        for (word_index, &word) in words.iter().enumerate() {\n+            if word != 0 {\n+                let usize_bits: usize = mem::size_of::<usize>();\n+                let base_index = word_index * usize_bits;\n+                for offset in 0..usize_bits {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of usize::BITS. This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value; that's why we first check\n+                        // that we are in range of bits_per_block.\n+                        let bit_index = base_index + offset as usize;\n+                        if bit_index >= self.sets.bits_per_block() {\n+                            return;\n+                        } else {\n+                            f(bit_index);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn interpret_set(&self, words: &[usize]) -> Vec<&O::Bit> {\n+        let mut v = Vec::new();\n+        self.each_bit(words, |i| {\n+            v.push(self.operator.interpret(i));\n+        });\n+        v\n+    }\n+}\n+\n+pub trait BitwiseOperator {\n+    /// Joins two predecessor bits together, typically either `|` or `&`\n+    fn join(&self, pred1: usize, pred2: usize) -> usize;\n+}\n+\n+/// Parameterization for the precise form of data flow that is used.\n+pub trait DataflowOperator : BitwiseOperator {\n+    /// Specifies the initial value for each bit in the `on_entry` set\n+    fn initial_value(&self) -> bool;\n+}\n+\n+pub trait BitDenotation: DataflowOperator {\n+    /// Specifies what is represented by each bit in the dataflow bitvector.\n+    type Bit;\n+    /// Size of each bivector allocated for each block in the analysis.\n+    fn bits_per_block(&self) -> usize;\n+    /// Provides the meaning of each entry in the dataflow bitvector.\n+    /// (Mostly intended for use for better debug instrumentation.)\n+    fn interpret(&self, idx: usize) -> &Self::Bit;\n+}\n+\n+impl<D: BitDenotation> DataflowState<D> {\n+    pub fn new(mir: &Mir, denotation: D) -> Self {\n+        let bits_per_block = denotation.bits_per_block();\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n+        let num_blocks = mir.basic_blocks.len();\n+        let num_words = num_blocks * words_per_block;\n+\n+        let entry = if denotation.initial_value() { usize::MAX } else {0};\n+\n+        let zeroes = Bits::new(0, num_words);\n+        let on_entry = Bits::new(entry, num_words);\n+\n+        DataflowState {\n+            sets: AllSets {\n+                bits_per_block: bits_per_block,\n+                words_per_block: words_per_block,\n+                gen_sets: zeroes.clone(),\n+                kill_sets: zeroes,\n+                on_entry_sets: on_entry,\n+            },\n+            operator: denotation,\n+        }\n+    }\n+}\n+\n+impl<D: BitDenotation> DataflowState<D> {\n+    /// Propagates the bits of `in_out` into all the successors of `bb`,\n+    /// using bitwise operator denoted by `self.operator`.\n+    ///\n+    /// For most blocks, this is entirely uniform. However, for blocks\n+    /// that end with a call terminator, the effect of the call on the\n+    /// dataflow state may depend on whether the call returned\n+    /// successfully or unwound. To reflect this, the `on_return`\n+    /// callback mutates `in_out` when propagating `in_out` via a call\n+    /// terminator; such mutation is performed *last*, to ensure its\n+    /// side-effects do not leak elsewhere (e.g. into unwind target).\n+    fn propagate_bits_into_graph_successors_of<OnReturn>(\n+        &mut self,\n+        in_out: &mut [usize],\n+        changed: &mut bool,\n+        bb: &repr::BasicBlockData,\n+        on_return: OnReturn) where OnReturn: Fn(&D, &mut [usize], &repr::Lvalue)\n+    {\n+        let term = if let Some(ref term) = bb.terminator { term } else { return };\n+        match *term {\n+            repr::Terminator::Return |\n+            repr::Terminator::Resume => {}\n+            repr::Terminator::Goto { ref target } |\n+            repr::Terminator::Drop { ref target, value: _, unwind: None } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+            }\n+            repr::Terminator::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+            }\n+            repr::Terminator::If { ref targets, .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n+            }\n+            repr::Terminator::Switch { ref targets, .. } |\n+            repr::Terminator::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                }\n+            }\n+            repr::Terminator::Call { ref cleanup, ref destination, func: _, args: _ } => {\n+                if let Some(ref unwind) = *cleanup {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+                }\n+                if let Some((ref dest_lval, ref dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, after all other\n+                    // propagation, as documented in comment above.\n+                    on_return(&self.operator, in_out, dest_lval);\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(&mut self,\n+                                         in_out: &[usize],\n+                                         changed: &mut bool,\n+                                         bb: &repr::BasicBlock) {\n+        let entry_set = self.sets.for_block(bb.index()).on_entry;\n+        let set_changed = bitwise(entry_set, in_out, &self.operator);\n+        if set_changed {\n+            *changed = true;\n+        }\n+    }\n+}\n+\n+\n+impl<'tcx> DataflowState<MoveData<'tcx>> {\n+    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> Self {\n+        let move_data = MoveData::gather_moves(mir, tcx);\n+        DataflowState::new(mir, move_data)\n+    }\n+}\n+\n+impl<'tcx> BitwiseOperator for MoveData<'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // moves from both preds are in scope\n+    }\n+}\n+\n+impl<'tcx> DataflowOperator for MoveData<'tcx> {\n+    #[inline]\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n+    }\n+}\n+\n+#[inline]\n+fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n+                               in_vec: &[usize],\n+                               op: &Op) -> bool {\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n+        let old_val = *out_elt;\n+        let new_val = op.join(old_val, *in_elt);\n+        *out_elt = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+struct Union;\n+impl BitwiseOperator for Union {\n+    fn join(&self, a: usize, b: usize) -> usize { a | b }\n+}\n+struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n+}"}, {"sha": "17a016a3ae300e5aa3ae125f9826c6f7c7f10881", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "added", "additions": 747, "deletions": 0, "changes": 747, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -0,0 +1,747 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use rustc::middle::ty;\n+use rustc::mir::repr::{self, Mir, BasicBlock, Lvalue, Rvalue};\n+use rustc::mir::repr::{StatementKind, Terminator};\n+use rustc::util::nodemap::FnvHashMap;\n+\n+use std::cell::{Cell};\n+use std::collections::hash_map::Entry;\n+use std::fmt;\n+use std::iter;\n+use std::ops::Index;\n+\n+use super::dataflow::BitDenotation;\n+use super::abs_domain::{AbstractElem, Lift};\n+\n+// This submodule holds some newtype'd Index wrappers that are using\n+// NonZero to ensure that Option<Index> occupies only a single word.\n+// They are in a submodule to impose privacy restrictions; namely, to\n+// ensure that other code does not accidentally access `index.0`\n+// (which is likely to yield a subtle off-by-one error).\n+mod indexes {\n+    use core::nonzero::NonZero;\n+\n+    macro_rules! new_index {\n+        ($Index:ident) => {\n+            #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+            pub struct $Index(NonZero<usize>);\n+\n+            impl $Index {\n+                pub fn new(idx: usize) -> Self {\n+                    unsafe { $Index(NonZero::new(idx + 1)) }\n+                }\n+                pub fn idx(&self) -> usize {\n+                    *self.0 - 1\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Index into MovePathData.move_paths\n+    new_index!(MovePathIndex);\n+\n+    /// Index into MoveData.moves.\n+    new_index!(MoveOutIndex);\n+}\n+\n+pub use self::indexes::MovePathIndex;\n+pub use self::indexes::MoveOutIndex;\n+\n+/// `MovePath` is a canonicalized representation of a path that is\n+/// moved or assigned to.\n+///\n+/// It follows a tree structure.\n+///\n+/// Given `struct X { m: M, n: N }` and `x: X`, moves like `drop x.m;`\n+/// move *out* of the l-value `x.m`.\n+///\n+/// The MovePaths representing `x.m` and `x.n` are siblings (that is,\n+/// one of them will link to the other via the `next_sibling` field,\n+/// and the other will have no entry in its `next_sibling` field), and\n+/// they both have the MovePath representing `x` as their parent.\n+#[derive(Clone)]\n+pub struct MovePath<'tcx> {\n+    pub next_sibling: Option<MovePathIndex>,\n+    pub first_child: Option<MovePathIndex>,\n+    pub parent: Option<MovePathIndex>,\n+    pub content: MovePathContent<'tcx>,\n+}\n+\n+/// MovePaths usually represent a single l-value. The exceptions are\n+/// forms that arise due to erroneous input code: static data holds\n+/// l-values that we cannot actually move out of. Therefore we map\n+/// statics to a special marker value (`MovePathContent::Static`)\n+/// representing an invalid origin.\n+#[derive(Clone, Debug)]\n+pub enum MovePathContent<'tcx> {\n+    Lvalue(Lvalue<'tcx>),\n+    Static,\n+}\n+\n+/// During construction of the MovePath's, we use PreMovePath to\n+/// represent accumulated state while we are gathering up all the\n+/// children of each path.\n+#[derive(Clone)]\n+struct PreMovePath<'tcx> {\n+    pub next_sibling: Option<MovePathIndex>,\n+    pub first_child: Cell<Option<MovePathIndex>>,\n+    pub parent: Option<MovePathIndex>,\n+    pub content: MovePathContent<'tcx>,\n+}\n+\n+impl<'tcx> PreMovePath<'tcx> {\n+    fn into_move_path(self) -> MovePath<'tcx> {\n+        MovePath {\n+            next_sibling: self.next_sibling,\n+            parent: self.parent,\n+            content: self.content,\n+            first_child: self.first_child.get(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for MovePath<'tcx> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(w, \"MovePath {{\"));\n+        if let Some(parent) = self.parent {\n+            try!(write!(w, \" parent: {:?},\", parent));\n+        }\n+        if let Some(first_child) = self.first_child {\n+            try!(write!(w, \" first_child: {:?},\", first_child));\n+        }\n+        if let Some(next_sibling) = self.next_sibling {\n+            try!(write!(w, \" next_sibling: {:?}\", next_sibling));\n+        }\n+        write!(w, \" content: {:?} }}\", self.content)\n+    }\n+}\n+\n+pub struct MoveData<'tcx> {\n+    pub move_paths: MovePathData<'tcx>,\n+    pub moves: Vec<MoveOut>,\n+    pub loc_map: LocMap,\n+    pub path_map: PathMap,\n+    pub rev_lookup: MovePathLookup<'tcx>,\n+}\n+\n+pub struct LocMap {\n+    /// Location-indexed (BasicBlock for outer index, index within BB\n+    /// for inner index) map to list of MoveOutIndex's.\n+    ///\n+    /// Each Location `l` is mapped to the MoveOut's that are effects\n+    /// of executing the code at `l`. (There can be multiple MoveOut's\n+    /// for a given `l` because each MoveOut is associated with one\n+    /// particular path being moved.)\n+    map: Vec<Vec<Vec<MoveOutIndex>>>,\n+}\n+\n+impl Index<Location> for LocMap {\n+    type Output = [MoveOutIndex];\n+    fn index(&self, index: Location) -> &Self::Output {\n+        assert!(index.block.index() < self.map.len());\n+        assert!(index.index < self.map[index.block.index()].len());\n+        &self.map[index.block.index()][index.index]\n+    }\n+}\n+\n+pub struct PathMap {\n+    /// Path-indexed map to list of MoveOutIndex's.\n+    ///\n+    /// Each Path `p` is mapped to the MoveOut's that move out of `p`.\n+    map: Vec<Vec<MoveOutIndex>>,\n+}\n+\n+impl Index<MovePathIndex> for PathMap {\n+    type Output = [MoveOutIndex];\n+    fn index(&self, index: MovePathIndex) -> &Self::Output {\n+        &self.map[index.idx()]\n+    }\n+}\n+\n+/// `MoveOut` represents a point in a program that moves out of some\n+/// L-value; i.e., \"creates\" uninitialized memory.\n+///\n+/// With respect to dataflow analysis:\n+/// - Generated by moves and declaration of uninitialized variables.\n+/// - Killed by assignments to the memory.\n+#[derive(Copy, Clone)]\n+pub struct MoveOut {\n+    /// path being moved\n+    pub path: MovePathIndex,\n+    /// location of move\n+    pub source: Location,\n+}\n+\n+impl fmt::Debug for MoveOut {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"p{}@{:?}\", self.path.idx(), self.source)\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Location {\n+    /// block where action is located\n+    pub block: BasicBlock,\n+    /// index within above block; statement when < statments.len) or\n+    /// the terminator (when = statements.len).\n+    pub index: usize,\n+}\n+\n+impl fmt::Debug for Location {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}[{}]\", self.block, self.index)\n+    }\n+}\n+\n+pub struct MovePathData<'tcx> {\n+    move_paths: Vec<MovePath<'tcx>>,\n+}\n+\n+impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n+    type Output = MovePath<'tcx>;\n+    fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n+        &self.move_paths[i.idx()]\n+    }\n+}\n+\n+/// MovePathInverseMap maps from a uint in an lvalue-category to the\n+/// MovePathIndex for the MovePath for that lvalue.\n+type MovePathInverseMap = Vec<Option<MovePathIndex>>;\n+\n+struct MovePathDataBuilder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    pre_move_paths: Vec<PreMovePath<'tcx>>,\n+    rev_lookup: MovePathLookup<'tcx>,\n+}\n+\n+/// Tables mapping from an l-value to its MovePathIndex.\n+pub struct MovePathLookup<'tcx> {\n+    vars: MovePathInverseMap,\n+    temps: MovePathInverseMap,\n+    args: MovePathInverseMap,\n+\n+    /// The move path representing the return value is constructed\n+    /// lazily when we first encounter it in the input MIR.\n+    return_ptr: Option<MovePathIndex>,\n+\n+    /// A single move path (representing any static data referenced)\n+    /// is constructed lazily when we first encounter statics in the\n+    /// input MIR.\n+    statics: Option<MovePathIndex>,\n+\n+    /// projections are made from a base-lvalue and a projection\n+    /// elem. The base-lvalue will have a unique MovePathIndex; we use\n+    /// the latter as the index into the outer vector (narrowing\n+    /// subsequent search so that it is solely relative to that\n+    /// base-lvalue). For the remaining lookup, we map the projection\n+    /// elem to the associated MovePathIndex.\n+    projections: Vec<FnvHashMap<AbstractElem<'tcx>, MovePathIndex>>,\n+\n+    /// Tracks the next index to allocate during construction of the\n+    /// MovePathData. Unused after MovePathData is fully constructed.\n+    next_index: MovePathIndex,\n+}\n+\n+trait FillTo {\n+    type T;\n+    fn fill_to_with(&mut self, idx: usize, x: Self::T);\n+    fn fill_to(&mut self, idx: usize) where Self::T: Default {\n+        self.fill_to_with(idx, Default::default())\n+    }\n+}\n+impl<T:Clone> FillTo for Vec<T> {\n+    type T = T;\n+    fn fill_to_with(&mut self, idx: usize, x: T) {\n+        if idx >= self.len() {\n+            let delta = idx + 1 - self.len();\n+            assert_eq!(idx + 1, self.len() + delta);\n+            self.extend(iter::repeat(x).take(delta))\n+        }\n+        debug_assert!(idx < self.len());\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+enum LookupKind { Generate, Reuse }\n+struct Lookup<T>(LookupKind, T);\n+\n+impl Lookup<MovePathIndex> {\n+    fn idx(&self) -> usize { (self.1).idx() }\n+}\n+\n+impl<'tcx> MovePathLookup<'tcx> {\n+    fn new() -> Self {\n+        MovePathLookup {\n+            vars: vec![],\n+            temps: vec![],\n+            args: vec![],\n+            statics: None,\n+            return_ptr: None,\n+            projections: vec![],\n+            next_index: MovePathIndex::new(0),\n+        }\n+    }\n+\n+    fn next_index(next: &mut MovePathIndex) -> MovePathIndex {\n+        let i = *next;\n+        *next = MovePathIndex::new(i.idx() + 1);\n+        i\n+    }\n+\n+    fn lookup_or_generate(vec: &mut Vec<Option<MovePathIndex>>,\n+                          idx: u32,\n+                          next_index: &mut MovePathIndex) -> Lookup<MovePathIndex> {\n+        let idx = idx as usize;\n+        vec.fill_to_with(idx, None);\n+        let entry = &mut vec[idx];\n+        match *entry {\n+            None => {\n+                let i = Self::next_index(next_index);\n+                *entry = Some(i);\n+                Lookup(LookupKind::Generate, i)\n+            }\n+            Some(entry_idx) => {\n+                Lookup(LookupKind::Reuse, entry_idx)\n+            }\n+        }\n+    }\n+\n+    fn lookup_var(&mut self, var_idx: u32) -> Lookup<MovePathIndex> {\n+        Self::lookup_or_generate(&mut self.vars,\n+                                 var_idx,\n+                                 &mut self.next_index)\n+    }\n+\n+    fn lookup_temp(&mut self, temp_idx: u32) -> Lookup<MovePathIndex> {\n+        Self::lookup_or_generate(&mut self.temps,\n+                                 temp_idx,\n+                                 &mut self.next_index)\n+    }\n+\n+    fn lookup_arg(&mut self, arg_idx: u32) -> Lookup<MovePathIndex> {\n+        Self::lookup_or_generate(&mut self.args,\n+                                 arg_idx,\n+                                 &mut self.next_index)\n+    }\n+\n+    fn lookup_static(&mut self) -> Lookup<MovePathIndex> {\n+        match self.statics {\n+            Some(mpi) => {\n+                Lookup(LookupKind::Reuse, mpi)\n+            }\n+            ref mut ret @ None => {\n+                let mpi = Self::next_index(&mut self.next_index);\n+                *ret = Some(mpi);\n+                Lookup(LookupKind::Generate, mpi)\n+            }\n+        }\n+    }\n+\n+    fn lookup_return_pointer(&mut self) -> Lookup<MovePathIndex> {\n+        match self.return_ptr {\n+            Some(mpi) => {\n+                Lookup(LookupKind::Reuse, mpi)\n+            }\n+            ref mut ret @ None => {\n+                let mpi = Self::next_index(&mut self.next_index);\n+                *ret = Some(mpi);\n+                Lookup(LookupKind::Generate, mpi)\n+            }\n+        }\n+    }\n+\n+    fn lookup_proj(&mut self,\n+                   proj: &repr::LvalueProjection<'tcx>,\n+                   base: MovePathIndex) -> Lookup<MovePathIndex> {\n+        let MovePathLookup { ref mut projections,\n+                             ref mut next_index, .. } = *self;\n+        projections.fill_to(base.idx());\n+        match projections[base.idx()].entry(proj.elem.lift()) {\n+            Entry::Occupied(ent) => {\n+                Lookup(LookupKind::Reuse, *ent.get())\n+            }\n+            Entry::Vacant(ent) => {\n+                let mpi = Self::next_index(next_index);\n+                ent.insert(mpi);\n+                Lookup(LookupKind::Generate, mpi)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> MovePathLookup<'tcx> {\n+    // Unlike the builder `fn move_path_for` below, this lookup\n+    // alternative will *not* create a MovePath on the fly for an\n+    // unknown l-value; it will simply panic.\n+    pub fn find(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+        match *lval {\n+            Lvalue::Var(var_idx) => self.vars[var_idx as usize].unwrap(),\n+            Lvalue::Temp(temp_idx) => self.temps[temp_idx as usize].unwrap(),\n+            Lvalue::Arg(arg_idx) => self.args[arg_idx as usize].unwrap(),\n+            Lvalue::Static(ref _def_id) => self.statics.unwrap(),\n+            Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n+            Lvalue::Projection(ref proj) => {\n+                let base_index = self.find(&proj.base);\n+                self.projections[base_index.idx()][&proj.elem.lift()]\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n+    fn lookup(&mut self, lval: &Lvalue<'tcx>) -> Lookup<MovePathIndex> {\n+        let proj = match *lval {\n+            Lvalue::Var(var_idx) =>\n+                return self.rev_lookup.lookup_var(var_idx),\n+            Lvalue::Temp(temp_idx) =>\n+                return self.rev_lookup.lookup_temp(temp_idx),\n+            Lvalue::Arg(arg_idx) =>\n+                return self.rev_lookup.lookup_arg(arg_idx),\n+            Lvalue::Static(_def_id) =>\n+                return self.rev_lookup.lookup_static(),\n+            Lvalue::ReturnPointer =>\n+                return self.rev_lookup.lookup_return_pointer(),\n+            Lvalue::Projection(ref proj) => {\n+                proj\n+            }\n+        };\n+\n+        let base_index = self.move_path_for(&proj.base);\n+        self.rev_lookup.lookup_proj(proj, base_index)\n+    }\n+\n+    fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+        let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n+\n+        // `lookup` is either the previously assigned index or a\n+        // newly-allocated one.\n+        debug_assert!(lookup.idx() <= self.pre_move_paths.len());\n+\n+        if let Lookup(LookupKind::Generate, mpi) = lookup {\n+            let parent;\n+            let sibling;\n+            // tracks whether content is Some non-static; statics map to None.\n+            let content: Option<&Lvalue<'tcx>>;\n+\n+            match *lval {\n+                Lvalue::Static(_) => {\n+                    content = None;\n+                    sibling = None;\n+                    parent = None;\n+                }\n+\n+                Lvalue::Var(_) | Lvalue::Temp(_) | Lvalue::Arg(_) |\n+                Lvalue::ReturnPointer => {\n+                    content = Some(lval);\n+                    sibling = None;\n+                    parent = None;\n+                }\n+                Lvalue::Projection(ref proj) => {\n+                    content = Some(lval);\n+\n+                    // Here, install new MovePath as new first_child.\n+\n+                    // Note: `parent` previously allocated (Projection\n+                    // case of match above established this).\n+                    let idx = self.move_path_for(&proj.base);\n+                    parent = Some(idx);\n+\n+                    let parent_move_path = &mut self.pre_move_paths[idx.idx()];\n+\n+                    // At last: Swap in the new first_child.\n+                    sibling = parent_move_path.first_child.get();\n+                    parent_move_path.first_child.set(Some(mpi));\n+                }\n+            };\n+\n+            let content = match content {\n+                Some(lval) => MovePathContent::Lvalue(lval.clone()),\n+                None => MovePathContent::Static,\n+            };\n+\n+            let move_path = PreMovePath {\n+                next_sibling: sibling,\n+                parent: parent,\n+                content: content,\n+                first_child: Cell::new(None),\n+            };\n+\n+            self.pre_move_paths.push(move_path);\n+        }\n+\n+        return lookup.1;\n+    }\n+}\n+\n+impl<'tcx> MoveData<'tcx> {\n+    pub fn gather_moves(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> Self {\n+        gather_moves(mir, tcx)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum StmtKind {\n+    Use, Repeat, Cast, BinaryOp, UnaryOp, Box,\n+    Aggregate, Drop, CallFn, CallArg, Return,\n+}\n+\n+fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx> {\n+    use self::StmtKind as SK;\n+\n+    let bbs = mir.all_basic_blocks();\n+    let mut moves = Vec::with_capacity(bbs.len());\n+    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bbs.len()).collect();\n+    let mut path_map = Vec::new();\n+\n+    // this is mutable only because we will move it to and fro' the\n+    // BlockContexts constructed on each iteration. (Moving is more\n+    // straight-forward than mutable borrows in this instance.)\n+    let mut builder = MovePathDataBuilder {\n+        mir: mir,\n+        pre_move_paths: Vec::new(),\n+        rev_lookup: MovePathLookup::new(),\n+    };\n+\n+    for bb in bbs {\n+        let loc_map_bb = &mut loc_map[bb.index()];\n+        let bb_data = mir.basic_block_data(bb);\n+\n+        debug_assert!(loc_map_bb.len() == 0);\n+        let len = bb_data.statements.len();\n+        loc_map_bb.fill_to(len);\n+        debug_assert!(loc_map_bb.len() == len + 1);\n+\n+        let mut bb_ctxt = BlockContext {\n+            tcx: tcx,\n+            moves: &mut moves,\n+            builder: builder,\n+            path_map: &mut path_map,\n+            loc_map_bb: loc_map_bb,\n+        };\n+\n+        for (i, stmt) in bb_data.statements.iter().enumerate() {\n+            let source = Location { block: bb, index: i };\n+            match stmt.kind {\n+                StatementKind::Assign(ref lval, ref rval) => {\n+                    // ensure MovePath created for `lval`.\n+                    bb_ctxt.builder.move_path_for(lval);\n+\n+                    match *rval {\n+                        Rvalue::Use(ref operand) => {\n+                            bb_ctxt.on_operand(SK::Use, operand, source)\n+                        }\n+                        Rvalue::Repeat(ref operand, ref _const) =>\n+                            bb_ctxt.on_operand(SK::Repeat, operand, source),\n+                        Rvalue::Cast(ref _kind, ref operand, ref _ty) =>\n+                            bb_ctxt.on_operand(SK::Cast, operand, source),\n+                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) => {\n+                            bb_ctxt.on_operand(SK::BinaryOp, operand1, source);\n+                            bb_ctxt.on_operand(SK::BinaryOp, operand2, source);\n+                        }\n+                        Rvalue::UnaryOp(ref _unop, ref operand) => {\n+                            bb_ctxt.on_operand(SK::UnaryOp, operand, source);\n+                        }\n+                        Rvalue::Box(ref _ty) => {\n+                            // this is creating uninitialized\n+                            // memory that needs to be initialized.\n+                            let deref_lval = Lvalue::Projection(Box::new( repr::Projection {\n+                                base: lval.clone(),\n+                                elem: repr::ProjectionElem::Deref,\n+                            }));\n+                            bb_ctxt.on_move_out_lval(SK::Box, &deref_lval, source);\n+                        }\n+                        Rvalue::Aggregate(ref _kind, ref operands) => {\n+                            for operand in operands {\n+                                bb_ctxt.on_operand(SK::Aggregate, operand, source);\n+                            }\n+                        }\n+                        Rvalue::Ref(..) |\n+                        Rvalue::Len(..) |\n+                        Rvalue::InlineAsm { .. } => {}\n+\n+                        Rvalue::Slice {..} => {\n+                            bb_ctxt.tcx.sess.bug(\"cannot move out of slice\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if let Some(ref term) = bb_data.terminator {\n+            match *term {\n+                Terminator::Goto { target: _ } | Terminator::Resume => { }\n+\n+                Terminator::Return => {\n+                    let source = Location { block: bb,\n+                                            index: bb_data.statements.len() };\n+                    let lval = &Lvalue::ReturnPointer.deref();\n+                    bb_ctxt.on_move_out_lval(SK::Return, lval, source);\n+                }\n+\n+                Terminator::If { ref cond, targets: _ } => {\n+                    // The `cond` is always of (copyable) type `bool`,\n+                    // so there will never be anything to move.\n+                    let _ = cond;\n+                }\n+\n+                Terminator::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n+                Terminator::Switch { adt_def: _, targets: _, ref discr } => {\n+                    // The `discr` is not consumed; that is instead\n+                    // encoded on specific match arms (and for\n+                    // SwitchInt`, it is always a copyable integer\n+                    // type anyway).\n+                    let _ = discr;\n+                }\n+\n+                Terminator::Drop { value: ref lval, target: _, unwind: _ } => {\n+                    let source = Location { block: bb,\n+                                            index: bb_data.statements.len() };\n+                    bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n+                }\n+\n+                Terminator::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                    let source = Location { block: bb,\n+                                            index: bb_data.statements.len() };\n+                    bb_ctxt.on_operand(SK::CallFn, func, source);\n+                    for arg in args {\n+                        bb_ctxt.on_operand(SK::CallArg, arg, source);\n+                    }\n+                    if let Some((ref destination, _bb)) = *destination {\n+                        // Create MovePath for `destination`, then\n+                        // discard returned index.\n+                        bb_ctxt.builder.move_path_for(destination);\n+                    }\n+                }\n+            }\n+        }\n+\n+        builder = bb_ctxt.builder;\n+    }\n+\n+    // At this point, we may have created some MovePaths that do not\n+    // have corresponding entries in the path map.\n+    //\n+    // (For example, creating the path `a.b.c` may, as a side-effect,\n+    // create a path for the parent path `a.b`.)\n+    //\n+    // All such paths were not referenced ...\n+    //\n+    // well you know, lets actually try just asserting that the path map *is* complete.\n+    assert_eq!(path_map.len(), builder.pre_move_paths.len());\n+    path_map.fill_to(builder.pre_move_paths.len() - 1);\n+\n+    let pre_move_paths = builder.pre_move_paths;\n+    let move_paths: Vec<_> = pre_move_paths.into_iter()\n+        .map(|p| p.into_move_path())\n+        .collect();\n+\n+    debug!(\"{}\", {\n+        let mut seen: Vec<_> = move_paths.iter().map(|_| false).collect();\n+        for (j, &MoveOut { ref path, ref source }) in moves.iter().enumerate() {\n+            debug!(\"MovePathData moves[{}]: MoveOut {{ path: {:?} = {:?}, source: {:?} }}\",\n+                   j, path, move_paths[path.idx()], source);\n+            seen[path.idx()] = true;\n+        }\n+        for (j, path) in move_paths.iter().enumerate() {\n+            if !seen[j] {\n+                debug!(\"MovePathData move_paths[{}]: {:?}\", j, path);\n+            }\n+        }\n+        \"done dumping MovePathData\"\n+    });\n+\n+    MoveData {\n+        move_paths: MovePathData { move_paths: move_paths, },\n+        moves: moves,\n+        loc_map: LocMap { map: loc_map },\n+        path_map: PathMap { map: path_map },\n+        rev_lookup: builder.rev_lookup,\n+    }\n+}\n+\n+struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n+    tcx: &'b ty::TyCtxt<'tcx>,\n+    moves: &'b mut Vec<MoveOut>,\n+    builder: MovePathDataBuilder<'a, 'tcx>,\n+    path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n+    loc_map_bb: &'b mut Vec<Vec<MoveOutIndex>>,\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n+    fn on_move_out_lval(&mut self,\n+                        stmt_kind: StmtKind,\n+                        lval: &repr::Lvalue<'tcx>,\n+                        source: Location) {\n+        let tcx = self.tcx;\n+        let lval_ty = self.builder.mir.lvalue_ty(tcx, lval);\n+\n+        // FIXME: does lvalue_ty ever return TyError, or is it\n+        // guaranteed to always return non-Infer/non-Error values?\n+\n+        // This code is just trying to avoid creating a MoveOut\n+        // entry for values that do not need move semantics.\n+        //\n+        // type_contents is imprecise (may claim needs drop for\n+        // types that in fact have no destructor). But that is\n+        // still usable for our purposes here.\n+        let consumed = lval_ty.to_ty(tcx).type_contents(tcx).needs_drop(tcx);\n+\n+        if !consumed {\n+            debug!(\"ctxt: {:?} no consume of lval: {:?} of type {:?}\",\n+                   stmt_kind, lval, lval_ty);\n+            return;\n+        }\n+        let i = source.index;\n+        let index = MoveOutIndex::new(self.moves.len());\n+\n+        let path = self.builder.move_path_for(lval);\n+        self.moves.push(MoveOut { path: path, source: source.clone() });\n+        self.path_map.fill_to(path.idx());\n+\n+        debug!(\"ctxt: {:?} add consume of lval: {:?} \\\n+                at index: {:?} \\\n+                to path_map for path: {:?} and \\\n+                to loc_map for loc: {:?}\",\n+               stmt_kind, lval, index, path, source);\n+\n+        debug_assert!(path.idx() < self.path_map.len());\n+        // this is actually a questionable assert; at the very\n+        // least, incorrect input code can probably cause it to\n+        // fire.\n+        assert!(self.path_map[path.idx()].iter().find(|idx| **idx == index).is_none());\n+        self.path_map[path.idx()].push(index);\n+\n+        debug_assert!(i < self.loc_map_bb.len());\n+        debug_assert!(self.loc_map_bb[i].iter().find(|idx| **idx == index).is_none());\n+        self.loc_map_bb[i].push(index);\n+    }\n+\n+    fn on_operand(&mut self, stmt_kind: StmtKind, operand: &repr::Operand<'tcx>, source: Location) {\n+        match *operand {\n+            repr::Operand::Constant(..) => {} // not-a-move\n+            repr::Operand::Consume(ref lval) => { // a move\n+                self.on_move_out_lval(stmt_kind, lval, source);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> BitDenotation for MoveData<'tcx>{\n+    type Bit = MoveOut;\n+    fn bits_per_block(&self) -> usize {\n+        self.moves.len()\n+    }\n+    fn interpret(&self, idx: usize) -> &Self::Bit {\n+        &self.moves[idx]\n+    }\n+}"}, {"sha": "b81ef186a4f9dd3735ed5a0a78c2aece30a2bdc7", "filename": "src/librustc_borrowck/borrowck/mir/graphviz.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -0,0 +1,232 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Hook into libgraphviz for rendering dataflow graphs for MIR.\n+\n+use rustc::mir::repr::{BasicBlock, Mir};\n+\n+use dot;\n+use dot::IntoCow;\n+\n+use std::fs::File;\n+use std::io;\n+use std::io::prelude::*;\n+\n+use super::MirBorrowckCtxt;\n+use bitslice::bits_to_string;\n+use super::gather_moves::MoveOut;\n+\n+struct Graph<'c, 'b:'c, 'a:'b, 'tcx:'a> { mbcx: &'c MirBorrowckCtxt<'b, 'a, 'tcx>,\n+                                          context: &'b str }\n+\n+pub fn print_borrowck_graph_to(mbcx: &MirBorrowckCtxt,\n+                               context: &str,\n+                               path: &str) -> io::Result<()> {\n+    let g = Graph { mbcx: mbcx, context: context };\n+    let mut v = Vec::new();\n+    try!(dot::render(&g, &mut v));\n+    println!(\"print_borrowck_graph_to path: {} context: {} node_id: {}\",\n+             path, context, mbcx.node_id);\n+    File::create(path).and_then(|mut f| f.write_all(&v))\n+}\n+\n+pub type Node = BasicBlock;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Edge { source: BasicBlock, index: usize }\n+\n+fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n+    let succ_len = mir.basic_block_data(bb).terminator().successors().len();\n+    (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n+}\n+\n+impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n+    type Node = Node;\n+    type Edge = Edge;\n+    fn graph_id(&self) -> dot::Id {\n+        dot::Id::new(format!(\"graph_for_node_{}_{}\",\n+                             self.mbcx.node_id,\n+                             self.context))\n+            .unwrap()\n+    }\n+\n+    fn node_id(&self, n: &Node) -> dot::Id {\n+        dot::Id::new(format!(\"bb_{}\", n.index()))\n+            .unwrap()\n+    }\n+\n+    fn node_label(&self, n: &Node) -> dot::LabelText {\n+        // A standard MIR label, as generated by write_node_label, is\n+        // presented in a single column in a table.\n+        //\n+        // The code below does a bunch of formatting work to format a\n+        // node (i.e. MIR basic-block) label with extra\n+        // dataflow-enriched information.  In particular, the goal is\n+        // to add extra columns that present the three dataflow\n+        // bitvectors, and the data those bitvectors represent.\n+        //\n+        // It presents it in the following format (where I am\n+        // presenting the table rendering via ASCII art, one line per\n+        // row of the table, and a chunk size of 3 rather than 5):\n+        //\n+        // ------  -----------------------  ------------  --------------------\n+        //                    [e1, e3, e4]\n+        //             [e8, e9] \"= ENTRY:\"  <ENTRY-BITS>\n+        // ------  -----------------------  ------------  --------------------\n+        // Left\n+        // Most\n+        // Column\n+        // Is\n+        // Just\n+        // Normal\n+        // Series\n+        // Of\n+        // MIR\n+        // Stmts\n+        // ------  -----------------------  ------------  --------------------\n+        //           [g1, g4, g5] \"= GEN:\"  <GEN-BITS>\n+        // ------  -----------------------  ------------  --------------------\n+        //                         \"KILL:\"  <KILL-BITS>   \"=\" [k1, k3, k8]\n+        //                                                [k9]\n+        // ------  -----------------------  ------------  --------------------\n+        //\n+        // (In addition, the added dataflow is rendered with a colored\n+        // background just so it will stand out compared to the\n+        // statements.)\n+        let mut v = Vec::new();\n+        let i = n.index();\n+        let chunk_size = 5;\n+        const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n+        const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n+        const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n+        fn chunked_present_left<W:io::Write>(w: &mut W,\n+                                             interpreted: &[&MoveOut],\n+                                             chunk_size: usize)\n+                                             -> io::Result<()>\n+        {\n+            // This function may emit a sequence of <tr>'s, but it\n+            // always finishes with an (unfinished)\n+            // <tr><td></td><td>\n+            //\n+            // Thus, after being called, one should finish both the\n+            // pending <td> as well as the <tr> itself.\n+            let mut seen_one = false;\n+            for c in interpreted.chunks(chunk_size) {\n+                if seen_one {\n+                    // if not the first row, finish off the previous row\n+                    try!(write!(w, \"</td><td></td><td></td></tr>\"));\n+                }\n+                try!(write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n+                            bg = BG_FLOWCONTENT,\n+                            align = ALIGN_RIGHT,\n+                            objs = c));\n+                seen_one = true;\n+            }\n+            if !seen_one {\n+                try!(write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n+                            bg = BG_FLOWCONTENT,\n+                            align = ALIGN_RIGHT));\n+            }\n+            Ok(())\n+        }\n+        ::rustc_mir::graphviz::write_node_label(\n+            *n, self.mbcx.mir, &mut v, 4,\n+            |w| {\n+                let flow = &self.mbcx.flow_state;\n+                let entry = flow.interpret_set(flow.sets.on_entry_set_for(i));\n+                try!(chunked_present_left(w, &entry[..], chunk_size));\n+                write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n+                                        <td></td></tr>\",\n+                       bg = BG_FLOWCONTENT,\n+                       face = FACE_MONOSPACE,\n+                       entrybits=bits_to_string(flow.sets.on_entry_set_for(i),\n+                                                flow.sets.bytes_per_block()))\n+            },\n+            |w| {\n+                let flow = &self.mbcx.flow_state;\n+                let gen = flow.interpret_set( flow.sets.gen_set_for(i));\n+                let kill = flow.interpret_set(flow.sets.kill_set_for(i));\n+                try!(chunked_present_left(w, &gen[..], chunk_size));\n+                try!(write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n+                                            <td></td></tr>\",\n+                            bg = BG_FLOWCONTENT,\n+                            face = FACE_MONOSPACE,\n+                            genbits=bits_to_string( flow.sets.gen_set_for(i),\n+                                                    flow.sets.bytes_per_block())));\n+                try!(write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n+                                             <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n+                            bg = BG_FLOWCONTENT,\n+                            align = ALIGN_RIGHT,\n+                            face = FACE_MONOSPACE,\n+                            killbits=bits_to_string(flow.sets.kill_set_for(i),\n+                                                    flow.sets.bytes_per_block())));\n+\n+                // (chunked_present_right)\n+                let mut seen_one = false;\n+                for k in kill.chunks(chunk_size) {\n+                    if !seen_one {\n+                        // continuation of row; this is fourth <td>\n+                        try!(write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n+                                    bg = BG_FLOWCONTENT,\n+                                    kill=k));\n+                    } else {\n+                        // new row, with indent of three <td>'s\n+                        try!(write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n+                                    bg = BG_FLOWCONTENT,\n+                                    kill=k));\n+                    }\n+                    seen_one = true;\n+                }\n+                if !seen_one {\n+                    try!(write!(w, \"<td {bg}>= []</td></tr>\",\n+                                bg = BG_FLOWCONTENT));\n+                }\n+\n+                Ok(())\n+            })\n+            .unwrap();\n+        dot::LabelText::html(String::from_utf8(v).unwrap())\n+    }\n+\n+    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+}\n+\n+impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::GraphWalk<'c> for Graph<'c,'b,'a,'tcx> {\n+    type Node = Node;\n+    type Edge = Edge;\n+    fn nodes(&self) -> dot::Nodes<Node> {\n+        self.mbcx.mir.all_basic_blocks().into_cow()\n+    }\n+\n+    fn edges(&self) -> dot::Edges<Edge> {\n+        let mir = self.mbcx.mir;\n+        let blocks = self.mbcx.mir.all_basic_blocks();\n+        // base initial capacity on assumption every block has at\n+        // least one outgoing edge (Which should be true for all\n+        // blocks but one, the exit-block).\n+        let mut edges = Vec::with_capacity(blocks.len());\n+        for bb in blocks {\n+            let outgoing = outgoing(mir, bb);\n+            edges.extend(outgoing.into_iter());\n+        }\n+        edges.into_cow()\n+    }\n+\n+    fn source(&self, edge: &Edge) -> Node {\n+        edge.source\n+    }\n+\n+    fn target(&self, edge: &Edge) -> Node {\n+        let mir = self.mbcx.mir;\n+        mir.basic_block_data(edge.source).terminator().successors()[edge.index]\n+    }\n+}"}, {"sha": "d1335811858b8aa926fbaa99de800f1bb58ccc04", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrowck::BorrowckCtxt;\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+use rustc_front::intravisit::{FnKind};\n+\n+use rustc::mir::repr::{BasicBlock, BasicBlockData, Mir, Statement, Terminator};\n+\n+mod abs_domain;\n+mod dataflow;\n+mod gather_moves;\n+mod graphviz;\n+\n+use self::dataflow::{Dataflow, DataflowState};\n+use self::gather_moves::{MoveData};\n+\n+pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n+    bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n+    fk: FnKind,\n+    _decl: &hir::FnDecl,\n+    mir: &'a Mir<'tcx>,\n+    body: &hir::Block,\n+    _sp: Span,\n+    id: ast::NodeId,\n+    attributes: &[ast::Attribute]) {\n+    match fk {\n+        FnKind::ItemFn(name, _, _, _, _, _, _) |\n+        FnKind::Method(name, _, _, _) => {\n+            debug!(\"borrowck_mir({}) UNIMPLEMENTED\", name);\n+        }\n+        FnKind::Closure(_) => {\n+            debug!(\"borrowck_mir closure (body.id={}) UNIMPLEMENTED\", body.id);\n+        }\n+    }\n+\n+    let mut mbcx = MirBorrowckCtxt {\n+        bcx: bcx,\n+        mir: mir,\n+        node_id: id,\n+        attributes: attributes,\n+        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n+    };\n+\n+    for bb in mir.all_basic_blocks() {\n+        mbcx.process_basic_block(bb);\n+    }\n+\n+    mbcx.dataflow();\n+\n+    debug!(\"borrowck_mir done\");\n+}\n+\n+pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n+    bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n+    mir: &'b Mir<'tcx>,\n+    node_id: ast::NodeId,\n+    attributes: &'b [ast::Attribute],\n+    flow_state: DataflowState<MoveData<'tcx>>,\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn process_basic_block(&mut self, bb: BasicBlock) {\n+        let &BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n+            self.mir.basic_block_data(bb);\n+        for stmt in statements {\n+            self.process_statement(bb, stmt);\n+        }\n+\n+        self.process_terminator(bb, terminator);\n+    }\n+\n+    fn process_statement(&mut self, bb: BasicBlock, stmt: &Statement<'tcx>) {\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}\", bb, stmt);\n+    }\n+\n+    fn process_terminator(&mut self, bb: BasicBlock, term: &Option<Terminator<'tcx>>) {\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?})\", bb, term);\n+    }\n+}"}, {"sha": "bb2fe7acb9536e4b9287ef9afcac76c75b244f7a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -40,6 +40,7 @@ use std::fmt;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n \n@@ -49,12 +50,16 @@ use rustc_front::intravisit;\n use rustc_front::intravisit::{Visitor, FnKind};\n use rustc_front::util as hir_util;\n \n+use rustc::mir::mir_map::MirMap;\n+\n pub mod check_loans;\n \n pub mod gather_loans;\n \n pub mod move_data;\n \n+mod mir;\n+\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n@@ -66,15 +71,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n-                let new_free_region_map = self.tcx.free_region_map(id);\n-                let old_free_region_map =\n-                    mem::replace(&mut self.free_region_map, new_free_region_map);\n-                borrowck_fn(self, fk, fd, b, s, id);\n-                self.free_region_map = old_free_region_map;\n+                self.with_temp_region_map(id, |this| {\n+                    borrowck_fn(this, fk, fd, b, s, id, fk.attrs())\n+                });\n             }\n \n-            FnKind::Closure => {\n-                borrowck_fn(self, fk, fd, b, s, id);\n+            FnKind::Closure(..) => {\n+                borrowck_fn(self, fk, fd, b, s, id, fk.attrs());\n             }\n         }\n     }\n@@ -98,9 +101,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n+        mir_map: Some(mir_map),\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -159,8 +163,17 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                decl: &hir::FnDecl,\n                body: &hir::Block,\n                sp: Span,\n-               id: ast::NodeId) {\n+               id: ast::NodeId,\n+               attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n+\n+    if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n+        let mir = this.mir_map.unwrap().map.get(&id).unwrap();\n+        this.with_temp_region_map(id, |this| {\n+            mir::borrowck_mir(this, fk, decl, mir, body, sp, id, attributes)\n+        });\n+    }\n+\n     let cfg = cfg::CFG::new(this.tcx, body);\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n@@ -233,13 +246,15 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: &'a TyCtxt<'tcx>,\n+    mir_map: Option<&'a MirMap<'tcx>>,\n     fn_parts: FnParts<'a>,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n+        mir_map: mir_map,\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -279,9 +294,13 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     free_region_map: FreeRegionMap,\n \n     // Statistics:\n-    stats: BorrowStats\n+    stats: BorrowStats,\n+\n+    // NodeId to MIR mapping (for methods that carry the #[rustc_mir] attribute).\n+    mir_map: Option<&'a MirMap<'tcx>>,\n }\n \n+#[derive(Clone)]\n struct BorrowStats {\n     loaned_paths_same: usize,\n     loaned_paths_imm: usize,\n@@ -574,6 +593,15 @@ pub enum MovedValueUseKind {\n // Misc\n \n impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n+    fn with_temp_region_map<F>(&mut self, id: ast::NodeId, f: F)\n+        where F: for <'b> FnOnce(&'b mut BorrowckCtxt<'a, 'tcx>)\n+    {\n+        let new_free_region_map = self.tcx.free_region_map(id);\n+        let old_free_region_map = mem::replace(&mut self.free_region_map, new_free_region_map);\n+        f(self);\n+        self.free_region_map = old_free_region_map;\n+    }\n+\n     pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n                            -> bool\n     {"}, {"sha": "fd23772bcda13c55cd0dc895860ede3979197a0d", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -129,7 +129,9 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {\n+impl<'a, 'tcx> dot::Labeller<'a> for DataflowLabeller<'a, 'tcx> {\n+    type Node = Node<'a>;\n+    type Edge = Edge<'a>;\n     fn graph_id(&'a self) -> dot::Id<'a> { self.inner.graph_id() }\n     fn node_id(&'a self, n: &Node<'a>) -> dot::Id<'a> { self.inner.node_id(n) }\n     fn node_label(&'a self, n: &Node<'a>) -> dot::LabelText<'a> {\n@@ -143,7 +145,9 @@ impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 't\n     fn edge_label(&'a self, e: &Edge<'a>) -> dot::LabelText<'a> { self.inner.edge_label(e) }\n }\n \n-impl<'a, 'tcx> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {\n+impl<'a, 'tcx> dot::GraphWalk<'a> for DataflowLabeller<'a, 'tcx> {\n+    type Node = Node<'a>;\n+    type Edge = Edge<'a>;\n     fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n     fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n     fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }"}, {"sha": "65e9b79224181a8abd4fb763241acf4d96a8518a", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -23,7 +23,8 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-\n+#![feature(associated_consts)]\n+#![feature(nonzero)]\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n@@ -32,6 +33,8 @@\n extern crate graphviz as dot;\n extern crate rustc;\n extern crate rustc_front;\n+extern crate rustc_mir;\n+extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n@@ -42,6 +45,7 @@ pub use borrowck::{AnalysisData, BorrowckCtxt};\n pub mod diagnostics;\n \n mod borrowck;\n+mod bitslice;\n \n pub mod graphviz;\n "}, {"sha": "c39d0d7587f439f7fbca4c512100f3cd392249b2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -880,7 +880,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes,\n              \"borrow checking\",\n-             || borrowck::check_crate(tcx));\n+             || borrowck::check_crate(tcx, &mir_map));\n \n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids"}, {"sha": "5134278de2183db2ae4ede34d02c4a991bc0dbc6", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -56,6 +56,8 @@ use rustc_front::hir;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_front::print::pprust as pprust_hir;\n \n+use rustc::mir::mir_map::MirMap;\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n     PpmNormal,\n@@ -875,9 +877,10 @@ pub fn pretty_print_input(sess: Session,\n                                                                      &arenas,\n                                                                      &id,\n                                                                      resolve::MakeGlobMap::No,\n-                                                                     |tcx, _, _, _| {\n+                                                                     |tcx, mir_map, _, _| {\n                         print_flowgraph(variants,\n                                         tcx,\n+                                        mir_map.as_ref(),\n                                         code,\n                                         mode,\n                                         out)\n@@ -911,12 +914,13 @@ pub fn pretty_print_input(sess: Session,\n     }\n }\n \n-fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                             tcx: &TyCtxt,\n-                             code: blocks::Code,\n-                             mode: PpFlowGraphMode,\n-                             mut out: W)\n-                             -> io::Result<()> {\n+fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n+                                   tcx: &TyCtxt<'tcx>,\n+                                   mir_map: Option<&MirMap<'tcx>>,\n+                                   code: blocks::Code,\n+                                   mode: PpFlowGraphMode,\n+                                   mut out: W)\n+                                   -> io::Result<()> {\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n@@ -942,6 +946,7 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n         blocks::FnLikeCode(fn_like) => {\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n+                                                              mir_map,\n                                                               fn_like.to_fn_parts(),\n                                                               &cfg);\n "}, {"sha": "be1cc528d889e59134bf8f67449153f3548b99c5", "filename": "src/librustc_front/intravisit.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -27,19 +27,30 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n+use syntax::attr::ThinAttributesExt;\n use syntax::codemap::Span;\n use hir::*;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, Visibility),\n+    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, Visibility, &'a [Attribute]),\n \n     /// fn foo(&self)\n-    Method(Name, &'a MethodSig, Option<Visibility>),\n+    Method(Name, &'a MethodSig, Option<Visibility>, &'a [Attribute]),\n \n     /// |x, y| {}\n-    Closure,\n+    Closure(&'a [Attribute]),\n+}\n+\n+impl<'a> FnKind<'a> {\n+    pub fn attrs(&self) -> &'a [Attribute] {\n+        match *self {\n+            FnKind::ItemFn(_, _, _, _, _, _, attrs) => attrs,\n+            FnKind::Method(_, _, _, attrs) => attrs,\n+            FnKind::Closure(attrs) => attrs,\n+        }\n+    }\n }\n \n /// Each method of the Visitor trait is a hook to be potentially\n@@ -310,7 +321,8 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                             unsafety,\n                                             constness,\n                                             abi,\n-                                            item.vis),\n+                                            item.vis,\n+                                            &item.attrs),\n                              declaration,\n                              body,\n                              item.span,\n@@ -595,14 +607,14 @@ pub fn walk_fn_decl_nopat<'v, V: Visitor<'v>>(visitor: &mut V, function_declarat\n \n pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n     match function_kind {\n-        FnKind::ItemFn(_, generics, _, _, _, _) => {\n+        FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n             visitor.visit_generics(generics);\n         }\n-        FnKind::Method(_, sig, _) => {\n+        FnKind::Method(_, sig, _, _) => {\n             visitor.visit_generics(&sig.generics);\n             visitor.visit_explicit_self(&sig.explicit_self);\n         }\n-        FnKind::Closure => {}\n+        FnKind::Closure(_) => {}\n     }\n }\n \n@@ -630,7 +642,10 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_fn_decl(visitor, &sig.decl);\n         }\n         MethodTraitItem(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.name, sig, None),\n+            visitor.visit_fn(FnKind::Method(trait_item.name,\n+                                            sig,\n+                                            None,\n+                                            &trait_item.attrs),\n                              &sig.decl,\n                              body,\n                              trait_item.span,\n@@ -652,7 +667,10 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_expr(expr);\n         }\n         ImplItemKind::Method(ref sig, ref body) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.name, sig, Some(impl_item.vis)),\n+            visitor.visit_fn(FnKind::Method(impl_item.name,\n+                                            sig,\n+                                            Some(impl_item.vis),\n+                                            &impl_item.attrs),\n                              &sig.decl,\n                              body,\n                              impl_item.span,\n@@ -758,7 +776,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprClosure(_, ref function_declaration, ref body) => {\n-            visitor.visit_fn(FnKind::Closure,\n+            visitor.visit_fn(FnKind::Closure(expression.attrs.as_attr_slice()),\n                              function_declaration,\n                              body,\n                              expression.span,"}, {"sha": "f4f9cb75eaf36efc361e3c4be218ca58884cb33d", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -254,13 +254,13 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n         self.operation.visit_id(node_id);\n \n         match function_kind {\n-            FnKind::ItemFn(_, generics, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n                 self.visit_generics_helper(generics)\n             }\n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 self.visit_generics_helper(&sig.generics)\n             }\n-            FnKind::Closure => {}\n+            FnKind::Closure(_) => {}\n         }\n \n         for argument in &function_declaration.inputs {"}, {"sha": "e399270197e2b6626683b21270b002ed93594302", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -237,7 +237,7 @@ impl LateLintPass for NonSnakeCase {\n                 fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, id: ast::NodeId) {\n         match fk {\n-            FnKind::Method(name, _, _) => match method_context(cx, id, span) {\n+            FnKind::Method(name, _, _, _) => match method_context(cx, id, span) {\n                 MethodLateContext::PlainImpl => {\n                     self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n                 },\n@@ -246,10 +246,10 @@ impl LateLintPass for NonSnakeCase {\n                 },\n                 _ => (),\n             },\n-            FnKind::ItemFn(name, _, _, _, _, _) => {\n+            FnKind::ItemFn(name, _, _, _, _, _, _) => {\n                 self.check_snake_case(cx, \"function\", &name.as_str(), Some(span))\n             },\n-            _ => (),\n+            FnKind::Closure(_) => (),\n         }\n     }\n "}, {"sha": "2ccb905b6ecdf1cd90158863e8c526a3fce6a3d5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -223,10 +223,10 @@ impl LateLintPass for UnsafeCode {\n     fn check_fn(&mut self, cx: &LateContext, fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, _: ast::NodeId) {\n         match fk {\n-            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, _, _, _) =>\n+            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, _, _, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 if sig.unsafety == hir::Unsafety::Unsafe {\n                     cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n@@ -670,7 +670,7 @@ impl LateLintPass for UnconditionalRecursion {\n                 cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n             }\n             // closures can't recur, so they don't matter.\n-            FnKind::Closure => return\n+            FnKind::Closure(_) => return\n         };\n \n         // Walk through this function (say `f`) looking to see if"}, {"sha": "bed83708ff8b50d117633ab26bfa2fa71e314f07", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -43,16 +43,33 @@ where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n     Ok(())\n }\n \n-/// Write a graphviz DOT node for the given basic block.\n-fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+/// Write a graphviz HTML-styled label for the given basic block, with\n+/// all necessary escaping already performed. (This is suitable for\n+/// emitting directly, as is done in this module, or for use with the\n+/// LabelText::HtmlStr from libgraphviz.)\n+///\n+/// `init` and `fini` are callbacks for emitting additional rows of\n+/// data (using HTML enclosed with `<tr>` in the emitted text).\n+pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n+                                              mir: &Mir,\n+                                              w: &mut W,\n+                                              num_cols: u32,\n+                                              init: INIT,\n+                                              fini: FINI) -> io::Result<()>\n+    where INIT: Fn(&mut W) -> io::Result<()>,\n+          FINI: Fn(&mut W) -> io::Result<()>\n+{\n     let data = mir.basic_block_data(block);\n \n-    // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n-    try!(write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block)));\n     try!(write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#));\n \n     // Basic block number at the top.\n-    try!(write!(w, r#\"<tr><td bgcolor=\"gray\" align=\"center\">{}</td></tr>\"#, block.index()));\n+    try!(write!(w, r#\"<tr><td {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n+                attrs=r#\"bgcolor=\"gray\" align=\"center\"\"#,\n+                colspan=num_cols,\n+                blk=block.index()));\n+\n+    try!(init(w));\n \n     // List of statements in the middle.\n     if !data.statements.is_empty() {\n@@ -69,8 +86,19 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<(\n     data.terminator().fmt_head(&mut terminator_head).unwrap();\n     try!(write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head)));\n \n-    // Close the table, node label, and the node itself.\n-    writeln!(w, \"</table>>];\")\n+    try!(fini(w));\n+\n+    // Close the table\n+    writeln!(w, \"</table>\")\n+}\n+\n+/// Write a graphviz DOT node for the given basic block.\n+fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+    // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n+    try!(write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block)));\n+    try!(write_node_label(block, mir, w, 1, |_| Ok(()), |_| Ok(())));\n+    // Close the node label and the node itself.\n+    writeln!(w, \">];\")\n }\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors."}, {"sha": "05dbd63ef1a4221b827ba4486878e614ae5c5f36", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n                 body: &'tcx hir::Block,\n                 span: Span,\n                 id: ast::NodeId) {\n-        let implicit_arg_tys = if let intravisit::FnKind::Closure = fk {\n+        let implicit_arg_tys = if let intravisit::FnKind::Closure(..) = fk {\n             vec![closure_self_ty(&self.tcx, id, body.id)]\n         } else {\n             vec![]"}, {"sha": "c2b764594180cfeb4eacdfa2d0aa94b74e4a2455", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -132,10 +132,10 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         let mode = match fk {\n-            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _) => {\n+            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _) => {\n                 Mode::ConstFn\n             }\n-            FnKind::Method(_, m, _) => {\n+            FnKind::Method(_, m, _, _) => {\n                 if m.constness == hir::Constness::Const {\n                     Mode::ConstFn\n                 } else {"}, {"sha": "af8c9d81687421457d089e80ed7cd1e90c040006", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -634,16 +634,16 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n-            FnKind::ItemFn(_, generics, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 self.visit_generics(&sig.generics);\n                 self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind\n             }\n-            FnKind::Closure => ClosureRibKind(node_id),\n+            FnKind::Closure(_) => ClosureRibKind(node_id),\n         };\n         self.resolve_function(rib_kind, declaration, block);\n     }"}, {"sha": "11386715492b64198304daf3d4945ece8613aef3", "filename": "src/librustc_trans/trans/assert_dep_graph.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -253,7 +253,9 @@ fn dump_graph(tcx: &TyCtxt) {\n \n pub struct GraphvizDepGraph(FnvHashSet<DepNode>, Vec<(DepNode, DepNode)>);\n \n-impl<'a, 'tcx> dot::GraphWalk<'a, DepNode, (DepNode, DepNode)> for GraphvizDepGraph {\n+impl<'a, 'tcx> dot::GraphWalk<'a> for GraphvizDepGraph {\n+    type Node = DepNode;\n+    type Edge = (DepNode, DepNode);\n     fn nodes(&self) -> dot::Nodes<DepNode> {\n         let nodes: Vec<_> = self.0.iter().cloned().collect();\n         nodes.into_cow()\n@@ -269,7 +271,9 @@ impl<'a, 'tcx> dot::GraphWalk<'a, DepNode, (DepNode, DepNode)> for GraphvizDepGr\n     }\n }\n \n-impl<'a, 'tcx> dot::Labeller<'a, DepNode, (DepNode, DepNode)> for GraphvizDepGraph {\n+impl<'a, 'tcx> dot::Labeller<'a> for GraphvizDepGraph {\n+    type Node = DepNode;\n+    type Edge = (DepNode, DepNode);\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(\"DependencyGraph\").unwrap()\n     }"}, {"sha": "9ef0b400022989bc92b5761da3a73b48e5fca891", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e3f2dfdececa8053e652eb0fb286db9aef0f82e6/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=e3f2dfdececa8053e652eb0fb286db9aef0f82e6", "patch": "@@ -109,6 +109,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_front 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n "}]}