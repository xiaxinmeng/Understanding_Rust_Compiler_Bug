{"sha": "b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYWUwOWU1MmE3MTJmMzRkZTc4MjNkZTU1YWFhNmVmMTQyYzZmZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-15T01:21:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-15T01:21:22Z"}, "message": "auto merge of #15434 : steveklabnik/rust/guide_match, r=brson", "tree": {"sha": "350bbb8796d4db87dbda9f219a5f067bea63f6b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350bbb8796d4db87dbda9f219a5f067bea63f6b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "html_url": "https://github.com/rust-lang/rust/commit/b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1ae09e52a712f34de7823de55aaa6ef142c6fe9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b733592adb28ed9f6498382ee35b4d0c3d954df6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b733592adb28ed9f6498382ee35b4d0c3d954df6", "html_url": "https://github.com/rust-lang/rust/commit/b733592adb28ed9f6498382ee35b4d0c3d954df6"}, {"sha": "daea9f4ad9bd8a391eb283fcc6f8e97e943c6342", "url": "https://api.github.com/repos/rust-lang/rust/commits/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342", "html_url": "https://github.com/rust-lang/rust/commit/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "2b8e83d55e462680db5e063f62c348282d392447", "filename": "src/doc/guide.md", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b1ae09e52a712f34de7823de55aaa6ef142c6fe9/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1ae09e52a712f34de7823de55aaa6ef142c6fe9/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "patch": "@@ -1264,6 +1264,102 @@ do that with `match`.\n \n ## Match\n \n+Often, a simple `if`/`else` isn't enough, because you have more than two\n+possible options. And `else` conditions can get incredibly complicated. So\n+what's the solution?\n+\n+Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n+groupings with something more powerful. Check it out:\n+\n+```rust\n+let x = 5i;\n+\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    4 => println!(\"four\"),\n+    5 => println!(\"five\"),\n+    _ => println!(\"something else\"),\n+}\n+```\n+\n+`match` takes an expression, and then branches based on its value. Each 'arm' of\n+the branch is of the form `val => expression`. When the value matches, that arm's\n+expression will be evaluated. It's called `match` because of the term 'pattern\n+matching,' which `match` is an implementation of.\n+\n+So what's the big advantage here? Well, there are a few. First of all, `match`\n+does 'exhaustiveness checking.' Do you see that last arm, the one with the\n+underscore (`_`)? If we remove that arm, Rust will give us an error:\n+\n+```{ignore,notrust}\n+error: non-exhaustive patterns: `_` not covered\n+```\n+\n+In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n+integer, Rust knows that it can have a number of different values. For example,\n+`6i`. But without the `_`, there is no arm that could match, and so Rust refuses\n+to compile. `_` is sort of like a catch-all arm. If none of the other arms match,\n+the arm with `_` will. And since we have this catch-all arm, we now have an arm\n+for every possible value of `x`, and so our program will now compile.\n+\n+`match` statements also destructure enums, as well. Remember this code from the\n+section on enums?\n+\n+```{rust}\n+let x = 5i;\n+let y = 10i;\n+\n+let ordering = x.cmp(&y);\n+\n+if ordering == Less {\n+    println!(\"less\");\n+} else if ordering == Greater {\n+    println!(\"greater\");\n+} else if ordering == Equal {\n+    println!(\"equal\");\n+}\n+```\n+\n+We can re-write this as a `match`:\n+\n+```{rust}\n+let x = 5i;\n+let y = 10i;\n+\n+match x.cmp(&y) {\n+    Less    => println!(\"less\"),\n+    Greater => println!(\"greater\"),\n+    Equal   => println!(\"equal\"),\n+}\n+```\n+\n+This version has way less noise, and it also checks exhaustively to make sure\n+that we have covered all possible variants of `Ordering`. With our `if`/`else`\n+version, if we had forgotten the `Greater` case, for example, our program would\n+have happily compiled. If we forget in the `match`, it will not. Rust helps us\n+make sure to cover all of our bases.\n+\n+`match` is also an expression, which means we can use it on the right hand side\n+of a `let` binding. We could also implement the previous line like this:\n+\n+```\n+let x = 5i;\n+let y = 10i;\n+\n+let result = match x.cmp(&y) {\n+    Less    => \"less\",\n+    Greater => \"greater\",\n+    Equal   => \"equal\",\n+};\n+\n+println!(\"{}\", result);\n+```\n+\n+In this case, it doesn't make a lot of sense, as we are just making a temporary\n+string where we don't need to, but sometimes, it's a nice pattern.\n+\n ## Looping\n \n for"}]}