{"sha": "027c8507b4265dcf285b0b503e2a49214b929f7b", "node_id": "C_kwDOAAsO6NoAKDAyN2M4NTA3YjQyNjVkY2YyODViMGI1MDNlMmE0OTIxNGI5MjlmN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-25T16:39:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-25T16:39:29Z"}, "message": "Auto merge of #103902 - vincenzopalazzo:macros/obligation_rulesv2, r=oli-obk\n\nuse `LocalDefId` instead of `HirId` in trait resolution to simplify the obligation clause resolution\n\nThis commit introduces a refactoring suggested by `@lcnr` to simplify the obligation clause resolution.\n\nThis is just the first PR that introduces a type of refactoring, but others PRs will follow this to introduce name changing to change from the variable name from `body_id` to something else.\n\nFixes https://github.com/rust-lang/rust/issues/104827\n\nSigned-off-by: Vincenzo Palazzo <vincenzopalazzodev@gmail.com>\n\n`@rustbot` r? `@lcnr`", "tree": {"sha": "04284e06ad87b0aaa593de220539e85983990470", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04284e06ad87b0aaa593de220539e85983990470"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/027c8507b4265dcf285b0b503e2a49214b929f7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/027c8507b4265dcf285b0b503e2a49214b929f7b", "html_url": "https://github.com/rust-lang/rust/commit/027c8507b4265dcf285b0b503e2a49214b929f7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/027c8507b4265dcf285b0b503e2a49214b929f7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "html_url": "https://github.com/rust-lang/rust/commit/95b61d16d4bd2e46b0a110c1bda703f026f0a94f"}, {"sha": "7d2c1103d7e6773db6fcef8f142d29f2004a4e3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2c1103d7e6773db6fcef8f142d29f2004a4e3b", "html_url": "https://github.com/rust-lang/rust/commit/7d2c1103d7e6773db6fcef8f142d29f2004a4e3b"}], "stats": {"total": 545, "additions": 265, "deletions": 280}, "files": [{"sha": "720bfe2c77abad563e6c503e9d80a89df27ed1fe", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -766,7 +766,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let copy_did = infcx.tcx.require_lang_item(LangItem::Copy, Some(span));\n         let cause = ObligationCause::new(\n             span,\n-            self.mir_hir_id(),\n+            self.mir_def_id(),\n             rustc_infer::traits::ObligationCauseCode::MiscObligation,\n         );\n         let errors = rustc_trait_selection::traits::fully_solve_bound("}, {"sha": "2ae13990a4589834128aea43c4b98bbe0f5d0ef3", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n@@ -2022,7 +2021,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|constraint| BlameConstraint {\n                 category: constraint.category,\n                 from_closure: constraint.from_closure,\n-                cause: ObligationCause::new(constraint.span, CRATE_HIR_ID, cause_code.clone()),\n+                cause: ObligationCause::new(constraint.span, CRATE_DEF_ID, cause_code.clone()),\n                 variance_info: constraint.variance_info,\n                 outlives_constraint: *constraint,\n             })"}, {"sha": "ef6de8b109136ca8d156fe615411382fc4a6f82b", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -273,7 +273,6 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // This logic duplicates most of `check_opaque_meets_bounds`.\n         // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n         let param_env = self.tcx.param_env(def_id);\n-        let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n         // HACK This bubble is required for this tests to pass:\n         // type-alias-impl-trait/issue-67844-nested-opaque.rs\n         let infcx =\n@@ -290,15 +289,15 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // the bounds that the function supplies.\n         let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n         if let Err(err) = ocx.eq(\n-            &ObligationCause::misc(instantiated_ty.span, body_id),\n+            &ObligationCause::misc(instantiated_ty.span, def_id),\n             param_env,\n             opaque_ty,\n             definition_ty,\n         ) {\n             infcx\n                 .err_ctxt()\n                 .report_mismatched_types(\n-                    &ObligationCause::misc(instantiated_ty.span, body_id),\n+                    &ObligationCause::misc(instantiated_ty.span, def_id),\n                     opaque_ty,\n                     definition_ty,\n                     err,\n@@ -309,7 +308,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         ocx.register_obligation(Obligation::misc(\n             infcx.tcx,\n             instantiated_ty.span,\n-            body_id,\n+            def_id,\n             param_env,\n             predicate,\n         ));"}, {"sha": "cc40c2566d2e6ad60debca45850e423b9b451425", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -754,12 +754,9 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         let ocx = ObligationCtxt::new(&infcx);\n \n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n-                        let hir_id = tcx\n-                            .hir()\n-                            .local_def_id_to_hir_id(self.body.source.def_id().expect_local());\n                         let cause = ObligationCause::new(\n                             terminator.source_info.span,\n-                            hir_id,\n+                            self.body.source.def_id().expect_local(),\n                             ObligationCauseCode::ItemObligation(callee),\n                         );\n                         let normalized_predicates = ocx.normalize(&cause, param_env, predicates);"}, {"sha": "a5c96a8b01613aa42a51389536b4abfad7b3b0fa", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -2,11 +2,11 @@ use crate::errors::AutoDerefReachedRecursionLimit;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::NormalizeExt;\n use crate::traits::{self, TraitEngine, TraitEngineExt};\n-use rustc_hir as hir;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::Limit;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::Span;\n \n@@ -28,7 +28,7 @@ pub struct Autoderef<'a, 'tcx> {\n     // Meta infos:\n     infcx: &'a InferCtxt<'tcx>,\n     span: Span,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n \n     // Current state:\n@@ -96,14 +96,14 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     pub fn new(\n         infcx: &'a InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_def_id: LocalDefId,\n         span: Span,\n         base_ty: Ty<'tcx>,\n     ) -> Autoderef<'a, 'tcx> {\n         Autoderef {\n             infcx,\n             span,\n-            body_id,\n+            body_id: body_def_id,\n             param_env,\n             state: AutoderefSnapshot {\n                 steps: vec![],"}, {"sha": "6c7482b40c3d2f3c30e48237da80113016885884", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -412,7 +412,6 @@ fn check_opaque_meets_bounds<'tcx>(\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n         hir::OpaqueTyOrigin::TyAlias => def_id,\n@@ -438,7 +437,7 @@ fn check_opaque_meets_bounds<'tcx>(\n         _ => re,\n     });\n \n-    let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+    let misc_cause = traits::ObligationCause::misc(span, def_id);\n \n     match ocx.eq(&misc_cause, param_env, opaque_ty, hidden_ty) {\n         Ok(()) => {}"}, {"sha": "c09294090d3102094628956b1ca410959fe037bd", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -147,12 +147,12 @@ fn compare_method_predicate_entailment<'tcx>(\n     //\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n-    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n+    let impl_m_def_id = impl_m.def_id.expect_local();\n     let cause = ObligationCause::new(\n         impl_m_span,\n-        impl_m_hir_id,\n+        impl_m_def_id,\n         ObligationCauseCode::CompareImplItemObligation {\n-            impl_item_def_id: impl_m.def_id.expect_local(),\n+            impl_item_def_id: impl_m_def_id,\n             trait_item_def_id: trait_m.def_id,\n             kind: impl_m.kind,\n         },\n@@ -198,7 +198,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     // Construct trait parameter environment and then shift it into the placeholder viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_def_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n@@ -213,14 +213,14 @@ fn compare_method_predicate_entailment<'tcx>(\n \n     let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n     for (predicate, span) in impl_m_own_bounds {\n-        let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n+        let normalize_cause = traits::ObligationCause::misc(span, impl_m_def_id);\n         let predicate = ocx.normalize(&normalize_cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n-            impl_m_hir_id,\n+            impl_m_def_id,\n             ObligationCauseCode::CompareImplItemObligation {\n-                impl_item_def_id: impl_m.def_id.expect_local(),\n+                impl_item_def_id: impl_m_def_id,\n                 trait_item_def_id: trait_m.def_id,\n                 kind: impl_m.kind,\n             },\n@@ -253,7 +253,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     );\n     let unnormalized_impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(unnormalized_impl_sig));\n \n-    let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+    let norm_cause = ObligationCause::misc(impl_m_span, impl_m_def_id);\n     let impl_sig = ocx.normalize(&norm_cause, param_env, unnormalized_impl_sig);\n     debug!(\"compare_impl_method: impl_fty={:?}\", impl_sig);\n \n@@ -311,6 +311,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     if !errors.is_empty() {\n         match check_implied_wf {\n             CheckImpliedWfMode::Check => {\n+                let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n@@ -336,7 +337,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         Some(infcx),\n-        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys.clone()),\n+        infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n         outlives_env.region_bound_pairs(),\n@@ -346,6 +347,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     if !errors.is_empty() {\n         // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n         // becomes a hard error (i.e. ideally we'd just call `resolve_regions_and_report_errors`\n+        let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n         match check_implied_wf {\n             CheckImpliedWfMode::Check => {\n                 return compare_method_predicate_entailment(\n@@ -371,7 +373,7 @@ fn compare_method_predicate_entailment<'tcx>(\n             }\n             CheckImpliedWfMode::Skip => {\n                 if infcx.tainted_by_errors().is_none() {\n-                    infcx.err_ctxt().report_region_errors(impl_m.def_id.expect_local(), &errors);\n+                    infcx.err_ctxt().report_region_errors(impl_m_def_id, &errors);\n                 }\n                 return Err(tcx\n                     .sess\n@@ -610,13 +612,14 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n-    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n+    let impl_m_def_id = impl_m.def_id.expect_local();\n+    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n     let cause = ObligationCause::new(\n         return_span,\n-        impl_m_hir_id,\n+        impl_m_def_id,\n         ObligationCauseCode::CompareImplItemObligation {\n-            impl_item_def_id: impl_m.def_id.expect_local(),\n+            impl_item_def_id: impl_m_def_id,\n             trait_item_def_id: trait_m.def_id,\n             kind: impl_m.kind,\n         },\n@@ -633,7 +636,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     let ocx = ObligationCtxt::new(infcx);\n \n     // Normalize the impl signature with fresh variables for lifetime inference.\n-    let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n+    let norm_cause = ObligationCause::misc(return_span, impl_m_def_id);\n     let impl_sig = ocx.normalize(\n         &norm_cause,\n         param_env,\n@@ -650,7 +653,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // the ImplTraitInTraitCollector, which gathers all of the RPITITs and replaces\n     // them with inference variables.\n     // We will use these inference variables to collect the hidden types of RPITITs.\n-    let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n+    let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_def_id);\n     let unnormalized_trait_sig = tcx\n         .liberate_late_bound_regions(\n             impl_m.def_id,\n@@ -732,12 +735,11 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n         Some(infcx),\n-        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+        infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_m.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n+    infcx\n+        .err_ctxt()\n+        .check_region_obligations_and_report_errors(impl_m_def_id, &outlives_environment)?;\n \n     let mut collected_tys = FxHashMap::default();\n     for (def_id, (ty, substs)) in collector.types {\n@@ -819,15 +821,15 @@ struct ImplTraitInTraitCollector<'a, 'tcx> {\n     types: FxHashMap<DefId, (Ty<'tcx>, ty::SubstsRef<'tcx>)>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n }\n \n impl<'a, 'tcx> ImplTraitInTraitCollector<'a, 'tcx> {\n     fn new(\n         ocx: &'a ObligationCtxt<'a, 'tcx>,\n         span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n     ) -> Self {\n         ImplTraitInTraitCollector { ocx, types: FxHashMap::default(), span, param_env, body_id }\n     }\n@@ -1671,14 +1673,12 @@ pub(super) fn compare_impl_const_raw(\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_const_item_def);\n-\n     // Compute placeholder form of impl and trait const tys.\n     let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n     let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n     let mut cause = ObligationCause::new(\n         impl_c_span,\n-        impl_c_hir_id,\n+        impl_const_item_def,\n         ObligationCauseCode::CompareImplItemObligation {\n             impl_item_def_id: impl_const_item_def,\n             trait_item_def_id: trait_const_item_def,\n@@ -1799,7 +1799,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // This `HirId` should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n+    let impl_ty_def_id = impl_ty.def_id.expect_local();\n     debug!(\"compare_type_predicate_entailment: trait_to_impl_substs={:?}\", trait_to_impl_substs);\n \n     // The predicates declared by the impl definition, the trait and the\n@@ -1814,7 +1814,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: bounds={:?}\", hybrid_preds);\n \n-    let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_hir_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_def_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n@@ -1827,12 +1827,12 @@ fn compare_type_predicate_entailment<'tcx>(\n     debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n     for (predicate, span) in impl_ty_own_bounds {\n-        let cause = ObligationCause::misc(span, impl_ty_hir_id);\n+        let cause = ObligationCause::misc(span, impl_ty_def_id);\n         let predicate = ocx.normalize(&cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n-            impl_ty_hir_id,\n+            impl_ty_def_id,\n             ObligationCauseCode::CompareImplItemObligation {\n                 impl_item_def_id: impl_ty.def_id.expect_local(),\n                 trait_item_def_id: trait_ty.def_id,\n@@ -2008,7 +2008,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     };\n     debug!(?normalize_param_env);\n \n-    let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n+    let impl_ty_def_id = impl_ty.def_id.expect_local();\n     let impl_ty_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n     let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n \n@@ -2020,7 +2020,7 @@ pub(super) fn check_type_bounds<'tcx>(\n \n     let normalize_cause = ObligationCause::new(\n         impl_ty_span,\n-        impl_ty_hir_id,\n+        impl_ty_def_id,\n         ObligationCauseCode::CheckAssociatedTypeBounds {\n             impl_item_def_id: impl_ty.def_id.expect_local(),\n             trait_item_def_id: trait_ty.def_id,\n@@ -2032,7 +2032,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         } else {\n             traits::BindingObligation(trait_ty.def_id, span)\n         };\n-        ObligationCause::new(impl_ty_span, impl_ty_hir_id, code)\n+        ObligationCause::new(impl_ty_span, impl_ty_def_id, code)\n     };\n \n     let obligations = tcx\n@@ -2063,7 +2063,7 @@ pub(super) fn check_type_bounds<'tcx>(\n \n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_hir_id, assumed_wf_types);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n "}, {"sha": "c93ac5ad963d2faeeaa440a92ad3c4ea29a7ad85", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -56,7 +56,8 @@ fn equate_intrinsic_type<'tcx>(\n         && gen_count_ok(own_counts.consts, 0, \"const\")\n     {\n         let fty = tcx.mk_fn_ptr(sig);\n-        let cause = ObligationCause::new(it.span, it.hir_id(), ObligationCauseCode::IntrinsicType);\n+        let it_def_id = it.owner_id.def_id;\n+        let cause = ObligationCause::new(it.span, it_def_id, ObligationCauseCode::IntrinsicType);\n         require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id)), fty);\n     }\n }"}, {"sha": "cf14da35375cc0ac7bdcfd5635788649d313a957", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -37,7 +37,7 @@ use std::ops::{ControlFlow, Deref};\n pub(super) struct WfCheckingCtxt<'a, 'tcx> {\n     pub(super) ocx: ObligationCtxt<'a, 'tcx>,\n     span: Span,\n-    body_id: hir::HirId,\n+    body_def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n impl<'a, 'tcx> Deref for WfCheckingCtxt<'a, 'tcx> {\n@@ -59,7 +59,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         self.ocx.normalize(\n-            &ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc)),\n+            &ObligationCause::new(span, self.body_def_id, ObligationCauseCode::WellFormed(loc)),\n             self.param_env,\n             value,\n         )\n@@ -71,8 +71,11 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         loc: Option<WellFormedLoc>,\n         arg: ty::GenericArg<'tcx>,\n     ) {\n-        let cause =\n-            traits::ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc));\n+        let cause = traits::ObligationCause::new(\n+            span,\n+            self.body_def_id,\n+            ObligationCauseCode::WellFormed(loc),\n+        );\n         // for a type to be WF, we do not need to check if const trait predicates satisfy.\n         let param_env = self.param_env.without_const();\n         self.ocx.register_obligation(traits::Obligation::new(\n@@ -93,19 +96,18 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     F: for<'a> FnOnce(&WfCheckingCtxt<'a, 'tcx>),\n {\n     let param_env = tcx.param_env(body_def_id);\n-    let body_id = tcx.hir().local_def_id_to_hir_id(body_def_id);\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n \n-    let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n+    let mut wfcx = WfCheckingCtxt { ocx, span, body_def_id, param_env };\n \n     if !tcx.features().trivial_bounds {\n         wfcx.check_false_global_bounds()\n     }\n     f(&mut wfcx);\n \n     let assumed_wf_types = wfcx.ocx.assumed_wf_types(param_env, span, body_def_id);\n-    let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, body_def_id, assumed_wf_types);\n \n     let errors = wfcx.select_all_or_error();\n     if !errors.is_empty() {\n@@ -374,7 +376,6 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                     continue;\n                 }\n \n-                let item_hir_id = item.id.hir_id();\n                 let param_env = tcx.param_env(item_def_id);\n \n                 let item_required_bounds = match item.kind {\n@@ -390,7 +391,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                         gather_gat_bounds(\n                             tcx,\n                             param_env,\n-                            item_hir_id,\n+                            item_def_id.def_id,\n                             sig.inputs_and_output,\n                             // We also assume that all of the function signature's parameter types\n                             // are well formed.\n@@ -412,7 +413,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                         gather_gat_bounds(\n                             tcx,\n                             param_env,\n-                            item_hir_id,\n+                            item_def_id.def_id,\n                             tcx.explicit_item_bounds(item_def_id).to_vec(),\n                             &FxIndexSet::default(),\n                             gat_def_id.def_id,\n@@ -458,21 +459,32 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n         let gat_item_hir = tcx.hir().expect_trait_item(gat_def_id.def_id);\n         debug!(?required_bounds);\n         let param_env = tcx.param_env(gat_def_id);\n-        let gat_hir = gat_item_hir.hir_id();\n \n         let mut unsatisfied_bounds: Vec<_> = required_bounds\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n                     a,\n                     b,\n-                ))) => {\n-                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n-                }\n+                ))) => !region_known_to_outlive(\n+                    tcx,\n+                    gat_def_id.def_id,\n+                    param_env,\n+                    &FxIndexSet::default(),\n+                    a,\n+                    b,\n+                ),\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n                     a,\n                     b,\n-                ))) => !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b),\n+                ))) => !ty_known_to_outlive(\n+                    tcx,\n+                    gat_def_id.def_id,\n+                    param_env,\n+                    &FxIndexSet::default(),\n+                    a,\n+                    b,\n+                ),\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n             .map(|clause| clause.to_string())\n@@ -551,7 +563,7 @@ fn augment_param_env<'tcx>(\n fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    item_hir: hir::HirId,\n+    item_def_id: LocalDefId,\n     to_check: T,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     gat_def_id: LocalDefId,\n@@ -584,7 +596,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n         // reflected in a where clause on the GAT itself.\n         for (ty, ty_idx) in &types {\n             // In our example, requires that `Self: 'a`\n-            if ty_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *ty, *region_a) {\n+            if ty_known_to_outlive(tcx, item_def_id, param_env, &wf_tys, *ty, *region_a) {\n                 debug!(?ty_idx, ?region_a_idx);\n                 debug!(\"required clause: {ty} must outlive {region_a}\");\n                 // Translate into the generic parameters of the GAT. In\n@@ -622,7 +634,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             if ty::ReStatic == **region_b || region_a == region_b {\n                 continue;\n             }\n-            if region_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *region_a, *region_b) {\n+            if region_known_to_outlive(tcx, item_def_id, param_env, &wf_tys, *region_a, *region_b) {\n                 debug!(?region_a_idx, ?region_b_idx);\n                 debug!(\"required clause: {region_a} must outlive {region_b}\");\n                 // Translate into the generic parameters of the GAT.\n@@ -658,7 +670,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n /// `ty` outlives `region`.\n fn ty_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    id: hir::HirId,\n+    id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     ty: Ty<'tcx>,\n@@ -675,7 +687,7 @@ fn ty_known_to_outlive<'tcx>(\n /// `region_a` outlives `region_b`\n fn region_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    id: hir::HirId,\n+    id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     region_a: ty::Region<'tcx>,\n@@ -699,7 +711,7 @@ fn region_known_to_outlive<'tcx>(\n /// to be tested), then resolve region and return errors\n fn resolve_regions_with_wf_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    id: hir::HirId,\n+    id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     add_constraints: impl for<'a> FnOnce(&'a InferCtxt<'tcx>, &'a RegionBoundPairs<'tcx>),\n@@ -1093,7 +1105,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n                         hir_ty.span,\n-                        wfcx.body_id,\n+                        wfcx.body_def_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n@@ -1113,7 +1125,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             if let ty::VariantDiscr::Explicit(discr_def_id) = variant.discr {\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n-                    wfcx.body_id,\n+                    wfcx.body_def_id,\n                     traits::MiscObligation,\n                 );\n                 wfcx.register_obligation(traits::Obligation::new(\n@@ -1174,7 +1186,7 @@ fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: &ty::AssocI\n         traits::wf::predicate_obligations(\n             wfcx.infcx,\n             wfcx.param_env,\n-            wfcx.body_id,\n+            wfcx.body_def_id,\n             normalized_bound,\n             bound_span,\n         )\n@@ -1214,7 +1226,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n         wfcx.register_wf_obligation(ty_span, Some(WellFormedLoc::Ty(item_id)), item_ty.into());\n         if forbid_unsized {\n             wfcx.register_bound(\n-                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::WellFormed(None)),\n+                traits::ObligationCause::new(ty_span, wfcx.body_def_id, traits::WellFormed(None)),\n                 wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sized, None),\n@@ -1229,7 +1241,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n \n         if should_check_for_sync {\n             wfcx.register_bound(\n-                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::SharedStatic),\n+                traits::ObligationCause::new(ty_span, wfcx.body_def_id, traits::SharedStatic),\n                 wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sync, Some(ty_span)),\n@@ -1269,7 +1281,7 @@ fn check_impl<'tcx>(\n                 let mut obligations = traits::wf::trait_obligations(\n                     wfcx.infcx,\n                     wfcx.param_env,\n-                    wfcx.body_id,\n+                    wfcx.body_def_id,\n                     &trait_pred,\n                     ast_trait_ref.path.span,\n                     item,\n@@ -1466,7 +1478,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             let pred = wfcx.normalize(sp, None, pred);\n             let cause = traits::ObligationCause::new(\n                 sp,\n-                wfcx.body_id,\n+                wfcx.body_def_id,\n                 traits::ItemObligation(def_id.to_def_id()),\n             );\n             traits::Obligation::new(tcx, cause, wfcx.param_env, pred)\n@@ -1482,12 +1494,11 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n         traits::wf::predicate_obligations(\n             infcx,\n             wfcx.param_env.without_const(),\n-            wfcx.body_id,\n+            wfcx.body_def_id,\n             p,\n             sp,\n         )\n     });\n-\n     let obligations: Vec<_> = wf_obligations.chain(default_obligations).collect();\n     wfcx.register_obligations(obligations);\n }\n@@ -1549,7 +1560,7 @@ fn check_fn_or_method<'tcx>(\n         // Check that the argument is a tuple\n         if let Some(ty) = inputs.next() {\n             wfcx.register_bound(\n-                ObligationCause::new(span, wfcx.body_id, ObligationCauseCode::RustCall),\n+                ObligationCause::new(span, wfcx.body_def_id, ObligationCauseCode::RustCall),\n                 wfcx.param_env,\n                 *ty,\n                 tcx.require_lang_item(hir::LangItem::Tuple, Some(span)),\n@@ -1597,7 +1608,7 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n                     traits::wf::predicate_obligations(\n                         wfcx.infcx,\n                         wfcx.param_env,\n-                        wfcx.body_id,\n+                        wfcx.body_def_id,\n                         normalized_bound,\n                         bound_span,\n                     )\n@@ -1697,7 +1708,7 @@ fn receiver_is_valid<'tcx>(\n     let infcx = wfcx.infcx;\n     let tcx = wfcx.tcx();\n     let cause =\n-        ObligationCause::new(span, wfcx.body_id, traits::ObligationCauseCode::MethodReceiver);\n+        ObligationCause::new(span, wfcx.body_def_id, traits::ObligationCauseCode::MethodReceiver);\n \n     let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty).is_ok();\n \n@@ -1709,7 +1720,7 @@ fn receiver_is_valid<'tcx>(\n         return true;\n     }\n \n-    let mut autoderef = Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty);\n+    let mut autoderef = Autoderef::new(infcx, wfcx.param_env, wfcx.body_def_id, span, receiver_ty);\n \n     // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {\n@@ -1894,8 +1905,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         let mut span = self.span;\n         let empty_env = ty::ParamEnv::empty();\n \n-        let def_id = tcx.hir().local_def_id(self.body_id);\n-        let predicates_with_span = tcx.predicates_of(def_id).predicates.iter().copied();\n+        let predicates_with_span = tcx.predicates_of(self.body_def_id).predicates.iter().copied();\n         // Check elaborated bounds.\n         let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n \n@@ -1910,7 +1920,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n             // Match the existing behavior.\n             if pred.is_global() && !pred.has_late_bound_vars() {\n                 let pred = self.normalize(span, None, pred);\n-                let hir_node = tcx.hir().find(self.body_id);\n+                let hir_node = tcx.hir().find_by_def_id(self.body_def_id);\n \n                 // only use the span of the predicate clause (#90869)\n \n@@ -1929,7 +1939,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n                 let obligation = traits::Obligation::new(\n                     tcx,\n-                    traits::ObligationCause::new(span, self.body_id, traits::TrivialBound),\n+                    traits::ObligationCause::new(span, self.body_def_id, traits::TrivialBound),\n                     empty_env,\n                     pred,\n                 );"}, {"sha": "76668f7e9ac4b0379a5ff9db80e6a20ebe42e003", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -64,8 +64,6 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-\n     let self_type = tcx.type_of(impl_did);\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\", self_type);\n \n@@ -80,7 +78,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => bug!(\"expected Copy impl item\"),\n     };\n \n-    let cause = traits::ObligationCause::misc(span, impl_hir_id);\n+    let cause = traits::ObligationCause::misc(span, impl_did);\n     match type_allowed_to_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n@@ -224,7 +222,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n \n     let infcx = tcx.infer_ctxt().build();\n-    let cause = ObligationCause::misc(span, impl_hir_id);\n+    let cause = ObligationCause::misc(span, impl_did);\n \n     use rustc_type_ir::sty::TyKind::*;\n     match (source.kind(), target.kind()) {\n@@ -386,8 +384,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\", source, target);\n \n     let infcx = tcx.infer_ctxt().build();\n-    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-    let cause = ObligationCause::misc(span, impl_hir_id);\n+    let cause = ObligationCause::misc(span, impl_did);\n     let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                        mt_b: ty::TypeAndMut<'tcx>,\n                        mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -575,7 +572,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     };\n \n     // Register an obligation for `A: Trait<B>`.\n-    let cause = traits::ObligationCause::misc(span, impl_hir_id);\n+    let cause = traits::ObligationCause::misc(span, impl_did);\n     let predicate =\n         predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, [source, target]);\n     let errors = traits::fully_solve_obligation(&infcx, predicate);"}, {"sha": "e253459ef64ab07d6df9f87193f174215cb93b10", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -1248,11 +1248,12 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n     }\n }\n \n+// FIXME(vincenzopalazzo): remove the hir item when the refactoring is stable\n fn suggest_impl_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ret_ty: Ty<'tcx>,\n     span: Span,\n-    hir_id: hir::HirId,\n+    _hir_id: hir::HirId,\n     def_id: LocalDefId,\n ) -> Option<String> {\n     let format_as_assoc: fn(_, _, _, _, _) -> _ =\n@@ -1324,7 +1325,7 @@ fn suggest_impl_trait<'tcx>(\n         }\n         let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n         let item_ty = ocx.normalize(\n-            &ObligationCause::misc(span, hir_id),\n+            &ObligationCause::misc(span, def_id),\n             param_env,\n             tcx.mk_projection(assoc_item_def_id, substs),\n         );"}, {"sha": "9cf82b39ec947b9e4d5ee29e803dfe2fc5a088b6", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -1,11 +1,12 @@\n use crate::collect::ItemCtxt;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{ForeignItem, ForeignItemKind, HirId};\n+use rustc_hir::{ForeignItem, ForeignItemKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Region, TyCtxt, TypeFoldable, TypeFolder};\n+use rustc_span::def_id::LocalDefId;\n use rustc_trait_selection::traits;\n \n pub fn provide(providers: &mut Providers) {\n@@ -57,7 +58,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n         cause: Option<ObligationCause<'tcx>>,\n         cause_depth: usize,\n         icx: ItemCtxt<'tcx>,\n-        hir_id: HirId,\n+        def_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         depth: usize,\n     }\n@@ -68,7 +69,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n             let tcx_ty = self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n             let cause = traits::ObligationCause::new(\n                 ty.span,\n-                self.hir_id,\n+                self.def_id,\n                 traits::ObligationCauseCode::WellFormed(None),\n             );\n             let errors = traits::fully_solve_obligation(\n@@ -106,7 +107,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n         cause: None,\n         cause_depth: 0,\n         icx,\n-        hir_id,\n+        def_id,\n         param_env: tcx.param_env(def_id.to_def_id()),\n         depth: 0,\n     };"}, {"sha": "a5dcfab9be8e84d102923a58822f232df27731e8", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -164,7 +164,6 @@ fn get_impl_substs(\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n     let param_env = tcx.param_env(impl1_def_id);\n-    let impl1_hir_id = tcx.hir().local_def_id_to_hir_id(impl1_def_id);\n \n     let assumed_wf_types =\n         ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n@@ -179,7 +178,7 @@ fn get_impl_substs(\n         return None;\n     }\n \n-    let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n@@ -372,15 +371,9 @@ fn check_predicates<'tcx>(\n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().subst_identity().substs {\n         let infcx = &tcx.infer_ctxt().build();\n-        let obligations = wf::obligations(\n-            infcx,\n-            tcx.param_env(impl1_def_id),\n-            tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n-            0,\n-            arg,\n-            span,\n-        )\n-        .unwrap();\n+        let obligations =\n+            wf::obligations(infcx, tcx.param_env(impl1_def_id), impl1_def_id, 0, arg, span)\n+                .unwrap();\n \n         assert!(!obligations.needs_infer());\n         impl2_predicates.extend("}, {"sha": "da35210023891ab37a378a4a55775228af3d4a7b", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -100,14 +100,14 @@ mod variance;\n \n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{Node, CRATE_HIR_ID};\n+use rustc_hir::Node;\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util;\n use rustc_session::{config::EntryFnType, parse::feature_err};\n+use rustc_span::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -185,16 +185,15 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     let main_fnsig = tcx.fn_sig(main_def_id);\n     let main_span = tcx.def_span(main_def_id);\n \n-    fn main_fn_diagnostics_hir_id(tcx: TyCtxt<'_>, def_id: DefId, sp: Span) -> hir::HirId {\n+    fn main_fn_diagnostics_def_id(tcx: TyCtxt<'_>, def_id: DefId, sp: Span) -> LocalDefId {\n         if let Some(local_def_id) = def_id.as_local() {\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n             let hir_type = tcx.type_of(local_def_id);\n             if !matches!(hir_type.kind(), ty::FnDef(..)) {\n                 span_bug!(sp, \"main has a non-function type: found `{}`\", hir_type);\n             }\n-            hir_id\n+            local_def_id\n         } else {\n-            CRATE_HIR_ID\n+            CRATE_DEF_ID\n         }\n     }\n \n@@ -251,7 +250,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     }\n \n     let mut error = false;\n-    let main_diagnostics_hir_id = main_fn_diagnostics_hir_id(tcx, main_def_id, main_span);\n+    let main_diagnostics_def_id = main_fn_diagnostics_def_id(tcx, main_def_id, main_span);\n     let main_fn_generics = tcx.generics_of(main_def_id);\n     let main_fn_predicates = tcx.predicates_of(main_def_id);\n     if main_fn_generics.count() != 0 || !main_fnsig.bound_vars().is_empty() {\n@@ -326,7 +325,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let param_env = ty::ParamEnv::empty();\n         let cause = traits::ObligationCause::new(\n             return_ty_span,\n-            main_diagnostics_hir_id,\n+            main_diagnostics_def_id,\n             ObligationCauseCode::MainFunctionType,\n         );\n         let ocx = traits::ObligationCtxt::new(&infcx);\n@@ -356,7 +355,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         tcx,\n         &ObligationCause::new(\n             main_span,\n-            main_diagnostics_hir_id,\n+            main_diagnostics_def_id,\n             ObligationCauseCode::MainFunctionType,\n         ),\n         se_ty,\n@@ -444,7 +443,11 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n \n             require_same_types(\n                 tcx,\n-                &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n+                &ObligationCause::new(\n+                    start_span,\n+                    start_def_id,\n+                    ObligationCauseCode::StartFunctionType,\n+                ),\n                 se_ty,\n                 tcx.mk_fn_ptr(tcx.fn_sig(start_def_id)),\n             );"}, {"sha": "73aba2780d680388e6496981672e40da59fe2529", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -186,10 +186,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         prior_arm: Option<(Option<hir::HirId>, Ty<'tcx>, Span)>,\n     ) {\n         let hir = self.tcx.hir();\n-\n         // First, check that we're actually in the tail of a function.\n-        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, _), .. }) =\n-            hir.get(self.body_id) else { return; };\n+        let Some(body_id) = hir.maybe_body_owned_by(self.body_id) else { return; };\n+        let body = hir.body(body_id);\n+        let hir::ExprKind::Block(block, _) = body.value.kind else { return; };\n         let Some(hir::Stmt { kind: hir::StmtKind::Semi(last_expr), .. })\n             = block.innermost_block().stmts.last() else {  return; };\n         if last_expr.hir_id != expr.hir_id {\n@@ -198,7 +198,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Next, make sure that we have no type expectation.\n         let Some(ret) = hir\n-            .find_by_def_id(self.body_id.owner.def_id)\n+            .find_by_def_id(self.body_id)\n             .and_then(|owner| owner.fn_decl())\n             .map(|decl| decl.output.span()) else { return; };\n         let Expectation::IsLast(stmt) = expectation else {"}, {"sha": "8bbbf04c0cd4729019ba1fdf6bd7754f3280bed5", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -43,7 +43,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     let ret_ty =\n         fcx.register_infer_ok_obligations(fcx.infcx.replace_opaque_types_with_inference_vars(\n             declared_ret_ty,\n-            body.value.hir_id,\n+            fn_def_id,\n             decl.output.span(),\n             fcx.param_env,\n         ));"}, {"sha": "329b69eff54a396338f6e6f4e58e69f0ffc3c61c", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -4,7 +4,6 @@ use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use hir::def::DefKind;\n use rustc_hir as hir;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -14,6 +13,7 @@ use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TypeSuperVisitable, TypeVisitor};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(?bound_sig, ?liberated_sig);\n \n-        let mut fcx = FnCtxt::new(self, self.param_env.without_const(), body.value.hir_id);\n+        let mut fcx = FnCtxt::new(self, self.param_env.without_const(), closure.def_id);\n         let generator_types = check_fn(\n             &mut fcx,\n             liberated_sig,\n@@ -620,8 +620,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // function.\n                 Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn)) => {\n                     debug!(\"closure is async fn body\");\n-                    self.deduce_future_output_from_obligations(expr_def_id, body.id().hir_id)\n-                        .unwrap_or_else(|| {\n+                    let def_id = self.tcx.hir().body_owner_def_id(body.id());\n+                    self.deduce_future_output_from_obligations(expr_def_id, def_id).unwrap_or_else(\n+                        || {\n                             // AFAIK, deducing the future output\n                             // always succeeds *except* in error cases\n                             // like #65159. I'd like to return Error\n@@ -630,7 +631,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // *have* reported an\n                             // error. --nikomatsakis\n                             astconv.ty_infer(None, decl.output.span())\n-                        })\n+                        },\n+                    )\n                 }\n \n                 _ => astconv.ty_infer(None, decl.output.span()),\n@@ -665,7 +667,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn deduce_future_output_from_obligations(\n         &self,\n         expr_def_id: LocalDefId,\n-        body_id: hir::HirId,\n+        body_def_id: LocalDefId,\n     ) -> Option<Ty<'tcx>> {\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(self.tcx.def_span(expr_def_id), \"async fn generator outside of a fn\")\n@@ -725,7 +727,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let InferOk { value: output_ty, obligations } = self\n             .replace_opaque_types_with_inference_vars(\n                 output_ty,\n-                body_id,\n+                body_def_id,\n                 self.tcx.def_span(expr_def_id),\n                 self.param_env,\n             );"}, {"sha": "058984731040a2356ff126d4307b787ddf2a1c46", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -852,7 +852,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Point any obligations that were registered due to opaque type\n             // inference at the return expression.\n             self.select_obligations_where_possible(|errors| {\n-                self.point_at_return_for_opaque_ty_error(errors, span, return_expr_ty);\n+                self.point_at_return_for_opaque_ty_error(errors, span, return_expr_ty, return_expr.span);\n             });\n         }\n     }\n@@ -862,9 +862,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n         span: Span,\n         return_expr_ty: Ty<'tcx>,\n+        return_span: Span,\n     ) {\n         // Don't point at the whole block if it's empty\n-        if span == self.tcx.hir().span(self.body_id) {\n+        if span == return_span {\n             return;\n         }\n         for err in errors {\n@@ -1374,7 +1375,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let body = self.tcx.hir().body(anon_const.body);\n \n         // Create a new function context.\n-        let fcx = FnCtxt::new(self, self.param_env.with_const(), body.value.hir_id);\n+        let def_id = anon_const.def_id;\n+        let fcx = FnCtxt::new(self, self.param_env.with_const(), def_id);\n         crate::GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n         let ty = fcx.check_expr_with_expectation(&body.value, expected);\n@@ -2151,13 +2153,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         variant: &'tcx ty::VariantDef,\n         access_span: Span,\n     ) -> Vec<Symbol> {\n+        let body_owner_hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n         variant\n             .fields\n             .iter()\n             .filter(|field| {\n                 let def_scope = self\n                     .tcx\n-                    .adjust_ident_and_get_scope(field.ident(self.tcx), variant.def_id, self.body_id)\n+                    .adjust_ident_and_get_scope(\n+                        field.ident(self.tcx),\n+                        variant.def_id,\n+                        body_owner_hir_id,\n+                    )\n                     .1;\n                 field.vis.is_accessible_from(def_scope, self.tcx)\n                     && !matches!(\n@@ -2199,8 +2206,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match deref_base_ty.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\", deref_base_ty);\n+                    let body_hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n                     let (ident, def_scope) =\n-                        self.tcx.adjust_ident_and_get_scope(field, base_def.did(), self.body_id);\n+                        self.tcx.adjust_ident_and_get_scope(field, base_def.did(), body_hir_id);\n                     let fields = &base_def.non_enum_variant().fields;\n                     if let Some(index) = fields\n                         .iter()\n@@ -2538,7 +2546,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn point_at_param_definition(&self, err: &mut Diagnostic, param: ty::ParamTy) {\n-        let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n+        let generics = self.tcx.generics_of(self.body_id);\n         let generic_param = generics.type_param(&param, self.tcx);\n         if let ty::GenericParamDefKind::Type { synthetic: true, .. } = generic_param.kind {\n             return;"}, {"sha": "a6d96881c8f290efd9d014f521954cd448beca4e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -2126,7 +2126,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match *callee_ty.kind() {\n                 ty::Param(param) => {\n                     let param =\n-                        self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx);\n+                        self.tcx.generics_of(self.body_id).type_param(&param, self.tcx);\n                     if param.kind.is_synthetic() {\n                         // if it's `impl Fn() -> ..` then just fall down to the def-id based logic\n                         def_id = param.def_id;\n@@ -2135,7 +2135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // and point at that.\n                         let instantiated = self\n                             .tcx\n-                            .explicit_predicates_of(self.body_id.owner)\n+                            .explicit_predicates_of(self.body_id)\n                             .instantiate_identity(self.tcx);\n                         // FIXME(compiler-errors): This could be problematic if something has two\n                         // fn-like predicates with different args, but callable types really never"}, {"sha": "8724e69cc5134fae02a13b770b24e1b85851cba0", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -10,7 +10,7 @@ pub use suggestions::*;\n use crate::coercion::DynamicCoerceMany;\n use crate::{Diverges, EnclosingBreakables, Inherited};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n@@ -38,7 +38,7 @@ use std::ops::Deref;\n /// [`ItemCtxt`]: rustc_hir_analysis::collect::ItemCtxt\n /// [`InferCtxt`]: infer::InferCtxt\n pub struct FnCtxt<'a, 'tcx> {\n-    pub(super) body_id: hir::HirId,\n+    pub(super) body_id: LocalDefId,\n \n     /// The parameter environment used for proving trait obligations\n     /// in this function. This can change when we descend into\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn new(\n         inh: &'a Inherited<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n     ) -> FnCtxt<'a, 'tcx> {\n         FnCtxt {\n             body_id,\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn item_def_id(&self) -> DefId {\n-        self.body_id.owner.to_def_id()\n+        self.body_id.to_def_id()\n     }\n \n     fn get_type_parameter_bounds("}, {"sha": "6046e55c65c18366c2b2cb10fae1cd1a390fe7f1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.typeck_results\n             .borrow()\n             .liberated_fn_sigs()\n-            .get(self.tcx.hir().parent_id(self.body_id))\n+            .get(self.tcx.hir().local_def_id_to_hir_id(self.body_id))\n             .copied()\n     }\n \n@@ -164,7 +164,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n-        self.err_ctxt().extract_callable_info(self.body_id, self.param_env, ty)\n+        let body_hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n+        self.err_ctxt().extract_callable_info(body_hir_id, self.param_env, ty)\n     }\n \n     pub fn suggest_two_fn_call("}, {"sha": "bb487facc23fdf9d58eb2a640181ac005749fb08", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -201,7 +201,7 @@ fn typeck_with_fallback<'tcx>(\n \n     let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n-        let mut fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n+        let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n \n         if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {"}, {"sha": "939f9c93a02cab29174b1c48713fd1498a731138", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -508,9 +508,10 @@ fn method_autoderef_steps<'tcx>(\n     let (ref infcx, goal, inference_vars) = tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n     let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-    let mut autoderef = Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty)\n-        .include_raw_pointers()\n-        .silence_errors();\n+    let mut autoderef =\n+        Autoderef::new(infcx, param_env, hir::def_id::CRATE_DEF_ID, DUMMY_SP, self_ty)\n+            .include_raw_pointers()\n+            .silence_errors();\n     let mut reached_raw_pointer = false;\n     let mut steps: Vec<_> = autoderef\n         .by_ref()\n@@ -610,10 +611,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn push_candidate(&mut self, candidate: Candidate<'tcx>, is_inherent: bool) {\n         let is_accessible = if let Some(name) = self.method_name {\n             let item = candidate.item;\n-            let def_scope = self\n-                .tcx\n-                .adjust_ident_and_get_scope(name, item.container_id(self.tcx), self.body_id)\n-                .1;\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(name, item.container_id(self.tcx), hir_id).1;\n             item.visibility(self.tcx).is_accessible_from(def_scope, self.tcx)\n         } else {\n             true"}, {"sha": "7a2791b11bfdd0d58951bd071f09bb0c50a59e1b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -352,7 +352,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty_span = match rcvr_ty.kind() {\n             ty::Param(param_type) => {\n-                Some(param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()))\n+                Some(param_type.span_from_generics(self.tcx, self.body_id.to_def_id()))\n             }\n             ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n             _ => None,\n@@ -403,7 +403,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 args,\n                 sugg_span,\n             );\n-\n             self.note_candidates_on_method_error(\n                 rcvr_ty,\n                 item_name,\n@@ -496,9 +495,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::Param(_) => {\n                                 // Account for `fn` items like in `issue-35677.rs` to\n                                 // suggest restricting its type params.\n-                                let parent_body =\n-                                    hir.body_owner(hir::BodyId { hir_id: self.body_id });\n-                                Some(hir.get(parent_body))\n+                                Some(hir.get_by_def_id(self.body_id))\n                             }\n                             ty::Adt(def, _) => {\n                                 def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n@@ -1343,7 +1340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => None,\n         });\n         if let Some((field, field_ty)) = field_receiver {\n-            let scope = tcx.parent_module(self.body_id);\n+            let scope = tcx.parent_module_from_def_id(self.body_id);\n             let is_accessible = field.vis.is_accessible_from(scope, tcx);\n \n             if is_accessible {\n@@ -1593,7 +1590,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 else { return };\n \n         let map = self.infcx.tcx.hir();\n-        let body = map.body(rustc_hir::BodyId { hir_id: self.body_id });\n+        let body_id = self.tcx.hir().body_owned_by(self.body_id);\n+        let body = map.body(body_id);\n         struct LetVisitor<'a> {\n             result: Option<&'a hir::Expr<'a>>,\n             ident_name: Symbol,\n@@ -2195,7 +2193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             true\n         });\n \n-        let module_did = self.tcx.parent_module(self.body_id);\n+        let module_did = self.tcx.parent_module_from_def_id(self.body_id);\n         let (module, _, _) = self.tcx.hir().get_module(module_did);\n         let span = module.spans.inject_use_span;\n \n@@ -2517,7 +2515,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             // Obtain the span for `param` and use it for a structured suggestion.\n             if let Some(param) = param_type {\n-                let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n+                let generics = self.tcx.generics_of(self.body_id.to_def_id());\n                 let type_param = generics.type_param(param, self.tcx);\n                 let hir = self.tcx.hir();\n                 if let Some(def_id) = type_param.def_id.as_local() {"}, {"sha": "79704b6adf78e0e6b204d701d014664d2e7c513a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -1845,16 +1845,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             }\n         }\n \n-        // In some (most?) cases cause.body_id points to actual body, but in some cases\n-        // it's an actual definition. According to the comments (e.g. in\n-        // rustc_hir_analysis/check/compare_impl_item.rs:compare_predicate_entailment) the latter\n-        // is relied upon by some other code. This might (or might not) need cleanup.\n-        let body_owner_def_id =\n-            self.tcx.hir().opt_local_def_id(cause.body_id).unwrap_or_else(|| {\n-                self.tcx.hir().body_owner_def_id(hir::BodyId { hir_id: cause.body_id })\n-            });\n         self.check_and_note_conflicting_crates(diag, terr);\n-        self.tcx.note_and_explain_type_err(diag, terr, cause, span, body_owner_def_id.to_def_id());\n+        self.tcx.note_and_explain_type_err(diag, terr, cause, span, cause.body_id.to_def_id());\n \n         if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values\n             && let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind()"}, {"sha": "eb7bd7256c6747288b2eb4f28c762c2066a1c074", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -487,8 +487,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         span: Span,\n     ) {\n         let hir = self.tcx.hir();\n-        let fn_hir_id = hir.parent_id(cause.body_id);\n-        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n+        if let Some(node) = self.tcx.hir().find_by_def_id(cause.body_id) &&\n             let hir::Node::Item(hir::Item {\n                     kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n                 }) = node {"}, {"sha": "b68b0baaa4062bd7df559e134fbb21b5b5725f49", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def::DefKind;\n use hir::def_id::{DefId, LocalDefId};\n-use hir::{HirId, OpaqueTyOrigin};\n+use hir::OpaqueTyOrigin;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n@@ -48,7 +48,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn replace_opaque_types_with_inference_vars<T: TypeFoldable<'tcx>>(\n         &self,\n         value: T,\n-        body_id: HirId,\n+        body_id: LocalDefId,\n         span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {"}, {"sha": "3a82899660b19df2e1c842cd7bb60a0624522358", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -8,6 +8,7 @@ mod project;\n mod structural_impls;\n pub mod util;\n \n+use hir::def_id::LocalDefId;\n use rustc_hir as hir;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::{self, Const, ToPredicate, Ty, TyCtxt};\n@@ -146,7 +147,7 @@ impl<'tcx, O> Obligation<'tcx, O> {\n     pub fn misc(\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         trait_ref: impl ToPredicate<'tcx, O>,\n     ) -> Obligation<'tcx, O> {"}, {"sha": "f27fd90c55c2a9527972be0ab8353705d7eff02d", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -732,7 +732,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             cx.tcx,\n             param_env,\n             ty,\n-            traits::ObligationCause::misc(item.span, item.hir_id()),\n+            traits::ObligationCause::misc(item.span, item.owner_id.def_id),\n         )\n         .is_ok()\n         {"}, {"sha": "1add352e0c42d853f719a2db62c234b5497864ef", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -139,9 +139,10 @@ fn suggest_question_mark<'tcx>(\n \n     let ty = substs.type_at(0);\n     let infcx = cx.tcx.infer_ctxt().build();\n+    let body_def_id = cx.tcx.hir().body_owner_def_id(body_id);\n     let cause = ObligationCause::new(\n         span,\n-        body_id.hir_id,\n+        body_def_id,\n         rustc_infer::traits::ObligationCauseCode::MiscObligation,\n     );\n     let errors = rustc_trait_selection::traits::fully_solve_bound("}, {"sha": "f6fae8ab552743c23007da3bd119e93ff8e21ad9", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -18,7 +18,8 @@ use crate::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n+use rustc_span::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n@@ -99,7 +100,7 @@ pub struct ObligationCause<'tcx> {\n     /// (in particular, closures can add new assumptions). See the\n     /// field `region_obligations` of the `FulfillmentContext` for more\n     /// information.\n-    pub body_id: hir::HirId,\n+    pub body_id: LocalDefId,\n \n     code: InternedObligationCauseCode<'tcx>,\n }\n@@ -120,13 +121,13 @@ impl<'tcx> ObligationCause<'tcx> {\n     #[inline]\n     pub fn new(\n         span: Span,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n         code: ObligationCauseCode<'tcx>,\n     ) -> ObligationCause<'tcx> {\n         ObligationCause { span, body_id, code: code.into() }\n     }\n \n-    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+    pub fn misc(span: Span, body_id: LocalDefId) -> ObligationCause<'tcx> {\n         ObligationCause::new(span, body_id, MiscObligation)\n     }\n \n@@ -137,7 +138,7 @@ impl<'tcx> ObligationCause<'tcx> {\n \n     #[inline(always)]\n     pub fn dummy_with_span(span: Span) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id: hir::CRATE_HIR_ID, code: Default::default() }\n+        ObligationCause { span, body_id: CRATE_DEF_ID, code: Default::default() }\n     }\n \n     pub fn span(&self) -> Span {"}, {"sha": "4af29fcbfb58645f30d3d74be4af30a4d3c4a53b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -2437,6 +2437,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         ident\n     }\n \n+    // FIXME(vincenzoapalzzo): move the HirId to a LocalDefId\n     pub fn adjust_ident_and_get_scope(\n         self,\n         mut ident: Ident,"}, {"sha": "b0d24af958dd7bed2f854c5d41c213412c518af6", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n+use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::Span;\n use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -189,10 +190,11 @@ impl<'tcx> ConstToPat<'tcx> {\n         // using `PartialEq::eq` in this scenario in the past.)\n         let partial_eq_trait_id =\n             self.tcx().require_lang_item(hir::LangItem::PartialEq, Some(self.span));\n+        let def_id = self.tcx().hir().opt_local_def_id(self.id).unwrap_or(CRATE_DEF_ID);\n         let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n             self.tcx(),\n             self.param_env,\n-            ObligationCause::misc(self.span, self.id),\n+            ObligationCause::misc(self.span, def_id),\n             partial_eq_trait_id,\n             0,\n             [ty, ty],"}, {"sha": "ecee0bf7a6d1b7aa422d95b16e32eb8aed946901", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -17,7 +17,6 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n@@ -382,18 +381,14 @@ fn resolve_negative_obligation<'tcx>(\n         return false;\n     }\n \n-    let (body_id, body_def_id) = if let Some(body_def_id) = body_def_id.as_local() {\n-        (tcx.hir().local_def_id_to_hir_id(body_def_id), body_def_id)\n-    } else {\n-        (CRATE_HIR_ID, CRATE_DEF_ID)\n-    };\n+    let body_def_id = body_def_id.as_local().unwrap_or(CRATE_DEF_ID);\n \n     let ocx = ObligationCtxt::new(&infcx);\n     let wf_tys = ocx.assumed_wf_types(param_env, DUMMY_SP, body_def_id);\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         Some(&infcx),\n-        infcx.implied_bounds_tys(param_env, body_id, wf_tys),\n+        infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n \n     infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);"}, {"sha": "a2ddd91546c18814f8bdce17c2b8647698b9aeee", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -190,8 +190,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n         let assumed_wf_types = tcx.assumed_wf_types(def_id);\n         let mut implied_bounds = FxIndexSet::default();\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        let cause = ObligationCause::misc(span, hir_id);\n+        let cause = ObligationCause::misc(span, def_id);\n         for ty in assumed_wf_types {\n             // FIXME(@lcnr): rustc currently does not check wf for types\n             // pre-normalization, meaning that implied bounds are sometimes"}, {"sha": "6bf453c3ff084376b2afa27c74384acbf4e5a8bd", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -81,7 +81,7 @@ pub fn recompute_applicable_impls<'tcx>(\n     );\n \n     let predicates =\n-        tcx.predicates_of(obligation.cause.body_id.owner.to_def_id()).instantiate_identity(tcx);\n+        tcx.predicates_of(obligation.cause.body_id.to_def_id()).instantiate_identity(tcx);\n     for obligation in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n         let kind = obligation.predicate.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = kind.skip_binder()"}, {"sha": "aaeb3def06ac3d79b706ec2091071d4aaabfcbd4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -839,14 +839,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             err.note(s.as_str());\n                         }\n                         if let Some(ref s) = parent_label {\n-                            let body = tcx\n-                                .hir()\n-                                .opt_local_def_id(obligation.cause.body_id)\n-                                .unwrap_or_else(|| {\n-                                    tcx.hir().body_owner_def_id(hir::BodyId {\n-                                        hir_id: obligation.cause.body_id,\n-                                    })\n-                                });\n+                            let body = obligation.cause.body_id;\n                             err.span_label(tcx.def_span(body), s);\n                         }\n \n@@ -934,6 +927,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n+                        let body_hir_id =\n+                            self.tcx.hir().local_def_id_to_hir_id(obligation.cause.body_id);\n                         // Try to report a help message\n                         if is_fn_trait\n                             && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n@@ -1014,7 +1009,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             if !self.report_similar_impl_candidates(\n                                 impl_candidates,\n                                 trait_ref,\n-                                obligation.cause.body_id,\n+                                body_hir_id,\n                                 &mut err,\n                                 true,\n                             ) {\n@@ -1050,7 +1045,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                     self.report_similar_impl_candidates(\n                                         impl_candidates,\n                                         trait_ref,\n-                                        obligation.cause.body_id,\n+                                        body_hir_id,\n                                         &mut err,\n                                         true,\n                                     );\n@@ -2305,10 +2300,12 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 predicate.to_opt_poly_trait_pred().unwrap(),\n                             );\n                             if impl_candidates.len() < 10 {\n+                                let hir =\n+                                    self.tcx.hir().local_def_id_to_hir_id(obligation.cause.body_id);\n                                 self.report_similar_impl_candidates(\n                                     impl_candidates,\n                                     trait_ref,\n-                                    body_id.map(|id| id.hir_id).unwrap_or(obligation.cause.body_id),\n+                                    body_id.map(|id| id.hir_id).unwrap_or(hir),\n                                     &mut err,\n                                     false,\n                                 );"}, {"sha": "a3209d35e58be577186af66ae55e9ccde446603e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -149,10 +149,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .unwrap_or_else(|| (trait_ref.def_id(), trait_ref.skip_binder().substs));\n         let trait_ref = trait_ref.skip_binder();\n \n-        let mut flags = vec![(\n-            sym::ItemContext,\n-            self.describe_enclosure(obligation.cause.body_id).map(|s| s.to_owned()),\n-        )];\n+        let body_hir = self.tcx.hir().local_def_id_to_hir_id(obligation.cause.body_id);\n+        let mut flags =\n+            vec![(sym::ItemContext, self.describe_enclosure(body_hir).map(|s| s.to_owned()))];\n \n         match obligation.cause.code() {\n             ObligationCauseCode::BuiltinDerivedObligation(..)"}, {"sha": "bf5e77e6ce12fe4298f16970dd10ed4a41a2e4c4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -9,7 +9,6 @@ use crate::infer::InferCtxt;\n use crate::traits::{NormalizeExt, ObligationCtxt};\n \n use hir::def::CtorOf;\n-use hir::{Expr, HirId};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n@@ -22,6 +21,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n+use rustc_hir::{Expr, HirId};\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{InferOk, LateBoundRegionConversionTime};\n@@ -34,6 +34,7 @@ use rustc_middle::ty::{\n     IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n     TypeSuperFoldable, TypeVisitable, TypeckResults,\n };\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, MacroKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n@@ -179,7 +180,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         associated_item: Option<(&'static str, Ty<'tcx>)>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n     );\n \n     fn suggest_dereferences(\n@@ -522,7 +523,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         mut err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         associated_ty: Option<(&'static str, Ty<'tcx>)>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n     ) {\n         let trait_pred = self.resolve_numeric_literals_with_default(trait_pred);\n \n@@ -535,8 +536,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n         //        don't suggest `T: Sized + ?Sized`.\n-        let mut hir_id = body_id;\n-        while let Some(node) = self.tcx.hir().find(hir_id) {\n+        let mut body_id = body_id;\n+        while let Some(node) = self.tcx.hir().find_by_def_id(body_id) {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(body_id);\n             match node {\n                 hir::Node::Item(hir::Item {\n                     ident,\n@@ -713,8 +715,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                 _ => {}\n             }\n-\n-            hir_id = self.tcx.hir().get_parent_item(hir_id).into();\n+            body_id = self.tcx.local_parent(body_id);\n         }\n     }\n \n@@ -905,8 +906,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             trait_pred.self_ty(),\n         );\n \n+        let body_hir_id = self.tcx.hir().local_def_id_to_hir_id(obligation.cause.body_id);\n         let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(\n-            obligation.cause.body_id,\n+            body_hir_id,\n             obligation.param_env,\n             self_ty,\n         ) else { return false; };\n@@ -1004,8 +1006,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             span.remove_mark();\n         }\n         let mut expr_finder = FindExprBySpan::new(span);\n-        let Some(hir::Node::Expr(body)) = self.tcx.hir().find(obligation.cause.body_id) else { return; };\n-        expr_finder.visit_expr(&body);\n+        let Some(body_id) = self.tcx.hir().maybe_body_owned_by(obligation.cause.body_id) else { return; };\n+        let body = self.tcx.hir().body(body_id);\n+        expr_finder.visit_expr(body.value);\n         let Some(expr) = expr_finder.result else { return; };\n         let Some(typeck) = &self.typeck_results else { return; };\n         let Some(ty) = typeck.expr_ty_adjusted_opt(expr) else { return; };\n@@ -1060,8 +1063,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     ) -> bool {\n         let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n         let ty = self.tcx.erase_late_bound_regions(self_ty);\n-        let owner = self.tcx.hir().get_parent_item(obligation.cause.body_id);\n-        let Some(generics) = self.tcx.hir().get_generics(owner.def_id) else { return false };\n+        let Some(generics) = self.tcx.hir().get_generics(obligation.cause.body_id) else { return false };\n         let ty::Ref(_, inner_ty, hir::Mutability::Not) = ty.kind() else { return false };\n         let ty::Param(param) = inner_ty.kind() else { return false };\n         let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code() else { return false };\n@@ -1104,6 +1106,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     /// Extracts information about a callable type for diagnostics. This is a\n     /// heuristic -- it doesn't necessarily mean that a type is always callable,\n     /// because the callable type must also be well-formed to be called.\n+    // FIXME(vincenzopalazzo): move the HirId to a LocalDefId\n     fn extract_callable_info(\n         &self,\n         hir_id: HirId,\n@@ -1429,10 +1432,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             span.remove_mark();\n         }\n         let mut expr_finder = super::FindExprBySpan::new(span);\n-        let Some(hir::Node::Expr(body)) = self.tcx.hir().find(obligation.cause.body_id) else {\n+        let Some(body_id) = self.tcx.hir().maybe_body_owned_by(obligation.cause.body_id) else {\n             return false;\n         };\n-        expr_finder.visit_expr(&body);\n+        let body = self.tcx.hir().body(body_id);\n+        expr_finder.visit_expr(body.value);\n         let mut maybe_suggest = |suggested_ty, count, suggestions| {\n             // Remapping bound vars here\n             let trait_pred_and_suggested_ty =\n@@ -1670,8 +1674,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         let hir = self.tcx.hir();\n-        let parent_node = hir.parent_id(obligation.cause.body_id);\n-        let node = hir.find(parent_node);\n+        let node = hir.find_by_def_id(obligation.cause.body_id);\n         if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. })) = node\n             && let hir::ExprKind::Block(blk, _) = &hir.body(*body_id).value.kind\n             && sig.decl.output.span().overlaps(span)\n@@ -1707,8 +1710,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span> {\n         let hir = self.tcx.hir();\n-        let parent_node = hir.parent_id(obligation.cause.body_id);\n-        let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, ..), .. })) = hir.find(parent_node) else {\n+        let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, ..), .. })) = hir.find_by_def_id(obligation.cause.body_id) else {\n             return None;\n         };\n \n@@ -1732,8 +1734,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-        let fn_hir_id = hir.parent_id(obligation.cause.body_id);\n-        let node = hir.find(fn_hir_id);\n+        let fn_hir_id = hir.local_def_id_to_hir_id(obligation.cause.body_id);\n+        let node = hir.find_by_def_id(obligation.cause.body_id);\n         let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(sig, _, body_id),\n             ..\n@@ -1806,7 +1808,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         match liberated_sig.output().kind() {\n             ty::Dynamic(predicates, _, ty::Dyn) => {\n-                let cause = ObligationCause::misc(ret_ty.span, fn_hir_id);\n+                let cause = ObligationCause::misc(ret_ty.span, obligation.cause.body_id);\n                 let param_env = ty::ParamEnv::empty();\n \n                 if !only_never_return {\n@@ -1944,8 +1946,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-        let parent_node = hir.parent_id(obligation.cause.body_id);\n-        let node = hir.find(parent_node);\n+        let node = hir.find_by_def_id(obligation.cause.body_id);\n         if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) =\n             node\n         {\n@@ -3283,12 +3284,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n     ) {\n-        let body_hir_id = obligation.cause.body_id;\n-        let item_id = self.tcx.hir().parent_id(body_hir_id);\n-\n-        if let Some(body_id) =\n-            self.tcx.hir().maybe_body_owned_by(self.tcx.hir().local_def_id(item_id))\n-        {\n+        if let Some(body_id) = self.tcx.hir().maybe_body_owned_by(obligation.cause.body_id) {\n             let body = self.tcx.hir().body(body_id);\n             if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n                 let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n@@ -3727,9 +3723,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     term: ty_var.into(),\n                 },\n             )));\n+            let body_def_id = self.tcx.hir().enclosing_body_owner(body_id);\n             // Add `<ExprTy as Iterator>::Item = _` obligation.\n             ocx.register_obligation(Obligation::misc(\n-                self.tcx, span, body_id, param_env, projection,\n+                self.tcx,\n+                span,\n+                body_def_id,\n+                param_env,\n+                projection,\n             ));\n             if ocx.select_where_possible().is_empty() {\n                 // `ty_var` now holds the type that `Item` is for `ExprTy`."}, {"sha": "83458017e00f00b7cabdc6871aedbdf492d0f130", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -26,12 +26,11 @@ use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorGuaranteed;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n+use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n use rustc_span::Span;\n \n use std::fmt::Debug;\n@@ -151,7 +150,7 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n         // anyhow).\n-        cause: ObligationCause::misc(span, hir::CRATE_HIR_ID),\n+        cause: ObligationCause::misc(span, CRATE_DEF_ID),\n         recursion_depth: 0,\n         predicate: pred.to_predicate(infcx.tcx),\n     };\n@@ -166,14 +165,12 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n         // that guess. While imperfect, I believe this is sound.\n \n         // FIXME(@lcnr): this function doesn't seem right.\n+        //\n         // The handling of regions in this area of the code is terrible,\n         // see issue #29149. We should be able to improve on this with\n         // NLL.\n         let errors = fully_solve_obligation(infcx, obligation);\n \n-        // Note: we only assume something is `Copy` if we can\n-        // *definitively* show that it implements `Copy`. Otherwise,\n-        // assume it is move; linear is always ok.\n         match &errors[..] {\n             [] => true,\n             errors => {"}, {"sha": "6cb64ad574f5be191db9341065d1245b3b306c16", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -3,9 +3,8 @@ use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n use crate::traits::ObligationCause;\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_hir as hir;\n-use rustc_hir::HirId;\n use rustc_middle::ty::{self, ParamEnv, Ty};\n+use rustc_span::def_id::LocalDefId;\n \n pub use rustc_middle::traits::query::OutlivesBound;\n \n@@ -14,14 +13,14 @@ pub trait InferCtxtExt<'a, 'tcx> {\n     fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n         ty: Ty<'tcx>,\n     ) -> Vec<OutlivesBound<'tcx>>;\n \n     fn implied_bounds_tys(\n         &'a self,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n         tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx>;\n }\n@@ -50,10 +49,10 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n     fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n         ty: Ty<'tcx>,\n     ) -> Vec<OutlivesBound<'tcx>> {\n-        let span = self.tcx.hir().span(body_id);\n+        let span = self.tcx.def_span(body_id);\n         let result = param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n             .fully_perform(self);\n@@ -102,7 +101,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n     fn implied_bounds_tys(\n         &'a self,\n         param_env: ParamEnv<'tcx>,\n-        body_id: HirId,\n+        body_id: LocalDefId,\n         tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx> {\n         tys.into_iter()"}, {"sha": "d9556848099f122ead5b1a3079d41b0a4fd7f8f1", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -1,10 +1,10 @@\n use crate::infer::InferCtxt;\n use crate::traits;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n use std::iter;\n@@ -17,7 +17,7 @@ use std::iter;\n pub fn obligations<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n     recursion_depth: usize,\n     arg: GenericArg<'tcx>,\n     span: Span,\n@@ -82,7 +82,7 @@ pub fn obligations<'tcx>(\n pub fn trait_obligations<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n     trait_pred: &ty::TraitPredicate<'tcx>,\n     span: Span,\n     item: &'tcx hir::Item<'tcx>,\n@@ -105,7 +105,7 @@ pub fn trait_obligations<'tcx>(\n pub fn predicate_obligations<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n     predicate: ty::Predicate<'tcx>,\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n@@ -167,7 +167,7 @@ pub fn predicate_obligations<'tcx>(\n struct WfPredicates<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n     recursion_depth: usize,"}, {"sha": "fe633d687d91baff202ec6364841dbcd1888d19e", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -2,13 +2,13 @@\n //! Do not call this query directory. See\n //! [`rustc_trait_selection::traits::query::type_op::implied_outlives_bounds`].\n \n-use rustc_hir as hir;\n use rustc_infer::infer::canonical::{self, Canonical};\n use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::query::OutlivesBound;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n@@ -67,9 +67,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n         // bounds can be backward incompatible, e.g. #101951 was caused by\n         // us not dealing with inference vars in `TypeOutlives` predicates.\n-        let obligations =\n-            wf::obligations(ocx.infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n-                .unwrap_or_default();\n+        let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n+            .unwrap_or_default();\n \n         // While these predicates should all be implied by other parts of\n         // the program, they are still relevant as they may constrain"}, {"sha": "27dc16259926bdba9b1c044781edfcf567e3c4b0", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{ParamEnvAnd, Predicate};\n use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};\n+use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n@@ -76,7 +77,6 @@ fn relate_mir_and_user_ty<'tcx>(\n     // FIXME(#104764): We should check well-formedness before normalization.\n     let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n     ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n-\n     Ok(())\n }\n \n@@ -111,7 +111,7 @@ fn relate_mir_and_user_substs<'tcx>(\n         let span = if span == DUMMY_SP { predicate_span } else { span };\n         let cause = ObligationCause::new(\n             span,\n-            hir::CRATE_HIR_ID,\n+            CRATE_DEF_ID,\n             ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n         );\n         let instantiated_predicate =\n@@ -126,7 +126,6 @@ fn relate_mir_and_user_substs<'tcx>(\n         let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n \n         ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n-\n         let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n         ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n     }"}, {"sha": "13a76648690165bad418ae07618afcb7dd76e5d9", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n use rustc_session::config::TraitSolver;\n+use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n@@ -208,14 +208,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n         constness,\n     );\n \n-    let body_id =\n-        local_did.and_then(|id| tcx.hir().maybe_body_owned_by(id).map(|body| body.hir_id));\n-    let body_id = match body_id {\n-        Some(id) => id,\n-        None if hir_id.is_some() => hir_id.unwrap(),\n-        _ => hir::CRATE_HIR_ID,\n-    };\n-\n+    let body_id = local_did.unwrap_or(CRATE_DEF_ID);\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n }"}, {"sha": "2a79b18b829941c4a218843a84a135fc8b83a0ae", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -78,7 +78,8 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                 let send_trait = cx.tcx.get_diagnostic_item(sym::Send).unwrap();\n                 let span = decl.output.span();\n                 let infcx = cx.tcx.infer_ctxt().build();\n-                let cause = traits::ObligationCause::misc(span, hir_id);\n+                let def_id = cx.tcx.hir().local_def_id(hir_id);\n+                let cause = traits::ObligationCause::misc(span, def_id);\n                 let send_errors = traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait);\n                 if !send_errors.is_empty() {\n                     span_lint_and_then("}, {"sha": "b812e81cb107b35a217694df38a8fa3865889205", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -371,7 +371,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                 && let output_ty = return_ty(cx, item.hir_id())\n                 && let local_def_id = cx.tcx.hir().local_def_id(item.hir_id())\n                 && Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-                    let fn_ctxt = FnCtxt::new(inherited, cx.param_env, item.hir_id());\n+                    let fn_ctxt = FnCtxt::new(inherited, cx.param_env, local_def_id);\n                     fn_ctxt.can_coerce(ty, output_ty)\n                 }) {\n                     if has_lifetime(output_ty) && has_lifetime(ty) {"}, {"sha": "b59d52dfc4d313b9b2b8e99719aeb483ffc7bba2", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027c8507b4265dcf285b0b503e2a49214b929f7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027c8507b4265dcf285b0b503e2a49214b929f7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=027c8507b4265dcf285b0b503e2a49214b929f7b", "patch": "@@ -46,7 +46,7 @@ fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>\n     let local_def_id = hir_id.owner.def_id;\n \n     Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(inherited, cx.param_env, hir_id);\n+        let fn_ctxt = FnCtxt::new(inherited, cx.param_env, local_def_id);\n \n         // If we already have errors, we can't be sure we can pointer cast.\n         assert!("}]}