{"sha": "e09b62033926dff8bfedca35b93e0dfbf767749f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOWI2MjAzMzkyNmRmZjhiZmVkY2EzNWI5M2UwZGZiZjc2Nzc0OWY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-06-16T08:37:34Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-06-19T16:13:41Z"}, "message": "Add fuzzy pointer comparison intrinsics", "tree": {"sha": "b7002d10c8dce99dfd2ac5551f057bdd982db090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7002d10c8dce99dfd2ac5551f057bdd982db090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e09b62033926dff8bfedca35b93e0dfbf767749f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e09b62033926dff8bfedca35b93e0dfbf767749f", "html_url": "https://github.com/rust-lang/rust/commit/e09b62033926dff8bfedca35b93e0dfbf767749f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e09b62033926dff8bfedca35b93e0dfbf767749f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9245ba83047b14fc7c9cef4c7d2bf37828c445b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9245ba83047b14fc7c9cef4c7d2bf37828c445b6", "html_url": "https://github.com/rust-lang/rust/commit/9245ba83047b14fc7c9cef4c7d2bf37828c445b6"}], "stats": {"total": 282, "additions": 260, "deletions": 22}, "files": [{"sha": "4648f762bab4219aaf3b5d2107b0677963c59578", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -1948,6 +1948,16 @@ extern \"rust-intrinsic\" {\n     #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n     pub fn count_code_region(index: u32);\n+\n+    /// See documentation of `<*const T>::guaranteed_eq` for details.\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;\n+\n+    /// See documentation of `<*const T>::guaranteed_ne` for details.\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "b2f6f789603a9386c5fe8591e6136cbb7d46e998", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -87,6 +87,7 @@\n #![feature(const_generics)]\n #![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n+#![cfg_attr(not(bootstrap), feature(const_raw_ptr_comparison))]\n #![feature(const_result)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_slice_ptr_len)]"}, {"sha": "0e2e6848416b668d78971589b3685561dce173b3", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -295,6 +295,72 @@ impl<T: ?Sized> *const T {\n         intrinsics::ptr_offset_from(self, origin)\n     }\n \n+    /// Returns whether two pointers are guaranteed equal.\n+    ///\n+    /// At runtime this function behaves like `self == other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine equality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be equal.\n+    /// But when it returns `true`, the pointers are guaranteed to be equal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_ne`]: #method.guaranteed_ne\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const fn guaranteed_eq(self, other: *const T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_eq(self, other)\n+    }\n+\n+    /// Returns whether two pointers are guaranteed not equal.\n+    ///\n+    /// At runtime this function behaves like `self != other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine the inequality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_eq`]: #method.guaranteed_eq\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const fn guaranteed_ne(self, other: *const T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_ne(self, other)\n+    }\n+\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///"}, {"sha": "67ace1f72a0ab0e6b28c9bf175b2ae2218348361", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -273,6 +273,72 @@ impl<T: ?Sized> *mut T {\n         if self.is_null() { None } else { Some(&mut *self) }\n     }\n \n+    /// Returns whether two pointers are guaranteed equal.\n+    ///\n+    /// At runtime this function behaves like `self == other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine equality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be equal.\n+    /// But when it returns `true`, the pointers are guaranteed to be equal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_ne`]: #method.guaranteed_ne\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const fn guaranteed_eq(self, other: *mut T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_eq(self as *const _, other as *const _)\n+    }\n+\n+    /// Returns whether two pointers are guaranteed not equal.\n+    ///\n+    /// At runtime this function behaves like `self != other`.\n+    /// However, in some contexts (e.g., compile-time evaluation),\n+    /// it is not always possible to determine the inequality of two pointers, so this function may\n+    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    ///\n+    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n+    /// comparisons for which both functions return `false`.\n+    ///\n+    /// [`guaranteed_eq`]: #method.guaranteed_eq\n+    ///\n+    /// The return value may change depending on the compiler version and unsafe code may not\n+    /// rely on the result of this function for soundness. It is suggested to only use this function\n+    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// affect the outcome, but just the performance.\n+    /// The consequences of using this method to make runtime and compile-time code behave\n+    /// differently have not been explored. This method should not be used to introduce such\n+    /// differences, and it should also not be stabilized before we have a better understanding\n+    /// of this issue.\n+    /// ```\n+    #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub const unsafe fn guaranteed_ne(self, other: *mut T) -> bool\n+    where\n+        T: Sized,\n+    {\n+        intrinsics::ptr_guaranteed_ne(self as *const _, other as *const _)\n+    }\n+\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///"}, {"sha": "12932b06d32d4fd07042f947b79ed0cef6e92894", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -5946,7 +5946,8 @@ where\n     }\n }\n \n-// Use an equal-pointer optimization when types are `Eq`\n+// Remove after boostrap bump\n+#[cfg(bootstrap)]\n impl<A> SlicePartialEq<A> for [A]\n where\n     A: PartialEq<A> + Eq,\n@@ -5964,7 +5965,8 @@ where\n     }\n }\n \n-// Use memcmp for bytewise equality when the types allow\n+// Remove after boostrap bump\n+#[cfg(bootstrap)]\n impl<A> SlicePartialEq<A> for [A]\n where\n     A: PartialEq<A> + BytewiseEquality,\n@@ -5983,6 +5985,50 @@ where\n     }\n }\n \n+// Use an equal-pointer optimization when types are `Eq`\n+#[cfg(not(bootstrap))]\n+impl<A> SlicePartialEq<A> for [A]\n+where\n+    A: PartialEq<A> + Eq,\n+{\n+    default fn equal(&self, other: &[A]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        // While performance would suffer if `guaranteed_eq` just returned `false`\n+        // for all arguments, correctness and return value of this function are not affected.\n+        if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n+            return true;\n+        }\n+\n+        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n+    }\n+}\n+\n+// Use memcmp for bytewise equality when the types allow\n+#[cfg(not(bootstrap))]\n+impl<A> SlicePartialEq<A> for [A]\n+where\n+    A: PartialEq<A> + BytewiseEquality,\n+{\n+    fn equal(&self, other: &[A]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        // While performance would suffer if `guaranteed_eq` just returned `false`\n+        // for all arguments, correctness and return value of this function are not affected.\n+        if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n+            return true;\n+        }\n+        unsafe {\n+            let size = mem::size_of_val(self);\n+            memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n+        }\n+    }\n+}\n+\n #[doc(hidden)]\n // intermediate trait for specialization of slice's PartialOrd\n trait SlicePartialOrd: Sized {"}, {"sha": "78c29588e2e1b71e8e7ad56d07d8c4ecbc884d5f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -12,7 +12,7 @@ use log::debug;\n use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n-use rustc_codegen_ssa::common::TypeKind;\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n@@ -731,6 +731,18 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 return;\n             }\n \n+            \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" => {\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                let a = self.ptrtoint(a, self.type_isize());\n+                let b = self.ptrtoint(b, self.type_isize());\n+                if name == \"ptr_guaranteed_eq\" {\n+                    self.icmp(IntPredicate::IntEQ, a, b)\n+                } else {\n+                    self.icmp(IntPredicate::IntNE, a, b)\n+                }\n+            }\n+\n             \"ptr_offset_from\" => {\n                 let ty = substs.type_at(0);\n                 let pointee_size = self.size_of(ty);"}, {"sha": "1b4113a61b451d3d743725116f44202cf4e5da0c", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -291,6 +291,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let offset_ptr = ptr.ptr_wrapping_signed_offset(offset_bytes, self);\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+                // FIXME: return `true` for at least some comparisons where we can reliably\n+                // determine the result of runtime (in)equality tests at compile-time.\n+                self.write_scalar(Scalar::from_bool(false), dest)?;\n+            }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;"}, {"sha": "9f005c0b4dda877574d09f5563881219888acf92", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -290,17 +290,23 @@ impl NonConstOp for RawPtrComparison {\n             \"pointers cannot be compared in a meaningful way during const eval.\",\n         );\n         err.note(\n-            \"It is conceptually impossible for const eval to know in all cases whether two \\\n-             pointers are equal. While sometimes it is clear (the address of a static item \\\n-             is never equal to the address of another static item), comparing an integer \\\n-             address with any allocation's address is impossible to do at compile-time.\",\n+            \"see issue #53020 <https://github.com/rust-lang/rust/issues/53020> \\\n+            for more information\",\n         );\n         err.note(\n-            \"That said, there's the `ptr_maybe_eq` intrinsic which returns `true` for all \\\n-             comparisons where CTFE isn't sure whether two addresses are equal. The mirror \\\n-             intrinsic `ptr_maybe_ne` returns `true` for all comparisons where CTFE isn't \\\n-             sure whether two addresses are inequal.\",\n+            \"It is conceptually impossible for const eval to know in all cases whether two \\\n+             pointers are equal. While sometimes it is clear (the address of a non-zst static item \\\n+             is never equal to the address of another non-zst static item), comparing an integer \\\n+             address with any allocation's address is impossible to do at compile-time.\",\n         );\n+        if ccx.tcx.sess.parse_sess.unstable_features.is_nightly_build() {\n+            err.note(\n+                \"That said, there's the `<*const T>::guaranteed_eq` intrinsic which returns `true` \\\n+                for all comparisons where CTFE is sure that two addresses are equal. The mirror \\\n+                intrinsic `<*const T>::guaranteed_ne` returns `true` for all comparisons where \\\n+                CTFE is sure that two addresses are inequal.\",\n+            );\n+        }\n         err.emit();\n     }\n }"}, {"sha": "06d1f36622b94ef101b913a73f293c9c5793b1b7", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -588,6 +588,8 @@ symbols! {\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n         profiler_runtime,\n+        ptr_guaranteed_eq,\n+        ptr_guaranteed_ne,\n         ptr_offset_from,\n         pub_restricted,\n         pure,"}, {"sha": "ef6c7c14404a7239b9bf5b840e7f37f67ed5c66d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -74,9 +74,8 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n         | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" | \"saturating_add\"\n         | \"saturating_sub\" | \"rotate_left\" | \"rotate_right\" | \"ctpop\" | \"ctlz\" | \"cttz\"\n         | \"bswap\" | \"bitreverse\" | \"discriminant_value\" | \"type_id\" | \"likely\" | \"unlikely\"\n-        | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\" | \"maxnumf64\" | \"type_name\" => {\n-            hir::Unsafety::Normal\n-        }\n+        | \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\"\n+        | \"maxnumf64\" | \"type_name\" => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }\n }\n@@ -258,6 +257,10 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 (1, vec![param(0), param(0)], tcx.intern_tup(&[param(0), tcx.types.bool]))\n             }\n \n+            \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" => {\n+                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.bool)\n+            }\n+\n             \"ptr_offset_from\" => {\n                 (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.isize)\n             }"}, {"sha": "6f27ac74ade83065e0d5fa4bbe05f2a7673e9d17", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -4,17 +4,19 @@ error: pointers cannot be compared in a meaningful way during const eval.\n LL | const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 };\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a static item is never equal to the address of another static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n-   = note: That said, there's the `ptr_maybe_eq` intrinsic which returns `true` for all comparisons where CTFE isn't sure whether two addresses are equal. The mirror intrinsic `ptr_maybe_ne` returns `true` for all comparisons where CTFE isn't sure whether two addresses are inequal.\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n+   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a non-zst static item is never equal to the address of another non-zst static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n+   = note: That said, there's the `<*const T>::guaranteed_eq` intrinsic which returns `true` for all comparisons where CTFE is sure that two addresses are equal. The mirror intrinsic `<*const T>::guaranteed_ne` returns `true` for all comparisons where CTFE is sure that two addresses are inequal.\n \n error: pointers cannot be compared in a meaningful way during const eval.\n   --> $DIR/const_raw_ptr_ops.rs:6:27\n    |\n LL | const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a static item is never equal to the address of another static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n-   = note: That said, there's the `ptr_maybe_eq` intrinsic which returns `true` for all comparisons where CTFE isn't sure whether two addresses are equal. The mirror intrinsic `ptr_maybe_ne` returns `true` for all comparisons where CTFE isn't sure whether two addresses are inequal.\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n+   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a non-zst static item is never equal to the address of another non-zst static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n+   = note: That said, there's the `<*const T>::guaranteed_eq` intrinsic which returns `true` for all comparisons where CTFE is sure that two addresses are equal. The mirror intrinsic `<*const T>::guaranteed_ne` returns `true` for all comparisons where CTFE is sure that two addresses are inequal.\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fd843105daf2a8a3a819a905e49354446536d7ba", "filename": "src/test/ui/consts/miri_unleashed/slice_eq.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+// run-pass\n+\n+#![feature(const_raw_ptr_comparison)]\n+\n+const EMPTY_SLICE: &[i32] = &[];\n+const EMPTY_EQ: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[] as *const _);\n+const EMPTY_EQ2: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[] as *const _);\n+const EMPTY_NE: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[1] as *const _);\n+const EMPTY_NE2: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[1] as *const _);\n+\n+fn main() {\n+    assert!(!EMPTY_EQ);\n+    assert!(!EMPTY_EQ2);\n+    assert!(!EMPTY_NE);\n+    assert!(!EMPTY_NE2);\n+}"}, {"sha": "62949cf15e13ccb6cdd9eca5f23f070bca2423f9", "filename": "src/test/ui/error-codes/E0395.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Ferror-codes%2FE0395.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Ferror-codes%2FE0395.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0395.stderr?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -4,8 +4,9 @@ error: pointers cannot be compared in a meaningful way during const eval.\n LL | static BAZ: bool = unsafe { (&FOO as *const i32) == (&BAR as *const i32) };\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a static item is never equal to the address of another static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n-   = note: That said, there's the `ptr_maybe_eq` intrinsic which returns `true` for all comparisons where CTFE isn't sure whether two addresses are equal. The mirror intrinsic `ptr_maybe_ne` returns `true` for all comparisons where CTFE isn't sure whether two addresses are inequal.\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n+   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a non-zst static item is never equal to the address of another non-zst static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n+   = note: That said, there's the `<*const T>::guaranteed_eq` intrinsic which returns `true` for all comparisons where CTFE is sure that two addresses are equal. The mirror intrinsic `<*const T>::guaranteed_ne` returns `true` for all comparisons where CTFE is sure that two addresses are inequal.\n \n error: aborting due to previous error\n "}, {"sha": "cb24aede81a2c4b4056ad115b50c823c4862aff6", "filename": "src/test/ui/issues/issue-25826.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Fissues%2Fissue-25826.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e09b62033926dff8bfedca35b93e0dfbf767749f/src%2Ftest%2Fui%2Fissues%2Fissue-25826.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25826.stderr?ref=e09b62033926dff8bfedca35b93e0dfbf767749f", "patch": "@@ -4,8 +4,9 @@ error: pointers cannot be compared in a meaningful way during const eval.\n LL |     const A: bool = unsafe { id::<u8> as *const () < id::<u16> as *const () };\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a static item is never equal to the address of another static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n-   = note: That said, there's the `ptr_maybe_eq` intrinsic which returns `true` for all comparisons where CTFE isn't sure whether two addresses are equal. The mirror intrinsic `ptr_maybe_ne` returns `true` for all comparisons where CTFE isn't sure whether two addresses are inequal.\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n+   = note: It is conceptually impossible for const eval to know in all cases whether two pointers are equal. While sometimes it is clear (the address of a non-zst static item is never equal to the address of another non-zst static item), comparing an integer address with any allocation's address is impossible to do at compile-time.\n+   = note: That said, there's the `<*const T>::guaranteed_eq` intrinsic which returns `true` for all comparisons where CTFE is sure that two addresses are equal. The mirror intrinsic `<*const T>::guaranteed_ne` returns `true` for all comparisons where CTFE is sure that two addresses are inequal.\n \n error: aborting due to previous error\n "}]}