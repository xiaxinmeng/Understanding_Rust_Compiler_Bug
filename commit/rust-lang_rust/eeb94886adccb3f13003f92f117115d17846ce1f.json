{"sha": "eeb94886adccb3f13003f92f117115d17846ce1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjk0ODg2YWRjY2IzZjEzMDAzZjkyZjExNzExNWQxNzg0NmNlMWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-17T22:32:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T18:37:43Z"}, "message": "std: Remove deprecated/unstable num functionality\n\nThis commit removes all the old casting/generic traits from `std::num` that are\nno longer in use by the standard library. This additionally removes the old\n`strconv` module which has not seen much use in quite a long time. All generic\nfunctionality has been supplanted with traits in the `num` crate and the\n`strconv` module is supplanted with the [rust-strconv crate][rust-strconv].\n\n[rust-strconv]: https://github.com/lifthrasiir/rust-strconv\n\nThis is a breaking change due to the removal of these deprecated crates, and the\nalternative crates are listed above.\n\n[breaking-change]", "tree": {"sha": "2d729b8e48c5022941e2c06e412a2b2a1744ca1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d729b8e48c5022941e2c06e412a2b2a1744ca1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb94886adccb3f13003f92f117115d17846ce1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb94886adccb3f13003f92f117115d17846ce1f", "html_url": "https://github.com/rust-lang/rust/commit/eeb94886adccb3f13003f92f117115d17846ce1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb94886adccb3f13003f92f117115d17846ce1f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e091ba3f3e8b2b00827ab4934314829b33ffb966", "url": "https://api.github.com/repos/rust-lang/rust/commits/e091ba3f3e8b2b00827ab4934314829b33ffb966", "html_url": "https://github.com/rust-lang/rust/commit/e091ba3f3e8b2b00827ab4934314829b33ffb966"}], "stats": {"total": 6222, "additions": 623, "deletions": 5599}, "files": [{"sha": "07b99402cd2c31c3b0a45be5673a0ae2d66d39ac", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -1058,14 +1058,6 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n-#[allow(deprecated)]\n-impl<'a> Str for Cow<'a, str> {\n-    #[inline]\n-    fn as_slice<'b>(&'b self) -> &'b str {\n-        &**self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "4b75bd5f67e3d94fd7d07b23a19c4567e0ade186", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -11,15 +11,15 @@\n pub use self::ExponentFormat::*;\n pub use self::SignificantDigits::*;\n \n-use char::{self, CharExt};\n+use prelude::*;\n+\n+use char;\n use fmt;\n-use iter::Iterator;\n-use num::{cast, Float, ToPrimitive};\n+use num::Float;\n use num::FpCategory as Fp;\n-use ops::FnOnce;\n-use result::Result::Ok;\n-use slice::{self, SliceExt};\n-use str::{self, StrExt};\n+use ops::{Div, Rem, Mul};\n+use slice;\n+use str;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n@@ -42,6 +42,21 @@ pub enum SignificantDigits {\n     DigExact(usize)\n }\n \n+#[doc(hidden)]\n+pub trait MyFloat: Float + PartialEq + PartialOrd + Div<Output=Self> +\n+                   Mul<Output=Self> + Rem<Output=Self> + Copy {\n+    fn from_u32(u: u32) -> Self;\n+    fn to_i32(&self) -> i32;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl MyFloat for $t {\n+        fn from_u32(u: u32) -> $t { u as $t }\n+        fn to_i32(&self) -> i32 { *self as i32 }\n+    })*)\n+}\n+doit! { f32 f64 }\n+\n /// Converts a float number to its string representation.\n /// This is meant to be a common base implementation for various formatting styles.\n /// The number is assumed to be non-negative, callers use `Formatter::pad_integral`\n@@ -63,7 +78,7 @@ pub enum SignificantDigits {\n /// # Panics\n ///\n /// - Panics if `num` is negative.\n-pub fn float_to_str_bytes_common<T: Float, U, F>(\n+pub fn float_to_str_bytes_common<T: MyFloat, U, F>(\n     num: T,\n     digits: SignificantDigits,\n     exp_format: ExponentFormat,\n@@ -72,10 +87,10 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n ) -> U where\n     F: FnOnce(&str) -> U,\n {\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n+    let _0: T = T::zero();\n+    let _1: T = T::one();\n     let radix: u32 = 10;\n-    let radix_f: T = cast(radix).unwrap();\n+    let radix_f = T::from_u32(radix);\n \n     assert!(num.is_nan() || num >= _0, \"float_to_str_bytes_common: number is negative\");\n \n@@ -99,7 +114,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     let (num, exp) = match exp_format {\n         ExpDec if num != _0 => {\n             let exp = num.log10().floor();\n-            (num / radix_f.powf(exp), cast::<T, i32>(exp).unwrap())\n+            (num / radix_f.powf(exp), exp.to_i32())\n         }\n         _ => (num, 0)\n     };\n@@ -114,7 +129,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         deccum = deccum / radix_f;\n         deccum = deccum.trunc();\n \n-        let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n+        let c = char::from_digit(current_digit.to_i32() as u32, radix);\n         buf[end] = c.unwrap() as u8;\n         end += 1;\n \n@@ -158,7 +173,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             let current_digit = deccum.trunc();\n \n-            let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n+            let c = char::from_digit(current_digit.to_i32() as u32, radix);\n             buf[end] = c.unwrap() as u8;\n             end += 1;\n "}, {"sha": "5cff0186f25064f60bc4eb78b9af68f5cb45eba4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -12,21 +12,16 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n-use char::CharExt;\n-use clone::Clone;\n-use iter::Iterator;\n-use marker::{Copy, PhantomData, Sized};\n+use marker::PhantomData;\n use mem;\n-use num::Float;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::Ok;\n-use ops::{Deref, FnOnce};\n+use ops::Deref;\n use result;\n-use slice::SliceExt;\n+use num::Float;\n use slice;\n-use str::{self, StrExt};\n+use str;\n use self::rt::v1::Alignment;\n \n pub use self::num::radix;\n@@ -912,7 +907,8 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_str_common<T: Float, F>(num: &T, precision: Option<usize>, post: F) -> Result\n+fn float_to_str_common<T: float::MyFloat, F>(num: &T, precision: Option<usize>,\n+                                             post: F) -> Result\n         where F : FnOnce(&str) -> Result {\n     let digits = match precision {\n         Some(i) => float::DigExact(i),\n@@ -950,8 +946,6 @@ macro_rules! floating { ($ty:ident) => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::Float;\n-\n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n                 None => float::DigMax(6),\n@@ -969,8 +963,6 @@ macro_rules! floating { ($ty:ident) => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::Float;\n-\n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n                 None => float::DigMax(6),"}, {"sha": "122fffc5959056a99c3edbe3d97155ec878c0d66", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -14,12 +14,28 @@\n \n #![allow(unsigned_negation)]\n \n+use prelude::*;\n+\n use fmt;\n-use iter::Iterator;\n-use num::{Int, cast};\n-use slice::SliceExt;\n+use num::Zero;\n+use ops::{Div, Rem, Sub};\n use str;\n \n+#[doc(hidden)]\n+trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n+           Sub<Output=Self> + Copy {\n+    fn from_u8(u: u8) -> Self;\n+    fn to_u8(&self) -> u8;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl Int for $t {\n+        fn from_u8(u: u8) -> $t { u as $t }\n+        fn to_u8(&self) -> u8 { *self as u8 }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n /// A type that represents a specific radix\n #[doc(hidden)]\n trait GenericRadix {\n@@ -33,33 +49,32 @@ trait GenericRadix {\n     fn digit(&self, x: u8) -> u8;\n \n     /// Format an integer using the radix using a formatter.\n-    #[allow(deprecated)] // Int\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n         // The radix can be as low as 2, so we need a buffer of at least 64\n         // characters for a base 2 number.\n-        let zero = Int::zero();\n+        let zero = T::zero();\n         let is_positive = x >= zero;\n         let mut buf = [0; 64];\n         let mut curr = buf.len();\n-        let base = cast(self.base()).unwrap();\n+        let base = T::from_u8(self.base());\n         if is_positive {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n             for byte in buf.iter_mut().rev() {\n-                let n = x % base;                         // Get the current place value.\n-                x = x / base;                             // Deaccumulate the number.\n-                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                let n = x % base;              // Get the current place value.\n+                x = x / base;                  // Deaccumulate the number.\n+                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };                   // No more digits left to accumulate.\n+                if x == zero { break };        // No more digits left to accumulate.\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n             for byte in buf.iter_mut().rev() {\n-                let n = zero - (x % base);                // Get the current place value.\n-                x = x / base;                             // Deaccumulate the number.\n-                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                let n = zero - (x % base);     // Get the current place value.\n+                x = x / base;                  // Deaccumulate the number.\n+                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };                   // No more digits left to accumulate.\n+                if x == zero { break };        // No more digits left to accumulate.\n             }\n         }\n         let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };"}, {"sha": "651658e4d56ed656016554750ae76f98a0ffb21b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -64,7 +64,7 @@ use cmp::{Ord, PartialOrd, PartialEq};\n use default::Default;\n use marker;\n use mem;\n-use num::{Int, Zero, One};\n+use num::{Zero, One};\n use ops::{self, Add, Sub, FnMut, Mul, RangeFrom};\n use option::Option::{self, Some, None};\n use marker::Sized;\n@@ -2647,80 +2647,6 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     }\n }\n \n-/// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n-#[derive(Clone)]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-pub struct RangeStepInclusive<A> {\n-    state: A,\n-    stop: A,\n-    step: A,\n-    rev: bool,\n-    done: bool,\n-}\n-\n-/// Returns an iterator over the range [start, stop] by `step`.\n-///\n-/// It handles overflow by stopping.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::iter::range_step_inclusive;\n-///\n-/// for i in range_step_inclusive(0, 10, 2) {\n-///     println!(\"{}\", i);\n-/// }\n-/// ```\n-///\n-/// This prints:\n-///\n-/// ```text\n-/// 0\n-/// 2\n-/// 4\n-/// 6\n-/// 8\n-/// 10\n-/// ```\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n-    let rev = step < Int::zero();\n-    RangeStepInclusive {\n-        state: start,\n-        stop: stop,\n-        step: step,\n-        rev: rev,\n-        done: false,\n-    }\n-}\n-\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-impl<A: Int> Iterator for RangeStepInclusive<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        if !self.done && ((self.rev && self.state >= self.stop) ||\n-                          (!self.rev && self.state <= self.stop)) {\n-            let result = self.state;\n-            match self.state.checked_add(self.step) {\n-                Some(x) => self.state = x,\n-                None => self.done = true\n-            }\n-            Some(result)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "fdabdbc5ed4ce0c59c8d2853e662084247d7544c", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -35,7 +35,16 @@ use hash::Hasher;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub unsafe trait Send {\n+    // empty.\n+}\n+\n+/// Types able to be transferred across thread boundaries.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"send\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n+#[cfg(stage0)]\n pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n@@ -51,7 +60,17 @@ impl !Send for Managed { }\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n-#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub trait Sized {\n+    // Empty.\n+}\n+\n+/// Types with a constant size known at compile-time.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"sized\"]\n+#[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n+#[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n+#[cfg(stage0)]\n pub trait Sized : MarkerTrait {\n     // Empty.\n }\n@@ -199,13 +218,23 @@ pub trait Copy : Clone {\n /// the `sync` crate do ensure that any mutation cannot cause data\n /// races.  Hence these types are `Sync`.\n ///\n-/// Any types with interior mutability must also use the `std::cell::UnsafeCell` wrapper around the\n-/// value(s) which can be mutated when behind a `&` reference; not doing this is undefined\n-/// behaviour (for example, `transmute`-ing from `&T` to `&mut T` is illegal).\n+/// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n+/// wrapper around the value(s) which can be mutated when behind a `&`\n+/// reference; not doing this is undefined behaviour (for example,\n+/// `transmute`-ing from `&T` to `&mut T` is illegal).\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"sync\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n+pub unsafe trait Sync {\n+    // Empty\n+}\n+\n+/// dox\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n-#[allow(deprecated)]\n pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n@@ -272,42 +301,20 @@ macro_rules! impls{\n         )\n }\n \n-/// `MarkerTrait` is deprecated and no longer needed.\n+/// dox\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[allow(deprecated)]\n #[cfg(stage0)]\n pub trait MarkerTrait : PhantomFn<Self,Self> { }\n \n-/// `MarkerTrait` is deprecated and no longer needed.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[allow(deprecated)]\n-#[cfg(not(stage0))]\n-pub trait MarkerTrait { }\n-\n-#[allow(deprecated)]\n-impl<T:?Sized> MarkerTrait for T { }\n+#[cfg(stage0)]\n+impl<T: ?Sized> MarkerTrait for T {}\n \n-/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n+/// dox\n #[lang=\"phantom_fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n #[cfg(stage0)]\n pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n }\n \n-/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[cfg(not(stage0))]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n-}\n-\n-#[allow(deprecated)]\n-#[cfg(not(stage0))]\n-impl<A:?Sized,R:?Sized,T:?Sized> PhantomFn<A,R> for T { }\n-\n /// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n /// even though it does not. This allows you to inform the compiler about certain safety properties\n /// of your code.\n@@ -454,8 +461,14 @@ mod impls {\n #[rustc_reflect_like]\n #[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n #[allow(deprecated)]\n-pub trait Reflect : MarkerTrait {\n-}\n+#[cfg(not(stage0))]\n+pub trait Reflect {}\n+\n+/// dox\n+#[rustc_reflect_like]\n+#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+#[cfg(stage0)]\n+pub trait Reflect: MarkerTrait {}\n \n impl Reflect for .. { }\n "}, {"sha": "9ea44c39fe9c6382c6a27b441df0f0a028d62a36", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -10,12 +10,17 @@\n \n //! Exposes the NonZero lang item which provides optimization hints.\n \n-use marker::{Sized, MarkerTrait};\n+use marker::Sized;\n use ops::Deref;\n+#[cfg(stage0)] use marker::MarkerTrait;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-#[allow(deprecated)]\n-pub unsafe trait Zeroable : MarkerTrait {}\n+#[cfg(not(stage0))]\n+pub unsafe trait Zeroable {}\n+\n+/// Unsafe trait to indicate what types are usable with the NonZero struct\n+#[cfg(stage0)]\n+pub unsafe trait Zeroable: MarkerTrait {}\n \n unsafe impl<T:?Sized> Zeroable for *const T {}\n unsafe impl<T:?Sized> Zeroable for *mut T {}"}, {"sha": "a9afa5078d21f7e3eaa5ed9656bc77e46fbd92df", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -20,7 +20,6 @@ use intrinsics;\n use mem;\n use num::Float;\n use num::FpCategory as Fp;\n-use option::Option;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n@@ -33,19 +32,6 @@ pub const DIGITS: u32 = 6;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n-/// Smallest finite f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN`\")]\n-pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n-/// Smallest positive, normalized f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN_POSITIVE`\")]\n-pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n-/// Largest finite f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MAX`\")]\n-pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n-\n /// Smallest finite f32 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: f32 = -3.40282347e+38_f32;\n@@ -118,26 +104,14 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_SQRT_PI: f32 = 1.12837916709551257389615890312154517_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n-    pub const FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n-\n     /// sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const SQRT_2: f32 = 1.41421356237309504880168872420969808_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n-    pub const SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n-\n     /// 1.0/sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_SQRT_2: f32 = 0.707106781186547524400844362104849039_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n-    pub const FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n-\n     /// Euler's number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f32 = 2.71828182845904523536028747135266250_f32;\n@@ -218,56 +192,6 @@ impl Float for f32 {\n         }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f32>) -> usize { MANTISSA_DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f32>) -> usize { DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn epsilon() -> f32 { EPSILON }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f32>) -> isize { MIN_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f32>) -> isize { MAX_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f32>) -> isize { MIN_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f32>) -> isize { MAX_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f32 { MIN }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POSITIVE }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f32 { MAX }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u32 = unsafe { mem::transmute(self) };"}, {"sha": "fa9660a60e918f2b2d924bea4b45145b9108eb25", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -20,7 +20,6 @@ use intrinsics;\n use mem;\n use num::Float;\n use num::FpCategory as Fp;\n-use option::Option;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n@@ -33,19 +32,6 @@ pub const DIGITS: u32 = 15;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n-/// Smallest finite f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN`\")]\n-pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n-/// Smallest positive, normalized f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN_POSITIVE`\")]\n-pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n-/// Largest finite f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MAX`\")]\n-pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n-\n /// Smallest finite f64 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: f64 = -1.7976931348623157e+308_f64;\n@@ -118,26 +104,14 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_SQRT_PI: f64 = 1.12837916709551257389615890312154517_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n-    pub const FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n-\n     /// sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const SQRT_2: f64 = 1.41421356237309504880168872420969808_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n-    pub const SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n-\n     /// 1.0/sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_SQRT_2: f64 = 0.707106781186547524400844362104849039_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n-    pub const FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n-\n     /// Euler's number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n@@ -218,56 +192,6 @@ impl Float for f64 {\n         }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f64>) -> usize { MANTISSA_DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f64>) -> usize { DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn epsilon() -> f64 { EPSILON }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f64>) -> isize { MIN_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f64>) -> isize { MAX_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f64>) -> isize { MIN_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f64>) -> isize { MAX_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f64 { MIN }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POSITIVE }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f64 { MAX }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u64 = unsafe { mem::transmute(self) };"}, {"sha": "cd1ce1f45350954757d7f94236e0b3a3d11c9f7f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 103, "deletions": 1508, "changes": 1611, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -13,18 +13,15 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-use self::wrapping::{OverflowingOps, WrappingOps};\n+use self::wrapping::OverflowingOps;\n \n use char::CharExt;\n-use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord};\n+use cmp::{Eq, PartialOrd};\n use fmt;\n use intrinsics;\n use iter::Iterator;\n use marker::Copy;\n use mem::size_of;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n@@ -98,736 +95,20 @@ macro_rules! zero_one_impl_float {\n }\n zero_one_impl_float! { f32 f64 }\n \n-/// A built-in signed or unsigned integer.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n-#[allow(deprecated)]\n-pub trait Int\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd + Ord\n-    + PartialEq + Eq\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-    + Not<Output=Self>\n-    + BitAnd<Output=Self>\n-    + BitOr<Output=Self>\n-    + BitXor<Output=Self>\n-    + Shl<usize, Output=Self>\n-    + Shr<usize, Output=Self>\n-    + WrappingOps\n-    + OverflowingOps\n-{\n-    /// Returns the `0` value of this integer type.\n-    // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn zero() -> Self;\n-\n-    /// Returns the `1` value of this integer type.\n-    // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn one() -> Self;\n-\n-    /// Returns the smallest value that can be represented by this integer type.\n-    // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_value() -> Self;\n-\n-    /// Returns the largest value that can be represented by this integer type.\n-    // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn max_value() -> Self;\n-\n-    /// Returns the number of ones in the binary representation of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b01001100u8;\n-    ///\n-    /// assert_eq!(n.count_ones(), 3);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn count_ones(self) -> u32;\n-\n-    /// Returns the number of zeros in the binary representation of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b01001100u8;\n-    ///\n-    /// assert_eq!(n.count_zeros(), 5);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    #[inline]\n-    fn count_zeros(self) -> u32 {\n-        (!self).count_ones()\n-    }\n-\n-    /// Returns the number of leading zeros in the binary representation\n-    /// of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b0101000u16;\n-    ///\n-    /// assert_eq!(n.leading_zeros(), 10);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn leading_zeros(self) -> u32;\n-\n-    /// Returns the number of trailing zeros in the binary representation\n-    /// of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b0101000u16;\n-    ///\n-    /// assert_eq!(n.trailing_zeros(), 3);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn trailing_zeros(self) -> u32;\n-\n-    /// Shifts the bits to the left by a specified amount, `n`, wrapping\n-    /// the truncated bits to the end of the resulting integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0x3456789ABCDEF012u64;\n-    ///\n-    /// assert_eq!(n.rotate_left(12), m);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn rotate_left(self, n: u32) -> Self;\n-\n-    /// Shifts the bits to the right by a specified amount, `n`, wrapping\n-    /// the truncated bits to the beginning of the resulting integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xDEF0123456789ABCu64;\n-    ///\n-    /// assert_eq!(n.rotate_right(12), m);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn rotate_right(self, n: u32) -> Self;\n-\n-    /// Reverses the byte order of the integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xEFCDAB8967452301u64;\n-    ///\n-    /// assert_eq!(n.swap_bytes(), m);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn swap_bytes(self) -> Self;\n-\n-    /// Converts an integer from big endian to the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(Int::from_be(n), n)\n-    /// } else {\n-    ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn from_be(x: Self) -> Self {\n-        if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Converts an integer from little endian to the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(Int::from_le(n), n)\n-    /// } else {\n-    ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn from_le(x: Self) -> Self {\n-        if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Converts `self` to big endian from the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(n.to_be(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_be(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn to_be(self) -> Self { // or not to be?\n-        if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n-    }\n-\n-    /// Converts `self` to little endian from the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(n.to_le(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_le(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn to_le(self) -> Self {\n-        if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n-    }\n-\n-    /// Checked integer addition. Computes `self + other`, returning `None` if\n-    /// overflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.checked_add(65530), Some(65535));\n-    /// assert_eq!(6u16.checked_add(65530), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_add(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer subtraction. Computes `self - other`, returning `None`\n-    /// if underflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n-    /// assert_eq!((-128i8).checked_sub(1), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_sub(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer multiplication. Computes `self * other`, returning\n-    /// `None` if underflow or overflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u8.checked_mul(51), Some(255));\n-    /// assert_eq!(5u8.checked_mul(52), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_mul(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer division. Computes `self / other`, returning `None` if\n-    /// `other == 0` or the operation results in underflow or overflow.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!((-127i8).checked_div(-1), Some(127));\n-    /// assert_eq!((-128i8).checked_div(-1), None);\n-    /// assert_eq!((1i8).checked_div(0), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_div(self, other: Self) -> Option<Self>;\n-\n-    /// Saturating integer addition. Computes `self + other`, saturating at\n-    /// the numeric bounds instead of overflowing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.saturating_add(65534), 65535);\n-    /// assert_eq!((-5i16).saturating_add(-32767), -32768);\n-    /// assert_eq!(100u32.saturating_add(4294967294), 4294967295);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn saturating_add(self, other: Self) -> Self {\n-        match self.checked_add(other) {\n-            Some(x)                      => x,\n-            None if other >= Int::zero() => Int::max_value(),\n-            None                         => Int::min_value(),\n-        }\n-    }\n-\n-    /// Saturating integer subtraction. Computes `self - other`, saturating at\n-    /// the numeric bounds instead of overflowing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.saturating_sub(65534), 0);\n-    /// assert_eq!(5i16.saturating_sub(-32767), 32767);\n-    /// assert_eq!(100u32.saturating_sub(4294967294), 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn saturating_sub(self, other: Self) -> Self {\n-        match self.checked_sub(other) {\n-            Some(x)                      => x,\n-            None if other >= Int::zero() => Int::min_value(),\n-            None                         => Int::max_value(),\n-        }\n-    }\n-\n-    /// Raises self to the power of `exp`, using exponentiation by squaring.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(2.pow(4), 16);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    #[inline]\n-    fn pow(self, mut exp: u32) -> Self {\n-        let mut base = self;\n-        let mut acc: Self = Int::one();\n-\n-        let mut prev_base = self;\n-        let mut base_oflo = false;\n-        while exp > 0 {\n-            if (exp & 1) == 1 {\n-                if base_oflo {\n-                    // ensure overflow occurs in the same manner it\n-                    // would have otherwise (i.e. signal any exception\n-                    // it would have otherwise).\n-                    acc = acc * (prev_base * prev_base);\n-                } else {\n-                    acc = acc * base;\n-                }\n-            }\n-            prev_base = base;\n-            let (new_base, new_base_oflo) = base.overflowing_mul(base);\n-            base = new_base;\n-            base_oflo = new_base_oflo;\n-            exp /= 2;\n-        }\n-        acc\n-    }\n-}\n-\n macro_rules! checked_op {\n     ($T:ty, $U:ty, $op:path, $x:expr, $y:expr) => {{\n         let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n         if overflowed { None } else { Some(result as $T) }\n     }}\n }\n \n-macro_rules! uint_impl {\n-    ($T:ty = $ActualT:ty, $BITS:expr,\n-     $ctpop:path,\n-     $ctlz:path,\n-     $cttz:path,\n-     $bswap:path,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl Int for $T {\n-            #[inline]\n-            fn zero() -> $T { 0 }\n-\n-            #[inline]\n-            fn one() -> $T { 1 }\n-\n-            #[inline]\n-            fn min_value() -> $T { 0 }\n-\n-            #[inline]\n-            fn max_value() -> $T { !0 }\n-\n-            #[inline]\n-            fn count_ones(self) -> u32 {\n-                unsafe { $ctpop(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn leading_zeros(self) -> u32 {\n-                unsafe { $ctlz(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn trailing_zeros(self) -> u32 {\n-                unsafe { $cttz(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn rotate_left(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self << n) | (self >> (($BITS - n) % $BITS))\n-            }\n-\n-            #[inline]\n-            fn rotate_right(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self >> n) | (self << (($BITS - n) % $BITS))\n-            }\n-\n-            #[inline]\n-            fn swap_bytes(self) -> $T {\n-                unsafe { $bswap(self as $ActualT) as $T }\n-            }\n-\n-            #[inline]\n-            fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0 => None,\n-                    v => Some(self / v),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// Swapping a single byte is a no-op. This is marked as `unsafe` for\n /// consistency with the other `bswap` intrinsics.\n unsafe fn bswap8(x: u8) -> u8 { x }\n \n-uint_impl! { u8 = u8, 8,\n-    intrinsics::ctpop8,\n-    intrinsics::ctlz8,\n-    intrinsics::cttz8,\n-    bswap8,\n-    intrinsics::u8_add_with_overflow,\n-    intrinsics::u8_sub_with_overflow,\n-    intrinsics::u8_mul_with_overflow }\n-\n-uint_impl! { u16 = u16, 16,\n-    intrinsics::ctpop16,\n-    intrinsics::ctlz16,\n-    intrinsics::cttz16,\n-    intrinsics::bswap16,\n-    intrinsics::u16_add_with_overflow,\n-    intrinsics::u16_sub_with_overflow,\n-    intrinsics::u16_mul_with_overflow }\n-\n-uint_impl! { u32 = u32, 32,\n-    intrinsics::ctpop32,\n-    intrinsics::ctlz32,\n-    intrinsics::cttz32,\n-    intrinsics::bswap32,\n-    intrinsics::u32_add_with_overflow,\n-    intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow }\n-\n-uint_impl! { u64 = u64, 64,\n-    intrinsics::ctpop64,\n-    intrinsics::ctlz64,\n-    intrinsics::cttz64,\n-    intrinsics::bswap64,\n-    intrinsics::u64_add_with_overflow,\n-    intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"32\")]\n-uint_impl! { usize = u32, 32,\n-    intrinsics::ctpop32,\n-    intrinsics::ctlz32,\n-    intrinsics::cttz32,\n-    intrinsics::bswap32,\n-    intrinsics::u32_add_with_overflow,\n-    intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-uint_impl! { usize = u64, 64,\n-    intrinsics::ctpop64,\n-    intrinsics::ctlz64,\n-    intrinsics::cttz64,\n-    intrinsics::bswap64,\n-    intrinsics::u64_add_with_overflow,\n-    intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow }\n-\n-macro_rules! int_impl {\n-    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl Int for $T {\n-            #[inline]\n-            fn zero() -> $T { 0 }\n-\n-            #[inline]\n-            fn one() -> $T { 1 }\n-\n-            #[inline]\n-            fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n-\n-            #[inline]\n-            fn max_value() -> $T { let min: $T = Int::min_value(); !min }\n-\n-            #[inline]\n-            fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n-\n-            #[inline]\n-            fn leading_zeros(self) -> u32 {\n-                (self as $UnsignedT).leading_zeros()\n-            }\n-\n-            #[inline]\n-            fn trailing_zeros(self) -> u32 {\n-                (self as $UnsignedT).trailing_zeros()\n-            }\n-\n-            #[inline]\n-            fn rotate_left(self, n: u32) -> $T {\n-                (self as $UnsignedT).rotate_left(n) as $T\n-            }\n-\n-            #[inline]\n-            fn rotate_right(self, n: u32) -> $T {\n-                (self as $UnsignedT).rotate_right(n) as $T\n-            }\n-\n-            #[inline]\n-            fn swap_bytes(self) -> $T {\n-                (self as $UnsignedT).swap_bytes() as $T\n-            }\n-\n-            #[inline]\n-            fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0   => None,\n-                   -1 if self == Int::min_value()\n-                        => None,\n-                    v   => Some(self / v),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-int_impl! { i8 = i8, u8, 8,\n-    intrinsics::i8_add_with_overflow,\n-    intrinsics::i8_sub_with_overflow,\n-    intrinsics::i8_mul_with_overflow }\n-\n-int_impl! { i16 = i16, u16, 16,\n-    intrinsics::i16_add_with_overflow,\n-    intrinsics::i16_sub_with_overflow,\n-    intrinsics::i16_mul_with_overflow }\n-\n-int_impl! { i32 = i32, u32, 32,\n-    intrinsics::i32_add_with_overflow,\n-    intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow }\n-\n-int_impl! { i64 = i64, u64, 64,\n-    intrinsics::i64_add_with_overflow,\n-    intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"32\")]\n-int_impl! { isize = i32, u32, 32,\n-    intrinsics::i32_add_with_overflow,\n-    intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-int_impl! { isize = i64, u64, 64,\n-    intrinsics::i64_add_with_overflow,\n-    intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow }\n-\n-/// A built-in two's complement integer.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n-#[allow(deprecated)]\n-pub trait SignedInt\n-    : Int\n-    + Neg<Output=Self>\n-{\n-    /// Computes the absolute value of `self`. `Int::min_value()` will be\n-    /// returned if the number is `Int::min_value()`.\n-    #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n-    fn abs(self) -> Self;\n-\n-    /// Returns a number representing sign of `self`.\n-    ///\n-    /// - `0` if the number is zero\n-    /// - `1` if the number is positive\n-    /// - `-1` if the number is negative\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signum(self) -> Self;\n-\n-    /// Returns `true` if `self` is positive and `false` if the number\n-    /// is zero or negative.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_positive(self) -> bool;\n-\n-    /// Returns `true` if `self` is negative and `false` if the number\n-    /// is zero or positive.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_negative(self) -> bool;\n-}\n-\n-macro_rules! signed_int_impl {\n-    ($T:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl SignedInt for $T {\n-            #[inline]\n-            fn abs(self) -> $T {\n-                if self.is_negative() { -self } else { self }\n-            }\n-\n-            #[inline]\n-            fn signum(self) -> $T {\n-                match self {\n-                    n if n > 0 =>  1,\n-                    0          =>  0,\n-                    _          => -1,\n-                }\n-            }\n-\n-            #[inline]\n-            fn is_positive(self) -> bool { self > 0 }\n-\n-            #[inline]\n-            fn is_negative(self) -> bool { self < 0 }\n-        }\n-    }\n-}\n-\n-signed_int_impl! { i8 }\n-signed_int_impl! { i16 }\n-signed_int_impl! { i32 }\n-signed_int_impl! { i64 }\n-signed_int_impl! { isize }\n-\n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+    ($T:ident = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n@@ -840,7 +121,7 @@ macro_rules! int_impl {\n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn max_value() -> $T {\n-            let min: $T = Int::min_value(); !min\n+            let min = $T::min_value(); !min\n         }\n \n         /// Converts a string slice in a given base to an integer.\n@@ -859,7 +140,7 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n-            <Self as FromStrRadix>::from_str_radix(src, radix)\n+            from_str_radix(src, radix)\n         }\n \n         /// Returns the number of ones in the binary representation of `self`.\n@@ -1439,7 +720,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n-            <Self as FromStrRadix>::from_str_radix(src, radix)\n+            from_str_radix(src, radix)\n         }\n \n         /// Returns the number of ones in the binary representation of `self`.\n@@ -2007,575 +1288,6 @@ impl usize {\n         intrinsics::u64_mul_with_overflow }\n }\n \n-/// A generic trait for converting a value to a number.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait ToPrimitive {\n-    /// Converts the value of `self` to an `isize`.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use to_isize\")]\n-    fn to_int(&self) -> Option<isize> {\n-        self.to_i64().and_then(|x| x.to_isize())\n-    }\n-\n-    /// Converts the value of `self` to an `isize`.\n-    #[inline]\n-    fn to_isize(&self) -> Option<isize> {\n-        self.to_i64().and_then(|x| x.to_isize())\n-    }\n-\n-    /// Converts the value of `self` to an `i8`.\n-    #[inline]\n-    fn to_i8(&self) -> Option<i8> {\n-        self.to_i64().and_then(|x| x.to_i8())\n-    }\n-\n-    /// Converts the value of `self` to an `i16`.\n-    #[inline]\n-    fn to_i16(&self) -> Option<i16> {\n-        self.to_i64().and_then(|x| x.to_i16())\n-    }\n-\n-    /// Converts the value of `self` to an `i32`.\n-    #[inline]\n-    fn to_i32(&self) -> Option<i32> {\n-        self.to_i64().and_then(|x| x.to_i32())\n-    }\n-\n-    /// Converts the value of `self` to an `i64`.\n-    fn to_i64(&self) -> Option<i64>;\n-\n-    /// Converts the value of `self` to an `usize`.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use to_usize\")]\n-    fn to_uint(&self) -> Option<usize> {\n-        self.to_u64().and_then(|x| x.to_usize())\n-    }\n-\n-    /// Converts the value of `self` to a `usize`.\n-    #[inline]\n-    fn to_usize(&self) -> Option<usize> {\n-        self.to_u64().and_then(|x| x.to_usize())\n-    }\n-\n-    /// Converts the value of `self` to an `u8`.\n-    #[inline]\n-    fn to_u8(&self) -> Option<u8> {\n-        self.to_u64().and_then(|x| x.to_u8())\n-    }\n-\n-    /// Converts the value of `self` to an `u16`.\n-    #[inline]\n-    fn to_u16(&self) -> Option<u16> {\n-        self.to_u64().and_then(|x| x.to_u16())\n-    }\n-\n-    /// Converts the value of `self` to an `u32`.\n-    #[inline]\n-    fn to_u32(&self) -> Option<u32> {\n-        self.to_u64().and_then(|x| x.to_u32())\n-    }\n-\n-    /// Converts the value of `self` to an `u64`.\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64>;\n-\n-    /// Converts the value of `self` to an `f32`.\n-    #[inline]\n-    fn to_f32(&self) -> Option<f32> {\n-        self.to_f64().and_then(|x| x.to_f32())\n-    }\n-\n-    /// Converts the value of `self` to an `f64`.\n-    #[inline]\n-    fn to_f64(&self) -> Option<f64> {\n-        self.to_i64().and_then(|x| x.to_f64())\n-    }\n-}\n-\n-macro_rules! impl_to_primitive_int_to_int {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some($slf as $DstT)\n-            } else {\n-                let n = $slf as i64;\n-                let min_value: $DstT = Int::min_value();\n-                let max_value: $DstT = Int::max_value();\n-                if min_value as i64 <= n && n <= max_value as i64 {\n-                    Some($slf as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_int_to_uint {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            let zero: $SrcT = Int::zero();\n-            let max_value: $DstT = Int::max_value();\n-            if zero <= $slf && $slf as u64 <= max_value as u64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_int {\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8, *self) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16, *self) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32, *self) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64, *self) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8, *self) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16, *self) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32, *self) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64, *self) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_int! { isize }\n-impl_to_primitive_int! { i8 }\n-impl_to_primitive_int! { i16 }\n-impl_to_primitive_int! { i32 }\n-impl_to_primitive_int! { i64 }\n-\n-macro_rules! impl_to_primitive_uint_to_int {\n-    ($DstT:ty, $slf:expr) => (\n-        {\n-            let max_value: $DstT = Int::max_value();\n-            if $slf as u64 <= max_value as u64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_uint_to_uint {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some($slf as $DstT)\n-            } else {\n-                let zero: $SrcT = Int::zero();\n-                let max_value: $DstT = Int::max_value();\n-                if zero <= $slf && $slf as u64 <= max_value as u64 {\n-                    Some($slf as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_uint {\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16, *self) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32, *self) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> {\n-                impl_to_primitive_uint_to_uint!($T, usize, *self)\n-            }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16, *self) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32, *self) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64, *self) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_uint! { usize }\n-impl_to_primitive_uint! { u8 }\n-impl_to_primitive_uint! { u16 }\n-impl_to_primitive_uint! { u32 }\n-impl_to_primitive_uint! { u64 }\n-\n-macro_rules! impl_to_primitive_float_to_float {\n-    ($SrcT:ident, $DstT:ident, $slf:expr) => (\n-        if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-            Some($slf as $DstT)\n-        } else {\n-            let n = $slf as f64;\n-            let max_value: $SrcT = ::$SrcT::MAX;\n-            if -max_value as f64 <= n && n <= max_value as f64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_float {\n-    ($T:ident) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { Some(*self as isize) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { Some(*self as isize) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { Some(*self as usize) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> { Some(*self as usize) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32, *self) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64, *self) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_float! { f32 }\n-impl_to_primitive_float! { f64 }\n-\n-/// A generic trait for converting a number to a value.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait FromPrimitive : ::marker::Sized {\n-    /// Converts an `isize` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-    fn from_int(n: isize) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `isize` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_isize(n: isize) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i8(n: i8) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i16(n: i16) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i32(n: i32) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_i64(n: i64) -> Option<Self>;\n-\n-    /// Converts an `usize` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use from_usize\")]\n-    fn from_uint(n: usize) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts a `usize` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_usize(n: usize) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u8(n: u8) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u16(n: u16) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u32(n: u32) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_u64(n: u64) -> Option<Self>;\n-\n-    /// Converts a `f32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f32(n: f32) -> Option<Self> {\n-        FromPrimitive::from_f64(n as f64)\n-    }\n-\n-    /// Converts a `f64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f64(n: f64) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_int`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-pub fn from_int<A: FromPrimitive>(n: isize) -> Option<A> {\n-    FromPrimitive::from_isize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_isize`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_isize<A: FromPrimitive>(n: isize) -> Option<A> {\n-    FromPrimitive::from_isize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i8`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n-    FromPrimitive::from_i8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i16`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n-    FromPrimitive::from_i16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n-    FromPrimitive::from_i32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n-    FromPrimitive::from_i64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_uint`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use from_uint\")]\n-pub fn from_uint<A: FromPrimitive>(n: usize) -> Option<A> {\n-    FromPrimitive::from_usize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_usize`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_usize<A: FromPrimitive>(n: usize) -> Option<A> {\n-    FromPrimitive::from_usize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u8`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n-    FromPrimitive::from_u8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u16`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n-    FromPrimitive::from_u16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n-    FromPrimitive::from_u32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n-    FromPrimitive::from_u64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n-    FromPrimitive::from_f32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n-    FromPrimitive::from_f64(n)\n-}\n-\n-macro_rules! impl_from_primitive {\n-    ($T:ty, $to_ty:ident) => (\n-        #[allow(deprecated)]\n-        impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: isize) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i8(n: i8) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i16(n: i16) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i32(n: i32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i64(n: i64) -> Option<$T> { n.$to_ty() }\n-\n-            #[inline] fn from_uint(n: usize) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u8(n: u8) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u16(n: u16) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u32(n: u32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u64(n: u64) -> Option<$T> { n.$to_ty() }\n-\n-            #[inline] fn from_f32(n: f32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_f64(n: f64) -> Option<$T> { n.$to_ty() }\n-        }\n-    )\n-}\n-\n-impl_from_primitive! { isize, to_int }\n-impl_from_primitive! { i8, to_i8 }\n-impl_from_primitive! { i16, to_i16 }\n-impl_from_primitive! { i32, to_i32 }\n-impl_from_primitive! { i64, to_i64 }\n-impl_from_primitive! { usize, to_uint }\n-impl_from_primitive! { u8, to_u8 }\n-impl_from_primitive! { u16, to_u16 }\n-impl_from_primitive! { u32, to_u32 }\n-impl_from_primitive! { u64, to_u64 }\n-impl_from_primitive! { f32, to_f32 }\n-impl_from_primitive! { f64, to_f64 }\n-\n-/// Casts from one machine scalar to another.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::num;\n-///\n-/// let twenty: f32 = num::cast(0x14).unwrap();\n-/// assert_eq!(twenty, 20f32);\n-/// ```\n-///\n-#[inline]\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n-    NumCast::from(n)\n-}\n-\n-/// An interface for casting between machine scalars.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait NumCast: ToPrimitive {\n-    /// Creates a number from another value that can be converted into a primitive via the\n-    /// `ToPrimitive` trait.\n-    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n-}\n-\n-macro_rules! impl_num_cast {\n-    ($T:ty, $conv:ident) => (\n-        impl NumCast for $T {\n-            #[inline]\n-            #[allow(deprecated)]\n-            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n-                // `$conv` could be generated using `concat_idents!`, but that\n-                // macro seems to be broken at the moment\n-                n.$conv()\n-            }\n-        }\n-    )\n-}\n-\n-impl_num_cast! { u8,    to_u8 }\n-impl_num_cast! { u16,   to_u16 }\n-impl_num_cast! { u32,   to_u32 }\n-impl_num_cast! { u64,   to_u64 }\n-impl_num_cast! { usize,  to_uint }\n-impl_num_cast! { i8,    to_i8 }\n-impl_num_cast! { i16,   to_i16 }\n-impl_num_cast! { i32,   to_i32 }\n-impl_num_cast! { i64,   to_i64 }\n-impl_num_cast! { isize,   to_int }\n-impl_num_cast! { f32,   to_f32 }\n-impl_num_cast! { f64,   to_f64 }\n-\n /// Used for representing the classification of floating point numbers\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2602,94 +1314,21 @@ pub enum FpCategory {\n }\n \n /// A built-in floating point number.\n-// FIXME(#5527): In a future version of Rust, many of these functions will\n-//               become constants.\n-//\n-// FIXME(#8888): Several of these functions have a parameter named\n-//               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable(feature = \"core\",\n-           reason = \"distribution of methods between core/std is unclear\")]\n #[doc(hidden)]\n-pub trait Float\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd\n-    + PartialEq\n-    + Neg<Output=Self>\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-{\n+pub trait Float {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n     /// Returns the infinite value.\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n     fn neg_infinity() -> Self;\n-    /// Returns the `0` value.\n-    fn zero() -> Self;\n     /// Returns -0.0.\n     fn neg_zero() -> Self;\n-    /// Returns the `1` value.\n+    /// Returns 0.0.\n+    fn zero() -> Self;\n+    /// Returns 1.0.\n     fn one() -> Self;\n \n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Returns the number of binary digits of mantissa that this type supports.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n-    /// Returns the number of base-10 digits of precision that this type supports.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> usize;\n-    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    fn epsilon() -> Self;\n-    /// Returns the minimum binary exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the maximum binary exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the minimum base-10 exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the maximum base-10 exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the smallest finite value that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN` or `std::f64::MIN` as appropriate\")]\n-    fn min_value() -> Self;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_POSITIVE` or \\\n-                           `std::f64::MIN_POSITIVE` as appropriate\")]\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-    /// Returns the largest finite value that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX` or `std::f64::MAX` as appropriate\")]\n-    fn max_value() -> Self;\n-\n     /// Returns true if this value is NaN and false otherwise.\n     fn is_nan(self) -> bool;\n     /// Returns true if this value is positive infinity or negative infinity and\n@@ -2705,16 +1344,16 @@ pub trait Float\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Returns the largest integer less than or equal to a number.\n+    /// Return the largest integer less than or equal to a number.\n     fn floor(self) -> Self;\n-    /// Returns the smallest integer greater than or equal to a number.\n+    /// Return the smallest integer greater than or equal to a number.\n     fn ceil(self) -> Self;\n-    /// Returns the nearest integer to a number. Round half-way cases away from\n+    /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n     fn round(self) -> Self;\n-    /// Returns the integer part of a number.\n+    /// Return the integer part of a number.\n     fn trunc(self) -> Self;\n-    /// Returns the fractional part of a number.\n+    /// Return the fractional part of a number.\n     fn fract(self) -> Self;\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n@@ -2737,21 +1376,21 @@ pub trait Float\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n     fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n     fn recip(self) -> Self;\n \n-    /// Raises a number to an integer power.\n+    /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     fn powi(self, n: i32) -> Self;\n-    /// Raises a number to a floating point power.\n+    /// Raise a number to a floating point power.\n     fn powf(self, n: Self) -> Self;\n \n-    /// Takes the square root of a number.\n+    /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     fn sqrt(self) -> Self;\n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -2767,37 +1406,12 @@ pub trait Float\n     /// Returns the base 10 logarithm of the number.\n     fn log10(self) -> Self;\n \n-    /// Converts radians to degrees.\n+    /// Convert radians to degrees.\n     fn to_degrees(self) -> Self;\n-    /// Converts degrees to radians.\n+    /// Convert degrees to radians.\n     fn to_radians(self) -> Self;\n }\n \n-/// A generic trait for converting a string with a radix (base) to a value\n-#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n-pub trait FromStrRadix {\n-    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n-    type Err;\n-\n-    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n-    #[allow(deprecated)]\n-    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::Err>;\n-}\n-\n-/// A utility function that just calls `FromStrRadix::from_str_radix`.\n-#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use e.g. i32::from_str_radix\")]\n-#[allow(deprecated)]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: u32)\n-                                       -> Result<T, T::Err> {\n-    FromStrRadix::from_str_radix(str, radix)\n-}\n-\n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2832,39 +1446,9 @@ macro_rules! from_str_radix_float_impl {\n             #[inline]\n             #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n-                from_str_radix(src, 10)\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl FromStrRadix for $T {\n-            type Err = ParseFloatError;\n-\n-            /// Converts a string in a given base to a float.\n-            ///\n-            /// Due to possible conflicts, this function does **not** accept\n-            /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-            /// does it recognize exponents of any kind.\n-            ///\n-            /// Leading and trailing whitespace represent an error.\n-            ///\n-            /// # Arguments\n-            ///\n-            /// * src - A string\n-            /// * radix - The base to use. Must lie in the range [2 .. 36]\n-            ///\n-            /// # Return value\n-            ///\n-            /// `Err(ParseFloatError)` if the string did not represent a valid number.\n-            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n-            fn from_str_radix(src: &str, radix: u32)\n-                              -> Result<$T, ParseFloatError> {\n                 use self::FloatErrorKind::*;\n                 use self::ParseFloatError as PFE;\n-                assert!(radix >= 2 && radix <= 36,\n-                       \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n-                       radix);\n+                let radix = 10;\n \n                 // Special values\n                 match src {\n@@ -3005,87 +1589,98 @@ from_str_radix_float_impl! { f32 }\n from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n-    ($T:ty) => {\n+    ($($T:ident)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         impl FromStr for $T {\n             type Err = ParseIntError;\n-            #[inline]\n             fn from_str(src: &str) -> Result<$T, ParseIntError> {\n                 from_str_radix(src, 10)\n             }\n         }\n+    )*}\n+}\n+from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl FromStrRadix for $T {\n-            type Err = ParseIntError;\n-            fn from_str_radix(src: &str, radix: u32)\n-                              -> Result<$T, ParseIntError> {\n-                use self::IntErrorKind::*;\n-                use self::ParseIntError as PIE;\n-                assert!(radix >= 2 && radix <= 36,\n-                       \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-                       radix);\n-\n-                let is_signed_ty = (0 as $T) > Int::min_value();\n-\n-                match src.slice_shift_char() {\n-                    Some(('-', \"\")) => Err(PIE { kind: Empty }),\n-                    Some(('-', src)) if is_signed_ty => {\n-                        // The number is negative\n-                        let mut result = 0;\n-                        for c in src.chars() {\n-                            let x = match c.to_digit(radix) {\n-                                Some(x) => x,\n-                                None => return Err(PIE { kind: InvalidDigit }),\n-                            };\n-                            result = match result.checked_mul(radix as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Underflow }),\n-                            };\n-                            result = match result.checked_sub(x as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Underflow }),\n-                            };\n-                        }\n-                        Ok(result)\n-                    },\n-                    Some((_, _)) => {\n-                        // The number is signed\n-                        let mut result = 0;\n-                        for c in src.chars() {\n-                            let x = match c.to_digit(radix) {\n-                                Some(x) => x,\n-                                None => return Err(PIE { kind: InvalidDigit }),\n-                            };\n-                            result = match result.checked_mul(radix as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Overflow }),\n-                            };\n-                            result = match result.checked_add(x as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Overflow }),\n-                            };\n-                        }\n-                        Ok(result)\n-                    },\n-                    None => Err(ParseIntError { kind: Empty }),\n-                }\n+#[doc(hidden)]\n+trait FromStrRadixHelper: PartialOrd + Copy {\n+    fn min_value() -> Self;\n+    fn from_u32(u: u32) -> Self;\n+    fn checked_mul(&self, other: u32) -> Option<Self>;\n+    fn checked_sub(&self, other: u32) -> Option<Self>;\n+    fn checked_add(&self, other: u32) -> Option<Self>;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl FromStrRadixHelper for $t {\n+        fn min_value() -> Self { <$t>::min_value() }\n+        fn from_u32(u: u32) -> Self { u as $t }\n+        fn checked_mul(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_mul(*self, other as $t)\n+        }\n+        fn checked_sub(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_sub(*self, other as $t)\n+        }\n+        fn checked_add(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_add(*self, other as $t)\n+        }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n+                                         -> Result<T, ParseIntError> {\n+    use self::IntErrorKind::*;\n+    use self::ParseIntError as PIE;\n+    assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n+    let is_signed_ty = T::from_u32(0) > T::min_value();\n+\n+    match src.slice_shift_char() {\n+        Some(('-', \"\")) => Err(PIE { kind: Empty }),\n+        Some(('-', src)) if is_signed_ty => {\n+            // The number is negative\n+            let mut result = T::from_u32(0);\n+            for c in src.chars() {\n+                let x = match c.to_digit(radix) {\n+                    Some(x) => x,\n+                    None => return Err(PIE { kind: InvalidDigit }),\n+                };\n+                result = match result.checked_mul(radix) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Underflow }),\n+                };\n+                result = match result.checked_sub(x) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Underflow }),\n+                };\n             }\n-        }\n+            Ok(result)\n+        },\n+        Some((_, _)) => {\n+            // The number is signed\n+            let mut result = T::from_u32(0);\n+            for c in src.chars() {\n+                let x = match c.to_digit(radix) {\n+                    Some(x) => x,\n+                    None => return Err(PIE { kind: InvalidDigit }),\n+                };\n+                result = match result.checked_mul(radix) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Overflow }),\n+                };\n+                result = match result.checked_add(x) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Overflow }),\n+                };\n+            }\n+            Ok(result)\n+        },\n+        None => Err(ParseIntError { kind: Empty }),\n     }\n }\n-from_str_radix_int_impl! { isize }\n-from_str_radix_int_impl! { i8 }\n-from_str_radix_int_impl! { i16 }\n-from_str_radix_int_impl! { i32 }\n-from_str_radix_int_impl! { i64 }\n-from_str_radix_int_impl! { usize }\n-from_str_radix_int_impl! { u8 }\n-from_str_radix_int_impl! { u16 }\n-from_str_radix_int_impl! { u32 }\n-from_str_radix_int_impl! { u64 }\n \n /// An error which can be returned when parsing an integer.\n #[derive(Debug, Clone, PartialEq)]"}, {"sha": "b7ca497db18637bcd0d1d83a9c1d945a550b5b24", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -15,8 +15,6 @@ use super::Wrapping;\n \n use ops::*;\n \n-use intrinsics::{overflowing_add, overflowing_sub, overflowing_mul};\n-\n use intrinsics::{i8_add_with_overflow, u8_add_with_overflow};\n use intrinsics::{i16_add_with_overflow, u16_add_with_overflow};\n use intrinsics::{i32_add_with_overflow, u32_add_with_overflow};\n@@ -32,14 +30,6 @@ use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n use ::{i8,i16,i32,i64};\n \n-#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n-pub trait WrappingOps {\n-    fn wrapping_add(self, rhs: Self) -> Self;\n-    fn wrapping_sub(self, rhs: Self) -> Self;\n-    fn wrapping_mul(self, rhs: Self) -> Self;\n-}\n-\n #[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n@@ -99,27 +89,6 @@ sh_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n macro_rules! wrapping_impl {\n     ($($t:ty)*) => ($(\n-        impl WrappingOps for $t {\n-            #[inline(always)]\n-            fn wrapping_add(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_add(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn wrapping_sub(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_sub(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn wrapping_mul(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_mul(self, rhs)\n-                }\n-            }\n-        }\n-\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Add for Wrapping<$t> {\n             type Output = Wrapping<$t>;"}, {"sha": "1e96d761d405a948e3db12b02f4f45f18ca27c19", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -51,7 +51,7 @@ use result::Result::{Ok, Err};\n use ptr;\n use mem;\n use mem::size_of;\n-use marker::{Send, Sized, Sync, self};\n+use marker::{Send, Sync, self};\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;"}, {"sha": "4d343ea0f1e42c37712371a6b2fc47a70d72d93b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -25,7 +25,6 @@ use default::Default;\n use fmt;\n use iter::ExactSizeIterator;\n use iter::{Map, Iterator, DoubleEndedIterator};\n-use marker::Sized;\n use mem;\n use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};"}, {"sha": "9cd3b74e1552d95adef258408645af0715a20bd6", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -11,8 +11,6 @@\n //! The ChaCha random number generator.\n \n use core::prelude::*;\n-use core::num::Int;\n-use core::num::wrapping::WrappingOps;\n use {Rng, SeedableRng, Rand};\n \n const KEY_WORDS    : usize =  8; // 8 words for the 256-bit key"}, {"sha": "4ea81b8e61938b4f9c5f2e54f369a754750ee644", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -18,7 +18,7 @@\n //! that do not need to record state.\n \n use core::prelude::*;\n-use core::num::{Float, Int};\n+use core::num::Float;\n use core::marker::PhantomData;\n \n use {Rng, Rand};"}, {"sha": "c5dd741c80c1053ca9bdb3825a7a97856e189238", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -13,8 +13,6 @@\n // this is surprisingly complicated to be both generic & correct\n \n use core::prelude::PartialOrd;\n-use core::num::Int;\n-use core::num::wrapping::WrappingOps;\n \n use Rng;\n use distributions::{Sample, IndependentSample};\n@@ -73,7 +71,7 @@ pub trait SampleRange {\n }\n \n macro_rules! integer_impl {\n-    ($ty:ty, $unsigned:ty) => {\n+    ($ty:ident, $unsigned:ident) => {\n         impl SampleRange for $ty {\n             // we play free and fast with unsigned vs signed here\n             // (when $ty is signed), but that's fine, since the\n@@ -83,7 +81,7 @@ macro_rules! integer_impl {\n \n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n                 let range = (high as $unsigned).wrapping_sub(low as $unsigned);\n-                let unsigned_max: $unsigned = Int::max_value();\n+                let unsigned_max: $unsigned = $unsigned::max_value();\n \n                 // this is the largest number that fits into $unsigned\n                 // that `range` divides evenly, so, if we've sampled\n@@ -168,11 +166,11 @@ mod tests {\n     fn test_integers() {\n         let mut rng = ::test::rng();\n         macro_rules! t {\n-            ($($ty:ty),*) => {{\n+            ($($ty:ident),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0, 10),\n                                             (10, 127),\n-                                            (Int::min_value(), Int::max_value())];\n+                                            ($ty::min_value(), $ty::max_value())];\n                    for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in 0..1000 {"}, {"sha": "b7938397038b490d6b02c4b0092ad4ad8b62966a", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -836,7 +836,6 @@ pub mod writer {\n     use std::io::prelude::*;\n     use std::io::{self, SeekFrom, Cursor};\n     use std::slice::bytes;\n-    use std::num::ToPrimitive;\n \n     use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n         EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n@@ -1070,10 +1069,10 @@ pub mod writer {\n     impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-            if let Some(v) = v.to_u8() {\n-                self.wr_tagged_raw_u8(EsSub8 as usize, v)\n-            } else if let Some(v) = v.to_u32() {\n-                self.wr_tagged_raw_u32(EsSub32 as usize, v)\n+            if v as u8 as usize == v {\n+                self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n+            } else if v as u32 as usize == v {\n+                self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n             } else {\n                 Err(io::Error::new(io::ErrorKind::Other,\n                                    &format!(\"length or variant id too big: {}\",\n@@ -1101,21 +1100,24 @@ pub mod writer {\n             self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            match v.to_u32() {\n-                Some(v) => self.emit_u32(v),\n-                None => self.wr_tagged_raw_u64(EsU64 as usize, v)\n+            if v as u32 as u64 == v {\n+                self.emit_u32(v as u32)\n+            } else {\n+                self.wr_tagged_raw_u64(EsU64 as usize, v)\n             }\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            match v.to_u16() {\n-                Some(v) => self.emit_u16(v),\n-                None => self.wr_tagged_raw_u32(EsU32 as usize, v)\n+            if v as u16 as u32 == v {\n+                self.emit_u16(v as u16)\n+            } else {\n+                self.wr_tagged_raw_u32(EsU32 as usize, v)\n             }\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            match v.to_u8() {\n-                Some(v) => self.emit_u8(v),\n-                None => self.wr_tagged_raw_u16(EsU16 as usize, v)\n+            if v as u8 as u16 == v {\n+                self.emit_u8(v as u8)\n+            } else {\n+                self.wr_tagged_raw_u16(EsU16 as usize, v)\n             }\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n@@ -1126,21 +1128,24 @@ pub mod writer {\n             self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            match v.to_i32() {\n-                Some(v) => self.emit_i32(v),\n-                None => self.wr_tagged_raw_i64(EsI64 as usize, v)\n+            if v as i32 as i64 == v {\n+                self.emit_i32(v as i32)\n+            } else {\n+                self.wr_tagged_raw_i64(EsI64 as usize, v)\n             }\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            match v.to_i16() {\n-                Some(v) => self.emit_i16(v),\n-                None => self.wr_tagged_raw_i32(EsI32 as usize, v)\n+            if v as i16 as i32 == v {\n+                self.emit_i16(v as i16)\n+            } else {\n+                self.wr_tagged_raw_i32(EsI32 as usize, v)\n             }\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            match v.to_i8() {\n-                Some(v) => self.emit_i8(v),\n-                None => self.wr_tagged_raw_i16(EsI16 as usize, v)\n+            if v as i8 as i16 == v {\n+                self.emit_i8(v as i8)\n+            } else {\n+                self.wr_tagged_raw_i16(EsI16 as usize, v)\n             }\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {"}, {"sha": "b65bd965976d133efc10be8033aa17482966ba08", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -69,6 +69,9 @@ extern crate test;\n \n pub use rustc_llvm as llvm;\n \n+#[macro_use]\n+mod macros;\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n@@ -142,6 +145,7 @@ pub mod util {\n     pub mod ppaux;\n     pub mod nodemap;\n     pub mod lev_distance;\n+    pub mod num;\n }\n \n pub mod lib {"}, {"sha": "ed764ebd9f95dd4e27b579342fc0f4c66e77a486", "filename": "src/librustc/macros.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! enum_from_u32 {\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident = $e:expr,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant = $e),*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant,)*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "06a40f1dd277da124749bebf2b9ede7b975b18fa", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -116,37 +116,39 @@ pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n pub const tag_items_data_item_reexport_name: usize = 0x48;\n \n // used to encode crate_ctxt side tables\n-#[derive(Copy, Clone, PartialEq, FromPrimitive)]\n-#[repr(usize)]\n-pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n-    tag_ast = 0x50,\n-\n-    tag_tree = 0x51,\n-\n-    tag_id_range = 0x52,\n-\n-    tag_table = 0x53,\n-    // GAP 0x54, 0x55\n-    tag_table_def = 0x56,\n-    tag_table_node_type = 0x57,\n-    tag_table_item_subst = 0x58,\n-    tag_table_freevars = 0x59,\n-    tag_table_tcache = 0x5a,\n-    tag_table_param_defs = 0x5b,\n-    tag_table_mutbl = 0x5c,\n-    tag_table_last_use = 0x5d,\n-    tag_table_spill = 0x5e,\n-    tag_table_method_map = 0x5f,\n-    tag_table_vtable_map = 0x60,\n-    tag_table_adjustments = 0x61,\n-    tag_table_moves_map = 0x62,\n-    tag_table_capture_map = 0x63,\n-    tag_table_closure_tys = 0x64,\n-    tag_table_closure_kinds = 0x65,\n-    tag_table_upvar_capture_map = 0x66,\n-    tag_table_capture_modes = 0x67,\n-    tag_table_object_cast_map = 0x68,\n-    tag_table_const_qualif = 0x69,\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq)]\n+    #[repr(usize)]\n+    pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n+        tag_ast = 0x50,\n+\n+        tag_tree = 0x51,\n+\n+        tag_id_range = 0x52,\n+\n+        tag_table = 0x53,\n+        // GAP 0x54, 0x55\n+        tag_table_def = 0x56,\n+        tag_table_node_type = 0x57,\n+        tag_table_item_subst = 0x58,\n+        tag_table_freevars = 0x59,\n+        tag_table_tcache = 0x5a,\n+        tag_table_param_defs = 0x5b,\n+        tag_table_mutbl = 0x5c,\n+        tag_table_last_use = 0x5d,\n+        tag_table_spill = 0x5e,\n+        tag_table_method_map = 0x5f,\n+        tag_table_vtable_map = 0x60,\n+        tag_table_adjustments = 0x61,\n+        tag_table_moves_map = 0x62,\n+        tag_table_capture_map = 0x63,\n+        tag_table_closure_tys = 0x64,\n+        tag_table_closure_kinds = 0x65,\n+        tag_table_upvar_capture_map = 0x66,\n+        tag_table_capture_modes = 0x67,\n+        tag_table_object_cast_map = 0x68,\n+        tag_table_const_qualif = 0x69,\n+    }\n }\n \n pub const tag_item_trait_item_sort: usize = 0x70;"}, {"sha": "1f18b13fc46fe26fff04ab9c29d40db0d2f499fd", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -68,11 +68,13 @@ pub enum LinkagePreference {\n     RequireStatic,\n }\n \n-#[derive(Copy, Clone, PartialEq, FromPrimitive)]\n-pub enum NativeLibraryKind {\n-    NativeStatic,    // native static library (.a archive)\n-    NativeFramework, // OSX-specific\n-    NativeUnknown,   // default way to specify a dynamic library\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq)]\n+    pub enum NativeLibraryKind {\n+        NativeStatic,    // native static library (.a archive)\n+        NativeFramework, // OSX-specific\n+        NativeUnknown,   // default way to specify a dynamic library\n+    }\n }\n \n // Where a crate came from on the local filesystem. One of these two options"}, {"sha": "cbd542567709c13f9b114d9949b1fc62784de9d3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -35,7 +35,6 @@ use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n use std::io::prelude::*;\n use std::io;\n-use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::slice::bytes;\n use std::str;\n@@ -1349,7 +1348,7 @@ pub fn get_native_libraries(cdata: Cmd)\n         let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n         let kind: cstore::NativeLibraryKind =\n-            FromPrimitive::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n+            cstore::NativeLibraryKind::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n         let name = name_doc.as_str().to_string();\n         result.push((kind, name));\n         true\n@@ -1359,7 +1358,7 @@ pub fn get_native_libraries(cdata: Cmd)\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n     reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n-        .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n+        .map(|doc| reader::doc_as_u32(doc))\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n@@ -1407,7 +1406,7 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     let mut result = Vec::new();\n     reader::tagged_docs(items, tag_lang_items_missing, |missing_docs| {\n         let item: lang_items::LangItem =\n-            FromPrimitive::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n+            lang_items::LangItem::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n         result.push(item);\n         true\n     });"}, {"sha": "ee8373279d976f9f4d95c76cbba2a566121b93f2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -41,7 +41,6 @@ use syntax;\n use std::cell::Cell;\n use std::io::SeekFrom;\n use std::io::prelude::*;\n-use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::fmt::Debug;\n \n@@ -1713,7 +1712,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n-        let decoded_tag: Option<c::astencode_tag> = FromPrimitive::from_usize(tag);\n+        let tag = tag as u32;\n+        let decoded_tag: Option<c::astencode_tag> = c::astencode_tag::from_u32(tag);\n         match decoded_tag {\n             None => {\n                 dcx.tcx.sess.bug("}, {"sha": "2c6ffb3281fcb4922cd173710578565938bf65d3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -20,6 +20,7 @@ use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n+use util::num::ToPrimitive;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n@@ -30,7 +31,6 @@ use syntax::{ast_map, ast_util, codemap};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n-use std::num::ToPrimitive;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::{i8, i16, i32, i64};"}, {"sha": "c77a43e75cdc089a3dc70f8396bae1675f27619f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -36,7 +36,6 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n use std::iter::Enumerate;\n-use std::num::FromPrimitive;\n use std::slice;\n \n // The actual lang items defined come at the end of this file in one handy table.\n@@ -46,9 +45,12 @@ macro_rules! lets_do_this {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-#[derive(Copy, Clone, FromPrimitive, PartialEq, Eq, Hash)]\n-pub enum LangItem {\n-    $($variant),*\n+\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    pub enum LangItem {\n+        $($variant,)*\n+    }\n }\n \n pub struct LanguageItems {\n@@ -71,7 +73,7 @@ impl LanguageItems {\n     }\n \n     pub fn item_name(index: usize) -> &'static str {\n-        let item: Option<LangItem> = FromPrimitive::from_usize(index);\n+        let item: Option<LangItem> = LangItem::from_u32(index as u32);\n         match item {\n             $( Some($variant) => $name, )*\n             None => \"???\""}, {"sha": "2c94399f92138c981f0ca805b039bbb7f404cd26", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -63,6 +63,7 @@ use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::FnvHashMap;\n+use util::num::ToPrimitive;\n \n use arena::TypedArena;\n use std::borrow::{Borrow, Cow};\n@@ -71,7 +72,6 @@ use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use std::mem;\n-use std::num::ToPrimitive;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;"}, {"sha": "da04976a96a37234b4f1cfaf05af3b622ce865ab", "filename": "src/librustc/util/num.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Futil%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc%2Futil%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnum.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait ToPrimitive {\n+    fn to_i8(&self) -> Option<i8>;\n+    fn to_i16(&self) -> Option<i16>;\n+    fn to_i32(&self) -> Option<i32>;\n+    fn to_i64(&self) -> Option<i64>;\n+    fn to_u8(&self) -> Option<u8>;\n+    fn to_u16(&self) -> Option<u16>;\n+    fn to_u32(&self) -> Option<u32>;\n+    fn to_u64(&self) -> Option<u64>;\n+}\n+\n+impl ToPrimitive for i64 {\n+    fn to_i8(&self) -> Option<i8> {\n+        if *self < i8::min_value() as i64 || *self > i8::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i8)\n+        }\n+    }\n+    fn to_i16(&self) -> Option<i16> {\n+        if *self < i16::min_value() as i64 || *self > i16::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i16)\n+        }\n+    }\n+    fn to_i32(&self) -> Option<i32> {\n+        if *self < i32::min_value() as i64 || *self > i32::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i32)\n+        }\n+    }\n+    fn to_i64(&self) -> Option<i64> {\n+        Some(*self)\n+    }\n+    fn to_u8(&self) -> Option<u8> {\n+        if *self < 0 || *self > u8::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u8)\n+        }\n+    }\n+    fn to_u16(&self) -> Option<u16> {\n+        if *self < 0 || *self > u16::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u16)\n+        }\n+    }\n+    fn to_u32(&self) -> Option<u32> {\n+        if *self < 0 || *self > u32::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u32)\n+        }\n+    }\n+    fn to_u64(&self) -> Option<u64> {\n+        if *self < 0 {None} else {Some(*self as u64)}\n+    }\n+}\n+\n+impl ToPrimitive for u64 {\n+    fn to_i8(&self) -> Option<i8> {\n+        if *self > i8::max_value() as u64 {None} else {Some(*self as i8)}\n+    }\n+    fn to_i16(&self) -> Option<i16> {\n+        if *self > i16::max_value() as u64 {None} else {Some(*self as i16)}\n+    }\n+    fn to_i32(&self) -> Option<i32> {\n+        if *self > i32::max_value() as u64 {None} else {Some(*self as i32)}\n+    }\n+    fn to_i64(&self) -> Option<i64> {\n+        if *self > i64::max_value() as u64 {None} else {Some(*self as i64)}\n+    }\n+    fn to_u8(&self) -> Option<u8> {\n+        if *self > u8::max_value() as u64 {None} else {Some(*self as u8)}\n+    }\n+    fn to_u16(&self) -> Option<u16> {\n+        if *self > u16::max_value() as u64 {None} else {Some(*self as u16)}\n+    }\n+    fn to_u32(&self) -> Option<u32> {\n+        if *self > u32::max_value() as u64 {None} else {Some(*self as u32)}\n+    }\n+    fn to_u64(&self) -> Option<u64> {\n+        Some(*self)\n+    }\n+}"}, {"sha": "c45ce12efb7dac04fa385d77294c57085a92657a", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -12,10 +12,7 @@\n //! use. This implementation is not intended for external use or for any use where security is\n //! important.\n \n-#![allow(deprecated)] // to_be32\n-\n use std::iter::repeat;\n-use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n \n@@ -61,10 +58,10 @@ impl ToBits for u64 {\n \n /// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n /// overflow.\n-fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n+fn add_bytes_to_bits(bits: u64, bytes: u64) -> u64 {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    if new_high_bits > T::zero() {\n+    if new_high_bits > 0 {\n         panic!(\"numeric overflow occurred.\")\n     }\n "}, {"sha": "e8752ab14b344685f72fd9c55aef57187b14fa23", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -21,9 +21,6 @@ use libc;\n use flate;\n \n use std::ffi::CString;\n-use std::mem;\n-#[allow(deprecated)]\n-use std::num::Int;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[String]) {\n@@ -198,19 +195,15 @@ fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n-    return read_from_le_bytes::<u32>(bc, link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET);\n+    let pos = link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET;\n+    let byte_data = &bc[pos..pos + 4];\n+    let data = unsafe { *(byte_data.as_ptr() as *const u32) };\n+    u32::from_le(data)\n }\n \n fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n-    return read_from_le_bytes::<u64>(bc, link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET);\n-}\n-\n-#[allow(deprecated)]\n-fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: usize) -> T {\n-    let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n-    let data = unsafe {\n-        *(byte_data.as_ptr() as *const T)\n-    };\n-\n-    Int::from_le(data)\n+    let pos = link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET;\n+    let byte_data = &bc[pos..pos + 8];\n+    let data = unsafe { *(byte_data.as_ptr() as *const u64) };\n+    u64::from_le(data)\n }"}, {"sha": "e2827eeae15d0bbb0cf17ae56fa57d6e4b8fc82f", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -45,8 +45,6 @@\n \n pub use self::Repr::*;\n \n-#[allow(deprecated)]\n-use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};"}, {"sha": "9f01521313633360909b34399635ecc7049b589d", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -21,8 +21,6 @@ use util::ppaux::Repr;\n \n use trans::type_::Type;\n \n-#[allow(deprecated)]\n-use std::num::Int;\n use syntax::abi;\n use syntax::ast;\n "}, {"sha": "fc5be67d4a9e5321339a56aabe8d2532e8ff78af", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -204,12 +204,10 @@ use std::io::prelude::*;\n use std::io;\n use std::mem::swap;\n use std::num::FpCategory as Fp;\n-#[allow(deprecated)]\n-use std::num::wrapping::WrappingOps;\n use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n-use std::{char, f64, fmt, num, str};\n+use std::{char, f64, fmt, str};\n use std;\n use rustc_unicode::str as unicode_str;\n use rustc_unicode::str::Utf16Item;\n@@ -460,8 +458,8 @@ fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {\n fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n         Fp::Nan | Fp::Infinite => string::String::from_str(\"null\"),\n-        _ if v.fract() != 0f64 => f64::to_str_digits(v, 6),\n-        _ => f64::to_str_digits(v, 6) + \".0\",\n+        _ if v.fract() != 0f64 => v.to_string(),\n+        _ => v.to_string() + \".0\",\n     }\n }\n \n@@ -1165,7 +1163,7 @@ impl Json {\n     pub fn as_i64(&self) -> Option<i64> {\n         match *self {\n             Json::I64(n) => Some(n),\n-            Json::U64(n) => num::cast(n),\n+            Json::U64(n) => Some(n as i64),\n             _ => None\n         }\n     }\n@@ -1174,7 +1172,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_u64(&self) -> Option<u64> {\n         match *self {\n-            Json::I64(n) => num::cast(n),\n+            Json::I64(n) => Some(n as u64),\n             Json::U64(n) => Some(n),\n             _ => None\n         }\n@@ -1184,8 +1182,8 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_f64(&self) -> Option<f64> {\n         match *self {\n-            Json::I64(n) => num::cast(n),\n-            Json::U64(n) => num::cast(n),\n+            Json::I64(n) => Some(n as f64),\n+            Json::U64(n) => Some(n as f64),\n             Json::F64(n) => Some(n),\n             _ => None\n         }\n@@ -1556,7 +1554,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n \n     #[allow(deprecated)] // possible resolve bug is mapping these to traits\n     fn parse_u64(&mut self) -> Result<u64, ParserError> {\n-        let mut accum = 0;\n+        let mut accum = 0u64;\n         let last_accum = 0; // necessary to detect overflow.\n \n         match self.ch_or_null() {\n@@ -2121,14 +2119,8 @@ macro_rules! read_primitive {\n     ($name:ident, $ty:ty) => {\n         fn $name(&mut self) -> DecodeResult<$ty> {\n             match self.pop() {\n-                Json::I64(f) => match num::cast(f) {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                },\n-                Json::U64(f) => match num::cast(f) {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                },\n+                Json::I64(f) => Ok(f as $ty),\n+                Json::U64(f) => Ok(f as $ty),\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec."}, {"sha": "3a63e2ab59cc85ed5ddfd4356cac3813eb437c93", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -17,7 +17,7 @@ use iter::{Iterator, ExactSizeIterator};\n use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n-use num::wrapping::{OverflowingOps, WrappingOps};\n+use num::wrapping::OverflowingOps;\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};"}, {"sha": "97c5a29d308a11c8975611bac9680094f78a153e", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -172,13 +172,6 @@ impl Error {\n         Error { repr: Repr::Os(code) }\n     }\n \n-    /// Creates a new instance of an `Error` from a particular OS error code.\n-    #[unstable(feature = \"io\", reason = \"deprecated\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_raw_os_error\")]\n-    pub fn from_os_error(code: i32) -> Error {\n-        Error { repr: Repr::Os(code) }\n-    }\n-\n     /// Returns the OS error that this error represents (if any).\n     ///\n     /// If this `Error` was constructed via `last_os_error` then this function"}, {"sha": "f7d15f9695c3e8fd1940499417ed5b9dfc8f3978", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -128,6 +128,7 @@\n #![feature(std_misc)]\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n+#![feature(zero_one)]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std."}, {"sha": "3bfc764e540b21b900f0a95673a4c3c7288dbd03", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -18,8 +18,6 @@\n use prelude::v1::*;\n \n use io::{self, Error, ErrorKind};\n-#[allow(deprecated)] // Int\n-use num::Int;\n use sys_common::net2 as net_imp;\n \n pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n@@ -55,10 +53,21 @@ pub enum Shutdown {\n     Both,\n }\n \n-#[allow(deprecated)] // Int\n-fn hton<I: Int>(i: I) -> I { i.to_be() }\n-#[allow(deprecated)] // Int\n-fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n+#[doc(hidden)]\n+trait NetInt {\n+    fn from_be(i: Self) -> Self;\n+    fn to_be(&self) -> Self;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl NetInt for $t {\n+        fn from_be(i: Self) -> Self { <$t>::from_be(i) }\n+        fn to_be(&self) -> Self { <$t>::to_be(*self) }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn hton<I: NetInt>(i: I) -> I { i.to_be() }\n+fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }\n \n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n     where F: FnMut(&SocketAddr) -> io::Result<T>"}, {"sha": "430fec4ff2e738d1a2a190f395843f91b55b3946", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 4, "deletions": 430, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -15,20 +15,14 @@\n #![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n \n-use prelude::v1::*;\n-\n use intrinsics;\n use libc::c_int;\n-use num::{Float, FpCategory};\n-use num::strconv;\n-use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n-use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n-use num::strconv::SignFormat::SignNeg;\n+use num::FpCategory;\n \n use core::num;\n \n-pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n-pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f32::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n pub use core::f32::consts;\n@@ -74,290 +68,6 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 { num::Float::nan() }\n-    #[inline]\n-    fn infinity() -> f32 { num::Float::infinity() }\n-    #[inline]\n-    fn neg_infinity() -> f32 { num::Float::neg_infinity() }\n-    #[inline]\n-    fn zero() -> f32 { num::Float::zero() }\n-    #[inline]\n-    fn neg_zero() -> f32 { num::Float::neg_zero() }\n-    #[inline]\n-    fn one() -> f32 { num::Float::one() }\n-\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn mantissa_digits(unused_self: Option<f32>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn epsilon() -> f32 { num::Float::epsilon() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_value() -> f32 { num::Float::min_value() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_value() -> f32 { num::Float::max_value() }\n-\n-    #[inline]\n-    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-    #[inline]\n-    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-    #[inline]\n-    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-    #[inline]\n-    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-    #[inline]\n-    fn classify(self) -> FpCategory { num::Float::classify(self) }\n-\n-    #[inline]\n-    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n-    #[inline]\n-    fn floor(self) -> f32 { num::Float::floor(self) }\n-    #[inline]\n-    fn ceil(self) -> f32 { num::Float::ceil(self) }\n-    #[inline]\n-    fn round(self) -> f32 { num::Float::round(self) }\n-    #[inline]\n-    fn trunc(self) -> f32 { num::Float::trunc(self) }\n-    #[inline]\n-    fn fract(self) -> f32 { num::Float::fract(self) }\n-\n-    #[inline]\n-    fn abs(self) -> f32 { num::Float::abs(self) }\n-    #[inline]\n-    fn signum(self) -> f32 { num::Float::signum(self) }\n-    #[inline]\n-    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-    #[inline]\n-    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n-    #[inline]\n-    fn recip(self) -> f32 { num::Float::recip(self) }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n-    #[inline]\n-    fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n-\n-    #[inline]\n-    fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n-    #[inline]\n-    fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n-\n-    #[inline]\n-    fn exp(self) -> f32 { num::Float::exp(self) }\n-    #[inline]\n-    fn exp2(self) -> f32 { num::Float::exp2(self) }\n-    #[inline]\n-    fn ln(self) -> f32 { num::Float::ln(self) }\n-    #[inline]\n-    fn log(self, base: f32) -> f32 { num::Float::log(self, base) }\n-    #[inline]\n-    fn log2(self) -> f32 { num::Float::log2(self) }\n-    #[inline]\n-    fn log10(self) -> f32 { num::Float::log10(self) }\n-    #[inline]\n-    fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n-    #[inline]\n-    fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n-\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n-    /// power of `exp`\n-    #[inline]\n-    fn ldexp(self, exp: isize) -> f32 {\n-        unsafe { cmath::ldexpf(self, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(self) -> (f32, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    #[inline]\n-    fn next_after(self, other: f32) -> f32 {\n-        unsafe { cmath::nextafterf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn max(self, other: f32) -> f32 {\n-        unsafe { cmath::fmaxf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f32) -> f32 {\n-        unsafe { cmath::fminf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(self, other: f32) -> f32 {\n-        unsafe { cmath::fdimf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn cbrt(self) -> f32 {\n-        unsafe { cmath::cbrtf(self) }\n-    }\n-\n-    #[inline]\n-    fn hypot(self, other: f32) -> f32 {\n-        unsafe { cmath::hypotf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn sin(self) -> f32 {\n-        unsafe { intrinsics::sinf32(self) }\n-    }\n-\n-    #[inline]\n-    fn cos(self) -> f32 {\n-        unsafe { intrinsics::cosf32(self) }\n-    }\n-\n-    #[inline]\n-    fn tan(self) -> f32 {\n-        unsafe { cmath::tanf(self) }\n-    }\n-\n-    #[inline]\n-    fn asin(self) -> f32 {\n-        unsafe { cmath::asinf(self) }\n-    }\n-\n-    #[inline]\n-    fn acos(self) -> f32 {\n-        unsafe { cmath::acosf(self) }\n-    }\n-\n-    #[inline]\n-    fn atan(self) -> f32 {\n-        unsafe { cmath::atanf(self) }\n-    }\n-\n-    #[inline]\n-    fn atan2(self, other: f32) -> f32 {\n-        unsafe { cmath::atan2f(self, other) }\n-    }\n-\n-    /// Simultaneously computes the sine and cosine of the number\n-    #[inline]\n-    fn sin_cos(self) -> (f32, f32) {\n-        (self.sin(), self.cos())\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is\n-    /// accurate even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f32 {\n-        unsafe { cmath::expm1f(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n-    /// accurately than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f32 {\n-        unsafe { cmath::log1pf(self) }\n-    }\n-\n-    #[inline]\n-    fn sinh(self) -> f32 {\n-        unsafe { cmath::sinhf(self) }\n-    }\n-\n-    #[inline]\n-    fn cosh(self) -> f32 {\n-        unsafe { cmath::coshf(self) }\n-    }\n-\n-    #[inline]\n-    fn tanh(self) -> f32 {\n-        unsafe { cmath::tanhf(self) }\n-    }\n-\n-    /// Inverse hyperbolic sine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n-    /// - `NAN` if `self` is `NAN`\n-    #[inline]\n-    fn asinh(self) -> f32 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic cosine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `INFINITY` if `self` is `INFINITY`\n-    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    #[inline]\n-    fn acosh(self) -> f32 {\n-        match self {\n-            x if x < 1.0 => Float::nan(),\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic tangent\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n-    /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `INFINITY` if `self` is `1.0`\n-    /// - `NEG_INFINITY` if `self` is `-1.0`\n-    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `INFINITY` and `NEG_INFINITY`)\n-    #[inline]\n-    fn atanh(self) -> f32 {\n-        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n-    }\n-}\n-\n #[cfg(not(test))]\n #[lang = \"f32\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -617,11 +327,6 @@ impl f32 {\n     #[inline]\n     pub fn is_sign_positive(self) -> bool { num::Float::is_positive(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n-    #[inline]\n-    pub fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-\n     /// Returns `true` if `self`'s sign is negative, including `-0.0`\n     /// and `NEG_INFINITY`.\n     ///\n@@ -641,11 +346,6 @@ impl f32 {\n     #[inline]\n     pub fn is_sign_negative(self) -> bool { num::Float::is_negative(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n-    #[inline]\n-    pub fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n@@ -729,24 +429,6 @@ impl f32 {\n     #[inline]\n     pub fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n \n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::f32;\n-    ///\n-    /// let f = 4.0f32;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n-    #[inline]\n-    pub fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n-\n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n@@ -1339,7 +1021,7 @@ impl f32 {\n     #[inline]\n     pub fn acosh(self) -> f32 {\n         match self {\n-            x if x < 1.0 => Float::nan(),\n+            x if x < 1.0 => num::Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1363,114 +1045,6 @@ impl f32 {\n     }\n }\n \n-//\n-// Section: String Conversions\n-//\n-\n-/// Converts a float to a string\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n-pub fn to_string(num: f32) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in hexadecimal format\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_hex(num: f32) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 16, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in a given radix, and a flag indicating\n-/// whether it's a special value\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n-}\n-\n-/// Converts a float to a string with exactly the number of\n-/// provided significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f32, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string with a maximum number of\n-/// significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f32, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with exactly the number of\n-/// provided digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f32, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with the maximum number of\n-/// digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f32, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n-    r\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f32::*;"}, {"sha": "bd50a087c71b466342cdbcd3b15bdc14bb276133", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 403, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -14,20 +14,14 @@\n #![allow(missing_docs)]\n #![doc(primitive = \"f64\")]\n \n-use prelude::v1::*;\n-\n use intrinsics;\n use libc::c_int;\n-use num::{Float, FpCategory};\n-use num::strconv;\n-use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n-use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n-use num::strconv::SignFormat::SignNeg;\n+use num::FpCategory;\n \n use core::num;\n \n-pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n-pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f64::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n pub use core::f64::consts;\n@@ -82,291 +76,6 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Float for f64 {\n-    // inlined methods from `num::Float`\n-    #[inline]\n-    fn nan() -> f64 { num::Float::nan() }\n-    #[inline]\n-    fn infinity() -> f64 { num::Float::infinity() }\n-    #[inline]\n-    fn neg_infinity() -> f64 { num::Float::neg_infinity() }\n-    #[inline]\n-    fn zero() -> f64 { num::Float::zero() }\n-    #[inline]\n-    fn neg_zero() -> f64 { num::Float::neg_zero() }\n-    #[inline]\n-    fn one() -> f64 { num::Float::one() }\n-\n-\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn mantissa_digits(unused_self: Option<f64>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn epsilon() -> f64 { num::Float::epsilon() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_value() -> f64 { num::Float::min_value() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_value() -> f64 { num::Float::max_value() }\n-\n-    #[inline]\n-    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-    #[inline]\n-    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-    #[inline]\n-    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-    #[inline]\n-    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-    #[inline]\n-    fn classify(self) -> FpCategory { num::Float::classify(self) }\n-\n-    #[inline]\n-    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n-    #[inline]\n-    fn floor(self) -> f64 { num::Float::floor(self) }\n-    #[inline]\n-    fn ceil(self) -> f64 { num::Float::ceil(self) }\n-    #[inline]\n-    fn round(self) -> f64 { num::Float::round(self) }\n-    #[inline]\n-    fn trunc(self) -> f64 { num::Float::trunc(self) }\n-    #[inline]\n-    fn fract(self) -> f64 { num::Float::fract(self) }\n-\n-    #[inline]\n-    fn abs(self) -> f64 { num::Float::abs(self) }\n-    #[inline]\n-    fn signum(self) -> f64 { num::Float::signum(self) }\n-    #[inline]\n-    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-    #[inline]\n-    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n-    #[inline]\n-    fn recip(self) -> f64 { num::Float::recip(self) }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n-    #[inline]\n-    fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n-\n-    #[inline]\n-    fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n-    #[inline]\n-    fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n-\n-    #[inline]\n-    fn exp(self) -> f64 { num::Float::exp(self) }\n-    #[inline]\n-    fn exp2(self) -> f64 { num::Float::exp2(self) }\n-    #[inline]\n-    fn ln(self) -> f64 { num::Float::ln(self) }\n-    #[inline]\n-    fn log(self, base: f64) -> f64 { num::Float::log(self, base) }\n-    #[inline]\n-    fn log2(self) -> f64 { num::Float::log2(self) }\n-    #[inline]\n-    fn log10(self) -> f64 { num::Float::log10(self) }\n-\n-    #[inline]\n-    fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n-    #[inline]\n-    fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n-\n-    #[inline]\n-    fn ldexp(self, exp: isize) -> f64 {\n-        unsafe { cmath::ldexp(self, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(self) -> (f64, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexp(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    #[inline]\n-    fn next_after(self, other: f64) -> f64 {\n-        unsafe { cmath::nextafter(self, other) }\n-    }\n-\n-    #[inline]\n-    fn max(self, other: f64) -> f64 {\n-        unsafe { cmath::fmax(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f64) -> f64 {\n-        unsafe { cmath::fmin(self, other) }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(self, other: f64) -> f64 {\n-        unsafe { cmath::fdim(self, other) }\n-    }\n-\n-    #[inline]\n-    fn cbrt(self) -> f64 {\n-        unsafe { cmath::cbrt(self) }\n-    }\n-\n-    #[inline]\n-    fn hypot(self, other: f64) -> f64 {\n-        unsafe { cmath::hypot(self, other) }\n-    }\n-\n-    #[inline]\n-    fn sin(self) -> f64 {\n-        unsafe { intrinsics::sinf64(self) }\n-    }\n-\n-    #[inline]\n-    fn cos(self) -> f64 {\n-        unsafe { intrinsics::cosf64(self) }\n-    }\n-\n-    #[inline]\n-    fn tan(self) -> f64 {\n-        unsafe { cmath::tan(self) }\n-    }\n-\n-    #[inline]\n-    fn asin(self) -> f64 {\n-        unsafe { cmath::asin(self) }\n-    }\n-\n-    #[inline]\n-    fn acos(self) -> f64 {\n-        unsafe { cmath::acos(self) }\n-    }\n-\n-    #[inline]\n-    fn atan(self) -> f64 {\n-        unsafe { cmath::atan(self) }\n-    }\n-\n-    #[inline]\n-    fn atan2(self, other: f64) -> f64 {\n-        unsafe { cmath::atan2(self, other) }\n-    }\n-\n-    /// Simultaneously computes the sine and cosine of the number\n-    #[inline]\n-    fn sin_cos(self) -> (f64, f64) {\n-        (self.sin(), self.cos())\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is\n-    /// accurate even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f64 {\n-        unsafe { cmath::expm1(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n-    /// accurately than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f64 {\n-        unsafe { cmath::log1p(self) }\n-    }\n-\n-    #[inline]\n-    fn sinh(self) -> f64 {\n-        unsafe { cmath::sinh(self) }\n-    }\n-\n-    #[inline]\n-    fn cosh(self) -> f64 {\n-        unsafe { cmath::cosh(self) }\n-    }\n-\n-    #[inline]\n-    fn tanh(self) -> f64 {\n-        unsafe { cmath::tanh(self) }\n-    }\n-\n-    /// Inverse hyperbolic sine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n-    /// - `NAN` if `self` is `NAN`\n-    #[inline]\n-    fn asinh(self) -> f64 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic cosine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `INFINITY` if `self` is `INFINITY`\n-    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    #[inline]\n-    fn acosh(self) -> f64 {\n-        match self {\n-            x if x < 1.0 => Float::nan(),\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic tangent\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n-    /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `INFINITY` if `self` is `1.0`\n-    /// - `NEG_INFINITY` if `self` is `-1.0`\n-    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `INFINITY` and `NEG_INFINITY`)\n-    #[inline]\n-    fn atanh(self) -> f64 {\n-        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n-    }\n-}\n-\n #[cfg(not(test))]\n #[lang = \"f64\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1304,7 +1013,7 @@ impl f64 {\n     #[inline]\n     pub fn acosh(self) -> f64 {\n         match self {\n-            x if x < 1.0 => Float::nan(),\n+            x if x < 1.0 => num::Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1328,114 +1037,6 @@ impl f64 {\n     }\n }\n \n-//\n-// Section: String Conversions\n-//\n-\n-/// Converts a float to a string\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n-pub fn to_string(num: f64) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in hexadecimal format\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_hex(num: f64) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 16, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in a given radix, and a flag indicating\n-/// whether it's a special value\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n-}\n-\n-/// Converts a float to a string with exactly the number of\n-/// provided significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f64, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string with a maximum number of\n-/// significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f64, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with exactly the number of\n-/// provided digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f64, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with the maximum number of\n-/// digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f64, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n-    r\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f64::*;"}, {"sha": "dbe06b773296b75a0e08f30822595b0a53dad4b5", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 1091, "changes": 1093, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -15,1102 +15,13 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n-#![allow(deprecated)]\n \n #[cfg(test)] use fmt::Debug;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-\n-use marker::Copy;\n-use clone::Clone;\n-use cmp::{PartialOrd, PartialEq};\n-\n-pub use core::num::{Int, SignedInt, Zero, One};\n-pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n-pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n-pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n-pub use core::num::{from_f32, from_f64};\n-pub use core::num::{FromStrRadix, from_str_radix};\n+\n+pub use core::num::{Zero, One};\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n pub use core::num::{wrapping, Wrapping};\n \n-use option::Option;\n-\n-#[unstable(feature = \"std_misc\", reason = \"likely to be removed\")]\n-pub mod strconv;\n-\n-/// Mathematical operations on primitive floating point numbers.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; use rust-lang/num for generics\")]\n-pub trait Float\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd\n-    + PartialEq\n-    + Neg<Output=Self>\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-{\n-    // inlined methods from `num::Float`\n-    /// Returns the `NaN` value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let nan: f32 = Float::nan();\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let infinity: f32 = Float::infinity();\n-    ///\n-    /// assert!(infinity.is_infinite());\n-    /// assert!(!infinity.is_finite());\n-    /// assert!(infinity > f32::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let neg_infinity: f32 = Float::neg_infinity();\n-    ///\n-    /// assert!(neg_infinity.is_infinite());\n-    /// assert!(!neg_infinity.is_finite());\n-    /// assert!(neg_infinity < f32::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn neg_infinity() -> Self;\n-    /// Returns `0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn zero() -> Self;\n-    /// Returns `-0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn neg_zero() -> Self;\n-    /// Returns `1.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let one: f32 = Float::one();\n-    ///\n-    /// assert_eq!(one, 1.0f32);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn one() -> Self;\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Deprecated: use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS`\n-    /// instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n-    /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> usize;\n-    /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    fn epsilon() -> Self;\n-    /// Deprecated: use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> isize;\n-\n-    /// Returns the smallest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::min_value();\n-    ///\n-    /// assert_eq!(x, f64::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_value() -> Self;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-    /// Returns the largest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::max_value();\n-    /// assert_eq!(x, f64::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn max_value() -> Self;\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    /// let f = 7.0;\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// assert!(!f.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_nan(self) -> bool;\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n-    ///\n-    /// assert!(!f.is_infinite());\n-    /// assert!(!nan.is_infinite());\n-    ///\n-    /// assert!(inf.is_infinite());\n-    /// assert!(neg_inf.is_infinite());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_infinite(self) -> bool;\n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n-    ///\n-    /// assert!(f.is_finite());\n-    ///\n-    /// assert!(!nan.is_finite());\n-    /// assert!(!inf.is_finite());\n-    /// assert!(!neg_inf.is_finite());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_finite(self) -> bool;\n-\n-    /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n-    /// let max = f32::MAX;\n-    /// let lower_than_min = 1.0e-40_f32;\n-    /// let zero = 0.0f32;\n-    ///\n-    /// assert!(min.is_normal());\n-    /// assert!(max.is_normal());\n-    ///\n-    /// assert!(!zero.is_normal());\n-    /// assert!(!f32::NAN.is_normal());\n-    /// assert!(!f32::INFINITY.is_normal());\n-    /// // Values between `0` and `min` are Subnormal.\n-    /// assert!(!lower_than_min.is_normal());\n-    /// ```\n-    /// [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_normal(self) -> bool;\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    ///\n-    /// ```\n-    /// use std::num::{Float, FpCategory};\n-    /// use std::f32;\n-    ///\n-    /// let num = 12.4f32;\n-    /// let inf = f32::INFINITY;\n-    ///\n-    /// assert_eq!(num.classify(), FpCategory::Normal);\n-    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn classify(self) -> FpCategory;\n-\n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let num = 2.0f32;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f32;\n-    /// let mantissa_f = mantissa as f32;\n-    /// let exponent_f = num.powf(exponent as f32);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    /// [floating-point]: ../../../../../reference.html#machine-types\n-    #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n-    fn integer_decode(self) -> (u64, i16, i8);\n-\n-    /// Returns the largest integer less than or equal to a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.99;\n-    /// let g = 3.0;\n-    ///\n-    /// assert_eq!(f.floor(), 3.0);\n-    /// assert_eq!(g.floor(), 3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn floor(self) -> Self;\n-    /// Returns the smallest integer greater than or equal to a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.01;\n-    /// let g = 4.0;\n-    ///\n-    /// assert_eq!(f.ceil(), 4.0);\n-    /// assert_eq!(g.ceil(), 4.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ceil(self) -> Self;\n-    /// Returns the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.3;\n-    ///\n-    /// assert_eq!(f.round(), 3.0);\n-    /// assert_eq!(g.round(), -3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn round(self) -> Self;\n-    /// Returns the integer part of a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.7;\n-    ///\n-    /// assert_eq!(f.trunc(), 3.0);\n-    /// assert_eq!(g.trunc(), -3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trunc(self) -> Self;\n-    /// Returns the fractional part of a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n-    /// let abs_difference_x = (x.fract() - 0.5).abs();\n-    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fract(self) -> Self;\n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n-    ///\n-    /// let abs_difference_x = (x.abs() - x).abs();\n-    /// let abs_difference_y = (y.abs() - (-y)).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    ///\n-    /// assert!(f64::NAN.abs().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn abs(self) -> Self;\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = 3.5;\n-    ///\n-    /// assert_eq!(f.signum(), 1.0);\n-    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n-    ///\n-    /// assert!(f64::NAN.signum().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signum(self) -> Self;\n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan: f64 = f64::NAN;\n-    ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n-    ///\n-    /// assert!(f.is_positive());\n-    /// assert!(!g.is_positive());\n-    /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_positive(self) -> bool;\n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n-    ///\n-    /// assert!(!f.is_negative());\n-    /// assert!(g.is_negative());\n-    /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_negative(self) -> bool;\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let m = 10.0;\n-    /// let x = 4.0;\n-    /// let b = 60.0;\n-    ///\n-    /// // 100.0\n-    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn recip(self) -> Self;\n-\n-    /// Raises a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.powi(2) - x*x).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn powi(self, n: i32) -> Self;\n-    /// Raises a number to a floating point power.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn powf(self, n: Self) -> Self;\n-    /// Takes the square root of a number.\n-    ///\n-    /// Returns NaN if `self` is a negative number.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let positive = 4.0;\n-    /// let negative = -4.0;\n-    ///\n-    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// assert!(negative.sqrt().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sqrt(self) -> Self;\n-\n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 4.0;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn rsqrt(self) -> Self;\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n-    /// // e^1\n-    /// let e = one.exp();\n-    ///\n-    /// // ln(e) - 1 == 0\n-    /// let abs_difference = (e.ln() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn exp(self) -> Self;\n-    /// Returns `2^(self)`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 2.0;\n-    ///\n-    /// // 2^2 - 4 == 0\n-    /// let abs_difference = (f.exp2() - 4.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn exp2(self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n-    /// // e^1\n-    /// let e = one.exp();\n-    ///\n-    /// // ln(e) - 1 == 0\n-    /// let abs_difference = (e.ln() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ln(self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n-    /// let two = 2.0;\n-    ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n-    ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference_10 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log(self, base: Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let two = 2.0;\n-    ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference = (two.log2() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log2(self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n-    ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference = (ten.log10() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log10(self) -> Self;\n-\n-    /// Converts radians to degrees.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = consts::PI;\n-    ///\n-    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n-    fn to_degrees(self) -> Self;\n-    /// Converts degrees to radians.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = 180.0;\n-    ///\n-    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n-    fn to_radians(self) -> Self;\n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (Float::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"pending integer conventions\")]\n-    fn ldexp(self, exp: isize) -> Self;\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 4.0;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"pending integer conventions\")]\n-    fn frexp(self) -> (Self, isize);\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0f32;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n-    ///\n-    /// assert!(abs_diff < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn next_after(self, other: Self) -> Self;\n-\n-    /// Returns the maximum of the two numbers.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n-    ///\n-    /// assert_eq!(x.max(y), y);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn max(self, other: Self) -> Self;\n-    /// Returns the minimum of the two numbers.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n-    ///\n-    /// assert_eq!(x.min(y), x);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn min(self, other: Self) -> Self;\n-\n-    /// The positive difference of two numbers.\n-    ///\n-    /// * If `self <= other`: `0:0`\n-    /// * Else: `self - other`\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.0;\n-    /// let y = -3.0;\n-    ///\n-    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n-    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn abs_sub(self, other: Self) -> Self;\n-    /// Takes the cubic root of a number.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 8.0;\n-    ///\n-    /// // x^(1/3) - 2 == 0\n-    /// let abs_difference = (x.cbrt() - 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn cbrt(self) -> Self;\n-    /// Calculates the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let y = 3.0;\n-    ///\n-    /// // sqrt(x^2 + y^2)\n-    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn hypot(self, other: Self) -> Self;\n-\n-    /// Computes the sine of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/2.0;\n-    ///\n-    /// let abs_difference = (x.sin() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sin(self) -> Self;\n-    /// Computes the cosine of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = 2.0*f64::consts::PI;\n-    ///\n-    /// let abs_difference = (x.cos() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn cos(self) -> Self;\n-    /// Computes the tangent of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/4.0;\n-    /// let abs_difference = (x.tan() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-14);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn tan(self) -> Self;\n-    /// Computes the arcsine of a number. Return value is in radians in\n-    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = f64::consts::PI / 2.0;\n-    ///\n-    /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn asin(self) -> Self;\n-    /// Computes the arccosine of a number. Return value is in radians in\n-    /// the range [0, pi] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = f64::consts::PI / 4.0;\n-    ///\n-    /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn acos(self) -> Self;\n-    /// Computes the arctangent of a number. Return value is in radians in the\n-    /// range [-pi/2, pi/2];\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 1.0;\n-    ///\n-    /// // atan(tan(1))\n-    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atan(self) -> Self;\n-    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n-    ///\n-    /// * `x = 0`, `y = 0`: `0`\n-    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n-    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n-    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let pi = f64::consts::PI;\n-    /// // All angles from horizontal right (+x)\n-    /// // 45 deg counter-clockwise\n-    /// let x1 = 3.0;\n-    /// let y1 = -3.0;\n-    ///\n-    /// // 135 deg clockwise\n-    /// let x2 = -3.0;\n-    /// let y2 = 3.0;\n-    ///\n-    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n-    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n-    ///\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atan2(self, other: Self) -> Self;\n-    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n-    /// `(sin(x), cos(x))`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/4.0;\n-    /// let f = x.sin_cos();\n-    ///\n-    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n-    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sin_cos(self) -> (Self, Self);\n-\n-    /// Returns `e^(self) - 1` in a way that is accurate even if the\n-    /// number is close to zero.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 7.0;\n-    ///\n-    /// // e^(ln(7)) - 1\n-    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn exp_m1(self) -> Self;\n-    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n-    /// the operations were performed separately.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::E - 1.0;\n-    ///\n-    /// // ln(1 + (e - 1)) == ln(e) == 1\n-    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn ln_1p(self) -> Self;\n-\n-    /// Hyperbolic sine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    ///\n-    /// let f = x.sinh();\n-    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n-    /// let g = (e*e - 1.0)/(2.0*e);\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sinh(self) -> Self;\n-    /// Hyperbolic cosine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    /// let f = x.cosh();\n-    /// // Solving cosh() at 1 gives this result\n-    /// let g = (e*e + 1.0)/(2.0*e);\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// // Same result\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn cosh(self) -> Self;\n-    /// Hyperbolic tangent function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    ///\n-    /// let f = x.tanh();\n-    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n-    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn tanh(self) -> Self;\n-    /// Inverse hyperbolic sine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let f = x.sinh().asinh();\n-    ///\n-    /// let abs_difference = (f - x).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn asinh(self) -> Self;\n-    /// Inverse hyperbolic cosine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let f = x.cosh().acosh();\n-    ///\n-    /// let abs_difference = (f - x).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn acosh(self) -> Self;\n-    /// Inverse hyperbolic tangent function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let f = e.tanh().atanh();\n-    ///\n-    /// let abs_difference = (f - e).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atanh(self) -> Self;\n-}\n-\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T>(ten: T, two: T) where"}, {"sha": "ce1da4742d1dffe0c5c042d6dc627f7bb8713f16", "filename": "src/libstd/num/strconv.rs", "status": "removed", "additions": 0, "deletions": 556, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/e091ba3f3e8b2b00827ab4934314829b33ffb966/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e091ba3f3e8b2b00827ab4934314829b33ffb966/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=e091ba3f3e8b2b00827ab4934314829b33ffb966", "patch": "@@ -1,556 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(missing_docs)]\n-#![allow(deprecated)]\n-\n-use self::ExponentFormat::*;\n-use self::SignificantDigits::*;\n-use self::SignFormat::*;\n-\n-use char;\n-use num::{self, Int, Float, ToPrimitive};\n-use num::FpCategory as Fp;\n-use ops::FnMut;\n-use string::String;\n-use vec::Vec;\n-\n-/// A flag that specifies whether to use exponential (scientific) notation.\n-#[derive(Copy, Clone)]\n-pub enum ExponentFormat {\n-    /// Do not use exponential notation.\n-    ExpNone,\n-    /// Use exponential notation with the exponent having a base of 10 and the\n-    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n-    /// 1e3.\n-    ExpDec,\n-    /// Use exponential notation with the exponent having a base of 2 and the\n-    /// exponent sign being `p` or `P`. For example, 8 would be printed 1p3.\n-    ExpBin,\n-}\n-\n-/// The number of digits used for emitting the fractional part of a number, if\n-/// any.\n-#[derive(Copy, Clone)]\n-pub enum SignificantDigits {\n-    /// All calculable digits will be printed.\n-    ///\n-    /// Note that bignums or fractions may cause a surprisingly large number\n-    /// of digits to be printed.\n-    DigAll,\n-\n-    /// At most the given number of digits will be printed, truncating any\n-    /// trailing zeroes.\n-    DigMax(usize),\n-\n-    /// Precisely the given number of digits will be printed.\n-    DigExact(usize)\n-}\n-\n-/// How to emit the sign of a number.\n-#[derive(Copy, Clone)]\n-pub enum SignFormat {\n-    /// No sign will be printed. The exponent sign will also be emitted.\n-    SignNone,\n-    /// `-` will be printed for negative values, but no sign will be emitted\n-    /// for positive numbers.\n-    SignNeg,\n-    /// `+` will be printed for positive values, and `-` will be printed for\n-    /// negative values.\n-    SignAll,\n-}\n-\n-/// Converts an integral number to its string representation as a byte vector.\n-/// This is meant to be a common base implementation for all integral string\n-/// conversion functions like `to_string()` or `to_str_radix()`.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert. Accepts any number that\n-///                     implements the numeric traits.\n-/// - `radix`         - Base to use. Accepts only the values 2-36.\n-/// - `sign`          - How to emit the sign. Options are:\n-///     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n-///     - `SignNeg`:  Only `-` on negative values.\n-///     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n-/// - `f`             - a callback which will be invoked for each ascii character\n-///                     which composes the string representation of this integer\n-///\n-/// # Panics\n-///\n-/// - Panics if `radix` < 2 or `radix` > 36.\n-fn int_to_str_bytes_common<T, F>(num: T, radix: usize, sign: SignFormat, mut f: F) where\n-    T: Int,\n-    F: FnMut(u8),\n-{\n-    assert!(2 <= radix && radix <= 36);\n-\n-    let _0: T = Int::zero();\n-\n-    let neg = num < _0;\n-    let radix_gen: T = num::cast(radix).unwrap();\n-\n-    let mut deccum = num;\n-    // This is just for integral types, the largest of which is a u64. The\n-    // smallest base that we can have is 2, so the most number of digits we're\n-    // ever going to have is 64\n-    let mut buf = [0; 64];\n-    let mut cur = 0;\n-\n-    // Loop at least once to make sure at least a `0` gets emitted.\n-    loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit_signed = deccum % radix_gen;\n-        let current_digit = if current_digit_signed < _0 {\n-            _0 - current_digit_signed\n-        } else {\n-            current_digit_signed\n-        };\n-        buf[cur] = match current_digit.to_u8().unwrap() {\n-            i @ 0...9 => b'0' + i,\n-            i         => b'a' + (i - 10),\n-        };\n-        cur += 1;\n-\n-        deccum = deccum / radix_gen;\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg | SignAll if neg => { f(b'-'); }\n-        SignAll => { f(b'+'); }\n-        _ => ()\n-    }\n-\n-    // We built the number in reverse order, so un-reverse it here\n-    while cur > 0 {\n-        cur -= 1;\n-        f(buf[cur]);\n-    }\n-}\n-\n-/// Converts a number to its string representation as a byte vector.\n-/// This is meant to be a common base implementation for all numeric string\n-/// conversion functions like `to_string()` or `to_str_radix()`.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert. Accepts any number that\n-///                     implements the numeric traits.\n-/// - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n-///                     is used, then this base is only used for the significand. The exponent\n-///                     itself always printed using a base of 10.\n-/// - `negative_zero` - Whether to treat the special value `-0` as\n-///                     `-0` or as `+0`.\n-/// - `sign`          - How to emit the sign. See `SignFormat`.\n-/// - `digits`        - The amount of digits to use for emitting the fractional\n-///                     part, if any. See `SignificantDigits`.\n-/// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n-///                    See `ExponentFormat`.\n-/// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n-///                     exponential notation is desired.\n-///\n-/// # Return value\n-///\n-/// A tuple containing the byte vector, and a boolean flag indicating\n-/// whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n-/// It returns a tuple because there can be ambiguity between a special value\n-/// and a number representation at higher bases.\n-///\n-/// # Panics\n-///\n-/// - Panics if `radix` < 2 or `radix` > 36.\n-/// - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n-///   between digit and exponent sign `'e'`.\n-/// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n-///   between digit and exponent sign `'p'`.\n-pub fn float_to_str_bytes_common<T: Float>(\n-        num: T, radix: u32, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n-        ) -> (Vec<u8>, bool) {\n-    assert!(2 <= radix && radix <= 36);\n-    match exp_format {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'e' as decimal exponent\", radix),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'p' as binary exponent\", radix),\n-        _ => ()\n-    }\n-\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n-\n-    match num.classify() {\n-        Fp::Nan => { return (b\"NaN\".to_vec(), true); }\n-        Fp::Infinite if num > _0 => {\n-            return match sign {\n-                SignAll => (b\"+inf\".to_vec(), true),\n-                _       => (b\"inf\".to_vec(), true)\n-            };\n-        }\n-        Fp::Infinite if num < _0 => {\n-            return match sign {\n-                SignNone => (b\"inf\".to_vec(), true),\n-                _        => (b\"-inf\".to_vec(), true),\n-            };\n-        }\n-        _ => {}\n-    }\n-\n-    let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n-    let mut buf = Vec::new();\n-    let radix_gen: T = num::cast(radix as isize).unwrap();\n-\n-    let (num, exp) = match exp_format {\n-        ExpNone => (num, 0),\n-        ExpDec | ExpBin => {\n-            if num == _0 {\n-                (num, 0)\n-            } else {\n-                let (exp, exp_base) = match exp_format {\n-                    ExpDec => (num.abs().log10().floor(), num::cast::<f64, T>(10.0f64).unwrap()),\n-                    ExpBin => (num.abs().log2().floor(), num::cast::<f64, T>(2.0f64).unwrap()),\n-                    ExpNone => unreachable!()\n-                };\n-\n-                (num / exp_base.powf(exp), num::cast::<T, i32>(exp).unwrap())\n-            }\n-        }\n-    };\n-\n-    // First emit the non-fractional part, looping at least once to make\n-    // sure at least a `0` gets emitted.\n-    let mut deccum = num.trunc();\n-    loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit = (deccum % radix_gen).abs();\n-\n-        // Decrease the deccumulator one digit at a time\n-        deccum = deccum / radix_gen;\n-        deccum = deccum.trunc();\n-\n-        buf.push(char::from_digit(current_digit.to_isize().unwrap() as u32, radix)\n-             .unwrap() as u8);\n-\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // If limited digits, calculate one digit more for rounding.\n-    let (limit_digits, digit_count, exact) = match digits {\n-        DigAll          => (false, 0,       false),\n-        DigMax(count)   => (true,  count+1, false),\n-        DigExact(count) => (true,  count+1, true)\n-    };\n-\n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg | SignAll if neg => {\n-            buf.push(b'-');\n-        }\n-        SignAll => {\n-            buf.push(b'+');\n-        }\n-        _ => ()\n-    }\n-\n-    buf.reverse();\n-\n-    // Remember start of the fractional digits.\n-    // Points one beyond end of buf if none get generated,\n-    // or at the '.' otherwise.\n-    let start_fractional_digits = buf.len();\n-\n-    // Now emit the fractional part, if any\n-    deccum = num.fract();\n-    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf.push(b'.');\n-        let mut dig = 0;\n-\n-        // calculate new digits while\n-        // - there is no limit and there are digits left\n-        // - or there is a limit, it's not reached yet and\n-        //   - it's exact\n-        //   - or it's a maximum, and there are still digits left\n-        while (!limit_digits && deccum != _0)\n-           || (limit_digits && dig < digit_count && (\n-                   exact\n-                || (!exact && deccum != _0)\n-              )\n-        ) {\n-            // Shift first fractional digit into the integer part\n-            deccum = deccum * radix_gen;\n-\n-            // Calculate the absolute value of each digit.\n-            // See note in first loop.\n-            let current_digit = deccum.trunc().abs();\n-\n-            buf.push(char::from_digit(\n-                current_digit.to_isize().unwrap() as u32, radix).unwrap() as u8);\n-\n-            // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n-            dig += 1;\n-        }\n-\n-        // If digits are limited, and that limit has been reached,\n-        // cut off the one extra digit, and depending on its value\n-        // round the remaining ones.\n-        if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n-                (chr as char).to_digit(radix).unwrap()\n-            };\n-            let value2ascii = |val: u32| {\n-                char::from_digit(val, radix).unwrap() as u8\n-            };\n-\n-            let extra_digit = ascii2value(buf.pop().unwrap());\n-            if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: isize = buf.len() as isize - 1;\n-                loop {\n-                    // If reached left end of number, have to\n-                    // insert additional digit:\n-                    if i < 0\n-                    || buf[i as usize] == b'-'\n-                    || buf[i as usize] == b'+' {\n-                        buf.insert((i + 1) as usize, value2ascii(1));\n-                        break;\n-                    }\n-\n-                    // Skip the '.'\n-                    if buf[i as usize] == b'.' { i -= 1; continue; }\n-\n-                    // Either increment the digit,\n-                    // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as usize]);\n-                    if current_digit < (radix - 1) {\n-                        buf[i as usize] = value2ascii(current_digit+1);\n-                        break;\n-                    } else {\n-                        buf[i as usize] = value2ascii(0);\n-                        i -= 1;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // if number of digits is not exact, remove all trailing '0's up to\n-    // and including the '.'\n-    if !exact {\n-        let buf_max_i = buf.len() - 1;\n-\n-        // index to truncate from\n-        let mut i = buf_max_i;\n-\n-        // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == b'0' {\n-            i -= 1;\n-        }\n-\n-        // Only attempt to truncate digits if buf has fractional digits\n-        if i >= start_fractional_digits {\n-            // If buf ends with '.', cut that too.\n-            if buf[i] == b'.' { i -= 1 }\n-\n-            // only resize buf if we actually remove digits\n-            if i < buf_max_i {\n-                buf = buf[.. (i + 1)].to_vec();\n-            }\n-        }\n-    } // If exact and trailing '.', just cut that\n-    else {\n-        let max_i = buf.len() - 1;\n-        if buf[max_i] == b'.' {\n-            buf = buf[.. max_i].to_vec();\n-        }\n-    }\n-\n-    match exp_format {\n-        ExpNone => (),\n-        _ => {\n-            buf.push(match exp_format {\n-                ExpDec if exp_upper => 'E',\n-                ExpDec if !exp_upper => 'e',\n-                ExpBin if exp_upper => 'P',\n-                ExpBin if !exp_upper => 'p',\n-                _ => unreachable!()\n-            } as u8);\n-\n-            int_to_str_bytes_common(exp, 10, sign, |c| buf.push(c));\n-        }\n-    }\n-\n-    (buf, false)\n-}\n-\n-/// Converts a number to its string representation. This is a wrapper for\n-/// `to_str_bytes_common()`, for details see there.\n-#[inline]\n-pub fn float_to_str_common<T: Float>(\n-        num: T, radix: u32, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n-        ) -> (String, bool) {\n-    let (bytes, special) = float_to_str_bytes_common(num, radix,\n-                               negative_zero, sign, digits, exp_format, exp_capital);\n-    (String::from_utf8(bytes).unwrap(), special)\n-}\n-\n-// Some constants for from_str_bytes_common's input validation,\n-// they define minimum radix values for which the character is a valid digit.\n-const DIGIT_P_RADIX: u32 = ('p' as u32) - ('a' as u32) + 11;\n-const DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n-\n-#[cfg(test)]\n-mod tests {\n-    use core::num::wrapping::WrappingOps;\n-    use string::ToString;\n-\n-    #[test]\n-    fn test_int_to_str_overflow() {\n-        let mut i8_val: i8 = 127;\n-        assert_eq!(i8_val.to_string(), \"127\");\n-\n-        i8_val = i8_val.wrapping_add(1);\n-        assert_eq!(i8_val.to_string(), \"-128\");\n-\n-        let mut i16_val: i16 = 32_767;\n-        assert_eq!(i16_val.to_string(), \"32767\");\n-\n-        i16_val = i16_val.wrapping_add(1);\n-        assert_eq!(i16_val.to_string(), \"-32768\");\n-\n-        let mut i32_val: i32 = 2_147_483_647;\n-        assert_eq!(i32_val.to_string(), \"2147483647\");\n-\n-        i32_val = i32_val.wrapping_add(1);\n-        assert_eq!(i32_val.to_string(), \"-2147483648\");\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807;\n-        assert_eq!(i64_val.to_string(), \"9223372036854775807\");\n-\n-        i64_val = i64_val.wrapping_add(1);\n-        assert_eq!(i64_val.to_string(), \"-9223372036854775808\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    #![allow(deprecated)] // rand\n-    extern crate test;\n-\n-    mod usize {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use std::fmt;\n-\n-        #[inline]\n-        fn to_string(x: usize, base: u8) {\n-            format!(\"{}\", fmt::radix(x, base));\n-        }\n-\n-        #[bench]\n-        fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 2); })\n-        }\n-\n-        #[bench]\n-        fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 8); })\n-        }\n-\n-        #[bench]\n-        fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 10); })\n-        }\n-\n-        #[bench]\n-        fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 16); })\n-        }\n-\n-        #[bench]\n-        fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 36); })\n-        }\n-    }\n-\n-    mod isize {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use std::fmt;\n-\n-        #[inline]\n-        fn to_string(x: isize, base: u8) {\n-            format!(\"{}\", fmt::radix(x, base));\n-        }\n-\n-        #[bench]\n-        fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 2); })\n-        }\n-\n-        #[bench]\n-        fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 8); })\n-        }\n-\n-        #[bench]\n-        fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 10); })\n-        }\n-\n-        #[bench]\n-        fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 16); })\n-        }\n-\n-        #[bench]\n-        fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 36); })\n-        }\n-    }\n-\n-    mod f64 {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use f64;\n-\n-        #[bench]\n-        fn float_to_string(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { f64::to_string(rng.gen()); })\n-        }\n-    }\n-}"}, {"sha": "1148c7bc3cfdde9ef9f294d832430a88869c01ac", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -110,7 +110,7 @@ use string::String;\n use vec::Vec;\n use fmt;\n \n-use ffi::{OsStr, OsString, AsOsStr};\n+use ffi::{OsStr, OsString};\n \n use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n "}, {"sha": "c2964b7a4f12506d15033e15ef93833f2c14c937", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -161,14 +161,6 @@ impl Condvar {\n         }\n     }\n \n-    /// Deprecated: use `wait_timeout_ms` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use wait_timeout_ms instead\")]\n-    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        self.wait_timeout_ms(guard, dur.num_milliseconds() as u32)\n-    }\n-\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///"}, {"sha": "fc21effb45a8da06cf01b0c57534325bbd2c1d06", "filename": "src/libstd/sys/common/net.rs", "status": "removed", "additions": 0, "deletions": 971, "changes": 971, "blob_url": "https://github.com/rust-lang/rust/blob/e091ba3f3e8b2b00827ab4934314829b33ffb966/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e091ba3f3e8b2b00827ab4934314829b33ffb966/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=e091ba3f3e8b2b00827ab4934314829b33ffb966", "patch": "@@ -1,971 +0,0 @@\n-// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-use self::SocketStatus::*;\n-use self::InAddr::*;\n-\n-use ffi::{CString, CStr};\n-use old_io::net::addrinfo;\n-use old_io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n-use old_io::{IoResult, IoError};\n-use libc::{self, c_char, c_int};\n-use mem;\n-use num::Int;\n-use ptr::{self, null, null_mut};\n-use str;\n-use sys::{self, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n-          wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n-          decode_error_detailed};\n-use sync::{Arc, Mutex};\n-#[cfg(not(target_os = \"linux\"))]\n-use sync::MutexGuard;\n-use sys_common::{self, keep_going, short_write, timeout};\n-use cmp;\n-use old_io;\n-\n-// FIXME: move uses of Arc and deadline tracking to std::io\n-\n-#[derive(Debug)]\n-pub enum SocketStatus {\n-    Readable,\n-    Writable,\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// sockaddr and misc bindings\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub fn htons(u: u16) -> u16 {\n-    u.to_be()\n-}\n-pub fn ntohs(u: u16) -> u16 {\n-    Int::from_be(u)\n-}\n-\n-pub enum InAddr {\n-    In4Addr(libc::in_addr),\n-    In6Addr(libc::in6_addr),\n-}\n-\n-pub fn ip_to_inaddr(ip: IpAddr) -> InAddr {\n-    match ip {\n-        Ipv4Addr(a, b, c, d) => {\n-            let ip = ((a as u32) << 24) |\n-                     ((b as u32) << 16) |\n-                     ((c as u32) <<  8) |\n-                     ((d as u32) <<  0);\n-            In4Addr(libc::in_addr {\n-                s_addr: Int::from_be(ip)\n-            })\n-        }\n-        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-            In6Addr(libc::in6_addr {\n-                s6_addr: [\n-                    htons(a),\n-                    htons(b),\n-                    htons(c),\n-                    htons(d),\n-                    htons(e),\n-                    htons(f),\n-                    htons(g),\n-                    htons(h),\n-                ]\n-            })\n-        }\n-    }\n-}\n-\n-pub fn addr_to_sockaddr(addr: SocketAddr,\n-                    storage: &mut libc::sockaddr_storage)\n-                    -> libc::socklen_t {\n-    unsafe {\n-        let len = match ip_to_inaddr(addr.ip) {\n-            In4Addr(inaddr) => {\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in;\n-                (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n-                (*storage).sin_port = htons(addr.port);\n-                (*storage).sin_addr = inaddr;\n-                mem::size_of::<libc::sockaddr_in>()\n-            }\n-            In6Addr(inaddr) => {\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in6;\n-                (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n-                (*storage).sin6_port = htons(addr.port);\n-                (*storage).sin6_addr = inaddr;\n-                mem::size_of::<libc::sockaddr_in6>()\n-            }\n-        };\n-        return len as libc::socklen_t;\n-    }\n-}\n-\n-pub fn socket(addr: SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n-    unsafe {\n-        let fam = match addr.ip {\n-            Ipv4Addr(..) => libc::AF_INET,\n-            Ipv6Addr(..) => libc::AF_INET6,\n-        };\n-        match libc::socket(fam, ty, 0) as i32 {\n-            -1 => Err(last_net_error()),\n-            fd => Ok(fd as sock_t),\n-        }\n-    }\n-}\n-\n-pub fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n-                 payload: T) -> IoResult<()> {\n-    unsafe {\n-        let payload = &payload as *const T as *const libc::c_void;\n-        let ret = libc::setsockopt(fd, opt, val,\n-                                   payload,\n-                                   mem::size_of::<T>() as libc::socklen_t);\n-        if ret != 0 {\n-            Err(last_net_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n-                           val: libc::c_int) -> IoResult<T> {\n-    unsafe {\n-        let mut slot: T = mem::zeroed();\n-        let mut len = mem::size_of::<T>() as libc::socklen_t;\n-        let ret = c::getsockopt(fd, opt, val,\n-                                &mut slot as *mut _ as *mut _,\n-                                &mut len);\n-        if ret != 0 {\n-            Err(last_net_error())\n-        } else {\n-            assert!(len as usize == mem::size_of::<T>());\n-            Ok(slot)\n-        }\n-    }\n-}\n-\n-pub fn sockname(fd: sock_t,\n-            f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n-                                         *mut libc::socklen_t) -> libc::c_int)\n-    -> IoResult<SocketAddr>\n-{\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-    unsafe {\n-        let storage = &mut storage as *mut libc::sockaddr_storage;\n-        let ret = f(fd,\n-                    storage as *mut libc::sockaddr,\n-                    &mut len as *mut libc::socklen_t);\n-        if ret != 0 {\n-            return Err(last_net_error())\n-        }\n-    }\n-    return sockaddr_to_addr(&storage, len as usize);\n-}\n-\n-pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: usize) -> IoResult<SocketAddr> {\n-    match storage.ss_family as libc::c_int {\n-        libc::AF_INET => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n-            let storage: &libc::sockaddr_in = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let ip = (storage.sin_addr.s_addr as u32).to_be();\n-            let a = (ip >> 24) as u8;\n-            let b = (ip >> 16) as u8;\n-            let c = (ip >>  8) as u8;\n-            let d = (ip >>  0) as u8;\n-            Ok(SocketAddr {\n-                ip: Ipv4Addr(a, b, c, d),\n-                port: ntohs(storage.sin_port),\n-            })\n-        }\n-        libc::AF_INET6 => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n-            let storage: &libc::sockaddr_in6 = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let a = ntohs(storage.sin6_addr.s6_addr[0]);\n-            let b = ntohs(storage.sin6_addr.s6_addr[1]);\n-            let c = ntohs(storage.sin6_addr.s6_addr[2]);\n-            let d = ntohs(storage.sin6_addr.s6_addr[3]);\n-            let e = ntohs(storage.sin6_addr.s6_addr[4]);\n-            let f = ntohs(storage.sin6_addr.s6_addr[5]);\n-            let g = ntohs(storage.sin6_addr.s6_addr[6]);\n-            let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            Ok(SocketAddr {\n-                ip: Ipv6Addr(a, b, c, d, e, f, g, h),\n-                port: ntohs(storage.sin6_port),\n-            })\n-        }\n-        _ => {\n-            Err(IoError {\n-                kind: old_io::InvalidInput,\n-                desc: \"invalid argument\",\n-                detail: None,\n-            })\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// get_host_addresses\n-////////////////////////////////////////////////////////////////////////////////\n-\n-extern \"system\" {\n-    fn getaddrinfo(node: *const c_char, service: *const c_char,\n-                   hints: *const libc::addrinfo,\n-                   res: *mut *mut libc::addrinfo) -> c_int;\n-    fn freeaddrinfo(res: *mut libc::addrinfo);\n-}\n-\n-pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<addrinfo::Hint>)\n-                          -> Result<Vec<addrinfo::Info>, IoError>\n-{\n-    sys::init_net();\n-\n-    assert!(host.is_some() || servname.is_some());\n-\n-    let c_host = match host {\n-        Some(x) => Some(try!(CString::new(x))),\n-        None => None,\n-    };\n-    let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-    let c_serv = match servname {\n-        Some(x) => Some(try!(CString::new(x))),\n-        None => None,\n-    };\n-    let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-\n-    let hint = hint.map(|hint| {\n-        libc::addrinfo {\n-            ai_flags: hint.flags as c_int,\n-            ai_family: hint.family as c_int,\n-            ai_socktype: 0,\n-            ai_protocol: 0,\n-            ai_addrlen: 0,\n-            ai_canonname: null_mut(),\n-            ai_addr: null_mut(),\n-            ai_next: null_mut()\n-        }\n-    });\n-\n-    let hint_ptr = hint.as_ref().map_or(null(), |x| {\n-        x as *const libc::addrinfo\n-    });\n-    let mut res = null_mut();\n-\n-    // Make the call\n-    let s = unsafe {\n-        getaddrinfo(c_host, c_serv, hint_ptr, &mut res)\n-    };\n-\n-    // Error?\n-    if s != 0 {\n-        return Err(last_gai_error(s));\n-    }\n-\n-    // Collect all the results we found\n-    let mut addrs = Vec::new();\n-    let mut rp = res;\n-    while !rp.is_null() {\n-        unsafe {\n-            let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                             (*rp).ai_addrlen as usize));\n-            addrs.push(addrinfo::Info {\n-                address: addr,\n-                family: (*rp).ai_family as usize,\n-                socktype: None,\n-                protocol: None,\n-                flags: (*rp).ai_flags as usize\n-            });\n-\n-            rp = (*rp).ai_next as *mut libc::addrinfo;\n-        }\n-    }\n-\n-    unsafe { freeaddrinfo(res); }\n-\n-    Ok(addrs)\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// get_address_name\n-////////////////////////////////////////////////////////////////////////////////\n-\n-extern \"system\" {\n-    fn getnameinfo(sa: *const libc::sockaddr, salen: libc::socklen_t,\n-        host: *mut c_char, hostlen: libc::size_t,\n-        serv: *mut c_char, servlen: libc::size_t,\n-        flags: c_int) -> c_int;\n-}\n-\n-const NI_MAXHOST: usize = 1025;\n-\n-pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n-    let addr = SocketAddr{ip: addr, port: 0};\n-\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let len = addr_to_sockaddr(addr, &mut storage);\n-\n-    let mut hostbuf = [0 as c_char; NI_MAXHOST];\n-\n-    let res = unsafe {\n-        getnameinfo(&storage as *const _ as *const libc::sockaddr, len,\n-            hostbuf.as_mut_ptr(), NI_MAXHOST as libc::size_t,\n-            ptr::null_mut(), 0,\n-            0)\n-    };\n-\n-    if res != 0 {\n-        return Err(last_gai_error(res));\n-    }\n-\n-    unsafe {\n-        let data = CStr::from_ptr(hostbuf.as_ptr());\n-        Ok(str::from_utf8(data.to_bytes()).unwrap().to_string())\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Timeout helpers\n-//\n-// The read/write functions below are the helpers for reading/writing a socket\n-// with a possible deadline specified. This is generally viewed as a timed out\n-// I/O operation.\n-//\n-// From the application's perspective, timeouts apply to the I/O object, not to\n-// the underlying file descriptor (it's one timeout per object). This means that\n-// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n-//\n-// The next idea to implement timeouts would be to use nonblocking I/O. An\n-// invocation of select() would wait (with a timeout) for a socket to be ready.\n-// Once its ready, we can perform the operation. Note that the operation *must*\n-// be nonblocking, even though select() says the socket is ready. This is\n-// because some other thread could have come and stolen our data (handles can be\n-// cloned).\n-//\n-// To implement nonblocking I/O, the first option we have is to use the\n-// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n-// I/O objects, so this was initially viewed as unwise.\n-//\n-// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n-// send/recv, but the niftiness wears off once you realize it only works well on\n-// Linux [1] [2]. This means that it's pretty easy to get a nonblocking\n-// operation on Linux (no flag fiddling, no affecting other objects), but not on\n-// other platforms.\n-//\n-// To work around this constraint on other platforms, we end up using the\n-// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n-// could cause other objects' blocking operations to suddenly become\n-// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n-// falls back to using the same code path as nonblocking operations, but with an\n-// infinite timeout (select + send/recv). This helps emulate blocking\n-// reads/writes despite the underlying descriptor being nonblocking, as well as\n-// optimizing the fast path of just hitting one syscall in the good case.\n-//\n-// As a final caveat, this implementation uses a mutex so only one thread is\n-// doing a nonblocking operation at at time. This is the operation that comes\n-// after the select() (at which point we think the socket is ready). This is\n-// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n-// expect (wouldn't want someone turning it on when it should be off!). All\n-// operations performed in the lock are *nonblocking* to avoid holding the mutex\n-// forever.\n-//\n-// So, in summary, Linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n-// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n-// reads/writes are still blocking.\n-//\n-// Fun, fun!\n-//\n-// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n-// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n-\n-pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<usize> where\n-    L: FnMut() -> T,\n-    R: FnMut(bool) -> libc::c_int,\n-{\n-    let mut ret = -1;\n-    if deadline == 0 {\n-        ret = retry(|| read(false));\n-    }\n-\n-    if deadline != 0 || (ret == -1 && wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        loop {\n-            // With a timeout, first we wait for the socket to become\n-            // readable using select(), specifying the relevant timeout for\n-            // our previously set deadline.\n-            try!(await(&[fd], deadline, Readable));\n-\n-            // At this point, we're still within the timeout, and we've\n-            // determined that the socket is readable (as returned by\n-            // select). We must still read the socket in *nonblocking* mode\n-            // because some other thread could come steal our data. If we\n-            // fail to read some data, we retry (hence the outer loop) and\n-            // wait for the socket to become readable again.\n-            let _guard = lock();\n-            match retry(|| read(deadline.is_some())) {\n-                -1 if wouldblock() => {}\n-                -1 => return Err(last_net_error()),\n-               n => { ret = n; break }\n-            }\n-        }\n-    }\n-\n-    match ret {\n-        0 => Err(sys_common::eof()),\n-        n if n < 0 => Err(last_net_error()),\n-        n => Ok(n as usize)\n-    }\n-}\n-\n-pub fn write<T, L, W>(fd: sock_t,\n-                      deadline: u64,\n-                      buf: &[u8],\n-                      write_everything: bool,\n-                      mut lock: L,\n-                      mut write: W) -> IoResult<usize> where\n-    L: FnMut() -> T,\n-    W: FnMut(bool, *const u8, usize) -> i64,\n-{\n-    let mut ret = -1;\n-    let mut written = 0;\n-    if deadline == 0 {\n-        if write_everything {\n-            ret = keep_going(buf, |inner, len| {\n-                written = buf.len() - len;\n-                write(false, inner, len)\n-            });\n-        } else {\n-            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n-            if ret > 0 { written = ret as usize; }\n-        }\n-    }\n-\n-    if deadline != 0 || (ret == -1 && wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        while written < buf.len() && (write_everything || written == 0) {\n-            // As with read(), first wait for the socket to be ready for\n-            // the I/O operation.\n-            match await(&[fd], deadline, Writable) {\n-                Err(ref e) if e.kind == old_io::EndOfFile && written > 0 => {\n-                    assert!(deadline.is_some());\n-                    return Err(short_write(written, \"short write\"))\n-                }\n-                Err(e) => return Err(e),\n-                Ok(()) => {}\n-            }\n-\n-            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n-            // against unforeseen circumstances.\n-            let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n-            let len = buf.len() - written;\n-            match retry(|| write(deadline.is_some(), ptr, len)) {\n-                -1 if wouldblock() => {}\n-                -1 => return Err(last_net_error()),\n-                n => { written += n as usize; }\n-            }\n-        }\n-        ret = 0;\n-    }\n-    if ret < 0 {\n-        Err(last_net_error())\n-    } else {\n-        Ok(written)\n-    }\n-}\n-\n-// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n-// derived from.\n-pub fn connect_timeout(fd: sock_t,\n-                       addrp: *const libc::sockaddr,\n-                       len: libc::socklen_t,\n-                       timeout_ms: u64) -> IoResult<()> {\n-    #[cfg(unix)]    use libc::EINPROGRESS as INPROGRESS;\n-    #[cfg(windows)] use libc::WSAEINPROGRESS as INPROGRESS;\n-    #[cfg(unix)]    use libc::EWOULDBLOCK as WOULDBLOCK;\n-    #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n-\n-    // Make sure the call to connect() doesn't block\n-    set_nonblocking(fd, true);\n-\n-    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n-        // If the connection is in progress, then we need to wait for it to\n-        // finish (with a timeout). The current strategy for doing this is\n-        // to use select() with a timeout.\n-        -1 if os::errno() as isize == INPROGRESS as isize ||\n-              os::errno() as isize == WOULDBLOCK as isize => {\n-            let mut set: c::fd_set = unsafe { mem::zeroed() };\n-            c::fd_set(&mut set, fd);\n-            match await(fd, &mut set, timeout_ms) {\n-                0 => Err(timeout(\"connection timed out\")),\n-                -1 => Err(last_net_error()),\n-                _ => {\n-                    let err: libc::c_int = try!(\n-                        getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n-                    if err == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(decode_error_detailed(err))\n-                    }\n-                }\n-            }\n-        }\n-\n-        -1 => Err(last_net_error()),\n-        _ => Ok(()),\n-    };\n-\n-    // be sure to turn blocking I/O back on\n-    set_nonblocking(fd, false);\n-    return ret;\n-\n-    #[cfg(unix)]\n-    fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-        let start = timer::now();\n-        retry(|| unsafe {\n-            // Recalculate the timeout each iteration (it is generally\n-            // undefined what the value of the 'tv' is after select\n-            // returns EINTR).\n-            let mut tv = ms_to_timeval(timeout - (timer::now() - start));\n-            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n-                      ptr::null_mut(), &mut tv)\n-        })\n-    }\n-    #[cfg(windows)]\n-    fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-        let mut tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n-    }\n-}\n-\n-pub fn await(fds: &[sock_t], deadline: Option<u64>,\n-             status: SocketStatus) -> IoResult<()> {\n-    let mut set: c::fd_set = unsafe { mem::zeroed() };\n-    let mut max = 0;\n-    for &fd in fds {\n-        c::fd_set(&mut set, fd);\n-        max = cmp::max(max, fd + 1);\n-    }\n-    if cfg!(windows) {\n-        max = fds.len() as sock_t;\n-    }\n-\n-    let (read, write) = match status {\n-        Readable => (&mut set as *mut _, ptr::null_mut()),\n-        Writable => (ptr::null_mut(), &mut set as *mut _),\n-    };\n-    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n-\n-    match retry(|| {\n-        let now = timer::now();\n-        let tvp = match deadline {\n-            None => ptr::null_mut(),\n-            Some(deadline) => {\n-                // If we're past the deadline, then pass a 0 timeout to\n-                // select() so we can poll the status\n-                let ms = if deadline < now {0} else {deadline - now};\n-                tv = ms_to_timeval(ms);\n-                &mut tv as *mut _\n-            }\n-        };\n-        let r = unsafe {\n-            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n-        };\n-        r\n-    }) {\n-        -1 => Err(last_net_error()),\n-        0 => Err(timeout(\"timed out\")),\n-        _ => Ok(()),\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Basic socket representation\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct Inner {\n-    fd: sock_t,\n-\n-    // Unused on Linux, where this lock is not necessary.\n-    #[allow(dead_code)]\n-    lock: Mutex<()>,\n-}\n-\n-impl Inner {\n-    fn new(fd: sock_t) -> Inner {\n-        Inner { fd: fd, lock: Mutex::new(()) }\n-    }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { close_sock(self.fd); } }\n-}\n-\n-#[cfg(not(target_os = \"linux\"))]\n-pub struct Guard<'a> {\n-    pub fd: sock_t,\n-    pub guard: MutexGuard<'a, ()>,\n-}\n-\n-#[cfg(not(target_os = \"linux\"))]\n-#[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n-    fn drop(&mut self) {\n-        set_nonblocking(self.fd, false);\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// TCP streams\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct TcpStream {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n-}\n-\n-impl TcpStream {\n-    pub fn connect(addr: SocketAddr, timeout: Option<u64>) -> IoResult<TcpStream> {\n-        sys::init_net();\n-\n-        let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let ret = TcpStream::new(fd);\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        match timeout {\n-            Some(timeout) => {\n-                try!(connect_timeout(fd, addrp, len, timeout));\n-                Ok(ret)\n-            },\n-            None => {\n-                match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n-                    -1 => Err(last_error()),\n-                    _ => Ok(ret),\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn new(fd: sock_t) -> TcpStream {\n-        TcpStream {\n-            inner: Arc::new(Inner::new(fd)),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_NODELAY,\n-                   nodelay as libc::c_int)\n-    }\n-\n-    pub fn set_keepalive(&mut self, seconds: Option<usize>) -> IoResult<()> {\n-        let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n-                             seconds.is_some() as libc::c_int);\n-        match seconds {\n-            Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n-            None => ret,\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(target_os = \"openbsd\")]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::SO_KEEPALIVE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(not(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"freebsd\",\n-                  target_os = \"dragonfly\",\n-                  target_os = \"openbsd\")))]\n-    fn set_tcp_keepalive(&mut self, _seconds: usize) -> IoResult<()> {\n-        Ok(())\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn lock_nonblocking(&self) {}\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n-        let ret = Guard {\n-            fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n-        };\n-        set_nonblocking(self.fd(), true);\n-        ret\n-    }\n-\n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::recv(fd,\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as wrlen,\n-                       flags) as libc::c_int\n-        };\n-        read(fd, self.read_deadline, dolock, doread)\n-    }\n-\n-    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: usize| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::send(fd,\n-                       buf as *const _,\n-                       len as wrlen,\n-                       flags) as i64\n-        };\n-        write(fd, self.write_deadline, buf, true, dolock, dowrite).map(|_| ())\n-    }\n-    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getpeername)\n-    }\n-\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n-    }\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-        self.read_deadline = deadline;\n-        self.write_deadline = deadline;\n-    }\n-    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-}\n-\n-impl Clone for TcpStream {\n-    fn clone(&self) -> TcpStream {\n-        TcpStream {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// UDP\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UdpSocket {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n-}\n-\n-impl UdpSocket {\n-    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n-        sys::init_net();\n-\n-        let fd = try!(socket(addr, libc::SOCK_DGRAM));\n-        let ret = UdpSocket {\n-            inner: Arc::new(Inner::new(fd)),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        };\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(last_error()),\n-            _ => Ok(ret),\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_BROADCAST,\n-                   on as libc::c_int)\n-    }\n-\n-    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP,\n-                   on as libc::c_int)\n-    }\n-\n-    pub fn set_membership(&mut self, addr: IpAddr, opt: libc::c_int) -> IoResult<()> {\n-        match ip_to_inaddr(addr) {\n-            In4Addr(addr) => {\n-                let mreq = libc::ip_mreq {\n-                    imr_multiaddr: addr,\n-                    // interface == INADDR_ANY\n-                    imr_interface: libc::in_addr { s_addr: 0x0 },\n-                };\n-                setsockopt(self.fd(), libc::IPPROTO_IP, opt, mreq)\n-            }\n-            In6Addr(addr) => {\n-                let mreq = libc::ip6_mreq {\n-                    ipv6mr_multiaddr: addr,\n-                    ipv6mr_interface: 0,\n-                };\n-                setsockopt(self.fd(), libc::IPPROTO_IPV6, opt, mreq)\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn lock_nonblocking(&self) {}\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n-        let ret = Guard {\n-            fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n-        };\n-        set_nonblocking(self.fd(), true);\n-        ret\n-    }\n-\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-\n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n-        let fd = self.fd();\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n-        let mut addrlen: libc::socklen_t =\n-                mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-\n-        let dolock = || self.lock_nonblocking();\n-        let n = try!(read(fd, self.read_deadline, dolock, |nb| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::recvfrom(fd,\n-                           buf.as_mut_ptr() as *mut libc::c_void,\n-                           buf.len() as msglen_t,\n-                           flags,\n-                           storagep,\n-                           &mut addrlen) as libc::c_int\n-        }));\n-        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize).unwrap()))\n-    }\n-\n-    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        let mut storage = unsafe { mem::zeroed() };\n-        let dstlen = addr_to_sockaddr(dst, &mut storage);\n-        let dstp = &storage as *const _ as *const libc::sockaddr;\n-\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *const u8, len: usize| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::sendto(fd,\n-                         buf as *const libc::c_void,\n-                         len as msglen_t,\n-                         flags,\n-                         dstp,\n-                         dstlen) as i64\n-        };\n-\n-        let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n-        assert!(n == buf.len(), \"UDP packet not completely written.\");\n-        Ok(())\n-    }\n-\n-    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        match multi {\n-            Ipv4Addr(..) => {\n-                self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n-            }\n-            Ipv6Addr(..) => {\n-                self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n-            }\n-        }\n-    }\n-    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        match multi {\n-            Ipv4Addr(..) => {\n-                self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n-            }\n-            Ipv6Addr(..) => {\n-                self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n-            }\n-        }\n-    }\n-\n-    pub fn multicast_time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n-                   ttl as libc::c_int)\n-    }\n-    pub fn time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-        self.read_deadline = deadline;\n-        self.write_deadline = deadline;\n-    }\n-    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-}\n-\n-impl Clone for UdpSocket {\n-    fn clone(&self) -> UdpSocket {\n-        UdpSocket {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-}"}, {"sha": "63e665ea6984bce4e07b5280f464aa2e0e0dfb2f", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -37,8 +37,6 @@ use fmt;\n use hash::{Hash, Hasher};\n use iter::{FromIterator, IntoIterator};\n use mem;\n-#[allow(deprecated)] // Int\n-use num::Int;\n use ops;\n use slice;\n use str;"}, {"sha": "ed6382e000ac90278a0c2e5b852e4c3cd154a2e2", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -17,7 +17,6 @@ use sys::mutex::{self, Mutex};\n use sys::time;\n use sys::sync as ffi;\n use time::Duration;\n-use num::{Int, NumCast};\n \n pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n \n@@ -70,8 +69,8 @@ impl Condvar {\n         let r = ffi::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n-        let seconds = NumCast::from(dur.num_seconds());\n-        let timeout = match seconds.and_then(|s| sys_now.tv_sec.checked_add(s)) {\n+        let seconds = dur.num_seconds() as libc::time_t;\n+        let timeout = match sys_now.tv_sec.checked_add(seconds) {\n             Some(sec) => {\n                 libc::timespec {\n                     tv_sec: sec,\n@@ -81,7 +80,7 @@ impl Condvar {\n             }\n             None => {\n                 libc::timespec {\n-                    tv_sec: Int::max_value(),\n+                    tv_sec: <libc::time_t>::max_value(),\n                     tv_nsec: 1_000_000_000 - 1,\n                 }\n             }"}, {"sha": "d99753a6a4c800c47b0237b23fa2b5dfb328d652", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -15,7 +15,8 @@ use prelude::v1::*;\n \n use io::{self, ErrorKind};\n use libc;\n-use num::{Int, SignedInt};\n+use num::One;\n+use ops::Neg;\n \n pub mod backtrace;\n pub mod c;\n@@ -63,23 +64,8 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-#[inline]\n-#[allow(deprecated)]\n-pub fn retry<T, F> (mut f: F) -> T where\n-    T: SignedInt,\n-    F: FnMut() -> T,\n-{\n-    let one: T = Int::one();\n-    loop {\n-        let n = f();\n-        if n == -one && os::errno() == libc::EINTR as i32 { }\n-        else { return n }\n-    }\n-}\n-\n-#[allow(deprecated)]\n-pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n-    let one: T = Int::one();\n+pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n+    let one: T = T::one();\n     if t == -one {\n         Err(io::Error::last_os_error())\n     } else {\n@@ -89,7 +75,7 @@ pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n \n #[allow(deprecated)]\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: SignedInt, F: FnMut() -> T\n+    where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n {\n     loop {\n         match cvt(f()) {"}, {"sha": "4e7c4d241f53209b2f0acbf99aef8a467d2d7ea8", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -19,7 +19,7 @@ use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n use ptr;\n use sys::pipe2::AnonPipe;\n-use sys::{self, retry, c, cvt};\n+use sys::{self, c, cvt, cvt_r};\n use sys::fs2::{File, OpenOptions};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -273,7 +273,7 @@ impl Process {\n                     }\n                 }\n             };\n-            retry(|| libc::dup2(fd.raw(), dst)) != -1\n+            cvt_r(|| libc::dup2(fd.raw(), dst)).is_ok()\n         };\n \n         if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n@@ -317,19 +317,19 @@ impl Process {\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n         let mut status = 0 as c_int;\n-        try!(cvt(retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) })));\n+        try!(cvt_r(|| unsafe { c::waitpid(self.pid, &mut status, 0) }));\n         Ok(translate_status(status))\n     }\n \n     pub fn try_wait(&self) -> Option<ExitStatus> {\n         let mut status = 0 as c_int;\n-        match retry(|| unsafe {\n+        match cvt_r(|| unsafe {\n             c::waitpid(self.pid, &mut status, c::WNOHANG)\n         }) {\n-            n if n == self.pid => Some(translate_status(status)),\n-            0 => None,\n-            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n-                       io::Error::last_os_error()),\n+            Ok(0) => None,\n+            Ok(n) if n == self.pid => Some(translate_status(status)),\n+            Ok(n) => panic!(\"unkown pid: {}\", n),\n+            Err(e) => panic!(\"unknown waitpid error: {}\", e),\n         }\n     }\n }"}, {"sha": "c65377e238f8fb589fe2d6125970fe050b612dec", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -497,15 +497,6 @@ pub fn sleep_ms(ms: u32) {\n     imp::sleep(Duration::milliseconds(ms as i64))\n }\n \n-/// Deprecated: use `sleep_ms` instead.\n-#[unstable(feature = \"thread_sleep\",\n-           reason = \"recently added, needs an RFC, and `Duration` itself is \\\n-                     unstable\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use sleep_ms instead\")]\n-pub fn sleep(dur: Duration) {\n-    imp::sleep(dur)\n-}\n-\n /// Blocks unless or until the current thread's token is made available (may wake spuriously).\n ///\n /// See the module doc for more detail.\n@@ -546,13 +537,6 @@ pub fn park_timeout_ms(ms: u32) {\n     *guard = false;\n }\n \n-/// Deprecated: use `park_timeout_ms`\n-#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use park_timeout_ms instead\")]\n-pub fn park_timeout(duration: Duration) {\n-    park_timeout_ms(duration.num_milliseconds() as u32)\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Thread\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "636a0dd697a2bb6003f0a15d87e9f1e2f09bfdd2", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -12,13 +12,10 @@\n \n #![unstable(feature = \"std_misc\")]\n \n+use prelude::v1::*;\n+\n use {fmt, i64};\n-use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n-use option::Option;\n-use option::Option::{Some, None};\n-#[allow(deprecated)] // Int\n-use num::Int;\n-use result::Result::Ok;\n+use ops::{Add, Sub, Mul, Div, Neg};\n \n /// The number of nanoseconds in a microsecond.\n const NANOS_PER_MICRO: i32 = 1000;"}, {"sha": "399810cb7f5010ae6d6a4042efadd15bbd347e1e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -66,8 +66,6 @@ use parse::lexer;\n use ptr::P;\n \n use std::fmt;\n-#[allow(deprecated)]\n-use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -1142,16 +1140,24 @@ pub enum Sign {\n }\n \n impl Sign {\n-    #[allow(deprecated)] // Int\n-    pub fn new<T:Int>(n: T) -> Sign {\n-        if n < Int::zero() {\n-            Minus\n-        } else {\n-            Plus\n-        }\n+    pub fn new<T: IntSign>(n: T) -> Sign {\n+        n.sign()\n     }\n }\n \n+pub trait IntSign {\n+    fn sign(&self) -> Sign;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl IntSign for $t {\n+        #[allow(unused_comparisons)]\n+        fn sign(&self) -> Sign {\n+            if *self < 0 {Minus} else {Plus}\n+        }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LitIntType {\n     SignedIntLit(IntTy, Sign),"}, {"sha": "835d0395199e4362b3ae6f62848f10ccfe303289", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -20,7 +20,6 @@\n pub use self::MacroFormat::*;\n \n use std::cell::RefCell;\n-use std::num::ToPrimitive;\n use std::ops::{Add, Sub};\n use std::rc::Rc;\n \n@@ -862,7 +861,11 @@ impl CodeMap {\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);\n-        ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n+        let len = expansions.len();\n+        if len > u32::max_value() as usize {\n+            panic!(\"too many ExpnInfo's!\");\n+        }\n+        ExpnId(len as u32 - 1)\n     }\n \n     pub fn with_expn_info<T, F>(&self, id: ExpnId, f: F) -> T where"}, {"sha": "f4b108c435276c52bfc835fbde6e5e8a14b8b2d5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -22,8 +22,6 @@ use std::cell::{Cell, RefCell};\n use std::fs::File;\n use std::io::Read;\n use std::iter;\n-#[allow(deprecated)] // Int\n-use std::num::Int;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;"}, {"sha": "4532f5d65d870f580303eab96fad112d0e80fb42", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -75,7 +75,6 @@ use std::fs::File;\n use std::io::prelude::*;\n use std::io;\n use std::iter::repeat;\n-use std::num::{Float, Int};\n use std::path::PathBuf;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n@@ -413,7 +412,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n #[derive(Clone, PartialEq)]\n pub struct BenchSamples {\n-    ns_iter_summ: stats::Summary<f64>,\n+    ns_iter_summ: stats::Summary,\n     mb_s: usize,\n }\n \n@@ -1066,7 +1065,7 @@ impl Bencher {\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary<f64> where F: FnMut(&mut Bencher) {\n+    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary where F: FnMut(&mut Bencher) {\n         // Initial bench run to get ballpark figure.\n         let mut n = 1;\n         self.bench_n(n, |x| f(x));"}, {"sha": "341be762601dd856ff903e25c2727a4247b3c9df", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 73, "deletions": 74, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb94886adccb3f13003f92f117115d17846ce1f/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=eeb94886adccb3f13003f92f117115d17846ce1f", "patch": "@@ -13,9 +13,8 @@\n \n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::mem;\n-use std::num::{Float, FromPrimitive};\n \n-fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n+fn local_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n     if y.is_nan() {\n         Less\n@@ -30,37 +29,37 @@ fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     }\n }\n \n-fn local_sort<T: Float>(v: &mut [T]) {\n-    v.sort_by(|x: &T, y: &T| local_cmp(*x, *y));\n+fn local_sort(v: &mut [f64]) {\n+    v.sort_by(|x: &f64, y: &f64| local_cmp(*x, *y));\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: Float + FromPrimitive> {\n+pub trait Stats {\n \n     /// Sum of the samples.\n     ///\n     /// Note: this method sacrifices performance at the altar of accuracy\n     /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n     /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n-    fn sum(&self) -> T;\n+    fn sum(&self) -> f64;\n \n     /// Minimum value of the samples.\n-    fn min(&self) -> T;\n+    fn min(&self) -> f64;\n \n     /// Maximum value of the samples.\n-    fn max(&self) -> T;\n+    fn max(&self) -> f64;\n \n     /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n-    fn mean(&self) -> T;\n+    fn mean(&self) -> f64;\n \n     /// Median of the samples: value separating the lower half of the samples from the higher half.\n     /// Equal to `self.percentile(50.0)`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Median\n-    fn median(&self) -> T;\n+    fn median(&self) -> f64;\n \n     /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n     /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n@@ -69,21 +68,21 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// than `n`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Variance\n-    fn var(&self) -> T;\n+    fn var(&self) -> f64;\n \n     /// Standard deviation: the square root of the sample variance.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev` for unknown distributions.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Standard_deviation\n-    fn std_dev(&self) -> T;\n+    fn std_dev(&self) -> f64;\n \n     /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev_pct` for unknown distributions.\n-    fn std_dev_pct(&self) -> T;\n+    fn std_dev_pct(&self) -> f64;\n \n     /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n     /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n@@ -92,10 +91,10 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// deviation.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n-    fn median_abs_dev(&self) -> T;\n+    fn median_abs_dev(&self) -> f64;\n \n     /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n-    fn median_abs_dev_pct(&self) -> T;\n+    fn median_abs_dev_pct(&self) -> f64;\n \n     /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n     /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n@@ -104,44 +103,44 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// Calculated by linear interpolation between closest ranks.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Percentile\n-    fn percentile(&self, pct: T) -> T;\n+    fn percentile(&self, pct: f64) -> f64;\n \n     /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n     /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n     /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n     /// is otherwise equivalent.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Quartile\n-    fn quartiles(&self) -> (T,T,T);\n+    fn quartiles(&self) -> (f64,f64,f64);\n \n     /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n     /// percentile (3rd quartile). See `quartiles`.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n-    fn iqr(&self) -> T;\n+    fn iqr(&self) -> f64;\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n #[derive(Clone, PartialEq)]\n #[allow(missing_docs)]\n-pub struct Summary<T> {\n-    pub sum: T,\n-    pub min: T,\n-    pub max: T,\n-    pub mean: T,\n-    pub median: T,\n-    pub var: T,\n-    pub std_dev: T,\n-    pub std_dev_pct: T,\n-    pub median_abs_dev: T,\n-    pub median_abs_dev_pct: T,\n-    pub quartiles: (T,T,T),\n-    pub iqr: T,\n+pub struct Summary {\n+    pub sum: f64,\n+    pub min: f64,\n+    pub max: f64,\n+    pub mean: f64,\n+    pub median: f64,\n+    pub var: f64,\n+    pub std_dev: f64,\n+    pub std_dev_pct: f64,\n+    pub median_abs_dev: f64,\n+    pub median_abs_dev_pct: f64,\n+    pub quartiles: (f64,f64,f64),\n+    pub iqr: f64,\n }\n \n-impl<T: Float + FromPrimitive> Summary<T> {\n+impl Summary {\n     /// Construct a new summary of a sample set.\n-    pub fn new(samples: &[T]) -> Summary<T> {\n+    pub fn new(samples: &[f64]) -> Summary {\n         Summary {\n             sum: samples.sum(),\n             min: samples.min(),\n@@ -159,9 +158,9 @@ impl<T: Float + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<T: Float + FromPrimitive> Stats<T> for [T] {\n+impl Stats for [f64] {\n     // FIXME #11059 handle NaN, inf and overflow\n-    fn sum(&self) -> T {\n+    fn sum(&self) -> f64 {\n         let mut partials = vec![];\n \n         for &x in self {\n@@ -170,15 +169,15 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n             for i in 0..partials.len() {\n-                let mut y: T = partials[i];\n+                let mut y: f64 = partials[i];\n                 if x.abs() < y.abs() {\n                     mem::swap(&mut x, &mut y);\n                 }\n                 // Rounded `x+y` is stored in `hi` with round-off stored in\n                 // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n-                if lo != Float::zero() {\n+                if lo != 0.0 {\n                     partials[j] = lo;\n                     j += 1;\n                 }\n@@ -191,89 +190,89 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n                 partials.truncate(j+1);\n             }\n         }\n-        let zero: T = Float::zero();\n+        let zero: f64 = 0.0;\n         partials.iter().fold(zero, |p, q| p + *q)\n     }\n \n-    fn min(&self) -> T {\n+    fn min(&self) -> f64 {\n         assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.min(*q))\n     }\n \n-    fn max(&self) -> T {\n+    fn max(&self) -> f64 {\n         assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.max(*q))\n     }\n \n-    fn mean(&self) -> T {\n+    fn mean(&self) -> f64 {\n         assert!(!self.is_empty());\n-        self.sum() / FromPrimitive::from_usize(self.len()).unwrap()\n+        self.sum() / (self.len() as f64)\n     }\n \n-    fn median(&self) -> T {\n-        self.percentile(FromPrimitive::from_usize(50).unwrap())\n+    fn median(&self) -> f64 {\n+        self.percentile(50 as f64)\n     }\n \n-    fn var(&self) -> T {\n+    fn var(&self) -> f64 {\n         if self.len() < 2 {\n-            Float::zero()\n+            0.0\n         } else {\n             let mean = self.mean();\n-            let mut v: T = Float::zero();\n+            let mut v: f64 = 0.0;\n             for s in self {\n                 let x = *s - mean;\n                 v = v + x*x;\n             }\n             // NB: this is _supposed to be_ len-1, not len. If you\n             // change it back to len, you will be calculating a\n             // population variance, not a sample variance.\n-            let denom = FromPrimitive::from_usize(self.len()-1).unwrap();\n+            let denom = (self.len() - 1) as f64;\n             v/denom\n         }\n     }\n \n-    fn std_dev(&self) -> T {\n+    fn std_dev(&self) -> f64 {\n         self.var().sqrt()\n     }\n \n-    fn std_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_usize(100).unwrap();\n+    fn std_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n         (self.std_dev() / self.mean()) * hundred\n     }\n \n-    fn median_abs_dev(&self) -> T {\n+    fn median_abs_dev(&self) -> f64 {\n         let med = self.median();\n-        let abs_devs: Vec<T> = self.iter().map(|&v| (med - v).abs()).collect();\n+        let abs_devs: Vec<f64> = self.iter().map(|&v| (med - v).abs()).collect();\n         // This constant is derived by smarter statistics brains than me, but it is\n         // consistent with how R and other packages treat the MAD.\n-        let number = FromPrimitive::from_f64(1.4826).unwrap();\n+        let number = 1.4826;\n         abs_devs.median() * number\n     }\n \n-    fn median_abs_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_usize(100).unwrap();\n+    fn median_abs_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n         (self.median_abs_dev() / self.median()) * hundred\n     }\n \n-    fn percentile(&self, pct: T) -> T {\n+    fn percentile(&self, pct: f64) -> f64 {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n         percentile_of_sorted(&tmp, pct)\n     }\n \n-    fn quartiles(&self) -> (T,T,T) {\n+    fn quartiles(&self) -> (f64,f64,f64) {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n-        let first = FromPrimitive::from_usize(25).unwrap();\n+        let first = 25f64;\n         let a = percentile_of_sorted(&tmp, first);\n-        let secound = FromPrimitive::from_usize(50).unwrap();\n+        let secound = 50f64;\n         let b = percentile_of_sorted(&tmp, secound);\n-        let third = FromPrimitive::from_usize(75).unwrap();\n+        let third = 75f64;\n         let c = percentile_of_sorted(&tmp, third);\n         (a,b,c)\n     }\n \n-    fn iqr(&self) -> T {\n+    fn iqr(&self) -> f64 {\n         let (a,_,c) = self.quartiles();\n         c - a\n     }\n@@ -282,41 +281,41 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n \n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n-fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n-                                                             pct: T) -> T {\n+fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n     assert!(!sorted_samples.is_empty());\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }\n-    let zero: T = Float::zero();\n+    let zero: f64 = 0.0;\n     assert!(zero <= pct);\n-    let hundred = FromPrimitive::from_usize(100).unwrap();\n+    let hundred = 100f64;\n     assert!(pct <= hundred);\n     if pct == hundred {\n         return sorted_samples[sorted_samples.len() - 1];\n     }\n-    let length = FromPrimitive::from_usize(sorted_samples.len() - 1).unwrap();\n+    let length = (sorted_samples.len() - 1) as f64;\n     let rank = (pct / hundred) * length;\n     let lrank = rank.floor();\n     let d = rank - lrank;\n-    let n = lrank.to_usize().unwrap();\n+    let n = lrank as usize;\n     let lo = sorted_samples[n];\n     let hi = sorted_samples[n+1];\n     lo + (hi - lo) * d\n }\n \n \n-/// Winsorize a set of samples, replacing values above the `100-pct` percentile and below the `pct`\n-/// percentile with those percentiles themselves. This is a way of minimizing the effect of\n-/// outliers, at the cost of biasing the sample. It differs from trimming in that it does not\n-/// change the number of samples, just changes the values of those that are outliers.\n+/// Winsorize a set of samples, replacing values above the `100-pct` percentile\n+/// and below the `pct` percentile with those percentiles themselves. This is a\n+/// way of minimizing the effect of outliers, at the cost of biasing the sample.\n+/// It differs from trimming in that it does not change the number of samples,\n+/// just changes the values of those that are outliers.\n ///\n /// See: http://en.wikipedia.org/wiki/Winsorising\n-pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n+pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_vec();\n     local_sort(&mut tmp);\n     let lo = percentile_of_sorted(&tmp, pct);\n-    let hundred: T = FromPrimitive::from_usize(100).unwrap();\n+    let hundred = 100 as f64;\n     let hi = percentile_of_sorted(&tmp, hundred-pct);\n     for samp in samples {\n         if *samp > hi {"}]}