{"sha": "c90f68224b069f5bb2a80e30e2737e4bb17c1466", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MGY2ODIyNGIwNjlmNWJiMmE4MGUzMGUyNzM3ZTRiYjE3YzE0NjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-08T08:52:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-08T08:52:23Z"}, "message": "Auto merge of #46882 - oli-obk:miri3, r=eddyb\n\nReplace all const evaluation with miri\n\n* error reporting in constants prints a stacktrace through all called const fns\n* Trivial constant propagation and folding in MIR (always active, irrelevant of the optimization level)\n* can now use floating constants in patterns (previously only floating point literals were allowed)\n    * the future compat lint is still produced for both cases\n* can index into constant arrays during const eval (previously feature gated)\n* can create a constant union value with field `a` and read from field `b`\n* can dereference references into constants\n* can create references inside constants (`const X: &u32 = &22`)\n* Tuple struct constructors can be used in constants\n* regression in const eval errors spans (some of these need improvements in mir debug info)\n* can cast floats to ints and vice versa (in constants, and even nan/inf constants)\n* Mir dump prints false/true instead of 0u8/1u8\n* `1i8 >> [8][0]` does not lint about exceeding bitshifts anymore.\n    * Needs const propagation across projections\n* `foo[I]` produces a const eval lint if `foo: [T; N]` and `N < I`\n    * Essentially all builtin panics produce lints if they can be statically proven to trigger at runtime. This is on a best effort basis, so there might be some complex cases that don't trigger. (The runtime panic stays there, irrelevant of whether the lint is produced or not)\n* can use `union`s to implement `transmute` for `Copy` types in constants without a feature gate. With all the greatness and nasal demons that come with this.\n* can convert integers to `&'static T` in constants (useful for embedded)\n\nfixes #34997 (stack overflow with many constants)\nfixes #25574 (deref byte strings in patterns)\nfixes #27918 (broken mir ICE)\nfixes #46114 (ICE on struct constructors in patterns)\nfixes #37448 (`SomeStruct { foo } as SomeStruct`)\nfixes #43754 (`return` in const fn)\nfixes #41898 (tuple struct constructors)\nfixes #31364 (infinite recursion with const fn, fixed by miri's recursion limit)\ncloses #29947 (const indexing stabilization)\nfixes #45044 (pattern matching repeat expressions)\nfixes #47971 (ICE on const fn + references)\nfixes #48081 (ICE on cyclic assoc const error)\nfixes #48746 (nonhelpful error message with unions)\n\nr? @eddyb\n\neven though 1k loc are added in tests, this PR reduces the loc in this repository by 700", "tree": {"sha": "f2f6522832596d658d2644411abfcbdd1840b829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2f6522832596d658d2644411abfcbdd1840b829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c90f68224b069f5bb2a80e30e2737e4bb17c1466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c90f68224b069f5bb2a80e30e2737e4bb17c1466", "html_url": "https://github.com/rust-lang/rust/commit/c90f68224b069f5bb2a80e30e2737e4bb17c1466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c90f68224b069f5bb2a80e30e2737e4bb17c1466/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcca786468a71375584bb48e3093790c91084f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcca786468a71375584bb48e3093790c91084f7", "html_url": "https://github.com/rust-lang/rust/commit/cdcca786468a71375584bb48e3093790c91084f7"}, {"sha": "52dec0e1c9e0fe5bbbe81385531e69c2c46ef56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52dec0e1c9e0fe5bbbe81385531e69c2c46ef56e", "html_url": "https://github.com/rust-lang/rust/commit/52dec0e1c9e0fe5bbbe81385531e69c2c46ef56e"}], "stats": {"total": 13804, "additions": 6638, "deletions": 7166}, "files": [{"sha": "34c077a6f7a0362da3938d9cd6f59e443d9cc183", "filename": "src/Cargo.lock", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1858,20 +1858,6 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_const_eval\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"arena 0.0.0\",\n- \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n- \"rustc_data_structures 0.0.0\",\n- \"rustc_errors 0.0.0\",\n- \"syntax 0.0.0\",\n- \"syntax_pos 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc_const_math\"\n version = \"0.0.0\"\n@@ -1914,7 +1900,6 @@ dependencies = [\n  \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n- \"rustc_const_eval 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n@@ -1964,7 +1949,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_const_eval 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -2012,6 +1997,7 @@ dependencies = [\n name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arena 0.0.0\",\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n@@ -2020,7 +2006,6 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -2046,10 +2031,10 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "b62762ef69e0136e61975ad92df73df6e23e8fd1", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -64,7 +64,6 @@ for details on how to format and write long error codes.\n   [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/diagnostics.rs),\n   [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/diagnostics.rs),\n   [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/diagnostics.rs),\n-  [librustc_const_eval](https://github.com/rust-lang/rust/blob/master/src/librustc_const_eval/diagnostics.rs),\n   [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/diagnostics.rs),\n   [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/diagnostics.rs),\n   [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),"}, {"sha": "42d46ce15f676e552025619097bd9c90c17730e3", "filename": "src/doc/unstable-book/src/language-features/const-indexing.md", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,19 +0,0 @@\n-# `const_indexing`\n-\n-The tracking issue for this feature is: [#29947]\n-\n-[#29947]: https://github.com/rust-lang/rust/issues/29947\n-\n-------------------------\n-\n-The `const_indexing` feature allows the constant evaluation of index operations\n-on constant arrays and repeat expressions.\n-\n-## Examples\n-\n-```rust\n-#![feature(const_indexing)]\n-\n-const ARR: [usize; 5] = [1, 2, 3, 4, 5];\n-const ARR2: [usize; ARR[1]] = [42, 99];\n-```\n\\ No newline at end of file"}, {"sha": "6602643dc5106f6101b575b214851777dade3760", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -427,6 +427,7 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n+#[cfg_attr(not(stage0), lang = \"ord\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an `Ordering` between `self` and `other`.\n@@ -596,7 +597,8 @@ impl PartialOrd for Ordering {\n /// assert_eq!(x < y, true);\n /// assert_eq!(x.lt(&y), true);\n /// ```\n-#[lang = \"ord\"]\n+#[cfg_attr(stage0, lang = \"ord\")]\n+#[cfg_attr(not(stage0), lang = \"partial_ord\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {"}, {"sha": "7d8709a82f4d386af6256aa0710663a869111185", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -60,15 +60,15 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n+use mir::interpret::{GlobalId};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n-use ich::Fingerprint;\n+use ich::{Fingerprint, StableHashingContext};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n use ty::subst::Substs;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use ich::StableHashingContext;\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n@@ -518,7 +518,7 @@ define_dep_nodes!( <'tcx>\n     [] TypeckTables(DefId),\n     [] UsedTraitImports(DefId),\n     [] HasTypeckTables(DefId),\n-    [] ConstEval { param_env: ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)> },\n+    [] ConstEval { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n     [] CheckMatch(DefId),\n     [] SymbolName(DefId),\n     [] InstanceSymbolName { instance: Instance<'tcx> },\n@@ -661,7 +661,7 @@ trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'gcx>> + fmt::Debug\n+    where T: HashStable<StableHashingContext<'a>> + fmt::Debug\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "b3a904f2f5fec520598714aee8882b5642f33c12", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -14,19 +14,6 @@\n // Each message should start and end with a new line, and be wrapped to 80 characters.\n // In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n-E0020: r##\"\n-This error indicates that an attempt was made to divide by zero (or take the\n-remainder of a zero divisor) in a static or constant expression. Erroneous\n-code example:\n-\n-```compile_fail\n-#[deny(const_err)]\n-\n-const X: i32 = 42 / 0;\n-// error: attempt to divide by zero in a constant expression\n-```\n-\"##,\n-\n E0038: r##\"\n Trait objects like `Box<Trait>` can only be constructed when certain\n requirements are satisfied by the trait in question."}, {"sha": "34b3aa53d6bcf807e0e818ad4eef538128942bfb", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -220,7 +220,6 @@ impl serialize::UseSpecializedDecodable for DefId {}\n pub struct LocalDefId(DefIndex);\n \n impl LocalDefId {\n-\n     #[inline]\n     pub fn from_def_id(def_id: DefId) -> LocalDefId {\n         assert!(def_id.is_local());"}, {"sha": "3c523f5633e114fd9d405bff4f4ea10a07f71fa7", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -529,7 +529,7 @@ struct HirItemLike<T> {\n     hash_bodies: bool,\n }\n \n-impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n+impl<'a, 'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n     where T: HashStable<StableHashingContext<'hir>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "6ae588b2a07b657229b3c1310e0cf3ce22954b40", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -46,19 +46,19 @@ pub fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n #[derive(Clone)]\n-pub struct StableHashingContext<'gcx> {\n-    sess: &'gcx Session,\n-    definitions: &'gcx Definitions,\n-    cstore: &'gcx dyn CrateStore,\n-    body_resolver: BodyResolver<'gcx>,\n+pub struct StableHashingContext<'a> {\n+    sess: &'a Session,\n+    definitions: &'a Definitions,\n+    cstore: &'a dyn CrateStore,\n+    body_resolver: BodyResolver<'a>,\n     hash_spans: bool,\n     hash_bodies: bool,\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n     // CachingCodemapView, so we initialize it lazily.\n-    raw_codemap: &'gcx CodeMap,\n-    caching_codemap: Option<CachingCodemapView<'gcx>>,\n+    raw_codemap: &'a CodeMap,\n+    caching_codemap: Option<CachingCodemapView<'a>>,\n }\n \n #[derive(PartialEq, Eq, Clone, Copy)]\n@@ -81,14 +81,14 @@ impl<'gcx> BodyResolver<'gcx> {\n     }\n }\n \n-impl<'gcx> StableHashingContext<'gcx> {\n+impl<'a> StableHashingContext<'a> {\n     // The `krate` here is only used for mapping BodyIds to Bodies.\n     // Don't use it for anything else or you'll run the risk of\n     // leaking data out of the tracking system.\n-    pub fn new(sess: &'gcx Session,\n-               krate: &'gcx hir::Crate,\n-               definitions: &'gcx Definitions,\n-               cstore: &'gcx dyn CrateStore)\n+    pub fn new(sess: &'a Session,\n+               krate: &'a hir::Crate,\n+               definitions: &'a Definitions,\n+               cstore: &'a dyn CrateStore)\n                -> Self {\n         let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n \n@@ -106,7 +106,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n     }\n \n     #[inline]\n-    pub fn sess(&self) -> &'gcx Session {\n+    pub fn sess(&self) -> &'a Session {\n         self.sess\n     }\n \n@@ -165,7 +165,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'gcx> {\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'a> {\n         match self.caching_codemap {\n             Some(ref mut cm) => {\n                 cm\n@@ -193,38 +193,38 @@ impl<'gcx> StableHashingContext<'gcx> {\n }\n \n impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n-    type ContextType = StableHashingContext<'gcx>;\n+    type ContextType = StableHashingContext<'a>;\n     fn create_stable_hashing_context(&self) -> Self::ContextType {\n         (*self).create_stable_hashing_context()\n     }\n }\n \n \n-impl<'gcx> StableHashingContextProvider for StableHashingContext<'gcx> {\n-    type ContextType = StableHashingContext<'gcx>;\n+impl<'a> StableHashingContextProvider for StableHashingContext<'a> {\n+    type ContextType = StableHashingContext<'a>;\n     fn create_stable_hashing_context(&self) -> Self::ContextType {\n         self.clone()\n     }\n }\n \n-impl<'gcx> ::dep_graph::DepGraphSafe for StableHashingContext<'gcx> {\n+impl<'a> ::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n }\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         if hcx.hash_bodies() {\n             hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::HirId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -243,21 +243,21 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::HirId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let def_path_hash = hcx.local_def_path_hash(self.owner);\n         (def_path_hash, self.local_id)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -270,18 +270,18 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::NodeId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         hcx.definitions.node_to_hir_id(*self).to_stable_hash_key(hcx)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n+impl<'a> HashStable<StableHashingContext<'a>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -293,7 +293,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         const TAG_VALID_SPAN: u8 = 0;\n         const TAG_INVALID_SPAN: u8 = 1;\n@@ -373,8 +373,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_trait_impls<'gcx, W, R>(\n-    hcx: &mut StableHashingContext<'gcx>,\n+pub fn hash_stable_trait_impls<'a, 'gcx, W, R>(\n+    hcx: &mut StableHashingContext<'a>,\n     hasher: &mut StableHasher<W>,\n     blanket_impls: &Vec<DefId>,\n     non_blanket_impls: &HashMap<fast_reject::SimplifiedType, Vec<DefId>, R>)"}, {"sha": "5f3ff461c0c7ec5a28309a77c093c019c9e6bc5f", "filename": "src/librustc/ich/impls_const_math.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,33 +16,6 @@ impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n     bits\n });\n \n-impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {\n-    I8(val),\n-    I16(val),\n-    I32(val),\n-    I64(val),\n-    I128(val),\n-    Isize(val),\n-    U8(val),\n-    U16(val),\n-    U32(val),\n-    U64(val),\n-    U128(val),\n-    Usize(val)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstIsize {\n-    Is16(i16),\n-    Is32(i32),\n-    Is64(i64)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstUsize {\n-    Us16(i16),\n-    Us32(i32),\n-    Us64(i64)\n-});\n-\n impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n     NotInRange,\n     CmpBetweenUnequalTypes,"}, {"sha": "c085b803085a853bb1eacbf6d630c577b0a28f86", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -21,46 +21,46 @@ use std::mem;\n use syntax::ast;\n use syntax::attr;\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n+impl<'a> HashStable<StableHashingContext<'a>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for DefId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for DefId {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         hcx.def_path_hash(*self)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LocalDefId {\n+impl<'a> HashStable<StableHashingContext<'a>> for LocalDefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(self.to_def_id()).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for LocalDefId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalDefId {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         hcx.def_path_hash(self.to_def_id())\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n+impl<'a> HashStable<StableHashingContext<'a>> for CrateNum {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(DefId {\n             krate: *self,\n@@ -69,25 +69,25 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for CrateNum {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for CrateNum {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         def_id.to_stable_hash_key(hcx)\n     }\n }\n \n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::ItemLocalId {\n     type KeyType = hir::ItemLocalId;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> hir::ItemLocalId {\n         *self\n     }\n@@ -100,9 +100,9 @@ for hir::ItemLocalId {\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -114,9 +114,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -128,9 +128,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -271,9 +271,9 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Ty {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n@@ -339,9 +339,9 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitRef {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n@@ -376,9 +376,9 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n@@ -400,9 +400,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Pat {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Pat {\n             id: _,\n@@ -527,9 +527,9 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Expr {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n@@ -591,9 +591,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::MatchSource {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -647,9 +647,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -660,9 +660,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id: _,\n@@ -695,9 +695,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id: _,\n@@ -729,9 +729,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -750,9 +750,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Defaultness {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -771,9 +771,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Mod {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -826,9 +826,9 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Item {\n             name,\n@@ -885,10 +885,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -930,9 +930,9 @@ impl_stable_hash_for!(struct hir::Arg {\n     hir_id\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n             ref arguments,\n@@ -948,12 +948,12 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::BodyId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let hir::BodyId { node_id } = *self;\n         node_id.to_stable_hash_key(hcx)\n@@ -966,9 +966,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -979,9 +979,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::InlineAsm {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1062,22 +1062,22 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::def_id::DefIndex {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n          hcx.local_def_path_hash(*self)\n     }\n }\n@@ -1090,10 +1090,10 @@ impl_stable_hash_for!(struct hir::def::Export {\n     is_import\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n@@ -1104,10 +1104,10 @@ impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n     missing\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let hir::TraitCandidate {\n@@ -1121,11 +1121,11 @@ for hir::TraitCandidate {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     type KeyType = (DefPathHash, Option<(DefPathHash, hir::ItemLocalId)>);\n \n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> Self::KeyType {\n         let hir::TraitCandidate {\n             def_id,"}, {"sha": "1e6dadae363717729d0e567fdd07686f965d725e", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -35,11 +35,11 @@ impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator,\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::BorrowKind {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -54,11 +54,11 @@ for mir::BorrowKind {\n }\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::UnsafetyViolationKind {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -79,12 +79,12 @@ impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n     source_info\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearCrossCrate<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for mir::ClearCrossCrate<T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -96,61 +96,61 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearCrossCrate<T>\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Local {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::BasicBlock {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Field {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Promoted {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::TerminatorKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -227,10 +227,10 @@ for mir::TerminatorKind<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::AssertMessage<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -250,10 +250,10 @@ for mir::AssertMessage<'gcx> {\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::StatementKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -287,12 +287,12 @@ for mir::StatementKind<'gcx> {\n     }\n }\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n     for mir::ValidationOperand<'gcx, T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>)\n     {\n         self.place.hash_stable(hcx, hasher);\n@@ -304,9 +304,9 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n \n impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -323,14 +323,14 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n     }\n }\n \n-impl<'gcx, B, V, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, B, V, T> HashStable<StableHashingContext<'a>>\n for mir::Projection<'gcx, B, V, T>\n-    where B: HashStable<StableHashingContext<'gcx>>,\n-          V: HashStable<StableHashingContext<'gcx>>,\n-          T: HashStable<StableHashingContext<'gcx>>\n+    where B: HashStable<StableHashingContext<'a>>,\n+          V: HashStable<StableHashingContext<'a>>,\n+          T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -342,13 +342,13 @@ for mir::Projection<'gcx, B, V, T>\n     }\n }\n \n-impl<'gcx, V, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, V, T> HashStable<StableHashingContext<'a>>\n for mir::ProjectionElem<'gcx, V, T>\n-    where V: HashStable<StableHashingContext<'gcx>>,\n-          T: HashStable<StableHashingContext<'gcx>>\n+    where V: HashStable<StableHashingContext<'a>>,\n+          T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -382,9 +382,9 @@ impl_stable_hash_for!(struct mir::VisibilityScopeInfo {\n     lint_root, safety\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Safety {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -399,9 +399,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -419,9 +419,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Rvalue<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Rvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -479,10 +479,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::AggregateKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -541,9 +541,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Literal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -570,9 +570,9 @@ impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n     blame_span\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::ClosureOutlivesSubject<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubject<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -585,3 +585,5 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::ClosureOutlivesSubjec\n         }\n     }\n }\n+\n+impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });"}, {"sha": "52f43fbed7b0acb3e8f255afebb7153847df042b", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -29,42 +29,42 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for InternedString {\n+impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for InternedString {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> InternedString {\n         self.clone()\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Name {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::Name {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::Name {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> InternedString {\n         self.as_str()\n     }\n@@ -111,10 +111,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     rustc_const_unstable\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -166,9 +166,9 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n+impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         if self.len() == 0 {\n             self.len().hash_stable(hcx, hasher);\n@@ -191,9 +191,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -220,10 +220,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -242,20 +242,22 @@ for tokenstream::TokenTree {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n-                                           hcx: &mut StableHashingContext<'gcx>,\n-                                           hasher: &mut StableHasher<W>) {\n+fn hash_token<'a, 'gcx, W: StableHasherResult>(\n+    token: &token::Token,\n+    hcx: &mut StableHashingContext<'a>,\n+    hasher: &mut StableHasher<W>,\n+) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n     match *token {\n         token::Token::Eq |\n@@ -383,9 +385,9 @@ impl_stable_hash_for!(enum ::syntax_pos::FileName {\n     Custom(s)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             name: _, // We hash the smaller name_hash instead of this"}, {"sha": "d927a151610ef88e401092139b58b0c17cda9b28", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 331, "deletions": 139, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -21,12 +21,13 @@ use std::mem;\n use middle::region;\n use traits;\n use ty;\n+use mir;\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for &'gcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'gcx>> {\n+    where T: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<(usize, usize), Fingerprint>> =\n@@ -51,19 +52,19 @@ for &'gcx ty::Slice<T>\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.unpack().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::subst::UnpackedKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         match self {\n             ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n@@ -72,10 +73,10 @@ for ty::subst::UnpackedKind<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -119,20 +120,20 @@ for ty::RegionKind {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::RegionVid {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -147,10 +148,10 @@ for ty::adjustment::AutoBorrow<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::Adjust<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -196,10 +197,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::UpvarCapture<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -223,11 +224,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Binder(ref inner) = *self;\n         inner.hash_stable(hcx, hasher);\n@@ -246,13 +247,13 @@ impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'gcx, A, B> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, A, B> HashStable<StableHashingContext<'a>>\n for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'gcx>>,\n-          B: HashStable<StableHashingContext<'gcx>>,\n+    where A: HashStable<StableHashingContext<'a>>,\n+          B: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -264,9 +265,9 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::Predicate<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -304,9 +305,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::AdtFlags {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -331,69 +332,102 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal::*;\n-        use middle::const_val::ConstAggregate::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Integral(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Float(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Str(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            ByteStr(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Bool(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Char(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Variant(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            Function(def_id, substs) => {\n+            Unevaluated(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    substs.hash_stable(hcx, hasher);\n-                });\n-            }\n-            Aggregate(Struct(ref name_values)) => {\n-                let mut values = name_values.to_vec();\n-                values.sort_unstable_by_key(|&(ref name, _)| name.clone());\n-                values.hash_stable(hcx, hasher);\n-            }\n-            Aggregate(Tuple(ref value)) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Aggregate(Array(ref value)) => {\n-                value.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n             }\n-            Aggregate(Repeat(ref value, times)) => {\n+            Value(ref value) => {\n                 value.hash_stable(hcx, hasher);\n-                times.hash_stable(hcx, hasher);\n             }\n-            Unevaluated(def_id, substs) => {\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::interpret::Value {\n+    ByVal(v),\n+    ByValPair(a, b),\n+    ByRef(ptr, align)\n+});\n+\n+impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n+    alloc_id,\n+    offset\n+});\n+\n+enum AllocDiscriminant {\n+    Static,\n+    Constant,\n+    Function,\n+}\n+impl_stable_hash_for!(enum self::AllocDiscriminant {\n+    Static,\n+    Constant,\n+    Function\n+});\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        ty::tls::with_opt(|tcx| {\n+            let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n+            if let Some(def_id) = tcx.interpret_interner.get_corresponding_static_def_id(*self) {\n+                AllocDiscriminant::Static.hash_stable(hcx, hasher);\n+                // statics are unique via their DefId\n                 def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n+            } else if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n+                // not a static, can't be recursive, hash the allocation\n+                AllocDiscriminant::Constant.hash_stable(hcx, hasher);\n+                alloc.hash_stable(hcx, hasher);\n+            } else if let Some(inst) = tcx.interpret_interner.get_fn(*self) {\n+                AllocDiscriminant::Function.hash_stable(hcx, hasher);\n+                inst.hash_stable(hcx, hasher);\n+            } else {\n+                bug!(\"no allocation for {}\", self);\n             }\n+        });\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        self.bytes.hash_stable(hcx, hasher);\n+        for reloc in self.relocations.iter() {\n+            reloc.hash_stable(hcx, hasher);\n         }\n+        self.undef_mask.hash_stable(hcx, hasher);\n+        self.align.hash_stable(hcx, hasher);\n+        self.runtime_mutability.hash_stable(hcx, hasher);\n     }\n }\n \n-impl_stable_hash_for!(struct ::middle::const_val::ByteArray<'tcx> {\n-    data\n+impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n+    Immutable,\n+    Mutable\n+});\n+\n+impl_stable_hash_for!(struct mir::interpret::Pointer{primval});\n+\n+impl_stable_hash_for!(enum mir::interpret::PrimVal {\n+    Bytes(b),\n+    Ptr(p),\n+    Undef\n });\n \n impl_stable_hash_for!(struct ty::Const<'tcx> {\n@@ -406,26 +440,22 @@ impl_stable_hash_for!(struct ::middle::const_val::ConstEvalErr<'tcx> {\n     kind\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl_stable_hash_for!(struct ::middle::const_val::FrameInfo {\n+    span,\n+    location\n+});\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ErrKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ErrKind::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            CannotCast |\n-            MissingStructField |\n             NonConstPath |\n-            ExpectedConstTuple |\n-            ExpectedConstStruct |\n-            IndexedNonVec |\n-            IndexNotUsize |\n-            MiscBinaryOp |\n-            MiscCatchAll |\n-            IndexOpFeatureGated |\n             TypeckError |\n             CheckMatchError => {\n                 // nothing to do\n@@ -443,9 +473,10 @@ for ::middle::const_val::ErrKind<'gcx> {\n             LayoutError(ref layout_error) => {\n                 layout_error.hash_stable(hcx, hasher);\n             }\n-            ErroneousReferencedConstant(ref const_val) => {\n-                const_val.hash_stable(hcx, hasher);\n-            }\n+            Miri(ref err, ref trace) => {\n+                err.hash_stable(hcx, hasher);\n+                trace.hash_stable(hcx, hasher);\n+            },\n         }\n     }\n }\n@@ -459,6 +490,167 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::EvalError<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::EvalErrorKind::*;\n+\n+        mem::discriminant(&self.kind).hash_stable(hcx, hasher);\n+\n+        match self.kind {\n+            DanglingPointerDeref |\n+            DoubleFree |\n+            InvalidMemoryAccess |\n+            InvalidFunctionPointer |\n+            InvalidBool |\n+            InvalidDiscriminant |\n+            InvalidNullPointerUsage |\n+            ReadPointerAsBytes |\n+            ReadBytesAsPointer |\n+            InvalidPointerMath |\n+            ReadUndefBytes |\n+            DeadLocal |\n+            ExecutionTimeLimitReached |\n+            StackFrameLimitReached |\n+            OutOfTls |\n+            TlsOutOfBounds |\n+            CalledClosureAsFunction |\n+            VtableForArgumentlessMethod |\n+            ModifiedConstantMemory |\n+            AssumptionNotHeld |\n+            InlineAsm |\n+            ReallocateNonBasePtr |\n+            DeallocateNonBasePtr |\n+            HeapAllocZeroBytes |\n+            Unreachable |\n+            Panic |\n+            ReadFromReturnPointer |\n+            UnimplementedTraitSelection |\n+            TypeckError |\n+            DerefFunctionPointer |\n+            ExecuteMemory |\n+            ReferencedConstant |\n+            OverflowingMath => {}\n+            MachineError(ref err) => err.hash_stable(hcx, hasher),\n+            FunctionPointerTyMismatch(a, b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            NoMirFor(ref s) => s.hash_stable(hcx, hasher),\n+            UnterminatedCString(ptr) => ptr.hash_stable(hcx, hasher),\n+            PointerOutOfBounds {\n+                ptr,\n+                access,\n+                allocation_size,\n+            } => {\n+                ptr.hash_stable(hcx, hasher);\n+                access.hash_stable(hcx, hasher);\n+                allocation_size.hash_stable(hcx, hasher)\n+            },\n+            InvalidBoolOp(bop) => bop.hash_stable(hcx, hasher),\n+            Unimplemented(ref s) => s.hash_stable(hcx, hasher),\n+            ArrayIndexOutOfBounds(sp, a, b) => {\n+                sp.hash_stable(hcx, hasher);\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            Math(sp, ref err) => {\n+                sp.hash_stable(hcx, hasher);\n+                err.hash_stable(hcx, hasher)\n+            },\n+            Intrinsic(ref s) => s.hash_stable(hcx, hasher),\n+            InvalidChar(c) => c.hash_stable(hcx, hasher),\n+            AbiViolation(ref s) => s.hash_stable(hcx, hasher),\n+            AlignmentCheckFailed {\n+                required,\n+                has,\n+            } => {\n+                required.hash_stable(hcx, hasher);\n+                has.hash_stable(hcx, hasher)\n+            },\n+            MemoryLockViolation {\n+                ptr,\n+                len,\n+                frame,\n+                access,\n+                ref lock,\n+            } =>  {\n+                ptr.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+                frame.hash_stable(hcx, hasher);\n+                access.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            MemoryAcquireConflict {\n+                ptr,\n+                len,\n+                kind,\n+                ref lock,\n+            } =>  {\n+                ptr.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+                kind.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            InvalidMemoryLockRelease {\n+                ptr,\n+                len,\n+                frame,\n+                ref lock,\n+            } =>  {\n+                ptr.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+                frame.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            DeallocatedLockedMemory {\n+                ptr,\n+                ref lock,\n+            } => {\n+                ptr.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            ValidationFailure(ref s) => s.hash_stable(hcx, hasher),\n+            TypeNotPrimitive(ty) => ty.hash_stable(hcx, hasher),\n+            ReallocatedWrongMemoryKind(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            DeallocatedWrongMemoryKind(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            IncorrectAllocationInformation(a, b, c, d) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+                c.hash_stable(hcx, hasher);\n+                d.hash_stable(hcx, hasher)\n+            },\n+            Layout(lay) => lay.hash_stable(hcx, hasher),\n+            HeapAllocNonPowerOfTwoAlignment(n) => n.hash_stable(hcx, hasher),\n+            PathNotFound(ref v) => v.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::interpret::Lock {\n+    NoLock,\n+    WriteLock(dl),\n+    ReadLock(v)\n+});\n+\n+impl_stable_hash_for!(struct mir::interpret::DynamicLifetime {\n+    frame,\n+    region\n+});\n+\n+impl_stable_hash_for!(enum mir::interpret::AccessKind {\n+    Read,\n+    Write\n+});\n+\n impl_stable_hash_for!(enum ty::Variance {\n     Covariant,\n     Invariant,\n@@ -470,9 +662,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -498,10 +690,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -527,12 +719,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n     synthetic\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -583,11 +775,11 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n impl_stable_hash_for!(tuple_struct ::middle::region::FirstStatementIndex { idx });\n impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, _: &StableHashingContext<'gcx>) -> region::Scope {\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'a>) -> region::Scope {\n         *self\n     }\n }\n@@ -613,11 +805,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::TypeVariants<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -714,11 +906,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::ExistentialPredicate<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -751,9 +943,9 @@ impl_stable_hash_for!(struct ty::Instance<'tcx> {\n     substs\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::InstanceDef<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -775,21 +967,21 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n             ty::InstanceDef::ClosureOnceShim { call_once } => {\n                 call_once.hash_stable(hcx, hasher);\n             }\n-            ty::InstanceDef::DropGlue(def_id, t) => {\n+            ty::InstanceDef::DropGlue(def_id, ty) => {\n                 def_id.hash_stable(hcx, hasher);\n-                t.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n             }\n-            ty::InstanceDef::CloneShim(def_id, t) => {\n+            ty::InstanceDef::CloneShim(def_id, ty) => {\n                 def_id.hash_stable(hcx, hasher);\n-                t.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TraitDef {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::TraitDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TraitDef {\n             // We already have the def_path_hash below, no need to hash it twice\n@@ -817,9 +1009,9 @@ impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CrateVariancesMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::CrateVariancesMap {\n             ref variances,\n@@ -853,12 +1045,12 @@ impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n });\n \n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ty::steal::Steal<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.borrow().hash_stable(hcx, hasher);\n     }\n@@ -881,10 +1073,10 @@ impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n     Public\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let ::middle::privacy::AccessLevels {\n@@ -911,10 +1103,10 @@ impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n     reachable_set\n });\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use traits::Vtable::*;\n \n@@ -933,10 +1125,10 @@ for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableImplData {\n             impl_def_id,\n@@ -949,10 +1141,10 @@ for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gc\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableAutoImplData {\n             trait_def_id,\n@@ -963,10 +1155,10 @@ for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'gcx>\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableObjectData {\n             upcast_trait_ref,\n@@ -979,10 +1171,10 @@ for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableBuiltinData {\n             ref nested,\n@@ -991,10 +1183,10 @@ for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>>\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableClosureData {\n             closure_def_id,\n@@ -1007,10 +1199,10 @@ for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableFnPointerData {\n             fn_ty,\n@@ -1021,10 +1213,10 @@ for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableGeneratorData {\n             closure_def_id,"}, {"sha": "56de2939ffae1efb811dd0d9d095674e04f873f9", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -49,6 +49,7 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(dyn_trait)]\n+#![feature(entry_or_default)]\n #![feature(from_ref)]\n #![feature(fs_read_write)]\n #![feature(i128)]"}, {"sha": "a951265d458bf2e6a78ec67dad8e234593227b94", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -20,6 +20,12 @@ use session::Session;\n use session::config::Epoch;\n use syntax::codemap::Span;\n \n+declare_lint! {\n+    pub EXCEEDING_BITSHIFTS,\n+    Deny,\n+    \"shift exceeds the type's number of bits\"\n+}\n+\n declare_lint! {\n     pub CONST_ERR,\n     Warn,\n@@ -263,6 +269,12 @@ declare_lint! {\n     Epoch::Epoch2018\n }\n \n+declare_lint! {\n+    pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+    Warn,\n+    \"floating-point literals cannot be used in patterns\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -271,6 +283,8 @@ pub struct HardwiredLints;\n impl LintPass for HardwiredLints {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n+            ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+            EXCEEDING_BITSHIFTS,\n             UNUSED_IMPORTS,\n             UNUSED_EXTERN_CRATES,\n             UNUSED_QUALIFICATIONS,"}, {"sha": "8a899a35ecb547a7e27e5fc59549a6df067a17f3", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -394,10 +394,10 @@ impl LintLevelMap {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LintLevelMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let LintLevelMap {\n             ref sets,"}, {"sha": "9a394e524817b23485270a2a7a19f3151db46fae", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -73,10 +73,10 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n-        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $enum_name {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 use $enum_name::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n@@ -92,10 +92,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name {\n                     $(ref $field),*\n@@ -106,10 +106,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (tuple_struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name (\n                     $(ref $field),*\n@@ -125,11 +125,11 @@ macro_rules! impl_stable_hash_for {\n macro_rules! impl_stable_hash_for_spanned {\n     ($T:path) => (\n \n-        impl<'tcx> HashStable<StableHashingContext<'tcx>> for ::syntax::codemap::Spanned<$T>\n+        impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ::syntax::codemap::Spanned<$T>\n         {\n             #[inline]\n             fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'tcx>,\n+                                                  hcx: &mut StableHashingContext<'a>,\n                                                   hasher: &mut StableHasher<W>) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);"}, {"sha": "6f5791ed5d71bc063c11a69b1b3a10e4525b3eef", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -20,9 +20,9 @@ pub struct BorrowCheckResult {\n     pub used_mut_nodes: FxHashSet<HirId>,\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for BorrowCheckResult {\n+impl<'a> HashStable<StableHashingContext<'a>> for BorrowCheckResult {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let BorrowCheckResult {\n             ref used_mut_nodes,"}, {"sha": "8c3dfd0bce752e51463411de9b2618e98f9d48e8", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 57, "deletions": 85, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,106 +8,72 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use rustc_const_math::ConstInt;\n-\n use hir::def_id::DefId;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n use rustc_const_math::*;\n+use mir::interpret::{Value, PrimVal};\n+use errors::DiagnosticBuilder;\n \n use graphviz::IntoCow;\n-use errors::DiagnosticBuilder;\n-use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n-use syntax::symbol::InternedString;\n-use syntax::ast;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n+use std::rc::Rc;\n \n pub type EvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ConstEvalErr<'tcx>>;\n \n #[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n-    Integral(ConstInt),\n-    Float(ConstFloat),\n-    Str(InternedString),\n-    ByteStr(ByteArray<'tcx>),\n-    Bool(bool),\n-    Char(char),\n-    Variant(DefId),\n-    Function(DefId, &'tcx Substs<'tcx>),\n-    Aggregate(ConstAggregate<'tcx>),\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, Eq, PartialEq)]\n-pub struct ByteArray<'tcx> {\n-    pub data: &'tcx [u8],\n-}\n-\n-impl<'tcx> serialize::UseSpecializedDecodable for ByteArray<'tcx> {}\n-\n-#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n-pub enum ConstAggregate<'tcx> {\n-    Struct(&'tcx [(ast::Name, &'tcx ty::Const<'tcx>)]),\n-    Tuple(&'tcx [&'tcx ty::Const<'tcx>]),\n-    Array(&'tcx [&'tcx ty::Const<'tcx>]),\n-    Repeat(&'tcx ty::Const<'tcx>, u64),\n-}\n-\n-impl<'tcx> Encodable for ConstAggregate<'tcx> {\n-    fn encode<S: Encoder>(&self, _: &mut S) -> Result<(), S::Error> {\n-        bug!(\"should never encode ConstAggregate::{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Decodable for ConstAggregate<'tcx> {\n-    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n-        bug!(\"should never decode ConstAggregate\")\n-    }\n+    Value(Value),\n }\n \n impl<'tcx> ConstVal<'tcx> {\n-    pub fn to_const_int(&self) -> Option<ConstInt> {\n+    pub fn to_raw_bits(&self) -> Option<u128> {\n         match *self {\n-            ConstVal::Integral(i) => Some(i),\n-            ConstVal::Bool(b) => Some(ConstInt::U8(b as u8)),\n-            ConstVal::Char(ch) => Some(ConstInt::U32(ch as u32)),\n-            _ => None\n+            ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n+                Some(b)\n+            },\n+            _ => None,\n+        }\n+    }\n+    pub fn unwrap_u64(&self) -> u64 {\n+        match self.to_raw_bits() {\n+            Some(val) => {\n+                assert_eq!(val as u64 as u128, val);\n+                val as u64\n+            },\n+            None => bug!(\"expected constant u64, got {:#?}\", self),\n         }\n     }\n }\n \n #[derive(Clone, Debug)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub kind: ErrKind<'tcx>,\n+    pub kind: Rc<ErrKind<'tcx>>,\n }\n \n #[derive(Clone, Debug)]\n pub enum ErrKind<'tcx> {\n-    CannotCast,\n-    MissingStructField,\n \n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n-    ExpectedConstTuple,\n-    ExpectedConstStruct,\n-    IndexedNonVec,\n-    IndexNotUsize,\n     IndexOutOfBounds { len: u64, index: u64 },\n \n-    MiscBinaryOp,\n-    MiscCatchAll,\n-\n-    IndexOpFeatureGated,\n     Math(ConstMathErr),\n     LayoutError(layout::LayoutError<'tcx>),\n \n-    ErroneousReferencedConstant(Box<ConstEvalErr<'tcx>>),\n-\n     TypeckError,\n     CheckMatchError,\n+    Miri(::mir::interpret::EvalError<'tcx>, Vec<FrameInfo>),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FrameInfo {\n+    pub span: Span,\n+    pub location: String,\n }\n \n impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n@@ -120,21 +86,23 @@ impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum ConstEvalErrDescription<'a> {\n+pub enum ConstEvalErrDescription<'a, 'tcx: 'a> {\n     Simple(Cow<'a, str>),\n+    Backtrace(&'a ::mir::interpret::EvalError<'tcx>, &'a [FrameInfo]),\n }\n \n-impl<'a> ConstEvalErrDescription<'a> {\n+impl<'a, 'tcx> ConstEvalErrDescription<'a, 'tcx> {\n     /// Return a one-line description of the error, for lints and such\n     pub fn into_oneline(self) -> Cow<'a, str> {\n         match self {\n             ConstEvalErrDescription::Simple(simple) => simple,\n+            ConstEvalErrDescription::Backtrace(miri, _) => format!(\"{}\", miri).into_cow(),\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n-    pub fn description(&self) -> ConstEvalErrDescription {\n+    pub fn description(&'a self) -> ConstEvalErrDescription<'a, 'tcx> {\n         use self::ErrKind::*;\n         use self::ConstEvalErrDescription::*;\n \n@@ -145,31 +113,21 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n             })\n         }\n \n-        match self.kind {\n-            CannotCast => simple!(\"can't cast this type\"),\n-            MissingStructField  => simple!(\"nonexistent struct field\"),\n+        match *self.kind {\n             NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n                 simple!(\"unimplemented constant expression: {}\", what),\n-            ExpectedConstTuple => simple!(\"expected constant tuple\"),\n-            ExpectedConstStruct => simple!(\"expected constant struct\"),\n-            IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n-            IndexNotUsize => simple!(\"indices must be of type `usize`\"),\n             IndexOutOfBounds { len, index } => {\n                 simple!(\"index out of bounds: the len is {} but the index is {}\",\n                         len, index)\n             }\n \n-            MiscBinaryOp => simple!(\"bad operands for binary\"),\n-            MiscCatchAll => simple!(\"unsupported constant expr\"),\n-            IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n             Math(ref err) => Simple(err.description().into_cow()),\n             LayoutError(ref err) => Simple(err.to_string().into_cow()),\n \n-            ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n-\n             TypeckError => simple!(\"type-checking failed\"),\n             CheckMatchError => simple!(\"match-checking failed\"),\n+            Miri(ref err, ref trace) => Backtrace(err, trace),\n         }\n     }\n \n@@ -179,15 +137,8 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         primary_kind: &str)\n         -> DiagnosticBuilder<'gcx>\n     {\n-        let mut err = self;\n-        while let &ConstEvalErr {\n-            kind: ErrKind::ErroneousReferencedConstant(box ref i_err), ..\n-        } = err {\n-            err = i_err;\n-        }\n-\n-        let mut diag = struct_span_err!(tcx.sess, err.span, E0080, \"constant evaluation error\");\n-        err.note(tcx, primary_span, primary_kind, &mut diag);\n+        let mut diag = struct_error(tcx, self.span, \"constant evaluation error\");\n+        self.note(tcx, primary_span, primary_kind, &mut diag);\n         diag\n     }\n \n@@ -201,6 +152,12 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n             ConstEvalErrDescription::Simple(message) => {\n                 diag.span_label(self.span, message);\n             }\n+            ConstEvalErrDescription::Backtrace(miri, frames) => {\n+                diag.span_label(self.span, format!(\"{}\", miri));\n+                for frame in frames {\n+                    diag.span_label(frame.span, format!(\"inside call to `{}`\", frame.location));\n+                }\n+            }\n         }\n \n         if !primary_span.contains(self.span) {\n@@ -214,10 +171,25 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         primary_span: Span,\n         primary_kind: &str)\n     {\n-        match self.kind {\n+        match *self.kind {\n             ErrKind::TypeckError | ErrKind::CheckMatchError => return,\n+            ErrKind::Miri(ref miri, _) => {\n+                match miri.kind {\n+                    ::mir::interpret::EvalErrorKind::TypeckError |\n+                    ::mir::interpret::EvalErrorKind::Layout(_) => return,\n+                    _ => {},\n+                }\n+            }\n             _ => {}\n         }\n         self.struct_error(tcx, primary_span, primary_kind).emit();\n     }\n }\n+\n+pub fn struct_error<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    span: Span,\n+    msg: &str,\n+) -> DiagnosticBuilder<'gcx> {\n+    struct_span_err!(tcx.sess, span, E0080, \"{}\", msg)\n+}"}, {"sha": "3b37031cf461452978a78fa6a4760262543b4514", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -280,6 +280,7 @@ language_item_table! {\n     GeneratorTraitLangItem,          \"generator\",               gen_trait;\n \n     EqTraitLangItem,                 \"eq\",                      eq_trait;\n+    PartialOrdTraitLangItem,         \"partial_ord\",             partial_ord_trait;\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n \n     // A number of panic-related lang items. The `panic` item corresponds to"}, {"sha": "30d63b8443e3dec8eb152f728f207b72fb27dd75", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -913,8 +913,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, len) if\n-                len.val.to_const_int().and_then(|i| i.to_u64()) == Some(0) => true,\n+            ty::TyArray(_, len) if len.val.to_raw_bits() == Some(0) => true,\n             _ => promotable,\n         };\n "}, {"sha": "c73930553cdea679a69addc7499c105fe3e0218a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1488,9 +1488,9 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ScopeTree {\n+impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ScopeTree {\n             root_body,"}, {"sha": "45cb70d00706844193586b3ebddad102646b02c5", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -35,9 +35,9 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Cache {\n+impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           _: &mut StableHasher<W>) {\n         // do nothing\n     }"}, {"sha": "51660b180cd980d0f7456d46287a3f78f41c2386", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,7 +12,7 @@ use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n use backtrace::Backtrace;\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct EvalError<'tcx> {\n     pub kind: EvalErrorKind<'tcx>,\n     pub backtrace: Option<Backtrace>,\n@@ -31,11 +31,11 @@ impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum EvalErrorKind<'tcx> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant\n-    MachineError(Box<dyn Error>),\n+    MachineError(String),\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n     UnterminatedCString(MemoryPointer),\n@@ -65,11 +65,6 @@ pub enum EvalErrorKind<'tcx> {\n     Intrinsic(String),\n     OverflowingMath,\n     InvalidChar(u128),\n-    OutOfMemory {\n-        allocation_size: u64,\n-        memory_size: u64,\n-        memory_usage: u64,\n-    },\n     ExecutionTimeLimitReached,\n     StackFrameLimitReached,\n     OutOfTls,\n@@ -124,6 +119,9 @@ pub enum EvalErrorKind<'tcx> {\n     UnimplementedTraitSelection,\n     /// Abort in case type errors are reached\n     TypeckError,\n+    /// Cannot compute this constant because it depends on another one\n+    /// which already produced an error\n+    ReferencedConstant,\n }\n \n pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n@@ -132,7 +130,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {\n         use self::EvalErrorKind::*;\n         match self.kind {\n-            MachineError(ref inner) => inner.description(),\n+            MachineError(ref inner) => inner,\n             FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n             InvalidMemoryAccess =>\n@@ -190,10 +188,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"mir not found\",\n             InvalidChar(..) =>\n                 \"tried to interpret an invalid 32-bit value as a char\",\n-            OutOfMemory{..} =>\n-                \"could not allocate more memory\",\n             ExecutionTimeLimitReached =>\n-                \"reached the configured maximum execution time\",\n+                \"the expression was too complex to be evaluated or resulted in an infinite loop\",\n             StackFrameLimitReached =>\n                 \"reached the configured maximum number of stack frames\",\n             OutOfTls =>\n@@ -245,14 +241,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"there were unresolved type arguments during trait selection\",\n             TypeckError =>\n                 \"encountered constants with type errors, stopping evaluation\",\n-        }\n-    }\n-\n-    fn cause(&self) -> Option<&dyn Error> {\n-        use self::EvalErrorKind::*;\n-        match self.kind {\n-            MachineError(ref inner) => Some(&**inner),\n-            _ => None,\n+            ReferencedConstant =>\n+                \"referenced constant has errors\",\n         }\n     }\n }\n@@ -294,15 +284,12 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n             DeallocatedWrongMemoryKind(ref old, ref new) =>\n                 write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n-            Math(span, ref err) =>\n-                write!(f, \"{:?} at {:?}\", err, span),\n+            Math(_, ref err) =>\n+                write!(f, \"{}\", err.description()),\n             Intrinsic(ref err) =>\n                 write!(f, \"{}\", err),\n             InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n-            OutOfMemory { allocation_size, memory_size, memory_usage } =>\n-                write!(f, \"tried to allocate {} more bytes, but only {} bytes are free of the {} byte memory\",\n-                       allocation_size, memory_size - memory_usage, memory_size),\n             AlignmentCheckFailed { required, has } =>\n                write!(f, \"tried to access memory with alignment {}, but alignment {} is required\",\n                       has, required),\n@@ -313,7 +300,7 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n             PathNotFound(ref path) =>\n                 write!(f, \"Cannot find path {:?}\", path),\n             MachineError(ref inner) =>\n-                write!(f, \"machine error: {}\", inner),\n+                write!(f, \"{}\", inner),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n                 write!(f, \"incorrect alloc info: expected size {} and align {}, got size {} and align {}\", size, align, size2, align2),\n             _ => write!(f, \"{}\", self.description()),"}, {"sha": "67f30f53a6810fb8feff799ca86cc57b12fbdeed", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -10,7 +10,7 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer, bytes_to_f32, bytes_to_f64};\n+pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n \n use std::collections::BTreeMap;\n use std::fmt;\n@@ -19,6 +19,7 @@ use ty;\n use ty::layout::{self, Align, HasDataLayout};\n use middle::region;\n use std::iter;\n+use syntax::ast::Mutability;\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Lock {\n@@ -41,7 +42,7 @@ pub enum AccessKind {\n }\n \n /// Uniquely identifies a specific constant or static.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n     /// For a promoted global, the `Instance` of the function they belong to.\n@@ -101,7 +102,7 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub struct MemoryPointer {\n     pub alloc_id: AllocId,\n     pub offset: u64,\n@@ -148,13 +149,16 @@ impl<'tcx> MemoryPointer {\n #[derive(Copy, Clone, Default, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n pub struct AllocId(pub u64);\n \n+impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n+impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n+\n impl fmt::Display for AllocId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.0)\n     }\n }\n \n-#[derive(Debug, Eq, PartialEq, Hash)]\n+#[derive(Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n@@ -166,6 +170,10 @@ pub struct Allocation {\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n+    /// Whether the allocation (of a static) should be put into mutable memory when translating\n+    ///\n+    /// Only happens for `static mut` or `static` with interior mutability\n+    pub runtime_mutability: Mutability,\n }\n \n impl Allocation {\n@@ -177,6 +185,7 @@ impl Allocation {\n             relocations: BTreeMap::new(),\n             undef_mask,\n             align: Align::from_bytes(1, 1).unwrap(),\n+            runtime_mutability: Mutability::Immutable,\n         }\n     }\n }\n@@ -188,12 +197,14 @@ impl Allocation {\n type Block = u64;\n const BLOCK_SIZE: u64 = 64;\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+#[derive(Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UndefMask {\n     blocks: Vec<Block>,\n     len: u64,\n }\n \n+impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n+\n impl UndefMask {\n     pub fn new(size: u64) -> Self {\n         let mut m = UndefMask {"}, {"sha": "7289d74bfbb1bd653fa529cd7951ff7da8a11bb6", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,24 +1,9 @@\n #![allow(unknown_lints)]\n \n use ty::layout::{Align, HasDataLayout};\n+use ty;\n \n use super::{EvalResult, MemoryPointer, PointerArithmetic};\n-use syntax::ast::FloatTy;\n-use rustc_const_math::ConstFloat;\n-\n-pub fn bytes_to_f32(bits: u128) -> ConstFloat {\n-    ConstFloat {\n-        bits,\n-        ty: FloatTy::F32,\n-    }\n-}\n-\n-pub fn bytes_to_f64(bits: u128) -> ConstFloat {\n-    ConstFloat {\n-        bits,\n-        ty: FloatTy::F64,\n-    }\n-}\n \n /// A `Value` represents a single self-contained Rust value.\n ///\n@@ -29,23 +14,32 @@ pub fn bytes_to_f64(bits: u128) -> ConstFloat {\n /// For optimization of a few very common cases, there is also a representation for a pair of\n /// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n /// operations and fat pointers. This idea was taken from rustc's trans.\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub enum Value {\n     ByRef(Pointer, Align),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n \n+impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n+    fn super_fold_with<'gcx: 'tcx, F: ty::fold::TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: ty::fold::TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n /// A wrapper type around `PrimVal` that cannot be turned back into a `PrimVal` accidentally.\n /// This type clears up a few APIs where having a `PrimVal` argument for something that is\n /// potentially an integer pointer or a pointer to an allocation was unclear.\n ///\n /// I (@oli-obk) believe it is less easy to mix up generic primvals and primvals that are just\n /// the representation of pointers. Also all the sites that convert between primvals and pointers\n /// are explicit now (and rare!)\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pointer {\n-    primval: PrimVal,\n+    pub primval: PrimVal,\n }\n \n impl<'tcx> Pointer {\n@@ -138,7 +132,7 @@ impl ::std::convert::From<MemoryPointer> for Pointer {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n /// of a simple value, a pointer into another `Allocation`, or be undefined.\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub enum PrimVal {\n     /// The raw bytes of a simple value.\n     Bytes(u128),\n@@ -172,10 +166,6 @@ impl<'tcx> PrimVal {\n         PrimVal::Bytes(n as u128)\n     }\n \n-    pub fn from_float(f: ConstFloat) -> Self {\n-        PrimVal::Bytes(f.bits)\n-    }\n-\n     pub fn from_bool(b: bool) -> Self {\n         PrimVal::Bytes(b as u128)\n     }\n@@ -250,14 +240,6 @@ impl<'tcx> PrimVal {\n         })\n     }\n \n-    pub fn to_f32(self) -> EvalResult<'tcx, ConstFloat> {\n-        self.to_bytes().map(bytes_to_f32)\n-    }\n-\n-    pub fn to_f64(self) -> EvalResult<'tcx, ConstFloat> {\n-        self.to_bytes().map(bytes_to_f64)\n-    }\n-\n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         match self.to_bytes()? {\n             0 => Ok(false),"}, {"sha": "e39765699f9be01dd05b48a289b74ddde9819f72", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 67, "deletions": 30, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -15,7 +15,7 @@\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use middle::region;\n-use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n+use rustc_const_math::ConstMathErr;\n use rustc_data_structures::sync::{Lrc};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n@@ -25,13 +25,14 @@ use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n+use mir::interpret::{Value, PrimVal};\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use ty::TypeAndMut;\n use util::ppaux;\n use std::slice;\n use hir::{self, InlineAsm};\n-use std::ascii;\n use std::borrow::{Cow};\n use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n@@ -707,7 +708,7 @@ pub enum TerminatorKind<'tcx> {\n \n         /// Possible values. The locations to branch to in each case\n         /// are found in the corresponding indices from the `targets` vector.\n-        values: Cow<'tcx, [ConstInt]>,\n+        values: Cow<'tcx, [u128]>,\n \n         /// Possible branch sites. The last element of this vector is used\n         /// for the otherwise branch, so targets.len() == values.len() + 1\n@@ -858,7 +859,7 @@ impl<'tcx> Terminator<'tcx> {\n impl<'tcx> TerminatorKind<'tcx> {\n     pub fn if_<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, cond: Operand<'tcx>,\n                          t: BasicBlock, f: BasicBlock) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::U8(0)];\n+        static BOOL_SWITCH_FALSE: &'static [u128] = &[0];\n         TerminatorKind::SwitchInt {\n             discr: cond,\n             switch_ty: tcx.types.bool,\n@@ -1144,12 +1145,16 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref values, .. } => {\n+            SwitchInt { ref values, switch_ty, .. } => {\n                 values.iter()\n-                      .map(|const_val| {\n-                          let mut buf = String::new();\n-                          fmt_const_val(&mut buf, &ConstVal::Integral(*const_val)).unwrap();\n-                          buf.into()\n+                      .map(|&u| {\n+                          let mut s = String::new();\n+                          print_miri_value(\n+                              Value::ByVal(PrimVal::Bytes(u)),\n+                              switch_ty,\n+                              &mut s,\n+                          ).unwrap();\n+                          s.into()\n                       })\n                       .chain(iter::once(String::from(\"otherwise\").into()))\n                       .collect()\n@@ -1533,7 +1538,8 @@ impl<'tcx> Operand<'tcx> {\n             ty,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(def_id, substs),\n+                    // ZST function type\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty\n                 })\n             },\n@@ -1557,7 +1563,7 @@ pub enum Rvalue<'tcx> {\n     Use(Operand<'tcx>),\n \n     /// [x; 32]\n-    Repeat(Operand<'tcx>, ConstUsize),\n+    Repeat(Operand<'tcx>, u64),\n \n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n@@ -1853,7 +1859,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n         match *self {\n             Value { value } => {\n                 write!(fmt, \"const \")?;\n-                fmt_const_val(fmt, &value.val)\n+                fmt_const_val(fmt, value)\n             }\n             Promoted { index } => {\n                 write!(fmt, \"{:?}\", index)\n@@ -1863,25 +1869,47 @@ impl<'tcx> Debug for Literal<'tcx> {\n }\n \n /// Write a `ConstVal` in a way closer to the original source code than the `Debug` output.\n-fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n+fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n     use middle::const_val::ConstVal::*;\n-    match *const_val {\n-        Float(f) => write!(fmt, \"{:?}\", f),\n-        Integral(n) => write!(fmt, \"{}\", n),\n-        Str(s) => write!(fmt, \"{:?}\", s),\n-        ByteStr(bytes) => {\n-            let escaped: String = bytes.data\n-                .iter()\n-                .flat_map(|&ch| ascii::escape_default(ch).map(|c| c as char))\n-                .collect();\n-            write!(fmt, \"b\\\"{}\\\"\", escaped)\n-        }\n-        Bool(b) => write!(fmt, \"{:?}\", b),\n-        Char(c) => write!(fmt, \"{:?}\", c),\n-        Variant(def_id) |\n-        Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n-        Aggregate(_) => bug!(\"`ConstVal::{:?}` should not be in MIR\", const_val),\n-        Unevaluated(..) => write!(fmt, \"{:?}\", const_val)\n+    match const_val.val {\n+        Unevaluated(..) => write!(fmt, \"{:?}\", const_val),\n+        Value(val) => print_miri_value(val, const_val.ty, fmt),\n+    }\n+}\n+\n+pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n+    use ty::TypeVariants::*;\n+    use rustc_const_math::ConstFloat;\n+    match (value, &ty.sty) {\n+        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n+        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(fty)) =>\n+            write!(f, \"{}\", ConstFloat { bits, ty: fty }),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n+            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n+        (Value::ByVal(PrimVal::Undef), &TyFnDef(did, _)) =>\n+            write!(f, \"{}\", item_path_str(did)),\n+        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)), &TyRef(_, TypeAndMut {\n+            ty: &ty::TyS { sty: TyStr, .. }, ..\n+        })) => {\n+            ty::tls::with(|tcx| {\n+                let alloc = tcx\n+                    .interpret_interner\n+                    .get_alloc(ptr.alloc_id);\n+                if let Some(alloc) = alloc {\n+                    assert_eq!(len as usize as u128, len);\n+                    let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n+                    let s = ::std::str::from_utf8(slice)\n+                        .expect(\"non utf8 str from miri\");\n+                    write!(f, \"{:?}\", s)\n+                } else {\n+                    write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n+                }\n+            })\n+        },\n+        _ => write!(f, \"{:?}:{}\", value, ty),\n     }\n }\n \n@@ -2467,6 +2495,15 @@ impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for Field {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {"}, {"sha": "d01059a3e017185bfd2dd001410c066c1954d926", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -41,9 +41,9 @@ impl<'tcx> MonoItem<'tcx> {\n     }\n }\n \n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'tcx>,\n+                                           hcx: &mut StableHashingContext<'a>,\n                                            hasher: &mut StableHasher<W>) {\n         ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -171,9 +171,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n }\n \n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for CodegenUnit<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'tcx>,\n+                                           hcx: &mut StableHashingContext<'a>,\n                                            hasher: &mut StableHasher<W>) {\n         let CodegenUnit {\n             ref items,"}, {"sha": "7d232ac20bfd52a0f55495b08f9fa7a0174f841b", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 PlaceTy::Ty {\n                     ty: match ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                            let size = size.val.unwrap_u64();\n                             let len = size - (from as u64) - (to as u64);\n                             tcx.mk_array(inner, len)\n                         }\n@@ -149,7 +149,7 @@ impl<'tcx> Rvalue<'tcx> {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n             Rvalue::Repeat(ref operand, count) => {\n-                tcx.mk_array_const_usize(operand.ty(local_decls, tcx), count)\n+                tcx.mk_array(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::Ref(reg, bk, ref place) => {\n                 let place_ty = place.ty(local_decls, tcx).to_ty(tcx);"}, {"sha": "650af8dc4d903fa41ab133d94ef5b40bad093ebc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,7 +12,6 @@ use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty, GeneratorInterior};\n use mir::*;\n-use rustc_const_math::ConstUsize;\n use syntax_pos::Span;\n \n // # The MIR Visitor\n@@ -243,18 +242,6 @@ macro_rules! make_mir_visitor {\n                 self.super_generator_interior(interior);\n             }\n \n-            fn visit_const_int(&mut self,\n-                               const_int: &ConstInt,\n-                               _: Location) {\n-                self.super_const_int(const_int);\n-            }\n-\n-            fn visit_const_usize(&mut self,\n-                                 const_usize: & $($mutability)* ConstUsize,\n-                                 _: Location) {\n-                self.super_const_usize(const_usize);\n-            }\n-\n             fn visit_local_decl(&mut self,\n                                 local: Local,\n                                 local_decl: & $($mutability)* LocalDecl<'tcx>) {\n@@ -426,13 +413,10 @@ macro_rules! make_mir_visitor {\n \n                     TerminatorKind::SwitchInt { ref $($mutability)* discr,\n                                                 ref $($mutability)* switch_ty,\n-                                                ref values,\n+                                                values: _,\n                                                 ref targets } => {\n                         self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty, TyContext::Location(source_location));\n-                        for value in &values[..] {\n-                            self.visit_const_int(value, source_location);\n-                        }\n                         for &target in targets {\n                             self.visit_branch(block, target);\n                         }\n@@ -538,10 +522,8 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(operand, location);\n                     }\n \n-                    Rvalue::Repeat(ref $($mutability)* value,\n-                                   ref $($mutability)* length) => {\n+                    Rvalue::Repeat(ref $($mutability)* value, _) => {\n                         self.visit_operand(value, location);\n-                        self.visit_const_usize(length, location);\n                     }\n \n                     Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n@@ -798,12 +780,6 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_int(&mut self, _const_int: &ConstInt) {\n-            }\n-\n-            fn super_const_usize(&mut self, _const_usize: & $($mutability)* ConstUsize) {\n-            }\n-\n             // Convenience methods\n \n             fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {"}, {"sha": "437369400ed11d1a89369b7753de726540b58599", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -179,10 +179,10 @@ impl_stable_hash_for!(enum self::OutputType {\n     DepInfo\n });\n \n-impl<'tcx> ToStableHashKey<StableHashingContext<'tcx>> for OutputType {\n+impl<'a, 'tcx> ToStableHashKey<StableHashingContext<'a>> for OutputType {\n     type KeyType = OutputType;\n     #[inline]\n-    fn to_stable_hash_key(&self, _: &StableHashingContext<'tcx>) -> Self::KeyType {\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'a>) -> Self::KeyType {\n         *self\n     }\n }"}, {"sha": "defc5731f2f8aa9bf65fbfcee6d2c0a6d1347704", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -103,6 +103,11 @@ pub struct Session {\n     /// The maximum length of types during monomorphization.\n     pub type_length_limit: Cell<usize>,\n \n+    /// The maximum number of stackframes allowed in const eval\n+    pub const_eval_stack_frame_limit: Cell<usize>,\n+    /// The maximum number miri steps per constant\n+    pub const_eval_step_limit: Cell<usize>,\n+\n     /// The metadata::creader module may inject an allocator/panic_runtime\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n@@ -1004,6 +1009,8 @@ pub fn build_session_(sopts: config::Options,\n         features: RefCell::new(None),\n         recursion_limit: Cell::new(64),\n         type_length_limit: Cell::new(1048576),\n+        const_eval_stack_frame_limit: Cell::new(100),\n+        const_eval_step_limit: Cell::new(1_000_000),\n         next_node_id: Cell::new(NodeId::new(1)),\n         injected_allocator: Cell::new(None),\n         allocator_kind: Cell::new(None),"}, {"sha": "cd2d0d7e2a043d297715b7d37818ab112570b922", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -32,7 +32,6 @@ use hir;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n-use middle::const_val;\n use std::fmt;\n use syntax::ast;\n use session::DiagnosticMessageId;\n@@ -776,7 +775,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             ConstEvalFailure(ref err) => {\n-                if let const_val::ErrKind::TypeckError = err.kind {\n+                if let ::middle::const_val::ErrKind::TypeckError = *err.kind {\n                     return;\n                 }\n                 err.struct_error(self.tcx, span, \"constant expression\")"}, {"sha": "bb2c7977f265b7dc0e6cc382ae6c72cba5f6de05", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,12 +9,14 @@\n // except according to those terms.\n \n use infer::{RegionObligation, InferCtxt};\n+use mir::interpret::GlobalId;\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n use hir::def_id::DefId;\n+use middle::const_val::{ConstEvalErr, ErrKind};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -514,17 +516,35 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                 }\n                 Some(param_env) => {\n                     match selcx.tcx().lift_to_global(&substs) {\n+                        Some(substs) => {\n+                            let instance = ty::Instance::resolve(\n+                                selcx.tcx().global_tcx(),\n+                                param_env,\n+                                def_id,\n+                                substs,\n+                            );\n+                            if let Some(instance) = instance {\n+                                let cid = GlobalId {\n+                                    instance,\n+                                    promoted: None,\n+                                };\n+                                match selcx.tcx().at(obligation.cause.span)\n+                                                 .const_eval(param_env.and(cid)) {\n+                                    Ok(_) => Ok(Some(vec![])),\n+                                    Err(err) => Err(CodeSelectionError(ConstEvalFailure(err)))\n+                                }\n+                            } else {\n+                                Err(CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n+                                    span: obligation.cause.span,\n+                                    kind: ErrKind::UnimplementedConstVal(\"could not resolve\")\n+                                        .into(),\n+                                })))\n+                            }\n+                        },\n                         None => {\n                             pending_obligation.stalled_on = substs.types().collect();\n                             Ok(None)\n                         }\n-                        Some(substs) => {\n-                            match selcx.tcx().at(obligation.cause.span)\n-                                             .const_eval(param_env.and((def_id, substs))) {\n-                                Ok(_) => Ok(Some(vec![])),\n-                                Err(e) => Err(CodeSelectionError(ConstEvalFailure(e)))\n-                            }\n-                        }\n                     }\n                 }\n             }"}, {"sha": "e0e85600b9036c353f1fda479fb98f33e8fddfc4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -20,8 +20,8 @@ pub use self::ObligationCauseCode::*;\n use hir;\n use hir::def_id::DefId;\n use infer::outlives::env::OutlivesEnvironment;\n-use middle::const_val::ConstEvalErr;\n use middle::region;\n+use middle::const_val::ConstEvalErr;\n use ty::subst::Substs;\n use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};"}, {"sha": "a9dc49157437967d198dc0e6bf3c44b8dadf4e61", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -29,6 +29,7 @@ use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use infer::type_variable::TypeVariableOrigin;\n use middle::const_val::ConstVal;\n+use mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::symbol::Symbol;\n use ty::subst::{Subst, Substs};\n@@ -400,31 +401,38 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n-            if substs.needs_infer() {\n-                let identity_substs = Substs::identity_for_item(self.tcx(), def_id);\n-                let data = self.param_env.and((def_id, identity_substs));\n-                match self.tcx().lift_to_global(&data) {\n-                    Some(data) => {\n-                        match self.tcx().const_eval(data) {\n+            let tcx = self.selcx.tcx().global_tcx();\n+            if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n+                if substs.needs_infer() {\n+                    let identity_substs = Substs::identity_for_item(tcx, def_id);\n+                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n+                    if let Some(instance) = instance {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None\n+                        };\n+                        match tcx.const_eval(param_env.and(cid)) {\n                             Ok(evaluated) => {\n                                 let evaluated = evaluated.subst(self.tcx(), substs);\n                                 return self.fold_const(evaluated);\n                             }\n                             Err(_) => {}\n                         }\n                     }\n-                    None => {}\n-                }\n-            } else {\n-                let data = self.param_env.and((def_id, substs));\n-                match self.tcx().lift_to_global(&data) {\n-                    Some(data) => {\n-                        match self.tcx().const_eval(data) {\n-                            Ok(evaluated) => return self.fold_const(evaluated),\n-                            Err(_) => {}\n+                } else {\n+                    if let Some(substs) = self.tcx().lift_to_global(&substs) {\n+                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n+                        if let Some(instance) = instance {\n+                            let cid = GlobalId {\n+                                instance,\n+                                promoted: None\n+                            };\n+                            match tcx.const_eval(param_env.and(cid)) {\n+                                Ok(evaluated) => return self.fold_const(evaluated),\n+                                Err(_) => {}\n+                            }\n                         }\n                     }\n-                    None => {}\n                 }\n             }\n         }"}, {"sha": "91d86394b0192d56ae58c7383a027def22f27c46", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -42,6 +42,7 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n use middle::lang_items;\n+use mir::interpret::{GlobalId};\n \n use rustc_data_structures::bitvec::BitVector;\n use std::iter;\n@@ -732,11 +733,26 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                match self.tcx().lift_to_global(&(obligation.param_env, substs)) {\n+                let tcx = self.tcx();\n+                match tcx.lift_to_global(&(obligation.param_env, substs)) {\n                     Some((param_env, substs)) => {\n-                        match self.tcx().const_eval(param_env.and((def_id, substs))) {\n-                            Ok(_) => EvaluatedToOk,\n-                            Err(_) => EvaluatedToErr\n+                        let instance = ty::Instance::resolve(\n+                            tcx.global_tcx(),\n+                            param_env,\n+                            def_id,\n+                            substs,\n+                        );\n+                        if let Some(instance) = instance {\n+                            let cid = GlobalId {\n+                                instance,\n+                                promoted: None\n+                            };\n+                            match self.tcx().const_eval(param_env.and(cid)) {\n+                                Ok(_) => EvaluatedToOk,\n+                                Err(_) => EvaluatedToErr\n+                            }\n+                        } else {\n+                            EvaluatedToErr\n                         }\n                     }\n                     None => {"}, {"sha": "f8b895177f381dfa74c02ca0341ceabcde309361", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -391,9 +391,9 @@ pub fn ancestors(tcx: TyCtxt,\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Children {\n+impl<'a> HashStable<StableHashingContext<'a>> for Children {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let Children {\n             ref nonblanket_impls,"}, {"sha": "f98bc953560988f2290b1443c2ef4318b1f39fed", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -17,7 +17,6 @@\n // persisting to incr. comp. caches.\n \n use hir::def_id::{DefId, CrateNum};\n-use middle::const_val::ByteArray;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n use std::hash::Hash;\n@@ -240,17 +239,6 @@ pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n               .mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n-#[inline]\n-pub fn decode_byte_array<'a, 'tcx, D>(decoder: &mut D)\n-                                      -> Result<ByteArray<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n-{\n-    Ok(ByteArray {\n-        data: decoder.tcx().alloc_byte_array(&Vec::decode(decoder)?)\n-    })\n-}\n-\n #[inline]\n pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n                                  -> Result<&'tcx ty::Const<'tcx>, D::Error>\n@@ -278,7 +266,6 @@ macro_rules! implement_ty_decoder {\n             use $crate::ty::codec::*;\n             use $crate::ty::subst::Substs;\n             use $crate::hir::def_id::{CrateNum};\n-            use $crate::middle::const_val::ByteArray;\n             use rustc_serialize::{Decoder, SpecializedDecoder};\n             use std::borrow::Cow;\n \n@@ -377,13 +364,6 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<ByteArray<'tcx>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n-                    decode_byte_array(self)\n-                }\n-            }\n-\n             impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::Const<'tcx>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {"}, {"sha": "b760649c37d156f74b1124a23ae903ee8616ee49", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 91, "deletions": 40, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -30,7 +30,8 @@ use middle::cstore::EncodedMetadata;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n-use mir::{Mir, interpret};\n+use mir::{self, Mir, interpret};\n+use mir::interpret::{Value, PrimVal};\n use ty::subst::{Kind, Substs};\n use ty::ReprOptions;\n use ty::Instance;\n@@ -53,7 +54,6 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::{TypedArena, DroplessArena};\n-use rustc_const_math::{ConstInt, ConstUsize};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n@@ -675,9 +675,9 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n             local_id_root,\n@@ -868,7 +868,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n \n-    pub interpret_interner: RefCell<InterpretInterner<'tcx>>,\n+    pub interpret_interner: InterpretInterner<'tcx>,\n \n     layout_interner: RefCell<FxHashSet<&'tcx LayoutDetails>>,\n \n@@ -892,6 +892,11 @@ pub struct GlobalCtxt<'tcx> {\n /// Everything needed to efficiently work with interned allocations\n #[derive(Debug, Default)]\n pub struct InterpretInterner<'tcx> {\n+    inner: RefCell<InterpretInternerInner<'tcx>>,\n+}\n+\n+#[derive(Debug, Default)]\n+struct InterpretInternerInner<'tcx> {\n     /// Stores the value of constants (and deduplicates the actual memory)\n     allocs: FxHashSet<&'tcx interpret::Allocation>,\n \n@@ -905,78 +910,95 @@ pub struct InterpretInterner<'tcx> {\n     /// Allows obtaining const allocs via a unique identifier\n     alloc_by_id: FxHashMap<interpret::AllocId, &'tcx interpret::Allocation>,\n \n+    /// Reverse map of `alloc_cache`\n+    global_cache: FxHashMap<interpret::AllocId, DefId>,\n+\n     /// The AllocId to assign to the next new regular allocation.\n     /// Always incremented, never gets smaller.\n     next_id: interpret::AllocId,\n \n-    /// Allows checking whether a constant already has an allocation\n-    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::AllocId>,\n+    /// Allows checking whether a static already has an allocation\n+    ///\n+    /// This is only important for detecting statics referring to themselves\n+    // FIXME(oli-obk) move it to the EvalContext?\n+    alloc_cache: FxHashMap<DefId, interpret::AllocId>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n     literal_alloc_cache: FxHashMap<Vec<u8>, interpret::AllocId>,\n }\n \n impl<'tcx> InterpretInterner<'tcx> {\n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> interpret::AllocId {\n-        if let Some(&alloc_id) = self.function_cache.get(&instance) {\n+    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> interpret::AllocId {\n+        if let Some(&alloc_id) = self.inner.borrow().function_cache.get(&instance) {\n             return alloc_id;\n         }\n         let id = self.reserve();\n         debug!(\"creating fn ptr: {}\", id);\n-        self.functions.insert(id, instance);\n-        self.function_cache.insert(instance, id);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.functions.insert(id, instance);\n+        inner.function_cache.insert(instance, id);\n         id\n     }\n \n     pub fn get_fn(\n         &self,\n         id: interpret::AllocId,\n     ) -> Option<Instance<'tcx>> {\n-        self.functions.get(&id).cloned()\n+        self.inner.borrow().functions.get(&id).cloned()\n     }\n \n     pub fn get_alloc(\n         &self,\n         id: interpret::AllocId,\n     ) -> Option<&'tcx interpret::Allocation> {\n-        self.alloc_by_id.get(&id).cloned()\n+        self.inner.borrow().alloc_by_id.get(&id).cloned()\n     }\n \n     pub fn get_cached(\n         &self,\n-        global_id: interpret::GlobalId<'tcx>,\n+        static_id: DefId,\n     ) -> Option<interpret::AllocId> {\n-        self.alloc_cache.get(&global_id).cloned()\n+        self.inner.borrow().alloc_cache.get(&static_id).cloned()\n     }\n \n     pub fn cache(\n-        &mut self,\n-        global_id: interpret::GlobalId<'tcx>,\n-        ptr: interpret::AllocId,\n+        &self,\n+        static_id: DefId,\n+        alloc_id: interpret::AllocId,\n     ) {\n-        if let Some(old) = self.alloc_cache.insert(global_id, ptr) {\n-            bug!(\"tried to cache {:?}, but was already existing as {:#?}\", global_id, old);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.global_cache.insert(alloc_id, static_id);\n+        if let Some(old) = inner.alloc_cache.insert(static_id, alloc_id) {\n+            bug!(\"tried to cache {:?}, but was already existing as {:#?}\", static_id, old);\n         }\n     }\n \n+    pub fn get_corresponding_static_def_id(\n+        &self,\n+        ptr: interpret::AllocId,\n+    ) -> Option<DefId> {\n+        self.inner.borrow().global_cache.get(&ptr).cloned()\n+    }\n+\n     pub fn intern_at_reserved(\n-        &mut self,\n+        &self,\n         id: interpret::AllocId,\n         alloc: &'tcx interpret::Allocation,\n     ) {\n-        if let Some(old) = self.alloc_by_id.insert(id, alloc) {\n+        if let Some(old) = self.inner.borrow_mut().alloc_by_id.insert(id, alloc) {\n             bug!(\"tried to intern allocation at {}, but was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// obtains a new allocation ID that can be referenced but does not\n     /// yet have an allocation backing it.\n     pub fn reserve(\n-        &mut self,\n+        &self,\n     ) -> interpret::AllocId {\n-        let next = self.next_id;\n-        self.next_id.0 = self.next_id.0\n+        let mut inner = self.inner.borrow_mut();\n+        let next = inner.next_id;\n+        inner.next_id.0 = inner.next_id.0\n             .checked_add(1)\n             .expect(\"You overflowed a u64 by incrementing by 1... \\\n                      You've just earned yourself a free drink if we ever meet. \\\n@@ -1056,12 +1078,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         alloc: interpret::Allocation,\n     ) -> &'gcx interpret::Allocation {\n-        if let Some(alloc) = self.interpret_interner.borrow().allocs.get(&alloc) {\n+        if let Some(alloc) = self.interpret_interner.inner.borrow().allocs.get(&alloc) {\n             return alloc;\n         }\n \n         let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = self.interpret_interner.borrow_mut().allocs.replace(interned) {\n+        if let Some(prev) = self.interpret_interner.inner.borrow_mut().allocs.replace(interned) {\n             bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n         }\n         interned\n@@ -1070,20 +1092,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Allocates a byte or string literal for `mir::interpret`\n     pub fn allocate_cached(self, bytes: &[u8]) -> interpret::AllocId {\n         // check whether we already allocated this literal or a constant with the same memory\n-        if let Some(&alloc_id) = self.interpret_interner.borrow().literal_alloc_cache.get(bytes) {\n+        if let Some(&alloc_id) = self.interpret_interner.inner.borrow()\n+                                     .literal_alloc_cache.get(bytes) {\n             return alloc_id;\n         }\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n \n-        let mut int = self.interpret_interner.borrow_mut();\n         // the next unique id\n-        let id = int.reserve();\n+        let id = self.interpret_interner.reserve();\n         // make the allocation identifiable\n-        int.alloc_by_id.insert(id, alloc);\n+        self.interpret_interner.inner.borrow_mut().alloc_by_id.insert(id, alloc);\n         // cache it for the future\n-        int.literal_alloc_cache.insert(bytes.to_owned(), id);\n+        self.interpret_interner.inner.borrow_mut().literal_alloc_cache.insert(bytes.to_owned(), id);\n         id\n     }\n \n@@ -1248,6 +1270,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n+    /// Due to missing llvm support for lowering 128 bit math to software emulation\n+    /// (on some targets), the lowering can be done in MIR.\n+    ///\n+    /// This function only exists until said support is implemented.\n+    pub fn is_binop_lang_item(&self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n+        let items = self.lang_items();\n+        let def_id = Some(def_id);\n+        if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n+        else if items.u128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n+        else if items.i128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n+        else if items.u128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n+        else if items.i128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n+        else if items.u128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n+        else if items.i128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n+        else if items.u128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n+        else if items.i128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n+        else if items.u128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n+        else if items.i128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n+        else if items.u128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n+        else if items.i128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n+        else if items.u128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n+        else if items.i128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n+        else if items.u128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n+        else if items.i128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n+        else if items.u128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n+        else if items.i128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n+        else if items.u128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n+        else if items.i128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n+        else if items.u128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n+        else if items.i128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n+        else if items.u128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n+        else { None }\n+    }\n+\n     pub fn stability(self) -> Lrc<stability::Index<'tcx>> {\n         self.stability_index(LOCAL_CRATE)\n     }\n@@ -1321,7 +1377,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n \n-    pub fn create_stable_hashing_context(self) -> StableHashingContext<'gcx> {\n+    pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n         let krate = self.dep_graph.with_ignore(|| self.gcx.hir.krate());\n \n         StableHashingContext::new(self.sess,\n@@ -1731,7 +1787,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n         println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n-        println!(\"Interpret interner: #{}\", self.interpret_interner.borrow().allocs.len());\n+        println!(\"Interpret interner: #{}\", self.interpret_interner.inner.borrow().allocs.len());\n         println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n     }\n }\n@@ -2043,13 +2099,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        let n = ConstUsize::new(n, self.sess.target.usize_ty).unwrap();\n-        self.mk_array_const_usize(ty, n)\n-    }\n-\n-    pub fn mk_array_const_usize(self, ty: Ty<'tcx>, n: ConstUsize) -> Ty<'tcx> {\n         self.mk_ty(TyArray(ty, self.mk_const(ty::Const {\n-            val: ConstVal::Integral(ConstInt::Usize(n)),\n+            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n.into()))),\n             ty: self.types.usize\n         })))\n     }"}, {"sha": "dcb70a8f86a8a38084223b4fbb6fa20461bb0299", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,17 +9,13 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use middle::const_val::ConstVal;\n use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n-\n use std::fmt;\n use syntax::abi;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n-use rustc_const_math::ConstInt;\n-\n use hir;\n \n #[derive(Clone, Copy, Debug)]\n@@ -186,10 +182,9 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n             ty::TyForeign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n             ty::TyArray(_, n) => {\n-                if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n-                    format!(\"array of {} elements\", n)\n-                } else {\n-                    \"array\".to_string()\n+                match n.val.to_raw_bits() {\n+                    Some(n) => format!(\"array of {} elements\", n),\n+                    None => \"array\".to_string(),\n                 }\n             }\n             ty::TySlice(_) => \"slice\".to_string(),"}, {"sha": "93d8a4d979de6d1b020ff0e273f7af0ba130fce9", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -154,12 +154,12 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n     }\n }\n \n-impl<'gcx, D> HashStable<StableHashingContext<'gcx>> for SimplifiedTypeGen<D>\n+impl<'a, 'gcx, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n     where D: Copy + Debug + Ord + Eq + Hash +\n-             HashStable<StableHashingContext<'gcx>>,\n+             HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "f067789771c59ba6115e782dde94e85dbcc136e1", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_val::{ConstVal, ConstAggregate};\n+use middle::const_val::ConstVal;\n use ty::subst::Substs;\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n@@ -218,30 +218,7 @@ impl FlagComputation {\n     fn add_const(&mut self, constant: &ty::Const) {\n         self.add_ty(constant.ty);\n         match constant.val {\n-            ConstVal::Integral(_) |\n-            ConstVal::Float(_) |\n-            ConstVal::Str(_) |\n-            ConstVal::ByteStr(_) |\n-            ConstVal::Bool(_) |\n-            ConstVal::Char(_) |\n-            ConstVal::Variant(_) => {}\n-            ConstVal::Function(_, substs) => {\n-                self.add_substs(substs);\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                for &(_, v) in fields {\n-                    self.add_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                for v in fields {\n-                    self.add_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-                self.add_const(v);\n-            }\n+            ConstVal::Value(_) => {}\n             ConstVal::Unevaluated(_, substs) => {\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_substs(substs);"}, {"sha": "3e653cf126a8d521c6ecf7bf6658581a7ff6ae4b", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             },\n             TyArray(ty, len) => {\n-                match len.val.to_const_int().and_then(|i| i.to_u64()) {\n+                match len.val.to_raw_bits() {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n                     Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),"}, {"sha": "614158bafa63807332ec72f31d34875f2253f6c3", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -17,13 +17,13 @@ use util::ppaux;\n \n use std::fmt;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Instance<'tcx> {\n     pub def: InstanceDef<'tcx>,\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),"}, {"sha": "1b919ad68d047069d141ed0d736a07e570786e0f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -342,7 +342,7 @@ impl AddAssign for Size {\n /// Each field is a power of two, giving the alignment a maximum\n /// value of 2<sup>(2<sup>8</sup> - 1)</sup>, which is limited by LLVM to a i32, with\n /// a maximum capacity of 2<sup>31</sup> - 1 or 2147483647.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Align {\n     abi: u8,\n     pref: u8,\n@@ -794,6 +794,17 @@ impl Abi {\n             Abi::Aggregate { sized } => !sized\n         }\n     }\n+\n+    /// Returns true if this is a single signed integer scalar\n+    pub fn is_signed(&self) -> bool {\n+        match *self {\n+            Abi::Scalar(ref scal) => match scal.value {\n+                Primitive::Int(_, signed) => signed,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n@@ -1237,7 +1248,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 let element = self.layout_of(element)?;\n-                let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n+                let count = count.val.unwrap_u64();\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n@@ -1537,7 +1548,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     if variants[i].iter().any(|f| f.abi == Abi::Uninhabited) {\n                         continue;\n                     }\n-                    let x = discr.to_u128_unchecked() as i128;\n+                    let x = discr.val as i128;\n                     if x < min { min = x; }\n                     if x > max { max = x; }\n                 }\n@@ -2369,9 +2380,9 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n+impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::Variants::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2405,9 +2416,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement {\n+impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::FieldPlacement::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2428,9 +2439,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n+impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::Abi::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2455,9 +2466,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Scalar {\n+impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let Scalar { value, valid_range: RangeInclusive { start, end } } = *self;\n         value.hash_stable(hcx, hasher);\n@@ -2498,10 +2509,10 @@ impl_stable_hash_for!(struct ::ty::layout::Size {\n     raw\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LayoutError<'gcx>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "21affcbc9ede7c945b7a2c91a94eb1302386e038", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -10,9 +10,10 @@\n \n use dep_graph::SerializedDepNodeIndex;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n+use mir::interpret::{GlobalId};\n use ty::{self, Ty, TyCtxt};\n-use ty::maps::queries;\n use ty::subst::Substs;\n+use ty::maps::queries;\n \n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n@@ -152,8 +153,8 @@ impl<'tcx> QueryDescription<'tcx> for queries::reachable_set<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n-    fn describe(tcx: TyCtxt, key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>) -> String {\n-        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.0))\n+    fn describe(tcx: TyCtxt, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>) -> String {\n+        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.instance.def.def_id()))\n     }\n }\n "}, {"sha": "8fb1ad0da823b48ee694916fc8c4b4cd7da4f6b2", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -14,6 +14,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n+use mir;\n \n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -52,6 +53,16 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        self.instance.map_crate()\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.instance.default_span(tcx)\n+    }\n+}\n+\n impl Key for CrateNum {\n     fn map_crate(&self) -> CrateNum {\n         *self"}, {"sha": "0ded759fec730c55d86e0ca87de6e24e694d5076", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,7 +16,6 @@ use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n use lint;\n use middle::borrowck::BorrowCheckResult;\n-use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n                      ExternBodyNestedBodies};\n use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n@@ -27,8 +26,10 @@ use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n+use middle::const_val::EvalResult;\n use mir::mono::{CodegenUnit, Stats};\n use mir;\n+use mir::interpret::{GlobalId};\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n use traits::Vtable;\n@@ -210,8 +211,8 @@ define_maps! { <'tcx>\n \n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n-    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n-        -> const_val::EvalResult<'tcx>,\n+    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+        -> EvalResult<'tcx>,\n \n     [] fn check_match: CheckMatch(DefId)\n         -> Result<(), ErrorReported>,\n@@ -450,7 +451,7 @@ fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::TypeckBodiesKrate\n }\n \n-fn const_eval_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n+fn const_eval_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n                              -> DepConstructor<'tcx> {\n     DepConstructor::ConstEval { param_env }\n }"}, {"sha": "49c4b8bc49d8ce4bcd4469cf1adaf9f23ad3d259", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n                   RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n use hir::map::definitions::DefPathHash;\n use ich::{CachingCodemapView, Fingerprint};\n-use mir;\n+use mir::{self, interpret};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -187,6 +187,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 type_shorthands: FxHashMap(),\n                 predicate_shorthands: FxHashMap(),\n                 expn_info_shorthands: FxHashMap(),\n+                interpret_alloc_shorthands: FxHashMap(),\n                 codemap: CachingCodemapView::new(tcx.sess.codemap()),\n                 file_to_file_index,\n             };\n@@ -362,6 +363,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n             synthetic_expansion_infos: &self.synthetic_expansion_infos,\n+            interpret_alloc_cache: FxHashMap::default(),\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -423,6 +425,7 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     synthetic_expansion_infos: &'x RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'x RefCell<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n+    interpret_alloc_cache: FxHashMap<usize, interpret::AllocId>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n@@ -542,6 +545,50 @@ impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx,\n \n implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n \n+impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n+        const MAX1: usize = usize::max_value() - 1;\n+        let tcx = self.tcx;\n+        let pos = TyDecoder::position(self);\n+        match usize::decode(self)? {\n+            ::std::usize::MAX => {\n+                let alloc_id = tcx.interpret_interner.reserve();\n+                trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n+                // insert early to allow recursive allocs\n+                self.interpret_alloc_cache.insert(pos, alloc_id);\n+\n+                let allocation = interpret::Allocation::decode(self)?;\n+                trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n+                let allocation = self.tcx.intern_const_alloc(allocation);\n+                tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n+\n+                if let Some(glob) = Option::<DefId>::decode(self)? {\n+                    tcx.interpret_interner.cache(glob, alloc_id);\n+                }\n+\n+                Ok(alloc_id)\n+            },\n+            MAX1 => {\n+                trace!(\"creating fn alloc id at {}\", pos);\n+                let instance = ty::Instance::decode(self)?;\n+                trace!(\"decoded fn alloc instance: {:?}\", instance);\n+                let id = tcx.interpret_interner.create_fn_alloc(instance);\n+                trace!(\"created fn alloc id: {:?}\", id);\n+                self.interpret_alloc_cache.insert(pos, id);\n+                Ok(id)\n+            },\n+            shorthand => {\n+                trace!(\"loading shorthand {}\", shorthand);\n+                if let Some(&alloc_id) = self.interpret_alloc_cache.get(&shorthand) {\n+                    return Ok(alloc_id);\n+                }\n+                trace!(\"shorthand {} not cached, loading entire allocation\", shorthand);\n+                // need to load allocation\n+                self.with_position(shorthand, |this| interpret::AllocId::decode(this))\n+            },\n+        }\n+    }\n+}\n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let tag: u8 = Decodable::decode(self)?;\n@@ -703,6 +750,7 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n     expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n+    interpret_alloc_shorthands: FxHashMap<interpret::AllocId, usize>,\n     codemap: CachingCodemapView<'tcx>,\n     file_to_file_index: FxHashMap<*const FileMap, FileMapIndex>,\n }\n@@ -735,6 +783,37 @@ impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     }\n }\n \n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n+        trace!(\"encoding {:?} at {}\", alloc_id, self.position());\n+        if let Some(shorthand) = self.interpret_alloc_shorthands.get(alloc_id).cloned() {\n+            trace!(\"encoding {:?} as shorthand to {}\", alloc_id, shorthand);\n+            return shorthand.encode(self);\n+        }\n+        let start = self.position();\n+        // cache the allocation shorthand now, because the allocation itself might recursively\n+        // point to itself.\n+        self.interpret_alloc_shorthands.insert(*alloc_id, start);\n+        if let Some(alloc) = self.tcx.interpret_interner.get_alloc(*alloc_id) {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n+            usize::max_value().encode(self)?;\n+            alloc.encode(self)?;\n+            self.tcx.interpret_interner\n+                .get_corresponding_static_def_id(*alloc_id)\n+                .encode(self)?;\n+        } else if let Some(fn_instance) = self.tcx.interpret_interner.get_fn(*alloc_id) {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n+            (usize::max_value() - 1).encode(self)?;\n+            fn_instance.encode(self)?;\n+        } else {\n+            bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {"}, {"sha": "63494438f7d82e6866088d934542f9e883bab9ae", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 85, "deletions": 51, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -26,12 +26,13 @@ use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangIte\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n+use mir::interpret::{GlobalId, Value, PrimVal};\n use mir::GeneratorLayout;\n use session::CrateDisambiguator;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n-use ty::util::IntTypeExt;\n+use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n use util::common::ErrorReported;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n@@ -52,7 +53,6 @@ use syntax::attr;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n-use rustc_const_math::ConstInt;\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n@@ -79,7 +79,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, GlobalArenas, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables};\n+pub use self::context::{Lift, TypeckTables, InterpretInterner};\n \n pub use self::instance::{Instance, InstanceDef};\n \n@@ -528,9 +528,9 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TyS<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::TyS<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TyS {\n             ref sty,\n@@ -1439,11 +1439,11 @@ impl<'tcx, T> ParamEnvAnd<'tcx, T> {\n     }\n }\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for ParamEnvAnd<'gcx, T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'gcx, T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ParamEnvAnd {\n             ref param_env,\n@@ -1544,9 +1544,9 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for AdtDef {\n+impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<usize, Fingerprint>> =\n@@ -1824,27 +1824,79 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                         -> impl Iterator<Item=ConstInt> + 'a {\n+    pub fn eval_explicit_discr(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        expr_did: DefId,\n+    ) -> Option<Discr<'tcx>> {\n         let param_env = ParamEnv::empty(traits::Reveal::UserFacing);\n         let repr_type = self.repr.discr_type();\n+        let bit_size = layout::Integer::from_attr(tcx, repr_type).size().bits();\n+        let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n+        let instance = ty::Instance::new(expr_did, substs);\n+        let cid = GlobalId {\n+            instance,\n+            promoted: None\n+        };\n+        match tcx.const_eval(param_env.and(cid)) {\n+            Ok(&ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n+                ..\n+            }) => {\n+                trace!(\"discriminants: {} ({:?})\", b, repr_type);\n+                let ty = repr_type.to_ty(tcx);\n+                if repr_type.is_signed() {\n+                    let val = b as i128;\n+                    // sign extend to i128\n+                    let amt = 128 - bit_size;\n+                    let val = (val << amt) >> amt;\n+                    Some(Discr {\n+                        val: val as u128,\n+                        ty,\n+                    })\n+                } else {\n+                    Some(Discr {\n+                        val: b,\n+                        ty,\n+                    })\n+                }\n+            },\n+            Ok(&ty::Const {\n+                val: ConstVal::Value(other),\n+                ..\n+            }) => {\n+                info!(\"invalid enum discriminant: {:#?}\", other);\n+                ::middle::const_val::struct_error(\n+                    tcx,\n+                    tcx.def_span(expr_did),\n+                    \"constant evaluation of enum discriminant resulted in non-integer\",\n+                ).emit();\n+                None\n+            }\n+            Err(err) => {\n+                err.report(tcx, tcx.def_span(expr_did), \"enum discriminant\");\n+                if !expr_did.is_local() {\n+                    span_bug!(tcx.def_span(expr_did),\n+                        \"variant discriminant evaluation succeeded \\\n+                            in its crate but failed locally\");\n+                }\n+                None\n+            }\n+            _ => span_bug!(tcx.def_span(expr_did), \"const eval \"),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                         -> impl Iterator<Item=Discr<'tcx>> + 'a {\n+        let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n-        let mut prev_discr = None::<ConstInt>;\n+        let mut prev_discr = None::<Discr<'tcx>>;\n         self.variants.iter().map(move |v| {\n-            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n+            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n-                match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                    Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n-                        discr = v;\n-                    }\n-                    err => {\n-                        if !expr_did.is_local() {\n-                            span_bug!(tcx.def_span(expr_did),\n-                                \"variant discriminant evaluation succeeded \\\n-                                 in its crate but failed locally: {:?}\", err);\n-                        }\n-                    }\n+                if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n+                    discr = new_discr;\n                 }\n             }\n             prev_discr = Some(discr);\n@@ -1861,8 +1913,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     pub fn discriminant_for_variant(&self,\n                                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                     variant_index: usize)\n-                                    -> ConstInt {\n-        let param_env = ParamEnv::empty(traits::Reveal::UserFacing);\n+                                    -> Discr<'tcx> {\n         let repr_type = self.repr.discr_type();\n         let mut explicit_value = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut explicit_index = variant_index;\n@@ -1873,18 +1924,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     explicit_index -= distance;\n                 }\n                 ty::VariantDiscr::Explicit(expr_did) => {\n-                    let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n-                    match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                        Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n-                            explicit_value = v;\n+                    match self.eval_explicit_discr(tcx, expr_did) {\n+                        Some(discr) => {\n+                            explicit_value = discr;\n                             break;\n-                        }\n-                        err => {\n-                            if !expr_did.is_local() {\n-                                span_bug!(tcx.def_span(expr_did),\n-                                    \"variant discriminant evaluation succeeded \\\n-                                     in its crate but failed locally: {:?}\", err);\n-                            }\n+                        },\n+                        None => {\n                             if explicit_index == 0 {\n                                 break;\n                             }\n@@ -1894,18 +1939,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n             }\n         }\n-        let discr = explicit_value.to_u128_unchecked()\n-            .wrapping_add((variant_index - explicit_index) as u128);\n-        match repr_type {\n-            attr::UnsignedInt(ty) => {\n-                ConstInt::new_unsigned_truncating(discr, ty,\n-                                                  tcx.sess.target.usize_ty)\n-            }\n-            attr::SignedInt(ty) => {\n-                ConstInt::new_signed_truncating(discr as i128, ty,\n-                                                tcx.sess.target.isize_ty)\n-            }\n-        }\n+        explicit_value.checked_add(tcx, (variant_index - explicit_index) as u128).0\n     }\n \n     pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {"}, {"sha": "bae1ce31a5e774c3f5ecbd1cdeeb1dd371095250", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -20,6 +20,7 @@ use ty::subst::{UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::{TypeVisitor, TypeFolder};\n use ty::error::{ExpectedFound, TypeError};\n+use mir::interpret::{GlobalId, Value, PrimVal};\n use util::common::ErrorReported;\n use std::rc::Rc;\n use std::iter;\n@@ -482,19 +483,35 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             assert_eq!(sz_b.ty, tcx.types.usize);\n             let to_u64 = |x: &'tcx ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n                 match x.val {\n-                    ConstVal::Integral(x) => Ok(x.to_u64().unwrap()),\n+                    ConstVal::Value(Value::ByVal(prim)) => Ok(prim.to_u64().unwrap()),\n                     ConstVal::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                         match tcx.lift_to_global(&substs) {\n                             Some(substs) => {\n-                                match tcx.const_eval(param_env.and((def_id, substs))) {\n-                                    Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => {\n-                                        return Ok(x.to_u64().unwrap());\n+                                let instance = ty::Instance::resolve(\n+                                    tcx.global_tcx(),\n+                                    param_env,\n+                                    def_id,\n+                                    substs,\n+                                );\n+                                if let Some(instance) = instance {\n+                                    let cid = GlobalId {\n+                                        instance,\n+                                        promoted: None\n+                                    };\n+                                    match tcx.const_eval(param_env.and(cid)) {\n+                                        Ok(&ty::Const {\n+                                            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n+                                            ..\n+                                        }) => {\n+                                            assert_eq!(b as u64 as u128, b);\n+                                            return Ok(b as u64);\n+                                        }\n+                                        _ => {}\n                                     }\n-                                    _ => {}\n                                 }\n-                            }\n+                            },\n                             None => {}\n                         }\n                         tcx.sess.delay_span_bug(tcx.def_span(def_id),"}, {"sha": "78fccaa113106c80f65677061c14fbc4f285eafe", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 218, "deletions": 80, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -13,11 +13,12 @@\n //! hand, though we've recently added some macros (e.g.,\n //! `BraceStructLiftImpl!`) to help with the tedium.\n \n-use middle::const_val::{self, ConstVal, ConstAggregate, ConstEvalErr};\n+use middle::const_val::{self, ConstVal, ConstEvalErr};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use mir::interpret;\n \n use std::rc::Rc;\n \n@@ -56,6 +57,7 @@ CopyImpls! {\n     ::syntax::abi::Abi,\n     ::hir::def_id::DefId,\n     ::mir::Local,\n+    ::mir::Promoted,\n     ::traits::Reveal,\n     ::syntax_pos::Span,\n }\n@@ -576,44 +578,139 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ConstEvalErr<'a> {\n     type Lifted = ConstEvalErr<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.kind).map(|kind| {\n+        tcx.lift(&*self.kind).map(|kind| {\n             ConstEvalErr {\n                 span: self.span,\n-                kind,\n+                kind: Rc::new(kind),\n             }\n         })\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n+    type Lifted = interpret::EvalError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        use ::mir::interpret::EvalErrorKind::*;\n+        let kind = match self.kind {\n+            MachineError(ref err) => MachineError(err.clone()),\n+            FunctionPointerTyMismatch(a, b) => FunctionPointerTyMismatch(\n+                tcx.lift(&a)?,\n+                tcx.lift(&b)?,\n+            ),\n+            NoMirFor(ref s) => NoMirFor(s.clone()),\n+            UnterminatedCString(ptr) => UnterminatedCString(ptr),\n+            DanglingPointerDeref => DanglingPointerDeref,\n+            DoubleFree => DoubleFree,\n+            InvalidMemoryAccess => InvalidMemoryAccess,\n+            InvalidFunctionPointer => InvalidFunctionPointer,\n+            InvalidBool => InvalidBool,\n+            InvalidDiscriminant => InvalidDiscriminant,\n+            PointerOutOfBounds {\n+                ptr,\n+                access,\n+                allocation_size,\n+            } => PointerOutOfBounds { ptr, access, allocation_size },\n+            InvalidNullPointerUsage => InvalidNullPointerUsage,\n+            ReadPointerAsBytes => ReadPointerAsBytes,\n+            ReadBytesAsPointer => ReadBytesAsPointer,\n+            InvalidPointerMath => InvalidPointerMath,\n+            ReadUndefBytes => ReadUndefBytes,\n+            DeadLocal => DeadLocal,\n+            InvalidBoolOp(bop) => InvalidBoolOp(bop),\n+            Unimplemented(ref s) => Unimplemented(s.clone()),\n+            DerefFunctionPointer => DerefFunctionPointer,\n+            ExecuteMemory => ExecuteMemory,\n+            ArrayIndexOutOfBounds(sp, a, b) => ArrayIndexOutOfBounds(sp, a, b),\n+            Math(sp, ref err) => Math(sp, err.clone()),\n+            Intrinsic(ref s) => Intrinsic(s.clone()),\n+            OverflowingMath => OverflowingMath,\n+            InvalidChar(c) => InvalidChar(c),\n+            ExecutionTimeLimitReached => ExecutionTimeLimitReached,\n+            StackFrameLimitReached => StackFrameLimitReached,\n+            OutOfTls => OutOfTls,\n+            TlsOutOfBounds => TlsOutOfBounds,\n+            AbiViolation(ref s) => AbiViolation(s.clone()),\n+            AlignmentCheckFailed {\n+                required,\n+                has,\n+            } => AlignmentCheckFailed { required, has },\n+            MemoryLockViolation {\n+                ptr,\n+                len,\n+                frame,\n+                access,\n+                ref lock,\n+            } => MemoryLockViolation { ptr, len, frame, access, lock: lock.clone() },\n+            MemoryAcquireConflict {\n+                ptr,\n+                len,\n+                kind,\n+                ref lock,\n+            } => MemoryAcquireConflict { ptr, len, kind, lock: lock.clone() },\n+            InvalidMemoryLockRelease {\n+                ptr,\n+                len,\n+                frame,\n+                ref lock,\n+            } => InvalidMemoryLockRelease { ptr, len, frame, lock: lock.clone() },\n+            DeallocatedLockedMemory {\n+                ptr,\n+                ref lock,\n+            } => DeallocatedLockedMemory { ptr, lock: lock.clone() },\n+            ValidationFailure(ref s) => ValidationFailure(s.clone()),\n+            CalledClosureAsFunction => CalledClosureAsFunction,\n+            VtableForArgumentlessMethod => VtableForArgumentlessMethod,\n+            ModifiedConstantMemory => ModifiedConstantMemory,\n+            AssumptionNotHeld => AssumptionNotHeld,\n+            InlineAsm => InlineAsm,\n+            TypeNotPrimitive(ty) => TypeNotPrimitive(tcx.lift(&ty)?),\n+            ReallocatedWrongMemoryKind(ref a, ref b) => {\n+                ReallocatedWrongMemoryKind(a.clone(), b.clone())\n+            },\n+            DeallocatedWrongMemoryKind(ref a, ref b) => {\n+                DeallocatedWrongMemoryKind(a.clone(), b.clone())\n+            },\n+            ReallocateNonBasePtr => ReallocateNonBasePtr,\n+            DeallocateNonBasePtr => DeallocateNonBasePtr,\n+            IncorrectAllocationInformation(a, b, c, d) => {\n+                IncorrectAllocationInformation(a, b, c, d)\n+            },\n+            Layout(lay) => Layout(tcx.lift(&lay)?),\n+            HeapAllocZeroBytes => HeapAllocZeroBytes,\n+            HeapAllocNonPowerOfTwoAlignment(n) => HeapAllocNonPowerOfTwoAlignment(n),\n+            Unreachable => Unreachable,\n+            Panic => Panic,\n+            ReadFromReturnPointer => ReadFromReturnPointer,\n+            PathNotFound(ref v) => PathNotFound(v.clone()),\n+            UnimplementedTraitSelection => UnimplementedTraitSelection,\n+            TypeckError => TypeckError,\n+            ReferencedConstant => ReferencedConstant,\n+        };\n+        Some(interpret::EvalError {\n+            kind: kind,\n+            backtrace: self.backtrace.clone(),\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for const_val::ErrKind<'a> {\n     type Lifted = const_val::ErrKind<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         use middle::const_val::ErrKind::*;\n \n         Some(match *self {\n-            CannotCast => CannotCast,\n-            MissingStructField => MissingStructField,\n             NonConstPath => NonConstPath,\n             UnimplementedConstVal(s) => UnimplementedConstVal(s),\n-            ExpectedConstTuple => ExpectedConstTuple,\n-            ExpectedConstStruct => ExpectedConstStruct,\n-            IndexedNonVec => IndexedNonVec,\n-            IndexNotUsize => IndexNotUsize,\n             IndexOutOfBounds { len, index } => IndexOutOfBounds { len, index },\n-            MiscBinaryOp => MiscBinaryOp,\n-            MiscCatchAll => MiscCatchAll,\n-            IndexOpFeatureGated => IndexOpFeatureGated,\n             Math(ref e) => Math(e.clone()),\n \n             LayoutError(ref e) => {\n                 return tcx.lift(e).map(LayoutError)\n             }\n-            ErroneousReferencedConstant(ref e) => {\n-                return tcx.lift(e).map(ErroneousReferencedConstant)\n-            }\n \n             TypeckError => TypeckError,\n             CheckMatchError => CheckMatchError,\n+            Miri(ref e, ref frames) => return tcx.lift(e).map(|e| Miri(e, frames.clone())),\n         })\n     }\n }\n@@ -632,6 +729,42 @@ impl<'a, 'tcx> Lift<'tcx> for ty::layout::LayoutError<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n+    type Lifted = ty::InstanceDef<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::InstanceDef::Item(def_id) =>\n+                Some(ty::InstanceDef::Item(def_id)),\n+            ty::InstanceDef::Intrinsic(def_id) =>\n+                Some(ty::InstanceDef::Intrinsic(def_id)),\n+            ty::InstanceDef::FnPtrShim(def_id, ref ty) =>\n+                Some(ty::InstanceDef::FnPtrShim(def_id, tcx.lift(ty)?)),\n+            ty::InstanceDef::Virtual(def_id, n) =>\n+                Some(ty::InstanceDef::Virtual(def_id, n)),\n+            ty::InstanceDef::ClosureOnceShim { call_once } =>\n+                Some(ty::InstanceDef::ClosureOnceShim { call_once }),\n+            ty::InstanceDef::DropGlue(def_id, ref ty) =>\n+                Some(ty::InstanceDef::DropGlue(def_id, tcx.lift(ty)?)),\n+            ty::InstanceDef::CloneShim(def_id, ref ty) =>\n+                Some(ty::InstanceDef::CloneShim(def_id, tcx.lift(ty)?)),\n+        }\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ty::Instance<'a> {\n+        type Lifted = ty::Instance<'tcx>;\n+        def, substs\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for interpret::GlobalId<'a> {\n+        type Lifted = interpret::GlobalId<'tcx>;\n+        instance, promoted\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -778,6 +911,74 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use ty::InstanceDef::*;\n+        Self {\n+            substs: self.substs.fold_with(folder),\n+            def: match self.def {\n+                Item(did) => Item(did.fold_with(folder)),\n+                Intrinsic(did) => Intrinsic(did.fold_with(folder)),\n+                FnPtrShim(did, ty) => FnPtrShim(\n+                    did.fold_with(folder),\n+                    ty.fold_with(folder),\n+                ),\n+                Virtual(did, i) => Virtual(\n+                    did.fold_with(folder),\n+                    i,\n+                ),\n+                ClosureOnceShim { call_once } => ClosureOnceShim {\n+                    call_once: call_once.fold_with(folder),\n+                },\n+                DropGlue(did, ty) => DropGlue(\n+                    did.fold_with(folder),\n+                    ty.fold_with(folder),\n+                ),\n+                CloneShim(did, ty) => CloneShim(\n+                    did.fold_with(folder),\n+                    ty.fold_with(folder),\n+                ),\n+            },\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use ty::InstanceDef::*;\n+        self.substs.visit_with(visitor) ||\n+        match self.def {\n+            Item(did) => did.visit_with(visitor),\n+            Intrinsic(did) => did.visit_with(visitor),\n+            FnPtrShim(did, ty) => {\n+                did.visit_with(visitor) ||\n+                ty.visit_with(visitor)\n+            },\n+            Virtual(did, _) => did.visit_with(visitor),\n+            ClosureOnceShim { call_once } => call_once.visit_with(visitor),\n+            DropGlue(did, ty) => {\n+                did.visit_with(visitor) ||\n+                ty.visit_with(visitor)\n+            },\n+            CloneShim(did, ty) => {\n+                did.visit_with(visitor) ||\n+                ty.visit_with(visitor)\n+            },\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        Self {\n+            instance: self.instance.fold_with(folder),\n+            promoted: self.promoted\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.instance.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n@@ -1243,53 +1444,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstVal<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstVal::Integral(i) => ConstVal::Integral(i),\n-            ConstVal::Float(f) => ConstVal::Float(f),\n-            ConstVal::Str(s) => ConstVal::Str(s),\n-            ConstVal::ByteStr(b) => ConstVal::ByteStr(b),\n-            ConstVal::Bool(b) => ConstVal::Bool(b),\n-            ConstVal::Char(c) => ConstVal::Char(c),\n-            ConstVal::Variant(def_id) => ConstVal::Variant(def_id),\n-            ConstVal::Function(def_id, substs) => {\n-                ConstVal::Function(def_id, substs.fold_with(folder))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                let new_fields: Vec<_> = fields.iter().map(|&(name, v)| {\n-                    (name, v.fold_with(folder))\n-                }).collect();\n-                let fields = if new_fields == fields {\n-                    fields\n-                } else {\n-                    folder.tcx().alloc_name_const_slice(&new_fields)\n-                };\n-                ConstVal::Aggregate(ConstAggregate::Struct(fields))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) => {\n-                let new_fields: Vec<_> = fields.iter().map(|v| {\n-                    v.fold_with(folder)\n-                }).collect();\n-                let fields = if new_fields == fields {\n-                    fields\n-                } else {\n-                    folder.tcx().alloc_const_slice(&new_fields)\n-                };\n-                ConstVal::Aggregate(ConstAggregate::Tuple(fields))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                let new_fields: Vec<_> = fields.iter().map(|v| {\n-                    v.fold_with(folder)\n-                }).collect();\n-                let fields = if new_fields == fields {\n-                    fields\n-                } else {\n-                    folder.tcx().alloc_const_slice(&new_fields)\n-                };\n-                ConstVal::Aggregate(ConstAggregate::Array(fields))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, count)) => {\n-                let v = v.fold_with(folder);\n-                ConstVal::Aggregate(ConstAggregate::Repeat(v, count))\n-            }\n+            ConstVal::Value(v) => ConstVal::Value(v),\n             ConstVal::Unevaluated(def_id, substs) => {\n                 ConstVal::Unevaluated(def_id, substs.fold_with(folder))\n             }\n@@ -1298,24 +1453,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstVal<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ConstVal::Integral(_) |\n-            ConstVal::Float(_) |\n-            ConstVal::Str(_) |\n-            ConstVal::ByteStr(_) |\n-            ConstVal::Bool(_) |\n-            ConstVal::Char(_) |\n-            ConstVal::Variant(_) => false,\n-            ConstVal::Function(_, substs) => substs.visit_with(visitor),\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                fields.iter().any(|&(_, v)| v.visit_with(visitor))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                fields.iter().any(|v| v.visit_with(visitor))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-                v.visit_with(visitor)\n-            }\n+            ConstVal::Value(_) => false,\n             ConstVal::Unevaluated(_, substs) => substs.visit_with(visitor),\n         }\n     }"}, {"sha": "32f0d3384c4dcea44d47bb5cd3086369b851dfcd", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -186,9 +186,9 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n+impl<'a> HashStable<StableHashingContext<'a>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             ref blanket_impls,"}, {"sha": "cbd9a1b8d4f932de801e58e65ec3364310348a4b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 109, "deletions": 77, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -22,60 +22,98 @@ use ty::fold::TypeVisitor;\n use ty::subst::{Subst, UnpackedKind};\n use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n+use ty::layout::Integer;\n use util::common::ErrorReported;\n use middle::lang_items;\n+use mir::interpret::{Value, PrimVal};\n \n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n use rustc_data_structures::fx::FxHashMap;\n-use std::cmp;\n+use std::{cmp, fmt};\n use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n-type Disr = ConstInt;\n-\n-pub trait IntTypeExt {\n-    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n-                           -> Option<Disr>;\n-    fn assert_ty_matches(&self, val: Disr);\n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n+#[derive(Copy, Clone, Debug)]\n+pub struct Discr<'tcx> {\n+    pub val: u128,\n+    pub ty: Ty<'tcx>\n }\n \n+impl<'tcx> fmt::Display for Discr<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        if self.ty.is_signed() {\n+            write!(fmt, \"{}\", self.val as i128)\n+        } else {\n+            write!(fmt, \"{}\", self.val)\n+        }\n+    }\n+}\n \n-macro_rules! typed_literal {\n-    ($tcx:expr, $ty:expr, $lit:expr) => {\n-        match $ty {\n-            SignedInt(ast::IntTy::I8)    => ConstInt::I8($lit),\n-            SignedInt(ast::IntTy::I16)   => ConstInt::I16($lit),\n-            SignedInt(ast::IntTy::I32)   => ConstInt::I32($lit),\n-            SignedInt(ast::IntTy::I64)   => ConstInt::I64($lit),\n-            SignedInt(ast::IntTy::I128)   => ConstInt::I128($lit),\n-            SignedInt(ast::IntTy::Isize) => match $tcx.sess.target.isize_ty {\n-                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16($lit)),\n-                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32($lit)),\n-                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64($lit)),\n-                _ => bug!(),\n-            },\n-            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8($lit),\n-            UnsignedInt(ast::UintTy::U16) => ConstInt::U16($lit),\n-            UnsignedInt(ast::UintTy::U32) => ConstInt::U32($lit),\n-            UnsignedInt(ast::UintTy::U64) => ConstInt::U64($lit),\n-            UnsignedInt(ast::UintTy::U128) => ConstInt::U128($lit),\n-            UnsignedInt(ast::UintTy::Usize) => match $tcx.sess.target.usize_ty {\n-                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16($lit)),\n-                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32($lit)),\n-                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64($lit)),\n-                _ => bug!(),\n-            },\n+impl<'tcx> Discr<'tcx> {\n+    /// Adds 1 to the value and wraps around if the maximum for the type is reached\n+    pub fn wrap_incr<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        self.checked_add(tcx, 1).0\n+    }\n+    pub fn checked_add<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, n: u128) -> (Self, bool) {\n+        let (int, signed) = match self.ty.sty {\n+            TyInt(ity) => (Integer::from_attr(tcx, SignedInt(ity)), true),\n+            TyUint(uty) => (Integer::from_attr(tcx, UnsignedInt(uty)), false),\n+            _ => bug!(\"non integer discriminant\"),\n+        };\n+        if signed {\n+            let (min, max) = match int {\n+                Integer::I8 => (i8::min_value() as i128, i8::max_value() as i128),\n+                Integer::I16 => (i16::min_value() as i128, i16::max_value() as i128),\n+                Integer::I32 => (i32::min_value() as i128, i32::max_value() as i128),\n+                Integer::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n+                Integer::I128 => (i128::min_value(), i128::max_value()),\n+            };\n+            let val = self.val as i128;\n+            let n = n as i128;\n+            let oflo = val > max - n;\n+            let val = if oflo {\n+                min + (n - (max - val) - 1)\n+            } else {\n+                val + n\n+            };\n+            (Self {\n+                val: val as u128,\n+                ty: self.ty,\n+            }, oflo)\n+        } else {\n+            let (min, max) = match int {\n+                Integer::I8 => (u8::min_value() as u128, u8::max_value() as u128),\n+                Integer::I16 => (u16::min_value() as u128, u16::max_value() as u128),\n+                Integer::I32 => (u32::min_value() as u128, u32::max_value() as u128),\n+                Integer::I64 => (u64::min_value() as u128, u64::max_value() as u128),\n+                Integer::I128 => (u128::min_value(), u128::max_value()),\n+            };\n+            let val = self.val;\n+            let oflo = val > max - n;\n+            let val = if oflo {\n+                min + (n - (max - val) - 1)\n+            } else {\n+                val + n\n+            };\n+            (Self {\n+                val: val,\n+                ty: self.ty,\n+            }, oflo)\n         }\n     }\n }\n \n+pub trait IntTypeExt {\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Discr<'tcx>>)\n+                           -> Option<Discr<'tcx>>;\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx>;\n+}\n+\n impl IntTypeExt for attr::IntType {\n     fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n@@ -94,33 +132,26 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n-        typed_literal!(tcx, *self, 0)\n-    }\n-\n-    fn assert_ty_matches(&self, val: Disr) {\n-        match (*self, val) {\n-            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n-            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n-            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n-            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n-            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n-            (SignedInt(ast::IntTy::Isize), ConstInt::Isize(_)) => {},\n-            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n-            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n-            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n-            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n-            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n-            (UnsignedInt(ast::UintTy::Usize), ConstInt::Usize(_)) => {},\n-            _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx> {\n+        Discr {\n+            val: 0,\n+            ty: self.to_ty(tcx)\n         }\n     }\n \n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n-                           -> Option<Disr> {\n+    fn disr_incr<'a, 'tcx>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        val: Option<Discr<'tcx>>,\n+    ) -> Option<Discr<'tcx>> {\n         if let Some(val) = val {\n-            self.assert_ty_matches(val);\n-            (val + typed_literal!(tcx, *self, 1)).ok()\n+            assert_eq!(self.to_ty(tcx), val.ty);\n+            let (new, oflo) = val.checked_add(tcx, 1);\n+            if oflo {\n+                None\n+            } else {\n+                Some(new)\n+            }\n         } else {\n             Some(self.initial_discriminant(tcx))\n         }\n@@ -681,31 +712,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn const_usize(&self, val: u16) -> ConstInt {\n-        match self.sess.target.usize_ty {\n-            ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n-            ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),\n-            ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(val as u64)),\n-            _ => bug!(),\n-        }\n-    }\n-\n-    /// Check if the node pointed to by def_id is a mutable static item\n-    pub fn is_static_mut(&self, def_id: DefId) -> bool {\n+    /// Return whether the node pointed to by def_id is a static item, and its mutability\n+    pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n         if let Some(node) = self.hir.get_if_local(def_id) {\n             match node {\n                 Node::NodeItem(&hir::Item {\n-                    node: hir::ItemStatic(_, hir::MutMutable, _), ..\n-                }) => true,\n+                    node: hir::ItemStatic(_, mutbl, _), ..\n+                }) => Some(mutbl),\n                 Node::NodeForeignItem(&hir::ForeignItem {\n-                    node: hir::ForeignItemStatic(_, mutbl), ..\n-                }) => mutbl,\n-                _ => false\n+                    node: hir::ForeignItemStatic(_, is_mutbl), ..\n+                }) =>\n+                    Some(if is_mutbl {\n+                        hir::Mutability::MutMutable\n+                    } else {\n+                        hir::Mutability::MutImmutable\n+                    }),\n+                _ => None\n             }\n         } else {\n             match self.describe_def(def_id) {\n-                Some(Def::Static(_, mutbl)) => mutbl,\n-                _ => false\n+                Some(Def::Static(_, is_mutbl)) =>\n+                    Some(if is_mutbl {\n+                        hir::Mutability::MutMutable\n+                    } else {\n+                        hir::Mutability::MutImmutable\n+                    }),\n+                _ => None\n             }\n         }\n     }\n@@ -764,7 +796,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyArray(_, n) => {\n                 self.hash_discriminant_u8(&n.val);\n                 match n.val {\n-                    ConstVal::Integral(x) => self.hash(x.to_u64().unwrap()),\n+                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => self.hash(b),\n                     ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n                     _ => bug!(\"arrays should not have {:?} as length\", n)\n                 }"}, {"sha": "722fdfe773a98bac45eab8bbf6a4ad5a260337ba", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -11,7 +11,7 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n-use middle::const_val::{ConstVal, ConstAggregate};\n+use middle::const_val::ConstVal;\n use ty::{self, Ty};\n use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n@@ -140,30 +140,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n \n fn push_const<'tcx>(stack: &mut TypeWalkerStack<'tcx>, constant: &'tcx ty::Const<'tcx>) {\n     match constant.val {\n-        ConstVal::Integral(_) |\n-        ConstVal::Float(_) |\n-        ConstVal::Str(_) |\n-        ConstVal::ByteStr(_) |\n-        ConstVal::Bool(_) |\n-        ConstVal::Char(_) |\n-        ConstVal::Variant(_) => {}\n-        ConstVal::Function(_, substs) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-            for &(_, v) in fields.iter().rev() {\n-                push_const(stack, v);\n-            }\n-        }\n-        ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-        ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-            for v in fields.iter().rev() {\n-                push_const(stack, v);\n-            }\n-        }\n-        ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-            push_const(stack, v);\n-        }\n+        ConstVal::Value(_) => {}\n         ConstVal::Unevaluated(_, substs) => {\n             stack.extend(substs.types().rev());\n         }"}, {"sha": "49ae79ae9c92c69b9babf214f6168d3d8da97bc6", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use middle::const_val::{ConstVal, ConstAggregate};\n+use middle::const_val::ConstVal;\n use infer::InferCtxt;\n use ty::subst::Substs;\n use traits;\n@@ -217,28 +217,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn compute_const(&mut self, constant: &'tcx ty::Const<'tcx>) {\n         self.require_sized(constant.ty, traits::ConstSized);\n         match constant.val {\n-            ConstVal::Integral(_) |\n-            ConstVal::Float(_) |\n-            ConstVal::Str(_) |\n-            ConstVal::ByteStr(_) |\n-            ConstVal::Bool(_) |\n-            ConstVal::Char(_) |\n-            ConstVal::Variant(_) |\n-            ConstVal::Function(..) => {}\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                for &(_, v) in fields {\n-                    self.compute_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                for v in fields {\n-                    self.compute_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-                self.compute_const(v);\n-            }\n+            ConstVal::Value(_) => {}\n             ConstVal::Unevaluated(def_id, substs) => {\n                 let obligations = self.nominal_obligations(def_id, substs);\n                 self.out.extend(obligations);"}, {"sha": "5e2792ee6410e6a1fe2d1b95aed8fca80e45ce60", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -21,12 +21,12 @@ use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, Ty\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use util::nodemap::FxHashSet;\n+use mir::interpret::{Value, PrimVal};\n \n use std::cell::Cell;\n use std::fmt;\n use std::usize;\n \n-use rustc_const_math::ConstInt;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::abi::Abi;\n use syntax::ast::CRATE_NODE_ID;\n@@ -1165,7 +1165,7 @@ define_print! {\n                 TyArray(ty, sz) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz.val {\n-                        ConstVal::Integral(ConstInt::Usize(sz)) => {\n+                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(sz))) => {\n                             write!(f, \"{}\", sz)?;\n                         }\n                         ConstVal::Unevaluated(_def_id, substs) => {"}, {"sha": "53b8402ab2ad5e7927a2b3464498853e4fd7d11c", "filename": "src/librustc_const_eval/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_const_eval\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rustc_const_eval\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-arena = { path = \"../libarena\" }\n-log = \"0.4\"\n-rustc = { path = \"../librustc\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n-syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "d01b3c45f7fd1642603e3402008addf6085d6c5f", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 571, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,571 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_snake_case)]\n-\n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80 characters.\n-// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n-register_long_diagnostics! {\n-\n-E0001: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error suggests that the expression arm corresponding to the noted pattern\n-will never be reached as for all possible values of the expression being\n-matched, one of the preceding patterns will match.\n-\n-This means that perhaps some of the preceding patterns are too general, this\n-one is too specific or the ordering is incorrect.\n-\n-For example, the following `match` block has too many arms:\n-\n-```\n-match Some(0) {\n-    Some(bar) => {/* ... */}\n-    x => {/* ... */} // This handles the `None` case\n-    _ => {/* ... */} // All possible cases have already been handled\n-}\n-```\n-\n-`match` blocks have their patterns matched in order, so, for example, putting\n-a wildcard arm above a more specific arm will make the latter arm irrelevant.\n-\n-Ensure the ordering of the match arm is correct and remove any superfluous\n-arms.\n-\"##,\n-\n-E0002: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error indicates that an empty match expression is invalid because the type\n-it is matching on is non-empty (there exist values of this type). In safe code\n-it is impossible to create an instance of an empty type, so empty match\n-expressions are almost never desired. This error is typically fixed by adding\n-one or more cases to the match expression.\n-\n-An example of an empty type is `enum Empty { }`. So, the following will work:\n-\n-```\n-enum Empty {}\n-\n-fn foo(x: Empty) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\n-However, this won't:\n-\n-```compile_fail\n-fn foo(x: Option<String>) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\"##,\n-\n-E0003: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Not-a-Number (NaN) values cannot be compared for equality and hence can never\n-match the input to a match expression. So, the following will not compile:\n-\n-```compile_fail\n-const NAN: f32 = 0.0 / 0.0;\n-\n-let number = 0.1f32;\n-\n-match number {\n-    NAN => { /* ... */ },\n-    _ => {}\n-}\n-```\n-\n-To match against NaN values, you should instead use the `is_nan()` method in a\n-guard, like so:\n-\n-```\n-let number = 0.1f32;\n-\n-match number {\n-    x if x.is_nan() => { /* ... */ }\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0004: r##\"\n-This error indicates that the compiler cannot guarantee a matching pattern for\n-one or more possible inputs to a match expression. Guaranteed matches are\n-required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution. Erroneous code example:\n-\n-```compile_fail,E0004\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n-    Terminator::TalkToMyHand => {}\n-}\n-```\n-\n-If you encounter this error you must alter your patterns so that every possible\n-value of the input type is matched. For types with a small number of variants\n-(like enums) you should probably cover all cases explicitly. Alternatively, the\n-underscore `_` wildcard pattern can be added after all other patterns to match\n-\"anything else\". Example:\n-\n-```\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    Terminator::HastaLaVistaBaby => {}\n-}\n-\n-// or:\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0005: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. Erroneous code example:\n-\n-```compile_fail,E0005\n-let x = Some(1);\n-let Some(y) = x;\n-// error: refutable pattern in local binding: `None` not covered\n-```\n-\n-If you encounter this error you probably need to use a `match` or `if let` to\n-deal with the possibility of failure. Example:\n-\n-```\n-let x = Some(1);\n-\n-match x {\n-    Some(y) => {\n-        // do something\n-    },\n-    None => {}\n-}\n-\n-// or:\n-\n-if let Some(y) = x {\n-    // do something\n-}\n-```\n-\"##,\n-\n-E0007: r##\"\n-This error indicates that the bindings in a match arm would require a value to\n-be moved into more than one location, thus violating unique ownership. Code\n-like the following is invalid as it requires the entire `Option<String>` to be\n-moved into a variable called `op_string` while simultaneously requiring the\n-inner `String` to be moved into a variable called `s`.\n-\n-```compile_fail,E0007\n-let x = Some(\"s\".to_string());\n-\n-match x {\n-    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n-    None => {},\n-}\n-```\n-\n-See also the error E0303.\n-\"##,\n-\n-E0008: r##\"\n-Names bound in match arms retain their type in pattern guards. As such, if a\n-name is bound by move in a pattern, it should also be moved to wherever it is\n-referenced in the pattern guard code. Doing so however would prevent the name\n-from being available in the body of the match arm. Consider the following:\n-\n-```compile_fail,E0008\n-match Some(\"hi\".to_string()) {\n-    Some(s) if s.len() == 0 => {}, // use s.\n-    _ => {},\n-}\n-```\n-\n-The variable `s` has type `String`, and its use in the guard is as a variable of\n-type `String`. The guard code effectively executes in a separate scope to the\n-body of the arm, so the value would be moved into this anonymous scope and\n-therefore becomes unavailable in the body of the arm.\n-\n-The problem above can be solved by using the `ref` keyword.\n-\n-```\n-match Some(\"hi\".to_string()) {\n-    Some(ref s) if s.len() == 0 => {},\n-    _ => {},\n-}\n-```\n-\n-Though this example seems innocuous and easy to solve, the problem becomes clear\n-when it encounters functions which consume the value:\n-\n-```compile_fail,E0008\n-struct A{}\n-\n-impl A {\n-    fn consume(self) -> usize {\n-        0\n-    }\n-}\n-\n-fn main() {\n-    let a = Some(A{});\n-    match a {\n-        Some(y) if y.consume() > 0 => {}\n-        _ => {}\n-    }\n-}\n-```\n-\n-In this situation, even the `ref` keyword cannot solve it, since borrowed\n-content cannot be moved. This problem cannot be solved generally. If the value\n-can be cloned, here is a not-so-specific solution:\n-\n-```\n-#[derive(Clone)]\n-struct A{}\n-\n-impl A {\n-    fn consume(self) -> usize {\n-        0\n-    }\n-}\n-\n-fn main() {\n-    let a = Some(A{});\n-    match a{\n-        Some(ref y) if y.clone().consume() > 0 => {}\n-        _ => {}\n-    }\n-}\n-```\n-\n-If the value will be consumed in the pattern guard, using its clone will not\n-move its ownership, so the code works.\n-\"##,\n-\n-E0009: r##\"\n-In a pattern, all values that don't implement the `Copy` trait have to be bound\n-the same way. The goal here is to avoid binding simultaneously by-move and\n-by-ref.\n-\n-This limitation may be removed in a future version of Rust.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0009\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n-                            //        same pattern\n-    None => panic!()\n-}\n-```\n-\n-You have two solutions:\n-\n-Solution #1: Bind the pattern's values the same way.\n-\n-```\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((ref y, ref z)) => {},\n-    // or Some((y, z)) => {}\n-    None => panic!()\n-}\n-```\n-\n-Solution #2: Implement the `Copy` trait for the `X` structure.\n-\n-However, please keep in mind that the first solution should be preferred.\n-\n-```\n-#[derive(Clone, Copy)]\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {},\n-    None => panic!()\n-}\n-```\n-\"##,\n-\n-E0158: r##\"\n-`const` and `static` mean different things. A `const` is a compile-time\n-constant, an alias for a literal value. This property means you can match it\n-directly within a pattern.\n-\n-The `static` keyword, on the other hand, guarantees a fixed location in memory.\n-This does not always mean that the value is constant. For example, a global\n-mutex can be declared `static` as well.\n-\n-If you want to match against a `static`, consider using a guard instead:\n-\n-```\n-static FORTY_TWO: i32 = 42;\n-\n-match Some(42) {\n-    Some(x) if x == FORTY_TWO => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0162: r##\"\n-An if-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding instead. For instance:\n-\n-```compile_fail,E0162\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-if let Irrefutable(x) = irr {\n-    // This body will always be executed.\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-let Irrefutable(x) = irr;\n-println!(\"{}\", x);\n-```\n-\"##,\n-\n-E0165: r##\"\n-A while-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding inside a `loop` instead. For instance:\n-\n-```compile_fail,E0165\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-while let Irrefutable(x) = irr {\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```no_run\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-loop {\n-    let Irrefutable(x) = irr;\n-    // ...\n-}\n-```\n-\"##,\n-\n-E0170: r##\"\n-Enum variants are qualified by default. For example, given this type:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-```\n-\n-You would match it using:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-\n-let m = Method::GET;\n-\n-match m {\n-    Method::GET => {},\n-    Method::POST => {},\n-}\n-```\n-\n-If you don't qualify the names, the code will bind new variables named \"GET\" and\n-\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n-that happens.\n-\n-Qualified names are good practice, and most code works well with them. But if\n-you prefer them unqualified, you can import the variants into scope:\n-\n-```\n-use Method::*;\n-enum Method { GET, POST }\n-# fn main() {}\n-```\n-\n-If you want others to be able to import variants from your module directly, use\n-`pub use`:\n-\n-```\n-pub use Method::*;\n-pub enum Method { GET, POST }\n-# fn main() {}\n-```\n-\"##,\n-\n-\n-E0297: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Patterns used to bind names must be irrefutable. That is, they must guarantee\n-that a name will be extracted in all cases. Instead of pattern matching the\n-loop variable, consider using a `match` or `if let` inside the loop body. For\n-instance:\n-\n-```compile_fail,E0005\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-// This fails because `None` is not covered.\n-for Some(x) in xs {\n-    // ...\n-}\n-```\n-\n-Match inside the loop instead:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    match item {\n-        Some(x) => {},\n-        None => {},\n-    }\n-}\n-```\n-\n-Or use `if let`:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    if let Some(x) = item {\n-        // ...\n-    }\n-}\n-```\n-\"##,\n-\n-E0301: r##\"\n-Mutable borrows are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if mutable\n-borrows were allowed:\n-\n-```compile_fail,E0301\n-match Some(()) {\n-    None => { },\n-    option if option.take().is_none() => {\n-        /* impossible, option is `Some` */\n-    },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0302: r##\"\n-Assignments are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if assignments\n-were allowed:\n-\n-```compile_fail,E0302\n-match Some(()) {\n-    None => { },\n-    option if { option = None; false } => { },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0303: r##\"\n-In certain cases it is possible for sub-bindings to violate memory safety.\n-Updates to the borrow checker in a future version of Rust may remove this\n-restriction, but for now patterns must be rewritten without sub-bindings.\n-\n-Before:\n-\n-```compile_fail,E0303\n-match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(s) => {},\n-    None => {},\n-}\n-```\n-\n-After:\n-\n-```\n-match Some(\"hi\".to_string()) {\n-    Some(ref s) => {\n-        let op_string_ref = &Some(s);\n-        // ...\n-    },\n-    None => {},\n-}\n-```\n-\n-The `op_string_ref` binding has type `&Option<&String>` in both cases.\n-\n-See also https://github.com/rust-lang/rust/issues/14587\n-\"##,\n-\n-}\n-\n-\n-register_diagnostics! {\n-//  E0298, // cannot compare constants\n-//  E0299, // mismatched types between arms\n-//  E0471, // constant evaluation error (in pattern)\n-}"}, {"sha": "2a571fa82643b2d97777158abcead4396f283349", "filename": "src/librustc_const_eval/eval.rs", "status": "removed", "additions": 0, "deletions": 687, "changes": 687, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,687 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::middle::const_val::ConstVal::*;\n-use rustc::middle::const_val::ConstAggregate::*;\n-use rustc::middle::const_val::ErrKind::*;\n-use rustc::middle::const_val::{ByteArray, ConstVal, ConstEvalErr, EvalResult, ErrKind};\n-\n-use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::util::IntTypeExt;\n-use rustc::ty::subst::{Substs, Subst};\n-use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeMap;\n-\n-use syntax::abi::Abi;\n-use syntax::ast;\n-use syntax::attr;\n-use rustc::hir::{self, Expr};\n-use syntax_pos::Span;\n-\n-use std::cmp::Ordering;\n-\n-use rustc_const_math::*;\n-macro_rules! signal {\n-    ($e:expr, $exn:expr) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n-    }\n-}\n-\n-macro_rules! math {\n-    ($e:expr, $op:expr) => {\n-        match $op {\n-            Ok(val) => val,\n-            Err(e) => signal!($e, ErrKind::from(e)),\n-        }\n-    }\n-}\n-\n-/// * `DefId` is the id of the constant.\n-/// * `Substs` is the monomorphized substitutions for the expression.\n-pub fn lookup_const_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n-                                    -> Option<(DefId, &'tcx Substs<'tcx>)> {\n-    ty::Instance::resolve(\n-        tcx,\n-        key.param_env,\n-        key.value.0,\n-        key.value.1,\n-    ).map(|instance| (instance.def_id(), instance.substs))\n-}\n-\n-pub struct ConstContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    substs: &'tcx Substs<'tcx>,\n-    fn_args: Option<NodeMap<&'tcx ty::Const<'tcx>>>\n-}\n-\n-impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n-               tables: &'a ty::TypeckTables<'tcx>)\n-               -> Self {\n-        ConstContext {\n-            tcx,\n-            param_env: param_env_and_substs.param_env,\n-            tables,\n-            substs: param_env_and_substs.value,\n-            fn_args: None\n-        }\n-    }\n-\n-    /// Evaluate a constant expression in a context where the expression isn't\n-    /// guaranteed to be evaluable.\n-    pub fn eval(&self, e: &'tcx Expr) -> EvalResult<'tcx> {\n-        if self.tables.tainted_by_errors {\n-            signal!(e, TypeckError);\n-        }\n-        eval_const_expr_partial(self, e)\n-    }\n-}\n-\n-type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n-\n-fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n-                                     e: &'tcx Expr) -> EvalResult<'tcx> {\n-    trace!(\"eval_const_expr_partial: {:?}\", e);\n-    let tcx = cx.tcx;\n-    let ty = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n-    let mk_const = |val| tcx.mk_const(ty::Const { val, ty });\n-\n-    let result = match e.node {\n-      hir::ExprUnary(hir::UnNeg, ref inner) => {\n-        // unary neg literals already got their sign during creation\n-        if let hir::ExprLit(ref lit) = inner.node {\n-            use syntax::ast::*;\n-            use syntax::ast::LitIntType::*;\n-            const I8_OVERFLOW: u128 = i8::min_value() as u8 as u128;\n-            const I16_OVERFLOW: u128 = i16::min_value() as u16 as u128;\n-            const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n-            const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n-            const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            let negated = match (&lit.node, &ty.sty) {\n-                (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n-                (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    Some(I8(i8::min_value()))\n-                },\n-                (&LitKind::Int(I16_OVERFLOW, _), &ty::TyInt(IntTy::I16)) |\n-                (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    Some(I16(i16::min_value()))\n-                },\n-                (&LitKind::Int(I32_OVERFLOW, _), &ty::TyInt(IntTy::I32)) |\n-                (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    Some(I32(i32::min_value()))\n-                },\n-                (&LitKind::Int(I64_OVERFLOW, _), &ty::TyInt(IntTy::I64)) |\n-                (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    Some(I64(i64::min_value()))\n-                },\n-                (&LitKind::Int(I128_OVERFLOW, _), &ty::TyInt(IntTy::I128)) |\n-                (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n-                    Some(I128(i128::min_value()))\n-                },\n-                (&LitKind::Int(n, _), &ty::TyInt(IntTy::Isize)) |\n-                (&LitKind::Int(n, Signed(IntTy::Isize)), _) => {\n-                    match tcx.sess.target.isize_ty {\n-                        IntTy::I16 => if n == I16_OVERFLOW {\n-                            Some(Isize(Is16(i16::min_value())))\n-                        } else {\n-                            None\n-                        },\n-                        IntTy::I32 => if n == I32_OVERFLOW {\n-                            Some(Isize(Is32(i32::min_value())))\n-                        } else {\n-                            None\n-                        },\n-                        IntTy::I64 => if n == I64_OVERFLOW {\n-                            Some(Isize(Is64(i64::min_value())))\n-                        } else {\n-                            None\n-                        },\n-                        _ => span_bug!(e.span, \"typeck error\")\n-                    }\n-                },\n-                _ => None\n-            };\n-            if let Some(i) = negated {\n-                return Ok(mk_const(Integral(i)));\n-            }\n-        }\n-        mk_const(match cx.eval(inner)?.val {\n-          Float(f) => Float(-f),\n-          Integral(i) => Integral(math!(e, -i)),\n-          _ => signal!(e, TypeckError)\n-        })\n-      }\n-      hir::ExprUnary(hir::UnNot, ref inner) => {\n-        mk_const(match cx.eval(inner)?.val {\n-          Integral(i) => Integral(math!(e, !i)),\n-          Bool(b) => Bool(!b),\n-          _ => signal!(e, TypeckError)\n-        })\n-      }\n-      hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n-      hir::ExprBinary(op, ref a, ref b) => {\n-        // technically, if we don't have type hints, but integral eval\n-        // gives us a type through a type-suffix, cast or const def type\n-        // we need to re-eval the other value of the BinOp if it was\n-        // not inferred\n-        mk_const(match (cx.eval(a)?.val, cx.eval(b)?.val) {\n-          (Float(a), Float(b)) => {\n-            use std::cmp::Ordering::*;\n-            match op.node {\n-              hir::BiAdd => Float(math!(e, a + b)),\n-              hir::BiSub => Float(math!(e, a - b)),\n-              hir::BiMul => Float(math!(e, a * b)),\n-              hir::BiDiv => Float(math!(e, a / b)),\n-              hir::BiRem => Float(math!(e, a % b)),\n-              hir::BiEq => Bool(math!(e, a.try_cmp(b)) == Equal),\n-              hir::BiLt => Bool(math!(e, a.try_cmp(b)) == Less),\n-              hir::BiLe => Bool(math!(e, a.try_cmp(b)) != Greater),\n-              hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n-              hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n-              hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => span_bug!(e.span, \"typeck error\"),\n-            }\n-          }\n-          (Integral(a), Integral(b)) => {\n-            use std::cmp::Ordering::*;\n-            match op.node {\n-              hir::BiAdd => Integral(math!(e, a + b)),\n-              hir::BiSub => Integral(math!(e, a - b)),\n-              hir::BiMul => Integral(math!(e, a * b)),\n-              hir::BiDiv => Integral(math!(e, a / b)),\n-              hir::BiRem => Integral(math!(e, a % b)),\n-              hir::BiBitAnd => Integral(math!(e, a & b)),\n-              hir::BiBitOr => Integral(math!(e, a | b)),\n-              hir::BiBitXor => Integral(math!(e, a ^ b)),\n-              hir::BiShl => Integral(math!(e, a << b)),\n-              hir::BiShr => Integral(math!(e, a >> b)),\n-              hir::BiEq => Bool(math!(e, a.try_cmp(b)) == Equal),\n-              hir::BiLt => Bool(math!(e, a.try_cmp(b)) == Less),\n-              hir::BiLe => Bool(math!(e, a.try_cmp(b)) != Greater),\n-              hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n-              hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n-              hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => span_bug!(e.span, \"typeck error\"),\n-            }\n-          }\n-          (Bool(a), Bool(b)) => {\n-            Bool(match op.node {\n-              hir::BiAnd => a && b,\n-              hir::BiOr => a || b,\n-              hir::BiBitXor => a ^ b,\n-              hir::BiBitAnd => a & b,\n-              hir::BiBitOr => a | b,\n-              hir::BiEq => a == b,\n-              hir::BiNe => a != b,\n-              hir::BiLt => a < b,\n-              hir::BiLe => a <= b,\n-              hir::BiGe => a >= b,\n-              hir::BiGt => a > b,\n-              _ => span_bug!(e.span, \"typeck error\"),\n-             })\n-          }\n-          (Char(a), Char(b)) => {\n-            Bool(match op.node {\n-              hir::BiEq => a == b,\n-              hir::BiNe => a != b,\n-              hir::BiLt => a < b,\n-              hir::BiLe => a <= b,\n-              hir::BiGe => a >= b,\n-              hir::BiGt => a > b,\n-              _ => span_bug!(e.span, \"typeck error\"),\n-             })\n-          }\n-\n-          _ => signal!(e, MiscBinaryOp),\n-        })\n-      }\n-      hir::ExprCast(ref base, _) => {\n-        let base_val = cx.eval(base)?;\n-        let base_ty = cx.tables.expr_ty(base).subst(tcx, cx.substs);\n-        if ty == base_ty {\n-            base_val\n-        } else {\n-            match cast_const(tcx, base_val.val, ty) {\n-                Ok(val) => mk_const(val),\n-                Err(kind) => signal!(e, kind),\n-            }\n-        }\n-      }\n-      hir::ExprPath(ref qpath) => {\n-        let substs = cx.tables.node_substs(e.hir_id).subst(tcx, cx.substs);\n-          match cx.tables.qpath_def(qpath, e.hir_id) {\n-              Def::Const(def_id) |\n-              Def::AssociatedConst(def_id) => {\n-                    let substs = tcx.normalize_associated_type_in_env(&substs, cx.param_env);\n-                    match tcx.at(e.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                        Ok(val) => val,\n-                        Err(ConstEvalErr { kind: TypeckError, .. }) => {\n-                            signal!(e, TypeckError);\n-                        }\n-                        Err(err) => {\n-                            debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n-                            signal!(e, ErroneousReferencedConstant(box err))\n-                        },\n-                    }\n-              },\n-              Def::VariantCtor(variant_def, CtorKind::Const) => {\n-                mk_const(Variant(variant_def))\n-              }\n-              Def::VariantCtor(_, CtorKind::Fn) => {\n-                  signal!(e, UnimplementedConstVal(\"enum variants\"));\n-              }\n-              Def::StructCtor(_, CtorKind::Const) => {\n-                  mk_const(Aggregate(Struct(&[])))\n-              }\n-              Def::StructCtor(_, CtorKind::Fn) => {\n-                  signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n-              }\n-              Def::Local(id) => {\n-                  debug!(\"Def::Local({:?}): {:?}\", id, cx.fn_args);\n-                  if let Some(&val) = cx.fn_args.as_ref().and_then(|args| args.get(&id)) {\n-                      val\n-                  } else {\n-                      signal!(e, NonConstPath);\n-                  }\n-              },\n-              Def::Method(id) | Def::Fn(id) => mk_const(Function(id, substs)),\n-              Def::Err => span_bug!(e.span, \"typeck error\"),\n-              _ => signal!(e, NonConstPath),\n-          }\n-      }\n-      hir::ExprCall(ref callee, ref args) => {\n-          let (def_id, substs) = match cx.eval(callee)?.val {\n-              Function(def_id, substs) => (def_id, substs),\n-              _ => signal!(e, TypeckError),\n-          };\n-\n-          if tcx.fn_sig(def_id).abi() == Abi::RustIntrinsic {\n-            let layout_of = |ty: Ty<'tcx>| {\n-                let ty = tcx.erase_regions(&ty);\n-                tcx.at(e.span).layout_of(cx.param_env.and(ty)).map_err(|err| {\n-                    ConstEvalErr { span: e.span, kind: LayoutError(err) }\n-                })\n-            };\n-            match &tcx.item_name(def_id)[..] {\n-                \"size_of\" => {\n-                    let size = layout_of(substs.type_at(0))?.size.bytes();\n-                    return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n-                        tcx.sess.target.usize_ty).unwrap()))));\n-                }\n-                \"min_align_of\" => {\n-                    let align = layout_of(substs.type_at(0))?.align.abi();\n-                    return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n-                        tcx.sess.target.usize_ty).unwrap()))));\n-                }\n-                \"type_id\" => {\n-                    let type_id = tcx.type_id_hash(substs.type_at(0));\n-                    return Ok(mk_const(Integral(U64(type_id))));\n-                }\n-                _ => signal!(e, TypeckError)\n-            }\n-          }\n-\n-          let body = if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-            if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n-                if fn_like.constness() == hir::Constness::Const {\n-                    tcx.hir.body(fn_like.body())\n-                } else {\n-                    signal!(e, TypeckError)\n-                }\n-            } else {\n-                signal!(e, TypeckError)\n-            }\n-          } else {\n-            if tcx.is_const_fn(def_id) {\n-                tcx.extern_const_body(def_id).body\n-            } else {\n-                signal!(e, TypeckError)\n-            }\n-          };\n-\n-          let arg_ids = body.arguments.iter().map(|arg| match arg.pat.node {\n-               hir::PatKind::Binding(_, canonical_id, _, _) => Some(canonical_id),\n-               _ => None\n-           }).collect::<Vec<_>>();\n-          assert_eq!(arg_ids.len(), args.len());\n-\n-          let mut call_args = NodeMap();\n-          for (arg, arg_expr) in arg_ids.into_iter().zip(args.iter()) {\n-              let arg_val = cx.eval(arg_expr)?;\n-              debug!(\"const call arg: {:?}\", arg);\n-              if let Some(id) = arg {\n-                assert!(call_args.insert(id, arg_val).is_none());\n-              }\n-          }\n-          debug!(\"const call({:?})\", call_args);\n-          let callee_cx = ConstContext {\n-            tcx,\n-            param_env: cx.param_env,\n-            tables: tcx.typeck_tables_of(def_id),\n-            substs,\n-            fn_args: Some(call_args)\n-          };\n-          callee_cx.eval(&body.value)?\n-      },\n-      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ty) {\n-          Ok(val) => mk_const(val),\n-          Err(err) => signal!(e, err),\n-      },\n-      hir::ExprBlock(ref block) => {\n-        match block.expr {\n-            Some(ref expr) => cx.eval(expr)?,\n-            None => mk_const(Aggregate(Tuple(&[]))),\n-        }\n-      }\n-      hir::ExprType(ref e, _) => cx.eval(e)?,\n-      hir::ExprTup(ref fields) => {\n-        let values = fields.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n-        mk_const(Aggregate(Tuple(tcx.alloc_const_slice(&values))))\n-      }\n-      hir::ExprStruct(_, ref fields, _) => {\n-        mk_const(Aggregate(Struct(tcx.alloc_name_const_slice(&fields.iter().map(|f| {\n-            cx.eval(&f.expr).map(|v| (f.name.node, v))\n-        }).collect::<Result<Vec<_>, _>>()?))))\n-      }\n-      hir::ExprIndex(ref arr, ref idx) => {\n-        if !tcx.features().const_indexing {\n-            signal!(e, IndexOpFeatureGated);\n-        }\n-        let arr = cx.eval(arr)?;\n-        let idx = match cx.eval(idx)?.val {\n-            Integral(Usize(i)) => i.as_u64(),\n-            _ => signal!(idx, IndexNotUsize),\n-        };\n-        assert_eq!(idx as usize as u64, idx);\n-        match arr.val {\n-            Aggregate(Array(v)) => {\n-                if let Some(&elem) = v.get(idx as usize) {\n-                    elem\n-                } else {\n-                    let n = v.len() as u64;\n-                    signal!(e, IndexOutOfBounds { len: n, index: idx })\n-                }\n-            }\n-\n-            Aggregate(Repeat(.., n)) if idx >= n => {\n-                signal!(e, IndexOutOfBounds { len: n, index: idx })\n-            }\n-            Aggregate(Repeat(elem, _)) => elem,\n-\n-            ByteStr(b) if idx >= b.data.len() as u64 => {\n-                signal!(e, IndexOutOfBounds { len: b.data.len() as u64, index: idx })\n-            }\n-            ByteStr(b) => {\n-                mk_const(Integral(U8(b.data[idx as usize])))\n-            },\n-\n-            _ => signal!(e, IndexedNonVec),\n-        }\n-      }\n-      hir::ExprArray(ref v) => {\n-        let values = v.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n-        mk_const(Aggregate(Array(tcx.alloc_const_slice(&values))))\n-      }\n-      hir::ExprRepeat(ref elem, _) => {\n-          let n = match ty.sty {\n-            ty::TyArray(_, n) => n.val.to_const_int().unwrap().to_u64().unwrap(),\n-            _ => span_bug!(e.span, \"typeck error\")\n-          };\n-          mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n-      },\n-      hir::ExprTupField(ref base, index) => {\n-        if let Aggregate(Tuple(fields)) = cx.eval(base)?.val {\n-            fields[index.node]\n-        } else {\n-            signal!(base, ExpectedConstTuple);\n-        }\n-      }\n-      hir::ExprField(ref base, field_name) => {\n-        if let Aggregate(Struct(fields)) = cx.eval(base)?.val {\n-            if let Some(&(_, f)) = fields.iter().find(|&&(name, _)| name == field_name.node) {\n-                f\n-            } else {\n-                signal!(e, MissingStructField);\n-            }\n-        } else {\n-            signal!(base, ExpectedConstStruct);\n-        }\n-      }\n-      hir::ExprAddrOf(..) => signal!(e, UnimplementedConstVal(\"address operator\")),\n-      _ => signal!(e, MiscCatchAll)\n-    };\n-\n-    Ok(result)\n-}\n-\n-fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            val: ConstInt,\n-                            ty: Ty<'tcx>)\n-                            -> CastResult<'tcx> {\n-    let v = val.to_u128_unchecked();\n-    match ty.sty {\n-        ty::TyBool if v == 0 => Ok(Bool(false)),\n-        ty::TyBool if v == 1 => Ok(Bool(true)),\n-        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i128 as i8))),\n-        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i128 as i16))),\n-        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i128 as i32))),\n-        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n-        ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n-        ty::TyInt(ast::IntTy::Isize) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.isize_ty))))\n-        },\n-        ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n-        ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n-        ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n-        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n-        ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n-        ty::TyUint(ast::UintTy::Usize) => {\n-            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.usize_ty))))\n-        },\n-        ty::TyFloat(fty) => {\n-            if let Some(i) = val.to_u128() {\n-                Ok(Float(ConstFloat::from_u128(i, fty)))\n-            } else {\n-                // The value must be negative, go through signed integers.\n-                let i = val.to_u128_unchecked() as i128;\n-                Ok(Float(ConstFloat::from_i128(i, fty)))\n-            }\n-        }\n-        ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n-        ty::TyChar => match val {\n-            U8(u) => Ok(Char(u as char)),\n-            _ => bug!(),\n-        },\n-        _ => Err(CannotCast),\n-    }\n-}\n-\n-fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              val: ConstFloat,\n-                              ty: Ty<'tcx>) -> CastResult<'tcx> {\n-    let int_width = |ty| {\n-        ty::layout::Integer::from_attr(tcx, ty).size().bits() as usize\n-    };\n-    match ty.sty {\n-        ty::TyInt(ity) => {\n-            if let Some(i) = val.to_i128(int_width(attr::SignedInt(ity))) {\n-                cast_const_int(tcx, I128(i), ty)\n-            } else {\n-                Err(CannotCast)\n-            }\n-        }\n-        ty::TyUint(uty) => {\n-            if let Some(i) = val.to_u128(int_width(attr::UnsignedInt(uty))) {\n-                cast_const_int(tcx, U128(i), ty)\n-            } else {\n-                Err(CannotCast)\n-            }\n-        }\n-        ty::TyFloat(fty) => Ok(Float(val.convert(fty))),\n-        _ => Err(CannotCast),\n-    }\n-}\n-\n-fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        val: ConstVal<'tcx>,\n-                        ty: Ty<'tcx>)\n-                        -> CastResult<'tcx> {\n-    match val {\n-        Integral(i) => cast_const_int(tcx, i, ty),\n-        Bool(b) => cast_const_int(tcx, U8(b as u8), ty),\n-        Float(f) => cast_const_float(tcx, f, ty),\n-        Char(c) => cast_const_int(tcx, U32(c as u32), ty),\n-        Variant(v) => {\n-            let adt = tcx.adt_def(tcx.parent_def_id(v).unwrap());\n-            let idx = adt.variant_index_with_id(v);\n-            cast_const_int(tcx, adt.discriminant_for_variant(tcx, idx), ty)\n-        }\n-        Function(..) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n-        ByteStr(b) => match ty.sty {\n-            ty::TyRawPtr(_) => {\n-                Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n-            },\n-            ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyArray(ty, n) => {\n-                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-                    if ty == tcx.types.u8 && n == b.data.len() as u64 {\n-                        Ok(val)\n-                    } else {\n-                        Err(CannotCast)\n-                    }\n-                }\n-                ty::TySlice(_) => {\n-                    Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\"))\n-                },\n-                _ => Err(CannotCast),\n-            },\n-            _ => Err(CannotCast),\n-        },\n-        Str(s) => match ty.sty {\n-            ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting a str to a raw ptr\")),\n-            ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyStr => Ok(Str(s)),\n-                _ => Err(CannotCast),\n-            },\n-            _ => Err(CannotCast),\n-        },\n-        _ => Err(CannotCast),\n-    }\n-}\n-\n-fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          mut ty: Ty<'tcx>)\n-                          -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n-    use syntax::ast::*;\n-    use syntax::ast::LitIntType::*;\n-\n-    if let ty::TyAdt(adt, _) = ty.sty {\n-        if adt.is_enum() {\n-            ty = adt.repr.discr_type().to_ty(tcx)\n-        }\n-    }\n-\n-    match *lit {\n-        LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n-        LitKind::ByteStr(ref data) => Ok(ByteStr(ByteArray { data })),\n-        LitKind::Byte(n) => Ok(Integral(U8(n))),\n-        LitKind::Int(n, hint) => {\n-            match (&ty.sty, hint) {\n-                (&ty::TyInt(ity), _) |\n-                (_, Signed(ity)) => {\n-                    Ok(Integral(ConstInt::new_signed_truncating(n as i128,\n-                        ity, tcx.sess.target.isize_ty)))\n-                }\n-                (&ty::TyUint(uty), _) |\n-                (_, Unsigned(uty)) => {\n-                    Ok(Integral(ConstInt::new_unsigned_truncating(n as u128,\n-                        uty, tcx.sess.target.usize_ty)))\n-                }\n-                _ => bug!()\n-            }\n-        }\n-        LitKind::Float(n, fty) => {\n-            parse_float(&n.as_str(), fty).map(Float)\n-        }\n-        LitKind::FloatUnsuffixed(n) => {\n-            let fty = match ty.sty {\n-                ty::TyFloat(fty) => fty,\n-                _ => bug!()\n-            };\n-            parse_float(&n.as_str(), fty).map(Float)\n-        }\n-        LitKind::Bool(b) => Ok(Bool(b)),\n-        LitKind::Char(c) => Ok(Char(c)),\n-    }\n-}\n-\n-fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n-                     -> Result<ConstFloat, ErrKind<'tcx>> {\n-    ConstFloat::from_str(num, fty).map_err(|_| {\n-        // FIXME(#31407) this is only necessary because float parsing is buggy\n-        UnimplementedConstVal(\"could not evaluate float literal (see issue #31407)\")\n-    })\n-}\n-\n-pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n-                          -> Result<Ordering, ErrorReported>\n-{\n-    let result = match (a, b) {\n-        (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n-        (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n-        (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n-        (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n-        (&ByteStr(a), &ByteStr(b)) => Some(a.data.cmp(b.data)),\n-        (&Char(a), &Char(b)) => Some(a.cmp(&b)),\n-        _ => None,\n-    };\n-\n-    match result {\n-        Some(result) => Ok(result),\n-        None => {\n-            // FIXME: can this ever be reached?\n-            tcx.sess.delay_span_bug(span,\n-                &format!(\"type mismatch comparing {:?} and {:?}\", a, b));\n-            Err(ErrorReported)\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n-    pub fn compare_lit_exprs(&self,\n-                             span: Span,\n-                             a: &'tcx Expr,\n-                             b: &'tcx Expr) -> Result<Ordering, ErrorReported> {\n-        let tcx = self.tcx;\n-        let a = match self.eval(a) {\n-            Ok(a) => a,\n-            Err(e) => {\n-                e.report(tcx, a.span, \"expression\");\n-                return Err(ErrorReported);\n-            }\n-        };\n-        let b = match self.eval(b) {\n-            Ok(b) => b,\n-            Err(e) => {\n-                e.report(tcx, b.span, \"expression\");\n-                return Err(ErrorReported);\n-            }\n-        };\n-        compare_const_vals(tcx, span, &a.val, &b.val)\n-    }\n-}"}, {"sha": "4ec27d7ade560ce620f5560d429a134cff929e52", "filename": "src/librustc_const_math/int.rs", "status": "removed", "additions": 0, "deletions": 590, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,590 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cmp::Ordering;\n-use syntax::attr::IntType;\n-use syntax::ast::{IntTy, UintTy};\n-\n-use super::isize::*;\n-use super::usize::*;\n-use super::err::*;\n-\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n-pub enum ConstInt {\n-    I8(i8),\n-    I16(i16),\n-    I32(i32),\n-    I64(i64),\n-    I128(i128),\n-    Isize(ConstIsize),\n-    U8(u8),\n-    U16(u16),\n-    U32(u32),\n-    U64(u64),\n-    U128(u128),\n-    Usize(ConstUsize),\n-}\n-pub use self::ConstInt::*;\n-\n-\n-macro_rules! bounds {\n-    ($ct: ty, $($t:ident $min:ident $max:ident)*) => {\n-        $(\n-            pub const $min: $ct = $t::min_value() as $ct;\n-            pub const $max: $ct = $t::max_value() as $ct;\n-        )*\n-    };\n-    ($ct: ty: $min_val: expr, $($t:ident $min:ident $max:ident)*) => {\n-        $(\n-            pub const $min: $ct = $min_val;\n-            pub const $max: $ct = $t::max_value() as $ct;\n-        )*\n-    }\n-}\n-\n-mod ubounds {\n-    #![allow(dead_code)]\n-    bounds!{u128: 0,\n-        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n-        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX u128 U128MIN U128MAX\n-        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n-        // arbitrary host/target combinations\n-    }\n-}\n-\n-mod ibounds {\n-    #![allow(dead_code)]\n-    bounds!(i128, u64 U64MIN U64MAX);\n-\n-    pub const U128MIN: i128 = 0;\n-    pub const U128MAX: i128 = i128::max_value();\n-\n-    bounds!{i128,\n-        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n-        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX\n-        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n-        // arbitrary host/target combinations\n-    }\n-}\n-\n-impl ConstInt {\n-    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n-    /// not happen.\n-    pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {\n-        match ty {\n-            UintTy::U8 if val <= ubounds::U8MAX => Some(U8(val as u8)),\n-            UintTy::U16 if val <= ubounds::U16MAX => Some(U16(val as u16)),\n-            UintTy::U32 if val <= ubounds::U32MAX => Some(U32(val as u32)),\n-            UintTy::U64 if val <= ubounds::U64MAX => Some(U64(val as u64)),\n-            UintTy::Usize if val <= ubounds::U64MAX => ConstUsize::new(val as u64, usize_ty).ok()\n-                .map(Usize),\n-            UintTy::U128 => Some(U128(val)),\n-            _ => None\n-        }\n-    }\n-\n-    /// Creates a new signed ConstInt with matching type while also checking that overflow does\n-    /// not happen.\n-    pub fn new_signed(val: i128, ty: IntTy, isize_ty: IntTy) -> Option<ConstInt> {\n-        match ty {\n-            IntTy::I8 if val <= ibounds::I8MAX => Some(I8(val as i8)),\n-            IntTy::I16 if val <= ibounds::I16MAX => Some(I16(val as i16)),\n-            IntTy::I32 if val <= ibounds::I32MAX => Some(I32(val as i32)),\n-            IntTy::I64 if val <= ibounds::I64MAX => Some(I64(val as i64)),\n-            IntTy::Isize if val <= ibounds::I64MAX => ConstIsize::new(val as i64, isize_ty).ok()\n-                .map(Isize),\n-            IntTy::I128 => Some(I128(val)),\n-            _ => None\n-        }\n-    }\n-\n-    /// Creates a new unsigned ConstInt with matching type.\n-    pub fn new_unsigned_truncating(val: u128, ty: UintTy, usize_ty: UintTy) -> ConstInt {\n-        match ty {\n-            UintTy::U8 => U8(val as u8),\n-            UintTy::U16 => U16(val as u16),\n-            UintTy::U32 => U32(val as u32),\n-            UintTy::U64 => U64(val as u64),\n-            UintTy::Usize => Usize(ConstUsize::new_truncating(val, usize_ty)),\n-            UintTy::U128 => U128(val)\n-        }\n-    }\n-\n-    /// Creates a new signed ConstInt with matching type.\n-    pub fn new_signed_truncating(val: i128, ty: IntTy, isize_ty: IntTy) -> ConstInt {\n-        match ty {\n-            IntTy::I8 => I8(val as i8),\n-            IntTy::I16 => I16(val as i16),\n-            IntTy::I32 => I32(val as i32),\n-            IntTy::I64 => I64(val as i64),\n-            IntTy::Isize => Isize(ConstIsize::new_truncating(val, isize_ty)),\n-            IntTy::I128 => I128(val)\n-        }\n-    }\n-\n-    /// Description of the type, not the value\n-    pub fn description(&self) -> &'static str {\n-        match *self {\n-            I8(_) => \"i8\",\n-            I16(_) => \"i16\",\n-            I32(_) => \"i32\",\n-            I64(_) => \"i64\",\n-            I128(_) => \"i128\",\n-            Isize(_) => \"isize\",\n-            U8(_) => \"u8\",\n-            U16(_) => \"u16\",\n-            U32(_) => \"u32\",\n-            U64(_) => \"u64\",\n-            U128(_) => \"u128\",\n-            Usize(_) => \"usize\",\n-        }\n-    }\n-\n-    /// Erases the type and returns a u128.\n-    /// This is not the same as `-5i8 as u128` but as `-5i8 as i128 as u128`\n-    pub fn to_u128_unchecked(self) -> u128 {\n-        match self {\n-            I8(i) => i as i128 as u128,\n-            I16(i) => i as i128 as u128,\n-            I32(i) => i as i128 as u128,\n-            I64(i) => i as i128 as u128,\n-            I128(i) => i as i128 as u128,\n-            Isize(Is16(i)) => i as i128 as u128,\n-            Isize(Is32(i)) => i as i128 as u128,\n-            Isize(Is64(i)) => i as i128 as u128,\n-            U8(i) => i as u128,\n-            U16(i) => i as u128,\n-            U32(i) => i as u128,\n-            U64(i) => i as u128,\n-            U128(i) => i as u128,\n-            Usize(Us16(i)) => i as u128,\n-            Usize(Us32(i)) => i as u128,\n-            Usize(Us64(i)) => i as u128,\n-        }\n-    }\n-\n-    /// Converts the value to a `u32` if it's in the range 0...std::u32::MAX\n-    pub fn to_u32(&self) -> Option<u32> {\n-        self.to_u128().and_then(|v| if v <= u32::max_value() as u128 {\n-            Some(v as u32)\n-        } else {\n-            None\n-        })\n-    }\n-\n-    /// Converts the value to a `u64` if it's in the range 0...std::u64::MAX\n-    pub fn to_u64(&self) -> Option<u64> {\n-        self.to_u128().and_then(|v| if v <= u64::max_value() as u128 {\n-            Some(v as u64)\n-        } else {\n-            None\n-        })\n-    }\n-\n-    /// Converts the value to a `u128` if it's in the range 0...std::u128::MAX\n-    pub fn to_u128(&self) -> Option<u128> {\n-        match *self {\n-            I8(v) if v >= 0 => Some(v as u128),\n-            I16(v) if v >= 0 => Some(v as u128),\n-            I32(v) if v >= 0 => Some(v as u128),\n-            I64(v) if v >= 0 => Some(v as u128),\n-            I128(v) if v >= 0 => Some(v as u128),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u128),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u128),\n-            Isize(Is64(v)) if v >= 0 => Some(v as u128),\n-            U8(v) => Some(v as u128),\n-            U16(v) => Some(v as u128),\n-            U32(v) => Some(v as u128),\n-            U64(v) => Some(v as u128),\n-            U128(v) => Some(v as u128),\n-            Usize(Us16(v)) => Some(v as u128),\n-            Usize(Us32(v)) => Some(v as u128),\n-            Usize(Us64(v)) => Some(v as u128),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_negative(&self) -> bool {\n-        match *self {\n-            I8(v) => v < 0,\n-            I16(v) => v < 0,\n-            I32(v) => v < 0,\n-            I64(v) => v < 0,\n-            I128(v) => v < 0,\n-            Isize(Is16(v)) => v < 0,\n-            Isize(Is32(v)) => v < 0,\n-            Isize(Is64(v)) => v < 0,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Compares the values if they are of the same type\n-    pub fn try_cmp(self, rhs: Self) -> Result<::std::cmp::Ordering, ConstMathErr> {\n-        match (self, rhs) {\n-            (I8(a), I8(b)) => Ok(a.cmp(&b)),\n-            (I16(a), I16(b)) => Ok(a.cmp(&b)),\n-            (I32(a), I32(b)) => Ok(a.cmp(&b)),\n-            (I64(a), I64(b)) => Ok(a.cmp(&b)),\n-            (I128(a), I128(b)) => Ok(a.cmp(&b)),\n-            (Isize(Is16(a)), Isize(Is16(b))) => Ok(a.cmp(&b)),\n-            (Isize(Is32(a)), Isize(Is32(b))) => Ok(a.cmp(&b)),\n-            (Isize(Is64(a)), Isize(Is64(b))) => Ok(a.cmp(&b)),\n-            (U8(a), U8(b)) => Ok(a.cmp(&b)),\n-            (U16(a), U16(b)) => Ok(a.cmp(&b)),\n-            (U32(a), U32(b)) => Ok(a.cmp(&b)),\n-            (U64(a), U64(b)) => Ok(a.cmp(&b)),\n-            (U128(a), U128(b)) => Ok(a.cmp(&b)),\n-            (Usize(Us16(a)), Usize(Us16(b))) => Ok(a.cmp(&b)),\n-            (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n-            (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n-            _ => Err(CmpBetweenUnequalTypes),\n-        }\n-    }\n-\n-    /// Adds 1 to the value and wraps around if the maximum for the type is reached\n-    pub fn wrap_incr(self) -> Self {\n-        macro_rules! add1 {\n-            ($e:expr) => { ($e).wrapping_add(1) }\n-        }\n-        match self {\n-            ConstInt::I8(i) => ConstInt::I8(add1!(i)),\n-            ConstInt::I16(i) => ConstInt::I16(add1!(i)),\n-            ConstInt::I32(i) => ConstInt::I32(add1!(i)),\n-            ConstInt::I64(i) => ConstInt::I64(add1!(i)),\n-            ConstInt::I128(i) => ConstInt::I128(add1!(i)),\n-            ConstInt::Isize(ConstIsize::Is16(i)) => ConstInt::Isize(ConstIsize::Is16(add1!(i))),\n-            ConstInt::Isize(ConstIsize::Is32(i)) => ConstInt::Isize(ConstIsize::Is32(add1!(i))),\n-            ConstInt::Isize(ConstIsize::Is64(i)) => ConstInt::Isize(ConstIsize::Is64(add1!(i))),\n-            ConstInt::U8(i) => ConstInt::U8(add1!(i)),\n-            ConstInt::U16(i) => ConstInt::U16(add1!(i)),\n-            ConstInt::U32(i) => ConstInt::U32(add1!(i)),\n-            ConstInt::U64(i) => ConstInt::U64(add1!(i)),\n-            ConstInt::U128(i) => ConstInt::U128(add1!(i)),\n-            ConstInt::Usize(ConstUsize::Us16(i)) => ConstInt::Usize(ConstUsize::Us16(add1!(i))),\n-            ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n-            ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n-        }\n-    }\n-\n-    pub fn int_type(self) -> IntType {\n-        match self {\n-            ConstInt::I8(_) => IntType::SignedInt(IntTy::I8),\n-            ConstInt::I16(_) => IntType::SignedInt(IntTy::I16),\n-            ConstInt::I32(_) => IntType::SignedInt(IntTy::I32),\n-            ConstInt::I64(_) => IntType::SignedInt(IntTy::I64),\n-            ConstInt::I128(_) => IntType::SignedInt(IntTy::I128),\n-            ConstInt::Isize(_) => IntType::SignedInt(IntTy::Isize),\n-            ConstInt::U8(_) => IntType::UnsignedInt(UintTy::U8),\n-            ConstInt::U16(_) => IntType::UnsignedInt(UintTy::U16),\n-            ConstInt::U32(_) => IntType::UnsignedInt(UintTy::U32),\n-            ConstInt::U64(_) => IntType::UnsignedInt(UintTy::U64),\n-            ConstInt::U128(_) => IntType::UnsignedInt(UintTy::U128),\n-            ConstInt::Usize(_) => IntType::UnsignedInt(UintTy::Usize),\n-        }\n-    }\n-}\n-\n-impl ::std::cmp::PartialOrd for ConstInt {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.try_cmp(*other).ok()\n-    }\n-}\n-\n-impl ::std::cmp::Ord for ConstInt {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.try_cmp(*other).unwrap()\n-    }\n-}\n-\n-impl ::std::fmt::Display for ConstInt {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match *self {\n-            I8(i) => write!(fmt, \"{}i8\", i),\n-            I16(i) => write!(fmt, \"{}i16\", i),\n-            I32(i) => write!(fmt, \"{}i32\", i),\n-            I64(i) => write!(fmt, \"{}i64\", i),\n-            I128(i) => write!(fmt, \"{}i128\", i),\n-            Isize(i) => write!(fmt, \"{}isize\", i),\n-            U8(i) => write!(fmt, \"{}u8\", i),\n-            U16(i) => write!(fmt, \"{}u16\", i),\n-            U32(i) => write!(fmt, \"{}u32\", i),\n-            U64(i) => write!(fmt, \"{}u64\", i),\n-            U128(i) => write!(fmt, \"{}u128\", i),\n-            Usize(i) => write!(fmt, \"{}usize\", i),\n-        }\n-    }\n-}\n-\n-macro_rules! overflowing {\n-    ($e:expr, $err:expr) => {{\n-        if $e.1 {\n-            return Err(Overflow($err));\n-        } else {\n-            $e.0\n-        }\n-    }}\n-}\n-\n-macro_rules! impl_binop {\n-    ($op:ident, $func:ident, $checked_func:ident) => {\n-        impl ::std::ops::$op for ConstInt {\n-            type Output = Result<Self, ConstMathErr>;\n-            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match (self, rhs) {\n-                    (I8(a), I8(b)) => a.$checked_func(b).map(I8),\n-                    (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n-                    (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n-                    (I64(a), I64(b)) => a.$checked_func(b).map(I64),\n-                    (I128(a), I128(b)) => a.$checked_func(b).map(I128),\n-                    (Isize(Is16(a)), Isize(Is16(b))) => a.$checked_func(b).map(Is16).map(Isize),\n-                    (Isize(Is32(a)), Isize(Is32(b))) => a.$checked_func(b).map(Is32).map(Isize),\n-                    (Isize(Is64(a)), Isize(Is64(b))) => a.$checked_func(b).map(Is64).map(Isize),\n-                    (U8(a), U8(b)) => a.$checked_func(b).map(U8),\n-                    (U16(a), U16(b)) => a.$checked_func(b).map(U16),\n-                    (U32(a), U32(b)) => a.$checked_func(b).map(U32),\n-                    (U64(a), U64(b)) => a.$checked_func(b).map(U64),\n-                    (U128(a), U128(b)) => a.$checked_func(b).map(U128),\n-                    (Usize(Us16(a)), Usize(Us16(b))) => a.$checked_func(b).map(Us16).map(Usize),\n-                    (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n-                    (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n-                    _ => return Err(UnequalTypes(Op::$op)),\n-                }.ok_or(Overflow(Op::$op))\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! derive_binop {\n-    ($op:ident, $func:ident) => {\n-        impl ::std::ops::$op for ConstInt {\n-            type Output = Result<Self, ConstMathErr>;\n-            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match (self, rhs) {\n-                    (I8(a), I8(b)) => Ok(I8(a.$func(b))),\n-                    (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n-                    (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n-                    (I64(a), I64(b)) => Ok(I64(a.$func(b))),\n-                    (I128(a), I128(b)) => Ok(I128(a.$func(b))),\n-                    (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a.$func(b)))),\n-                    (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a.$func(b)))),\n-                    (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a.$func(b)))),\n-                    (U8(a), U8(b)) => Ok(U8(a.$func(b))),\n-                    (U16(a), U16(b)) => Ok(U16(a.$func(b))),\n-                    (U32(a), U32(b)) => Ok(U32(a.$func(b))),\n-                    (U64(a), U64(b)) => Ok(U64(a.$func(b))),\n-                    (U128(a), U128(b)) => Ok(U128(a.$func(b))),\n-                    (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a.$func(b)))),\n-                    (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n-                    (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n-                    _ => Err(UnequalTypes(Op::$op)),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl_binop!(Add, add, checked_add);\n-impl_binop!(Sub, sub, checked_sub);\n-impl_binop!(Mul, mul, checked_mul);\n-derive_binop!(BitAnd, bitand);\n-derive_binop!(BitOr, bitor);\n-derive_binop!(BitXor, bitxor);\n-\n-const I128_MIN: i128 = ::std::i128::MIN;\n-\n-fn check_division(\n-    lhs: ConstInt,\n-    rhs: ConstInt,\n-    op: Op,\n-    zerr: ConstMathErr,\n-) -> Result<(), ConstMathErr> {\n-    match (lhs, rhs) {\n-        (I8(_), I8(0)) => Err(zerr),\n-        (I16(_), I16(0)) => Err(zerr),\n-        (I32(_), I32(0)) => Err(zerr),\n-        (I64(_), I64(0)) => Err(zerr),\n-        (I128(_), I128(0)) => Err(zerr),\n-        (Isize(_), Isize(Is16(0))) => Err(zerr),\n-        (Isize(_), Isize(Is32(0))) => Err(zerr),\n-        (Isize(_), Isize(Is64(0))) => Err(zerr),\n-\n-        (U8(_), U8(0)) => Err(zerr),\n-        (U16(_), U16(0)) => Err(zerr),\n-        (U32(_), U32(0)) => Err(zerr),\n-        (U64(_), U64(0)) => Err(zerr),\n-        (U128(_), U128(0)) => Err(zerr),\n-        (Usize(_), Usize(Us16(0))) => Err(zerr),\n-        (Usize(_), Usize(Us32(0))) => Err(zerr),\n-        (Usize(_), Usize(Us64(0))) => Err(zerr),\n-\n-        (I8(::std::i8::MIN), I8(-1)) => Err(Overflow(op)),\n-        (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n-        (I32(::std::i32::MIN), I32(-1)) => Err(Overflow(op)),\n-        (I64(::std::i64::MIN), I64(-1)) => Err(Overflow(op)),\n-        (I128(I128_MIN), I128(-1)) => Err(Overflow(op)),\n-        (Isize(Is16(::std::i16::MIN)), Isize(Is16(-1))) => Err(Overflow(op)),\n-        (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n-        (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n-\n-        _ => Ok(()),\n-    }\n-}\n-\n-impl ::std::ops::Div for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn div(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = (self, rhs);\n-        check_division(lhs, rhs, Op::Div, DivisionByZero)?;\n-        match (lhs, rhs) {\n-            (I8(a), I8(b)) => Ok(I8(a/b)),\n-            (I16(a), I16(b)) => Ok(I16(a/b)),\n-            (I32(a), I32(b)) => Ok(I32(a/b)),\n-            (I64(a), I64(b)) => Ok(I64(a/b)),\n-            (I128(a), I128(b)) => Ok(I128(a/b)),\n-            (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a/b))),\n-            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n-            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n-\n-            (U8(a), U8(b)) => Ok(U8(a/b)),\n-            (U16(a), U16(b)) => Ok(U16(a/b)),\n-            (U32(a), U32(b)) => Ok(U32(a/b)),\n-            (U64(a), U64(b)) => Ok(U64(a/b)),\n-            (U128(a), U128(b)) => Ok(U128(a/b)),\n-            (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a/b))),\n-            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n-            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n-\n-            _ => Err(UnequalTypes(Op::Div)),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Rem for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn rem(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = (self, rhs);\n-        // should INT_MIN%-1 be zero or an error?\n-        check_division(lhs, rhs, Op::Rem, RemainderByZero)?;\n-        match (lhs, rhs) {\n-            (I8(a), I8(b)) => Ok(I8(a%b)),\n-            (I16(a), I16(b)) => Ok(I16(a%b)),\n-            (I32(a), I32(b)) => Ok(I32(a%b)),\n-            (I64(a), I64(b)) => Ok(I64(a%b)),\n-            (I128(a), I128(b)) => Ok(I128(a%b)),\n-            (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a%b))),\n-            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n-            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n-\n-            (U8(a), U8(b)) => Ok(U8(a%b)),\n-            (U16(a), U16(b)) => Ok(U16(a%b)),\n-            (U32(a), U32(b)) => Ok(U32(a%b)),\n-            (U64(a), U64(b)) => Ok(U64(a%b)),\n-            (U128(a), U128(b)) => Ok(U128(a%b)),\n-            (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a%b))),\n-            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n-            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n-\n-            _ => Err(UnequalTypes(Op::Rem)),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Shl<ConstInt> for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn shl(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let b = rhs.to_u32().ok_or(ShiftNegative)?;\n-        match self {\n-            I8(a) => Ok(I8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I32(a) => Ok(I32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I64(a) => Ok(I64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I128(a) => Ok(I128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            U8(a) => Ok(U8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U16(a) => Ok(U16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U32(a) => Ok(U32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U64(a) => Ok(U64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U128(a) => Ok(U128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Shr<ConstInt> for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn shr(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let b = rhs.to_u32().ok_or(ShiftNegative)?;\n-        match self {\n-            I8(a) => Ok(I8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I32(a) => Ok(I32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I64(a) => Ok(I64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I128(a) => Ok(I128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            U8(a) => Ok(U8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U16(a) => Ok(U16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U32(a) => Ok(U32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U64(a) => Ok(U64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U128(a) => Ok(U128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Neg for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn neg(self) -> Result<Self, ConstMathErr> {\n-        match self {\n-            I8(a) => Ok(I8(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I16(a) => Ok(I16(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I32(a) => Ok(I32(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I64(a) => Ok(I64(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I128(a) => Ok(I128(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n-            a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n-            U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Not for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn not(self) -> Result<Self, ConstMathErr> {\n-        match self {\n-            I8(a) => Ok(I8(!a)),\n-            I16(a) => Ok(I16(!a)),\n-            I32(a) => Ok(I32(!a)),\n-            I64(a) => Ok(I64(!a)),\n-            I128(a) => Ok(I128(!a)),\n-            Isize(Is16(a)) => Ok(Isize(Is16(!a))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(!a))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(!a))),\n-            U8(a) => Ok(U8(!a)),\n-            U16(a) => Ok(U16(!a)),\n-            U32(a) => Ok(U32(!a)),\n-            U64(a) => Ok(U64(!a)),\n-            U128(a) => Ok(U128(!a)),\n-            Usize(Us16(a)) => Ok(Usize(Us16(!a))),\n-            Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n-            Usize(Us64(a)) => Ok(Usize(Us64(!a))),\n-        }\n-    }\n-}"}, {"sha": "18acc782775d8adb2b2c6c0f6755782ae5282548", "filename": "src/librustc_const_math/isize.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_math%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_math%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fisize.rs?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-use super::err::*;\n-\n-/// Depending on the target only one variant is ever used in a compilation.\n-/// Anything else is an error. This invariant is checked at several locations\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n-pub enum ConstIsize {\n-    Is16(i16),\n-    Is32(i32),\n-    Is64(i64),\n-}\n-pub use self::ConstIsize::*;\n-\n-impl ::std::fmt::Display for ConstIsize {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{}\", self.as_i64())\n-    }\n-}\n-\n-impl ConstIsize {\n-    pub fn as_i64(self) -> i64 {\n-        match self {\n-            Is16(i) => i as i64,\n-            Is32(i) => i as i64,\n-            Is64(i) => i,\n-        }\n-    }\n-    pub fn new(i: i64, isize_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n-        match isize_ty {\n-            ast::IntTy::I16 if i as i16 as i64 == i => Ok(Is16(i as i16)),\n-            ast::IntTy::I16 => Err(LitOutOfRange(ast::IntTy::Isize)),\n-            ast::IntTy::I32 if i as i32 as i64 == i => Ok(Is32(i as i32)),\n-            ast::IntTy::I32 => Err(LitOutOfRange(ast::IntTy::Isize)),\n-            ast::IntTy::I64 => Ok(Is64(i)),\n-            _ => unreachable!(),\n-        }\n-    }\n-    pub fn new_truncating(i: i128, isize_ty: ast::IntTy) -> Self {\n-        match isize_ty {\n-            ast::IntTy::I16 => Is16(i as i16),\n-            ast::IntTy::I32 => Is32(i as i32),\n-            ast::IntTy::I64 => Is64(i as i64),\n-            _ => unreachable!(),\n-        }\n-    }\n-}"}, {"sha": "5555e727a955233be677bd64abeee2afe863d9ba", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -29,13 +29,7 @@ extern crate syntax;\n extern crate serialize as rustc_serialize; // used by deriving\n \n mod float;\n-mod int;\n-mod usize;\n-mod isize;\n mod err;\n \n pub use float::*;\n-pub use int::*;\n-pub use usize::*;\n-pub use isize::*;\n pub use err::{ConstMathErr, Op};"}, {"sha": "56995f08f05b855d9c339baffbb8d9a8a6cb1c5e", "filename": "src/librustc_const_math/usize.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_math%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Flibrustc_const_math%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fusize.rs?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-use super::err::*;\n-\n-/// Depending on the target only one variant is ever used in a compilation.\n-/// Anything else is an error. This invariant is checked at several locations\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n-pub enum ConstUsize {\n-    Us16(u16),\n-    Us32(u32),\n-    Us64(u64),\n-}\n-pub use self::ConstUsize::*;\n-\n-impl ::std::fmt::Display for ConstUsize {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{}\", self.as_u64())\n-    }\n-}\n-\n-impl ConstUsize {\n-    pub fn as_u64(self) -> u64 {\n-        match self {\n-            Us16(i) => i as u64,\n-            Us32(i) => i as u64,\n-            Us64(i) => i,\n-        }\n-    }\n-    pub fn new(i: u64, usize_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n-        match usize_ty {\n-            ast::UintTy::U16 if i as u16 as u64 == i => Ok(Us16(i as u16)),\n-            ast::UintTy::U16 => Err(ULitOutOfRange(ast::UintTy::Usize)),\n-            ast::UintTy::U32 if i as u32 as u64 == i => Ok(Us32(i as u32)),\n-            ast::UintTy::U32 => Err(ULitOutOfRange(ast::UintTy::Usize)),\n-            ast::UintTy::U64 => Ok(Us64(i)),\n-            _ => unreachable!(),\n-        }\n-    }\n-    pub fn new_truncating(i: u128, usize_ty: ast::UintTy) -> Self {\n-        match usize_ty {\n-            ast::UintTy::U16 => Us16(i as u16),\n-            ast::UintTy::U32 => Us32(i as u32),\n-            ast::UintTy::U64 => Us64(i as u64),\n-            _ => unreachable!(),\n-        }\n-    }\n-}"}, {"sha": "70733bc6aeda042e826b95787e9ea26047baee37", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -259,6 +259,14 @@ impl<CTX> HashStable<CTX> for f64 {\n     }\n }\n \n+impl<CTX> HashStable<CTX> for ::std::cmp::Ordering {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (*self as i8).hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<T1: HashStable<CTX>, CTX> HashStable<CTX> for (T1,) {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,"}, {"sha": "6a1d9e5653428ff1f05ac6bb8ce1dd9920a0b740", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -17,7 +17,6 @@ rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "c9cf3f3b81fe6d68de94b0568f2a6ac625500ca6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -36,8 +36,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{self, ast_validation, loops, consts, hir_stats};\n-use rustc_const_eval::{self, check_match};\n+use rustc_passes::{self, ast_validation, loops, rvalue_promotion, hir_stats};\n use super::Compilation;\n \n use serialize::json;\n@@ -942,7 +941,6 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n     ty::provide(providers);\n     traits::provide(providers);\n     reachable::provide(providers);\n-    rustc_const_eval::provide(providers);\n     rustc_passes::provide(providers);\n     middle::region::provide(providers);\n     cstore::provide(providers);\n@@ -1038,8 +1036,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n         }\n \n         time(time_passes,\n-             \"const checking\",\n-             || consts::check_crate(tcx));\n+             \"rvalue promotion\",\n+             || rvalue_promotion::check_crate(tcx));\n \n         analysis.access_levels =\n             time(time_passes, \"privacy checking\", || rustc_privacy::check_crate(tcx));\n@@ -1050,7 +1048,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n \n         time(time_passes,\n              \"match checking\",\n-             || check_match::check_crate(tcx));\n+             || mir::matchck_crate(tcx));\n \n         // this must run before MIR dump, because\n         // \"not all control paths return a value\" is reported here."}, {"sha": "8c0e89716cffdf32d145519dc920bc29ce35ebf0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -35,7 +35,6 @@ extern crate rustc;\n extern crate rustc_allocator;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n-extern crate rustc_const_eval;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_passes;\n@@ -1566,7 +1565,6 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     // FIXME: need to figure out a way to get these back in here\n     // all_errors.extend_from_slice(get_trans(sess).diagnostics());\n     all_errors.extend_from_slice(&rustc_trans_utils::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);\n@@ -1576,8 +1574,14 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     Registry::new(&all_errors)\n }\n \n-pub fn main() {\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// log crate version\n+pub fn init_rustc_env_logger() {\n     env_logger::init();\n+}\n+\n+pub fn main() {\n+    init_rustc_env_logger();\n     let result = run(|| {\n         let args = env::args_os().enumerate()\n             .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {"}, {"sha": "5ff891202dbc5b79d10c0a652ef32facd047ec49", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,6 +12,6 @@ test = false\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_mir = { path = \"../librustc_mir\"}\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "831d4fc755f8f03490bcd76051ad790fd29e60e1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -682,78 +682,6 @@ impl EarlyLintPass for DeprecatedAttr {\n     }\n }\n \n-declare_lint! {\n-    pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-    Warn,\n-    \"floating-point literals cannot be used in patterns\"\n-}\n-\n-/// Checks for floating point literals in patterns.\n-#[derive(Clone)]\n-pub struct IllegalFloatLiteralPattern;\n-\n-impl LintPass for IllegalFloatLiteralPattern {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN)\n-    }\n-}\n-\n-fn fl_lit_check_expr(cx: &EarlyContext, expr: &ast::Expr) {\n-    use self::ast::{ExprKind, LitKind};\n-    match expr.node {\n-        ExprKind::Lit(ref l) => {\n-            match l.node {\n-                LitKind::FloatUnsuffixed(..) |\n-                LitKind::Float(..) => {\n-                    cx.span_lint(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-                                 l.span,\n-                                 \"floating-point literals cannot be used in patterns\");\n-                    },\n-                _ => (),\n-            }\n-        }\n-        // These may occur in patterns\n-        // and can maybe contain float literals\n-        ExprKind::Unary(_, ref f) => fl_lit_check_expr(cx, f),\n-        // Other kinds of exprs can't occur in patterns so we don't have to check them\n-        // (ast_validation will emit an error if they occur)\n-        _ => (),\n-    }\n-}\n-\n-impl EarlyLintPass for IllegalFloatLiteralPattern {\n-    fn check_pat(&mut self, cx: &EarlyContext, pat: &ast::Pat) {\n-        use self::ast::PatKind;\n-        pat.walk(&mut |p| {\n-            match p.node {\n-                // Wildcard patterns and paths are uninteresting for the lint\n-                PatKind::Wild |\n-                PatKind::Path(..) => (),\n-\n-                // The walk logic recurses inside these\n-                PatKind::Ident(..) |\n-                PatKind::Struct(..) |\n-                PatKind::Tuple(..) |\n-                PatKind::TupleStruct(..) |\n-                PatKind::Ref(..) |\n-                PatKind::Box(..) |\n-                PatKind::Paren(..) |\n-                PatKind::Slice(..) => (),\n-\n-                // Extract the expressions and check them\n-                PatKind::Lit(ref e) => fl_lit_check_expr(cx, e),\n-                PatKind::Range(ref st, ref en, _) => {\n-                    fl_lit_check_expr(cx, st);\n-                    fl_lit_check_expr(cx, en);\n-                },\n-\n-                PatKind::Mac(_) => bug!(\"lint must run post-expansion\"),\n-            }\n-            true\n-        });\n-    }\n-}\n-\n declare_lint! {\n     pub UNUSED_DOC_COMMENT,\n     Warn,"}, {"sha": "e941f2e4e1c2a185441e69d6fe34b5a56eec35f4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -39,11 +39,10 @@ extern crate syntax;\n extern crate rustc;\n #[macro_use]\n extern crate log;\n-extern crate rustc_const_eval;\n+extern crate rustc_mir;\n extern crate syntax_pos;\n \n use rustc::lint;\n-use rustc::middle;\n use rustc::session;\n use rustc::util;\n \n@@ -107,7 +106,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                        UnusedParens,\n                        UnusedImportBraces,\n                        AnonymousParameters,\n-                       IllegalFloatLiteralPattern,\n                        UnusedDocComment,\n                        );\n "}, {"sha": "266f322e39777e69ad48059eb3355934e1f995f6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 78, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -14,16 +14,14 @@ use rustc::hir::map as hir_map;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf};\n-use middle::const_val::ConstVal;\n-use rustc_const_eval::ConstContext;\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n \n use std::cmp;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n-use syntax::ast;\n+use syntax::{ast, attr};\n use syntax::abi::Abi;\n use syntax_pos::Span;\n use syntax::codemap;\n@@ -42,12 +40,6 @@ declare_lint! {\n     \"literal out of range for its type\"\n }\n \n-declare_lint! {\n-    EXCEEDING_BITSHIFTS,\n-    Deny,\n-    \"shift exceeds the type's number of bits\"\n-}\n-\n declare_lint! {\n     VARIANT_SIZE_DIFFERENCES,\n     Allow,\n@@ -69,8 +61,7 @@ impl TypeLimits {\n impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_COMPARISONS,\n-                    OVERFLOWING_LITERALS,\n-                    EXCEEDING_BITSHIFTS)\n+                    OVERFLOWING_LITERALS)\n     }\n }\n \n@@ -89,49 +80,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                  e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n-\n-                if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n-                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.isize_ty)),\n-                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.usize_ty)),\n-                        _ => None,\n-                    };\n-\n-                    if let Some(bits) = opt_ty_bits {\n-                        let exceeding = if let hir::ExprLit(ref lit) = r.node {\n-                            if let ast::LitKind::Int(shift, _) = lit.node {\n-                                shift as u64 >= bits\n-                            } else {\n-                                false\n-                            }\n-                        } else {\n-                            // HACK(eddyb) This might be quite inefficient.\n-                            // This would be better left to MIR constant propagation,\n-                            // perhaps even at trans time (like is the case already\n-                            // when the value being shifted is *also* constant).\n-                            let parent_item = cx.tcx.hir.get_parent(e.id);\n-                            let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-                            let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-                            let const_cx = ConstContext::new(cx.tcx,\n-                                                             cx.param_env.and(substs),\n-                                                             cx.tables);\n-                            match const_cx.eval(&r) {\n-                                Ok(&ty::Const { val: ConstVal::Integral(i), .. }) => {\n-                                    i.is_negative() ||\n-                                    i.to_u64()\n-                                        .map(|i| i >= bits)\n-                                        .unwrap_or(true)\n-                                }\n-                                _ => false,\n-                            }\n-                        };\n-                        if exceeding {\n-                            cx.span_lint(EXCEEDING_BITSHIFTS,\n-                                         e.span,\n-                                         \"bitshift exceeds the type's number of bits\");\n-                        }\n-                    };\n-                }\n             }\n             hir::ExprLit(ref lit) => {\n                 match cx.tables.node_id_to_type(e.hir_id).sty {\n@@ -290,28 +238,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn int_ty_bits(int_ty: ast::IntTy, isize_ty: ast::IntTy) -> u64 {\n-            match int_ty {\n-                ast::IntTy::Isize => int_ty_bits(isize_ty, isize_ty),\n-                ast::IntTy::I8 => 8,\n-                ast::IntTy::I16 => 16 as u64,\n-                ast::IntTy::I32 => 32,\n-                ast::IntTy::I64 => 64,\n-                ast::IntTy::I128 => 128,\n-            }\n-        }\n-\n-        fn uint_ty_bits(uint_ty: ast::UintTy, usize_ty: ast::UintTy) -> u64 {\n-            match uint_ty {\n-                ast::UintTy::Usize => uint_ty_bits(usize_ty, usize_ty),\n-                ast::UintTy::U8 => 8,\n-                ast::UintTy::U16 => 16,\n-                ast::UintTy::U32 => 32,\n-                ast::UintTy::U64 => 64,\n-                ast::UintTy::U128 => 128,\n-            }\n-        }\n-\n         fn check_limits(cx: &LateContext,\n                         binop: hir::BinOp,\n                         l: &hir::Expr,\n@@ -439,12 +365,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         ) {\n             let (t, actually) = match ty {\n                 ty::TyInt(t) => {\n-                    let bits = int_ty_bits(t, cx.sess().target.isize_ty);\n+                    let ity = attr::IntType::SignedInt(t);\n+                    let bits = layout::Integer::from_attr(cx.tcx, ity).size().bits();\n                     let actually = (val << (128 - bits)) as i128 >> (128 - bits);\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n                 ty::TyUint(t) => {\n-                    let bits = uint_ty_bits(t, cx.sess().target.usize_ty);\n+                    let ity = attr::IntType::UnsignedInt(t);\n+                    let bits = layout::Integer::from_attr(cx.tcx, ity).size().bits();\n                     let actually = (val << (128 - bits)) >> (128 - bits);\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }"}, {"sha": "0ec5700f5f32a44ae88f01011e80c67d24811ec1", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -664,6 +664,16 @@ extern \"C\" {\n     pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n     pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n     pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n+    pub fn LLVMConstGEP(\n+        ConstantVal: ValueRef,\n+        ConstantIndices: *const ValueRef,\n+        NumIndices: c_uint,\n+    ) -> ValueRef;\n+    pub fn LLVMConstInBoundsGEP(\n+        ConstantVal: ValueRef,\n+        ConstantIndices: *const ValueRef,\n+        NumIndices: c_uint,\n+    ) -> ValueRef;\n     pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;"}, {"sha": "f44703b9335e20e360c71e02414e0ddbc976e61a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -21,14 +21,15 @@ use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex,\n-                         CRATE_DEF_INDEX, LOCAL_CRATE};\n+                         CRATE_DEF_INDEX, LOCAL_CRATE, LocalDefId};\n use rustc::ich::Fingerprint;\n use rustc::middle::lang_items;\n-use rustc::mir;\n+use rustc::mir::{self, interpret};\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n use rustc::mir::Mir;\n+use rustc::util::nodemap::FxHashMap;\n \n use std::cell::Ref;\n use std::collections::BTreeMap;\n@@ -54,6 +55,9 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     last_filemap_index: usize,\n \n     lazy_state: LazyState,\n+\n+    // interpreter allocation cache\n+    interpret_alloc_cache: FxHashMap<usize, interpret::AllocId>,\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n@@ -72,6 +76,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             tcx,\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n+            interpret_alloc_cache: FxHashMap::default(),\n         }\n     }\n }\n@@ -268,6 +273,58 @@ impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n+    #[inline]\n+    fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n+        self.specialized_decode().map(|i| LocalDefId::from_def_id(i))\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n+        const MAX1: usize = usize::max_value() - 1;\n+        let tcx = self.tcx.unwrap();\n+        let pos = self.position();\n+        match usize::decode(self)? {\n+            ::std::usize::MAX => {\n+                let alloc_id = tcx.interpret_interner.reserve();\n+                trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n+                // insert early to allow recursive allocs\n+                self.interpret_alloc_cache.insert(pos, alloc_id);\n+\n+                let allocation = interpret::Allocation::decode(self)?;\n+                trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n+                let allocation = self.tcx.unwrap().intern_const_alloc(allocation);\n+                tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n+\n+                if let Some(glob) = Option::<DefId>::decode(self)? {\n+                    tcx.interpret_interner.cache(glob, alloc_id);\n+                }\n+\n+                Ok(alloc_id)\n+            },\n+            MAX1 => {\n+                trace!(\"creating fn alloc id at {}\", pos);\n+                let instance = ty::Instance::decode(self)?;\n+                trace!(\"decoded fn alloc instance: {:?}\", instance);\n+                let id = tcx.interpret_interner.create_fn_alloc(instance);\n+                trace!(\"created fn alloc id: {:?}\", id);\n+                self.interpret_alloc_cache.insert(pos, id);\n+                Ok(id)\n+            },\n+            shorthand => {\n+                trace!(\"loading shorthand {}\", shorthand);\n+                if let Some(&alloc_id) = self.interpret_alloc_cache.get(&shorthand) {\n+                    return Ok(alloc_id);\n+                }\n+                trace!(\"shorthand {} not cached, loading entire allocation\", shorthand);\n+                // need to load allocation\n+                self.with_position(shorthand, |this| interpret::AllocId::decode(this))\n+            },\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let tag = u8::decode(self)?;"}, {"sha": "d959482417489a16b015c8c77f23e31737a791ff", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,14 +16,14 @@ use schema::*;\n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n                             EncodedMetadata};\n use rustc::hir::def::CtorKind;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::ich::Fingerprint;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n                                       metadata_symbol_name};\n use rustc::middle::lang_items;\n-use rustc::mir;\n+use rustc::mir::{self, interpret};\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n@@ -59,6 +59,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+    interpret_alloc_shorthands: FxHashMap<interpret::AllocId, usize>,\n \n     // This is used to speed up Span encoding.\n     filemap_cache: Lrc<FileMap>,\n@@ -180,12 +181,48 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'a, 'tcx> {\n+    #[inline]\n+    fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n+        self.specialized_encode(&def_id.to_def_id())\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n         ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n \n+impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n+    fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n+        trace!(\"encoding {:?} at {}\", alloc_id, self.position());\n+        if let Some(shorthand) = self.interpret_alloc_shorthands.get(alloc_id).cloned() {\n+            trace!(\"encoding {:?} as shorthand to {}\", alloc_id, shorthand);\n+            return shorthand.encode(self);\n+        }\n+        let start = self.position();\n+        // cache the allocation shorthand now, because the allocation itself might recursively\n+        // point to itself.\n+        self.interpret_alloc_shorthands.insert(*alloc_id, start);\n+        if let Some(alloc) = self.tcx.interpret_interner.get_alloc(*alloc_id) {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n+            usize::max_value().encode(self)?;\n+            alloc.encode(self)?;\n+            self.tcx.interpret_interner\n+                .get_corresponding_static_def_id(*alloc_id)\n+                .encode(self)?;\n+        } else if let Some(fn_instance) = self.tcx.interpret_interner.get_fn(*alloc_id) {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n+            (usize::max_value() - 1).encode(self)?;\n+            fn_instance.encode(self)?;\n+        } else {\n+            bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self,\n                           predicates: &ty::GenericPredicates<'tcx>)\n@@ -1117,7 +1154,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 _ => None,\n             },\n             mir: match item.node {\n-                hir::ItemStatic(..) if self.tcx.sess.opts.debugging_opts.always_encode_mir => {\n+                hir::ItemStatic(..) => {\n                     self.encode_optimized_mir(def_id)\n                 }\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n@@ -1699,6 +1736,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n             filemap_cache: tcx.sess.codemap().files()[0].clone(),\n+            interpret_alloc_shorthands: Default::default(),\n         };\n \n         // Encode the rustc version string in a predictable location."}, {"sha": "593f08e90bb3b093ca2902f8ae5b69fdcec20a26", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -227,9 +227,9 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             trait_id: (krate, def_index),\n@@ -310,9 +310,9 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer, u8),\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for EntryKind<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "90a0f18aba367040be8687c674d86124d6816435", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,13 +9,13 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+arena = { path = \"../libarena\" }\n bitflags = \"1.0\"\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n log_settings = \"0.1.1\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "028fc337967fa1aa55db33181317b84e91726e03", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1635,11 +1635,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Mutability::Mut => Ok(()),\n                 }\n             }\n-            Place::Static(ref static_) => if !self.tcx.is_static_mut(static_.def_id) {\n-                Err(place)\n-            } else {\n-                Ok(())\n-            },\n+            Place::Static(ref static_) =>\n+                if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+                    Err(place)\n+                } else {\n+                    Ok(())\n+                },\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n@@ -1792,7 +1793,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if static1.def_id != static2.def_id {\n                     debug!(\"place_element_conflict: DISJOINT-STATIC\");\n                     Overlap::Disjoint\n-                } else if self.tcx.is_static_mut(static1.def_id) {\n+                } else if self.tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n                     // We ignore mutable statics - they can only be unsafe code.\n                     debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n                     Overlap::Disjoint"}, {"sha": "36e173dd5d640c785e17ff468f9fa30be7976825", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -24,7 +24,6 @@ use rustc::traits::{self, FulfillmentContext};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n-use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n@@ -258,7 +257,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 // constraints on `'a` and `'b`. These constraints\n                 // would be lost if we just look at the normalized\n                 // value.\n-                if let ConstVal::Function(def_id, ..) = value.val {\n+                if let ty::TyFnDef(def_id, substs) = value.ty.sty {\n                     let tcx = self.tcx();\n                     let type_checker = &mut self.cx;\n \n@@ -271,17 +270,6 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     // are transitioning to the miri-based system, we\n                     // don't have a handy function for that, so for\n                     // now we just ignore `value.val` regions.\n-                    let substs = match value.ty.sty {\n-                        ty::TyFnDef(ty_def_id, substs) => {\n-                            assert_eq!(def_id, ty_def_id);\n-                            substs\n-                        }\n-                        _ => span_bug!(\n-                            self.last_span,\n-                            \"unexpected type for constant function: {:?}\",\n-                            value.ty\n-                        ),\n-                    };\n \n                     let instantiated_predicates =\n                         tcx.predicates_of(def_id).instantiate(tcx, substs);\n@@ -436,7 +424,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n                 ty: match base_ty.sty {\n                     ty::TyArray(inner, size) => {\n-                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let size = size.val.unwrap_u64();\n                         let min_size = (from as u64) + (to as u64);\n                         if let Some(rest_size) = size.checked_sub(min_size) {\n                             tcx.mk_array(inner, rest_size)\n@@ -1013,19 +1001,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn is_box_free(&self, operand: &Operand<'tcx>) -> bool {\n-        match operand {\n-            &Operand::Constant(box Constant {\n-                literal:\n-                    Literal::Value {\n-                        value:\n-                            &ty::Const {\n-                                val: ConstVal::Function(def_id, _),\n-                                ..\n-                            },\n-                        ..\n-                    },\n-                ..\n-            }) => Some(def_id) == self.tcx().lang_items().box_free_fn(),\n+        match *operand {\n+            Operand::Constant(ref c) => match c.ty.sty {\n+                ty::TyFnDef(ty_def_id, _) => {\n+                    Some(ty_def_id) == self.tcx().lang_items().box_free_fn()\n+                }\n+                _ => false,\n+            },\n             _ => false,\n         }\n     }\n@@ -1284,7 +1266,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.check_aggregate_rvalue(mir, rvalue, ak, ops, location)\n             }\n \n-            Rvalue::Repeat(operand, const_usize) => if const_usize.as_u64() > 1 {\n+            Rvalue::Repeat(operand, len) => if *len > 1 {\n                 let operand_ty = operand.ty(mir, tcx);\n \n                 let trait_ref = ty::TraitRef {"}, {"sha": "1a9064aab1b2f25e050f47ab333dff292fc17871", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 17, "deletions": 61, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -10,21 +10,18 @@\n \n //! See docs in build/expr/mod.rs\n \n-use std;\n-\n use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n-use rustc_const_math::{ConstInt, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n-use syntax::ast;\n+use rustc::mir::interpret::{Value, PrimVal};\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -203,7 +200,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         ty: this.hir.tcx().types.u32,\n                         literal: Literal::Value {\n                             value: this.hir.tcx().mk_const(ty::Const {\n-                                val: ConstVal::Integral(ConstInt::U32(0)),\n+                                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                                 ty: this.hir.tcx().types.u32\n                             }),\n                         },\n@@ -384,69 +381,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = match ty.sty {\n-            ty::TyInt(ity) => {\n-                let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(-1),\n-                    ast::IntTy::I16 => ConstInt::I16(-1),\n-                    ast::IntTy::I32 => ConstInt::I32(-1),\n-                    ast::IntTy::I64 => ConstInt::I64(-1),\n-                    ast::IntTy::I128 => ConstInt::I128(-1),\n-                    ast::IntTy::Isize => {\n-                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n-                        let val = ConstIsize::new(-1, int_ty).unwrap();\n-                        ConstInt::Isize(val)\n-                    }\n-                };\n-\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n-                        ty\n-                    })\n-                }\n-            }\n-            _ => {\n-                span_bug!(span, \"Invalid type for neg_1_literal: `{:?}`\", ty)\n-            }\n+        let bits = self.hir.integer_bit_width(ty);\n+        let n = (!0u128) >> (128 - bits);\n+        let literal = Literal::Value {\n+            value: self.hir.tcx().mk_const(ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))),\n+                ty\n+            })\n         };\n \n         self.literal_operand(span, ty, literal)\n     }\n \n     // Helper to get the minimum value of the appropriate type\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = match ty.sty {\n-            ty::TyInt(ity) => {\n-                let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(i8::min_value()),\n-                    ast::IntTy::I16 => ConstInt::I16(i16::min_value()),\n-                    ast::IntTy::I32 => ConstInt::I32(i32::min_value()),\n-                    ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n-                    ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n-                    ast::IntTy::Isize => {\n-                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n-                        let min = match int_ty {\n-                            ast::IntTy::I16 => std::i16::MIN as i64,\n-                            ast::IntTy::I32 => std::i32::MIN as i64,\n-                            ast::IntTy::I64 => std::i64::MIN,\n-                            _ => unreachable!()\n-                        };\n-                        let val = ConstIsize::new(min, int_ty).unwrap();\n-                        ConstInt::Isize(val)\n-                    }\n-                };\n-\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n-                        ty\n-                    })\n-                }\n-            }\n-            _ => {\n-                span_bug!(span, \"Invalid type for minval_literal: `{:?}`\", ty)\n-            }\n+        assert!(ty.is_signed());\n+        let bits = self.hir.integer_bit_width(ty);\n+        let n = 1 << (bits - 1);\n+        let literal = Literal::Value {\n+            value: self.hir.tcx().mk_const(ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))),\n+                ty\n+            })\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "229e33dcd786209fc49b67322248a6b3fb6cc696", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -354,7 +354,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<&'tcx ty::Const<'tcx>>,\n+        options: Vec<u128>,\n         indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     },\n "}, {"sha": "09579eaecb2dee8160e538f922e0f6fc2bb2c0e9", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 85, "deletions": 75, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -20,11 +20,10 @@ use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n-use rustc::hir::RangeEnd;\n+use rustc::hir::{RangeEnd, Mutability};\n use syntax_pos::Span;\n use std::cmp::Ordering;\n \n@@ -112,7 +111,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_place: &Place<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<&'tcx ty::Const<'tcx>>,\n+                                     options: &mut Vec<u128>,\n                                      indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n@@ -128,7 +127,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value);\n+                           options.push(value.val.to_raw_bits().expect(\"switching on int\"));\n                            options.len() - 1\n                        });\n                 true\n@@ -174,39 +173,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Convert a byte array or byte slice to a byte slice.\n-    fn to_slice_operand(&mut self,\n-                        block: BasicBlock,\n-                        source_info: SourceInfo,\n-                        operand: Operand<'tcx>)\n-                        -> Operand<'tcx>\n-    {\n-        let tcx = self.hir.tcx();\n-        let ty = operand.ty(&self.local_decls, tcx);\n-        debug!(\"to_slice_operand({:?}, {:?}: {:?})\", block, operand, ty);\n-        match ty.sty {\n-            ty::TyRef(region, mt) => match mt.ty.sty {\n-                ty::TyArray(ety, _) => {\n-                    let ty = tcx.mk_imm_ref(region, tcx.mk_slice(ety));\n-                    let temp = self.temp(ty, source_info.span);\n-                    self.cfg.push_assign(block, source_info, &temp,\n-                                         Rvalue::Cast(CastKind::Unsize, operand, ty));\n-                    Operand::Move(temp)\n-                }\n-                ty::TySlice(_) => operand,\n-                _ => {\n-                    span_bug!(source_info.span,\n-                              \"bad operand {:?}: {:?} to `to_slice_operand`\", operand, ty)\n-                }\n-            }\n-            _ => {\n-                span_bug!(source_info.span,\n-                          \"bad operand {:?}: {:?} to `to_slice_operand`\", operand, ty)\n-            }\n-        }\n-\n-    }\n-\n     /// Generates the code to perform a test.\n     pub fn perform_test(&mut self,\n                         block: BasicBlock,\n@@ -231,7 +197,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let tcx = self.hir.tcx();\n                 for (idx, discr) in adt_def.discriminants(tcx).enumerate() {\n                     target_blocks.place_back() <- if variants.contains(idx) {\n-                        values.push(discr);\n+                        values.push(discr.val);\n                         *(targets.place_back() <- self.cfg.start_new_block())\n                     } else {\n                         if otherwise_block.is_none() {\n@@ -266,9 +232,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n-                    let ret = match options[0].val {\n-                        ConstVal::Bool(true) => vec![true_bb, false_bb],\n-                        ConstVal::Bool(false) => vec![false_bb, true_bb],\n+                    let ret = match options[0] {\n+                        1 => vec![true_bb, false_bb],\n+                        0 => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n                     (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place.clone()),\n@@ -282,55 +248,99 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                .map(|_| self.cfg.start_new_block())\n                                .chain(Some(otherwise))\n                                .collect();\n-                    let values: Vec<_> = options.iter().map(|v|\n-                        v.val.to_const_int().expect(\"switching on integral\")\n-                    ).collect();\n                     (targets.clone(), TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place.clone()),\n                         switch_ty,\n-                        values: From::from(values),\n+                        values: options.clone().into(),\n                         targets,\n                     })\n                 };\n                 self.cfg.terminate(block, source_info, terminator);\n                 ret\n             }\n \n-            TestKind::Eq { value, ty } => {\n-                let tcx = self.hir.tcx();\n+            TestKind::Eq { value, mut ty } => {\n                 let mut val = Operand::Copy(place.clone());\n-\n-                // If we're using b\"...\" as a pattern, we need to insert an\n-                // unsizing coercion, as the byte string has the type &[u8; N].\n-                //\n-                // We want to do this even when the scrutinee is a reference to an\n-                // array, so we can call `<[u8]>::eq` rather than having to find an\n-                // `<[u8; N]>::eq`.\n-                let (expect, val) = if let ConstVal::ByteStr(bytes) = value.val {\n-                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len() as u64);\n-                    let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n-                    let array = self.literal_operand(test.span, array_ref, Literal::Value {\n-                        value\n-                    });\n-\n-                    let val = self.to_slice_operand(block, source_info, val);\n-                    let slice = self.to_slice_operand(block, source_info, array);\n-                    (slice, val)\n-                } else {\n-                    (self.literal_operand(test.span, ty, Literal::Value {\n-                        value\n-                    }), val)\n-                };\n-\n-                // Use PartialEq::eq for &str and &[u8] slices, instead of BinOp::Eq.\n+                let mut expect = self.literal_operand(test.span, ty, Literal::Value {\n+                    value\n+                });\n+                // Use PartialEq::eq instead of BinOp::Eq\n+                // (the binop can only handle primitives)\n                 let fail = self.cfg.start_new_block();\n-                let ty = expect.ty(&self.local_decls, tcx);\n-                if let ty::TyRef(_, mt) = ty.sty {\n-                    assert!(ty.is_slice());\n+                if !ty.is_scalar() {\n+                    // If we're using b\"...\" as a pattern, we need to insert an\n+                    // unsizing coercion, as the byte string has the type &[u8; N].\n+                    //\n+                    // We want to do this even when the scrutinee is a reference to an\n+                    // array, so we can call `<[u8]>::eq` rather than having to find an\n+                    // `<[u8; N]>::eq`.\n+                    let unsize = |ty: Ty<'tcx>| match ty.sty {\n+                        ty::TyRef(region, tam) => match tam.ty.sty {\n+                            ty::TyArray(inner_ty, n) => Some((region, inner_ty, n)),\n+                            _ => None,\n+                        },\n+                        _ => None,\n+                    };\n+                    let opt_ref_ty = unsize(ty);\n+                    let opt_ref_test_ty = unsize(value.ty);\n+                    let mut place = place.clone();\n+                    match (opt_ref_ty, opt_ref_test_ty) {\n+                        // nothing to do, neither is an array\n+                        (None, None) => {},\n+                        (Some((region, elem_ty, _)), _) |\n+                        (None, Some((region, elem_ty, _))) => {\n+                            let tcx = self.hir.tcx();\n+                            // make both a slice\n+                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n+                            if opt_ref_ty.is_some() {\n+                                place = self.temp(ty, test.span);\n+                                self.cfg.push_assign(block, source_info, &place,\n+                                                    Rvalue::Cast(CastKind::Unsize, val, ty));\n+                            }\n+                            if opt_ref_test_ty.is_some() {\n+                                let array = self.literal_operand(\n+                                    test.span,\n+                                    value.ty,\n+                                    Literal::Value {\n+                                        value\n+                                    },\n+                                );\n+\n+                                let slice = self.temp(ty, test.span);\n+                                self.cfg.push_assign(block, source_info, &slice,\n+                                                    Rvalue::Cast(CastKind::Unsize, array, ty));\n+                                expect = Operand::Move(slice);\n+                            }\n+                        },\n+                    }\n                     let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n-                    let ty = mt.ty;\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n \n+                    // take the argument by reference\n+                    let region_scope = self.topmost_scope();\n+                    let region = self.hir.tcx().mk_region(ty::ReScope(region_scope));\n+                    let tam = ty::TypeAndMut {\n+                        ty,\n+                        mutbl: Mutability::MutImmutable,\n+                    };\n+                    let ref_ty = self.hir.tcx().mk_ref(region, tam);\n+\n+                    // let lhs_ref_place = &lhs;\n+                    let ref_rvalue = Rvalue::Ref(region, BorrowKind::Shared, place.clone());\n+                    let lhs_ref_place = self.temp(ref_ty, test.span);\n+                    self.cfg.push_assign(block, source_info, &lhs_ref_place, ref_rvalue);\n+                    let val = Operand::Move(lhs_ref_place);\n+\n+                    // let rhs_place = rhs;\n+                    let rhs_place = self.temp(ty, test.span);\n+                    self.cfg.push_assign(block, source_info, &rhs_place, Rvalue::Use(expect));\n+\n+                    // let rhs_ref_place = &rhs_place;\n+                    let ref_rvalue = Rvalue::Ref(region, BorrowKind::Shared, rhs_place);\n+                    let rhs_ref_place = self.temp(ref_ty, test.span);\n+                    self.cfg.push_assign(block, source_info, &rhs_ref_place, ref_rvalue);\n+                    let expect = Operand::Move(rhs_ref_place);\n+\n                     let bool_ty = self.hir.bool_ty();\n                     let eq_result = self.temp(bool_ty, test.span);\n                     let eq_block = self.cfg.start_new_block();"}, {"sha": "6e10c2307c8e6879e29bf8b2e74ff7e6e1d6db07", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 12, "deletions": 56, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -13,12 +13,11 @@\n \n use build::Builder;\n \n-use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n+use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc::mir::*;\n-use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -55,63 +54,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = match ty.sty {\n-            ty::TyBool => {\n-                self.hir.false_literal()\n-            }\n-            ty::TyChar => {\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Char('\\0'),\n-                        ty\n-                    })\n-                }\n-            }\n-            ty::TyUint(ity) => {\n-                let val = match ity {\n-                    ast::UintTy::U8  => ConstInt::U8(0),\n-                    ast::UintTy::U16 => ConstInt::U16(0),\n-                    ast::UintTy::U32 => ConstInt::U32(0),\n-                    ast::UintTy::U64 => ConstInt::U64(0),\n-                    ast::UintTy::U128 => ConstInt::U128(0),\n-                    ast::UintTy::Usize => {\n-                        let uint_ty = self.hir.tcx().sess.target.usize_ty;\n-                        let val = ConstUsize::new(0, uint_ty).unwrap();\n-                        ConstInt::Usize(val)\n-                    }\n-                };\n-\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n-                        ty\n-                    })\n-                }\n-            }\n-            ty::TyInt(ity) => {\n-                let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(0),\n-                    ast::IntTy::I16 => ConstInt::I16(0),\n-                    ast::IntTy::I32 => ConstInt::I32(0),\n-                    ast::IntTy::I64 => ConstInt::I64(0),\n-                    ast::IntTy::I128 => ConstInt::I128(0),\n-                    ast::IntTy::Isize => {\n-                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n-                        let val = ConstIsize::new(0, int_ty).unwrap();\n-                        ConstInt::Isize(val)\n-                    }\n-                };\n-\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n-                        ty\n-                    })\n-                }\n-            }\n+        match ty.sty {\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyUint(_) |\n+            ty::TyInt(_) => {}\n             _ => {\n                 span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)\n             }\n+        }\n+        let literal = Literal::Value {\n+            value: self.hir.tcx().mk_const(ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n+                ty\n+            })\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "23c5499bb639648c15a0ac570b531f029087988e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -11,7 +11,7 @@\n \n use build;\n use hair::cx::Cx;\n-use hair::LintLevel;\n+use hair::{LintLevel, BindingMode, PatternKind};\n use rustc::hir;\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::region;\n@@ -21,7 +21,6 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n use rustc_back::PanicStrategy;\n-use rustc_const_eval::pattern::{BindingMode, PatternKind};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use shim;\n use std::mem;"}, {"sha": "a150335a1ae4d7b4107751b5501c569a223fb853", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -783,7 +783,7 @@ fn is_unsafe_place<'a, 'gcx: 'tcx, 'tcx: 'a>(\n \n     match *place {\n         Local(_) => false,\n-        Static(ref static_) => tcx.is_static_mut(static_.def_id),\n+        Static(ref static_) => tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable),\n         Projection(ref proj) => {\n             match proj.elem {\n                 ProjectionElem::Field(..) |"}, {"sha": "2000ebea25d7e3337bc47ef01a508b653668a537", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,6 +12,541 @@\n \n register_long_diagnostics! {\n \n+\n+E0001: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error suggests that the expression arm corresponding to the noted pattern\n+will never be reached as for all possible values of the expression being\n+matched, one of the preceding patterns will match.\n+\n+This means that perhaps some of the preceding patterns are too general, this\n+one is too specific or the ordering is incorrect.\n+\n+For example, the following `match` block has too many arms:\n+\n+```\n+match Some(0) {\n+    Some(bar) => {/* ... */}\n+    x => {/* ... */} // This handles the `None` case\n+    _ => {/* ... */} // All possible cases have already been handled\n+}\n+```\n+\n+`match` blocks have their patterns matched in order, so, for example, putting\n+a wildcard arm above a more specific arm will make the latter arm irrelevant.\n+\n+Ensure the ordering of the match arm is correct and remove any superfluous\n+arms.\n+\"##,\n+\n+E0002: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that an empty match expression is invalid because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired. This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`. So, the following will work:\n+\n+```\n+enum Empty {}\n+\n+fn foo(x: Empty) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\n+However, this won't:\n+\n+```compile_fail\n+fn foo(x: Option<String>) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\"##,\n+\n+E0004: r##\"\n+This error indicates that the compiler cannot guarantee a matching pattern for\n+one or more possible inputs to a match expression. Guaranteed matches are\n+required in order to assign values to match expressions, or alternatively,\n+determine the flow of execution. Erroneous code example:\n+\n+```compile_fail,E0004\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+    Terminator::TalkToMyHand => {}\n+}\n+```\n+\n+If you encounter this error you must alter your patterns so that every possible\n+value of the input type is matched. For types with a small number of variants\n+(like enums) you should probably cover all cases explicitly. Alternatively, the\n+underscore `_` wildcard pattern can be added after all other patterns to match\n+\"anything else\". Example:\n+\n+```\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    Terminator::HastaLaVistaBaby => {}\n+}\n+\n+// or:\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+E0005: r##\"\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases. Erroneous code example:\n+\n+```compile_fail,E0005\n+let x = Some(1);\n+let Some(y) = x;\n+// error: refutable pattern in local binding: `None` not covered\n+```\n+\n+If you encounter this error you probably need to use a `match` or `if let` to\n+deal with the possibility of failure. Example:\n+\n+```\n+let x = Some(1);\n+\n+match x {\n+    Some(y) => {\n+        // do something\n+    },\n+    None => {}\n+}\n+\n+// or:\n+\n+if let Some(y) = x {\n+    // do something\n+}\n+```\n+\"##,\n+\n+E0007: r##\"\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code\n+like the following is invalid as it requires the entire `Option<String>` to be\n+moved into a variable called `op_string` while simultaneously requiring the\n+inner `String` to be moved into a variable called `s`.\n+\n+```compile_fail,E0007\n+let x = Some(\"s\".to_string());\n+\n+match x {\n+    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n+    None => {},\n+}\n+```\n+\n+See also the error E0303.\n+\"##,\n+\n+E0008: r##\"\n+Names bound in match arms retain their type in pattern guards. As such, if a\n+name is bound by move in a pattern, it should also be moved to wherever it is\n+referenced in the pattern guard code. Doing so however would prevent the name\n+from being available in the body of the match arm. Consider the following:\n+\n+```compile_fail,E0008\n+match Some(\"hi\".to_string()) {\n+    Some(s) if s.len() == 0 => {}, // use s.\n+    _ => {},\n+}\n+```\n+\n+The variable `s` has type `String`, and its use in the guard is as a variable of\n+type `String`. The guard code effectively executes in a separate scope to the\n+body of the arm, so the value would be moved into this anonymous scope and\n+therefore becomes unavailable in the body of the arm.\n+\n+The problem above can be solved by using the `ref` keyword.\n+\n+```\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) if s.len() == 0 => {},\n+    _ => {},\n+}\n+```\n+\n+Though this example seems innocuous and easy to solve, the problem becomes clear\n+when it encounters functions which consume the value:\n+\n+```compile_fail,E0008\n+struct A{}\n+\n+impl A {\n+    fn consume(self) -> usize {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let a = Some(A{});\n+    match a {\n+        Some(y) if y.consume() > 0 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+In this situation, even the `ref` keyword cannot solve it, since borrowed\n+content cannot be moved. This problem cannot be solved generally. If the value\n+can be cloned, here is a not-so-specific solution:\n+\n+```\n+#[derive(Clone)]\n+struct A{}\n+\n+impl A {\n+    fn consume(self) -> usize {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let a = Some(A{});\n+    match a{\n+        Some(ref y) if y.clone().consume() > 0 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+If the value will be consumed in the pattern guard, using its clone will not\n+move its ownership, so the code works.\n+\"##,\n+\n+E0009: r##\"\n+In a pattern, all values that don't implement the `Copy` trait have to be bound\n+the same way. The goal here is to avoid binding simultaneously by-move and\n+by-ref.\n+\n+This limitation may be removed in a future version of Rust.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0009\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n+                            //        same pattern\n+    None => panic!()\n+}\n+```\n+\n+You have two solutions:\n+\n+Solution #1: Bind the pattern's values the same way.\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((ref y, ref z)) => {},\n+    // or Some((y, z)) => {}\n+    None => panic!()\n+}\n+```\n+\n+Solution #2: Implement the `Copy` trait for the `X` structure.\n+\n+However, please keep in mind that the first solution should be preferred.\n+\n+```\n+#[derive(Clone, Copy)]\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\"##,\n+\n+E0030: r##\"\n+When matching against a range, the compiler verifies that the range is\n+non-empty.  Range patterns include both end-points, so this is equivalent to\n+requiring the start of the range to be less than or equal to the end of the\n+range.\n+\n+For example:\n+\n+```compile_fail\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 ... 1 => {}\n+    // This range is empty, and the compiler can tell.\n+    1000 ... 5 => {}\n+}\n+```\n+\"##,\n+\n+E0158: r##\"\n+`const` and `static` mean different things. A `const` is a compile-time\n+constant, an alias for a literal value. This property means you can match it\n+directly within a pattern.\n+\n+The `static` keyword, on the other hand, guarantees a fixed location in memory.\n+This does not always mean that the value is constant. For example, a global\n+mutex can be declared `static` as well.\n+\n+If you want to match against a `static`, consider using a guard instead:\n+\n+```\n+static FORTY_TWO: i32 = 42;\n+\n+match Some(42) {\n+    Some(x) if x == FORTY_TWO => {}\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+E0162: r##\"\n+An if-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding instead. For instance:\n+\n+```compile_fail,E0162\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+if let Irrefutable(x) = irr {\n+    // This body will always be executed.\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+let Irrefutable(x) = irr;\n+println!(\"{}\", x);\n+```\n+\"##,\n+\n+E0165: r##\"\n+A while-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding inside a `loop` instead. For instance:\n+\n+```compile_fail,E0165\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+while let Irrefutable(x) = irr {\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```no_run\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+loop {\n+    let Irrefutable(x) = irr;\n+    // ...\n+}\n+```\n+\"##,\n+\n+E0170: r##\"\n+Enum variants are qualified by default. For example, given this type:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+```\n+\n+You would match it using:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+\n+let m = Method::GET;\n+\n+match m {\n+    Method::GET => {},\n+    Method::POST => {},\n+}\n+```\n+\n+If you don't qualify the names, the code will bind new variables named \"GET\" and\n+\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n+that happens.\n+\n+Qualified names are good practice, and most code works well with them. But if\n+you prefer them unqualified, you can import the variants into scope:\n+\n+```\n+use Method::*;\n+enum Method { GET, POST }\n+# fn main() {}\n+```\n+\n+If you want others to be able to import variants from your module directly, use\n+`pub use`:\n+\n+```\n+pub use Method::*;\n+pub enum Method { GET, POST }\n+# fn main() {}\n+```\n+\"##,\n+\n+\n+E0297: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Patterns used to bind names must be irrefutable. That is, they must guarantee\n+that a name will be extracted in all cases. Instead of pattern matching the\n+loop variable, consider using a `match` or `if let` inside the loop body. For\n+instance:\n+\n+```compile_fail,E0005\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+// This fails because `None` is not covered.\n+for Some(x) in xs {\n+    // ...\n+}\n+```\n+\n+Match inside the loop instead:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    match item {\n+        Some(x) => {},\n+        None => {},\n+    }\n+}\n+```\n+\n+Or use `if let`:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    if let Some(x) = item {\n+        // ...\n+    }\n+}\n+```\n+\"##,\n+\n+E0301: r##\"\n+Mutable borrows are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if mutable\n+borrows were allowed:\n+\n+```compile_fail,E0301\n+match Some(()) {\n+    None => { },\n+    option if option.take().is_none() => {\n+        /* impossible, option is `Some` */\n+    },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```\n+\"##,\n+\n+E0302: r##\"\n+Assignments are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if assignments\n+were allowed:\n+\n+```compile_fail,E0302\n+match Some(()) {\n+    None => { },\n+    option if { option = None; false } => { },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```\n+\"##,\n+\n+E0303: r##\"\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+Before:\n+\n+```compile_fail,E0303\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(s) => {},\n+    None => {},\n+}\n+```\n+\n+After:\n+\n+```\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) => {\n+        let op_string_ref = &Some(s);\n+        // ...\n+    },\n+    None => {},\n+}\n+```\n+\n+The `op_string_ref` binding has type `&Option<&String>` in both cases.\n+\n+See also https://github.com/rust-lang/rust/issues/14587\n+\"##,\n+\n E0010: r##\"\n The value of statics and constants must be known at compile time, and they live\n for the entire lifetime of a program. Creating a boxed value allocates memory on\n@@ -1613,6 +2148,24 @@ fn main() {\n ```\n \"##,\n \n+E0579: r##\"\n+When matching against an exclusive range, the compiler verifies that the range\n+is non-empty. Exclusive range patterns include the start point but not the end\n+point, so this is equivalent to requiring the start of the range to be less\n+than the end of the range.\n+\n+For example:\n+\n+```compile_fail\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 .. 2 => {}\n+    // This range is empty, and the compiler can tell.\n+    5 .. 5 => {}\n+}\n+```\n+\"##,\n+\n E0595: r##\"\n Closures cannot mutate immutable captured variables.\n \n@@ -1771,6 +2324,9 @@ b.resume();\n }\n \n register_diagnostics! {\n+//  E0298, // cannot compare constants\n+//  E0299, // mismatched types between arms\n+//  E0471, // constant evaluation error (in pattern)\n //    E0385, // {} in an aliasable location\n     E0493, // destructors cannot be evaluated at compile-time\n     E0524, // two closures require unique access to `..` at the same time"}, {"sha": "da25969bf1177ea3ec226bcb9775a119d4a000f8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -10,12 +10,12 @@\n \n use hair::*;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::cast::CastKind as TyCastKind;\n@@ -100,7 +100,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::Deref { arg: expr.to_ref() }\n         }\n         Adjust::Deref(Some(deref)) => {\n-            let call = deref.method_call(cx.tcx, expr.ty);\n+            let call = deref.method_call(cx.tcx(), expr.ty);\n \n             expr = Expr {\n                 temp_lifetime,\n@@ -314,7 +314,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n+        hir::ExprLit(ref lit) => ExprKind::Literal {\n+            literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n+        },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n@@ -400,9 +402,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n-                // FIXME runtime-overflow\n-                if let hir::ExprLit(_) = arg.node {\n-                    ExprKind::Literal { literal: cx.const_eval_literal(expr) }\n+                if let hir::ExprLit(ref lit) = arg.node {\n+                    ExprKind::Literal {\n+                        literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n+                    }\n                 } else {\n                     ExprKind::Unary {\n                         op: UnOp::Neg,\n@@ -508,10 +511,22 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let c = &cx.tcx.hir.body(count).value;\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n-            let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                Ok(&ty::Const { val: ConstVal::Integral(ConstInt::Usize(u)), .. }) => u,\n-                Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n-                Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n+            let instance = ty::Instance::resolve(\n+                cx.tcx.global_tcx(),\n+                cx.param_env,\n+                def_id,\n+                substs,\n+            ).unwrap();\n+            let global_id = GlobalId {\n+                instance,\n+                promoted: None\n+            };\n+            let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and(global_id)) {\n+                Ok(cv) => cv.val.unwrap_u64(),\n+                Err(e) => {\n+                    e.report(cx.tcx, cx.tcx.def_span(def_id), \"array length\");\n+                    0\n+                },\n             };\n \n             ExprKind::Repeat {\n@@ -634,8 +649,8 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(def_id, substs),\n+                value: cx.tcx().mk_const(ty::Const {\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty\n                 }),\n             },\n@@ -682,13 +697,13 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let substs = cx.tables().node_substs(expr.hir_id);\n     match def {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(def_id) |\n-        Def::Method(def_id) |\n-        Def::StructCtor(def_id, CtorKind::Fn) |\n-        Def::VariantCtor(def_id, CtorKind::Fn) => ExprKind::Literal {\n+        Def::Fn(_) |\n+        Def::Method(_) |\n+        Def::StructCtor(_, CtorKind::Fn) |\n+        Def::VariantCtor(_, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n                 value: cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(def_id, substs),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty: cx.tables().node_id_to_type(expr.hir_id)\n                 }),\n             },"}, {"sha": "d8d5f5073abc1d4828490e766ef7b9ffb9717a81", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 105, "deletions": 36, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,22 +16,22 @@\n \n use hair::*;\n \n-use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n-use rustc_const_eval::ConstContext;\n+use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, layout};\n use rustc::ty::subst::Substs;\n-use syntax::ast;\n+use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n-use rustc_const_math::{ConstInt, ConstUsize};\n+use rustc_const_math::ConstFloat;\n use rustc_data_structures::sync::Lrc;\n+use rustc::mir::interpret::{Value, PrimVal};\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -115,16 +115,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n-        match ConstUsize::new(value, self.tcx.sess.target.usize_ty) {\n-            Ok(val) => {\n-                Literal::Value {\n-                    value: self.tcx.mk_const(ty::Const {\n-                        val: ConstVal::Integral(ConstInt::Usize(val)),\n-                        ty: self.tcx.types.usize\n-                    })\n-                }\n-            }\n-            Err(_) => bug!(\"usize literal out of range for target\"),\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(value as u128))),\n+                ty: self.tcx.types.usize\n+            })\n         }\n     }\n \n@@ -139,7 +134,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n             value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Bool(true),\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(1))),\n                 ty: self.tcx.types.bool\n             })\n         }\n@@ -148,20 +143,104 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n             value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Bool(false),\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                 ty: self.tcx.types.bool\n             })\n         }\n     }\n \n-    pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n+    pub fn integer_bit_width(\n+        &self,\n+        ty: Ty,\n+    ) -> u64 {\n+        let ty = match ty.sty {\n+            ty::TyInt(ity) => attr::IntType::SignedInt(ity),\n+            ty::TyUint(uty) => attr::IntType::UnsignedInt(uty),\n+            _ => bug!(\"{} is not an integer\", ty),\n+        };\n+        layout::Integer::from_attr(self.tcx, ty).size().bits()\n+    }\n+\n+    pub fn const_eval_literal(\n+        &mut self,\n+        lit: &'tcx ast::LitKind,\n+        ty: Ty<'tcx>,\n+        sp: Span,\n+        neg: bool,\n+    ) -> Literal<'tcx> {\n+        trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n         let tcx = self.tcx.global_tcx();\n-        let const_cx = ConstContext::new(tcx,\n-                                         self.param_env.and(self.identity_substs),\n-                                         self.tables());\n-        match const_cx.eval(tcx.hir.expect_expr(e.id)) {\n-            Ok(value) => Literal::Value { value },\n-            Err(s) => self.fatal_const_eval_err(&s, e.span, \"expression\")\n+\n+        let parse_float = |num: &str, fty| -> ConstFloat {\n+            ConstFloat::from_str(num, fty).unwrap_or_else(|_| {\n+                // FIXME(#31407) this is only necessary because float parsing is buggy\n+                tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n+            })\n+        };\n+\n+        let clamp = |n| {\n+            let size = self.integer_bit_width(ty);\n+            trace!(\"clamp {} with size {} and amt {}\", n, size, 128 - size);\n+            let amt = 128 - size;\n+            let result = (n << amt) >> amt;\n+            trace!(\"clamp result: {}\", result);\n+            result\n+        };\n+\n+        use rustc::mir::interpret::*;\n+        let lit = match *lit {\n+            LitKind::Str(ref s, _) => {\n+                let s = s.as_str();\n+                let id = self.tcx.allocate_cached(s.as_bytes());\n+                let ptr = MemoryPointer::new(id, 0);\n+                Value::ByValPair(\n+                    PrimVal::Ptr(ptr),\n+                    PrimVal::from_u128(s.len() as u128),\n+                )\n+            },\n+            LitKind::ByteStr(ref data) => {\n+                let id = self.tcx.allocate_cached(data);\n+                let ptr = MemoryPointer::new(id, 0);\n+                Value::ByVal(PrimVal::Ptr(ptr))\n+            },\n+            LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+            LitKind::Int(n, _) if neg => {\n+                let n = n as i128;\n+                let n = n.overflowing_neg().0;\n+                let n = clamp(n as u128);\n+                Value::ByVal(PrimVal::Bytes(n))\n+            },\n+            LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(clamp(n))),\n+            LitKind::Float(n, fty) => {\n+                let n = n.as_str();\n+                let mut f = parse_float(&n, fty);\n+                if neg {\n+                    f = -f;\n+                }\n+                let bits = f.bits;\n+                Value::ByVal(PrimVal::Bytes(bits))\n+            }\n+            LitKind::FloatUnsuffixed(n) => {\n+                let fty = match ty.sty {\n+                    ty::TyFloat(fty) => fty,\n+                    _ => bug!()\n+                };\n+                let n = n.as_str();\n+                let mut f = parse_float(&n, fty);\n+                if neg {\n+                    f = -f;\n+                }\n+                let bits = f.bits;\n+                Value::ByVal(PrimVal::Bytes(bits))\n+            }\n+            LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+            LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+        };\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(lit),\n+                ty,\n+            }),\n         }\n     }\n \n@@ -177,17 +256,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                           p)\n     }\n \n-    pub fn fatal_const_eval_err(&mut self,\n-        err: &ConstEvalErr<'tcx>,\n-        primary_span: Span,\n-        primary_kind: &str)\n-        -> !\n-    {\n-        err.report(self.tcx, primary_span, primary_kind);\n-        self.tcx.sess.abort_if_errors();\n-        unreachable!()\n-    }\n-\n     pub fn trait_method(&mut self,\n                         trait_def_id: DefId,\n                         method_name: &str,\n@@ -203,7 +271,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 return (method_ty,\n                         Literal::Value {\n                             value: self.tcx.mk_const(ty::Const {\n-                                val: ConstVal::Function(item.def_id, substs),\n+                                // ZST function type\n+                                val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                                 ty: method_ty\n                             }),\n                         });"}, {"sha": "5f60a134fb13063bcbfc6594cf444c6ade8a1ed0", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -14,7 +14,6 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc_const_math::ConstUsize;\n use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n@@ -27,7 +26,8 @@ use self::cx::Cx;\n \n pub mod cx;\n \n-pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n+pub mod pattern;\n+pub use self::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n \n #[derive(Copy, Clone, Debug)]\n pub enum LintLevel {\n@@ -246,7 +246,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Repeat {\n         value: ExprRef<'tcx>,\n-        count: ConstUsize,\n+        count: u64,\n     },\n     Array {\n         fields: Vec<ExprRef<'tcx>>,"}, {"sha": "a3295aac80157690501b7e2de459e5b23d396e12", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "renamed", "additions": 126, "deletions": 56, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -13,21 +13,19 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc::middle::const_val::ConstVal;\n-use eval::{compare_const_vals};\n-\n-use rustc_const_math::ConstInt;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use pattern::{FieldPattern, Pattern, PatternKind};\n-use pattern::{PatternFoldable, PatternFolder};\n+use super::{FieldPattern, Pattern, PatternKind};\n+use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::util::common::ErrorReported;\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -182,18 +180,38 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n             match pat.kind {\n                 box PatternKind::Constant {\n-                    value: &ty::Const { val: ConstVal::ByteStr(b), .. }\n+                    value: &ty::Const { val: ConstVal::Value(b), ty }\n                 } => {\n-                    b.data.iter().map(|&b| &*pattern_arena.alloc(Pattern {\n-                        ty: tcx.types.u8,\n-                        span: pat.span,\n-                        kind: box PatternKind::Constant {\n-                            value: tcx.mk_const(ty::Const {\n-                                val: ConstVal::Integral(ConstInt::U8(b)),\n-                                ty: tcx.types.u8\n-                            })\n-                        }\n-                    })).collect()\n+                    match b {\n+                        Value::ByVal(PrimVal::Ptr(ptr)) => {\n+                            let is_array_ptr = ty\n+                                .builtin_deref(true)\n+                                .and_then(|t| t.ty.builtin_index())\n+                                .map_or(false, |t| t == tcx.types.u8);\n+                            assert!(is_array_ptr);\n+                            let alloc = tcx\n+                                .interpret_interner\n+                                .get_alloc(ptr.alloc_id)\n+                                .unwrap();\n+                            assert_eq!(ptr.offset, 0);\n+                            // FIXME: check length\n+                            alloc.bytes.iter().map(|b| {\n+                                &*pattern_arena.alloc(Pattern {\n+                                    ty: tcx.types.u8,\n+                                    span: pat.span,\n+                                    kind: box PatternKind::Constant {\n+                                        value: tcx.mk_const(ty::Const {\n+                                            val: ConstVal::Value(Value::ByVal(\n+                                                PrimVal::Bytes(*b as u128),\n+                                            )),\n+                                            ty: tcx.types.u8\n+                                        })\n+                                    }\n+                                })\n+                            }).collect()\n+                        },\n+                        _ => bug!(\"not a byte str: {:?}\", b),\n+                    }\n                 }\n                 _ => span_bug!(pat.span, \"unexpected byte array pattern {:?}\", pat)\n             }\n@@ -422,13 +440,13 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Bool(b),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b as u128))),\n                     ty: cx.tcx.types.bool\n                 }))\n             }).collect()\n         }\n-        ty::TyArray(ref sub_ty, len) if len.val.to_const_int().is_some() => {\n-            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+        ty::TyArray(ref sub_ty, len) if len.val.to_raw_bits().is_some() => {\n+            let len = len.val.unwrap_u64();\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n@@ -461,7 +479,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n }\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n-    _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     patterns: I) -> u64\n     where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n@@ -535,8 +553,23 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value: &ty::Const { val: ConstVal::ByteStr(b), .. } } => {\n-                max_fixed_len = cmp::max(max_fixed_len, b.data.len() as u64);\n+            PatternKind::Constant {\n+                value: &ty::Const {\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))),\n+                    ty,\n+                }\n+            } => {\n+                let is_array_ptr = ty\n+                    .builtin_deref(true)\n+                    .and_then(|t| t.ty.builtin_index())\n+                    .map_or(false, |t| t == cx.tcx.types.u8);\n+                if is_array_ptr {\n+                    let alloc = cx.tcx\n+                        .interpret_interner\n+                        .get_alloc(ptr.alloc_id)\n+                        .unwrap();\n+                    max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n+                }\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n                 let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n@@ -581,7 +614,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                        witness: WitnessPreference)\n                                        -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n-    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n+    debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n     // The base case. We are pattern-matching on () and the return value is\n     // based on whether our matrix has a row or not.\n@@ -626,10 +659,10 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n     };\n \n-    debug!(\"is_useful_expand_first_col: pcx={:?}, expanding {:?}\", pcx, v[0]);\n+    debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n-        debug!(\"is_useful - expanding constructors: {:?}\", constructors);\n+        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n         constructors.into_iter().map(|c|\n             is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -639,9 +672,9 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let used_ctors: Vec<Constructor> = rows.iter().flat_map(|row| {\n             pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n         }).collect();\n-        debug!(\"used_ctors = {:?}\", used_ctors);\n+        debug!(\"used_ctors = {:#?}\", used_ctors);\n         let all_ctors = all_constructors(cx, pcx);\n-        debug!(\"all_ctors = {:?}\", all_ctors);\n+        debug!(\"all_ctors = {:#?}\", all_ctors);\n         let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n             !used_ctors.contains(*c)\n         }).cloned().collect();\n@@ -669,7 +702,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n         let is_declared_nonexhaustive =\n             cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-        debug!(\"missing_ctors={:?} is_privately_empty={:?} is_declared_nonexhaustive={:?}\",\n+        debug!(\"missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n                missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n \n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n@@ -769,7 +802,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n-    debug!(\"is_useful_specialized({:?}, {:?}, {:?})\", v, ctor, lty);\n+    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n         Pattern {\n@@ -821,7 +854,7 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n             Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::TyArray(_, length) => Some(vec![\n-                Slice(length.val.to_const_int().unwrap().to_u64().unwrap())\n+                Slice(length.val.unwrap_u64())\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n@@ -842,7 +875,7 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n-    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n+    debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs, _) => fs.len() as u64,\n         ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n@@ -866,7 +899,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                                              ctor: &Constructor,\n                                              ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n {\n-    debug!(\"constructor_sub_pattern_tys({:?}, {:?})\", ctor, ty);\n+    debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs, _) => fs.into_iter().map(|t| *t).collect(),\n         ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n@@ -901,14 +934,28 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n+fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n                                     ctor: &Constructor,\n                                     prefix: &[Pattern],\n                                     slice: &Option<Pattern>,\n                                     suffix: &[Pattern])\n                                     -> Result<bool, ErrorReported> {\n-    let data = match *ctor {\n-        ConstantValue(&ty::Const { val: ConstVal::ByteStr(b), .. }) => b.data,\n+    let data: &[u8] = match *ctor {\n+        ConstantValue(&ty::Const { val: ConstVal::Value(\n+            Value::ByVal(PrimVal::Ptr(ptr))\n+        ), ty }) => {\n+            let is_array_ptr = ty\n+                .builtin_deref(true)\n+                .and_then(|t| t.ty.builtin_index())\n+                .map_or(false, |t| t == tcx.types.u8);\n+            assert!(is_array_ptr);\n+            tcx\n+                .interpret_interner\n+                .get_alloc(ptr.alloc_id)\n+                .unwrap()\n+                .bytes\n+                .as_ref()\n+        }\n         _ => bug!()\n     };\n \n@@ -923,11 +970,12 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n     {\n         match pat.kind {\n             box PatternKind::Constant { value } => match value.val {\n-                ConstVal::Integral(ConstInt::U8(u)) => {\n-                    if u != *ch {\n+                ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n+                    assert_eq!(b as u8 as u128, b);\n+                    if b as u8 != *ch {\n                         return Ok(false);\n                     }\n-                },\n+                }\n                 _ => span_bug!(pat.span, \"bad const u8 {:?}\", value)\n             },\n             _ => {}\n@@ -937,31 +985,41 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n     Ok(true)\n }\n \n-fn constructor_covered_by_range(tcx: TyCtxt, span: Span,\n-                                ctor: &Constructor,\n+fn constructor_covered_by_range(ctor: &Constructor,\n                                 from: &ConstVal, to: &ConstVal,\n-                                end: RangeEnd)\n+                                end: RangeEnd,\n+                                ty: Ty)\n                                 -> Result<bool, ErrorReported> {\n-    let cmp_from = |c_from| Ok(compare_const_vals(tcx, span, c_from, from)? != Ordering::Less);\n-    let cmp_to = |c_to| compare_const_vals(tcx, span, c_to, to);\n+    trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n+    let cmp_from = |c_from| compare_const_vals(c_from, from, ty)\n+        .map(|res| res != Ordering::Less);\n+    let cmp_to = |c_to| compare_const_vals(c_to, to, ty);\n+    macro_rules! some_or_ok {\n+        ($e:expr) => {\n+            match $e {\n+                Some(to) => to,\n+                None => return Ok(false), // not char or int\n+            }\n+        };\n+    }\n     match *ctor {\n         ConstantValue(value) => {\n-            let to = cmp_to(&value.val)?;\n+            let to = some_or_ok!(cmp_to(&value.val));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(&value.val)? && end)\n+            Ok(some_or_ok!(cmp_from(&value.val)) && end)\n         },\n         ConstantRange(from, to, RangeEnd::Included) => {\n-            let to = cmp_to(&to.val)?;\n+            let to = some_or_ok!(cmp_to(&to.val));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(&from.val)? && end)\n+            Ok(some_or_ok!(cmp_from(&from.val)) && end)\n         },\n         ConstantRange(from, to, RangeEnd::Excluded) => {\n-            let to = cmp_to(&to.val)?;\n+            let to = some_or_ok!(cmp_to(&to.val));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(cmp_from(&from.val)? && end)\n+            Ok(some_or_ok!(cmp_from(&from.val)) && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -979,7 +1037,7 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n         result[subpat.field.index()] = &subpat.pattern;\n     }\n \n-    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, wild_patterns, result);\n+    debug!(\"patterns_for_variant({:#?}, {:#?}) = {:#?}\", subpatterns, wild_patterns, result);\n     result\n }\n \n@@ -994,7 +1052,7 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     r: &[&'p Pattern<'tcx>],\n-    constructor: &Constructor,\n+    constructor: &Constructor<'tcx>,\n     wild_patterns: &[&'p Pattern<'tcx>])\n     -> Option<Vec<&'p Pattern<'tcx>>>\n {\n@@ -1024,8 +1082,19 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n         PatternKind::Constant { value } => {\n             match *constructor {\n                 Slice(..) => match value.val {\n-                    ConstVal::ByteStr(b) => {\n-                        if wild_patterns.len() == b.data.len() {\n+                    ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))) => {\n+                        let is_array_ptr = value.ty\n+                            .builtin_deref(true)\n+                            .and_then(|t| t.ty.builtin_index())\n+                            .map_or(false, |t| t == cx.tcx.types.u8);\n+                        assert!(is_array_ptr);\n+                        let data_len = cx.tcx\n+                            .interpret_interner\n+                            .get_alloc(ptr.alloc_id)\n+                            .unwrap()\n+                            .bytes\n+                            .len();\n+                        if wild_patterns.len() == data_len {\n                             Some(cx.lower_byte_str_pattern(pat))\n                         } else {\n                             None\n@@ -1036,7 +1105,8 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                 },\n                 _ => {\n                     match constructor_covered_by_range(\n-                        cx.tcx, pat.span, constructor, &value.val, &value.val, RangeEnd::Included\n+                        constructor, &value.val, &value.val, RangeEnd::Included,\n+                        value.ty,\n                             ) {\n                         Ok(true) => Some(vec![]),\n                         Ok(false) => None,\n@@ -1048,7 +1118,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n \n         PatternKind::Range { lo, hi, ref end } => {\n             match constructor_covered_by_range(\n-                cx.tcx, pat.span, constructor, &lo.val, &hi.val, end.clone()\n+                constructor, &lo.val, &hi.val, end.clone(), lo.ty,\n             ) {\n                 Ok(true) => Some(vec![]),\n                 Ok(false) => None,\n@@ -1092,7 +1162,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             }\n         }\n     };\n-    debug!(\"specialize({:?}, {:?}) = {:?}\", r[0], wild_patterns, head);\n+    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n \n     head.map(|mut head| {\n         head.extend_from_slice(&r[1 ..]);", "previous_filename": "src/librustc_const_eval/_match.rs"}, {"sha": "69ed4e6064fcf961f9511b9558edc1f0b602d097", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "renamed", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use _match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n-use _match::Usefulness::*;\n-use _match::WitnessPreference::*;\n+use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n+use super::_match::Usefulness::*;\n+use super::_match::WitnessPreference::*;\n \n-use pattern::{Pattern, PatternContext, PatternError, PatternKind};\n+use super::{Pattern, PatternContext, PatternError, PatternKind};\n \n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n@@ -138,8 +138,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternError::AssociatedConstInPattern(span) => {\n                     self.span_e0158(span, \"associated consts cannot be referenced in patterns\")\n                 }\n-                PatternError::ConstEval(ref err) => {\n-                    err.report(self.tcx, pat_span, \"pattern\");\n+                PatternError::FloatBug => {\n+                    // FIXME(#31407) this is only necessary because float parsing is buggy\n+                    ::rustc::middle::const_val::struct_error(\n+                        self.tcx, pat_span,\n+                        \"could not evaluate float literal (see issue #31407)\",\n+                    ).emit();\n+                }\n+                PatternError::NonConstPath(span) => {\n+                    ::rustc::middle::const_val::struct_error(\n+                        self.tcx, span,\n+                        \"runtime values cannot be referenced in patterns\",\n+                    ).emit();\n                 }\n             }\n         }", "previous_filename": "src/librustc_const_eval/check_match.rs"}, {"sha": "1774c95af0f052dedfdb18b22716a302f3b61119", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "renamed", "additions": 368, "deletions": 153, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,28 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use eval;\n+//! Code to validate patterns/matches\n \n-use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n+mod _match;\n+mod check_match;\n+\n+pub use self::check_match::check_crate;\n+pub(crate) use self::check_match::check_match;\n+\n+use interpret::{const_val_field, const_discr};\n+\n+use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n+use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_const_math::ConstFloat;\n \n+use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n-pub enum PatternError<'tcx> {\n+pub enum PatternError {\n     AssociatedConstInPattern(Span),\n     StaticInPattern(Span),\n-    ConstEval(ConstEvalErr<'tcx>),\n+    FloatBug,\n+    NonConstPath(Span),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -110,21 +122,26 @@ pub enum PatternKind<'tcx> {\n     },\n }\n \n-fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n-    match *value {\n-        ConstVal::Float(ref x) => write!(f, \"{}\", x),\n-        ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n-        ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n-        ConstVal::ByteStr(b) => write!(f, \"{:?}\", b.data),\n-        ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n-        ConstVal::Char(c) => write!(f, \"{:?}\", c),\n-        ConstVal::Variant(_) |\n-        ConstVal::Function(..) |\n-        ConstVal::Aggregate(_) |\n+fn print_const_val(value: &ty::Const, f: &mut fmt::Formatter) -> fmt::Result {\n+    match value.val {\n+        ConstVal::Value(v) => print_miri_value(v, value.ty, f),\n         ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n+fn print_miri_value(value: Value, ty: Ty, f: &mut fmt::Formatter) -> fmt::Result {\n+    use rustc::ty::TypeVariants::*;\n+    match (value, &ty.sty) {\n+        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n+        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(..)) => write!(f, \"{:?}\", n),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(..)) => write!(f, \"{:?}\", n as i128),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n+            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n+        _ => bug!(\"{:?}: {} not printable in a pattern\", value, ty),\n+    }\n+}\n+\n impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self.kind {\n@@ -232,15 +249,15 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 write!(f, \"{}\", subpattern)\n             }\n             PatternKind::Constant { value } => {\n-                print_const_val(&value.val, f)\n+                print_const_val(value, f)\n             }\n             PatternKind::Range { lo, hi, end } => {\n-                print_const_val(&lo.val, f)?;\n+                print_const_val(lo, f)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"...\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n-                print_const_val(&hi.val, f)\n+                print_const_val(hi, f)\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n@@ -272,7 +289,7 @@ pub struct PatternContext<'a, 'tcx: 'a> {\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     pub substs: &'tcx Substs<'tcx>,\n-    pub errors: Vec<PatternError<'tcx>>,\n+    pub errors: Vec<PatternError>,\n }\n \n impl<'a, 'tcx> Pattern<'tcx> {\n@@ -350,18 +367,53 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Lit(ref value) => self.lower_lit(value),\n \n-            PatKind::Range(ref lo, ref hi, end) => {\n-                match (self.lower_lit(lo), self.lower_lit(hi)) {\n+            PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n+                match (self.lower_lit(lo_expr), self.lower_lit(hi_expr)) {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n-                        PatternKind::Range { lo, hi, end }\n+                        use std::cmp::Ordering;\n+                        match (end, compare_const_vals(&lo.val, &hi.val, ty).unwrap()) {\n+                            (RangeEnd::Excluded, Ordering::Less) =>\n+                                PatternKind::Range { lo, hi, end },\n+                            (RangeEnd::Excluded, _) => {\n+                                span_err!(\n+                                    self.tcx.sess,\n+                                    lo_expr.span,\n+                                    E0579,\n+                                    \"lower range bound must be less than upper\",\n+                                );\n+                                PatternKind::Wild\n+                            },\n+                            (RangeEnd::Included, Ordering::Greater) => {\n+                                let mut err = struct_span_err!(\n+                                    self.tcx.sess,\n+                                    lo_expr.span,\n+                                    E0030,\n+                                    \"lower range bound must be less than or equal to upper\"\n+                                );\n+                                err.span_label(\n+                                    lo_expr.span,\n+                                    \"lower bound larger than upper bound\",\n+                                );\n+                                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                    err.note(\"When matching against a range, the compiler \\\n+                                              verifies that the range is non-empty. Range \\\n+                                              patterns include both end-points, so this is \\\n+                                              equivalent to requiring the start of the range \\\n+                                              to be less than or equal to the end of the range.\");\n+                                }\n+                                err.emit();\n+                                PatternKind::Wild\n+                            },\n+                            (RangeEnd::Included, _) => PatternKind::Range { lo, hi, end },\n+                        }\n                     }\n                     _ => PatternKind::Wild\n                 }\n             }\n \n             PatKind::Path(ref qpath) => {\n-                return self.lower_path(qpath, pat.hir_id, pat.id, pat.span);\n+                return self.lower_path(qpath, pat.hir_id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -471,7 +523,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                        pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                self.lower_variant_or_leaf(def, ty, subpatterns)\n+                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n@@ -503,7 +555,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, ty, subpatterns)\n+                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n             }\n         };\n \n@@ -580,7 +632,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n-                let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                let len = len.val.unwrap_u64();\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n                 PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n@@ -594,6 +646,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn lower_variant_or_leaf(\n         &mut self,\n         def: Def,\n+        span: Span,\n         ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n         -> PatternKind<'tcx>\n@@ -624,14 +677,19 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            _ => bug!()\n+            _ => {\n+                self.errors.push(PatternError::NonConstPath(span));\n+                PatternKind::Wild\n+            }\n         }\n     }\n \n+    /// Takes a HIR Path. If the path is a constant, evaluates it and feeds\n+    /// it to `const_to_pat`. Any other path (like enum variants without fields)\n+    /// is converted to the corresponding pattern via `lower_variant_or_leaf`\n     fn lower_path(&mut self,\n                   qpath: &hir::QPath,\n                   id: hir::HirId,\n-                  pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n         let ty = self.tables.node_id_to_type(id);\n@@ -643,34 +701,38 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let substs = self.tables.node_substs(id);\n-                match eval::lookup_const_by_id(self.tcx, self.param_env.and((def_id, substs))) {\n-                    Some((def_id, substs)) => {\n-                        // Enter the inlined constant's tables&substs temporarily.\n-                        let old_tables = self.tables;\n-                        let old_substs = self.substs;\n-                        self.tables = self.tcx.typeck_tables_of(def_id);\n-                        self.substs = substs;\n-                        let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                            self.tcx.hir.body(self.tcx.hir.body_owned_by(id))\n-                        } else {\n-                            self.tcx.extern_const_body(def_id).body\n+                match ty::Instance::resolve(\n+                    self.tcx,\n+                    self.param_env,\n+                    def_id,\n+                    substs,\n+                ) {\n+                    Some(instance) => {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n                         };\n-                        let pat = self.lower_const_expr(&body.value, pat_id, span);\n-                        self.tables = old_tables;\n-                        self.substs = old_substs;\n-                        return pat;\n-                    }\n+                        match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n+                            Ok(value) => {\n+                                return self.const_to_pat(instance, value, id, span)\n+                            },\n+                            Err(err) => {\n+                                err.report(self.tcx, span, \"pattern\");\n+                                PatternKind::Wild\n+                            },\n+                        }\n+                    },\n                     None => {\n                         self.errors.push(if is_associated_const {\n                             PatternError::AssociatedConstInPattern(span)\n                         } else {\n                             PatternError::StaticInPattern(span)\n                         });\n                         PatternKind::Wild\n-                    }\n+                    },\n                 }\n             }\n-            _ => self.lower_variant_or_leaf(def, ty, vec![]),\n+            _ => self.lower_variant_or_leaf(def, span, ty, vec![]),\n         };\n \n         Pattern {\n@@ -680,138 +742,167 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n+    /// Converts literals, paths and negation of literals to patterns.\n+    /// The special case for negation exists to allow things like -128i8\n+    /// which would overflow if we tried to evaluate 128i8 and then negate\n+    /// afterwards.\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n-        let const_cx = eval::ConstContext::new(self.tcx,\n-                                               self.param_env.and(self.substs),\n-                                               self.tables);\n-        match const_cx.eval(expr) {\n-            Ok(value) => {\n-                if let ConstVal::Variant(def_id) = value.val {\n-                    let ty = self.tables.expr_ty(expr);\n-                    self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n-                } else {\n-                    PatternKind::Constant { value }\n+        match expr.node {\n+            hir::ExprLit(ref lit) => {\n+                let ty = self.tables.expr_ty(expr);\n+                match lit_to_const(&lit.node, self.tcx, ty, false) {\n+                    Ok(val) => {\n+                        let instance = ty::Instance::new(\n+                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n+                            self.substs,\n+                        );\n+                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n+                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n+                    },\n+                    Err(()) => {\n+                        self.errors.push(PatternError::FloatBug);\n+                        PatternKind::Wild\n+                    },\n+                }\n+            },\n+            hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n+            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+                let ty = self.tables.expr_ty(expr);\n+                let lit = match expr.node {\n+                    hir::ExprLit(ref lit) => lit,\n+                    _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+                };\n+                match lit_to_const(&lit.node, self.tcx, ty, true) {\n+                    Ok(val) => {\n+                        let instance = ty::Instance::new(\n+                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n+                            self.substs,\n+                        );\n+                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n+                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n+                    },\n+                    Err(()) => {\n+                        self.errors.push(PatternError::FloatBug);\n+                        PatternKind::Wild\n+                    },\n                 }\n             }\n-            Err(e) => {\n-                self.errors.push(PatternError::ConstEval(e));\n-                PatternKind::Wild\n-            }\n+            _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n         }\n     }\n \n-    fn lower_const_expr(&mut self,\n-                        expr: &'tcx hir::Expr,\n-                        pat_id: ast::NodeId,\n-                        span: Span)\n-                        -> Pattern<'tcx> {\n-        let pat_ty = self.tables.expr_ty(expr);\n-        debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n-        match pat_ty.sty {\n+    /// Converts an evaluated constant to a pattern (if possible).\n+    /// This means aggregate values (like structs and enums) are converted\n+    /// to a pattern that matches the value (as if you'd compare via eq).\n+    fn const_to_pat(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n+        span: Span,\n+    ) -> Pattern<'tcx> {\n+        debug!(\"const_to_pat: cv={:#?}\", cv);\n+        let adt_subpattern = |i, variant_opt| {\n+            let field = Field::new(i);\n+            let val = match cv.val {\n+                ConstVal::Value(miri) => const_val_field(\n+                    self.tcx, self.param_env, instance,\n+                    variant_opt, field, miri, cv.ty,\n+                ).unwrap(),\n+                _ => bug!(\"{:#?} is not a valid adt\", cv),\n+            };\n+            self.const_to_pat(instance, val, id, span)\n+        };\n+        let adt_subpatterns = |n, variant_opt| {\n+            (0..n).map(|i| {\n+                let field = Field::new(i);\n+                FieldPattern {\n+                    field,\n+                    pattern: adt_subpattern(i, variant_opt),\n+                }\n+            }).collect::<Vec<_>>()\n+        };\n+        let kind = match cv.ty.sty {\n             ty::TyFloat(_) => {\n-                self.tcx.sess.span_err(span, \"floating point constants cannot be used in patterns\");\n-            }\n+                let id = self.tcx.hir.hir_to_node_id(id);\n+                self.tcx.lint_node(\n+                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+                    id,\n+                    span,\n+                    \"floating-point types cannot be used in patterns\",\n+                );\n+                PatternKind::Constant {\n+                    value: cv,\n+                }\n+            },\n             ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+                PatternKind::Wild\n             }\n-            ty::TyAdt(adt_def, _) => {\n-                if !self.tcx.has_attr(adt_def.did, \"structural_match\") {\n-                    let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n-                                       `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                      self.tcx.item_path_str(adt_def.did),\n-                                      self.tcx.item_path_str(adt_def.did));\n-                    self.tcx.sess.span_err(span, &msg);\n+            ty::TyAdt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+                let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n+                                    `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                                    self.tcx.item_path_str(adt_def.did),\n+                                    self.tcx.item_path_str(adt_def.did));\n+                self.tcx.sess.span_err(span, &msg);\n+                PatternKind::Wild\n+            },\n+            ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n+                match cv.val {\n+                    ConstVal::Value(val) => {\n+                        let discr = const_discr(\n+                            self.tcx, self.param_env, instance, val, cv.ty\n+                        ).unwrap();\n+                        let variant_index = adt_def\n+                            .discriminants(self.tcx)\n+                            .position(|var| var.val == discr)\n+                            .unwrap();\n+                        let subpatterns = adt_subpatterns(\n+                            adt_def.variants[variant_index].fields.len(),\n+                            Some(variant_index),\n+                        );\n+                        PatternKind::Variant {\n+                            adt_def,\n+                            substs,\n+                            variant_index,\n+                            subpatterns,\n+                        }\n+                    },\n+                    ConstVal::Unevaluated(..) =>\n+                        span_bug!(span, \"{:#?} is not a valid enum constant\", cv),\n                 }\n-            }\n-            _ => { }\n-        }\n-        let kind = match expr.node {\n-            hir::ExprTup(ref exprs) => {\n+            },\n+            ty::TyAdt(adt_def, _) => {\n+                let struct_var = adt_def.non_enum_variant();\n                 PatternKind::Leaf {\n-                    subpatterns: exprs.iter().enumerate().map(|(i, expr)| {\n-                        FieldPattern {\n-                            field: Field::new(i),\n-                            pattern: self.lower_const_expr(expr, pat_id, span)\n-                        }\n-                    }).collect()\n+                    subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n                 }\n             }\n-\n-            hir::ExprCall(ref callee, ref args) => {\n-                let qpath = match callee.node {\n-                    hir::ExprPath(ref qpath) => qpath,\n-                    _ => bug!()\n-                };\n-                let ty = self.tables.node_id_to_type(callee.hir_id);\n-                let def = self.tables.qpath_def(qpath, callee.hir_id);\n-                match def {\n-                    Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n-                    _ => {\n-                        let subpatterns = args.iter().enumerate().map(|(i, expr)| {\n-                            FieldPattern {\n-                                field: Field::new(i),\n-                                pattern: self.lower_const_expr(expr, pat_id, span)\n-                            }\n-                        }).collect();\n-                        self.lower_variant_or_leaf(def, ty, subpatterns)\n-                    }\n+            ty::TyTuple(fields, _) => {\n+                PatternKind::Leaf {\n+                    subpatterns: adt_subpatterns(fields.len(), None),\n                 }\n             }\n-\n-            hir::ExprStruct(ref qpath, ref fields, None) => {\n-                let def = self.tables.qpath_def(qpath, expr.hir_id);\n-                let adt_def = match pat_ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => {\n-                        span_bug!(\n-                            expr.span,\n-                            \"struct expr without ADT type\");\n-                    }\n-                };\n-                let variant_def = adt_def.variant_of_def(def);\n-\n-                let subpatterns =\n-                    fields.iter()\n-                          .map(|field| {\n-                              let index = variant_def.index_of_field_named(field.name.node);\n-                              let index = index.unwrap_or_else(|| {\n-                                  span_bug!(\n-                                      expr.span,\n-                                      \"no field with name {:?}\",\n-                                      field.name);\n-                              });\n-                              FieldPattern {\n-                                  field: Field::new(index),\n-                                  pattern: self.lower_const_expr(&field.expr, pat_id, span),\n-                              }\n-                          })\n-                          .collect();\n-\n-                self.lower_variant_or_leaf(def, pat_ty, subpatterns)\n-            }\n-\n-            hir::ExprArray(ref exprs) => {\n-                let pats = exprs.iter()\n-                                .map(|expr| self.lower_const_expr(expr, pat_id, span))\n-                                .collect();\n+            ty::TyArray(_, n) => {\n                 PatternKind::Array {\n-                    prefix: pats,\n+                    prefix: (0..n.val.unwrap_u64())\n+                        .map(|i| adt_subpattern(i as usize, None))\n+                        .collect(),\n                     slice: None,\n-                    suffix: vec![]\n+                    suffix: Vec::new(),\n                 }\n             }\n-\n-            hir::ExprPath(ref qpath) => {\n-                return self.lower_path(qpath, expr.hir_id, pat_id, span);\n-            }\n-\n-            _ => self.lower_lit(expr)\n+            _ => {\n+                PatternKind::Constant {\n+                    value: cv,\n+                }\n+            },\n         };\n \n         Pattern {\n             span,\n-            ty: pat_ty,\n+            ty: cv.ty,\n             kind: Box::new(kind),\n         }\n     }\n@@ -975,3 +1066,127 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n         }\n     }\n }\n+\n+pub fn compare_const_vals(a: &ConstVal, b: &ConstVal, ty: Ty) -> Option<Ordering> {\n+    use rustc_const_math::ConstFloat;\n+    trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n+    use rustc::mir::interpret::{Value, PrimVal};\n+    match (a, b) {\n+        (&ConstVal::Value(Value::ByVal(PrimVal::Bytes(a))),\n+         &ConstVal::Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n+            match ty.sty {\n+                ty::TyFloat(ty) => {\n+                    let l = ConstFloat {\n+                        bits: a,\n+                        ty,\n+                    };\n+                    let r = ConstFloat {\n+                        bits: b,\n+                        ty,\n+                    };\n+                    // FIXME(oli-obk): report cmp errors?\n+                    l.try_cmp(r).ok()\n+                },\n+                ty::TyInt(_) => Some((a as i128).cmp(&(b as i128))),\n+                _ => Some(a.cmp(&b)),\n+            }\n+        },\n+        _ if a == b => Some(Ordering::Equal),\n+        _ => None,\n+    }\n+}\n+\n+fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          neg: bool)\n+                          -> Result<ConstVal<'tcx>, ()> {\n+    use syntax::ast::*;\n+\n+    use rustc::mir::interpret::*;\n+    let lit = match *lit {\n+        LitKind::Str(ref s, _) => {\n+            let s = s.as_str();\n+            let id = tcx.allocate_cached(s.as_bytes());\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByValPair(\n+                PrimVal::Ptr(ptr),\n+                PrimVal::from_u128(s.len() as u128),\n+            )\n+        },\n+        LitKind::ByteStr(ref data) => {\n+            let id = tcx.allocate_cached(data);\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByVal(PrimVal::Ptr(ptr))\n+        },\n+        LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+        LitKind::Int(n, _) => {\n+            enum Int {\n+                Signed(IntTy),\n+                Unsigned(UintTy),\n+            }\n+            let ty = match ty.sty {\n+                ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n+                ty::TyInt(other) => Int::Signed(other),\n+                ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n+                ty::TyUint(other) => Int::Unsigned(other),\n+                _ => bug!(),\n+            };\n+            let n = match ty {\n+                // FIXME(oli-obk): are these casts correct?\n+                Int::Signed(IntTy::I8) if neg =>\n+                    (n as i128 as i8).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I16) if neg =>\n+                    (n as i128 as i16).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I32) if neg =>\n+                    (n as i128 as i32).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I64) if neg =>\n+                    (n as i128 as i64).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I128) if neg =>\n+                    (n as i128).overflowing_neg().0 as u128,\n+                Int::Signed(IntTy::I8) => n as i128 as i8 as i128 as u128,\n+                Int::Signed(IntTy::I16) => n as i128 as i16 as i128 as u128,\n+                Int::Signed(IntTy::I32) => n as i128 as i32 as i128 as u128,\n+                Int::Signed(IntTy::I64) => n as i128 as i64 as i128 as u128,\n+                Int::Signed(IntTy::I128) => n,\n+                Int::Unsigned(UintTy::U8) => n as u8 as u128,\n+                Int::Unsigned(UintTy::U16) => n as u16 as u128,\n+                Int::Unsigned(UintTy::U32) => n as u32 as u128,\n+                Int::Unsigned(UintTy::U64) => n as u64 as u128,\n+                Int::Unsigned(UintTy::U128) => n,\n+                _ => bug!(),\n+            };\n+            Value::ByVal(PrimVal::Bytes(n))\n+        },\n+        LitKind::Float(n, fty) => {\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n+        }\n+        LitKind::FloatUnsuffixed(n) => {\n+            let fty = match ty.sty {\n+                ty::TyFloat(fty) => fty,\n+                _ => bug!()\n+            };\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n+        }\n+        LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+        LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+    };\n+    Ok(ConstVal::Value(lit))\n+}\n+\n+fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n+                     -> Result<ConstFloat, ()> {\n+    ConstFloat::from_str(num, fty).map_err(|_| ())\n+}", "previous_filename": "src/librustc_const_eval/pattern.rs"}, {"sha": "e654142d2164c346d64655ff3e8dbb759abefd27", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 49, "deletions": 68, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,4 +1,5 @@\n use rustc::ty::Ty;\n+use rustc::ty::layout::LayoutOf;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_const_math::ConstFloat;\n@@ -7,115 +8,95 @@ use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmeti\n use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::Float;\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub(super) fn cast_primval(\n         &self,\n         val: PrimVal,\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n+        use rustc::ty::TypeVariants::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n-        let src_kind = self.ty_to_primval_kind(src_ty)?;\n \n         match val {\n             PrimVal::Undef => Ok(PrimVal::Undef),\n             PrimVal::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n-            val @ PrimVal::Bytes(_) => {\n-                use rustc::mir::interpret::PrimValKind::*;\n-                match src_kind {\n-                    F32 => self.cast_from_float(val.to_f32()?, dest_ty),\n-                    F64 => self.cast_from_float(val.to_f64()?, dest_ty),\n-\n-                    I8 | I16 | I32 | I64 | I128 => {\n-                        self.cast_from_signed_int(val.to_i128()?, dest_ty)\n-                    }\n-\n-                    Bool | Char | U8 | U16 | U32 | U64 | U128 | FnPtr | Ptr => {\n-                        self.cast_from_int(val.to_u128()?, dest_ty, false)\n-                    }\n+            PrimVal::Bytes(b) => {\n+                match src_ty.sty {\n+                    TyFloat(fty) => self.cast_from_float(b, fty, dest_ty),\n+                    _ => self.cast_from_int(b, src_ty, dest_ty),\n                 }\n             }\n         }\n     }\n \n-    fn cast_from_signed_int(&self, val: i128, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        self.cast_from_int(val as u128, ty, val < 0)\n-    }\n-\n-    fn int_to_int(&self, v: i128, ty: IntTy) -> u128 {\n-        match ty {\n-            IntTy::I8 => v as i8 as u128,\n-            IntTy::I16 => v as i16 as u128,\n-            IntTy::I32 => v as i32 as u128,\n-            IntTy::I64 => v as i64 as u128,\n-            IntTy::I128 => v as u128,\n-            IntTy::Isize => {\n-                let ty = self.tcx.sess.target.isize_ty;\n-                self.int_to_int(v, ty)\n-            }\n-        }\n-    }\n-    fn int_to_uint(&self, v: u128, ty: UintTy) -> u128 {\n-        match ty {\n-            UintTy::U8 => v as u8 as u128,\n-            UintTy::U16 => v as u16 as u128,\n-            UintTy::U32 => v as u32 as u128,\n-            UintTy::U64 => v as u64 as u128,\n-            UintTy::U128 => v,\n-            UintTy::Usize => {\n-                let ty = self.tcx.sess.target.usize_ty;\n-                self.int_to_uint(v, ty)\n-            }\n-        }\n-    }\n-\n     fn cast_from_int(\n         &self,\n         v: u128,\n-        ty: Ty<'tcx>,\n-        negative: bool,\n+        src_ty: Ty<'tcx>,\n+        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n-        trace!(\"cast_from_int: {}, {}, {}\", v, ty, negative);\n+        let signed = self.layout_of(src_ty)?.abi.is_signed();\n+        let v = if signed {\n+            self.sign_extend(v, src_ty)?\n+        } else {\n+            v\n+        };\n+        trace!(\"cast_from_int: {}, {}, {}\", v, src_ty, dest_ty);\n         use rustc::ty::TypeVariants::*;\n-        match ty.sty {\n-            // Casts to bool are not permitted by rustc, no need to handle them here.\n-            TyInt(ty) => Ok(PrimVal::Bytes(self.int_to_int(v as i128, ty))),\n-            TyUint(ty) => Ok(PrimVal::Bytes(self.int_to_uint(v, ty))),\n+        match dest_ty.sty {\n+            TyInt(_) | TyUint(_) => {\n+                let v = self.truncate(v, dest_ty)?;\n+                Ok(PrimVal::Bytes(v))\n+            }\n \n-            TyFloat(fty) if negative => Ok(PrimVal::Bytes(ConstFloat::from_i128(v as i128, fty).bits)),\n+            TyFloat(fty) if signed => Ok(PrimVal::Bytes(ConstFloat::from_i128(v as i128, fty).bits)),\n             TyFloat(fty) => Ok(PrimVal::Bytes(ConstFloat::from_u128(v, fty).bits)),\n \n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => err!(InvalidChar(v)),\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n-            TyRawPtr(_) => Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128)),\n+            TyRawPtr(_) => {\n+                Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128))\n+            },\n \n-            _ => err!(Unimplemented(format!(\"int to {:?} cast\", ty))),\n+            // Casts to bool are not permitted by rustc, no need to handle them here.\n+            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_ty))),\n         }\n     }\n \n-    fn cast_from_float(&self, val: ConstFloat, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n-        match ty.sty {\n+        use rustc_apfloat::FloatConvert;\n+        match dest_ty.sty {\n+            // float -> uint\n             TyUint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size() as usize * 8);\n-                match val.ty {\n-                    FloatTy::F32 => Ok(PrimVal::Bytes(Single::from_bits(val.bits).to_u128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::Bytes(Double::from_bits(val.bits).to_u128(width).value)),\n+                match fty {\n+                    FloatTy::F32 => Ok(PrimVal::Bytes(Single::from_bits(bits).to_u128(width).value)),\n+                    FloatTy::F64 => Ok(PrimVal::Bytes(Double::from_bits(bits).to_u128(width).value)),\n                 }\n             },\n-\n+            // float -> int\n             TyInt(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size() as usize * 8);\n-                match val.ty {\n-                    FloatTy::F32 => Ok(PrimVal::from_i128(Single::from_bits(val.bits).to_i128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::from_i128(Double::from_bits(val.bits).to_i128(width).value)),\n+                match fty {\n+                    FloatTy::F32 => Ok(PrimVal::from_i128(Single::from_bits(bits).to_i128(width).value)),\n+                    FloatTy::F64 => Ok(PrimVal::from_i128(Double::from_bits(bits).to_i128(width).value)),\n                 }\n             },\n-\n-            TyFloat(fty) => Ok(PrimVal::from_float(val.convert(fty))),\n-            _ => err!(Unimplemented(format!(\"float to {:?} cast\", ty))),\n+            // f64 -> f32\n+            TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n+                Ok(PrimVal::Bytes(Single::to_bits(Double::from_bits(bits).convert(&mut false).value)))\n+            },\n+            // f32 -> f64\n+            TyFloat(FloatTy::F64) if fty == FloatTy::F32 => {\n+                Ok(PrimVal::Bytes(Double::to_bits(Single::from_bits(bits).convert(&mut false).value)))\n+            },\n+            // identity cast\n+            TyFloat(_) => Ok(PrimVal::Bytes(bits)),\n+            _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }\n     }\n "}, {"sha": "ee5874be9d70ae997be6885fd7fda95489002de3", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 302, "deletions": 367, "changes": 669, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,34 +1,49 @@\n+use rustc::hir;\n+use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n+use rustc::middle::const_val::ErrKind::{TypeckError, CheckMatchError};\n+use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n use rustc::ty::layout::{self, LayoutOf};\n-use rustc::ty::subst::Substs;\n-use rustc::hir::def_id::DefId;\n-use rustc::mir;\n-use rustc::middle::const_val::ErrKind::{CheckMatchError, TypeckError};\n-use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n-use rustc_const_eval::{lookup_const_by_id, ConstContext};\n-use rustc::mir::Field;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc::ty::subst::Subst;\n \n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal};\n-use super::{Place, EvalContext, StackPopCleanup, ValTy};\n-\n-use rustc_const_math::ConstInt;\n+use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal, AllocId};\n+use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory};\n \n use std::fmt;\n use std::error::Error;\n+use std::rc::Rc;\n \n+pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    mir: &'mir mir::Mir<'tcx>,\n+    span: Span,\n+) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>> {\n+    debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n+    let param_env = tcx.param_env(instance.def_id());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    // insert a stack frame so any queries have the correct substs\n+    ecx.push_stack_frame(\n+        instance,\n+        span,\n+        mir,\n+        Place::undef(),\n+        StackPopCleanup::None,\n+    )?;\n+    Ok(ecx)\n+}\n \n pub fn mk_eval_cx<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, EvalContext<'a, 'tcx, CompileTimeEvaluator>> {\n+) -> EvalResult<'tcx, EvalContext<'a, 'tcx, 'tcx, CompileTimeEvaluator>> {\n     debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n-    let limits = super::ResourceLimits::default();\n-    let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n+    let span = tcx.def_span(instance.def_id());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n     let mir = ecx.load_mir(instance.def)?;\n     // insert a stack frame so any queries have the correct substs\n     ecx.push_stack_frame(\n@@ -41,99 +56,115 @@ pub fn mk_eval_cx<'a, 'tcx>(\n     Ok(ecx)\n }\n \n-pub fn eval_body<'a, 'tcx>(\n+pub fn eval_body_with_mir<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n+    cid: GlobalId<'tcx>,\n+    mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Pointer, Ty<'tcx>)> {\n-    debug!(\"eval_body: {:?}, {:?}\", instance, param_env);\n-    let limits = super::ResourceLimits::default();\n-    let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n-    let cid = GlobalId {\n-        instance,\n-        promoted: None,\n-    };\n-\n-    if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n-        return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n+) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+    let (res, ecx) = eval_body_and_ecx(tcx, cid, Some(mir), param_env);\n+    match res {\n+        Ok(val) => Some(val),\n+        Err(mut err) => {\n+            ecx.report(&mut err, true, None);\n+            None\n+        }\n     }\n-    let instance_ty = instance.ty(tcx);\n-    if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n-        let mir = ecx.load_mir(instance.def)?;\n-        let layout = ecx.layout_of(instance_ty)?;\n-        assert!(!layout.is_unsized());\n-        let ptr = ecx.memory.allocate(\n-            layout.size.bytes(),\n-            layout.align,\n-            None,\n-        )?;\n-        tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n-        let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n-        let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n-        trace!(\"const_eval: pushing stack frame for global: {}\", name);\n-        ecx.push_stack_frame(\n-            instance,\n-            mir.span,\n-            mir,\n-            Place::from_ptr(ptr, layout.align),\n-            cleanup.clone(),\n-        )?;\n+}\n \n-        while ecx.step()? {}\n+pub fn eval_body<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    cid: GlobalId<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+    let (res, ecx) = eval_body_and_ecx(tcx, cid, None, param_env);\n+    match res {\n+        Ok(val) => Some(val),\n+        Err(mut err) => {\n+            ecx.report(&mut err, true, None);\n+            None\n+        }\n     }\n-    let alloc = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n-    Ok((MemoryPointer::new(alloc, 0).into(), instance_ty))\n }\n \n-pub fn eval_body_as_integer<'a, 'tcx>(\n+fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    cid: GlobalId<'tcx>,\n+    mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-    instance: Instance<'tcx>,\n-) -> EvalResult<'tcx, ConstInt> {\n-    let ptr_ty = eval_body(tcx, instance, param_env);\n-    let (ptr, ty) = ptr_ty?;\n-    let ecx = mk_eval_cx(tcx, instance, param_env)?;\n-    let prim = match ecx.try_read_value(ptr, ecx.layout_of(ty)?.align, ty)? {\n-        Some(Value::ByVal(prim)) => prim.to_bytes()?,\n-        _ => return err!(TypeNotPrimitive(ty)),\n-    };\n-    use syntax::ast::{IntTy, UintTy};\n-    use rustc::ty::TypeVariants::*;\n-    use rustc_const_math::{ConstIsize, ConstUsize};\n-    Ok(match ty.sty {\n-        TyInt(IntTy::I8) => ConstInt::I8(prim as i128 as i8),\n-        TyInt(IntTy::I16) => ConstInt::I16(prim as i128 as i16),\n-        TyInt(IntTy::I32) => ConstInt::I32(prim as i128 as i32),\n-        TyInt(IntTy::I64) => ConstInt::I64(prim as i128 as i64),\n-        TyInt(IntTy::I128) => ConstInt::I128(prim as i128),\n-        TyInt(IntTy::Isize) => ConstInt::Isize(\n-            ConstIsize::new(prim as i128 as i64, tcx.sess.target.isize_ty)\n-                .expect(\"miri should already have errored\"),\n-        ),\n-        TyUint(UintTy::U8) => ConstInt::U8(prim as u8),\n-        TyUint(UintTy::U16) => ConstInt::U16(prim as u16),\n-        TyUint(UintTy::U32) => ConstInt::U32(prim as u32),\n-        TyUint(UintTy::U64) => ConstInt::U64(prim as u64),\n-        TyUint(UintTy::U128) => ConstInt::U128(prim),\n-        TyUint(UintTy::Usize) => ConstInt::Usize(\n-            ConstUsize::new(prim as u64, tcx.sess.target.usize_ty)\n-                .expect(\"miri should already have errored\"),\n-        ),\n-        _ => {\n-            return Err(\n-                ConstEvalError::NeedsRfc(\n-                    \"evaluating anything other than isize/usize during typeck\".to_string(),\n-                ).into(),\n-            )\n+) -> (EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+    debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n+    // we start out with the best span we have\n+    // and try improving it down the road when more information is available\n+    let span = tcx.def_span(cid.instance.def_id());\n+    let mut span = mir.map(|mir| mir.span).unwrap_or(span);\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    let res = (|| {\n+        let mut mir = match mir {\n+            Some(mir) => mir,\n+            None => ecx.load_mir(cid.instance.def)?,\n+        };\n+        if let Some(index) = cid.promoted {\n+            mir = &mir.promoted[index];\n         }\n-    })\n+        span = mir.span;\n+        let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n+        let alloc = tcx.interpret_interner.get_cached(cid.instance.def_id());\n+        let alloc = match alloc {\n+            Some(alloc) => {\n+                assert!(cid.promoted.is_none());\n+                assert!(param_env.caller_bounds.is_empty());\n+                alloc\n+            },\n+            None => {\n+                assert!(!layout.is_unsized());\n+                let ptr = ecx.memory.allocate(\n+                    layout.size.bytes(),\n+                    layout.align,\n+                    None,\n+                )?;\n+                if tcx.is_static(cid.instance.def_id()).is_some() {\n+                    tcx.interpret_interner.cache(cid.instance.def_id(), ptr.alloc_id);\n+                }\n+                let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n+                let mutability = tcx.is_static(cid.instance.def_id());\n+                let mutability = if mutability == Some(hir::Mutability::MutMutable) || internally_mutable {\n+                    Mutability::Mutable\n+                } else {\n+                    Mutability::Immutable\n+                };\n+                let cleanup = StackPopCleanup::MarkStatic(mutability);\n+                let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n+                let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+                trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n+                assert!(mir.arg_count == 0);\n+                ecx.push_stack_frame(\n+                    cid.instance,\n+                    mir.span,\n+                    mir,\n+                    Place::from_ptr(ptr, layout.align),\n+                    cleanup,\n+                )?;\n+\n+                while ecx.step()? {}\n+                ptr.alloc_id\n+            }\n+        };\n+        let ptr = MemoryPointer::new(alloc, 0).into();\n+        let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n+            Some(val) => val,\n+            _ => Value::ByRef(ptr, layout.align),\n+        };\n+        Ok((value, ptr, layout.ty))\n+    })();\n+    (res, ecx)\n }\n \n pub struct CompileTimeEvaluator;\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     fn into(self) -> EvalError<'tcx> {\n-        EvalErrorKind::MachineError(Box::new(self)).into()\n+        EvalErrorKind::MachineError(self.to_string()).into()\n     }\n }\n \n@@ -154,7 +185,7 @@ impl fmt::Display for ConstEvalError {\n                     msg\n                 )\n             }\n-            NotConst(ref msg) => write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n+            NotConst(ref msg) => write!(f, \"{}\", msg),\n         }\n     }\n }\n@@ -173,33 +204,48 @@ impl Error for ConstEvalError {\n     }\n }\n \n-impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n+impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     type MemoryData = ();\n     type MemoryKinds = !;\n     fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Place, mir::BasicBlock)>,\n-        _args: &[ValTy<'tcx>],\n+        args: &[ValTy<'tcx>],\n         span: Span,\n-        _sig: ty::FnSig<'tcx>,\n+        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         if !ecx.tcx.is_const_fn(instance.def_id()) {\n-            return Err(\n-                ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n-            );\n+            let def_id = instance.def_id();\n+            let (op, oflo) = if let Some(op) = ecx.tcx.is_binop_lang_item(def_id) {\n+                op\n+            } else {\n+                return Err(\n+                    ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n+                );\n+            };\n+            let (dest, bb) = destination.expect(\"128 lowerings can't diverge\");\n+            let dest_ty = sig.output();\n+            if oflo {\n+                ecx.intrinsic_with_overflow(op, args[0], args[1], dest, dest_ty)?;\n+            } else {\n+                ecx.intrinsic_overflowing(op, args[0], args[1], dest, dest_ty)?;\n+            }\n+            ecx.goto_block(bb);\n+            return Ok(true);\n         }\n         let mir = match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n-            Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n-                // some simple things like `malloc` might get accepted in the future\n-                return Err(\n-                    ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n-                        .into(),\n-                );\n+            Err(err) => {\n+                if let EvalErrorKind::NoMirFor(ref path) = err.kind {\n+                    return Err(\n+                        ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n+                            .into(),\n+                    );\n+                }\n+                return Err(err);\n             }\n-            Err(other) => return Err(other),\n         };\n         let (return_place, return_to_block) = match destination {\n             Some((place, block)) => (place, StackPopCleanup::Goto(block)),\n@@ -219,7 +265,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n \n \n     fn call_intrinsic<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         _args: &[ValTy<'tcx>],\n         dest: Place,\n@@ -261,7 +307,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n     }\n \n     fn try_ptr_op<'a>(\n-        _ecx: &EvalContext<'a, 'tcx, Self>,\n+        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         left: PrimVal,\n         _left_ty: Ty<'tcx>,\n@@ -277,12 +323,29 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n         }\n     }\n \n-    fn mark_static_initialized(m: !) -> EvalResult<'tcx> {\n-        m\n+    fn mark_static_initialized<'a>(\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        _id: AllocId,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx, bool> {\n+        Ok(false)\n+    }\n+\n+    fn init_static<'a>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        cid: GlobalId<'tcx>,\n+    ) -> EvalResult<'tcx, AllocId> {\n+        // ensure the static is computed\n+        ecx.const_eval(cid)?;\n+        Ok(ecx\n+            .tcx\n+            .interpret_interner\n+            .get_cached(cid.instance.def_id())\n+            .expect(\"uncached static\"))\n     }\n \n     fn box_alloc<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _ty: Ty<'tcx>,\n         _dest: Place,\n     ) -> EvalResult<'tcx> {\n@@ -292,7 +355,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n     }\n \n     fn global_item_with_linkage<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n@@ -302,275 +365,147 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n     }\n }\n \n+pub fn const_val_field<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    variant: Option<usize>,\n+    field: mir::Field,\n+    value: Value,\n+    ty: Ty<'tcx>,\n+) -> ::rustc::middle::const_val::EvalResult<'tcx> {\n+    trace!(\"const_val_field: {:?}, {:?}, {:?}, {:?}\", instance, field, value, ty);\n+    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let result = (|| {\n+        let (mut field, ty) = match value {\n+            Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, variant, field, ty)?.expect(\"const_val_field on non-field\"),\n+            Value::ByRef(ptr, align) => {\n+                let place = Place::Ptr {\n+                    ptr,\n+                    align,\n+                    extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n+                };\n+                let layout = ecx.layout_of(ty)?;\n+                let (place, layout) = ecx.place_field(place, field, layout)?;\n+                let (ptr, align) = place.to_ptr_align();\n+                (Value::ByRef(ptr, align), layout.ty)\n+            }\n+        };\n+        if let Value::ByRef(ptr, align) = field {\n+            if let Some(val) = ecx.try_read_value(ptr, align, ty)? {\n+                field = val;\n+            }\n+        }\n+        Ok((field, ty))\n+    })();\n+    match result {\n+        Ok((field, ty)) => Ok(tcx.mk_const(ty::Const {\n+            val: ConstVal::Value(field),\n+            ty,\n+        })),\n+        Err(err) => {\n+            let (trace, span) = ecx.generate_stacktrace(None);\n+            let err = ErrKind::Miri(err, trace);\n+            Err(ConstEvalErr {\n+                kind: err.into(),\n+                span,\n+            })\n+        },\n+    }\n+}\n+\n+pub fn const_discr<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    value: Value,\n+    ty: Ty<'tcx>,\n+) -> EvalResult<'tcx, u128> {\n+    trace!(\"const_discr: {:?}, {:?}, {:?}\", instance, value, ty);\n+    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let (ptr, align) = match value {\n+        Value::ByValPair(..) | Value::ByVal(_) => {\n+            let layout = ecx.layout_of(ty)?;\n+            use super::MemoryKind;\n+            let ptr = ecx.memory.allocate(layout.size.bytes(), layout.align, Some(MemoryKind::Stack))?;\n+            let ptr: Pointer = ptr.into();\n+            ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n+            (ptr, layout.align)\n+        },\n+        Value::ByRef(ptr, align) => (ptr, align),\n+    };\n+    let place = Place::from_primval_ptr(ptr, align);\n+    ecx.read_discriminant_value(place, ty)\n+}\n+\n pub fn const_eval_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>,\n+    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::middle::const_val::EvalResult<'tcx> {\n     trace!(\"const eval: {:?}\", key);\n-    let (def_id, substs) = if let Some(resolved) = lookup_const_by_id(tcx, key) {\n-        resolved\n-    } else {\n-        return Err(ConstEvalErr {\n-            span: tcx.def_span(key.value.0),\n-            kind: TypeckError\n-        });\n-    };\n+    let cid = key.value;\n+    let def_id = cid.instance.def.def_id();\n+\n+    if tcx.is_foreign_item(def_id) {\n+        let id = tcx.interpret_interner.get_cached(def_id);\n+        let id = match id {\n+            // FIXME: due to caches this shouldn't happen, add some assertions\n+            Some(id) => id,\n+            None => {\n+                let id = tcx.interpret_interner.reserve();\n+                tcx.interpret_interner.cache(def_id, id);\n+                id\n+            },\n+        };\n+        let ty = tcx.type_of(def_id);\n+        let layout = tcx.layout_of(key.param_env.and(ty)).unwrap();\n+        let ptr = MemoryPointer::new(id, 0);\n+        return Ok(tcx.mk_const(ty::Const {\n+            val: ConstVal::Value(Value::ByRef(ptr.into(), layout.align)),\n+            ty,\n+        }))\n+    }\n \n-    let tables = tcx.typeck_tables_of(def_id);\n-    let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-        let body_id = tcx.hir.body_owned_by(id);\n+    if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+        let tables = tcx.typeck_tables_of(def_id);\n+        let span = tcx.def_span(def_id);\n \n         // Do match-check before building MIR\n         if tcx.check_match(def_id).is_err() {\n             return Err(ConstEvalErr {\n-                span: tcx.def_span(key.value.0),\n-                kind: CheckMatchError,\n+                kind: Rc::new(CheckMatchError),\n+                span,\n             });\n         }\n \n-        tcx.mir_const_qualif(def_id);\n-        tcx.hir.body(body_id)\n-    } else {\n-        tcx.extern_const_body(def_id).body\n-    };\n-\n-    // do not continue into miri if typeck errors occurred\n-    // it will fail horribly\n-    if tables.tainted_by_errors {\n-        return Err(ConstEvalErr { span: body.value.span, kind: TypeckError })\n-    }\n-\n-    trace!(\"running old const eval\");\n-    let old_result = ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value);\n-    trace!(\"old const eval produced {:?}\", old_result);\n-    if tcx.sess.opts.debugging_opts.miri {\n-        let instance = ty::Instance::new(def_id, substs);\n-        trace!(\"const eval instance: {:?}, {:?}\", instance, key.param_env);\n-        let miri_result = ::interpret::eval_body(tcx, instance, key.param_env);\n-        match (miri_result, old_result) {\n-            (Err(err), Ok(ok)) => {\n-                trace!(\"miri failed, ctfe returned {:?}\", ok);\n-                tcx.sess.span_warn(\n-                    tcx.def_span(key.value.0),\n-                    \"miri failed to eval, while ctfe succeeded\",\n-                );\n-                let ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                let () = unwrap_miri(&ecx, Err(err));\n-                Ok(ok)\n-            },\n-            (_, Err(err)) => Err(err),\n-            (Ok((miri_val, miri_ty)), Ok(ctfe)) => {\n-                let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                let layout = ecx.layout_of(miri_ty).unwrap();\n-                let miri_place = Place::from_primval_ptr(miri_val, layout.align);\n-                check_ctfe_against_miri(&mut ecx, miri_place, miri_ty, ctfe.val);\n-                Ok(ctfe)\n-            }\n+        if let hir::BodyOwnerKind::Const = tcx.hir.body_owner_kind(id) {\n+            tcx.mir_const_qualif(def_id);\n         }\n-    } else {\n-        old_result\n-    }\n-}\n \n-fn check_ctfe_against_miri<'a, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    miri_place: Place,\n-    miri_ty: Ty<'tcx>,\n-    ctfe: ConstVal<'tcx>,\n-) {\n-    use rustc::middle::const_val::ConstAggregate::*;\n-    use rustc_const_math::ConstFloat;\n-    use rustc::ty::TypeVariants::*;\n-    let miri_val = ValTy {\n-        value: ecx.read_place(miri_place).unwrap(),\n-        ty: miri_ty\n+        // Do not continue into miri if typeck errors occurred; it will fail horribly\n+        if tables.tainted_by_errors {\n+            return Err(ConstEvalErr {\n+                kind: Rc::new(TypeckError),\n+                span,\n+            });\n+        }\n     };\n-    match miri_ty.sty {\n-        TyInt(int_ty) => {\n-            let prim = get_prim(ecx, miri_val);\n-            let c = ConstInt::new_signed_truncating(prim as i128,\n-                                                    int_ty,\n-                                                    ecx.tcx.sess.target.isize_ty);\n-            let c = ConstVal::Integral(c);\n-            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n-        },\n-        TyUint(uint_ty) => {\n-            let prim = get_prim(ecx, miri_val);\n-            let c = ConstInt::new_unsigned_truncating(prim,\n-                                                     uint_ty,\n-                                                     ecx.tcx.sess.target.usize_ty);\n-            let c = ConstVal::Integral(c);\n-            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n-        },\n-        TyFloat(ty) => {\n-            let prim = get_prim(ecx, miri_val);\n-            let f = ConstVal::Float(ConstFloat { bits: prim, ty });\n-            assert_eq!(f, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", f, ctfe);\n-        },\n-        TyBool => {\n-            let bits = get_prim(ecx, miri_val);\n-            if bits > 1 {\n-                bug!(\"miri evaluated to {}, but expected a bool {:?}\", bits, ctfe);\n-            }\n-            let b = ConstVal::Bool(bits == 1);\n-            assert_eq!(b, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", b, ctfe);\n-        },\n-        TyChar => {\n-            let bits = get_prim(ecx, miri_val);\n-            if let Some(cm) = ::std::char::from_u32(bits as u32) {\n-                assert_eq!(\n-                    ConstVal::Char(cm), ctfe,\n-                    \"miri evaluated to {:?}, but expected {:?}\", cm, ctfe,\n-                );\n-            } else {\n-                bug!(\"miri evaluated to {}, but expected a char {:?}\", bits, ctfe);\n-            }\n-        },\n-        TyStr => {\n-            let value = ecx.follow_by_ref_value(miri_val.value, miri_val.ty);\n-            if let Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len))) = value {\n-                let bytes = ecx\n-                    .memory\n-                    .read_bytes(ptr.into(), len as u64)\n-                    .expect(\"bad miri memory for str\");\n-                if let Ok(s) = ::std::str::from_utf8(bytes) {\n-                    if let ConstVal::Str(s2) = ctfe {\n-                        assert_eq!(s, s2, \"miri produced {:?}, but expected {:?}\", s, s2);\n-                    } else {\n-                        bug!(\"miri produced {:?}, but expected {:?}\", s, ctfe);\n-                    }\n-                } else {\n-                    bug!(\n-                        \"miri failed to produce valid utf8 {:?}, while ctfe produced {:?}\",\n-                        bytes,\n-                        ctfe,\n-                    );\n-                }\n-            } else {\n-                bug!(\"miri evaluated to {:?}, but expected a str {:?}\", value, ctfe);\n-            }\n-        },\n-        TyArray(elem_ty, n) => {\n-            let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-            let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n-                ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n-                    (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)\n-                }).collect(),\n-                ConstVal::Aggregate(Array(v)) => {\n-                    v.iter().map(|c| (c.val, c.ty)).collect()\n-                },\n-                ConstVal::Aggregate(Repeat(v, n)) => {\n-                    vec![(v.val, v.ty); n as usize]\n-                },\n-                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for (i, elem) in vec.into_iter().enumerate() {\n-                assert!((i as u64) < n);\n-                let (field_place, _) =\n-                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n-                check_ctfe_against_miri(ecx, field_place, elem_ty, elem.0);\n-            }\n-        },\n-        TyTuple(..) => {\n-            let vec = match ctfe {\n-                ConstVal::Aggregate(Tuple(v)) => v,\n-                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for (i, elem) in vec.into_iter().enumerate() {\n-                let (field_place, _) =\n-                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n-                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n-            }\n-        },\n-        TyAdt(def, _) => {\n-            let mut miri_place = miri_place;\n-            let struct_variant = if def.is_enum() {\n-                let discr = ecx.read_discriminant_value(miri_place, miri_ty).unwrap();\n-                let variant = def.discriminants(ecx.tcx).position(|variant_discr| {\n-                    variant_discr.to_u128_unchecked() == discr\n-                }).expect(\"miri produced invalid enum discriminant\");\n-                miri_place = ecx.place_downcast(miri_place, variant).unwrap();\n-                &def.variants[variant]\n-            } else {\n-                def.non_enum_variant()\n-            };\n-            let vec = match ctfe {\n-                ConstVal::Aggregate(Struct(v)) => v,\n-                ConstVal::Variant(did) => {\n-                    assert_eq!(struct_variant.fields.len(), 0);\n-                    assert_eq!(did, struct_variant.did);\n-                    return;\n-                },\n-                ctfe => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for &(name, elem) in vec.into_iter() {\n-                let field = struct_variant.fields.iter().position(|f| f.name == name).unwrap();\n-                let (field_place, _) =\n-                    ecx.place_field(miri_place, Field::new(field), layout).unwrap();\n-                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n-            }\n-        },\n-        TySlice(_) => bug!(\"miri produced a slice?\"),\n-        // not supported by ctfe\n-        TyRawPtr(_) |\n-        TyRef(..) => {}\n-        TyDynamic(..) => bug!(\"miri produced a trait object\"),\n-        TyClosure(..) => bug!(\"miri produced a closure\"),\n-        TyGenerator(..) => bug!(\"miri produced a generator\"),\n-        TyGeneratorWitness(..) => bug!(\"miri produced a generator witness\"),\n-        TyNever => bug!(\"miri produced a value of the never type\"),\n-        TyProjection(_) => bug!(\"miri produced a projection\"),\n-        TyAnon(..) => bug!(\"miri produced an impl Trait type\"),\n-        TyParam(_) => bug!(\"miri produced an unmonomorphized type\"),\n-        TyInfer(_) => bug!(\"miri produced an uninferred type\"),\n-        TyError => bug!(\"miri produced a type error\"),\n-        TyForeign(_) => bug!(\"miri produced an extern type\"),\n-        // should be fine\n-        TyFnDef(..) => {}\n-        TyFnPtr(_) => {\n-            let value = ecx.value_to_primval(miri_val);\n-            let ptr = match value {\n-                Ok(PrimVal::Ptr(ptr)) => ptr,\n-                value => bug!(\"expected fn ptr, got {:?}\", value),\n-            };\n-            let inst = ecx.memory.get_fn(ptr).unwrap();\n-            match ctfe {\n-                ConstVal::Function(did, substs) => {\n-                    let ctfe = ty::Instance::resolve(\n-                        ecx.tcx,\n-                        ecx.param_env,\n-                        did,\n-                        substs,\n-                    ).unwrap();\n-                    assert_eq!(inst, ctfe, \"expected fn ptr {:?}, but got {:?}\", ctfe, inst);\n-                },\n-                _ => bug!(\"ctfe produced {:?}, but miri produced function {:?}\", ctfe, inst),\n-            }\n-        },\n-    }\n-}\n \n-fn get_prim<'a, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    val: ValTy<'tcx>,\n-) -> u128 {\n-    let res = ecx.value_to_primval(val).and_then(|prim| prim.to_bytes());\n-    unwrap_miri(ecx, res)\n-}\n-\n-fn unwrap_miri<'a, 'tcx, T>(\n-    ecx: &EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    res: Result<T, EvalError<'tcx>>,\n-) -> T {\n-    match res {\n-        Ok(val) => val,\n-        Err(mut err) => {\n-            ecx.report(&mut err);\n-            ecx.tcx.sess.abort_if_errors();\n-            bug!(\"{:#?}\", err);\n+    let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n+    res.map(|(miri_value, _, miri_ty)| {\n+        tcx.mk_const(ty::Const {\n+            val: ConstVal::Value(miri_value),\n+            ty: miri_ty,\n+        })\n+    }).map_err(|mut err| {\n+        if tcx.is_static(def_id).is_some() {\n+            ecx.report(&mut err, true, None);\n         }\n-    }\n+        let (trace, span) = ecx.generate_stacktrace(None);\n+        let err = ErrKind::Miri(err, trace);\n+        ConstEvalErr {\n+            kind: err.into(),\n+            span,\n+        }\n+    })\n }"}, {"sha": "13090ca53302b48ccc5d6ff4af0f9c8255d6a87b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 221, "deletions": 158, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -3,56 +3,57 @@ use std::fmt::Write;\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n-use rustc::middle::const_val::ConstVal;\n+use rustc::middle::const_val::{ConstVal, ErrKind};\n use rustc::mir;\n-use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::TyCtxtAt;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::{self, DUMMY_SP};\n+use rustc::middle::const_val::FrameInfo;\n+use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n     GlobalId, Value, Pointer, PrimVal, PrimValKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n };\n \n use super::{Place, PlaceExtra, Memory,\n-            HasMemory, MemoryKind, operator,\n+            HasMemory, MemoryKind,\n             Machine};\n \n-pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n+pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n     pub param_env: ty::ParamEnv<'tcx>,\n \n     /// The virtual memory system.\n-    pub memory: Memory<'a, 'tcx, M>,\n+    pub memory: Memory<'a, 'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'tcx>>,\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n \n     /// The maximum number of stack frames allowed\n     pub(crate) stack_limit: usize,\n \n-    /// The maximum number of operations that may be executed.\n+    /// The maximum number of terminators that may be evaluated.\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n-    pub(crate) steps_remaining: u64,\n+    pub(crate) steps_remaining: usize,\n }\n \n /// A stack frame.\n-pub struct Frame<'tcx> {\n+pub struct Frame<'mir, 'tcx: 'mir> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n     /// The MIR for the function called on this frame.\n-    pub mir: &'tcx mir::Mir<'tcx>,\n+    pub mir: &'mir mir::Mir<'tcx>,\n \n     /// The def_id and substs of the current function\n     pub instance: ty::Instance<'tcx>,\n@@ -102,23 +103,6 @@ pub enum StackPopCleanup {\n     None,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct ResourceLimits {\n-    pub memory_size: u64,\n-    pub step_limit: u64,\n-    pub stack_limit: usize,\n-}\n-\n-impl Default for ResourceLimits {\n-    fn default() -> Self {\n-        ResourceLimits {\n-            memory_size: 100 * 1024 * 1024, // 100 MB\n-            step_limit: 1_000_000,\n-            stack_limit: 100,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct TyAndPacked<'tcx> {\n     pub ty: Ty<'tcx>,\n@@ -131,44 +115,53 @@ pub struct ValTy<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+impl<'tcx> ValTy<'tcx> {\n+    pub fn from(val: &ty::Const<'tcx>) -> Option<Self> {\n+        match val.val {\n+            ConstVal::Value(value) => Some(ValTy { value, ty: val.ty }),\n+            ConstVal::Unevaluated { .. } => None,\n+        }\n+    }\n+}\n+\n impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n     type Target = Value;\n     fn deref(&self) -> &Value {\n         &self.value\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> HasDataLayout for &'a EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> HasDataLayout\n-    for &'c &'b mut EvalContext<'a, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n+        *self.tcx\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> layout::HasTyCtxt<'tcx>\n-    for &'c &'b mut EvalContext<'a, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n-        self.tcx\n+        *self.tcx\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>> for &'a EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf<Ty<'tcx>> for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n@@ -177,8 +170,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>> for &'a EvalContext<'a, 'tcx\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>>\n-    for &'c &'b mut EvalContext<'a, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf<Ty<'tcx>>\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n     #[inline]\n@@ -187,22 +180,21 @@ impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>>\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        limits: ResourceLimits,\n         machine: M,\n         memory_data: M::MemoryData,\n     ) -> Self {\n         EvalContext {\n             machine,\n             tcx,\n             param_env,\n-            memory: Memory::new(tcx, limits.memory_size, memory_data),\n+            memory: Memory::new(tcx, memory_data),\n             stack: Vec::new(),\n-            stack_limit: limits.stack_limit,\n-            steps_remaining: limits.step_limit,\n+            stack_limit: tcx.sess.const_eval_stack_frame_limit.get(),\n+            steps_remaining: tcx.sess.const_eval_step_limit.get(),\n         }\n     }\n \n@@ -214,15 +206,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.memory.allocate(size, layout.align, Some(MemoryKind::Stack))\n     }\n \n-    pub fn memory(&self) -> &Memory<'a, 'tcx, M> {\n+    pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n \n-    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n+    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         &mut self.memory\n     }\n \n-    pub fn stack(&self) -> &[Frame<'tcx>] {\n+    pub fn stack(&self) -> &[Frame<'mir, 'tcx>] {\n         &self.stack\n     }\n \n@@ -240,53 +232,34 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ))\n     }\n \n-    pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        use rustc::middle::const_val::ConstVal::*;\n-\n-        let primval = match *const_val {\n-            Integral(const_int) => PrimVal::Bytes(const_int.to_u128_unchecked()),\n-\n-            Float(val) => PrimVal::Bytes(val.bits),\n-\n-            Bool(b) => PrimVal::from_bool(b),\n-            Char(c) => PrimVal::from_char(c),\n-\n-            Str(ref s) => return self.str_to_value(s),\n-\n-            ByteStr(ref bs) => {\n-                let ptr = self.memory.allocate_cached(bs.data);\n-                PrimVal::Ptr(ptr)\n-            }\n-\n-            Unevaluated(def_id, substs) => {\n+    pub(super) fn const_to_value(&self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        match *const_val {\n+            ConstVal::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                return Ok(self.read_global_as_value(GlobalId {\n+                self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                }, self.layout_of(ty)?));\n+                }, ty)\n             }\n-\n-            Aggregate(..) |\n-            Variant(_) => bug!(\"should not have aggregate or variant constants in MIR\"),\n-            // function items are zero sized and thus have no readable value\n-            Function(..) => PrimVal::Undef,\n-        };\n-\n-        Ok(Value::ByVal(primval))\n+            ConstVal::Value(val) => Ok(val),\n+        }\n     }\n \n     pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n-        let substs = self.tcx.trans_apply_param_substs(self.substs(), &substs);\n+        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n+        trace!(\"substs: {:#?}\", self.substs());\n+        trace!(\"param_env: {:#?}\", self.param_env);\n+        let substs = self.tcx.trans_apply_param_substs_env(self.substs(), self.param_env, &substs);\n         ty::Instance::resolve(\n-            self.tcx,\n+            *self.tcx,\n             self.param_env,\n             def_id,\n             substs,\n         ).ok_or(EvalErrorKind::TypeckError.into()) // turn error prop into a panic to expose associated type in const issue\n     }\n \n     pub(super) fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env)\n+        ty.is_sized(self.tcx, self.param_env)\n     }\n \n     pub fn load_mir(\n@@ -313,7 +286,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // miri doesn't care about lifetimes, and will choke on some crazy ones\n         // let's simply get rid of them\n         let without_lifetimes = self.tcx.erase_regions(&ty);\n-        let substituted = without_lifetimes.subst(self.tcx, substs);\n+        let substituted = without_lifetimes.subst(*self.tcx, substs);\n         let substituted = self.tcx.fully_normalize_monormophic_ty(&substituted);\n         substituted\n     }\n@@ -402,14 +375,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         span: codemap::Span,\n-        mir: &'tcx mir::Mir<'tcx>,\n+        mir: &'mir mir::Mir<'tcx>,\n         return_place: Place,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n         /// Return the set of locals that have a storage annotation anywhere\n-        fn collect_storage_annotations<'tcx>(mir: &'tcx mir::Mir<'tcx>) -> HashSet<mir::Local> {\n+        fn collect_storage_annotations<'mir, 'tcx>(mir: &'mir mir::Mir<'tcx>) -> HashSet<mir::Local> {\n             use rustc::mir::StatementKind::*;\n \n             let mut set = HashSet::new();\n@@ -477,7 +450,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             StackPopCleanup::MarkStatic(mutable) => {\n                 if let Place::Ptr { ptr, .. } = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    self.memory.mark_static_initalized(\n+                    self.memory.mark_static_initialized(\n                         ptr.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n@@ -563,16 +536,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             UnaryOp(un_op, ref operand) => {\n                 let val = self.eval_operand_to_primval(operand)?;\n-                let kind = self.ty_to_primval_kind(dest_ty)?;\n+                let val = self.unary_op(un_op, val, dest_ty)?;\n                 self.write_primval(\n                     dest,\n-                    operator::unary_op(un_op, val, kind)?,\n+                    val,\n                     dest_ty,\n                 )?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n-                self.inc_step_counter_and_check_limit(operands.len() as u64)?;\n+                self.inc_step_counter_and_check_limit(operands.len())?;\n \n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n@@ -600,7 +573,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             Repeat(ref operand, _) => {\n                 let (elem_ty, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (elem_ty, n.val.to_const_int().unwrap().to_u64().unwrap()),\n+                    ty::TyArray(elem_ty, n) => (elem_ty, n.val.unwrap_u64()),\n                     _ => {\n                         bug!(\n                             \"tried to assign array-repeat to non-array type {:?}\",\n@@ -720,8 +693,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                     bug!(\"reifying a fn ptr that requires \\\n                                           const arguments\");\n                                 }\n-                                let instance = self.resolve(def_id, substs)?;\n-                                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                                let instance: EvalResult<'tcx, _> = ty::Instance::resolve(\n+                                    *self.tcx,\n+                                    self.param_env,\n+                                    def_id,\n+                                    substs,\n+                                ).ok_or(EvalErrorKind::TypeckError.into());\n+                                let fn_ptr = self.memory.create_fn_alloc(instance?);\n                                 let valty = ValTy {\n                                     value: Value::ByVal(PrimVal::Ptr(fn_ptr)),\n                                     ty: dest_ty,\n@@ -748,7 +726,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             ty::TyClosure(def_id, substs) => {\n                                 let substs = self.tcx.trans_apply_param_substs(self.substs(), &substs);\n                                 let instance = ty::Instance::resolve_closure(\n-                                    self.tcx,\n+                                    *self.tcx,\n                                     def_id,\n                                     substs,\n                                     ty::ClosureKind::FnOnce,\n@@ -771,9 +749,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    trace!(\"Read discriminant {}, valid discriminants {:?}\", discr_val, adt_def.discriminants(self.tcx).collect::<Vec<_>>());\n-                    if adt_def.discriminants(self.tcx).all(|v| {\n-                        discr_val != v.to_u128_unchecked()\n+                    trace!(\"Read discriminant {}, valid discriminants {:?}\", discr_val, adt_def.discriminants(*self.tcx).collect::<Vec<_>>());\n+                    if adt_def.discriminants(*self.tcx).all(|v| {\n+                        discr_val != v.val\n                     })\n                     {\n                         return err!(InvalidDiscriminant);\n@@ -820,7 +798,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n         use rustc::mir::Operand::*;\n-        let ty = self.monomorphize(op.ty(self.mir(), self.tcx), self.substs());\n+        let ty = self.monomorphize(op.ty(self.mir(), *self.tcx), self.substs());\n         match *op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n             Copy(ref place) |\n@@ -841,7 +819,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         self.read_global_as_value(GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n-                        }, self.layout_of(ty)?)\n+                        }, ty)?\n                     }\n                 };\n \n@@ -928,8 +906,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             layout::Variants::Tagged { .. } => {\n                 let discr_val = dest_ty.ty_adt_def().unwrap()\n-                    .discriminant_for_variant(self.tcx, variant_index)\n-                    .to_u128_unchecked();\n+                    .discriminant_for_variant(*self.tcx, variant_index)\n+                    .val;\n \n                 let (discr_dest, discr) = self.place_field(dest, mir::Field::new(0), layout)?;\n                 self.write_primval(discr_dest, PrimVal::Bytes(discr_val), discr.ty)?;\n@@ -953,9 +931,38 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_global_as_value(&self, gid: GlobalId, layout: TyLayout) -> Value {\n-        let alloc = self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\");\n-        Value::ByRef(MemoryPointer::new(alloc, 0).into(), layout.align)\n+    pub fn read_global_as_value(&self, gid: GlobalId<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        if gid.promoted.is_none() {\n+            let cached = self\n+                .tcx\n+                .interpret_interner\n+                .get_cached(gid.instance.def_id());\n+            if let Some(alloc_id) = cached {\n+                let layout = self.layout_of(ty)?;\n+                let ptr = MemoryPointer::new(alloc_id, 0);\n+                return Ok(Value::ByRef(ptr.into(), layout.align))\n+            }\n+        }\n+        let cv = self.const_eval(gid)?;\n+        self.const_to_value(&cv.val, ty)\n+    }\n+\n+    pub fn const_eval(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        let param_env = if self.tcx.is_static(gid.instance.def_id()).is_some() {\n+            use rustc::traits;\n+            ty::ParamEnv::empty(traits::Reveal::All)\n+        } else {\n+            self.param_env\n+        };\n+        self.tcx.const_eval(param_env.and(gid)).map_err(|err| match *err.kind {\n+            ErrKind::Miri(ref err, _) => match err.kind {\n+                EvalErrorKind::TypeckError |\n+                EvalErrorKind::Layout(_) => EvalErrorKind::TypeckError.into(),\n+                _ => EvalErrorKind::ReferencedConstant.into(),\n+            },\n+            ErrKind::TypeckError => EvalErrorKind::TypeckError.into(),\n+            ref other => bug!(\"const eval returned {:?}\", other),\n+        })\n     }\n \n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n@@ -1121,20 +1128,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         dest_align: Align,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"write_value_to_ptr: {:#?}\", value);\n         let layout = self.layout_of(dest_ty)?;\n+        trace!(\"write_value_to_ptr: {:#?}, {}, {:#?}\", value, dest_ty, layout);\n         match value {\n             Value::ByRef(ptr, align) => {\n                 self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size.bytes(), false)\n             }\n             Value::ByVal(primval) => {\n-                match layout.abi {\n-                    layout::Abi::Scalar(_) => {}\n-                    _ if primval.is_undef() => {}\n+                let signed = match layout.abi {\n+                    layout::Abi::Scalar(ref scal) => match scal.value {\n+                        layout::Primitive::Int(_, signed) => signed,\n+                        _ => false,\n+                    },\n+                    _ if primval.is_undef() => false,\n                     _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout)\n-                }\n-                // TODO: Do we need signedness?\n-                self.memory.write_primval(dest.to_ptr()?, dest_align, primval, layout.size.bytes(), false)\n+                };\n+                self.memory.write_primval(dest.to_ptr()?, dest_align, primval, layout.size.bytes(), signed)\n             }\n             Value::ByValPair(a_val, b_val) => {\n                 let ptr = dest.to_ptr()?;\n@@ -1247,19 +1256,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         let ptr_size = self.memory.pointer_size();\n-        let p: Pointer = self.memory.read_ptr_sized_unsigned(ptr, ptr_align)?.into();\n+        let p: Pointer = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(ptr_size, self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory.read_ptr_sized_unsigned(extra, ptr_align)?.to_ptr()?,\n+                    self.memory.read_ptr_sized(extra, ptr_align)?.to_ptr()?,\n                 )),\n-                ty::TySlice(..) | ty::TyStr => Ok(\n-                    p.to_value_with_len(self.memory.read_ptr_sized_unsigned(extra, ptr_align)?.to_bytes()? as u64),\n-                ),\n+                ty::TySlice(..) | ty::TyStr => {\n+                    let len = self\n+                        .memory\n+                        .read_ptr_sized(extra, ptr_align)?\n+                        .to_bytes()?;\n+                    Ok(p.to_value_with_len(len as u64))\n+                },\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             }\n         }\n@@ -1271,7 +1284,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let ptr = ptr.to_ptr()?;\n         let val = match ty.sty {\n             ty::TyBool => {\n-                let val = self.memory.read_primval(ptr, ptr_align, 1, false)?;\n+                let val = self.memory.read_primval(ptr, ptr_align, 1)?;\n                 let val = match val {\n                     PrimVal::Bytes(0) => false,\n                     PrimVal::Bytes(1) => true,\n@@ -1281,7 +1294,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 PrimVal::from_bool(val)\n             }\n             ty::TyChar => {\n-                let c = self.memory.read_primval(ptr, ptr_align, 4, false)?.to_bytes()? as u32;\n+                let c = self.memory.read_primval(ptr, ptr_align, 4)?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1298,7 +1311,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     I128 => 16,\n                     Isize => self.memory.pointer_size(),\n                 };\n-                self.memory.read_primval(ptr, ptr_align, size, true)?\n+                self.memory.read_primval(ptr, ptr_align, size)?\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1311,17 +1324,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     U128 => 16,\n                     Usize => self.memory.pointer_size(),\n                 };\n-                self.memory.read_primval(ptr, ptr_align, size, false)?\n+                self.memory.read_primval(ptr, ptr_align, size)?\n             }\n \n             ty::TyFloat(FloatTy::F32) => {\n-                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 4, false)?.to_bytes()?)\n+                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 4)?.to_bytes()?)\n             }\n             ty::TyFloat(FloatTy::F64) => {\n-                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 8, false)?.to_bytes()?)\n+                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 8)?.to_bytes()?)\n             }\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr, ptr_align)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr_sized(ptr, ptr_align)?,\n             ty::TyRef(_, ref tam) |\n             ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, ptr_align, tam.ty).map(Some),\n \n@@ -1331,12 +1344,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 }\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n-                    let mut signed = false;\n-                    if let layout::Int(_, s) = scalar.value {\n-                        signed = s;\n-                    }\n                     let size = scalar.value.size(self).bytes();\n-                    self.memory.read_primval(ptr, ptr_align, size, signed)?\n+                    self.memory.read_primval(ptr, ptr_align, size)?\n                 } else {\n                     return Ok(None);\n                 }\n@@ -1348,15 +1357,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(Some(Value::ByVal(val)))\n     }\n \n-    pub fn frame(&self) -> &Frame<'tcx> {\n+    pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n-    pub fn frame_mut(&mut self) -> &mut Frame<'tcx> {\n+    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n-    pub(super) fn mir(&self) -> &'tcx mir::Mir<'tcx> {\n+    pub(super) fn mir(&self) -> &'mir mir::Mir<'tcx> {\n         self.frame().mir\n     }\n \n@@ -1385,7 +1394,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ptr = self.into_ptr(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let valty = ValTy {\n-                    value: ptr.to_value_with_len(length.val.to_const_int().unwrap().to_u64().unwrap() ),\n+                    value: ptr.to_value_with_len(length.val.unwrap_u64() ),\n                     ty: dest_ty,\n                 };\n                 self.write_value(valty, dest)\n@@ -1402,7 +1411,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             (_, &ty::TyDynamic(ref data, _)) => {\n                 let trait_ref = data.principal().unwrap().with_self_ty(\n-                    self.tcx,\n+                    *self.tcx,\n                     src_pointee_ty,\n                 );\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n@@ -1504,11 +1513,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 write!(msg, \":\").unwrap();\n \n                 match self.stack[frame].get_local(local) {\n-                    Err(EvalError { kind: EvalErrorKind::DeadLocal, .. }) => {\n-                        write!(msg, \" is dead\").unwrap();\n-                    }\n                     Err(err) => {\n-                        panic!(\"Failed to access local: {:?}\", err);\n+                        if let EvalErrorKind::DeadLocal = err.kind {\n+                            write!(msg, \" is dead\").unwrap();\n+                        } else {\n+                            panic!(\"Failed to access local: {:?}\", err);\n+                        }\n                     }\n                     Ok(Value::ByRef(ptr, align)) => {\n                         match ptr.into_inner_primval() {\n@@ -1566,7 +1576,40 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn report(&self, e: &mut EvalError) {\n+    pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> (Vec<FrameInfo>, Span) {\n+        let mut last_span = None;\n+        let mut frames = Vec::new();\n+        // skip 1 because the last frame is just the environment of the constant\n+        for &Frame { instance, span, .. } in self.stack().iter().skip(1).rev() {\n+            // make sure we don't emit frames that are duplicates of the previous\n+            if explicit_span == Some(span) {\n+                last_span = Some(span);\n+                continue;\n+            }\n+            if let Some(last) = last_span {\n+                if last == span {\n+                    continue;\n+                }\n+            } else {\n+                last_span = Some(span);\n+            }\n+            let location = if self.tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+                \"closure\".to_owned()\n+            } else {\n+                instance.to_string()\n+            };\n+            frames.push(FrameInfo { span, location });\n+        }\n+        trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n+        (frames, self.tcx.span)\n+    }\n+\n+    pub fn report(&self, e: &mut EvalError, as_err: bool, explicit_span: Option<Span>) {\n+        match e.kind {\n+            EvalErrorKind::Layout(_) |\n+            EvalErrorKind::TypeckError => return,\n+            _ => {},\n+        }\n         if let Some(ref mut backtrace) = e.backtrace {\n             let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n             backtrace.resolve();\n@@ -1599,29 +1642,60 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n         if let Some(frame) = self.stack().last() {\n             let block = &frame.mir.basic_blocks()[frame.block];\n-            let span = if frame.stmt < block.statements.len() {\n+            let span = explicit_span.unwrap_or_else(|| if frame.stmt < block.statements.len() {\n                 block.statements[frame.stmt].source_info.span\n             } else {\n                 block.terminator().source_info.span\n+            });\n+            trace!(\"reporting const eval failure at {:?}\", span);\n+            let mut err = if as_err {\n+                ::rustc::middle::const_val::struct_error(*self.tcx, span, \"constant evaluation error\")\n+            } else {\n+                let node_id = self\n+                    .stack()\n+                    .iter()\n+                    .rev()\n+                    .filter_map(|frame| self.tcx.hir.as_local_node_id(frame.instance.def_id()))\n+                    .next()\n+                    .expect(\"some part of a failing const eval must be local\");\n+                self.tcx.struct_span_lint_node(\n+                    ::rustc::lint::builtin::CONST_ERR,\n+                    node_id,\n+                    span,\n+                    \"constant evaluation error\",\n+                )\n             };\n-            let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n-            for &Frame { instance, span, .. } in self.stack().iter().rev() {\n-                if self.tcx.def_key(instance.def_id()).disambiguated_data.data ==\n-                    DefPathData::ClosureExpr\n-                {\n-                    err.span_note(span, \"inside call to closure\");\n-                    continue;\n-                }\n-                err.span_note(span, &format!(\"inside call to {}\", instance));\n+            let (frames, span) = self.generate_stacktrace(explicit_span);\n+            err.span_label(span, e.to_string());\n+            for FrameInfo { span, location } in frames {\n+                err.span_note(span, &format!(\"inside call to `{}`\", location));\n             }\n             err.emit();\n         } else {\n             self.tcx.sess.err(&e.to_string());\n         }\n     }\n+\n+    pub fn sign_extend(&self, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+        let layout = self.layout_of(ty)?;\n+        let size = layout.size.bits();\n+        assert!(layout.abi.is_signed());\n+        // sign extend\n+        let amt = 128 - size;\n+        // shift the unsigned value to the left\n+        // and back to the right as signed (essentially fills with FF on the left)\n+        Ok((((value << amt) as i128) >> amt) as u128)\n+    }\n+\n+    pub fn truncate(&self, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+        let size = self.layout_of(ty)?.size.bits();\n+        let amt = 128 - size;\n+        // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+        Ok((value << amt) >> amt)\n+    }\n }\n \n-impl<'tcx> Frame<'tcx> {\n+impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n     pub fn get_local(&self, local: mir::Local) -> EvalResult<'tcx, Value> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n         self.locals[local.index() - 1].ok_or(EvalErrorKind::DeadLocal.into())\n@@ -1655,14 +1729,3 @@ impl<'tcx> Frame<'tcx> {\n         return Ok(old);\n     }\n }\n-\n-// TODO(solson): Upstream these methods into rustc::ty::layout.\n-\n-pub fn resolve_drop_in_place<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ty: Ty<'tcx>,\n-) -> ty::Instance<'tcx> {\n-    let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n-    let substs = tcx.intern_substs(&[ty.into()]);\n-    ty::Instance::resolve(tcx, ty::ParamEnv::empty(Reveal::All), def_id, substs).unwrap()\n-}"}, {"sha": "5af0a053e9239e5b57aafa709f2c0803134fd0de", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -2,7 +2,7 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use rustc::mir::interpret::{AllocId, EvalResult, PrimVal, MemoryPointer, AccessKind};\n+use rustc::mir::interpret::{AllocId, EvalResult, PrimVal, MemoryPointer, AccessKind, GlobalId};\n use super::{EvalContext, Place, ValTy, Memory};\n \n use rustc::mir;\n@@ -12,7 +12,7 @@ use syntax::ast::Mutability;\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'tcx>: Sized {\n+pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n     type MemoryData;\n \n@@ -26,7 +26,7 @@ pub trait Machine<'tcx>: Sized {\n     ///\n     /// Returns Ok(false) if a new stack frame was pushed\n     fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n@@ -36,7 +36,7 @@ pub trait Machine<'tcx>: Sized {\n \n     /// directly process an intrinsic without pushing a stack frame.\n     fn call_intrinsic<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[ValTy<'tcx>],\n         dest: Place,\n@@ -51,7 +51,7 @@ pub trait Machine<'tcx>: Sized {\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn try_ptr_op<'a>(\n-        ecx: &EvalContext<'a, 'tcx, Self>,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: PrimVal,\n         left_ty: Ty<'tcx>,\n@@ -60,26 +60,37 @@ pub trait Machine<'tcx>: Sized {\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n \n     /// Called when trying to mark machine defined `MemoryKinds` as static\n-    fn mark_static_initialized(m: Self::MemoryKinds) -> EvalResult<'tcx>;\n+    fn mark_static_initialized<'a>(\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        _id: AllocId,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx, bool>;\n+\n+    /// Called when requiring a pointer to a static. Non const eval can\n+    /// create a mutable memory location for `static mut`\n+    fn init_static<'a>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        cid: GlobalId<'tcx>,\n+    ) -> EvalResult<'tcx, AllocId>;\n \n     /// Heap allocations via the `box` keyword\n     ///\n     /// Returns a pointer to the allocated memory\n     fn box_alloc<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         ty: Ty<'tcx>,\n         dest: Place,\n     ) -> EvalResult<'tcx>;\n \n     /// Called when trying to access a global declared with a `linkage` attribute\n     fn global_item_with_linkage<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx>;\n \n     fn check_locks<'a>(\n-        _mem: &Memory<'a, 'tcx, Self>,\n+        _mem: &Memory<'a, 'mir, 'tcx, Self>,\n         _ptr: MemoryPointer,\n         _size: u64,\n         _access: AccessKind,\n@@ -88,27 +99,27 @@ pub trait Machine<'tcx>: Sized {\n     }\n \n     fn add_lock<'a>(\n-        _mem: &mut Memory<'a, 'tcx, Self>,\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n         _id: AllocId,\n     ) {}\n \n     fn free_lock<'a>(\n-        _mem: &mut Memory<'a, 'tcx, Self>,\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n         _id: AllocId,\n         _len: u64,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n \n     fn end_region<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _reg: Option<::rustc::middle::region::Scope>,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n \n     fn validation_op<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,\n         _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n     ) -> EvalResult<'tcx> {"}, {"sha": "b369f80e849b0560404bfff09110d1846bbd9291", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 79, "deletions": 166, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,8 +1,9 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{ptr, mem, io};\n+use std::{ptr, io};\n \n-use rustc::ty::{Instance, TyCtxt};\n+use rustc::ty::Instance;\n+use rustc::ty::maps::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n@@ -19,8 +20,6 @@ use super::{EvalContext, Machine};\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n-    /// A mutable Static. All the others are interned in the tcx\n-    MutableStatic, // FIXME: move me into the machine, rustc const eval doesn't need them\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     Machine(T),\n }\n@@ -29,7 +28,7 @@ pub enum MemoryKind<T> {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n+pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n \n@@ -44,28 +43,20 @@ pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// Stores statics while they are being processed, before they are interned and thus frozen\n     uninitialized_statics: HashMap<AllocId, Allocation>,\n \n-    /// Number of virtual bytes allocated.\n-    memory_usage: u64,\n-\n-    /// Maximum number of virtual bytes that may be allocated.\n-    memory_size: u64,\n-\n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n \n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, max_memory: u64, data: M::MemoryData) -> Self {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+    pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n             alloc_kind: HashMap::new(),\n             alloc_map: HashMap::new(),\n             uninitialized_statics: HashMap::new(),\n             tcx,\n-            memory_size: max_memory,\n-            memory_usage: 0,\n             cur_frame: usize::max_value(),\n         }\n     }\n@@ -77,7 +68,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n-        let id = self.tcx.interpret_interner.borrow_mut().create_fn_alloc(instance);\n+        let id = self.tcx.interpret_interner.create_fn_alloc(instance);\n         MemoryPointer::new(id, 0)\n     }\n \n@@ -93,22 +84,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         align: Align,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n-        if self.memory_size - self.memory_usage < size {\n-            return err!(OutOfMemory {\n-                allocation_size: size,\n-                memory_size: self.memory_size,\n-                memory_usage: self.memory_usage,\n-            });\n-        }\n-        self.memory_usage += size;\n         assert_eq!(size as usize as u64, size);\n         let alloc = Allocation {\n             bytes: vec![0; size as usize],\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n+            runtime_mutability: Mutability::Immutable,\n         };\n-        let id = self.tcx.interpret_interner.borrow_mut().reserve();\n+        let id = self.tcx.interpret_interner.reserve();\n         M::add_lock(self, id);\n         match kind {\n             Some(kind @ MemoryKind::Stack) |\n@@ -119,7 +103,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             None => {\n                 self.uninitialized_statics.insert(id, alloc);\n             },\n-            Some(MemoryKind::MutableStatic) => bug!(\"don't allocate mutable statics directly\")\n         }\n         Ok(MemoryPointer::new(id, 0))\n     }\n@@ -164,10 +147,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn deallocate_local(&mut self, ptr: MemoryPointer) -> EvalResult<'tcx> {\n         match self.alloc_kind.get(&ptr.alloc_id).cloned() {\n-            // for a constant like `const FOO: &i32 = &1;` the local containing\n-            // the `1` is referred to by the global. We transitively marked everything\n-            // the global refers to as static itself, so we don't free it here\n-            Some(MemoryKind::MutableStatic) => Ok(()),\n             Some(MemoryKind::Stack) => self.deallocate(ptr, None, MemoryKind::Stack),\n             // Happens if the memory was interned into immutable memory\n             None => Ok(()),\n@@ -192,12 +171,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     \"uninitializedstatic\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.borrow().get_fn(ptr.alloc_id).is_some() {\n+            } else if self.tcx.interpret_interner.get_fn(ptr.alloc_id).is_some() {\n                 return err!(DeallocatedWrongMemoryKind(\n                     \"function\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.borrow().get_alloc(ptr.alloc_id).is_some() {\n+            } else if self.tcx.interpret_interner.get_alloc(ptr.alloc_id).is_some() {\n                 return err!(DeallocatedWrongMemoryKind(\n                     \"static\".to_string(),\n                     format!(\"{:?}\", kind),\n@@ -228,7 +207,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             }\n         }\n \n-        self.memory_usage -= alloc.bytes.len() as u64;\n         debug!(\"deallocated : {}\", ptr.alloc_id);\n \n         Ok(())\n@@ -292,7 +270,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         // normal alloc?\n         match self.alloc_map.get(&id) {\n@@ -301,11 +279,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             None => match self.uninitialized_statics.get(&id) {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n-                    let int = self.tcx.interpret_interner.borrow();\n                     // static alloc?\n-                    int.get_alloc(id)\n+                    self.tcx.interpret_interner.get_alloc(id)\n                         // no alloc? produce an error\n-                        .ok_or_else(|| if int.get_fn(id).is_some() {\n+                        .ok_or_else(|| if self.tcx.interpret_interner.get_fn(id).is_some() {\n                             EvalErrorKind::DerefFunctionPointer.into()\n                         } else {\n                             EvalErrorKind::DanglingPointerDeref.into()\n@@ -326,11 +303,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             None => match self.uninitialized_statics.get_mut(&id) {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n-                    let int = self.tcx.interpret_interner.borrow();\n                     // no alloc or immutable alloc? produce an error\n-                    if int.get_alloc(id).is_some() {\n+                    if self.tcx.interpret_interner.get_alloc(id).is_some() {\n                         err!(ModifiedConstantMemory)\n-                    } else if int.get_fn(id).is_some() {\n+                    } else if self.tcx.interpret_interner.get_fn(id).is_some() {\n                         err!(DerefFunctionPointer)\n                     } else {\n                         err!(DanglingPointerDeref)\n@@ -347,7 +323,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n         self.tcx\n             .interpret_interner\n-            .borrow()\n             .get_fn(ptr.alloc_id)\n             .ok_or(EvalErrorKind::ExecuteMemory.into())\n     }\n@@ -376,27 +351,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     Some(a) => (a, match self.alloc_kind[&id] {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n-                        MemoryKind::MutableStatic => \" (static mut)\".to_owned(),\n                     }),\n                     // uninitialized static alloc?\n                     None => match self.uninitialized_statics.get(&id) {\n                         Some(a) => (a, \" (static in the process of initialization)\".to_owned()),\n                         None => {\n-                            let int = self.tcx.interpret_interner.borrow();\n                             // static alloc?\n-                            match int.get_alloc(id) {\n+                            match self.tcx.interpret_interner.get_alloc(id) {\n                                 Some(a) => (a, \"(immutable)\".to_owned()),\n-                                None => if let Some(func) = int.get_fn(id) {\n+                                None => if let Some(func) = self.tcx.interpret_interner.get_fn(id) {\n                                     trace!(\"{} {}\", msg, func);\n-                    continue;\n+                                    continue;\n                                 } else {\n-                            trace!(\"{} (deallocated)\", msg);\n-                            continue;\n+                                    trace!(\"{} (deallocated)\", msg);\n+                                    continue;\n                                 },\n-                }\n+                            }\n                         },\n                     },\n-            };\n+                };\n \n             for i in 0..(alloc.bytes.len() as u64) {\n                 if let Some(&target_id) = alloc.relocations.get(&i) {\n@@ -441,14 +414,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn leak_report(&self) -> usize {\n         trace!(\"### LEAK REPORT ###\");\n-        let kinds = &self.alloc_kind;\n         let leaks: Vec<_> = self.alloc_map\n             .keys()\n-            .filter_map(|key| if kinds[key] != MemoryKind::MutableStatic {\n-                Some(*key)\n-            } else {\n-                None\n-            })\n+            .cloned()\n             .collect();\n         let n = leaks.len();\n         self.dump_allocs(leaks);\n@@ -457,7 +425,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Byte accessors\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_bytes_unchecked(\n         &self,\n         ptr: MemoryPointer,\n@@ -521,88 +489,55 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Reading and writing\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// mark an allocation pointed to by a static as static and initialized\n     fn mark_inner_allocation_initialized(\n         &mut self,\n         alloc: AllocId,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n         match self.alloc_kind.get(&alloc) {\n-            // do not go into immutable statics\n-            None |\n-            // or mutable statics\n-            Some(&MemoryKind::MutableStatic) => Ok(()),\n+            // do not go into statics\n+            None => Ok(()),\n             // just locals and machine allocs\n-            Some(_) => self.mark_static_initalized(alloc, mutability),\n+            Some(_) => self.mark_static_initialized(alloc, mutability),\n         }\n     }\n \n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initalized(\n+    pub fn mark_static_initialized(\n         &mut self,\n         alloc_id: AllocId,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n         trace!(\n-            \"mark_static_initalized {:?}, mutability: {:?}\",\n+            \"mark_static_initialized {:?}, mutability: {:?}\",\n             alloc_id,\n             mutability\n         );\n-        if mutability == Mutability::Immutable {\n-            let alloc = self.alloc_map.remove(&alloc_id);\n-            let kind = self.alloc_kind.remove(&alloc_id);\n-            assert_ne!(kind, Some(MemoryKind::MutableStatic));\n-            let uninit = self.uninitialized_statics.remove(&alloc_id);\n-            if let Some(alloc) = alloc.or(uninit) {\n-                let alloc = self.tcx.intern_const_alloc(alloc);\n-                self.tcx.interpret_interner.borrow_mut().intern_at_reserved(alloc_id, alloc);\n-                // recurse into inner allocations\n-                for &alloc in alloc.relocations.values() {\n-                    self.mark_inner_allocation_initialized(alloc, mutability)?;\n-                }\n-            }\n-            return Ok(());\n-        }\n-        // We are marking the static as initialized, so move it out of the uninit map\n-        if let Some(uninit) = self.uninitialized_statics.remove(&alloc_id) {\n-            self.alloc_map.insert(alloc_id, uninit);\n-        }\n-        // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n-        // sub-element or have circular pointers (e.g. `Rc`-cycles)\n-        let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(&mut Allocation {\n-                     ref mut relocations,\n-                     ..\n-                 }) => {\n-                match self.alloc_kind.get(&alloc_id) {\n-                    // const eval results can refer to \"locals\".\n-                    // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n-                    None |\n-                    Some(&MemoryKind::Stack) => {},\n-                    Some(&MemoryKind::Machine(m)) => M::mark_static_initialized(m)?,\n-                    Some(&MemoryKind::MutableStatic) => {\n-                        trace!(\"mark_static_initalized: skipping already initialized static referred to by static currently being initialized\");\n-                        return Ok(());\n-                    },\n-                }\n-                // overwrite or insert\n-                self.alloc_kind.insert(alloc_id, MemoryKind::MutableStatic);\n-                // take out the relocations vector to free the borrow on self, so we can call\n-                // mark recursively\n-                mem::replace(relocations, Default::default())\n+        // The machine handled it\n+        if M::mark_static_initialized(self, alloc_id, mutability)? {\n+            return Ok(())\n+        }\n+        let alloc = self.alloc_map.remove(&alloc_id);\n+        match self.alloc_kind.remove(&alloc_id) {\n+            None => {},\n+            Some(MemoryKind::Machine(_)) => bug!(\"machine didn't handle machine alloc\"),\n+            Some(MemoryKind::Stack) => {},\n+        }\n+        let uninit = self.uninitialized_statics.remove(&alloc_id);\n+        if let Some(mut alloc) = alloc.or(uninit) {\n+            // ensure llvm knows not to put this into immutable memroy\n+            alloc.runtime_mutability = mutability;\n+            let alloc = self.tcx.intern_const_alloc(alloc);\n+            self.tcx.interpret_interner.intern_at_reserved(alloc_id, alloc);\n+            // recurse into inner allocations\n+            for &alloc in alloc.relocations.values() {\n+                self.mark_inner_allocation_initialized(alloc, mutability)?;\n             }\n-            None => return err!(DanglingPointerDeref),\n-        };\n-        // recurse into inner allocations\n-        for &alloc in relocations.values() {\n-            self.mark_inner_allocation_initialized(alloc, mutability)?;\n+        } else {\n+            bug!(\"no allocation found for {:?}\", alloc_id);\n         }\n-        // put back the relocations\n-        self.alloc_map\n-            .get_mut(&alloc_id)\n-            .expect(\"checked above\")\n-            .relocations = relocations;\n         Ok(())\n     }\n \n@@ -720,7 +655,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n@@ -730,11 +665,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return Ok(PrimVal::Undef.into());\n         }\n         // Now we do the actual reading\n-        let bytes = if signed {\n-            read_target_int(endianness, bytes).unwrap() as u128\n-        } else {\n-            read_target_uint(endianness, bytes).unwrap()\n-        };\n+        let bytes = read_target_uint(endianness, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n             if self.relocations(ptr, size)?.count() != 0 {\n@@ -751,8 +682,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(PrimVal::Bytes(bytes))\n     }\n \n-    pub fn read_ptr_sized_unsigned(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, PrimVal> {\n-        self.read_primval(ptr, ptr_align, self.pointer_size(), false)\n+    pub fn read_ptr_sized(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, PrimVal> {\n+        self.read_primval(ptr, ptr_align, self.pointer_size())\n     }\n \n     pub fn write_primval(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n@@ -764,19 +695,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 val.offset as u128\n             }\n \n-            PrimVal::Bytes(bytes) => {\n-                // We need to mask here, or the byteorder crate can die when given a u64 larger\n-                // than fits in an integer of the requested size.\n-                let mask = match size {\n-                    1 => !0u8 as u128,\n-                    2 => !0u16 as u128,\n-                    4 => !0u32 as u128,\n-                    8 => !0u64 as u128,\n-                    16 => !0,\n-                    n => bug!(\"unexpected PrimVal::Bytes size: {}\", n),\n-                };\n-                bytes & mask\n-            }\n+            PrimVal::Bytes(bytes) => bytes,\n \n             PrimVal::Undef => {\n                 self.mark_definedness(PrimVal::Ptr(ptr).into(), size, false)?;\n@@ -829,7 +748,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Relocations\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn relocations(\n         &self,\n         ptr: MemoryPointer,\n@@ -883,7 +802,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Undefined bytes\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(\n         &mut self,\n@@ -944,7 +863,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n // Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn write_target_uint(\n+pub fn write_target_uint(\n     endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: u128,\n@@ -955,7 +874,8 @@ fn write_target_uint(\n         layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n     }\n }\n-fn write_target_int(\n+\n+pub fn write_target_int(\n     endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: i128,\n@@ -967,27 +887,20 @@ fn write_target_int(\n     }\n }\n \n-fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n+pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n     match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n \n-fn read_target_int(endianness: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n-    match endianness {\n-        layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n-        layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Unaligned accesses\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M>;\n-    fn memory(&self) -> &Memory<'a, 'tcx, M>;\n+pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M>;\n+    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M>;\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n@@ -997,7 +910,7 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     ) -> EvalResult<'tcx, Pointer> {\n         Ok(match value {\n             Value::ByRef(ptr, align) => {\n-                self.memory().read_ptr_sized_unsigned(ptr.to_ptr()?, align)?\n+                self.memory().read_ptr_sized(ptr.to_ptr()?, align)?\n             }\n             Value::ByVal(ptr) |\n             Value::ByValPair(ptr, _) => ptr,\n@@ -1011,8 +924,8 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n-                let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?, align)?.into();\n-                let vtable = mem.read_ptr_sized_unsigned(\n+                let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n+                let vtable = mem.read_ptr_sized(\n                     ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n                 )?.to_ptr()?;\n@@ -1033,8 +946,8 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n-                let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?, align)?.into();\n-                let len = mem.read_ptr_sized_unsigned(\n+                let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n+                let len = mem.read_ptr_sized(\n                     ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n                 )?.to_bytes()? as u64;\n@@ -1051,31 +964,31 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         self\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n+    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         self\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         &mut self.memory\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n+    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout"}, {"sha": "ae6337d82c3e3bd954be2be08b91ae57b6823e1d", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -11,13 +11,23 @@ mod step;\n mod terminator;\n mod traits;\n \n-pub use self::eval_context::{EvalContext, Frame, ResourceLimits, StackPopCleanup,\n+pub use self::eval_context::{EvalContext, Frame, StackPopCleanup,\n                              TyAndPacked, ValTy};\n \n pub use self::place::{Place, PlaceExtra};\n \n pub use self::memory::{Memory, MemoryKind, HasMemory};\n \n-pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider};\n+pub use self::const_eval::{\n+    eval_body_with_mir,\n+    mk_borrowck_eval_cx,\n+    eval_body,\n+    CompileTimeEvaluator,\n+    const_eval_provider,\n+    const_val_field,\n+    const_discr,\n+};\n \n pub use self::machine::Machine;\n+\n+pub use self::memory::{write_target_uint, write_target_int, read_target_uint};"}, {"sha": "dfc0c4a824a84293d1d63fd32a60840f356d4380", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 132, "deletions": 121, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,14 +1,15 @@\n use rustc::mir;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_math::ConstFloat;\n use syntax::ast::FloatTy;\n use std::cmp::Ordering;\n+use rustc::ty::layout::LayoutOf;\n \n use super::{EvalContext, Place, Machine, ValTy};\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, bytes_to_f32, bytes_to_f64};\n+use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n@@ -55,57 +56,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n }\n \n-macro_rules! overflow {\n-    ($op:ident, $l:expr, $r:expr) => ({\n-        let (val, overflowed) = $l.$op($r);\n-        let primval = PrimVal::Bytes(val as u128);\n-        Ok((primval, overflowed))\n-    })\n-}\n-\n-macro_rules! int_arithmetic {\n-    ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n-        let l = $l;\n-        let r = $r;\n-        use rustc::mir::interpret::PrimValKind::*;\n-        match $kind {\n-            I8  => overflow!($int_op, l as i8,  r as i8),\n-            I16 => overflow!($int_op, l as i16, r as i16),\n-            I32 => overflow!($int_op, l as i32, r as i32),\n-            I64 => overflow!($int_op, l as i64, r as i64),\n-            I128 => overflow!($int_op, l as i128, r as i128),\n-            U8  => overflow!($int_op, l as u8,  r as u8),\n-            U16 => overflow!($int_op, l as u16, r as u16),\n-            U32 => overflow!($int_op, l as u32, r as u32),\n-            U64 => overflow!($int_op, l as u64, r as u64),\n-            U128 => overflow!($int_op, l as u128, r as u128),\n-            _ => bug!(\"int_arithmetic should only be called on int primvals\"),\n-        }\n-    })\n-}\n-\n-macro_rules! int_shift {\n-    ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n-        let l = $l;\n-        let r = $r;\n-        let r_wrapped = r as u32;\n-        match $kind {\n-            I8  => overflow!($int_op, l as i8,  r_wrapped),\n-            I16 => overflow!($int_op, l as i16, r_wrapped),\n-            I32 => overflow!($int_op, l as i32, r_wrapped),\n-            I64 => overflow!($int_op, l as i64, r_wrapped),\n-            I128 => overflow!($int_op, l as i128, r_wrapped),\n-            U8  => overflow!($int_op, l as u8,  r_wrapped),\n-            U16 => overflow!($int_op, l as u16, r_wrapped),\n-            U32 => overflow!($int_op, l as u32, r_wrapped),\n-            U64 => overflow!($int_op, l as u64, r_wrapped),\n-            U128 => overflow!($int_op, l as u128, r_wrapped),\n-            _ => bug!(\"int_shift should only be called on int primvals\"),\n-        }.map(|(val, over)| (val, over || r != r_wrapped as u128))\n-    })\n-}\n-\n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n         &self,\n@@ -116,11 +67,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         right_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n-        use rustc::mir::interpret::PrimValKind::*;\n \n         let left_kind = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n-        //trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n         if !left_kind.is_float() && !right_kind.is_float() {\n@@ -133,13 +83,34 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let l = left.to_bytes()?;\n         let r = right.to_bytes()?;\n \n+        let left_layout = self.layout_of(left_ty)?;\n+\n         // These ops can have an RHS with a different numeric type.\n         if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n-            return match bin_op {\n-                Shl => int_shift!(left_kind, overflowing_shl, l, r),\n-                Shr => int_shift!(left_kind, overflowing_shr, l, r),\n-                _ => bug!(\"it has already been checked that this is a shift op\"),\n+            let signed = left_layout.abi.is_signed();\n+            let mut r = r as u32;\n+            let size = left_layout.size.bits() as u32;\n+            let oflo = r >= size;\n+            if oflo {\n+                r %= size;\n+            }\n+            let result = if signed {\n+                let l = self.sign_extend(l, left_ty)? as i128;\n+                let result = match bin_op {\n+                    Shl => l << r,\n+                    Shr => l >> r,\n+                    _ => bug!(\"it has already been checked that this is a shift op\"),\n+                };\n+                result as u128\n+            } else {\n+                match bin_op {\n+                    Shl => l << r,\n+                    Shr => l >> r,\n+                    _ => bug!(\"it has already been checked that this is a shift op\"),\n+                }\n             };\n+            let truncated = self.truncate(result, left_ty)?;\n+            return Ok((PrimVal::Bytes(truncated), oflo));\n         }\n \n         if left_kind != right_kind {\n@@ -179,89 +150,129 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n         };\n \n-        let val = match (bin_op, left_kind) {\n-            (_, F32) => float_op(bin_op, l, r, FloatTy::F32),\n-            (_, F64) => float_op(bin_op, l, r, FloatTy::F64),\n-\n-\n-            (Eq, _) => PrimVal::from_bool(l == r),\n-            (Ne, _) => PrimVal::from_bool(l != r),\n-\n-            (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n-            (Lt, _) => PrimVal::from_bool(l < r),\n-            (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n-            (Le, _) => PrimVal::from_bool(l <= r),\n-            (Gt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) > (r as i128)),\n-            (Gt, _) => PrimVal::from_bool(l > r),\n-            (Ge, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) >= (r as i128)),\n-            (Ge, _) => PrimVal::from_bool(l >= r),\n+        if left_layout.abi.is_signed() {\n+            let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n+                Lt => Some(i128::lt),\n+                Le => Some(i128::le),\n+                Gt => Some(i128::gt),\n+                Ge => Some(i128::ge),\n+                _ => None,\n+            };\n+            if let Some(op) = op {\n+                let l = self.sign_extend(l, left_ty)? as i128;\n+                let r = self.sign_extend(r, right_ty)? as i128;\n+                return Ok((PrimVal::from_bool(op(&l, &r)), false));\n+            }\n+            let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n+                Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                Div => Some(i128::overflowing_div),\n+                Rem => Some(i128::overflowing_rem),\n+                Add => Some(i128::overflowing_add),\n+                Sub => Some(i128::overflowing_sub),\n+                Mul => Some(i128::overflowing_mul),\n+                _ => None,\n+            };\n+            if let Some(op) = op {\n+                let l128 = self.sign_extend(l, left_ty)? as i128;\n+                let r = self.sign_extend(r, right_ty)? as i128;\n+                let size = left_layout.size.bits();\n+                match bin_op {\n+                    Rem | Div => {\n+                        // int_min / -1\n+                        if r == -1 && l == (1 << (size - 1)) {\n+                            return Ok((PrimVal::Bytes(l), true));\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+                trace!(\"{}, {}, {}\", l, l128, r);\n+                let (result, mut oflo) = op(l128, r);\n+                trace!(\"{}, {}\", result, oflo);\n+                if !oflo && size != 128 {\n+                    let max = 1 << (size - 1);\n+                    oflo = result >= max || result < -max;\n+                }\n+                let result = result as u128;\n+                let truncated = self.truncate(result, left_ty)?;\n+                return Ok((PrimVal::Bytes(truncated), oflo));\n+            }\n+        }\n \n-            (BitOr, _) => PrimVal::Bytes(l | r),\n-            (BitAnd, _) => PrimVal::Bytes(l & r),\n-            (BitXor, _) => PrimVal::Bytes(l ^ r),\n+        if let ty::TyFloat(fty) = left_ty.sty {\n+            return Ok((float_op(bin_op, l, r, fty), false));\n+        }\n \n-            (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n-            (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n-            (Mul, k) if k.is_int() => return int_arithmetic!(k, overflowing_mul, l, r),\n-            (Div, k) if k.is_int() => return int_arithmetic!(k, overflowing_div, l, r),\n-            (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n+        // only ints left\n+        let val = match bin_op {\n+            Eq => PrimVal::from_bool(l == r),\n+            Ne => PrimVal::from_bool(l != r),\n+\n+            Lt => PrimVal::from_bool(l < r),\n+            Le => PrimVal::from_bool(l <= r),\n+            Gt => PrimVal::from_bool(l > r),\n+            Ge => PrimVal::from_bool(l >= r),\n+\n+            BitOr => PrimVal::Bytes(l | r),\n+            BitAnd => PrimVal::Bytes(l & r),\n+            BitXor => PrimVal::Bytes(l ^ r),\n+\n+            Add | Sub | Mul | Rem | Div => {\n+                let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n+                    Add => u128::overflowing_add,\n+                    Sub => u128::overflowing_sub,\n+                    Mul => u128::overflowing_mul,\n+                    Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                    Div => u128::overflowing_div,\n+                    Rem => u128::overflowing_rem,\n+                    _ => bug!(),\n+                };\n+                let (result, oflo) = op(l, r);\n+                let truncated = self.truncate(result, left_ty)?;\n+                return Ok((PrimVal::Bytes(truncated), oflo || truncated != result));\n+            }\n \n             _ => {\n                 let msg = format!(\n                     \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                     bin_op,\n                     left,\n-                    left_kind,\n+                    left_ty,\n                     right,\n-                    right_kind\n+                    right_ty,\n                 );\n                 return err!(Unimplemented(msg));\n             }\n         };\n \n         Ok((val, false))\n     }\n-}\n \n-pub fn unary_op<'tcx>(\n-    un_op: mir::UnOp,\n-    val: PrimVal,\n-    val_kind: PrimValKind,\n-) -> EvalResult<'tcx, PrimVal> {\n-    use rustc::mir::UnOp::*;\n-    use rustc::mir::interpret::PrimValKind::*;\n-\n-    let bytes = val.to_bytes()?;\n+    pub fn unary_op(\n+        &self,\n+        un_op: mir::UnOp,\n+        val: PrimVal,\n+        ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        use rustc::mir::UnOp::*;\n+        use rustc_apfloat::ieee::{Single, Double};\n+        use rustc_apfloat::Float;\n \n-    let result_bytes = match (un_op, val_kind) {\n-        (Not, Bool) => !val.to_bool()? as u128,\n+        let bytes = val.to_bytes()?;\n+        let size = self.layout_of(ty)?.size.bits();\n \n-        (Not, U8) => !(bytes as u8) as u128,\n-        (Not, U16) => !(bytes as u16) as u128,\n-        (Not, U32) => !(bytes as u32) as u128,\n-        (Not, U64) => !(bytes as u64) as u128,\n-        (Not, U128) => !bytes,\n+        let result_bytes = match (un_op, &ty.sty) {\n \n-        (Not, I8) => !(bytes as i8) as u128,\n-        (Not, I16) => !(bytes as i16) as u128,\n-        (Not, I32) => !(bytes as i32) as u128,\n-        (Not, I64) => !(bytes as i64) as u128,\n-        (Not, I128) => !(bytes as i128) as u128,\n+            (Not, ty::TyBool) => !val.to_bool()? as u128,\n \n-        (Neg, I8) => -(bytes as i8) as u128,\n-        (Neg, I16) => -(bytes as i16) as u128,\n-        (Neg, I32) => -(bytes as i32) as u128,\n-        (Neg, I64) => -(bytes as i64) as u128,\n-        (Neg, I128) => -(bytes as i128) as u128,\n+            (Not, _) => !bytes,\n \n-        (Neg, F32) => (-bytes_to_f32(bytes)).bits,\n-        (Neg, F64) => (-bytes_to_f64(bytes)).bits,\n+            (Neg, ty::TyFloat(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n+            (Neg, ty::TyFloat(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n \n-        _ => {\n-            let msg = format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val);\n-            return err!(Unimplemented(msg));\n-        }\n-    };\n+            (Neg, _) if bytes == (1 << (size - 1)) => return err!(OverflowingMath),\n+            (Neg, _) => (-(bytes as i128)) as u128,\n+        };\n \n-    Ok(PrimVal::Bytes(result_bytes))\n+        Ok(PrimVal::Bytes(self.truncate(result_bytes, ty)?))\n+    }\n }"}, {"sha": "d27de3ef6bfc4e4c900ffeef81ea4cfed3b49239", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 59, "deletions": 38, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> Place {\n \n     pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n         match ty.sty {\n-            ty::TyArray(elem, n) => (elem, n.val.to_const_int().unwrap().to_u64().unwrap() as u64),\n+            ty::TyArray(elem, n) => (elem, n.val.unwrap_u64() as u64),\n \n             ty::TySlice(elem) => {\n                 match self {\n@@ -90,7 +90,7 @@ impl<'tcx> Place {\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Reads a value from the place without going through the intermediate step of obtaining\n     /// a `miri::Place`\n     pub fn try_read_place(\n@@ -103,18 +103,43 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Local(mir::RETURN_PLACE) => err!(ReadFromReturnPointer),\n             // Directly reading a local will always succeed\n             Local(local) => self.frame().get_local(local).map(Some),\n-            // Directly reading a static will always succeed\n-            Static(ref static_) => {\n-                let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                Ok(Some(self.read_global_as_value(GlobalId {\n-                    instance,\n-                    promoted: None,\n-                }, self.layout_of(self.place_ty(place))?)))\n-            }\n+            // No fast path for statics. Reading from statics is rare and would require another\n+            // Machine function to handle differently in miri.\n+            Static(_) => Ok(None),\n             Projection(ref proj) => self.try_read_place_projection(proj),\n         }\n     }\n \n+    pub fn read_field(\n+        &self,\n+        base: Value,\n+        variant: Option<usize>,\n+        field: mir::Field,\n+        base_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(Value, Ty<'tcx>)>> {\n+        let mut base_layout = self.layout_of(base_ty)?;\n+        if let Some(variant_index) = variant {\n+            base_layout = base_layout.for_variant(self, variant_index);\n+        }\n+        let field_index = field.index();\n+        let field = base_layout.field(self, field_index)?;\n+        if field.size.bytes() == 0 {\n+            return Ok(Some((Value::ByVal(PrimVal::Undef), field.ty)))\n+        }\n+        let offset = base_layout.fields.offset(field_index);\n+        match base {\n+            // the field covers the entire type\n+            Value::ByValPair(..) |\n+            Value::ByVal(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n+            // split fat pointers, 2 element tuples, ...\n+            Value::ByValPair(a, b) if base_layout.fields.count() == 2 => {\n+                let val = [a, b][field_index];\n+                Ok(Some((Value::ByVal(val), field.ty)))\n+            },\n+            _ => Ok(None),\n+        }\n+    }\n+\n     fn try_read_place_projection(\n         &mut self,\n         proj: &mir::PlaceProjection<'tcx>,\n@@ -126,23 +151,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n         let base_ty = self.place_ty(&proj.base);\n         match proj.elem {\n-            Field(field, _) => {\n-                let base_layout = self.layout_of(base_ty)?;\n-                let field_index = field.index();\n-                let field = base_layout.field(&self, field_index)?;\n-                let offset = base_layout.fields.offset(field_index);\n-                match base {\n-                    // the field covers the entire type\n-                    Value::ByValPair(..) |\n-                    Value::ByVal(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some(base)),\n-                    // split fat pointers, 2 element tuples, ...\n-                    Value::ByValPair(a, b) if base_layout.fields.count() == 2 => {\n-                        let val = [a, b][field_index];\n-                        Ok(Some(Value::ByVal(val)))\n-                    },\n-                    _ => Ok(None),\n-                }\n-            },\n+            Field(field, _) => Ok(self.read_field(base, None, field, base_ty)?.map(|(f, _)| f)),\n             // The NullablePointer cases should work fine, need to take care for normal enums\n             Downcast(..) |\n             Subslice { .. } |\n@@ -188,17 +197,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             },\n \n             Static(ref static_) => {\n-                let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                let gid = GlobalId {\n-                    instance,\n-                    promoted: None,\n-                };\n+                let alloc = self\n+                    .tcx\n+                    .interpret_interner\n+                    .get_cached(static_.def_id);\n                 let layout = self.layout_of(self.place_ty(mir_place))?;\n-                let alloc = self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\");\n-                Place::Ptr {\n-                    ptr: MemoryPointer::new(alloc, 0).into(),\n-                    align: layout.align,\n-                    extra: PlaceExtra::None,\n+                if let Some(alloc) = alloc {\n+                    Place::Ptr {\n+                        ptr: MemoryPointer::new(alloc, 0).into(),\n+                        align: layout.align,\n+                        extra: PlaceExtra::None,\n+                    }\n+                } else {\n+                    let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None\n+                    };\n+                    let alloc = Machine::init_static(self, cid)?;\n+                    Place::Ptr {\n+                        ptr: MemoryPointer::new(alloc, 0).into(),\n+                        align: layout.align,\n+                        extra: PlaceExtra::None,\n+                    }\n                 }\n             }\n \n@@ -424,7 +445,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(\n-            place.ty(self.mir(), self.tcx).to_ty(self.tcx),\n+            place.ty(self.mir(), *self.tcx).to_ty(*self.tcx),\n             self.substs(),\n         )\n     }"}, {"sha": "4e1750caf26ba30f637e2c3196fb210d0274dce2", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 14, "deletions": 236, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -2,22 +2,13 @@\n //!\n //! The main entry point is the `step` method.\n \n-use rustc::hir;\n-use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::mir;\n-use rustc::ty::{self, Instance};\n-use rustc::ty::layout::LayoutOf;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::mir::interpret::GlobalId;\n \n-use rustc::mir::interpret::{EvalResult, EvalErrorKind};\n-use super::{EvalContext, StackPopCleanup, Place, Machine};\n+use rustc::mir::interpret::EvalResult;\n+use super::{EvalContext, Machine};\n \n-use syntax::codemap::Span;\n-use syntax::ast::Mutability;\n-\n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    pub fn inc_step_counter_and_check_limit(&mut self, n: usize) -> EvalResult<'tcx> {\n         self.steps_remaining = self.steps_remaining.saturating_sub(n);\n         if self.steps_remaining > 0 {\n             Ok(())\n@@ -28,7 +19,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     /// Returns true as long as there are more things to do.\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n-        self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n             return Ok(false);\n         }\n@@ -41,52 +31,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let old_frames = self.cur_frame();\n \n         if let Some(stmt) = basic_block.statements.get(stmt_id) {\n-            let mut new = Ok(false);\n-            ConstantExtractor {\n-                span: stmt.source_info.span,\n-                instance: self.frame().instance,\n-                ecx: self,\n-                mir,\n-                new_constant: &mut new,\n-            }.visit_statement(\n-                block,\n-                stmt,\n-                mir::Location {\n-                    block,\n-                    statement_index: stmt_id,\n-                },\n-            );\n-            // if ConstantExtractor added a new frame, we don't execute anything here\n-            // but await the next call to step\n-            if !new? {\n-                assert_eq!(old_frames, self.cur_frame());\n-                self.statement(stmt)?;\n-            }\n+            assert_eq!(old_frames, self.cur_frame());\n+            self.statement(stmt)?;\n             return Ok(true);\n         }\n \n+        self.inc_step_counter_and_check_limit(1)?;\n+\n         let terminator = basic_block.terminator();\n-        let mut new = Ok(false);\n-        ConstantExtractor {\n-            span: terminator.source_info.span,\n-            instance: self.frame().instance,\n-            ecx: self,\n-            mir,\n-            new_constant: &mut new,\n-        }.visit_terminator(\n-            block,\n-            terminator,\n-            mir::Location {\n-                block,\n-                statement_index: stmt_id,\n-            },\n-        );\n-        // if ConstantExtractor added a new frame, we don't execute anything here\n-        // but await the next call to step\n-        if !new? {\n-            assert_eq!(old_frames, self.cur_frame());\n-            self.terminator(terminator)?;\n-        }\n+        assert_eq!(old_frames, self.cur_frame());\n+        self.terminator(terminator)?;\n         Ok(true)\n     }\n \n@@ -98,6 +52,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // Some statements (e.g. box) push new stack frames.  We have to record the stack frame number\n         // *before* executing the statement.\n         let frame_idx = self.cur_frame();\n+        self.tcx.span = stmt.source_info.span;\n+        self.memory.tcx.span = stmt.source_info.span;\n \n         match stmt.kind {\n             Assign(ref place, ref rvalue) => self.eval_rvalue_into_place(rvalue, place)?,\n@@ -146,190 +102,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n         trace!(\"{:?}\", terminator.kind);\n+        self.tcx.span = terminator.source_info.span;\n+        self.memory.tcx.span = terminator.source_info.span;\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n             trace!(\"// {:?}\", self.frame().block);\n         }\n         Ok(())\n     }\n-\n-    /// returns `true` if a stackframe was pushed\n-    fn global_item(\n-        &mut self,\n-        instance: Instance<'tcx>,\n-        span: Span,\n-        mutability: Mutability,\n-    ) -> EvalResult<'tcx, bool> {\n-        debug!(\"global_item: {:?}\", instance);\n-        let cid = GlobalId {\n-            instance,\n-            promoted: None,\n-        };\n-        if self.tcx.interpret_interner.borrow().get_cached(cid).is_some() {\n-            return Ok(false);\n-        }\n-        if self.tcx.has_attr(instance.def_id(), \"linkage\") {\n-            M::global_item_with_linkage(self, cid.instance, mutability)?;\n-            return Ok(false);\n-        }\n-        let instance_ty = instance.ty(self.tcx);\n-        let layout = self.layout_of(instance_ty)?;\n-        assert!(!layout.is_unsized());\n-        let ptr = self.memory.allocate(\n-            layout.size.bytes(),\n-            layout.align,\n-            None,\n-        )?;\n-        self.tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n-        let internally_mutable = !layout.ty.is_freeze(self.tcx, self.param_env, span);\n-        let mutability = if mutability == Mutability::Mutable || internally_mutable {\n-            Mutability::Mutable\n-        } else {\n-            Mutability::Immutable\n-        };\n-        let cleanup = StackPopCleanup::MarkStatic(mutability);\n-        let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n-        trace!(\"pushing stack frame for global: {}\", name);\n-        let mir = self.load_mir(instance.def)?;\n-        self.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            Place::from_ptr(ptr, layout.align),\n-            cleanup,\n-        )?;\n-        Ok(true)\n-    }\n-}\n-\n-struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b, M: Machine<'tcx> + 'a> {\n-    span: Span,\n-    ecx: &'a mut EvalContext<'b, 'tcx, M>,\n-    mir: &'tcx mir::Mir<'tcx>,\n-    instance: ty::Instance<'tcx>,\n-    // Whether a stackframe for a new constant has been pushed\n-    new_constant: &'a mut EvalResult<'tcx, bool>,\n-}\n-\n-impl<'a, 'b, 'tcx, M: Machine<'tcx>> ConstantExtractor<'a, 'b, 'tcx, M> {\n-    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, bool>>(&mut self, f: F) {\n-        match *self.new_constant {\n-            // already computed a constant, don't do more than one per iteration\n-            Ok(true) => {},\n-            // no constants computed yet\n-            Ok(false) => *self.new_constant = f(self),\n-            // error happened, abort the visitor traversing\n-            Err(_) => {},\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx, M> {\n-    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: mir::Location) {\n-        self.super_constant(constant, location);\n-        self.try(|this| {\n-            match constant.literal {\n-                // already computed by rustc\n-                mir::Literal::Value { value: &ty::Const { val: ConstVal::Unevaluated(def_id, substs), .. } } => {\n-                    debug!(\"global_item: {:?}, {:#?}\", def_id, substs);\n-                    let substs = this.ecx.tcx.trans_apply_param_substs(this.instance.substs, &substs);\n-                    debug!(\"global_item_new_substs: {:#?}\", substs);\n-                    debug!(\"global_item_param_env: {:#?}\", this.ecx.param_env);\n-                    let instance = Instance::resolve(\n-                        this.ecx.tcx,\n-                        this.ecx.param_env,\n-                        def_id,\n-                        substs,\n-                    ).ok_or(EvalErrorKind::TypeckError)?; // turn error prop into a panic to expose associated type in const issue\n-                    this.ecx.global_item(\n-                        instance,\n-                        constant.span,\n-                        Mutability::Immutable,\n-                    )\n-                }\n-                mir::Literal::Value { .. } => Ok(false),\n-                mir::Literal::Promoted { index } => {\n-                    let cid = GlobalId {\n-                        instance: this.instance,\n-                        promoted: Some(index),\n-                    };\n-                    if this.ecx.tcx.interpret_interner.borrow().get_cached(cid).is_some() {\n-                        return Ok(false);\n-                    }\n-                    let mir = &this.mir.promoted[index];\n-                    let ty = this.ecx.monomorphize(mir.return_ty(), this.instance.substs);\n-                    let layout = this.ecx.layout_of(ty)?;\n-                    assert!(!layout.is_unsized());\n-                    let ptr = this.ecx.memory.allocate(\n-                        layout.size.bytes(),\n-                        layout.align,\n-                        None,\n-                    )?;\n-                    this.ecx.tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n-                    trace!(\"pushing stack frame for {:?}\", index);\n-                    this.ecx.push_stack_frame(\n-                        this.instance,\n-                        constant.span,\n-                        mir,\n-                        Place::from_ptr(ptr, layout.align),\n-                        StackPopCleanup::MarkStatic(Mutability::Immutable),\n-                    )?;\n-                    Ok(true)\n-                }\n-            }\n-        });\n-    }\n-\n-    fn visit_place(\n-        &mut self,\n-        place: &mir::Place<'tcx>,\n-        context: PlaceContext<'tcx>,\n-        location: mir::Location,\n-    ) {\n-        self.super_place(place, context, location);\n-        self.try(|this| {\n-            if let mir::Place::Static(ref static_) = *place {\n-                let def_id = static_.def_id;\n-                let span = this.span;\n-                if let Some(node_item) = this.ecx.tcx.hir.get_if_local(def_id) {\n-                    if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n-                        if let hir::ItemStatic(_, m, _) = *node {\n-                            let instance = Instance::mono(this.ecx.tcx, def_id);\n-                            this.ecx.global_item(\n-                                instance,\n-                                span,\n-                                if m == hir::MutMutable {\n-                                    Mutability::Mutable\n-                                } else {\n-                                    Mutability::Immutable\n-                                },\n-                            )\n-                        } else {\n-                            bug!(\"static def id doesn't point to static\");\n-                        }\n-                    } else {\n-                        bug!(\"static def id doesn't point to item\");\n-                    }\n-                } else {\n-                    let def = this.ecx.tcx.describe_def(def_id).expect(\"static not found\");\n-                    if let hir::def::Def::Static(_, mutable) = def {\n-                        let instance = Instance::mono(this.ecx.tcx, def_id);\n-                        this.ecx.global_item(\n-                            instance,\n-                            span,\n-                            if mutable {\n-                                Mutability::Mutable\n-                            } else {\n-                                Mutability::Immutable\n-                            },\n-                        )\n-                    } else {\n-                        bug!(\"static found but isn't a static: {:?}\", def);\n-                    }\n-                }\n-            } else {\n-                Ok(false)\n-            }\n-        });\n-    }\n }"}, {"sha": "fbc0c499e59ded5124946755aa90dec5e52063d0", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -5,7 +5,7 @@ use syntax::codemap::Span;\n use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub(crate) fn drop_place(\n         &mut self,\n         place: Place,"}, {"sha": "babc78470147584e87d455e8fa0b647ce8438866", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -5,15 +5,14 @@ use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n-use super::{EvalContext, eval_context,\n-            Place, Machine, ValTy};\n+use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n use interpret::memory::HasMemory;\n \n mod drop;\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn goto_block(&mut self, target: mir::BasicBlock) {\n         self.frame_mut().block = target;\n         self.frame_mut().stmt = 0;\n@@ -45,8 +44,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n-                for (index, const_int) in values.iter().enumerate() {\n-                    let prim = PrimVal::Bytes(const_int.to_u128_unchecked());\n+                for (index, &const_int) in values.iter().enumerate() {\n+                    let prim = PrimVal::Bytes(const_int);\n                     if discr_prim.to_bytes()? == prim.to_bytes()? {\n                         target_block = targets[index];\n                         break;\n@@ -72,10 +71,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.value_to_primval(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n-                        let instance_ty = instance.ty(self.tcx);\n+                        let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n                             ty::TyFnDef(..) => {\n-                                let real_sig = instance_ty.fn_sig(self.tcx);\n+                                let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n                                 let real_sig = self.tcx.erase_late_bound_regions_and_normalize(&real_sig);\n                                 if !self.check_sig_compat(sig, real_sig)? {\n@@ -88,7 +87,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n                     ty::TyFnDef(def_id, substs) => (\n                         self.resolve(def_id, substs)?,\n-                        func.ty.fn_sig(self.tcx),\n+                        func.ty.fn_sig(*self.tcx),\n                     ),\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.ty);\n@@ -117,7 +116,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ty = self.tcx.trans_apply_param_substs(self.substs(), &ty);\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n-                let instance = eval_context::resolve_drop_in_place(self.tcx, ty);\n+                let instance = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_place(\n                     place,\n                     instance,\n@@ -402,7 +401,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ptr_size = self.memory.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n-                let fn_ptr = self.memory.read_ptr_sized_unsigned(\n+                let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n                 )?.to_ptr()?;"}, {"sha": "ded27108e716a235498d2ac4bb87e262512fd4ca", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -3,10 +3,9 @@ use rustc::ty::layout::{Size, Align, LayoutOf};\n use syntax::ast::Mutability;\n \n use rustc::mir::interpret::{PrimVal, Value, MemoryPointer, EvalResult};\n-use super::{EvalContext, eval_context,\n-            Machine};\n+use super::{EvalContext, Machine};\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///\n@@ -34,7 +33,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             None,\n         )?;\n \n-        let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n+        let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n         self.memory.write_ptr_sized_unsigned(vtable, ptr_align, PrimVal::Ptr(drop))?;\n \n@@ -52,9 +51,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n         }\n \n-        self.memory.mark_static_initalized(\n+        self.memory.mark_static_initialized(\n             vtable.alloc_id,\n-            Mutability::Mutable,\n+            Mutability::Immutable,\n         )?;\n \n         Ok(vtable)\n@@ -80,8 +79,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized_unsigned(vtable.offset(pointer_size, self)?, pointer_align)?.to_bytes()? as u64;\n-        let align = self.memory.read_ptr_sized_unsigned(\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bytes()? as u64;\n+        let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n         )?.to_bytes()? as u64;"}, {"sha": "c31e95fd826c686026b4ab9d83aa3727addebfab", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,6 +16,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![deny(warnings)]\n \n+#![feature(slice_patterns)]\n+#![feature(from_ref)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(catch_expr)]\n@@ -38,6 +40,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(nonzero)]\n #![feature(underscore_lifetimes)]\n \n+extern crate arena;\n #[macro_use]\n extern crate bitflags;\n #[macro_use] extern crate log;\n@@ -52,7 +55,6 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_back;\n extern crate rustc_const_math;\n-extern crate rustc_const_eval;\n extern crate core; // for NonZero\n extern crate log_settings;\n extern crate rustc_apfloat;\n@@ -70,13 +72,15 @@ pub mod util;\n pub mod interpret;\n pub mod monomorphize;\n \n+pub use hair::pattern::check_crate as matchck_crate;\n use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     borrow_check::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n     providers.const_eval = interpret::const_eval_provider;\n+    providers.check_match = hair::pattern::check_match;\n }\n \n __build_diagnostic_array! { librustc_mir, DIAGNOSTICS }"}, {"sha": "f6b47efca31cd7decc2cdde09e17608996158eaf", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 118, "deletions": 46, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -194,15 +194,17 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{Value, PrimVal, AllocId, Pointer};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::session::config;\n-use rustc::mir::{self, Location};\n+use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n+use rustc::mir::interpret::GlobalId;\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -377,7 +379,19 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             recursion_depth_reset = None;\n \n-            collect_neighbours(tcx, instance, true, &mut neighbors);\n+            let cid = GlobalId {\n+                instance,\n+                promoted: None,\n+            };\n+            let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+\n+            match tcx.const_eval(param_env.and(cid)) {\n+                Ok(val) => collect_const(tcx, val, instance.substs, &mut neighbors),\n+                Err(err) => {\n+                    let span = tcx.def_span(def_id);\n+                    err.report(tcx, span, \"static\");\n+                }\n+            }\n         }\n         MonoItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n@@ -389,7 +403,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                                recursion_depths));\n             check_type_length_limit(tcx, instance);\n \n-            collect_neighbours(tcx, instance, false, &mut neighbors);\n+            collect_neighbours(tcx, instance, &mut neighbors);\n         }\n         MonoItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n@@ -498,7 +512,6 @@ struct MirNeighborCollector<'a, 'tcx: 'a> {\n     mir: &'a mir::Mir<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: &'tcx Substs<'tcx>,\n-    const_context: bool,\n }\n \n impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n@@ -568,15 +581,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n-            let substs = self.tcx.trans_apply_param_substs(self.param_substs,\n-                                                           &substs);\n-            let instance = ty::Instance::resolve(self.tcx,\n-                                                 ty::ParamEnv::empty(traits::Reveal::All),\n-                                                 def_id,\n-                                                 substs).unwrap();\n-            collect_neighbours(self.tcx, instance, true, self.output);\n-        }\n+        collect_const(self.tcx, constant, self.param_substs, self.output);\n \n         self.super_const(constant);\n     }\n@@ -592,30 +597,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n                 let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n-\n-                let constness = match (self.const_context, &callee_ty.sty) {\n-                    (true, &ty::TyFnDef(def_id, substs)) if self.tcx.is_const_fn(def_id) => {\n-                        let instance =\n-                            ty::Instance::resolve(self.tcx,\n-                                                  ty::ParamEnv::empty(traits::Reveal::All),\n-                                                  def_id,\n-                                                  substs).unwrap();\n-                        Some(instance)\n-                    }\n-                    _ => None\n-                };\n-\n-                if let Some(const_fn_instance) = constness {\n-                    // If this is a const fn, called from a const context, we\n-                    // have to visit its body in order to find any fn reifications\n-                    // it might contain.\n-                    collect_neighbours(self.tcx,\n-                                       const_fn_instance,\n-                                       true,\n-                                       self.output);\n-                } else {\n-                    visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n-                }\n+                visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n@@ -1098,26 +1080,59 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+/// Scan the miri alloc in order to find function calls, closures, and drop-glue\n+fn collect_miri<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    alloc_id: AllocId,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n+    if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(alloc_id) {\n+        let instance = Instance::mono(tcx, did);\n+        if should_monomorphize_locally(tcx, &instance) {\n+            trace!(\"collecting static {:?}\", did);\n+            output.push(MonoItem::Static(did));\n+        }\n+    } else if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n+        trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n+        for &inner in alloc.relocations.values() {\n+            collect_miri(tcx, inner, output);\n+        }\n+    } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n+        if should_monomorphize_locally(tcx, &fn_instance) {\n+            trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n+            output.push(create_fn_mono_item(fn_instance));\n+        }\n+    } else {\n+        bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+    }\n+}\n+\n /// Scan the MIR in order to find function calls, closures, and drop-glue\n fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,\n-                                const_context: bool,\n                                 output: &mut Vec<MonoItem<'tcx>>)\n {\n     let mir = tcx.instance_mir(instance.def);\n \n-    let mut visitor = MirNeighborCollector {\n+    MirNeighborCollector {\n         tcx,\n         mir: &mir,\n         output,\n         param_substs: instance.substs,\n-        const_context,\n-    };\n-\n-    visitor.visit_mir(&mir);\n-    for promoted in &mir.promoted {\n-        visitor.mir = promoted;\n-        visitor.visit_mir(promoted);\n+    }.visit_mir(&mir);\n+    let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+    for (i, promoted) in mir.promoted.iter().enumerate() {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        let cid = GlobalId {\n+            instance,\n+            promoted: Some(Promoted::new(i)),\n+        };\n+        match tcx.const_eval(param_env.and(cid)) {\n+            Ok(val) => collect_const(tcx, val, instance.substs, output),\n+            Err(err) => {\n+                err.report(tcx, promoted.span, \"promoted\");\n+            }\n+        }\n     }\n }\n \n@@ -1129,3 +1144,60 @@ fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     printer.push_def_path(def_id, &mut output);\n     output\n }\n+\n+fn collect_const<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    constant: &ty::Const<'tcx>,\n+    param_substs: &'tcx Substs<'tcx>,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n+    debug!(\"visiting const {:?}\", *constant);\n+\n+    let val = match constant.val {\n+        ConstVal::Unevaluated(def_id, substs) => {\n+            let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+            let substs = tcx.trans_apply_param_substs(param_substs,\n+                                                        &substs);\n+            let instance = ty::Instance::resolve(tcx,\n+                                                param_env,\n+                                                def_id,\n+                                                substs).unwrap();\n+\n+            let cid = GlobalId {\n+                instance,\n+                promoted: None,\n+            };\n+            match tcx.const_eval(param_env.and(cid)) {\n+                Ok(val) => val.val,\n+                Err(err) => {\n+                    let span = tcx.def_span(def_id);\n+                    err.report(tcx, span, \"constant\");\n+                    return;\n+                }\n+            }\n+        },\n+        _ => constant.val,\n+    };\n+    match val {\n+        ConstVal::Unevaluated(..) => bug!(\"const eval yielded unevaluated const\"),\n+        ConstVal::Value(Value::ByValPair(PrimVal::Ptr(a), PrimVal::Ptr(b))) => {\n+            collect_miri(tcx, a.alloc_id, output);\n+            collect_miri(tcx, b.alloc_id, output);\n+        }\n+        ConstVal::Value(Value::ByValPair(_, PrimVal::Ptr(ptr))) |\n+        ConstVal::Value(Value::ByValPair(PrimVal::Ptr(ptr), _)) |\n+        ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))) =>\n+            collect_miri(tcx, ptr.alloc_id, output),\n+        ConstVal::Value(Value::ByRef(Pointer { primval: PrimVal::Ptr(ptr) }, _)) => {\n+            // by ref should only collect the inner allocation, not the value itself\n+            let alloc = tcx\n+                .interpret_interner\n+                .get_alloc(ptr.alloc_id)\n+                .expect(\"ByRef to extern static is not allowed\");\n+            for &inner in alloc.relocations.values() {\n+                collect_miri(tcx, inner, output);\n+            }\n+        }\n+        _ => {},\n+    }\n+}"}, {"sha": "1f7f1237ba7894901e671f36ed1a42584dad5605", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n                 write!(output, \"; {}\",\n-                    len.val.to_const_int().unwrap().to_u64().unwrap()).unwrap();\n+                    len.val.unwrap_u64()).unwrap();\n                 output.push(']');\n             },\n             ty::TySlice(inner_type) => {"}, {"sha": "9aff7fa2a2c7197ebda90676db98a0cce551ad4e", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n-use rustc_const_math::{ConstInt, ConstUsize};\n+use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n@@ -303,7 +303,7 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n         ty::TyArray(ty, len) => {\n-            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            let len = len.val.unwrap_u64();\n             builder.array_shim(dest, src, ty, len)\n         }\n         ty::TyClosure(def_id, substs) => {\n@@ -443,7 +443,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ty: func_ty,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(self.def_id, substs),\n+                    // ZST function type\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty: func_ty\n                 }),\n             },\n@@ -501,13 +502,12 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     }\n \n     fn make_usize(&self, value: u64) -> Box<Constant<'tcx>> {\n-        let value = ConstUsize::new(value, self.tcx.sess.target.usize_ty).unwrap();\n         box Constant {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Integral(ConstInt::Usize(value)),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(value.into()))),\n                     ty: self.tcx.types.usize,\n                 })\n             }\n@@ -739,8 +739,8 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ty,\n                 literal: Literal::Value {\n                     value: tcx.mk_const(ty::Const {\n-                        val: ConstVal::Function(def_id,\n-                            Substs::identity_for_item(tcx, def_id)),\n+                        // ZST function type\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                         ty\n                     }),\n                 },"}, {"sha": "86d08dec2b9c363621b76bcf73c5e38511d74ad7", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 // locals are safe\n             }\n             &Place::Static(box Static { def_id, ty: _ }) => {\n-                if self.tcx.is_static_mut(def_id) {\n+                if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\");\n                 } else if self.tcx.is_foreign_item(def_id) {\n                     let source_info = self.source_info;"}, {"sha": "f133d6e9c6dee847be829b68e1246284cc62091c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "added", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,517 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Propagates constants for early reporting of statically known\n+//! assertion failures\n+\n+\n+use rustc::hir::def::Def;\n+use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, Rvalue, Local};\n+use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n+use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n+use rustc::mir::visit::{Visitor, PlaceContext};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{TyCtxt, self, Instance};\n+use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n+use interpret::{eval_body_with_mir, mk_borrowck_eval_cx, ValTy};\n+use transform::{MirPass, MirSource};\n+use syntax::codemap::Span;\n+use rustc::ty::subst::Substs;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::ty::ParamEnv;\n+use rustc::ty::layout::{\n+    LayoutOf, TyLayout, LayoutError,\n+    HasTyCtxt, TargetDataLayout, HasDataLayout,\n+};\n+\n+pub struct ConstProp;\n+\n+impl MirPass for ConstProp {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        // will be evaluated by miri and produce its errors there\n+        if source.promoted.is_some() {\n+            return;\n+        }\n+        match tcx.describe_def(source.def_id) {\n+            // skip statics because they'll be evaluated by miri anyway\n+            Some(Def::Static(..)) => return,\n+            _ => {},\n+        }\n+        trace!(\"ConstProp starting for {:?}\", source.def_id);\n+\n+        // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n+        // constants, instead of just checking for const-folding succeeding.\n+        // That would require an uniform one-def no-mutation analysis\n+        // and RPO (or recursing when needing the value of a local).\n+        let mut optimization_finder = ConstPropagator::new(mir, tcx, source);\n+        optimization_finder.visit_mir(mir);\n+\n+        trace!(\"ConstProp done for {:?}\", source.def_id);\n+    }\n+}\n+\n+type Const<'tcx> = (Value, ty::Ty<'tcx>, Span);\n+\n+/// Finds optimization opportunities on the MIR.\n+struct ConstPropagator<'b, 'a, 'tcx:'a+'b> {\n+    mir: &'b Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: MirSource,\n+    places: IndexVec<Local, Option<Const<'tcx>>>,\n+    can_const_prop: IndexVec<Local, bool>,\n+    param_env: ParamEnv<'tcx>,\n+}\n+\n+impl<'a, 'b, 'tcx> LayoutOf<ty::Ty<'tcx>> for &'a ConstPropagator<'a, 'b, 'tcx> {\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    fn layout_of(self, ty: ty::Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx.layout_of(self.param_env.and(ty))\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> HasDataLayout for &'a ConstPropagator<'a, 'b, 'tcx> {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for &'a ConstPropagator<'a, 'b, 'tcx> {\n+    #[inline]\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n+    fn new(\n+        mir: &'b Mir<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        source: MirSource,\n+    ) -> ConstPropagator<'b, 'a, 'tcx> {\n+        let param_env = tcx.param_env(source.def_id);\n+        ConstPropagator {\n+            mir,\n+            tcx,\n+            source,\n+            param_env,\n+            can_const_prop: CanConstProp::check(mir),\n+            places: IndexVec::from_elem(None, &mir.local_decls),\n+        }\n+    }\n+\n+    fn const_eval(&self, cid: GlobalId<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+        let value = match self.tcx.const_eval(self.param_env.and(cid)) {\n+            Ok(val) => val,\n+            Err(err) => {\n+                err.report(self.tcx, err.span, \"constant propagated\");\n+                return None;\n+            },\n+        };\n+        let val = match value.val {\n+            ConstVal::Value(v) => v,\n+            _ => bug!(\"eval produced: {:?}\", value),\n+        };\n+        let val = (val, value.ty, span);\n+        trace!(\"evaluated {:?} to {:?}\", cid, val);\n+        Some(val)\n+    }\n+\n+    fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<Const<'tcx>> {\n+        match c.literal {\n+            Literal::Value { value } => match value.val {\n+                ConstVal::Value(v) => Some((v, value.ty, c.span)),\n+                ConstVal::Unevaluated(did, substs) => {\n+                    let instance = Instance::resolve(\n+                        self.tcx,\n+                        self.param_env,\n+                        did,\n+                        substs,\n+                    )?;\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    self.const_eval(cid, c.span)\n+                },\n+            },\n+            // evaluate the promoted and replace the constant with the evaluated result\n+            Literal::Promoted { index } => {\n+                let generics = self.tcx.generics_of(self.source.def_id);\n+                if generics.parent_types as usize + generics.types.len() > 0 {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: Some(index),\n+                };\n+                // cannot use `const_eval` here, because that would require having the MIR\n+                // for the current function available, but we're producing said MIR right now\n+                let (value, _, ty) = eval_body_with_mir(self.tcx, cid, self.mir, self.param_env)?;\n+                let val = (value, ty, c.span);\n+                trace!(\"evaluated {:?} to {:?}\", c, val);\n+                Some(val)\n+            }\n+        }\n+    }\n+\n+    fn eval_place(&mut self, place: &Place<'tcx>) -> Option<Const<'tcx>> {\n+        match *place {\n+            Place::Local(loc) => self.places[loc].clone(),\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _) => {\n+                    trace!(\"field proj on {:?}\", proj.base);\n+                    let (base, ty, span) = self.eval_place(&proj.base)?;\n+                    match base {\n+                        Value::ByValPair(a, b) => {\n+                            trace!(\"by val pair: {:?}, {:?}\", a, b);\n+                            let base_layout = self.tcx.layout_of(self.param_env.and(ty)).ok()?;\n+                            trace!(\"layout computed\");\n+                            use rustc_data_structures::indexed_vec::Idx;\n+                            let field_index = field.index();\n+                            let val = [a, b][field_index];\n+                            let field = base_layout.field(&*self, field_index).ok()?;\n+                            trace!(\"projection resulted in: {:?}\", val);\n+                            Some((Value::ByVal(val), field.ty, span))\n+                        },\n+                        _ => None,\n+                    }\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn eval_operand(&mut self, op: &Operand<'tcx>) -> Option<Const<'tcx>> {\n+        match *op {\n+            Operand::Constant(ref c) => self.eval_constant(c),\n+            Operand::Move(ref place) | Operand::Copy(ref place) => self.eval_place(place),\n+        }\n+    }\n+\n+    fn const_prop(\n+        &mut self,\n+        rvalue: &Rvalue<'tcx>,\n+        place_ty: ty::Ty<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> Option<Const<'tcx>> {\n+        let span = source_info.span;\n+        match *rvalue {\n+            // No need to overwrite an already evaluated constant\n+            Rvalue::Use(Operand::Constant(box Constant {\n+                literal: Literal::Value {\n+                    value: &ty::Const {\n+                        val: ConstVal::Value(_),\n+                        ..\n+                    },\n+                },\n+                ..\n+            })) => None,\n+            // This branch exists for the sanity type check\n+            Rvalue::Use(Operand::Constant(ref c)) => {\n+                assert_eq!(c.ty, place_ty);\n+                self.eval_constant(c)\n+            },\n+            Rvalue::Use(ref op) => {\n+                self.eval_operand(op)\n+            },\n+            Rvalue::Repeat(..) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::Aggregate(..) |\n+            Rvalue::NullaryOp(NullOp::Box, _) |\n+            Rvalue::Discriminant(..) => None,\n+            // FIXME(oli-obk): evaluate static/constant slice lengths\n+            Rvalue::Len(_) => None,\n+            Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n+                let param_env = self.tcx.param_env(self.source.def_id);\n+                type_size_of(self.tcx, param_env, ty).map(|n| (\n+                    Value::ByVal(PrimVal::Bytes(n as u128)),\n+                    self.tcx.types.usize,\n+                    span,\n+                ))\n+            }\n+            Rvalue::UnaryOp(op, ref arg) => {\n+                let def_id = if self.tcx.is_closure(self.source.def_id) {\n+                    self.tcx.closure_base_def_id(self.source.def_id)\n+                } else {\n+                    self.source.def_id\n+                };\n+                let generics = self.tcx.generics_of(def_id);\n+                if generics.parent_types as usize + generics.types.len() > 0 {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n+\n+                let val = self.eval_operand(arg)?;\n+                let prim = ecx.value_to_primval(ValTy { value: val.0, ty: val.1 }).ok()?;\n+                match ecx.unary_op(op, prim, val.1) {\n+                    Ok(val) => Some((Value::ByVal(val), place_ty, span)),\n+                    Err(mut err) => {\n+                        ecx.report(&mut err, false, Some(span));\n+                        None\n+                    },\n+                }\n+            }\n+            Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n+            Rvalue::BinaryOp(op, ref left, ref right) => {\n+                trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n+                let right = self.eval_operand(right)?;\n+                let def_id = if self.tcx.is_closure(self.source.def_id) {\n+                    self.tcx.closure_base_def_id(self.source.def_id)\n+                } else {\n+                    self.source.def_id\n+                };\n+                let generics = self.tcx.generics_of(def_id);\n+                let has_generics = generics.parent_types as usize + generics.types.len() > 0;\n+                if has_generics {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n+\n+                let r = ecx.value_to_primval(ValTy { value: right.0, ty: right.1 }).ok()?;\n+                if op == BinOp::Shr || op == BinOp::Shl {\n+                    let param_env = self.tcx.param_env(self.source.def_id);\n+                    let left_ty = left.ty(self.mir, self.tcx);\n+                    let bits = self.tcx.layout_of(param_env.and(left_ty)).unwrap().size.bits();\n+                    if r.to_bytes().ok().map_or(false, |b| b >= bits as u128) {\n+                        let scope_info = match self.mir.visibility_scope_info {\n+                            ClearCrossCrate::Set(ref data) => data,\n+                            ClearCrossCrate::Clear => return None,\n+                        };\n+                        let dir = if op == BinOp::Shr {\n+                            \"right\"\n+                        } else {\n+                            \"left\"\n+                        };\n+                        let node_id = scope_info[source_info.scope].lint_root;\n+                        self.tcx.lint_node(\n+                            ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n+                            node_id,\n+                            span,\n+                            &format!(\"attempt to shift {} with overflow\", dir));\n+                        return None;\n+                    }\n+                }\n+                let left = self.eval_operand(left)?;\n+                let l = ecx.value_to_primval(ValTy { value: left.0, ty: left.1 }).ok()?;\n+                trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n+                match ecx.binary_op(op, l, left.1, r, right.1) {\n+                    Ok((val, overflow)) => {\n+                        let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n+                            Value::ByValPair(\n+                                val,\n+                                PrimVal::from_bool(overflow),\n+                            )\n+                        } else {\n+                            if overflow {\n+                                use rustc::mir::interpret::EvalErrorKind;\n+                                let mut err = EvalErrorKind::OverflowingMath.into();\n+                                ecx.report(&mut err, false, Some(span));\n+                                return None;\n+                            }\n+                            Value::ByVal(val)\n+                        };\n+                        Some((val, place_ty, span))\n+                    },\n+                    Err(mut err) => {\n+                        ecx.report(&mut err, false, Some(span));\n+                        None\n+                    },\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: ty::ParamEnv<'tcx>,\n+                          ty: ty::Ty<'tcx>) -> Option<u64> {\n+    tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n+}\n+\n+struct CanConstProp {\n+    can_const_prop: IndexVec<Local, bool>,\n+    // false at the beginning, once set, there are not allowed to be any more assignments\n+    found_assignment: IndexVec<Local, bool>,\n+}\n+\n+impl CanConstProp {\n+    /// returns true if `local` can be propagated\n+    fn check(mir: &Mir) -> IndexVec<Local, bool> {\n+        let mut cpv = CanConstProp {\n+            can_const_prop: IndexVec::from_elem(true, &mir.local_decls),\n+            found_assignment: IndexVec::from_elem(false, &mir.local_decls),\n+        };\n+        for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n+            // cannot use args at all\n+            // cannot use locals because if x < y { y - x } else { x - y } would\n+            //        lint for x != y\n+            // FIXME(oli-obk): lint variables until they are used in a condition\n+            // FIXME(oli-obk): lint if return value is constant\n+            *val = mir.local_kind(local) == LocalKind::Temp;\n+        }\n+        cpv.visit_mir(mir);\n+        cpv.can_const_prop\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for CanConstProp {\n+    fn visit_local(\n+        &mut self,\n+        &local: &Local,\n+        context: PlaceContext<'tcx>,\n+        _: Location,\n+    ) {\n+        use rustc::mir::visit::PlaceContext::*;\n+        match context {\n+            // Constants must have at most one write\n+            // FIXME(oli-obk): we could be more powerful here, if the multiple writes\n+            // only occur in independent execution paths\n+            Store => if self.found_assignment[local] {\n+                self.can_const_prop[local] = false;\n+            } else {\n+                self.found_assignment[local] = true\n+            },\n+            // Reading constants is allowed an arbitrary number of times\n+            Copy | Move |\n+            StorageDead | StorageLive |\n+            Validate |\n+            Projection(_) |\n+            Inspect => {},\n+            _ => self.can_const_prop[local] = false,\n+        }\n+    }\n+}\n+\n+impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n+    fn visit_constant(\n+        &mut self,\n+        constant: &Constant<'tcx>,\n+        location: Location,\n+    ) {\n+        trace!(\"visit_constant: {:?}\", constant);\n+        self.super_constant(constant, location);\n+        self.eval_constant(constant);\n+    }\n+\n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+        if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n+            let place_ty = place\n+                .ty(&self.mir.local_decls, self.tcx)\n+                .to_ty(self.tcx);\n+            if let Some(value) = self.const_prop(rval, place_ty, statement.source_info) {\n+                if let Place::Local(local) = *place {\n+                    trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n+                    if self.can_const_prop[local] {\n+                        trace!(\"storing {:?} to {:?}\", value, local);\n+                        assert!(self.places[local].is_none());\n+                        self.places[local] = Some(value);\n+                    }\n+                }\n+            }\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_terminator_kind(\n+        &mut self,\n+        block: BasicBlock,\n+        kind: &TerminatorKind<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_terminator_kind(block, kind, location);\n+        if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n+            if let Some(value) = self.eval_operand(cond) {\n+                trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                if Value::ByVal(PrimVal::from_bool(*expected)) != value.0 {\n+                    // poison all places this operand references so that further code\n+                    // doesn't use the invalid value\n+                    match cond {\n+                        Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                            let mut place = place;\n+                            while let Place::Projection(ref proj) = *place {\n+                                place = &proj.base;\n+                            }\n+                            if let Place::Local(local) = *place {\n+                                self.places[local] = None;\n+                            }\n+                        },\n+                        Operand::Constant(_) => {}\n+                    }\n+                    let span = self.mir[block]\n+                        .terminator\n+                        .as_ref()\n+                        .unwrap()\n+                        .source_info\n+                        .span;\n+                    let node_id = self\n+                        .tcx\n+                        .hir\n+                        .as_local_node_id(self.source.def_id)\n+                        .expect(\"some part of a failing const eval must be local\");\n+                    use rustc::mir::AssertMessage::*;\n+                    let msg = match msg {\n+                        // Need proper const propagator for these\n+                        GeneratorResumedAfterReturn |\n+                        GeneratorResumedAfterPanic => return,\n+                        Math(ref err) => err.description().to_owned(),\n+                        BoundsCheck { ref len, ref index } => {\n+                            let len = self.eval_operand(len).expect(\"len must be const\");\n+                            let len = match len.0 {\n+                                Value::ByVal(PrimVal::Bytes(n)) => n,\n+                                _ => bug!(\"const len not primitive: {:?}\", len),\n+                            };\n+                            let index = self\n+                                .eval_operand(index)\n+                                .expect(\"index must be const\");\n+                            let index = match index.0 {\n+                                Value::ByVal(PrimVal::Bytes(n)) => n,\n+                                _ => bug!(\"const index not primitive: {:?}\", index),\n+                            };\n+                            format!(\n+                                \"index out of bounds: \\\n+                                the len is {} but the index is {}\",\n+                                len,\n+                                index,\n+                            )\n+                        },\n+                    };\n+                    self.tcx.lint_node(\n+                        ::rustc::lint::builtin::CONST_ERR,\n+                        node_id,\n+                        span,\n+                        &msg,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "2e8dd623d744d4a406efb540b09bf0e4accabba7", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -19,6 +19,7 @@ use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -541,7 +542,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             ty: self.tcx.types.bool,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Bool(val),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val as u128))),\n                     ty: self.tcx.types.bool\n                 })\n             }"}, {"sha": "0ff735694338808f6af2b7007c2589426432b53e", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -68,7 +68,6 @@ use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, LivenessMode};\n-use rustc_const_math::ConstInt;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use std::collections::HashMap;\n@@ -80,6 +79,7 @@ use transform::simplify;\n use transform::no_landing_pads::no_landing_pads;\n use dataflow::{do_dataflow, DebugFormatted, state_for_location};\n use dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n+use rustc::mir::interpret::{Value, PrimVal};\n \n pub struct StateTransform;\n \n@@ -181,7 +181,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(state_disc.into()))),\n                     ty: self.tcx.types.u32\n                 }),\n             },\n@@ -534,7 +534,7 @@ fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Copy(transform.make_field(transform.state_field, tcx.types.u32)),\n         switch_ty: tcx.types.u32,\n-        values: Cow::from(cases.iter().map(|&(i, _)| ConstInt::U32(i)).collect::<Vec<_>>()),\n+        values: Cow::from(cases.iter().map(|&(i, _)| i.into()).collect::<Vec<_>>()),\n         targets: cases.iter().map(|&(_, d)| d).chain(once(default_block)).collect(),\n     };\n \n@@ -698,7 +698,7 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Bool(false),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                     ty: tcx.types.bool\n                 }),\n             },"}, {"sha": "b8a0e0f89073dc09c263f3d08e3bf8c96b778735", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -207,6 +207,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             return false;\n         }\n \n+        // Do not inline {u,i}128 lang items, trans const eval depends\n+        // on detecting calls to these lang items and intercepting them\n+        if tcx.is_binop_lang_item(callsite.callee).is_some() {\n+            debug!(\"    not inlining 128bit integer lang item\");\n+            return false;\n+        }\n+\n         let trans_fn_attrs = tcx.trans_fn_attrs(callsite.callee);\n \n         let hinted = match trans_fn_attrs.inline {"}, {"sha": "81b740c917b5e492e4045b7ca2fccf830879d50d", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -41,6 +41,7 @@ pub mod dump_mir;\n pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n+pub mod const_prop;\n pub mod generator;\n pub mod inline;\n pub mod lower_128bit;\n@@ -265,6 +266,8 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         generator::StateTransform,\n \n         instcombine::InstCombine,\n+        const_prop::ConstProp,\n+        simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n         deaggregator::Deaggregator,\n         copy_prop::CopyPropagation,\n         remove_noop_landing_pads::RemoveNoopLandingPads,"}, {"sha": "88618122e4f1137d5e0fe7b8b90849fc2d0cf640", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -690,7 +690,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             _ => false\n                         }\n                     } else if let ty::TyArray(_, len) = ty.sty {\n-                        len.val.to_const_int().unwrap().to_u64().unwrap() == 0 &&\n+                        len.val.unwrap_u64() == 0 &&\n                             self.mode == Mode::Fn\n                     } else {\n                         false"}, {"sha": "9dd48952208a9bed86565fb603ffdbaca8bf1927", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -13,6 +13,7 @@\n use rustc::ty::{self, TyCtxt};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n+use rustc::mir::interpret::{Value, PrimVal};\n use transform::{MirPass, MirSource};\n \n use std::borrow::Cow;\n@@ -40,10 +41,10 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), ref values, ref targets, .. } => {\n-                    if let Some(ref constint) = value.val.to_const_int() {\n+                    if let Some(constint) = value.val.to_raw_bits() {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n-                        for (v, t) in values.iter().zip(targets.iter()) {\n+                        for (&v, t) in values.iter().zip(targets.iter()) {\n                             if v == constint {\n                                 ret = TerminatorKind::Goto { target: *t };\n                                 break;\n@@ -56,9 +57,12 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n                     literal: Literal::Value {\n-                        value: &ty::Const { val: ConstVal::Bool(cond), .. }\n+                        value: &ty::Const {\n+                            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(cond))),\n+                        .. }\n                     }, ..\n-                }), expected, .. } if cond == expected => {\n+                }), expected, .. } if (cond == 1) == expected => {\n+                    assert!(cond <= 1);\n                     TerminatorKind::Goto { target: target }\n                 },\n                 TerminatorKind::FalseEdges { real_target, .. } => {"}, {"sha": "9cc3ffb30638fe78945d485a482235b0ee7e0f92", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -81,8 +81,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                 } else {\n                     let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n                     if let ty::TyArray(item_ty, const_size) = place_ty.sty {\n-                        if let Some(size) = const_size.val.to_const_int().and_then(|v| v.to_u64()) {\n-                            assert!(size <= (u32::max_value() as u64),\n+                        if let Some(size) = const_size.val.to_raw_bits() {\n+                            assert!(size <= (u32::max_value() as u128),\n                                     \"unform array move out doesn't supported\n                                      for array bigger then u32\");\n                             self.uniform(location, dst_place, proj, item_ty, size as u32);\n@@ -203,7 +203,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                         let opt_size = opt_src_place.and_then(|src_place| {\n                             let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n                             if let ty::TyArray(_, ref size_o) = src_ty.sty {\n-                                size_o.val.to_const_int().and_then(|v| v.to_u64())\n+                                size_o.val.to_raw_bits().map(|n| n as u64)\n                             } else {\n                                 None\n                             }"}, {"sha": "458dd488409e4101cd9872867028871f16cc5b00", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -11,13 +11,14 @@\n use std::fmt;\n use rustc::hir;\n use rustc::mir::*;\n-use rustc::middle::const_val::{ConstInt, ConstVal};\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::util::IntTypeExt;\n use rustc_data_structures::indexed_vec::Idx;\n use util::patch::MirPatch;\n+use rustc::mir::interpret::{Value, PrimVal};\n \n use std::{iter, u32};\n \n@@ -425,7 +426,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     variant_path,\n                     &adt.variants[variant_index],\n                     substs);\n-                values.push(discr);\n+                values.push(discr.val);\n                 if let Unwind::To(unwind) = unwind {\n                     // We can't use the half-ladder from the original\n                     // drop ladder, because this breaks the\n@@ -480,7 +481,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn adt_switch_block(&mut self,\n                         adt: &'tcx ty::AdtDef,\n                         blocks: Vec<BasicBlock>,\n-                        values: &[ConstInt],\n+                        values: &[u128],\n                         succ: BasicBlock,\n                         unwind: Unwind)\n                         -> BasicBlock {\n@@ -803,7 +804,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n             ty::TyArray(ety, size) => self.open_drop_for_array(\n-                ety, size.val.to_const_int().and_then(|v| v.to_u64())),\n+                ety, size.val.to_raw_bits().map(|i| i as u64)),\n             ty::TySlice(ety) => self.open_drop_for_array(ety, None),\n \n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n@@ -949,7 +950,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty: self.tcx().types.usize,\n             literal: Literal::Value {\n                 value: self.tcx().mk_const(ty::Const {\n-                    val: ConstVal::Integral(self.tcx().const_usize(val)),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.into()))),\n                     ty: self.tcx().types.usize\n                 })\n             }"}, {"sha": "4bab24ae1392c1198fc1c8dba27ce64607ebfea6", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -11,7 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_mir = { path = \"../librustc_mir\"}\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "7a54fc72d53cc68a54aa3bd28c012b4df49a759b", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -31,23 +31,6 @@ const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n */\n-E0030: r##\"\n-When matching against a range, the compiler verifies that the range is\n-non-empty.  Range patterns include both end-points, so this is equivalent to\n-requiring the start of the range to be less than or equal to the end of the\n-range.\n-\n-For example:\n-\n-```compile_fail\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 ... 1 => {}\n-    // This range is empty, and the compiler can tell.\n-    1000 ... 5 => {}\n-}\n-```\n-\"##,\n \n E0130: r##\"\n You declared a pattern as an argument in a foreign function declaration.\n@@ -228,24 +211,6 @@ impl Foo for Bar {\n \"##,\n \n \n-E0579: r##\"\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n-\n-For example:\n-\n-```compile_fail\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 .. 2 => {}\n-    // This range is empty, and the compiler can tell.\n-    5 .. 5 => {}\n-}\n-```\n-\"##,\n-\n E0590: r##\"\n `break` or `continue` must include a label when used in the condition of a\n `while` loop."}, {"sha": "1f6cc1f71fc0876c8e198b2bb8ff6327e33ec7af", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -23,7 +23,7 @@\n \n #[macro_use]\n extern crate rustc;\n-extern crate rustc_const_eval;\n+extern crate rustc_mir;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n \n@@ -39,13 +39,13 @@ use rustc::ty::maps::Providers;\n mod diagnostics;\n \n pub mod ast_validation;\n-pub mod consts;\n+pub mod rvalue_promotion;\n pub mod hir_stats;\n pub mod loops;\n mod mir_stats;\n \n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }\n \n pub fn provide(providers: &mut Providers) {\n-    consts::provide(providers);\n+    rvalue_promotion::provide(providers);\n }"}, {"sha": "4a4ce63cc1d4e7f6c81dfcefdcc2dcd36b604a08", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,7 +12,6 @@\n // pieces of MIR. The resulting numbers are good approximations but not\n // completely accurate (some things might be counted twice, others missed).\n \n-use rustc_const_math::{ConstUsize};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, Local, LocalDecl};\n use rustc::mir::{Place, PlaceElem, PlaceProjection};\n@@ -265,13 +264,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_const(constant);\n     }\n \n-    fn visit_const_usize(&mut self,\n-                         const_usize: &ConstUsize,\n-                         _: Location) {\n-        self.record(\"ConstUsize\", const_usize);\n-        self.super_const_usize(const_usize);\n-    }\n-\n     fn visit_local_decl(&mut self,\n                         local: Local,\n                         local_decl: &LocalDecl<'tcx>) {"}, {"sha": "16278c37a0cc0cba6a06e1c2b72197f1734aa125", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "renamed", "additions": 4, "deletions": 119, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -25,33 +25,23 @@\n // by borrowck::gather_loans\n \n use rustc::ty::cast::CastKind;\n-use rustc_const_eval::ConstContext;\n-use rustc::middle::const_val::ConstEvalErr;\n-use rustc::middle::const_val::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll};\n-use rustc::middle::const_val::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n-use rustc::middle::const_val::ErrKind::{TypeckError, Math, LayoutError};\n-use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::maps::{queries, Providers};\n+use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n-use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::{ItemLocalSet, NodeSet};\n-use rustc::lint::builtin::CONST_ERR;\n-use rustc::hir::{self, PatKind, RangeEnd};\n+use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n-use std::cmp::Ordering;\n-\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         rvalue_promotable_map,\n@@ -124,29 +114,6 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n-    fn const_cx(&self) -> ConstContext<'a, 'gcx> {\n-        ConstContext::new(self.tcx, self.param_env.and(self.identity_substs), self.tables)\n-    }\n-\n-    fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n-        if let Err(err) = self.const_cx().eval(expr) {\n-            match err.kind {\n-                UnimplementedConstVal(_) => {}\n-                IndexOpFeatureGated => {}\n-                ErroneousReferencedConstant(_) => {}\n-                TypeckError => {}\n-                MiscCatchAll => {}\n-                _ => {\n-                    self.tcx.lint_node(CONST_ERR,\n-                                       expr.id,\n-                                       expr.span,\n-                                       &format!(\"constant evaluation error: {}\",\n-                                                err.description().into_oneline()));\n-                }\n-            }\n-        }\n-    }\n-\n     // Returns true iff all the values of the type are promotable.\n     fn type_has_only_promotable_values(&mut self, ty: Ty<'gcx>) -> bool {\n         ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n@@ -196,9 +163,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         self.identity_substs = Substs::identity_for_item(self.tcx, item_def_id);\n \n         let body = self.tcx.hir.body(body_id);\n-        if !self.in_fn {\n-            self.check_const_eval(&body.value);\n-        }\n \n         let tcx = self.tcx;\n         let param_env = self.param_env;\n@@ -214,52 +178,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         self.identity_substs = outer_identity_substs;\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        match p.node {\n-            PatKind::Lit(ref lit) => {\n-                self.check_const_eval(lit);\n-            }\n-            PatKind::Range(ref start, ref end, RangeEnd::Excluded) => {\n-                match self.const_cx().compare_lit_exprs(p.span, start, end) {\n-                    Ok(Ordering::Less) => {}\n-                    Ok(Ordering::Equal) |\n-                    Ok(Ordering::Greater) => {\n-                        span_err!(self.tcx.sess,\n-                                  start.span,\n-                                  E0579,\n-                                  \"lower range bound must be less than upper\");\n-                    }\n-                    Err(ErrorReported) => {}\n-                }\n-            }\n-            PatKind::Range(ref start, ref end, RangeEnd::Included) => {\n-                match self.const_cx().compare_lit_exprs(p.span, start, end) {\n-                    Ok(Ordering::Less) |\n-                    Ok(Ordering::Equal) => {}\n-                    Ok(Ordering::Greater) => {\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            start.span,\n-                            E0030,\n-                            \"lower range bound must be less than or equal to upper\"\n-                        );\n-                        err.span_label(start.span, \"lower bound larger than upper bound\");\n-                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                            err.note(\"When matching against a range, the compiler verifies that \\\n-                                      the range is non-empty. Range patterns include both \\\n-                                      end-points, so this is equivalent to requiring the start of \\\n-                                      the range to be less than or equal to the end of the range.\");\n-                        }\n-                        err.emit();\n-                    }\n-                    Err(ErrorReported) => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_pat(self, p);\n-    }\n-\n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n         match stmt.node {\n             hir::StmtDecl(ref decl, _) => {\n@@ -308,30 +226,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.promotable = false;\n         }\n \n-        if self.in_fn && self.promotable {\n-            match self.const_cx().eval(ex) {\n-                Ok(_) => {}\n-                Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n-                Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n-                Err(ConstEvalErr { kind: MiscBinaryOp, .. }) |\n-                Err(ConstEvalErr { kind: NonConstPath, .. }) |\n-                Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), .. }) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n-                Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n-                Err(ConstEvalErr { kind: TypeckError, .. }) => {}\n-                Err(ConstEvalErr {\n-                    kind: LayoutError(ty::layout::LayoutError::Unknown(_)), ..\n-                }) => {}\n-                Err(msg) => {\n-                    self.tcx.lint_node(CONST_ERR,\n-                                       ex.id,\n-                                       msg.span,\n-                                       &msg.description().into_oneline().into_owned());\n-                }\n-            }\n-        }\n-\n         if self.promotable {\n             self.result.insert(ex.hir_id.local_id);\n         }\n@@ -397,7 +291,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n \n                 // References to a static that are themselves within a static\n                 // are inherently promotable with the exception\n-                //  of \"#[thread_loca]\" statics, which may not\n+                //  of \"#[thread_local]\" statics, which may not\n                 // outlive the current function\n                 Def::Static(did, _) => {\n \n@@ -431,16 +325,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                         // Don't peek inside trait associated constants.\n                         false\n                     } else {\n-                        queries::const_is_rvalue_promotable_to_static::try_get(v.tcx, e.span, did)\n-                            .unwrap_or_else(|mut err| {\n-                                // A cycle between constants ought to be reported elsewhere.\n-                                err.cancel();\n-                                v.tcx.sess.delay_span_bug(\n-                                    e.span,\n-                                    &format!(\"cycle encountered during const qualification: {:?}\",\n-                                             did));\n-                                false\n-                            })\n+                        v.tcx.at(e.span).const_is_rvalue_promotable_to_static(did)\n                     };\n \n                     // Just in case the type is more specific than the definition,", "previous_filename": "src/librustc_passes/consts.rs"}, {"sha": "49a5b7ac8b907281b18697f1d63fb77f6f782a67", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -195,7 +195,7 @@ pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n-            C_usize(cx, len.val.to_const_int().unwrap().to_u64().unwrap())\n+            C_usize(cx, len.val.unwrap_u64())\n         }\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n@@ -334,14 +334,6 @@ pub fn cast_shift_expr_rhs(\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n-pub fn cast_shift_const_rhs(op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    cast_shift_rhs(op,\n-                   lhs,\n-                   rhs,\n-                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n-                   |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n-}\n-\n fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n                         lhs: ValueRef,\n                         rhs: ValueRef,\n@@ -980,6 +972,8 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n             collector::collect_crate_mono_items(tcx, collection_mode)\n     });\n \n+    tcx.sess.abort_if_errors();\n+\n     ::rustc_mir::monomorphize::assert_symbols_are_distinct(tcx, items.iter());\n \n     let strategy = if tcx.sess.opts.incremental.is_some() {"}, {"sha": "122b51dbbb778cab5551fbad85d9ea5fec630ef1", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -13,7 +13,6 @@ use llvm::{SetUnnamedAddr};\n use llvm::{ValueRef, True};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n use monomorphize::MonoItem;\n@@ -247,12 +246,15 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                               def_id: DefId,\n                               is_mutable: bool,\n-                              attrs: &[ast::Attribute])\n-                              -> Result<ValueRef, ConstEvalErr<'tcx>> {\n+                              attrs: &[ast::Attribute]) {\n     unsafe {\n         let g = get_static(cx, def_id);\n \n-        let v = ::mir::trans_static_initializer(cx, def_id)?;\n+        let v = match ::mir::trans_static_initializer(cx, def_id) {\n+            Ok(v) => v,\n+            // Error has already been reported\n+            Err(_) => return,\n+        };\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n@@ -316,7 +318,5 @@ pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n             cx.used_statics.borrow_mut().push(cast);\n         }\n-\n-        Ok(g)\n     }\n }"}, {"sha": "d20b51ca0fdf4fd3606ceb58b7d0d7efa1590254", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -276,7 +276,7 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     let upper_bound = match array_or_slice_type.sty {\n         ty::TyArray(_, len) => {\n-            len.val.to_const_int().unwrap().to_u64().unwrap() as c_longlong\n+            len.val.unwrap_u64() as c_longlong\n         }\n         _ => -1\n     };\n@@ -1378,7 +1378,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n-                    discr.to_u128_unchecked() as u64)\n+                    discr.val as u64)\n             }\n         })\n         .collect();"}, {"sha": "a88eb9ae354718eaa696d8c01bb8fbd3867e9c80", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -97,7 +97,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::TyArray(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push_str(&format!(\"; {}\", len.val.to_const_int().unwrap().to_u64().unwrap()));\n+            output.push_str(&format!(\"; {}\", len.val.unwrap_u64()));\n             output.push(']');\n         },\n         ty::TySlice(inner_type) => {"}, {"sha": "dd34dc0345886aa1f08f13cb46a60cf4e6c527d7", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -13,8 +13,7 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc::middle::const_val::ConstVal;\n-use rustc::mir::{self, Location, TerminatorKind, Literal};\n+use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::mir::traversal;\n use rustc::ty;\n@@ -109,23 +108,25 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                              block: mir::BasicBlock,\n                              kind: &mir::TerminatorKind<'tcx>,\n                              location: Location) {\n-        match *kind {\n+        let check = match *kind {\n             mir::TerminatorKind::Call {\n-                func: mir::Operand::Constant(box mir::Constant {\n-                    literal: Literal::Value {\n-                        value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n-                    }, ..\n-                }),\n+                func: mir::Operand::Constant(ref c),\n                 ref args, ..\n-            } if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() => {\n+            } => match c.ty.sty {\n+                ty::TyFnDef(did, _) => Some((did, args)),\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        if let Some((def_id, args)) = check {\n+            if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n                 if let mir::Operand::Move(ref place) = args[0] {\n                     self.visit_place(place, PlaceContext::Drop, location);\n                 }\n             }\n-            _ => {}\n         }\n \n         self.super_terminator_kind(block, kind, location);"}, {"sha": "efb5338f680af1cc5d792bea56ae727ba6f9902e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -10,7 +10,6 @@\n \n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n-use rustc::middle::const_val::{ConstEvalErr, ConstInt, ErrKind};\n use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::traits;\n@@ -19,7 +18,7 @@ use abi::{Abi, FnType, ArgType, PassMode};\n use base;\n use callee;\n use builder::Builder;\n-use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n+use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_uint_big, C_undef};\n use consts;\n use meth;\n use monomorphize;\n@@ -30,7 +29,6 @@ use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::Const;\n use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n@@ -196,19 +194,21 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 if switch_ty == bx.tcx().types.bool {\n                     let lltrue = llblock(self, targets[0]);\n                     let llfalse = llblock(self, targets[1]);\n-                    if let [ConstInt::U8(0)] = values[..] {\n+                    if let [0] = values[..] {\n                         bx.cond_br(discr.immediate(), llfalse, lltrue);\n                     } else {\n+                        assert_eq!(&values[..], &[1]);\n                         bx.cond_br(discr.immediate(), lltrue, llfalse);\n                     }\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n                                             llblock(self, *otherwise), values.len());\n-                    for (value, target) in values.iter().zip(targets) {\n-                        let val = Const::from_constint(bx.cx, value);\n+                    let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n+                    for (&value, target) in values.iter().zip(targets) {\n+                        let llval = C_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n-                        bx.add_case(switch, val.llval, llbb)\n+                        bx.add_case(switch, llval, llbb)\n                     }\n                 }\n             }\n@@ -351,26 +351,18 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     .max(tcx.data_layout.pointer_align);\n \n                 // Put together the arguments to the panic entry point.\n-                let (lang_item, args, const_err) = match *msg {\n+                let (lang_item, args) = match *msg {\n                     mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n                         let len = self.trans_operand(&mut bx, len).immediate();\n                         let index = self.trans_operand(&mut bx, index).immediate();\n \n-                        let const_err = common::const_to_opt_u128(len, false)\n-                            .and_then(|len| common::const_to_opt_u128(index, false)\n-                                .map(|index| ErrKind::IndexOutOfBounds {\n-                                    len: len as u64,\n-                                    index: index as u64\n-                                }));\n-\n                         let file_line_col = C_struct(bx.cx, &[filename, line, col], false);\n                         let file_line_col = consts::addr_of(bx.cx,\n                                                             file_line_col,\n                                                             align,\n                                                             \"panic_bounds_check_loc\");\n                         (lang_items::PanicBoundsCheckFnLangItem,\n-                         vec![file_line_col, index, len],\n-                         const_err)\n+                         vec![file_line_col, index, len])\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = Symbol::intern(err.description()).as_str();\n@@ -383,8 +375,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                                                 align,\n                                                                 \"panic_loc\");\n                         (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line_col],\n-                         Some(ErrKind::Math(err.clone())))\n+                         vec![msg_file_line_col])\n                     }\n                     mir::AssertMessage::GeneratorResumedAfterReturn |\n                     mir::AssertMessage::GeneratorResumedAfterPanic => {\n@@ -403,23 +394,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                                                 align,\n                                                                 \"panic_loc\");\n                         (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line_col],\n-                         None)\n+                         vec![msg_file_line_col])\n                     }\n                 };\n \n-                // If we know we always panic, and the error message\n-                // is also constant, then we can produce a warning.\n-                if const_cond == Some(!expected) {\n-                    if let Some(err) = const_err {\n-                        let err = ConstEvalErr{ span: span, kind: err };\n-                        let mut diag = bx.tcx().sess.struct_span_warn(\n-                            span, \"this expression will panic at run-time\");\n-                        err.note(bx.tcx(), span, \"expression\", &mut diag);\n-                        diag.emit();\n-                    }\n-                }\n-\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n@@ -529,10 +507,13 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                     span_bug!(span, \"shuffle indices must be constant\");\n                                 }\n                                 mir::Operand::Constant(ref constant) => {\n-                                    let val = self.trans_constant(&bx, constant);\n+                                    let (llval, ty) = self.simd_shuffle_indices(\n+                                        &bx,\n+                                        constant,\n+                                    );\n                                     return OperandRef {\n-                                        val: Immediate(val.llval),\n-                                        layout: bx.cx.layout_of(val.ty)\n+                                        val: Immediate(llval),\n+                                        layout: bx.cx.layout_of(ty)\n                                     };\n                                 }\n                             }"}, {"sha": "6aa8b7e5449fd1e6037d0e0ef7cfa2b41ee762df", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 181, "deletions": 1293, "changes": 1474, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,1341 +9,229 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n-use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n-use rustc_const_math::ConstInt::*;\n-use rustc_const_math::{ConstInt, ConstMathErr, MAX_F32_PLUS_HALF_ULP};\n+use rustc::middle::const_val::{ConstVal, ConstEvalErr};\n+use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n-use rustc::infer::TransNormalize;\n use rustc::traits;\n use rustc::mir;\n-use rustc::mir::tcx::PlaceTy;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutOf, Size};\n-use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc_apfloat::{ieee, Float, Status};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use base;\n-use abi::{self, Abi};\n-use callee;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc::mir::interpret::{Allocation, GlobalId, MemoryPointer, PrimVal, Value as MiriValue};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar};\n use builder::Builder;\n-use common::{self, CodegenCx, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_uint_big, C_u32, C_u64};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, C_fat_ptr};\n-use common::const_to_opt_u128;\n+use common::{CodegenCx};\n+use common::{C_bytes, C_struct, C_uint_big, C_undef, C_usize};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n-use value::Value;\n+use syntax::ast::Mutability;\n \n-use syntax_pos::Span;\n-use syntax::ast;\n-\n-use std::fmt;\n-use std::ptr;\n-\n-use super::operand::{OperandRef, OperandValue};\n+use super::super::callee;\n use super::FunctionCx;\n \n-/// A sized constant rvalue.\n-/// The LLVM type might not be the same for a single Rust type,\n-/// e.g. each enum variant would have its own LLVM struct type.\n-#[derive(Copy, Clone)]\n-pub struct Const<'tcx> {\n-    pub llval: ValueRef,\n-    pub ty: Ty<'tcx>\n-}\n-\n-impl<'a, 'tcx> Const<'tcx> {\n-    pub fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n-        Const {\n-            llval,\n-            ty,\n-        }\n-    }\n-\n-    pub fn from_constint(cx: &CodegenCx<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n-        let tcx = cx.tcx;\n-        let (llval, ty) = match *ci {\n-            I8(v) => (C_int(Type::i8(cx), v as i64), tcx.types.i8),\n-            I16(v) => (C_int(Type::i16(cx), v as i64), tcx.types.i16),\n-            I32(v) => (C_int(Type::i32(cx), v as i64), tcx.types.i32),\n-            I64(v) => (C_int(Type::i64(cx), v as i64), tcx.types.i64),\n-            I128(v) => (C_uint_big(Type::i128(cx), v as u128), tcx.types.i128),\n-            Isize(v) => (C_int(Type::isize(cx), v.as_i64()), tcx.types.isize),\n-            U8(v) => (C_uint(Type::i8(cx), v as u64), tcx.types.u8),\n-            U16(v) => (C_uint(Type::i16(cx), v as u64), tcx.types.u16),\n-            U32(v) => (C_uint(Type::i32(cx), v as u64), tcx.types.u32),\n-            U64(v) => (C_uint(Type::i64(cx), v), tcx.types.u64),\n-            U128(v) => (C_uint_big(Type::i128(cx), v), tcx.types.u128),\n-            Usize(v) => (C_uint(Type::isize(cx), v.as_u64()), tcx.types.usize),\n-        };\n-        Const { llval: llval, ty: ty }\n-    }\n-\n-    /// Translate ConstVal into a LLVM constant value.\n-    pub fn from_constval(cx: &CodegenCx<'a, 'tcx>,\n-                         cv: &ConstVal,\n-                         ty: Ty<'tcx>)\n-                         -> Const<'tcx> {\n-        let llty = cx.layout_of(ty).llvm_type(cx);\n-        let val = match *cv {\n-            ConstVal::Float(v) => {\n-                let bits = match v.ty {\n-                    ast::FloatTy::F32 => C_u32(cx, v.bits as u32),\n-                    ast::FloatTy::F64 => C_u64(cx, v.bits as u64)\n-                };\n-                consts::bitcast(bits, llty)\n-            }\n-            ConstVal::Bool(v) => C_bool(cx, v),\n-            ConstVal::Integral(ref i) => return Const::from_constint(cx, i),\n-            ConstVal::Str(ref v) => C_str_slice(cx, v.clone()),\n-            ConstVal::ByteStr(v) => {\n-                consts::addr_of(cx, C_bytes(cx, v.data), cx.align_of(ty), \"byte_str\")\n-            }\n-            ConstVal::Char(c) => C_uint(Type::char(cx), c as u64),\n-            ConstVal::Function(..) => C_undef(llty),\n-            ConstVal::Variant(_) |\n-            ConstVal::Aggregate(..) |\n-            ConstVal::Unevaluated(..) => {\n-                bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n-            }\n-        };\n-\n-        assert!(!ty.has_erasable_regions());\n-\n-        Const::new(val, ty)\n-    }\n-\n-    fn get_field(&self, cx: &CodegenCx<'a, 'tcx>, i: usize) -> ValueRef {\n-        let layout = cx.layout_of(self.ty);\n-        let field = layout.field(cx, i);\n-        if field.is_zst() {\n-            return C_undef(field.immediate_llvm_type(cx));\n-        }\n-        let offset = layout.fields.offset(i);\n-        match layout.abi {\n-            layout::Abi::Scalar(_) |\n-            layout::Abi::ScalarPair(..) |\n-            layout::Abi::Vector { .. }\n-                if offset.bytes() == 0 && field.size == layout.size => self.llval,\n-\n-            layout::Abi::ScalarPair(ref a, ref b) => {\n-                if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(cx));\n-                    const_get_elt(self.llval, 0)\n-                } else {\n-                    assert_eq!(offset, a.value.size(cx)\n-                        .abi_align(b.value.align(cx)));\n-                    assert_eq!(field.size, b.value.size(cx));\n-                    const_get_elt(self.llval, 1)\n-                }\n-            }\n-            _ => {\n-                match layout.fields {\n-                    layout::FieldPlacement::Union(_) => self.llval,\n-                    _ => const_get_elt(self.llval, layout.llvm_field_index(i)),\n-                }\n-            }\n-        }\n-    }\n-\n-    fn get_pair(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n-        (self.get_field(cx, 0), self.get_field(cx, 1))\n-    }\n-\n-    fn get_fat_ptr(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n-        assert_eq!(abi::FAT_PTR_ADDR, 0);\n-        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.get_pair(cx)\n-    }\n-\n-    fn as_place(&self) -> ConstPlace<'tcx> {\n-        ConstPlace {\n-            base: Base::Value(self.llval),\n-            llextra: ptr::null_mut(),\n-            ty: self.ty\n-        }\n-    }\n-\n-    pub fn to_operand(&self, cx: &CodegenCx<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let layout = cx.layout_of(self.ty);\n-        let llty = layout.immediate_llvm_type(cx);\n-        let llvalty = val_ty(self.llval);\n-\n-        let val = if llty == llvalty && layout.is_llvm_scalar_pair() {\n-            OperandValue::Pair(\n-                const_get_elt(self.llval, 0),\n-                const_get_elt(self.llval, 1))\n-        } else if llty == llvalty && layout.is_llvm_immediate() {\n-            // If the types match, we can use the value directly.\n-            OperandValue::Immediate(self.llval)\n-        } else {\n-            // Otherwise, or if the value is not immediate, we create\n-            // a constant LLVM global and cast its address if necessary.\n-            let align = cx.align_of(self.ty);\n-            let ptr = consts::addr_of(cx, self.llval, align, \"const\");\n-            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(cx).ptr_to()),\n-                              layout.align)\n-        };\n-\n-        OperandRef {\n-            val,\n-            layout\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for Const<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Const({:?}: {:?})\", Value(self.llval), self.ty)\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-enum Base {\n-    /// A constant value without an unique address.\n-    Value(ValueRef),\n-\n-    /// String literal base pointer (cast from array).\n-    Str(ValueRef),\n-\n-    /// The address of a static.\n-    Static(ValueRef)\n-}\n-\n-/// A place as seen from a constant.\n-#[derive(Copy, Clone)]\n-struct ConstPlace<'tcx> {\n-    base: Base,\n-    llextra: ValueRef,\n-    ty: Ty<'tcx>\n-}\n-\n-impl<'tcx> ConstPlace<'tcx> {\n-    fn to_const(&self, span: Span) -> Const<'tcx> {\n-        match self.base {\n-            Base::Value(val) => Const::new(val, self.ty),\n-            Base::Str(ptr) => {\n-                span_bug!(span, \"loading from `str` ({:?}) in constant\",\n-                          Value(ptr))\n-            }\n-            Base::Static(val) => {\n-                span_bug!(span, \"loading from `static` ({:?}) in constant\",\n-                          Value(val))\n-            }\n-        }\n-    }\n-\n-    pub fn len<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n-        match self.ty.sty {\n-            ty::TyArray(_, n) => {\n-                C_usize(cx, n.val.to_const_int().unwrap().to_u64().unwrap())\n-            }\n-            ty::TySlice(_) | ty::TyStr => {\n-                assert!(self.llextra != ptr::null_mut());\n-                self.llextra\n-            }\n-            _ => bug!(\"unexpected type `{}` in ConstPlace::len\", self.ty)\n-        }\n-    }\n-}\n-\n-/// Machinery for translating a constant's MIR to LLVM values.\n-/// FIXME(eddyb) use miri and lower its allocations to LLVM.\n-struct MirConstContext<'a, 'tcx: 'a> {\n-    cx: &'a CodegenCx<'a, 'tcx>,\n-    mir: &'a mir::Mir<'tcx>,\n-\n-    /// Type parameters for const fn and associated constants.\n-    substs: &'tcx Substs<'tcx>,\n-\n-    /// Values of locals in a constant or const fn.\n-    locals: IndexVec<mir::Local, Option<Result<Const<'tcx>, ConstEvalErr<'tcx>>>>\n-}\n-\n-fn add_err<'tcx, U, V>(failure: &mut Result<U, ConstEvalErr<'tcx>>,\n-                       value: &Result<V, ConstEvalErr<'tcx>>)\n-{\n-    if let &Err(ref err) = value {\n-        if failure.is_ok() {\n-            *failure = Err(err.clone());\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n-    fn new(cx: &'a CodegenCx<'a, 'tcx>,\n-           mir: &'a mir::Mir<'tcx>,\n-           substs: &'tcx Substs<'tcx>,\n-           args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n-           -> MirConstContext<'a, 'tcx> {\n-        let mut context = MirConstContext {\n-            cx,\n-            mir,\n-            substs,\n-            locals: (0..mir.local_decls.len()).map(|_| None).collect(),\n-        };\n-        for (i, arg) in args.into_iter().enumerate() {\n-            // Locals after local 0 are the function arguments\n-            let index = mir::Local::new(i + 1);\n-            context.locals[index] = Some(arg);\n-        }\n-        context\n-    }\n-\n-    fn trans_def(cx: &'a CodegenCx<'a, 'tcx>,\n-                 def_id: DefId,\n-                 substs: &'tcx Substs<'tcx>,\n-                 args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n-                 -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = ty::Instance::resolve(cx.tcx,\n-                                             ty::ParamEnv::empty(traits::Reveal::All),\n-                                             def_id,\n-                                             substs).unwrap();\n-        let mir = cx.tcx.instance_mir(instance.def);\n-        MirConstContext::new(cx, &mir, instance.substs, args).trans()\n-    }\n-\n-    fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        self.cx.tcx.trans_apply_param_substs(self.substs, value)\n-    }\n-\n-    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.cx.tcx;\n-        let mut bb = mir::START_BLOCK;\n-\n-        // Make sure to evaluate all statemenets to\n-        // report as many errors as we possibly can.\n-        let mut failure = Ok(());\n-\n-        loop {\n-            let data = &self.mir[bb];\n-            for statement in &data.statements {\n-                let span = statement.source_info.span;\n-                match statement.kind {\n-                    mir::StatementKind::Assign(ref dest, ref rvalue) => {\n-                        let ty = dest.ty(self.mir, tcx);\n-                        let ty = self.monomorphize(&ty).to_ty(tcx);\n-                        let value = self.const_rvalue(rvalue, ty, span);\n-                        add_err(&mut failure, &value);\n-                        self.store(dest, value, span);\n-                    }\n-                    mir::StatementKind::StorageLive(_) |\n-                    mir::StatementKind::StorageDead(_) |\n-                    mir::StatementKind::Validate(..) |\n-                    mir::StatementKind::EndRegion(_) |\n-                    mir::StatementKind::Nop => {}\n-                    mir::StatementKind::InlineAsm { .. } |\n-                    mir::StatementKind::SetDiscriminant{ .. } => {\n-                        span_bug!(span, \"{:?} should not appear in constants?\", statement.kind);\n-                    }\n-                }\n+pub fn primval_to_llvm(cx: &CodegenCx,\n+                       cv: PrimVal,\n+                       scalar: &Scalar,\n+                       llty: Type) -> ValueRef {\n+    let bits = if scalar.is_bool() { 1 } else { scalar.value.size(cx).bits() };\n+    match cv {\n+        PrimVal::Undef => C_undef(Type::ix(cx, bits)),\n+        PrimVal::Bytes(b) => {\n+            let llval = C_uint_big(Type::ix(cx, bits), b);\n+            if scalar.value == layout::Pointer {\n+                unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n+            } else {\n+                consts::bitcast(llval, llty)\n             }\n-\n-            let terminator = data.terminator();\n-            let span = terminator.source_info.span;\n-            bb = match terminator.kind {\n-                mir::TerminatorKind::Drop { target, .. } | // No dropping.\n-                mir::TerminatorKind::Goto { target } => target,\n-                mir::TerminatorKind::Return => {\n-                    failure?;\n-                    return self.locals[mir::RETURN_PLACE].clone().unwrap_or_else(|| {\n-                        span_bug!(span, \"no returned value in constant\");\n-                    });\n-                }\n-\n-                mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, .. } => {\n-                    let cond = self.const_operand(cond, span)?;\n-                    let cond_bool = common::const_to_uint(cond.llval) != 0;\n-                    if cond_bool != expected {\n-                        let err = match *msg {\n-                            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                                let len = self.const_operand(len, span)?;\n-                                let index = self.const_operand(index, span)?;\n-                                ErrKind::IndexOutOfBounds {\n-                                    len: common::const_to_uint(len.llval),\n-                                    index: common::const_to_uint(index.llval)\n-                                }\n-                            }\n-                            mir::AssertMessage::Math(ref err) => {\n-                                ErrKind::Math(err.clone())\n-                            }\n-                            mir::AssertMessage::GeneratorResumedAfterReturn |\n-                            mir::AssertMessage::GeneratorResumedAfterPanic =>\n-                                span_bug!(span, \"{:?} should not appear in constants?\", msg),\n-                        };\n-\n-                        let err = ConstEvalErr { span: span, kind: err };\n-                        err.report(tcx, span, \"expression\");\n-                        failure = Err(err);\n-                    }\n-                    target\n-                }\n-\n-                mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                    let fn_ty = func.ty(self.mir, tcx);\n-                    let fn_ty = self.monomorphize(&fn_ty);\n-                    let (def_id, substs) = match fn_ty.sty {\n-                        ty::TyFnDef(def_id, substs) => (def_id, substs),\n-                        _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n-                                       func, fn_ty)\n-                    };\n-\n-                    let mut arg_vals = IndexVec::with_capacity(args.len());\n-                    for arg in args {\n-                        let arg_val = self.const_operand(arg, span);\n-                        add_err(&mut failure, &arg_val);\n-                        arg_vals.push(arg_val);\n-                    }\n-                    if let Some((ref dest, target)) = *destination {\n-                        let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n-                            match &tcx.item_name(def_id)[..] {\n-                                \"size_of\" => {\n-                                    let llval = C_usize(self.cx,\n-                                        self.cx.size_of(substs.type_at(0)).bytes());\n-                                    Ok(Const::new(llval, tcx.types.usize))\n-                                }\n-                                \"min_align_of\" => {\n-                                    let llval = C_usize(self.cx,\n-                                        self.cx.align_of(substs.type_at(0)).abi());\n-                                    Ok(Const::new(llval, tcx.types.usize))\n-                                }\n-                                \"type_id\" => {\n-                                    let llval = C_u64(self.cx,\n-                                        self.cx.tcx.type_id_hash(substs.type_at(0)));\n-                                    Ok(Const::new(llval, tcx.types.u64))\n-                                }\n-                                _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n-                            }\n-                        } else if let Some((op, is_checked)) = self.is_binop_lang_item(def_id) {\n-                            (||{\n-                                assert_eq!(arg_vals.len(), 2);\n-                                let rhs = arg_vals.pop().unwrap()?;\n-                                let lhs = arg_vals.pop().unwrap()?;\n-                                if !is_checked {\n-                                    let binop_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                                    let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                                    Ok(Const::new(const_scalar_binop(op, lhs, rhs, binop_ty),\n-                                                  binop_ty))\n-                                } else {\n-                                    let ty = lhs.ty;\n-                                    let val_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                                    let binop_ty = tcx.intern_tup(&[val_ty, tcx.types.bool], false);\n-                                    let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                                    assert!(!ty.is_fp());\n-\n-                                    match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n-                                        Some((llval, of)) => {\n-                                            Ok(trans_const_adt(\n-                                                self.cx,\n-                                                binop_ty,\n-                                                &mir::AggregateKind::Tuple,\n-                                                &[\n-                                                    Const::new(llval, val_ty),\n-                                                    Const::new(C_bool(self.cx, of), tcx.types.bool)\n-                                                ]))\n-                                        }\n-                                        None => {\n-                                            span_bug!(span,\n-                                                \"{:?} got non-integer operands: {:?} and {:?}\",\n-                                                op, Value(lhs), Value(rhs));\n-                                        }\n-                                    }\n-                                }\n-                            })()\n-                        } else {\n-                            MirConstContext::trans_def(self.cx, def_id, substs, arg_vals)\n-                        };\n-                        add_err(&mut failure, &result);\n-                        self.store(dest, result, span);\n-                        target\n+        },\n+        PrimVal::Ptr(ptr) => {\n+            if let Some(fn_instance) = cx.tcx.interpret_interner.get_fn(ptr.alloc_id) {\n+                callee::get_fn(cx, fn_instance)\n+            } else {\n+                let static_ = cx\n+                    .tcx\n+                    .interpret_interner\n+                    .get_corresponding_static_def_id(ptr.alloc_id);\n+                let base_addr = if let Some(def_id) = static_ {\n+                    assert!(cx.tcx.is_static(def_id).is_some());\n+                    consts::get_static(cx, def_id)\n+                } else if let Some(alloc) = cx.tcx.interpret_interner\n+                                              .get_alloc(ptr.alloc_id) {\n+                    let init = global_initializer(cx, alloc);\n+                    if alloc.runtime_mutability == Mutability::Mutable {\n+                        consts::addr_of_mut(cx, init, alloc.align, \"byte_str\")\n                     } else {\n-                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind);\n-                    }\n-                }\n-                _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n-            };\n-        }\n-    }\n-\n-    fn is_binop_lang_item(&mut self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n-        let tcx = self.cx.tcx;\n-        let items = tcx.lang_items();\n-        let def_id = Some(def_id);\n-        if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n-        else if items.u128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n-        else if items.i128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n-        else if items.u128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n-        else if items.i128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n-        else if items.u128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n-        else if items.i128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n-        else if items.u128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n-        else if items.i128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n-        else if items.u128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n-        else if items.i128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n-        else if items.u128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n-        else if items.i128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n-        else if items.u128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n-        else if items.i128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n-        else if items.u128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n-        else if items.i128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n-        else if items.u128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n-        else if items.i128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n-        else if items.u128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n-        else if items.i128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n-        else if items.u128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n-        else if items.i128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n-        else if items.u128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n-        else { None }\n-    }\n-\n-    fn store(&mut self,\n-             dest: &mir::Place<'tcx>,\n-             value: Result<Const<'tcx>, ConstEvalErr<'tcx>>,\n-             span: Span) {\n-        if let mir::Place::Local(index) = *dest {\n-            self.locals[index] = Some(value);\n-        } else {\n-            span_bug!(span, \"assignment to {:?} in constant\", dest);\n-        }\n-    }\n-\n-    fn const_place(&self, place: &mir::Place<'tcx>, span: Span)\n-                    -> Result<ConstPlace<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.cx.tcx;\n-\n-        if let mir::Place::Local(index) = *place {\n-            return self.locals[index].clone().unwrap_or_else(|| {\n-                span_bug!(span, \"{:?} not initialized\", place)\n-            }).map(|v| v.as_place());\n-        }\n-\n-        let place = match *place {\n-            mir::Place::Local(_)  => bug!(), // handled above\n-            mir::Place::Static(box mir::Static { def_id, ty }) => {\n-                ConstPlace {\n-                    base: Base::Static(consts::get_static(self.cx, def_id)),\n-                    llextra: ptr::null_mut(),\n-                    ty: self.monomorphize(&ty),\n-                }\n-            }\n-            mir::Place::Projection(ref projection) => {\n-                let tr_base = self.const_place(&projection.base, span)?;\n-                let projected_ty = PlaceTy::Ty { ty: tr_base.ty }\n-                    .projection_ty(tcx, &projection.elem);\n-                let base = tr_base.to_const(span);\n-                let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n-                let has_metadata = self.cx.type_has_metadata(projected_ty);\n-\n-                let (projected, llextra) = match projection.elem {\n-                    mir::ProjectionElem::Deref => {\n-                        let (base, extra) = if !has_metadata {\n-                            (base.llval, ptr::null_mut())\n-                        } else {\n-                            base.get_fat_ptr(self.cx)\n-                        };\n-                        if self.cx.statics.borrow().contains_key(&base) {\n-                            (Base::Static(base), extra)\n-                        } else if let ty::TyStr = projected_ty.sty {\n-                            (Base::Str(base), extra)\n-                        } else {\n-                            let v = base;\n-                            let v = self.cx.const_unsized.borrow().get(&v).map_or(v, |&v| v);\n-                            let mut val = unsafe { llvm::LLVMGetInitializer(v) };\n-                            if val.is_null() {\n-                                span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n-                                          Value(base));\n-                            }\n-                            let layout = self.cx.layout_of(projected_ty);\n-                            if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-                                let i1_type = Type::i1(self.cx);\n-                                if scalar.is_bool() && val_ty(val) != i1_type {\n-                                    unsafe {\n-                                        val = llvm::LLVMConstTrunc(val, i1_type.to_ref());\n-                                    }\n-                                }\n-                            }\n-                            (Base::Value(val), extra)\n-                        }\n-                    }\n-                    mir::ProjectionElem::Field(ref field, _) => {\n-                        let llprojected = base.get_field(self.cx, field.index());\n-                        let llextra = if !has_metadata {\n-                            ptr::null_mut()\n-                        } else {\n-                            tr_base.llextra\n-                        };\n-                        (Base::Value(llprojected), llextra)\n-                    }\n-                    mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::Local(index));\n-                        let llindex = self.const_operand(index, span)?.llval;\n-\n-                        let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {\n-                            iv\n-                        } else {\n-                            span_bug!(span, \"index is not an integer-constant expression\")\n-                        };\n-\n-                        // Produce an undef instead of a LLVM assertion on OOB.\n-                        let len = common::const_to_uint(tr_base.len(self.cx));\n-                        let llelem = if iv < len as u128 {\n-                            const_get_elt(base.llval, iv as u64)\n-                        } else {\n-                            C_undef(self.cx.layout_of(projected_ty).llvm_type(self.cx))\n-                        };\n-\n-                        (Base::Value(llelem), ptr::null_mut())\n-                    }\n-                    _ => span_bug!(span, \"{:?} in constant\", projection.elem)\n-                };\n-                ConstPlace {\n-                    base: projected,\n-                    llextra,\n-                    ty: projected_ty\n-                }\n-            }\n-        };\n-        Ok(place)\n-    }\n-\n-    fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n-                     -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        debug!(\"const_operand({:?} @ {:?})\", operand, span);\n-        let result = match *operand {\n-            mir::Operand::Copy(ref place) |\n-            mir::Operand::Move(ref place) => {\n-                Ok(self.const_place(place, span)?.to_const(span))\n-            }\n-\n-            mir::Operand::Constant(ref constant) => {\n-                let ty = self.monomorphize(&constant.ty);\n-                match constant.literal.clone() {\n-                    mir::Literal::Promoted { index } => {\n-                        let mir = &self.mir.promoted[index];\n-                        MirConstContext::new(self.cx, mir, self.substs, IndexVec::new()).trans()\n-                    }\n-                    mir::Literal::Value { value } => {\n-                        if let ConstVal::Unevaluated(def_id, substs) = value.val {\n-                            let substs = self.monomorphize(&substs);\n-                            MirConstContext::trans_def(self.cx, def_id, substs, IndexVec::new())\n-                        } else {\n-                            Ok(Const::from_constval(self.cx, &value.val, ty))\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-        debug!(\"const_operand({:?} @ {:?}) = {:?}\", operand, span,\n-               result.as_ref().ok());\n-        result\n-    }\n-\n-    fn const_array(&self, array_ty: Ty<'tcx>, fields: &[ValueRef])\n-                   -> Const<'tcx>\n-    {\n-        let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n-            bug!(\"bad array type {:?}\", array_ty)\n-        });\n-        let llunitty = self.cx.layout_of(elem_ty).llvm_type(self.cx);\n-        // If the array contains enums, an LLVM array won't work.\n-        let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n-            C_array(llunitty, fields)\n-        } else {\n-            C_struct(self.cx, fields, false)\n-        };\n-        Const::new(val, array_ty)\n-    }\n-\n-    fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n-                    dest_ty: Ty<'tcx>, span: Span)\n-                    -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.cx.tcx;\n-        debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n-        let val = match *rvalue {\n-            mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n-\n-            mir::Rvalue::Repeat(ref elem, count) => {\n-                let elem = self.const_operand(elem, span)?;\n-                let size = count.as_u64();\n-                assert_eq!(size as usize as u64, size);\n-                let fields = vec![elem.llval; size as usize];\n-                self.const_array(dest_ty, &fields)\n-            }\n-\n-            mir::Rvalue::Aggregate(box mir::AggregateKind::Array(_), ref operands) => {\n-                // Make sure to evaluate all operands to\n-                // report as many errors as we possibly can.\n-                let mut fields = Vec::with_capacity(operands.len());\n-                let mut failure = Ok(());\n-                for operand in operands {\n-                    match self.const_operand(operand, span) {\n-                        Ok(val) => fields.push(val.llval),\n-                        Err(err) => if failure.is_ok() { failure = Err(err); }\n-                    }\n-                }\n-                failure?;\n-\n-                self.const_array(dest_ty, &fields)\n-            }\n-\n-            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                // Make sure to evaluate all operands to\n-                // report as many errors as we possibly can.\n-                let mut fields = Vec::with_capacity(operands.len());\n-                let mut failure = Ok(());\n-                for operand in operands {\n-                    match self.const_operand(operand, span) {\n-                        Ok(val) => fields.push(val),\n-                        Err(err) => if failure.is_ok() { failure = Err(err); }\n-                    }\n-                }\n-                failure?;\n-\n-                trans_const_adt(self.cx, dest_ty, kind, &fields)\n-            }\n-\n-            mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n-                let operand = self.const_operand(source, span)?;\n-                let cast_ty = self.monomorphize(&cast_ty);\n-\n-                let val = match *kind {\n-                    mir::CastKind::ReifyFnPointer => {\n-                        match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs) => {\n-                                if tcx.has_attr(def_id, \"rustc_args_required_const\") {\n-                                    bug!(\"reifying a fn ptr that requires \\\n-                                          const arguments\");\n-                                }\n-                                callee::resolve_and_get_fn(self.cx, def_id, substs)\n-                            }\n-                            _ => {\n-                                span_bug!(span, \"{} cannot be reified to a fn ptr\",\n-                                          operand.ty)\n-                            }\n-                        }\n-                    }\n-                    mir::CastKind::ClosureFnPointer => {\n-                        match operand.ty.sty {\n-                            ty::TyClosure(def_id, substs) => {\n-                                // Get the def_id for FnOnce::call_once\n-                                let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n-                                let call_once = tcx\n-                                    .global_tcx().associated_items(fn_once)\n-                                    .find(|it| it.kind == ty::AssociatedKind::Method)\n-                                    .unwrap().def_id;\n-                                // Now create its substs [Closure, Tuple]\n-                                let input = substs.closure_sig(def_id, tcx).input(0);\n-                                let input = tcx.erase_late_bound_regions_and_normalize(&input);\n-                                let substs = tcx.mk_substs([operand.ty, input]\n-                                    .iter().cloned().map(Kind::from));\n-                                callee::resolve_and_get_fn(self.cx, call_once, substs)\n-                            }\n-                            _ => {\n-                                bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n-                            }\n-                        }\n+                        consts::addr_of(cx, init, alloc.align, \"byte_str\")\n                     }\n-                    mir::CastKind::UnsafeFnPointer => {\n-                        // this is a no-op at the LLVM level\n-                        operand.llval\n-                    }\n-                    mir::CastKind::Unsize => {\n-                        let pointee_ty = operand.ty.builtin_deref(true)\n-                            .expect(\"consts: unsizing got non-pointer type\").ty;\n-                        let (base, old_info) = if !self.cx.type_is_sized(pointee_ty) {\n-                            // Normally, the source is a thin pointer and we are\n-                            // adding extra info to make a fat pointer. The exception\n-                            // is when we are upcasting an existing object fat pointer\n-                            // to use a different vtable. In that case, we want to\n-                            // load out the original data pointer so we can repackage\n-                            // it.\n-                            let (base, extra) = operand.get_fat_ptr(self.cx);\n-                            (base, Some(extra))\n-                        } else {\n-                            (operand.llval, None)\n-                        };\n-\n-                        let unsized_ty = cast_ty.builtin_deref(true)\n-                            .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                        let ptr_ty = self.cx.layout_of(unsized_ty).llvm_type(self.cx).ptr_to();\n-                        let base = consts::ptrcast(base, ptr_ty);\n-                        let info = base::unsized_info(self.cx, pointee_ty,\n-                                                      unsized_ty, old_info);\n-\n-                        if old_info.is_none() {\n-                            let prev_const = self.cx.const_unsized.borrow_mut()\n-                                                     .insert(base, operand.llval);\n-                            assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n-                        }\n-                        C_fat_ptr(self.cx, base, info)\n-                    }\n-                    mir::CastKind::Misc if self.cx.layout_of(operand.ty).is_llvm_immediate() => {\n-                        let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n-                        let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let cast_layout = self.cx.layout_of(cast_ty);\n-                        assert!(cast_layout.is_llvm_immediate());\n-                        let ll_t_out = cast_layout.immediate_llvm_type(self.cx);\n-                        let llval = operand.llval;\n-\n-                        let mut signed = false;\n-                        let l = self.cx.layout_of(operand.ty);\n-                        if let layout::Abi::Scalar(ref scalar) = l.abi {\n-                            if let layout::Int(_, true) = scalar.value {\n-                                signed = true;\n-                            }\n-                        }\n-\n-                        unsafe {\n-                            match (r_t_in, r_t_out) {\n-                                (CastTy::Int(_), CastTy::Int(_)) => {\n-                                    let s = signed as llvm::Bool;\n-                                    llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n-                                }\n-                                (CastTy::Int(_), CastTy::Float) => {\n-                                    cast_const_int_to_float(self.cx, llval, signed, ll_t_out)\n-                                }\n-                                (CastTy::Float, CastTy::Float) => {\n-                                    llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n-                                }\n-                                (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                    cast_const_float_to_int(self.cx, &operand,\n-                                                            true, ll_t_out, span)\n-                                }\n-                                (CastTy::Float, CastTy::Int(_)) => {\n-                                    cast_const_float_to_int(self.cx, &operand,\n-                                                            false, ll_t_out, span)\n-                                }\n-                                (CastTy::Ptr(_), CastTy::Ptr(_)) |\n-                                (CastTy::FnPtr, CastTy::Ptr(_)) |\n-                                (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n-                                    consts::ptrcast(llval, ll_t_out)\n-                                }\n-                                (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                    let s = signed as llvm::Bool;\n-                                    let usize_llval = llvm::LLVMConstIntCast(llval,\n-                                        self.cx.isize_ty.to_ref(), s);\n-                                    llvm::LLVMConstIntToPtr(usize_llval, ll_t_out.to_ref())\n-                                }\n-                                (CastTy::Ptr(_), CastTy::Int(_)) |\n-                                (CastTy::FnPtr, CastTy::Int(_)) => {\n-                                    llvm::LLVMConstPtrToInt(llval, ll_t_out.to_ref())\n-                                }\n-                                _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n-                            }\n-                        }\n-                    }\n-                    mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let l = self.cx.layout_of(operand.ty);\n-                        let cast = self.cx.layout_of(cast_ty);\n-                        if l.is_llvm_scalar_pair() {\n-                            let (data_ptr, meta) = operand.get_fat_ptr(self.cx);\n-                            if cast.is_llvm_scalar_pair() {\n-                                let data_cast = consts::ptrcast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(self.cx, 0));\n-                                C_fat_ptr(self.cx, data_cast, meta)\n-                            } else { // cast to thin-ptr\n-                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n-                                // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(self.cx);\n-                                consts::ptrcast(data_ptr, llcast_ty)\n-                            }\n-                        } else {\n-                            bug!(\"Unexpected non-fat-pointer operand\")\n-                        }\n-                    }\n-                };\n-                Const::new(val, cast_ty)\n-            }\n-\n-            mir::Rvalue::Ref(_, bk, ref place) => {\n-                let tr_place = self.const_place(place, span)?;\n-\n-                let ty = tr_place.ty;\n-                let ref_ty = tcx.mk_ref(tcx.types.re_erased,\n-                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() });\n-\n-                let base = match tr_place.base {\n-                    Base::Value(llval) => {\n-                        // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n-                        let align = if self.cx.type_is_sized(ty) {\n-                            self.cx.align_of(ty)\n-                        } else {\n-                            self.cx.tcx.data_layout.pointer_align\n-                        };\n-                        if let mir::BorrowKind::Mut { .. } = bk {\n-                            consts::addr_of_mut(self.cx, llval, align, \"ref_mut\")\n-                        } else {\n-                            consts::addr_of(self.cx, llval, align, \"ref\")\n-                        }\n-                    }\n-                    Base::Str(llval) |\n-                    Base::Static(llval) => llval\n-                };\n-\n-                let ptr = if self.cx.type_is_sized(ty) {\n-                    base\n                 } else {\n-                    C_fat_ptr(self.cx, base, tr_place.llextra)\n+                    bug!(\"missing allocation {:?}\", ptr.alloc_id);\n                 };\n-                Const::new(ptr, ref_ty)\n-            }\n-\n-            mir::Rvalue::Len(ref place) => {\n-                let tr_place = self.const_place(place, span)?;\n-                Const::new(tr_place.len(self.cx), tcx.types.usize)\n-            }\n-\n-            mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.const_operand(lhs, span)?;\n-                let rhs = self.const_operand(rhs, span)?;\n-                let ty = lhs.ty;\n-                let binop_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                Const::new(const_scalar_binop(op, lhs, rhs, ty), binop_ty)\n-            }\n-\n-            mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.const_operand(lhs, span)?;\n-                let rhs = self.const_operand(rhs, span)?;\n-                let ty = lhs.ty;\n-                let val_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                let binop_ty = tcx.intern_tup(&[val_ty, tcx.types.bool], false);\n-                let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                assert!(!ty.is_fp());\n-\n-                match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n-                    Some((llval, of)) => {\n-                        trans_const_adt(self.cx, binop_ty, &mir::AggregateKind::Tuple, &[\n-                            Const::new(llval, val_ty),\n-                            Const::new(C_bool(self.cx, of), tcx.types.bool)\n-                        ])\n-                    }\n-                    None => {\n-                        span_bug!(span, \"{:?} got non-integer operands: {:?} and {:?}\",\n-                                  rvalue, Value(lhs), Value(rhs));\n-                    }\n-                }\n-            }\n-\n-            mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.const_operand(operand, span)?;\n-                let lloperand = operand.llval;\n-                let llval = match op {\n-                    mir::UnOp::Not => {\n-                        unsafe {\n-                            llvm::LLVMConstNot(lloperand)\n-                        }\n-                    }\n-                    mir::UnOp::Neg => {\n-                        let is_float = operand.ty.is_fp();\n-                        unsafe {\n-                            if is_float {\n-                                llvm::LLVMConstFNeg(lloperand)\n-                            } else {\n-                                llvm::LLVMConstNeg(lloperand)\n-                            }\n-                        }\n-                    }\n-                };\n-                Const::new(llval, operand.ty)\n-            }\n-\n-            mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(self.cx.type_is_sized(ty));\n-                let llval = C_usize(self.cx, self.cx.size_of(ty).bytes());\n-                Const::new(llval, tcx.types.usize)\n-            }\n-\n-            _ => span_bug!(span, \"{:?} in constant\", rvalue)\n-        };\n-\n-        debug!(\"const_rvalue({:?}: {:?} @ {:?}) = {:?}\", rvalue, dest_ty, span, val);\n-\n-        Ok(val)\n-    }\n-\n-}\n-\n-fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n-    match t.sty {\n-        ty::TyInt(int_type) => const_to_opt_u128(value, true)\n-            .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n-                                                   tcx.sess.target.isize_ty)),\n-        ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n-            .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n-                                                     tcx.sess.target.usize_ty)),\n-        _ => None\n-\n-    }\n-}\n-\n-pub fn const_scalar_binop(op: mir::BinOp,\n-                          lhs: ValueRef,\n-                          rhs: ValueRef,\n-                          input_ty: Ty) -> ValueRef {\n-    assert!(!input_ty.is_simd());\n-    let is_float = input_ty.is_fp();\n-    let signed = input_ty.is_signed();\n-\n-    unsafe {\n-        match op {\n-            mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n-            mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n-\n-            mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n-            mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n-\n-            mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n-            mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n \n-            mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n-            mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n-            mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n-\n-            mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n-            mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n-            mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n-\n-            mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n-            mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n-            mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n-            mir::BinOp::Shl    => {\n-                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                llvm::LLVMConstShl(lhs, rhs)\n-            }\n-            mir::BinOp::Shr    => {\n-                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                if signed { llvm::LLVMConstAShr(lhs, rhs) }\n-                else      { llvm::LLVMConstLShr(lhs, rhs) }\n-            }\n-            mir::BinOp::Eq | mir::BinOp::Ne |\n-            mir::BinOp::Lt | mir::BinOp::Le |\n-            mir::BinOp::Gt | mir::BinOp::Ge => {\n-                if is_float {\n-                    let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n-                    llvm::LLVMConstFCmp(cmp, lhs, rhs)\n+                let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                    consts::bitcast(base_addr, Type::i8p(cx)),\n+                    &C_usize(cx, ptr.offset),\n+                    1,\n+                ) };\n+                if scalar.value != layout::Pointer {\n+                    unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n                 } else {\n-                    let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n-                                                                signed);\n-                    llvm::LLVMConstICmp(cmp, lhs, rhs)\n+                    consts::bitcast(llval, llty)\n                 }\n             }\n-            mir::BinOp::Offset => unreachable!(\"BinOp::Offset in const-eval!\")\n         }\n     }\n }\n \n-pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                            op: mir::BinOp,\n-                                            lllhs: ValueRef,\n-                                            llrhs: ValueRef,\n-                                            input_ty: Ty<'tcx>)\n-                                            -> Option<(ValueRef, bool)> {\n-    if let (Some(lhs), Some(rhs)) = (to_const_int(lllhs, input_ty, tcx),\n-                                     to_const_int(llrhs, input_ty, tcx)) {\n-        let result = match op {\n-            mir::BinOp::Add => lhs + rhs,\n-            mir::BinOp::Sub => lhs - rhs,\n-            mir::BinOp::Mul => lhs * rhs,\n-            mir::BinOp::Shl => lhs << rhs,\n-            mir::BinOp::Shr => lhs >> rhs,\n-            _ => {\n-                bug!(\"Operator `{:?}` is not a checkable operator\", op)\n-            }\n-        };\n+pub fn global_initializer(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n+    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n+    let layout = cx.data_layout();\n+    let pointer_size = layout.pointer_size.bytes() as usize;\n \n-        let of = match result {\n-            Ok(_) => false,\n-            Err(ConstMathErr::Overflow(_)) |\n-            Err(ConstMathErr::ShiftNegative) => true,\n-            Err(err) => {\n-                bug!(\"Operator `{:?}` on `{:?}` and `{:?}` errored: {}\",\n-                     op, lhs, rhs, err.description());\n-            }\n-        };\n-\n-        Some((const_scalar_binop(op, lllhs, llrhs, input_ty), of))\n-    } else {\n-        None\n+    let mut next_offset = 0;\n+    for (&offset, &alloc_id) in &alloc.relocations {\n+        assert_eq!(offset as usize as u64, offset);\n+        let offset = offset as usize;\n+        if offset > next_offset {\n+            llvals.push(C_bytes(cx, &alloc.bytes[next_offset..offset]));\n+        }\n+        let ptr_offset = read_target_uint(\n+            layout.endian,\n+            &alloc.bytes[offset..(offset + pointer_size)],\n+        ).expect(\"global_initializer: could not read relocation pointer\") as u64;\n+        llvals.push(primval_to_llvm(\n+            cx,\n+            PrimVal::Ptr(MemoryPointer { alloc_id, offset: ptr_offset }),\n+            &Scalar {\n+                value: layout::Primitive::Pointer,\n+                valid_range: 0..=!0\n+            },\n+            Type::i8p(cx)\n+        ));\n+        next_offset = offset + pointer_size;\n     }\n-}\n-\n-unsafe fn cast_const_float_to_int(cx: &CodegenCx,\n-                                  operand: &Const,\n-                                  signed: bool,\n-                                  int_ty: Type,\n-                                  span: Span) -> ValueRef {\n-    let llval = operand.llval;\n-    let float_bits = match operand.ty.sty {\n-        ty::TyFloat(fty) => fty.bit_width(),\n-        _ => bug!(\"cast_const_float_to_int: operand not a float\"),\n-    };\n-    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n-    // One way that might happen would be if addresses could be turned into integers in constant\n-    // expressions, but that doesn't appear to be possible?\n-    // In any case, an ICE is better than producing undef.\n-    let llval_bits = consts::bitcast(llval, Type::ix(cx, float_bits as u64));\n-    let bits = const_to_opt_u128(llval_bits, false).unwrap_or_else(|| {\n-        panic!(\"could not get bits of constant float {:?}\",\n-               Value(llval));\n-    });\n-    let int_width = int_ty.int_width() as usize;\n-    // Try to convert, but report an error for overflow and NaN. This matches HIR const eval.\n-    let cast_result = match float_bits {\n-        32 if signed => ieee::Single::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n-        64 if signed => ieee::Double::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n-        32 => ieee::Single::from_bits(bits).to_u128(int_width),\n-        64 => ieee::Double::from_bits(bits).to_u128(int_width),\n-        n => bug!(\"unsupported float width {}\", n),\n-    };\n-    if cast_result.status.contains(Status::INVALID_OP) {\n-        let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n-        err.report(cx.tcx, span, \"expression\");\n+    if alloc.bytes.len() >= next_offset {\n+        llvals.push(C_bytes(cx, &alloc.bytes[next_offset ..]));\n     }\n-    C_uint_big(int_ty, cast_result.value)\n-}\n \n-unsafe fn cast_const_int_to_float(cx: &CodegenCx,\n-                                  llval: ValueRef,\n-                                  signed: bool,\n-                                  float_ty: Type) -> ValueRef {\n-    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n-    // One way that might happen would be if addresses could be turned into integers in constant\n-    // expressions, but that doesn't appear to be possible?\n-    // In any case, an ICE is better than producing undef.\n-    let value = const_to_opt_u128(llval, signed).unwrap_or_else(|| {\n-        panic!(\"could not get z128 value of constant integer {:?}\",\n-               Value(llval));\n-    });\n-    if signed {\n-        llvm::LLVMConstSIToFP(llval, float_ty.to_ref())\n-    } else if float_ty.float_width() == 32 && value >= MAX_F32_PLUS_HALF_ULP {\n-        // We're casting to f32 and the value is > f32::MAX + 0.5 ULP -> round up to infinity.\n-        let infinity_bits = C_u32(cx, ieee::Single::INFINITY.to_bits() as u32);\n-        consts::bitcast(infinity_bits, float_ty)\n-    } else {\n-        llvm::LLVMConstUIToFP(llval, float_ty.to_ref())\n-    }\n+    C_struct(cx, &llvals, true)\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    pub fn trans_constant(&mut self,\n-                          bx: &Builder<'a, 'tcx>,\n-                          constant: &mir::Constant<'tcx>)\n-                          -> Const<'tcx>\n-    {\n-        debug!(\"trans_constant({:?})\", constant);\n-        let ty = self.monomorphize(&constant.ty);\n-        let result = match constant.literal.clone() {\n-            mir::Literal::Promoted { index } => {\n-                let mir = &self.mir.promoted[index];\n-                MirConstContext::new(bx.cx, mir, self.param_substs, IndexVec::new()).trans()\n-            }\n-            mir::Literal::Value { value } => {\n-                if let ConstVal::Unevaluated(def_id, substs) = value.val {\n-                    let substs = self.monomorphize(&substs);\n-                    MirConstContext::trans_def(bx.cx, def_id, substs, IndexVec::new())\n-                } else {\n-                    Ok(Const::from_constval(bx.cx, &value.val, ty))\n-                }\n-            }\n-        };\n-\n-        let result = result.unwrap_or_else(|_| {\n-            // We've errored, so we don't have to produce working code.\n-            let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n-            Const::new(C_undef(llty), ty)\n-        });\n-\n-        debug!(\"trans_constant({:?}) = {:?}\", constant, result);\n-        result\n-    }\n-}\n-\n-\n pub fn trans_static_initializer<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n-    MirConstContext::trans_def(cx, def_id, Substs::empty(), IndexVec::new())\n-        .map(|c| c.llval)\n-}\n-\n-/// Construct a constant value, suitable for initializing a\n-/// GlobalVariable, given a case and constant values for its fields.\n-/// Note that this may have a different LLVM type (and different\n-/// alignment!) from the representation's `type_of`, so it needs a\n-/// pointer cast before use.\n-///\n-/// The LLVM type system does not directly support unions, and only\n-/// pointers can be bitcast, so a constant (and, by extension, the\n-/// GlobalVariable initialized by it) will have a type that can vary\n-/// depending on which case of an enum it is.\n-///\n-/// To understand the alignment situation, consider `enum E { V64(u64),\n-/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n-/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n-/// i32, i32}`, which is 4-byte aligned.\n-///\n-/// Currently the returned value has the same size as the type, but\n-/// this could be changed in the future to avoid allocating unnecessary\n-/// space after values of shorter-than-maximum cases.\n-fn trans_const_adt<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    kind: &mir::AggregateKind,\n-    vals: &[Const<'tcx>]\n-) -> Const<'tcx> {\n-    let l = cx.layout_of(t);\n-    let variant_index = match *kind {\n-        mir::AggregateKind::Adt(_, index, _, _) => index,\n-        _ => 0,\n+    let instance = ty::Instance::mono(cx.tcx, def_id);\n+    let cid = GlobalId {\n+        instance,\n+        promoted: None\n     };\n+    let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+    cx.tcx.const_eval(param_env.and(cid))?;\n \n-    if let layout::Abi::Uninhabited = l.abi {\n-        return Const::new(C_undef(l.llvm_type(cx)), t);\n-    }\n+    let alloc_id = cx\n+        .tcx\n+        .interpret_interner\n+        .get_cached(def_id)\n+        .expect(\"global not cached\");\n \n-    match l.variants {\n-        layout::Variants::Single { index } => {\n-            assert_eq!(variant_index, index);\n-            if let layout::FieldPlacement::Union(_) = l.fields {\n-                assert_eq!(variant_index, 0);\n-                assert_eq!(vals.len(), 1);\n-                let (field_size, field_align) = cx.size_and_align_of(vals[0].ty);\n-                let contents = [\n-                    vals[0].llval,\n-                    padding(cx, l.size - field_size)\n-                ];\n+    let alloc = cx\n+        .tcx\n+        .interpret_interner\n+        .get_alloc(alloc_id)\n+        .expect(\"miri allocation never successfully created\");\n+    Ok(global_initializer(cx, alloc))\n+}\n \n-                let packed = l.align.abi() < field_align.abi();\n-                Const::new(C_struct(cx, &contents, packed), t)\n-            } else {\n-                if let layout::Abi::Vector { .. } = l.abi {\n-                    if let layout::FieldPlacement::Array { .. } = l.fields {\n-                        return Const::new(C_vector(&vals.iter().map(|x| x.llval)\n-                            .collect::<Vec<_>>()), t);\n-                    }\n-                }\n-                build_const_struct(cx, l, vals, None)\n-            }\n-        }\n-        layout::Variants::Tagged { .. } => {\n-            let discr = match *kind {\n-                mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    adt_def.discriminant_for_variant(cx.tcx, variant_index)\n-                           .to_u128_unchecked() as u64\n-                },\n-                _ => 0,\n-            };\n-            let discr_field = l.field(cx, 0);\n-            let discr = C_int(discr_field.llvm_type(cx), discr as i64);\n-            if let layout::Abi::Scalar(_) = l.abi {\n-                Const::new(discr, t)\n-            } else {\n-                let discr = Const::new(discr, discr_field.ty);\n-                build_const_struct(cx, l.for_variant(cx, variant_index), vals, Some(discr))\n-            }\n-        }\n-        layout::Variants::NicheFilling {\n-            dataful_variant,\n-            ref niche_variants,\n-            niche_start,\n-            ..\n-        } => {\n-            if variant_index == dataful_variant {\n-                build_const_struct(cx, l.for_variant(cx, dataful_variant), vals, None)\n-            } else {\n-                let niche = l.field(cx, 0);\n-                let niche_llty = niche.llvm_type(cx);\n-                let niche_value = ((variant_index - niche_variants.start) as u128)\n-                    .wrapping_add(niche_start);\n-                // FIXME(eddyb) Check the actual primitive type here.\n-                let niche_llval = if niche_value == 0 {\n-                    // HACK(eddyb) Using `C_null` as it works on all types.\n-                    C_null(niche_llty)\n-                } else {\n-                    C_uint_big(niche_llty, niche_value)\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+    fn const_to_miri_value(\n+        &mut self,\n+        bx: &Builder<'a, 'tcx>,\n+        constant: &'tcx ty::Const<'tcx>,\n+    ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n+        match constant.val {\n+            ConstVal::Unevaluated(def_id, ref substs) => {\n+                let tcx = bx.tcx();\n+                let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+                let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: None,\n                 };\n-                build_const_struct(cx, l, &[Const::new(niche_llval, niche.ty)], None)\n-            }\n+                let c = tcx.const_eval(param_env.and(cid))?;\n+                self.const_to_miri_value(bx, c)\n+            },\n+            ConstVal::Value(miri_val) => Ok(miri_val),\n         }\n     }\n-}\n-\n-/// Building structs is a little complicated, because we might need to\n-/// insert padding if a field's value is less aligned than its type.\n-///\n-/// Continuing the example from `trans_const_adt`, a value of type `(u32,\n-/// E)` should have the `E` at offset 8, but if that field's\n-/// initializer is 4-byte aligned then simply translating the tuple as\n-/// a two-element struct will locate it at offset 4, and accesses to it\n-/// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                layout: layout::TyLayout<'tcx>,\n-                                vals: &[Const<'tcx>],\n-                                discr: Option<Const<'tcx>>)\n-                                -> Const<'tcx> {\n-    assert_eq!(vals.len(), layout.fields.count());\n \n-    match layout.abi {\n-        layout::Abi::Scalar(_) |\n-        layout::Abi::ScalarPair(..) |\n-        layout::Abi::Vector { .. } if discr.is_none() => {\n-            let mut non_zst_fields = vals.iter().enumerate().map(|(i, f)| {\n-                (f, layout.fields.offset(i))\n-            }).filter(|&(f, _)| !cx.layout_of(f.ty).is_zst());\n-            match (non_zst_fields.next(), non_zst_fields.next()) {\n-                (Some((x, offset)), None) if offset.bytes() == 0 => {\n-                    return Const::new(x.llval, layout.ty);\n-                }\n-                (Some((a, a_offset)), Some((b, _))) if a_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(cx, &[a.llval, b.llval], false), layout.ty);\n-                }\n-                (Some((a, _)), Some((b, b_offset))) if b_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(cx, &[b.llval, a.llval], false), layout.ty);\n-                }\n-                _ => {}\n+    pub fn mir_constant_to_miri_value(\n+        &mut self,\n+        bx: &Builder<'a, 'tcx>,\n+        constant: &mir::Constant<'tcx>,\n+    ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n+        match constant.literal {\n+            mir::Literal::Promoted { index } => {\n+                let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+                let cid = mir::interpret::GlobalId {\n+                    instance: self.instance,\n+                    promoted: Some(index),\n+                };\n+                bx.tcx().const_eval(param_env.and(cid))\n             }\n-        }\n-        _ => {}\n-    }\n-\n-    // offset of current value\n-    let mut packed = false;\n-    let mut offset = Size::from_bytes(0);\n-    let mut cfields = Vec::new();\n-    cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n-\n-    if let Some(discr) = discr {\n-        let (field_size, field_align) = cx.size_and_align_of(discr.ty);\n-        packed |= layout.align.abi() < field_align.abi();\n-        cfields.push(discr.llval);\n-        offset = field_size;\n-    }\n-\n-    let parts = layout.fields.index_by_increasing_offset().map(|i| {\n-        (vals[i], layout.fields.offset(i))\n-    });\n-    for (val, target_offset) in parts {\n-        let (field_size, field_align) = cx.size_and_align_of(val.ty);\n-        packed |= layout.align.abi() < field_align.abi();\n-        cfields.push(padding(cx, target_offset - offset));\n-        cfields.push(val.llval);\n-        offset = target_offset + field_size;\n+            mir::Literal::Value { value } => {\n+                Ok(self.monomorphize(&value))\n+            }\n+        }.and_then(|c| self.const_to_miri_value(bx, c))\n+    }\n+\n+    /// process constant containing SIMD shuffle indices\n+    pub fn simd_shuffle_indices(\n+        &mut self,\n+        bx: &Builder<'a, 'tcx>,\n+        constant: &mir::Constant<'tcx>,\n+    ) -> (ValueRef, Ty<'tcx>) {\n+        self.mir_constant_to_miri_value(bx, constant)\n+            .and_then(|c| {\n+                let field_ty = constant.ty.builtin_index().unwrap();\n+                let fields = match constant.ty.sty {\n+                    ty::TyArray(_, n) => n.val.unwrap_u64(),\n+                    ref other => bug!(\"invalid simd shuffle type: {}\", other),\n+                };\n+                let values: Result<Vec<ValueRef>, _> = (0..fields).map(|field| {\n+                    let field = const_val_field(\n+                        bx.tcx(),\n+                        ty::ParamEnv::empty(traits::Reveal::All),\n+                        self.instance,\n+                        None,\n+                        mir::Field::new(field as usize),\n+                        c,\n+                        constant.ty,\n+                    )?;\n+                    match field.val {\n+                        ConstVal::Value(MiriValue::ByVal(prim)) => {\n+                            let layout = bx.cx.layout_of(field_ty);\n+                            let scalar = match layout.abi {\n+                                layout::Abi::Scalar(ref x) => x,\n+                                _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n+                            };\n+                            Ok(primval_to_llvm(\n+                                bx.cx, prim, scalar,\n+                                layout.immediate_llvm_type(bx.cx),\n+                            ))\n+                        },\n+                        other => bug!(\"simd shuffle field {:?}, {}\", other, constant.ty),\n+                    }\n+                }).collect();\n+                let llval = C_struct(bx.cx, &values?, false);\n+                Ok((llval, constant.ty))\n+            })\n+            .unwrap_or_else(|e| {\n+                e.report(bx.tcx(), constant.span, \"shuffle_indices\");\n+                // We've errored, so we don't have to produce working code.\n+                let ty = self.monomorphize(&constant.ty);\n+                let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n+                (C_undef(llty), ty)\n+            })\n     }\n-\n-    // Pad to the size of the whole type, not e.g. the variant.\n-    cfields.push(padding(cx, cx.size_of(layout.ty) - offset));\n-\n-    Const::new(C_struct(cx, &cfields, packed), layout.ty)\n-}\n-\n-fn padding(cx: &CodegenCx, size: Size) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(cx), size.bytes()))\n }"}, {"sha": "a1044ac87e4c550b394a85219ac86f5777ce783b", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -44,6 +44,8 @@ use self::operand::{OperandRef, OperandValue};\n \n /// Master context for translating MIR.\n pub struct FunctionCx<'a, 'tcx:'a> {\n+    instance: Instance<'tcx>,\n+\n     mir: &'a mir::Mir<'tcx>,\n \n     debug_context: debuginfo::FunctionDebugContext,\n@@ -227,6 +229,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let (landing_pads, funclets) = create_funclets(mir, &bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n+        instance,\n         mir,\n         llfn,\n         fn_ty,"}, {"sha": "75df349de41ee9d7075a90c36f407bd3e9157854", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 83, "deletions": 10, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,12 +9,15 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::middle::const_val::ConstEvalErr;\n use rustc::mir;\n+use rustc::mir::interpret::Value as MiriValue;\n+use rustc::ty;\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, CodegenCx, C_undef, C_usize};\n+use common::{self, CodegenCx, C_null, C_undef, C_usize};\n use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n@@ -24,6 +27,7 @@ use std::fmt;\n use std::ptr;\n \n use super::{FunctionCx, LocalRef};\n+use super::constant::{primval_to_llvm};\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -89,6 +93,70 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n+    pub fn from_const(bx: &Builder<'a, 'tcx>,\n+                      miri_val: MiriValue,\n+                      ty: ty::Ty<'tcx>)\n+                      -> Result<OperandRef<'tcx>, ConstEvalErr<'tcx>> {\n+        let layout = bx.cx.layout_of(ty);\n+\n+        if layout.is_zst() {\n+            return Ok(OperandRef::new_zst(bx.cx, layout));\n+        }\n+\n+        let val = match miri_val {\n+            MiriValue::ByVal(x) => {\n+                let scalar = match layout.abi {\n+                    layout::Abi::Scalar(ref x) => x,\n+                    _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n+                };\n+                let llval = primval_to_llvm(\n+                    bx.cx,\n+                    x,\n+                    scalar,\n+                    layout.immediate_llvm_type(bx.cx),\n+                );\n+                OperandValue::Immediate(llval)\n+            },\n+            MiriValue::ByValPair(a, b) => {\n+                let (a_scalar, b_scalar) = match layout.abi {\n+                    layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n+                    _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n+                };\n+                let a_llval = primval_to_llvm(\n+                    bx.cx,\n+                    a,\n+                    a_scalar,\n+                    layout.scalar_pair_element_llvm_type(bx.cx, 0),\n+                );\n+                let b_llval = primval_to_llvm(\n+                    bx.cx,\n+                    b,\n+                    b_scalar,\n+                    layout.scalar_pair_element_llvm_type(bx.cx, 1),\n+                );\n+                OperandValue::Pair(a_llval, b_llval)\n+            },\n+            MiriValue::ByRef(ptr, align) => {\n+                let scalar = layout::Scalar {\n+                    value: layout::Primitive::Pointer,\n+                    valid_range: 0..=!0\n+                };\n+                let ptr = primval_to_llvm(\n+                    bx.cx,\n+                    ptr.into_inner_primval(),\n+                    &scalar,\n+                    layout.llvm_type(bx.cx).ptr_to(),\n+                );\n+                return Ok(PlaceRef::new_sized(ptr, layout, align).load(bx));\n+            },\n+        };\n+\n+        Ok(OperandRef {\n+            val,\n+            layout\n+        })\n+    }\n+\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> ValueRef {\n@@ -327,14 +395,19 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let val = self.trans_constant(&bx, constant);\n-                let operand = val.to_operand(bx.cx);\n-                if let OperandValue::Ref(ptr, align) = operand.val {\n-                    // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    PlaceRef::new_sized(ptr, operand.layout, align).load(bx)\n-                } else {\n-                    operand\n-                }\n+                let ty = self.monomorphize(&constant.ty);\n+                self.mir_constant_to_miri_value(bx, constant)\n+                    .and_then(|c| OperandRef::from_const(bx, c, ty))\n+                    .unwrap_or_else(|err| {\n+                        err.report(bx.tcx(), constant.span, \"const operand\");\n+                        // We've errored, so we don't have to produce working code.\n+                        let layout = bx.cx.layout_of(ty);\n+                        PlaceRef::new_sized(\n+                            C_null(layout.llvm_type(bx.cx).ptr_to()),\n+                            layout,\n+                            layout.align,\n+                        ).load(bx)\n+                    })\n             }\n         }\n     }"}, {"sha": "b340d91b02708edf0eed3de96b9ff70c8cfb8cfd", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -328,7 +328,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 let ptr = self.project_field(bx, 0);\n                 let to = self.layout.ty.ty_adt_def().unwrap()\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n-                    .to_u128_unchecked() as u64;\n+                    .val as u64;\n                 bx.store(C_int(ptr.layout.llvm_type(bx.cx), to as i64),\n                     ptr.llval, ptr.align);\n             }"}, {"sha": "fa0514952d21373761aaedae3770c94a8f5cafe9", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -30,7 +30,6 @@ use type_of::LayoutLlvmExt;\n use value::Value;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n@@ -122,7 +121,6 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     }\n                 }\n \n-                let count = count.as_u64();\n                 let count = C_usize(bx.cx, count);\n                 let end = dest.project_index(&bx, count).llval;\n \n@@ -497,7 +495,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n-                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                    let n = n.val.unwrap_u64();\n                     return common::C_usize(bx.cx, n);\n                 }\n             }\n@@ -645,14 +643,6 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             return OperandValue::Pair(val, C_bool(bx.cx, false));\n         }\n \n-        // First try performing the operation on constants, which\n-        // will only succeed if both operands are constant.\n-        // This is necessary to determine when an overflow Assert\n-        // will always panic at runtime, and produce a warning.\n-        if let Some((val, of)) = const_scalar_checked_binop(bx.tcx(), op, lhs, rhs, input_ty) {\n-            return OperandValue::Pair(val, C_bool(bx.cx, of));\n-        }\n-\n         let (val, of) = match op {\n             // These are checked using intrinsics\n             mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {"}, {"sha": "06d94e8d15569a6be33bdfa1814802642de418e8", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -58,12 +58,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 };\n                 let attrs = tcx.get_attrs(def_id);\n \n-                match consts::trans_static(&cx, def_id, is_mutable, &attrs) {\n-                    Ok(_) => { /* Cool, everything's alright. */ },\n-                    Err(err) => {\n-                        err.report(tcx, tcx.def_span(def_id), \"static\");\n-                    }\n-                };\n+                consts::trans_static(&cx, def_id, is_mutable, &attrs);\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);"}, {"sha": "eb02c05fd3957112882bd15f0e94a25c2a54f96d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n                     ty::TyArray(inner_ty, size) => {\n-                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let size = size.val.unwrap_u64();\n                         let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n                             if min_len != size {"}, {"sha": "19085ff039ec5aa5aeded25ca1b1a137a0831581", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -93,13 +93,14 @@ use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n+use rustc::mir::interpret::{GlobalId};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n-use rustc::ty::util::{Representability, IntTypeExt};\n+use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use errors::{DiagnosticBuilder, DiagnosticId};\n \n use require_c_abi_if_variadic;\n@@ -132,7 +133,6 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map::Node;\n use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n-use rustc_const_math::ConstInt;\n \n mod autoderef;\n pub mod dropck;\n@@ -1631,10 +1631,10 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let mut disr_vals: Vec<ConstInt> = Vec::new();\n+    let mut disr_vals: Vec<Discr<'tcx>> = Vec::new();\n     for (discr, v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n-        if let Some(i) = disr_vals.iter().position(|&x| x == discr) {\n+        if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_i_node_id = tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n             let variant_i = tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n@@ -3999,10 +3999,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let count_def_id = tcx.hir.body_owner_def_id(count);\n             let param_env = ty::ParamEnv::empty(traits::Reveal::UserFacing);\n             let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n-            let count = tcx.const_eval(param_env.and((count_def_id, substs)));\n+            let instance = ty::Instance::resolve(\n+                tcx.global_tcx(),\n+                param_env,\n+                count_def_id,\n+                substs,\n+            ).unwrap();\n+            let global_id = GlobalId {\n+                instance,\n+                promoted: None\n+            };\n+            let count = tcx.const_eval(param_env.and(global_id));\n \n             if let Err(ref err) = count {\n-               err.report(tcx, tcx.def_span(count_def_id), \"constant expression\");\n+                err.report(tcx, tcx.def_span(count_def_id), \"constant expression\");\n             }\n \n             let uty = match expected {\n@@ -4029,9 +4039,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Ok(count) = count {\n-                let zero_or_one = count.val.to_const_int().and_then(|count| {\n-                    count.to_u64().map(|count| count <= 1)\n-                }).unwrap_or(false);\n+                let zero_or_one = count.val.to_raw_bits().map_or(false, |count| count <= 1);\n                 if !zero_or_one {\n                     // For [foo, ..n] where n > 1, `foo` must have\n                     // Copy type:"}, {"sha": "47a229cbd3b5b9f98b8bebc28cb2540f8874ef79", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -447,10 +447,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n                 hir::BiShl => (\"shl\", lang.shl_trait()),\n                 hir::BiShr => (\"shr\", lang.shr_trait()),\n-                hir::BiLt => (\"lt\", lang.ord_trait()),\n-                hir::BiLe => (\"le\", lang.ord_trait()),\n-                hir::BiGe => (\"ge\", lang.ord_trait()),\n-                hir::BiGt => (\"gt\", lang.ord_trait()),\n+                hir::BiLt => (\"lt\", lang.partial_ord_trait()),\n+                hir::BiLe => (\"le\", lang.partial_ord_trait()),\n+                hir::BiGe => (\"ge\", lang.partial_ord_trait()),\n+                hir::BiGt => (\"gt\", lang.partial_ord_trait()),\n                 hir::BiEq => (\"eq\", lang.eq_trait()),\n                 hir::BiNe => (\"ne\", lang.eq_trait()),\n                 hir::BiAnd | hir::BiOr => {"}, {"sha": "858d9fb5b749260b6cfb2bf812488c855ed17466", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -28,19 +28,15 @@ use astconv::{AstConv, Bounds};\n use lint;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n-use middle::const_val::ConstVal;\n use middle::resolve_lifetime as rl;\n use rustc::mir::mono::Linkage;\n-use rustc::traits::Reveal;\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n-use rustc::util::nodemap::FxHashSet;\n-use util::nodemap::FxHashMap;\n-\n-use rustc_const_math::ConstInt;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::ty::util::Discr;\n \n use syntax::{abi, ast};\n use syntax::ast::MetaItemKind;\n@@ -512,30 +508,17 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         variants: &[hir::Variant]) {\n-    let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n-    let mut prev_discr = None::<ConstInt>;\n+    let mut prev_discr = None::<Discr<'tcx>>;\n \n     // fill the discriminant values and field types\n     for variant in variants {\n-        let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n+        let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n-            let substs = Substs::identity_for_item(tcx, expr_did);\n-            let result = tcx.at(variant.span).const_eval(param_env.and((expr_did, substs)));\n-\n-            // enum variant evaluation happens before the global constant check\n-            // so we need to report the real error\n-            if let Err(ref err) = result {\n-                err.report(tcx, variant.span, \"enum discriminant\");\n-            }\n-\n-            match result {\n-                Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => Some(x),\n-                _ => None\n-            }\n+            def.eval_explicit_discr(tcx, expr_did)\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n             Some(discr)\n         } else {"}, {"sha": "bd2267a46010b1997e27c7e77807d466d8084062", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1020,41 +1020,6 @@ Here `X` will have already been specified the discriminant 0 by the time `Y` is\n encountered, so a conflict occurs.\n \"##,\n \n-E0082: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-When you specify enum discriminants with `=`, the compiler expects `isize`\n-values by default. Or you can add the `repr` attibute to the enum declaration\n-for an explicit choice of the discriminant type. In either cases, the\n-discriminant values must fall within a valid range for the expected type;\n-otherwise this error is raised. For example:\n-\n-```compile_fail\n-# #![deny(overflowing_literals)]\n-#[repr(u8)]\n-enum Thing {\n-    A = 1024,\n-    B = 5,\n-}\n-```\n-\n-Here, 1024 lies outside the valid range for `u8`, so the discriminant for `A` is\n-invalid. Here is another, more subtle example which depends on target word size:\n-\n-```compile_fail,E0080\n-# #[repr(i32)]\n-enum DependsOnPointerSize {\n-    A = 1 << 32,\n-}\n-```\n-\n-Here, `1 << 32` is interpreted as an `isize` value. So it is invalid for 32 bit\n-target (`target_pointer_width = \"32\"`) but valid for 64 bit target.\n-\n-You may want to change representation types to fix this, or else change invalid\n-discriminant values so that they fit within the existing type.\n-\"##,\n-\n E0084: r##\"\n An unsupported representation was attempted on a zero-variant enum.\n "}, {"sha": "40385cabf5661ba32e3f7055babd4487819f5d38", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -86,6 +86,7 @@ This API is completely unstable and subject to change.\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n+#![feature(i128_type)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "5d4addce2c43992174793767c6f694f7ede4ea26", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -34,6 +34,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime as rl;\n use rustc::ty::fold::TypeFolder;\n use rustc::middle::lang_items;\n+use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -51,7 +52,6 @@ use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n use std::fmt;\n \n-use rustc_const_math::ConstInt;\n use std::default::Default;\n use std::{mem, slice, vec};\n use std::iter::{FromIterator, once};\n@@ -2501,23 +2501,17 @@ impl Clean<Type> for hir::Ty {\n                 let def_id = cx.tcx.hir.body_owner_def_id(n);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = Substs::identity_for_item(cx.tcx, def_id);\n-                let n = cx.tcx.const_eval(param_env.and((def_id, substs))).unwrap_or_else(|_| {\n+                let cid = GlobalId {\n+                    instance: ty::Instance::new(def_id, substs),\n+                    promoted: None\n+                };\n+                let n = cx.tcx.const_eval(param_env.and(cid)).unwrap_or_else(|_| {\n                     cx.tcx.mk_const(ty::Const {\n                         val: ConstVal::Unevaluated(def_id, substs),\n                         ty: cx.tcx.types.usize\n                     })\n                 });\n-                let n = if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n-                    n.to_string()\n-                } else if let ConstVal::Unevaluated(def_id, _) = n.val {\n-                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n-                        print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n-                    } else {\n-                        inline::print_inlined_const(cx, def_id)\n-                    }\n-                } else {\n-                    format!(\"{:?}\", n)\n-                };\n+                let n = print_const(cx, n);\n                 Array(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n@@ -2636,21 +2630,15 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let mut n = cx.tcx.lift(&n).unwrap();\n                 if let ConstVal::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n-                    if let Ok(new_n) = cx.tcx.const_eval(param_env.and((def_id, substs))) {\n+                    let cid = GlobalId {\n+                        instance: ty::Instance::new(def_id, substs),\n+                        promoted: None\n+                    };\n+                    if let Ok(new_n) = cx.tcx.const_eval(param_env.and(cid)) {\n                         n = new_n;\n                     }\n                 };\n-                let n = if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n-                    n.to_string()\n-                } else if let ConstVal::Unevaluated(def_id, _) = n.val {\n-                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n-                        print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n-                    } else {\n-                        inline::print_inlined_const(cx, def_id)\n-                    }\n-                } else {\n-                    format!(\"{:?}\", n)\n-                };\n+                let n = print_const(cx, n);\n                 Array(box ty.clean(cx), n)\n             }\n             ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n@@ -3634,6 +3622,28 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n+fn print_const(cx: &DocContext, n: &ty::Const) -> String {\n+    match n.val {\n+        ConstVal::Unevaluated(def_id, _) => {\n+            if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n+                print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n+            } else {\n+                inline::print_inlined_const(cx, def_id)\n+            }\n+        },\n+        ConstVal::Value(val) => {\n+            let mut s = String::new();\n+            ::rustc::mir::print_miri_value(val, n.ty, &mut s).unwrap();\n+            // array lengths are obviously usize\n+            if s.ends_with(\"usize\") {\n+                let n = s.len() - \"usize\".len();\n+                s.truncate(n);\n+            }\n+            s\n+        },\n+    }\n+}\n+\n fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n     cx.tcx.hir.node_to_pretty_string(body.node_id)\n }"}, {"sha": "1a790bf78bd86172eb153630b7649042989f4663", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -217,9 +217,6 @@ declare_features! (\n     // Allows the definition of `const fn` functions.\n     (active, const_fn, \"1.2.0\", Some(24111)),\n \n-    // Allows indexing into constant arrays.\n-    (active, const_indexing, \"1.4.0\", Some(29947)),\n-\n     // Allows using #[prelude_import] on glob `use` items.\n     //\n     // rustc internal\n@@ -490,6 +487,8 @@ declare_features! (\n     (accepted, augmented_assignments, \"1.8.0\", Some(28235)),\n     // allow empty structs and enum variants with braces\n     (accepted, braced_empty_structs, \"1.8.0\", Some(29720)),\n+    // Allows indexing into constant arrays.\n+    (accepted, const_indexing, \"1.24.0\", Some(29947)),\n     (accepted, default_type_params, \"1.0.0\", None),\n     (accepted, globs, \"1.0.0\", None),\n     (accepted, if_let, \"1.0.0\", None),"}, {"sha": "bf9a832519ad9afa70d0787da2839bab44bf33d1", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -19,16 +19,37 @@ use hygiene::SyntaxContext;\n \n use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n+use std::hash::{Hash, Hasher};\n \n /// A compressed span.\n /// Contains either fields of `SpanData` inline if they are small, or index into span interner.\n /// The primary goal of `Span` is to be as small as possible and fit into other structures\n /// (that's why it uses `packed` as well). Decoding speed is the second priority.\n /// See `SpanData` for the info on span fields in decoded representation.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n #[repr(packed)]\n pub struct Span(u32);\n \n+impl Copy for Span {}\n+impl Clone for Span {\n+    fn clone(&self) -> Span {\n+        *self\n+    }\n+}\n+impl PartialEq for Span {\n+    fn eq(&self, other: &Span) -> bool {\n+        let a = self.0;\n+        let b = other.0;\n+        a == b\n+    }\n+}\n+impl Eq for Span {}\n+impl Hash for Span {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let a = self.0;\n+        a.hash(state)\n+    }\n+}\n+\n /// Dummy span, both position and length are zero, syntax context is zero as well.\n /// This span is kept inline and encoded with format 0.\n pub const DUMMY_SP: Span = Span(0);"}, {"sha": "007fb7f4596621c74a76a83f24a19d7757548515", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // compile-flags: -C no-prepopulate-passes\n+// ignore-tidy-linelength\n \n #![crate_type = \"lib\"]\n \n@@ -19,12 +20,11 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @ref.{{[0-9]+}} = {{.*}}, align 2\n+// CHECK: @byte_str.{{[0-9]+}} = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used\n-// CHECK: [[LOW_HIGH:@ref.[0-9]+]] = {{.*}}, align 4\n-// CHECK: [[LOW_HIGH_REF:@const.[0-9]+]] = {{.*}} [[LOW_HIGH]]\n+// CHECK: [[LOW_HIGH:@byte_str.[0-9]+]] = {{.*}}, align 4\n \n #[derive(Copy, Clone)]\n \n@@ -54,14 +54,14 @@ pub fn inline_enum_const() -> E<i8, i16> {\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: i8* getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0),\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: i8* getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0),\n     *&E::A(0)\n }"}, {"sha": "9c56a316b341cba7b9c3b5d45ebdb042213f7092", "filename": "src/test/codegen/link_section.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcodegen%2Flink_section.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcodegen%2Flink_section.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flink_section.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,7 +12,7 @@\n \n #![crate_type = \"lib\"]\n \n-// CHECK: @VAR1 = constant i32 1, section \".test_one\"\n+// CHECK: @VAR1 = constant <{ [4 x i8] }> <{ [4 x i8] c\"\\01\\00\\00\\00\" }>, section \".test_one\"\n #[no_mangle]\n #[link_section = \".test_one\"]\n pub static VAR1: u32 = 1;"}, {"sha": "4fb8c37558d48bbaa7ce1333709cbddf024bf8fa", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -22,7 +22,7 @@ mod aux_mod;\n include!(\"aux_mod.rs\");\n \n // Here we check that the expansion of the file!() macro is mapped.\n-// CHECK: internal constant [34 x i8] c\"/the/src/remap_path_prefix/main.rs\"\n+// CHECK: @byte_str.1 = private unnamed_addr constant <{ [34 x i8] }> <{ [34 x i8] c\"/the/src/remap_path_prefix/main.rs\" }>, align 1\n pub static FILE_PATH: &'static str = file!();\n \n fn main() {"}, {"sha": "02264228a6bf6d4ca8c03ba8b4d1f71bb946ec7e", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -15,4 +15,5 @@ fn f(x: usize) -> usize {\n fn main() {\n     let _ = [0; f(2)];\n     //~^ ERROR calls in constants are limited to constant functions\n+    //~| E0080\n }"}, {"sha": "3de0f1ff61e1cb4c148ba5ec1a3a7ba99bb7df7d", "filename": "src/test/compile-fail/const-err-early.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,17 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_indexing)]\n #![deny(const_err)]\n \n-pub const A: i8 = -std::i8::MIN; //~ ERROR attempt to negate with overflow\n-pub const B: u8 = 200u8 + 200u8; //~ ERROR attempt to add with overflow\n-pub const C: u8 = 200u8 * 4; //~ ERROR attempt to multiply with overflow\n-pub const D: u8 = 42u8 - (42u8 + 1); //~ ERROR attempt to subtract with overflow\n+pub const A: i8 = -std::i8::MIN; //~ ERROR E0080\n+//~^ ERROR attempt to negate with overflow\n+//~| ERROR constant evaluation error\n+pub const B: u8 = 200u8 + 200u8; //~ ERROR E0080\n+//~^ ERROR attempt to add with overflow\n+pub const C: u8 = 200u8 * 4; //~ ERROR E0080\n+//~^ ERROR attempt to multiply with overflow\n+pub const D: u8 = 42u8 - (42u8 + 1); //~ ERROR E0080\n+//~^ ERROR attempt to subtract with overflow\n pub const E: u8 = [5u8][1];\n-//~^ ERROR index out of bounds: the len is 1 but the index is 1\n+//~^ ERROR E0080\n \n fn main() {\n+    let _a = A;\n+    let _b = B;\n+    let _c = C;\n+    let _d = D;\n+    let _e = E;\n     let _e = [6u8][1];\n-    //~^ ERROR index out of bounds: the len is 1 but the index is 1\n }"}, {"sha": "d2355f57f17294c5ed97c40a951d97b4de2764d9", "filename": "src/test/compile-fail/const-err-multi.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err-multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err-multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err-multi.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -10,10 +10,17 @@\n \n #![deny(const_err)]\n \n-pub const A: i8 = -std::i8::MIN; //~ ERROR attempt to negate with overflow\n+pub const A: i8 = -std::i8::MIN;\n+//~^ ERROR E0080\n+//~| ERROR attempt to negate with overflow\n+//~| ERROR constant evaluation error\n pub const B: i8 = A;\n+//~^ ERROR E0080\n pub const C: u8 = A as u8;\n+//~^ ERROR E0080\n pub const D: i8 = 50 - A;\n+//~^ ERROR E0080\n \n fn main() {\n+    let _ = (A, B, C, D);\n }"}, {"sha": "8bd759b6d3735fe4cf9d266cd0f02fc6524e651f", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -26,26 +26,5 @@ const FOO: u8 = [5u8][1];\n //~| index out of bounds: the len is 1 but the index is 1\n \n fn main() {\n-    let a = -std::i8::MIN;\n-    //~^ WARN this expression will panic at run-time\n-    //~| attempt to negate with overflow\n-    let b = 200u8 + 200u8 + 200u8;\n-    //~^ WARN this expression will panic at run-time\n-    //~^^ WARN this expression will panic at run-time\n-    //~| attempt to add with overflow\n-    let c = 200u8 * 4;\n-    //~^ WARN this expression will panic at run-time\n-    //~| attempt to multiply with overflow\n-    let d = 42u8 - (42u8 + 1);\n-    //~^ WARN this expression will panic at run-time\n-    //~| attempt to subtract with overflow\n-    let _e = [5u8][1];\n-    //~^ WARN this expression will panic at run-time\n-    //~| index out of bounds: the len is 1 but the index is 1\n-    black_box(a);\n-    black_box(b);\n-    black_box(c);\n-    black_box(d);\n-\n     black_box((FOO, FOO));\n }"}, {"sha": "46b73371e56cf554ee652cb136a67b9d28132877", "filename": "src/test/compile-fail/const-err2.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// needed because negating int::MIN will behave differently between\n+// optimized compilation and unoptimized compilation and thus would\n+// lead to different lints being emitted\n+// compile-flags: -O\n+\n #![feature(rustc_attrs)]\n #![allow(exceeding_bitshifts)]\n #![deny(const_err)]\n@@ -18,13 +23,13 @@ fn black_box<T>(_: T) {\n \n fn main() {\n     let a = -std::i8::MIN;\n-    //~^ ERROR attempt to negate with overflow\n+    //~^ ERROR const_err\n     let b = 200u8 + 200u8 + 200u8;\n-    //~^ ERROR attempt to add with overflow\n+    //~^ ERROR const_err\n     let c = 200u8 * 4;\n-    //~^ ERROR attempt to multiply with overflow\n+    //~^ ERROR const_err\n     let d = 42u8 - (42u8 + 1);\n-    //~^ ERROR attempt to subtract with overflow\n+    //~^ ERROR const_err\n     let _e = [5u8][1];\n     black_box(a);\n     black_box(b);"}, {"sha": "9656af6002442c6369dd86120e9cb3008cb96b6f", "filename": "src/test/compile-fail/const-err3.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![deny(const_err)]\n+\n+fn black_box<T>(_: T) {\n+    unimplemented!()\n+}\n+\n+fn main() {\n+    let b = 200u8 + 200u8 + 200u8;\n+    //~^ ERROR const_err\n+    let c = 200u8 * 4;\n+    //~^ ERROR const_err\n+    let d = 42u8 - (42u8 + 1);\n+    //~^ ERROR const_err\n+    let _e = [5u8][1];\n+    black_box(b);\n+    black_box(c);\n+    black_box(d);\n+}"}, {"sha": "058a8d0a1bd4f5532dde59920b1783be1c71c2b8", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unused_imports)]\n-\n-// Note: the relevant lint pass here runs before some of the constant\n-// evaluation below (e.g. that performed by trans and llvm), so if you\n-// change this warn to a deny, then the compiler will exit before\n-// those errors are detected.\n-\n-#![warn(const_err)]\n-\n-use std::fmt;\n-use std::{i8, i16, i32, i64, isize};\n-use std::{u8, u16, u32, u64, usize};\n-\n-const VALS_I8: (i8, i8, i8, i8) =\n-    (-i8::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i8::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i8::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i8::MIN * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_I16: (i16, i16, i16, i16) =\n-    (-i16::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i16::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i16::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i16::MIN * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_I32: (i32, i32, i32, i32) =\n-    (-i32::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i32::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i32::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i32::MIN * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_I64: (i64, i64, i64, i64) =\n-    (-i64::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i64::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i64::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i64::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U8: (u8, u8, u8, u8) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u8::MIN as i8) as u8,\n-     u8::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u8::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u8::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U16: (u16, u16, u16, u16) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u16::MIN as i16) as u16,\n-     u16::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u16::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u16::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U32: (u32, u32, u32, u32) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u32::MIN as i32) as u32,\n-     u32::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u32::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u32::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U64: (u64, u64, u64, u64) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u64::MIN as i64) as u64,\n-     u64::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u64::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u64::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-fn main() {\n-    foo(VALS_I8);\n-    foo(VALS_I16);\n-    foo(VALS_I32);\n-    foo(VALS_I64);\n-\n-    foo(VALS_U8);\n-    foo(VALS_U16);\n-    foo(VALS_U32);\n-    foo(VALS_U64);\n-}\n-\n-fn foo<T:fmt::Debug>(x: T) {\n-    println!(\"{:?}\", x);\n-}"}, {"sha": "a0d8f9672c05e1519ffb37e72705dae40315ca4e", "filename": "src/test/compile-fail/const-eval-overflow2.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+\n+#![deny(const_err)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8,) =\n+    (\n+     i8::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+const VALS_I16: (i16,) =\n+    (\n+     i16::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+const VALS_I32: (i32,) =\n+    (\n+     i32::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+const VALS_I64: (i64,) =\n+    (\n+     i64::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+const VALS_U8: (u8,) =\n+    (\n+     u8::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+const VALS_U16: (u16,) = (\n+     u16::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+const VALS_U32: (u32,) = (\n+     u32::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+const VALS_U64: (u64,) =\n+    (\n+     u64::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to subtract with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T>(_: T) {\n+}"}, {"sha": "08128f90e532f368a16185a155bcbe0b5ac13104", "filename": "src/test/compile-fail/const-eval-overflow2b.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+\n+#![deny(const_err)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8,) =\n+    (\n+     i8::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+const VALS_I16: (i16,) =\n+    (\n+     i16::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+const VALS_I32: (i32,) =\n+    (\n+     i32::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+const VALS_I64: (i64,) =\n+    (\n+     i64::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+const VALS_U8: (u8,) =\n+    (\n+     u8::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+const VALS_U16: (u16,) = (\n+     u16::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+const VALS_U32: (u32,) = (\n+     u32::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+const VALS_U64: (u64,) =\n+    (\n+     u64::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to add with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T>(_: T) {\n+}"}, {"sha": "31a1638cade170e7fecbf058fd4266937d22093c", "filename": "src/test/compile-fail/const-eval-overflow2c.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+\n+#![deny(const_err)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8,) =\n+    (\n+     i8::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+const VALS_I16: (i16,) =\n+    (\n+     i16::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+const VALS_I32: (i32,) =\n+    (\n+     i32::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+const VALS_I64: (i64,) =\n+    (\n+     i64::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+const VALS_U8: (u8,) =\n+    (\n+     u8::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+const VALS_U16: (u16,) = (\n+     u16::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+const VALS_U32: (u32,) = (\n+     u32::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+const VALS_U64: (u64,) =\n+    (\n+     u64::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| ERROR attempt to multiply with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T>(_: T) {\n+}"}, {"sha": "3065122af6a94fb334e6015d132c0b6d2aa421ee", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,6 +16,7 @@ const X: usize = 42 && 39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR: [i32; X] = [99; 34];\n+//~^ ERROR constant evaluation error\n \n const X1: usize = 42 || 39;\n //~^ ERROR mismatched types\n@@ -25,6 +26,7 @@ const X1: usize = 42 || 39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR1: [i32; X1] = [99; 47];\n+//~^ ERROR constant evaluation error\n \n const X2: usize = -42 || -39;\n //~^ ERROR mismatched types\n@@ -34,6 +36,7 @@ const X2: usize = -42 || -39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR2: [i32; X2] = [99; 18446744073709551607];\n+//~^ ERROR constant evaluation error\n \n const X3: usize = -42 && -39;\n //~^ ERROR mismatched types\n@@ -43,36 +46,43 @@ const X3: usize = -42 && -39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR3: [i32; X3] = [99; 6];\n+//~^ ERROR constant evaluation error\n \n const Y: usize = 42.0 == 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR: [i32; Y] = [99; 1];\n+//~^ ERROR constant evaluation error\n \n const Y1: usize = 42.0 >= 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR1: [i32; Y1] = [99; 1];\n+//~^ ERROR constant evaluation error\n \n const Y2: usize = 42.0 <= 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR2: [i32; Y2] = [99; 1];\n+//~^ ERROR constant evaluation error\n \n const Y3: usize = 42.0 > 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR3: [i32; Y3] = [99; 0];\n+//~^ ERROR constant evaluation error\n \n const Y4: usize = 42.0 < 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR4: [i32; Y4] = [99; 0];\n+//~^ ERROR constant evaluation error\n \n const Y5: usize = 42.0 != 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR5: [i32; Y5] = [99; 0];\n+//~^ ERROR constant evaluation error\n \n fn main() {\n     let _ = ARR;"}, {"sha": "85cc893aa133c543457018af5bbec0c5edfb15be", "filename": "src/test/compile-fail/const-len-underflow-subspans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,6 +16,6 @@ const TWO: usize = 2;\n \n fn main() {\n     let a: [i8; ONE - TWO] = unimplemented!();\n-    //~^ ERROR constant evaluation error [E0080]\n+    //~^ ERROR constant evaluation error\n     //~| attempt to subtract with overflow\n }"}, {"sha": "179ea9e853f3ad6bd4a4abc7973ee4fb40e7203d", "filename": "src/test/compile-fail/const-slice-oob.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deny(const_err)]\n+\n const FOO: &'static[u32] = &[1, 2, 3];\n const BAR: u32 = FOO[5];\n //~^ ERROR constant evaluation error [E0080]"}, {"sha": "7596881ef9b9af1e03762dda451dca620cc3b1a3", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -14,6 +14,7 @@ const TUP: (usize,) = 5usize << 64;\n //~^ ERROR mismatched types\n //~| expected tuple, found usize\n const ARR: [i32; TUP.0] = [];\n+//~^ ERROR constant evaluation error\n \n fn main() {\n }"}, {"sha": "49f76c532df54d328f2605e21e6d4a9f5a330b4f", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum test {\n-    div_zero = 1/0, //~ ERROR E0080\n-                    //~| attempt to divide by zero\n-    rem_zero = 1%0,\n-    //~^ ERROR E0080\n-    //~| attempt to calculate the remainder with a divisor of zero\n+enum Test {\n+    DivZero = 1/0,\n+    //~^ attempt to divide by zero\n+    //~| ERROR constant evaluation error\n+    //~| WARN constant evaluation error\n+    RemZero = 1%0,\n+    //~^ attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n+    //~| WARN constant evaluation error\n }\n \n fn main() {}"}, {"sha": "1f07422e21be471a1dd0385174ae360254d45a3d", "filename": "src/test/compile-fail/float-int-invalid-const-cast.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cdcca786468a71375584bb48e3093790c91084f7/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdcca786468a71375584bb48e3093790c91084f7/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs?ref=cdcca786468a71375584bb48e3093790c91084f7", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(i128_type)]\n-#![allow(const_err)] // this test is only about hard errors\n-\n-use std::{f32, f64};\n-\n-// Forces evaluation of constants, triggering hard error\n-fn force<T>(_: T) {}\n-\n-fn main() {\n-    { const X: u16 = -1. as u16; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = -100. as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f32::NAN as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = f32::NAN as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u64 = f32::NAN as u64; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f32::NAN as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f32::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u32 = f32::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f32::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f32::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: u8 = f32::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u16 = f32::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n-    { const X: i64 = f32::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f32::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f64::NAN as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = f64::NAN as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u64 = f64::NAN as u64; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f64::NAN as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f64::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u32 = f64::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f64::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f64::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: u8 = f64::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u16 = f64::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n-    { const X: i64 = f64::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f64::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: u8 = 256. as u8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i8 = -129. as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i8 = 128. as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = 2147483648. as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = -2147483904. as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u32 = 4294967296. as u32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = 1e40 as u128; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = 1e40 as i128; force(X); } //~ ERROR constant evaluation error\n-}"}, {"sha": "7de84802e1d056765759c7dfe14f2ae9eaa8ef2e", "filename": "src/test/compile-fail/huge-array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:; 1518599999\n+// error-pattern:; 1518600000\n \n fn generic<T: Copy>(t: T) {\n     let s: [T; 1518600000] = [t; 1518600000];"}, {"sha": "be76796c5c465b936404ca001d5cb17f9f2596bb", "filename": "src/test/compile-fail/issue-27895.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -14,8 +14,7 @@ fn main() {\n \n     match i {\n         0...index => println!(\"winner\"),\n-        //~^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n+        //~^ ERROR runtime values cannot be referenced in patterns\n         _ => println!(\"hello\"),\n     }\n }"}, {"sha": "74121e3a420f9f74c941a812c548eec20ca36cd5", "filename": "src/test/compile-fail/issue-31109.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-31109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-31109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31109.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,6 +12,5 @@ fn main() {\n     // FIXME(#31407) this error should go away, but in the meantime we test that it\n     // is accompanied by a somewhat useful error message.\n     let _: f64 = 1234567890123456789012345678901234567890e-340;\n-    //~^ ERROR constant evaluation error\n-    //~| unimplemented constant expression: could not evaluate float literal\n+    //~^ ERROR could not evaluate float literal (see issue #31407)\n }"}, {"sha": "f01fd1fd8f1442571c9a7cfa6f9005f647b335a2", "filename": "src/test/compile-fail/issue-39559-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-39559-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-39559-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559-2.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -22,7 +22,9 @@ impl Dim for Dim3 {\n \n fn main() {\n     let array: [usize; Dim3::dim()]\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR E0015\n+    //~| ERROR E0080\n         = [0; Dim3::dim()];\n-        //~^ ERROR calls in constants are limited to constant functions\n+        //~^ ERROR E0015\n+        //~| ERROR E0080\n }"}, {"sha": "ac85e43cf4f0557e38e826929debb914bf621d05", "filename": "src/test/compile-fail/issue-41255.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -18,33 +18,33 @@\n fn main() {\n     let x = 42.0;\n     match x {\n-        5.0 => {}, //~ ERROR floating-point literals cannot be used\n+        5.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                    //~| WARNING hard error\n-        5.0f32 => {}, //~ ERROR floating-point literals cannot be used\n+        5.0f32 => {}, //~ ERROR floating-point types cannot be used in patterns\n                       //~| WARNING hard error\n-        -5.0 => {}, //~ ERROR floating-point literals cannot be used\n+        -5.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                     //~| WARNING hard error\n-        1.0 .. 33.0 => {}, //~ ERROR floating-point literals cannot be used\n+        1.0 .. 33.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                            //~| WARNING hard error\n-                           //~| ERROR floating-point literals cannot be used\n+                           //~| ERROR floating-point types cannot be used in patterns\n                            //~| WARNING hard error\n-        39.0 ... 70.0 => {}, //~ ERROR floating-point literals cannot be used\n+        39.0 ... 70.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                              //~| WARNING hard error\n-                             //~| ERROR floating-point literals cannot be used\n+                             //~| ERROR floating-point types cannot be used in patterns\n                              //~| WARNING hard error\n         _ => {},\n     };\n     let y = 5.0;\n     // Same for tuples\n     match (x, 5) {\n-        (3.14, 1) => {}, //~ ERROR floating-point literals cannot be used\n+        (3.14, 1) => {}, //~ ERROR floating-point types cannot be used\n                          //~| WARNING hard error\n         _ => {},\n     }\n     // Or structs\n     struct Foo { x: f32 };\n     match (Foo { x }) {\n-        Foo { x: 2.0 } => {}, //~ ERROR floating-point literals cannot be used\n+        Foo { x: 2.0 } => {}, //~ ERROR floating-point types cannot be used\n                               //~| WARNING hard error\n         _ => {},\n     }"}, {"sha": "c0af3b4b9e695a97289c42b5990af0cbf991c070", "filename": "src/test/compile-fail/issue-43105.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-43105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-43105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43105.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,6 +12,7 @@ fn xyz() -> u8 { 42 }\n \n const NUM: u8 = xyz();\n //~^ ERROR calls in constants are limited to constant functions, struct and enum constructors\n+//~| ERROR constant evaluation error\n \n fn main() {\n     match 1 {"}, {"sha": "18cfb35113dc6fdd98285c16b5490107f3ce52fa", "filename": "src/test/compile-fail/issue-44578.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-44578.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-44578.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-44578.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -18,7 +18,7 @@ enum Bar<A, B> {\n }\n \n impl<A: Foo, B: Foo> Foo for Bar<A, B> {\n-    const AMT: usize = [A::AMT][(A::AMT > B::AMT) as usize]; //~ ERROR constant evaluation\n+    const AMT: usize = [A::AMT][(A::AMT > B::AMT) as usize];\n }\n \n impl Foo for u8 {\n@@ -30,5 +30,5 @@ impl Foo for u16 {\n }\n \n fn main() {\n-    println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n+    println!(\"{}\", <Bar<u16, u8> as Foo>::AMT); //~ E0080\n }"}, {"sha": "9191dfa155c657d9dfc3813556ab36717c9a88a2", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,18 +12,21 @@\n \n #![feature(slice_patterns)]\n #![allow(unused)]\n+#![deny(illegal_floating_point_literal_pattern)]\n \n use std::f64::NAN;\n \n fn main() {\n     let x = NAN;\n     match x {\n-        NAN => {}, //~ ERROR floating point constants cannot be used\n+        NAN => {}, //~ ERROR floating-point types cannot be used\n+        //~^ WARN this was previously accepted by the compiler but is being phased out\n         _ => {},\n     };\n \n     match [x, 1.0] {\n-        [NAN, _] => {}, //~ ERROR floating point constants cannot be used\n+        [NAN, _] => {}, //~ ERROR floating-point types cannot be used\n+        //~^ WARN this was previously accepted by the compiler but is being phased out\n         _ => {},\n     };\n }"}, {"sha": "1d59e75a0f0f028874ee69aa71269f949edf13c5", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,42 +16,62 @@ use std::thread;\n fn main() {\n     assert!(thread::spawn(move|| { isize::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i8::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i16::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i32::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1isize / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i16 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i32 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n }"}, {"sha": "5ebfcc4926baa0a79eb67ff483241b177bb8d711", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,67 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(exceeding_bitshifts)]\n+#![deny(exceeding_bitshifts, const_err)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(const_indexing)]\n \n fn main() {\n       let n = 1u8 << 7;\n-      let n = 1u8 << 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u8 << 8;   //~ ERROR: attempt to shift left with overflow\n       let n = 1u16 << 15;\n-      let n = 1u16 << 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u16 << 16; //~ ERROR: attempt to shift left with overflow\n       let n = 1u32 << 31;\n-      let n = 1u32 << 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u32 << 32; //~ ERROR: attempt to shift left with overflow\n       let n = 1u64 << 63;\n-      let n = 1u64 << 64; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u64 << 64; //~ ERROR: attempt to shift left with overflow\n       let n = 1i8 << 7;\n-      let n = 1i8 << 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i8 << 8;   //~ ERROR: attempt to shift left with overflow\n       let n = 1i16 << 15;\n-      let n = 1i16 << 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i16 << 16; //~ ERROR: attempt to shift left with overflow\n       let n = 1i32 << 31;\n-      let n = 1i32 << 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i32 << 32; //~ ERROR: attempt to shift left with overflow\n       let n = 1i64 << 63;\n-      let n = 1i64 << 64; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i64 << 64; //~ ERROR: attempt to shift left with overflow\n \n       let n = 1u8 >> 7;\n-      let n = 1u8 >> 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u8 >> 8;   //~ ERROR: attempt to shift right with overflow\n       let n = 1u16 >> 15;\n-      let n = 1u16 >> 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u16 >> 16; //~ ERROR: attempt to shift right with overflow\n       let n = 1u32 >> 31;\n-      let n = 1u32 >> 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u32 >> 32; //~ ERROR: attempt to shift right with overflow\n       let n = 1u64 >> 63;\n-      let n = 1u64 >> 64; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u64 >> 64; //~ ERROR: attempt to shift right with overflow\n       let n = 1i8 >> 7;\n-      let n = 1i8 >> 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i8 >> 8;   //~ ERROR: attempt to shift right with overflow\n       let n = 1i16 >> 15;\n-      let n = 1i16 >> 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i16 >> 16; //~ ERROR: attempt to shift right with overflow\n       let n = 1i32 >> 31;\n-      let n = 1i32 >> 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i32 >> 32; //~ ERROR: attempt to shift right with overflow\n       let n = 1i64 >> 63;\n-      let n = 1i64 >> 64; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i64 >> 64; //~ ERROR: attempt to shift right with overflow\n \n       let n = 1u8;\n       let n = n << 7;\n-      let n = n << 8; //~ ERROR: bitshift exceeds the type's number of bits\n-\n-      let n = 1u8 << -8; //~ ERROR: bitshift exceeds the type's number of bits\n-      //~^ WARN: attempt to shift by a negative amount\n-\n-      let n = 1u8 << (4+3);\n-      let n = 1u8 << (4+4); //~ ERROR: bitshift exceeds the type's number of bits\n-\n-      #[cfg(target_pointer_width = \"32\")]\n-      const BITS: usize = 32;\n-      #[cfg(target_pointer_width = \"64\")]\n-      const BITS: usize = 64;\n-\n-      let n = 1_isize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1_usize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = n << 8; //~ ERROR: attempt to shift left with overflow\n \n+      let n = 1u8 << -8; //~ ERROR: attempt to shift left with overflow\n \n       let n = 1i8<<(1isize+-1);\n-\n-      let n = 1i64 >> [63][0];\n-      let n = 1i64 >> [64][0]; //~ ERROR: bitshift exceeds the type's number of bits\n }"}, {"sha": "3ba300eb7c4ab541c63823a20f3cba32d249c2f1", "filename": "src/test/compile-fail/lint-exceeding-bitshifts2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts2.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(exceeding_bitshifts, const_err)]\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+\n+fn main() {\n+      let n = 1u8 << (4+3);\n+      let n = 1u8 << (4+4); //~ ERROR: attempt to shift left with overflow\n+      let n = 1i64 >> [63][0];\n+      let n = 1i64 >> [64][0]; // should be linting, needs to wait for const propagation\n+\n+      #[cfg(target_pointer_width = \"32\")]\n+      const BITS: usize = 32;\n+      #[cfg(target_pointer_width = \"64\")]\n+      const BITS: usize = 64;\n+      let n = 1_isize << BITS; //~ ERROR: attempt to shift left with overflow\n+      let n = 1_usize << BITS; //~ ERROR: attempt to shift left with overflow\n+}"}, {"sha": "f7cf8a68d568446119a63c5b9d74cd05794589d7", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -17,7 +17,6 @@\n #[rustc_error]\n fn main() { //~ ERROR: compilation successful\n     let x2: i8 = --128; //~ warn: literal out of range for i8\n-    //~^ warn: attempt to negate with overflow\n \n     let x = -3.40282357e+38_f32; //~ warn: literal out of range for f32\n     let x =  3.40282357e+38_f32; //~ warn: literal out of range for f32"}, {"sha": "fe88ab4e11798b39467d7b791895d4fa9924935b", "filename": "src/test/compile-fail/non-constant-in-const-path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -12,7 +12,6 @@ fn main() {\n     let x = 0;\n     match 1 {\n         0 ... x => {}\n-        //~^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n+        //~^ ERROR runtime values cannot be referenced in patterns\n     };\n }"}, {"sha": "ca9af78dd993660991e315ab75ffa6057eaf0c0e", "filename": "src/test/compile-fail/rfc1445/match-forbidden-without-eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -28,7 +28,8 @@ fn main() {\n     let x = 0.0;\n     match x {\n         f32::INFINITY => { }\n-        //~^ ERROR floating point constants cannot be used in patterns\n+        //~^ WARNING floating-point types cannot be used in patterns\n+        //~| WARNING will become a hard error in a future release\n         _ => { }\n     }\n }"}, {"sha": "dc220bd1cc94fbfa81432109dbf7e16e32493fe8", "filename": "src/test/compile-fail/thread-local-in-ctfe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -16,15 +16,13 @@ static A: u32 = 1;\n static B: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n //~| ERROR cannot refer to other statics by value\n-//~| WARN non-constant path in constant expression\n \n static C: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n \n const D: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n //~| ERROR cannot refer to statics by value\n-//~| WARN non-constant path in constant expression\n \n const E: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time"}, {"sha": "3fb5621c8ae3ba4429d9584b0046feb9507d8f3d", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -49,7 +49,7 @@ fn main() {\n //         _3 = &'23_1rs _2;\n //         StorageLive(_5);\n //         _5 = _2;\n-//         switchInt(move _5) -> [0u8: bb5, otherwise: bb4];\n+//         switchInt(move _5) -> [false: bb5, otherwise: bb4];\n //     }\n //     bb3: {\n //         ..."}, {"sha": "070bde8e3c3e6f7faa15551307266e0f5afeb6c5", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -51,7 +51,7 @@ fn main() {\n //         _3 = &'26_1rs _1;\n //         StorageLive(_5);\n //         _5 = _1;\n-//         switchInt(move _5) -> [0u8: bb5, otherwise: bb4];\n+//         switchInt(move _5) -> [false: bb5, otherwise: bb4];\n //     }\n //     bb3: {\n //         ..."}, {"sha": "6d9a27eeeb4560dc276027cd92a4e7cd36bc4f50", "filename": "src/test/mir-opt/end_region_9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_9.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -72,7 +72,7 @@ fn main() {\n //    bb4: {\n //        StorageLive(_7);\n //        _7 = _1;\n-//        switchInt(move _7) -> [0u8: bb6, otherwise: bb5];\n+//        switchInt(move _7) -> [false: bb6, otherwise: bb5];\n //    }\n //    bb5: {\n //        _0 = ();"}, {"sha": "83425a72f4598e38131070b9cbaa9d9d6766df4c", "filename": "src/test/mir-opt/end_region_cyclic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -103,7 +103,7 @@ fn query() -> bool { true }\n //         _11 = const query() -> [return: bb6, unwind: bb3];\n //     }\n //     bb6: {\n-//         switchInt(move _11) -> [0u8: bb8, otherwise: bb7];\n+//         switchInt(move _11) -> [false: bb8, otherwise: bb7];\n //     }\n //     bb7: {\n //         _0 = ();"}, {"sha": "a9eea26f46643843d2270ea4402b78467a49d0e2", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -36,7 +36,7 @@ fn main() {\n //     bb3: {\n //         StorageLive(_4);\n //         _4 = _1;\n-//         switchInt(move _4) -> [0u8: bb5, otherwise: bb4];\n+//         switchInt(move _4) -> [false: bb5, otherwise: bb4];\n //     }\n //     bb4: {\n //         _0 = ();"}, {"sha": "53f178619975e9f9b2a1dd0208e1795e19ad27de", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -93,7 +93,7 @@ fn main() {\n //      _7 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: { // end of guard\n-//      switchInt(move _7) -> [0u8: bb11, otherwise: bb2];\n+//      switchInt(move _7) -> [false: bb11, otherwise: bb2];\n //  }\n //  bb11: { // to pre_binding2\n //      falseEdges -> [real: bb5, imaginary: bb5];\n@@ -157,7 +157,7 @@ fn main() {\n //      _7 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: { // end of guard\n-//      switchInt(move _7) -> [0u8: bb11, otherwise: bb2];\n+//      switchInt(move _7) -> [false: bb11, otherwise: bb2];\n //  }\n //  bb11: { // to pre_binding2\n //      falseEdges -> [real: bb6, imaginary: bb5];\n@@ -219,7 +219,7 @@ fn main() {\n //     _9 = const guard() -> [return: bb10, unwind: bb1];\n // }\n // bb10: { //end of guard\n-//    switchInt(move _9) -> [0u8: bb11, otherwise: bb2];\n+//    switchInt(move _9) -> [false: bb11, otherwise: bb2];\n // }\n // bb11: { // to pre_binding2\n //     falseEdges -> [real: bb5, imaginary: bb5];\n@@ -240,7 +240,7 @@ fn main() {\n // }\n // bb14: { // end of guard2\n //     StorageDead(_12);\n-//     switchInt(move _11) -> [0u8: bb15, otherwise: bb3];\n+//     switchInt(move _11) -> [false: bb15, otherwise: bb3];\n // }\n // bb15: { // to pre_binding4\n //     falseEdges -> [real: bb7, imaginary: bb7];"}, {"sha": "19d733d4f6b6a8931bdc0a4d2b5617b970b7b85c", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -41,7 +41,7 @@ fn main() {\n //            | Live variables on entry to bb2[0]: [_1, _3]\n //        _2 = &'_#2r _1[_3];\n //            | Live variables on entry to bb2[1]: [_2]\n-//        switchInt(const true) -> [0u8: bb4, otherwise: bb3];\n+//        switchInt(const true) -> [false: bb4, otherwise: bb3];\n //    }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir"}, {"sha": "52d5892e6560b96ca2165147535566a8c3711375", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -17,7 +17,7 @@ fn main() {\n // END RUST SOURCE\n // START rustc.main.SimplifyBranches-initial.before.mir\n // bb0: {\n-//     switchInt(const false) -> [0u8: bb3, otherwise: bb2];\n+//     switchInt(const false) -> [false: bb3, otherwise: bb2];\n // }\n // END rustc.main.SimplifyBranches-initial.before.mir\n // START rustc.main.SimplifyBranches-initial.after.mir"}, {"sha": "2e60634d15eed190f7db09d106677ef35cbf9b67", "filename": "src/test/run-pass/const-index-feature-gate.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fconst-index-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fconst-index-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-index-feature-gate.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n const ARR: [usize; 1] = [2];\n-const ARR2: [i32; ARR[0]] = [5, 6]; //~ ERROR E0080\n-                                    //~| unstable\n+const ARR2: [i32; ARR[0]] = [5, 6];\n \n fn main() {\n }", "previous_filename": "src/test/compile-fail/const-index-feature-gate.rs"}, {"sha": "5c633eb6112ffdb47264c9ca50c5976137c4cdc1", "filename": "src/test/run-pass/const-negation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-negation.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -17,11 +17,13 @@ fn main() {\n     const I: isize = -9223372036854775808isize;\n     assert_eq!(::std::i32::MIN as u64, 0xffffffff80000000);\n     assert_eq!(-2147483648isize as u64, 0xffffffff80000000);\n+    assert_eq!(-2147483648i32 as u64, 0xffffffff80000000);\n     assert_eq!(::std::i64::MIN as u64, 0x8000000000000000);\n     #[cfg(target_pointer_width = \"64\")]\n     assert_eq!(-9223372036854775808isize as u64, 0x8000000000000000);\n     #[cfg(target_pointer_width = \"32\")]\n     assert_eq!(-9223372036854775808isize as u64, 0);\n+    assert_eq!(-9223372036854775808i32 as u64, 0);\n     const J: usize = ::std::i32::MAX as usize;\n     const K: usize = -1i32 as u32 as usize;\n     const L: usize = ::std::i32::MIN as usize;"}, {"sha": "813dd5fbb994175dcd2ef378a42de2d94d074141", "filename": "src/test/run-pass/ctfe/chained-constants-stackoverflow.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fchained-constants-stackoverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fchained-constants-stackoverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fchained-constants-stackoverflow.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,364 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/34997\n+\n+pub const CST_1: u32 = 0;\n+pub const CST_2: u32 = CST_1+1;\n+pub const CST_3: u32 = CST_2+1;\n+pub const CST_4: u32 = CST_3+1;\n+pub const CST_5: u32 = CST_4+1;\n+pub const CST_6: u32 = CST_5+1;\n+pub const CST_7: u32 = CST_6+1;\n+pub const CST_8: u32 = CST_7+1;\n+pub const CST_9: u32 = CST_8+1;\n+pub const CST_10: u32 = CST_9+1;\n+pub const CST_11: u32 = CST_10+1;\n+pub const CST_12: u32 = CST_11+1;\n+pub const CST_13: u32 = CST_12+1;\n+pub const CST_14: u32 = CST_13+1;\n+pub const CST_15: u32 = CST_14+1;\n+pub const CST_16: u32 = CST_15+1;\n+pub const CST_17: u32 = CST_16+1;\n+pub const CST_18: u32 = CST_17+1;\n+pub const CST_19: u32 = CST_18+1;\n+pub const CST_20: u32 = CST_19+1;\n+pub const CST_21: u32 = CST_20+1;\n+pub const CST_22: u32 = CST_21+1;\n+pub const CST_23: u32 = CST_22+1;\n+pub const CST_24: u32 = CST_23+1;\n+pub const CST_25: u32 = CST_24+1;\n+pub const CST_26: u32 = CST_25+1;\n+pub const CST_27: u32 = CST_26+1;\n+pub const CST_28: u32 = CST_27+1;\n+pub const CST_29: u32 = CST_28+1;\n+pub const CST_30: u32 = CST_29+1;\n+pub const CST_31: u32 = CST_30+1;\n+pub const CST_32: u32 = CST_31+1;\n+pub const CST_33: u32 = CST_32+1;\n+pub const CST_34: u32 = CST_33+1;\n+pub const CST_35: u32 = CST_34+1;\n+pub const CST_36: u32 = CST_35+1;\n+pub const CST_37: u32 = CST_36+1;\n+pub const CST_38: u32 = CST_37+1;\n+pub const CST_39: u32 = CST_38+1;\n+pub const CST_40: u32 = CST_39+1;\n+pub const CST_41: u32 = CST_40+1;\n+pub const CST_42: u32 = CST_41+1;\n+pub const CST_43: u32 = CST_42+1;\n+pub const CST_44: u32 = CST_43+1;\n+pub const CST_45: u32 = CST_44+1;\n+pub const CST_46: u32 = CST_45+1;\n+pub const CST_47: u32 = CST_46+1;\n+pub const CST_48: u32 = CST_47+1;\n+pub const CST_49: u32 = CST_48+1;\n+pub const CST_50: u32 = CST_49+1;\n+pub const CST_51: u32 = CST_50+1;\n+pub const CST_52: u32 = CST_51+1;\n+pub const CST_53: u32 = CST_52+1;\n+pub const CST_54: u32 = CST_53+1;\n+pub const CST_55: u32 = CST_54+1;\n+pub const CST_56: u32 = CST_55+1;\n+pub const CST_57: u32 = CST_56+1;\n+pub const CST_58: u32 = CST_57+1;\n+pub const CST_59: u32 = CST_58+1;\n+pub const CST_60: u32 = CST_59+1;\n+pub const CST_61: u32 = CST_60+1;\n+pub const CST_62: u32 = CST_61+1;\n+pub const CST_63: u32 = CST_62+1;\n+pub const CST_64: u32 = CST_63+1;\n+pub const CST_65: u32 = CST_64+1;\n+pub const CST_66: u32 = CST_65+1;\n+pub const CST_67: u32 = CST_66+1;\n+pub const CST_68: u32 = CST_67+1;\n+pub const CST_69: u32 = CST_68+1;\n+pub const CST_70: u32 = CST_69+1;\n+pub const CST_71: u32 = CST_70+1;\n+pub const CST_72: u32 = CST_71+1;\n+pub const CST_73: u32 = CST_72+1;\n+pub const CST_74: u32 = CST_73+1;\n+pub const CST_75: u32 = CST_74+1;\n+pub const CST_76: u32 = CST_75+1;\n+pub const CST_77: u32 = CST_76+1;\n+pub const CST_78: u32 = CST_77+1;\n+pub const CST_79: u32 = CST_78+1;\n+pub const CST_80: u32 = CST_79+1;\n+pub const CST_81: u32 = CST_80+1;\n+pub const CST_82: u32 = CST_81+1;\n+pub const CST_83: u32 = CST_82+1;\n+pub const CST_84: u32 = CST_83+1;\n+pub const CST_85: u32 = CST_84+1;\n+pub const CST_86: u32 = CST_85+1;\n+pub const CST_87: u32 = CST_86+1;\n+pub const CST_88: u32 = CST_87+1;\n+pub const CST_89: u32 = CST_88+1;\n+pub const CST_90: u32 = CST_89+1;\n+pub const CST_91: u32 = CST_90+1;\n+pub const CST_92: u32 = CST_91+1;\n+pub const CST_93: u32 = CST_92+1;\n+pub const CST_94: u32 = CST_93+1;\n+pub const CST_95: u32 = CST_94+1;\n+pub const CST_96: u32 = CST_95+1;\n+pub const CST_97: u32 = CST_96+1;\n+pub const CST_98: u32 = CST_97+1;\n+pub const CST_99: u32 = CST_98+1;\n+pub const CST_100: u32 = CST_99+1;\n+pub const CST_101: u32 = CST_100+1;\n+pub const CST_102: u32 = CST_101+1;\n+pub const CST_103: u32 = CST_102+1;\n+pub const CST_104: u32 = CST_103+1;\n+pub const CST_105: u32 = CST_104+1;\n+pub const CST_106: u32 = CST_105+1;\n+pub const CST_107: u32 = CST_106+1;\n+pub const CST_108: u32 = CST_107+1;\n+pub const CST_109: u32 = CST_108+1;\n+pub const CST_110: u32 = CST_109+1;\n+pub const CST_111: u32 = CST_110+1;\n+pub const CST_112: u32 = CST_111+1;\n+pub const CST_113: u32 = CST_112+1;\n+pub const CST_114: u32 = CST_113+1;\n+pub const CST_115: u32 = CST_114+1;\n+pub const CST_116: u32 = CST_115+1;\n+pub const CST_117: u32 = CST_116+1;\n+pub const CST_118: u32 = CST_117+1;\n+pub const CST_119: u32 = CST_118+1;\n+pub const CST_120: u32 = CST_119+1;\n+pub const CST_121: u32 = CST_120+1;\n+pub const CST_122: u32 = CST_121+1;\n+pub const CST_123: u32 = CST_122+1;\n+pub const CST_124: u32 = CST_123+1;\n+pub const CST_125: u32 = CST_124+1;\n+pub const CST_126: u32 = CST_125+1;\n+pub const CST_127: u32 = CST_126+1;\n+pub const CST_128: u32 = CST_127+1;\n+pub const CST_129: u32 = CST_128+1;\n+pub const CST_130: u32 = CST_129+1;\n+pub const CST_131: u32 = CST_130+1;\n+pub const CST_132: u32 = CST_131+1;\n+pub const CST_133: u32 = CST_132+1;\n+pub const CST_134: u32 = CST_133+1;\n+pub const CST_135: u32 = CST_134+1;\n+pub const CST_136: u32 = CST_135+1;\n+pub const CST_137: u32 = CST_136+1;\n+pub const CST_138: u32 = CST_137+1;\n+pub const CST_139: u32 = CST_138+1;\n+pub const CST_140: u32 = CST_139+1;\n+pub const CST_141: u32 = CST_140+1;\n+pub const CST_142: u32 = CST_141+1;\n+pub const CST_143: u32 = CST_142+1;\n+pub const CST_144: u32 = CST_143+1;\n+pub const CST_145: u32 = CST_144+1;\n+pub const CST_146: u32 = CST_145+1;\n+pub const CST_147: u32 = CST_146+1;\n+pub const CST_148: u32 = CST_147+1;\n+pub const CST_149: u32 = CST_148+1;\n+pub const CST_150: u32 = CST_149+1;\n+pub const CST_151: u32 = CST_150+1;\n+pub const CST_152: u32 = CST_151+1;\n+pub const CST_153: u32 = CST_152+1;\n+pub const CST_154: u32 = CST_153+1;\n+pub const CST_155: u32 = CST_154+1;\n+pub const CST_156: u32 = CST_155+1;\n+pub const CST_157: u32 = CST_156+1;\n+pub const CST_158: u32 = CST_157+1;\n+pub const CST_159: u32 = CST_158+1;\n+pub const CST_160: u32 = CST_159+1;\n+pub const CST_161: u32 = CST_160+1;\n+pub const CST_162: u32 = CST_161+1;\n+pub const CST_163: u32 = CST_162+1;\n+pub const CST_164: u32 = CST_163+1;\n+pub const CST_165: u32 = CST_164+1;\n+pub const CST_166: u32 = CST_165+1;\n+pub const CST_167: u32 = CST_166+1;\n+pub const CST_168: u32 = CST_167+1;\n+pub const CST_169: u32 = CST_168+1;\n+pub const CST_170: u32 = CST_169+1;\n+pub const CST_171: u32 = CST_170+1;\n+pub const CST_172: u32 = CST_171+1;\n+pub const CST_173: u32 = CST_172+1;\n+pub const CST_174: u32 = CST_173+1;\n+pub const CST_175: u32 = CST_174+1;\n+pub const CST_176: u32 = CST_175+1;\n+pub const CST_177: u32 = CST_176+1;\n+pub const CST_178: u32 = CST_177+1;\n+pub const CST_179: u32 = CST_178+1;\n+pub const CST_180: u32 = CST_179+1;\n+pub const CST_181: u32 = CST_180+1;\n+pub const CST_182: u32 = CST_181+1;\n+pub const CST_183: u32 = CST_182+1;\n+pub const CST_184: u32 = CST_183+1;\n+pub const CST_185: u32 = CST_184+1;\n+pub const CST_186: u32 = CST_185+1;\n+pub const CST_187: u32 = CST_186+1;\n+pub const CST_188: u32 = CST_187+1;\n+pub const CST_189: u32 = CST_188+1;\n+pub const CST_190: u32 = CST_189+1;\n+pub const CST_191: u32 = CST_190+1;\n+pub const CST_192: u32 = CST_191+1;\n+pub const CST_193: u32 = CST_192+1;\n+pub const CST_194: u32 = CST_193+1;\n+pub const CST_195: u32 = CST_194+1;\n+pub const CST_196: u32 = CST_195+1;\n+pub const CST_197: u32 = CST_196+1;\n+pub const CST_198: u32 = CST_197+1;\n+pub const CST_199: u32 = CST_198+1;\n+pub const CST_200: u32 = CST_199+1;\n+pub const CST_201: u32 = CST_200+1;\n+pub const CST_202: u32 = CST_201+1;\n+pub const CST_203: u32 = CST_202+1;\n+pub const CST_204: u32 = CST_203+1;\n+pub const CST_205: u32 = CST_204+1;\n+pub const CST_206: u32 = CST_205+1;\n+pub const CST_207: u32 = CST_206+1;\n+pub const CST_208: u32 = CST_207+1;\n+pub const CST_209: u32 = CST_208+1;\n+pub const CST_210: u32 = CST_209+1;\n+pub const CST_211: u32 = CST_210+1;\n+pub const CST_212: u32 = CST_211+1;\n+pub const CST_213: u32 = CST_212+1;\n+pub const CST_214: u32 = CST_213+1;\n+pub const CST_215: u32 = CST_214+1;\n+pub const CST_216: u32 = CST_215+1;\n+pub const CST_217: u32 = CST_216+1;\n+pub const CST_218: u32 = CST_217+1;\n+pub const CST_219: u32 = CST_218+1;\n+pub const CST_220: u32 = CST_219+1;\n+pub const CST_221: u32 = CST_220+1;\n+pub const CST_222: u32 = CST_221+1;\n+pub const CST_223: u32 = CST_222+1;\n+pub const CST_224: u32 = CST_223+1;\n+pub const CST_225: u32 = CST_224+1;\n+pub const CST_226: u32 = CST_225+1;\n+pub const CST_227: u32 = CST_226+1;\n+pub const CST_228: u32 = CST_227+1;\n+pub const CST_229: u32 = CST_228+1;\n+pub const CST_230: u32 = CST_229+1;\n+pub const CST_231: u32 = CST_230+1;\n+pub const CST_232: u32 = CST_231+1;\n+pub const CST_233: u32 = CST_232+1;\n+pub const CST_234: u32 = CST_233+1;\n+pub const CST_235: u32 = CST_234+1;\n+pub const CST_236: u32 = CST_235+1;\n+pub const CST_237: u32 = CST_236+1;\n+pub const CST_238: u32 = CST_237+1;\n+pub const CST_239: u32 = CST_238+1;\n+pub const CST_240: u32 = CST_239+1;\n+pub const CST_241: u32 = CST_240+1;\n+pub const CST_242: u32 = CST_241+1;\n+pub const CST_243: u32 = CST_242+1;\n+pub const CST_244: u32 = CST_243+1;\n+pub const CST_245: u32 = CST_244+1;\n+pub const CST_246: u32 = CST_245+1;\n+pub const CST_247: u32 = CST_246+1;\n+pub const CST_248: u32 = CST_247+1;\n+pub const CST_249: u32 = CST_248+1;\n+pub const CST_250: u32 = CST_249+1;\n+pub const CST_251: u32 = CST_250+1;\n+pub const CST_252: u32 = CST_251+1;\n+pub const CST_253: u32 = CST_252+1;\n+pub const CST_254: u32 = CST_253+1;\n+pub const CST_255: u32 = CST_254+1;\n+pub const CST_256: u32 = CST_255+1;\n+pub const CST_257: u32 = CST_256+1;\n+pub const CST_258: u32 = CST_257+1;\n+pub const CST_259: u32 = CST_258+1;\n+pub const CST_260: u32 = CST_259+1;\n+pub const CST_261: u32 = CST_260+1;\n+pub const CST_262: u32 = CST_261+1;\n+pub const CST_263: u32 = CST_262+1;\n+pub const CST_264: u32 = CST_263+1;\n+pub const CST_265: u32 = CST_264+1;\n+pub const CST_266: u32 = CST_265+1;\n+pub const CST_267: u32 = CST_266+1;\n+pub const CST_268: u32 = CST_267+1;\n+pub const CST_269: u32 = CST_268+1;\n+pub const CST_270: u32 = CST_269+1;\n+pub const CST_271: u32 = CST_270+1;\n+pub const CST_272: u32 = CST_271+1;\n+pub const CST_273: u32 = CST_272+1;\n+pub const CST_274: u32 = CST_273+1;\n+pub const CST_275: u32 = CST_274+1;\n+pub const CST_276: u32 = CST_275+1;\n+pub const CST_277: u32 = CST_276+1;\n+pub const CST_278: u32 = CST_277+1;\n+pub const CST_279: u32 = CST_278+1;\n+pub const CST_280: u32 = CST_279+1;\n+pub const CST_281: u32 = CST_280+1;\n+pub const CST_282: u32 = CST_281+1;\n+pub const CST_283: u32 = CST_282+1;\n+pub const CST_284: u32 = CST_283+1;\n+pub const CST_285: u32 = CST_284+1;\n+pub const CST_286: u32 = CST_285+1;\n+pub const CST_287: u32 = CST_286+1;\n+pub const CST_288: u32 = CST_287+1;\n+pub const CST_289: u32 = CST_288+1;\n+pub const CST_290: u32 = CST_289+1;\n+pub const CST_291: u32 = CST_290+1;\n+pub const CST_292: u32 = CST_291+1;\n+pub const CST_293: u32 = CST_292+1;\n+pub const CST_294: u32 = CST_293+1;\n+pub const CST_295: u32 = CST_294+1;\n+pub const CST_296: u32 = CST_295+1;\n+pub const CST_297: u32 = CST_296+1;\n+pub const CST_298: u32 = CST_297+1;\n+pub const CST_299: u32 = CST_298+1;\n+pub const CST_300: u32 = CST_299+1;\n+pub const CST_301: u32 = CST_300+1;\n+pub const CST_302: u32 = CST_301+1;\n+pub const CST_303: u32 = CST_302+1;\n+pub const CST_304: u32 = CST_303+1;\n+pub const CST_305: u32 = CST_304+1;\n+pub const CST_306: u32 = CST_305+1;\n+pub const CST_307: u32 = CST_306+1;\n+pub const CST_308: u32 = CST_307+1;\n+pub const CST_309: u32 = CST_308+1;\n+pub const CST_310: u32 = CST_309+1;\n+pub const CST_311: u32 = CST_310+1;\n+pub const CST_312: u32 = CST_311+1;\n+pub const CST_313: u32 = CST_312+1;\n+pub const CST_314: u32 = CST_313+1;\n+pub const CST_315: u32 = CST_314+1;\n+pub const CST_316: u32 = CST_315+1;\n+pub const CST_317: u32 = CST_316+1;\n+pub const CST_318: u32 = CST_317+1;\n+pub const CST_319: u32 = CST_318+1;\n+pub const CST_320: u32 = CST_319+1;\n+pub const CST_321: u32 = CST_320+1;\n+pub const CST_322: u32 = CST_321+1;\n+pub const CST_323: u32 = CST_322+1;\n+pub const CST_324: u32 = CST_323+1;\n+pub const CST_325: u32 = CST_324+1;\n+pub const CST_326: u32 = CST_325+1;\n+pub const CST_327: u32 = CST_326+1;\n+pub const CST_328: u32 = CST_327+1;\n+pub const CST_329: u32 = CST_328+1;\n+pub const CST_330: u32 = CST_329+1;\n+pub const CST_331: u32 = CST_330+1;\n+pub const CST_332: u32 = CST_331+1;\n+pub const CST_333: u32 = CST_332+1;\n+pub const CST_334: u32 = CST_333+1;\n+pub const CST_335: u32 = CST_334+1;\n+pub const CST_336: u32 = CST_335+1;\n+pub const CST_337: u32 = CST_336+1;\n+pub const CST_338: u32 = CST_337+1;\n+pub const CST_339: u32 = CST_338+1;\n+pub const CST_340: u32 = CST_339+1;\n+pub const CST_341: u32 = CST_340+1;\n+pub const CST_342: u32 = CST_341+1;\n+pub const CST_343: u32 = CST_342+1;\n+pub const CST_344: u32 = CST_343+1;\n+pub const CST_345: u32 = CST_344+1;\n+pub const CST_346: u32 = CST_345+1;\n+pub const CST_347: u32 = CST_346+1;\n+pub const CST_348: u32 = CST_347+1;\n+pub const CST_349: u32 = CST_348+1;\n+pub const CST_350: u32 = CST_349+1;\n+\n+fn main() {}"}, {"sha": "4ccfa0338f3937f2f799a135d124006797e77590", "filename": "src/test/run-pass/ctfe/deref_in_pattern.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fderef_in_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fderef_in_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fderef_in_pattern.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/25574\n+\n+const A: [u8; 4] = *b\"fooo\";\n+\n+fn main() {\n+    match *b\"xxxx\" {\n+        A => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "c435e5fdaab4a108cb3e2c4171abc7303756bb70", "filename": "src/test/run-pass/ctfe/ice-48279.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fice-48279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fice-48279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fice-48279.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/48279\n+\n+#![feature(const_fn)]\n+\n+#[derive(PartialEq, Eq)]\n+pub struct NonZeroU32 {\n+    value: u32\n+}\n+\n+impl NonZeroU32 {\n+    const unsafe fn new_unchecked(value: u32) -> Self {\n+        NonZeroU32 { value }\n+    }\n+}\n+\n+//pub const FOO_ATOM: NonZeroU32 = unsafe { NonZeroU32::new_unchecked(7) };\n+pub const FOO_ATOM: NonZeroU32 = unsafe { NonZeroU32 { value: 7 } };\n+\n+fn main() {\n+    match None {\n+        Some(FOO_ATOM) => {}\n+        _ => {}\n+    }\n+}"}, {"sha": "6ed0c7c0d5dc4aa6ff9a24b46f922bb731b81c59", "filename": "src/test/run-pass/ctfe/issue-broken-mir.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fissue-broken-mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fissue-broken-mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fissue-broken-mir.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/27918\n+\n+fn main() {\n+    match b\"    \" {\n+        b\"1234\" => {},\n+        _ => {},\n+    }\n+}"}, {"sha": "0bb253d1a6455d94f97e59cf7a738533bf45e81f", "filename": "src/test/run-pass/ctfe/match-const-fn-structs.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fmatch-const-fn-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fmatch-const-fn-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fmatch-const-fn-structs.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/46114\n+\n+#![feature(const_fn)]\n+\n+#[derive(Eq, PartialEq)]\n+struct A { value: u32 }\n+\n+const fn new(value: u32) -> A {\n+    A { value }\n+}\n+\n+const A_1: A = new(1);\n+const A_2: A = new(2);\n+\n+fn main() {\n+    let a_str = match new(42) {\n+        A_1 => \"A 1\",\n+        A_2 => \"A 2\",\n+        _ => \"Unknown A\",\n+    };\n+}"}, {"sha": "9c8a4b5ae6a2d355dfe97a9e2d19a023236893fa", "filename": "src/test/run-pass/ctfe/mozjs-error.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fmozjs-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fmozjs-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fmozjs-error.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct CustomAutoRooterVFTable {\n+    trace: unsafe extern \"C\" fn(this: *mut i32, trc: *mut u32),\n+}\n+\n+unsafe trait CustomAutoTraceable: Sized {\n+    const vftable: CustomAutoRooterVFTable = CustomAutoRooterVFTable {\n+        trace: Self::trace,\n+    };\n+\n+    unsafe extern \"C\" fn trace(this: *mut i32, trc: *mut u32) {\n+        let this = this as *const Self;\n+        let this = this.as_ref().unwrap();\n+        Self::do_trace(this, trc);\n+    }\n+\n+    fn do_trace(&self, trc: *mut u32);\n+}\n+\n+unsafe impl CustomAutoTraceable for () {\n+    fn do_trace(&self, _: *mut u32) {\n+        // nop\n+    }\n+}\n+\n+fn main() {\n+    let _ = <()>::vftable;\n+}"}, {"sha": "ff4474f47c9f3b2e734d33af09b64065d225e374", "filename": "src/test/run-pass/ctfe/non-scalar-cast.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fnon-scalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fnon-scalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fnon-scalar-cast.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/37448\n+\n+fn main() {\n+    struct A;\n+    const FOO: &A = &(A as A);\n+    let _x = FOO;\n+}"}, {"sha": "2d228408254aa687dc5925b62fc20b4b4324a595", "filename": "src/test/run-pass/ctfe/promotion.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fpromotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Fpromotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fpromotion.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(_: &'static [&'static str]) {}\n+fn bar(_: &'static [&'static str; 3]) {}\n+\n+fn main() {\n+    foo(&[\"a\", \"b\", \"c\"]);\n+    bar(&[\"d\", \"e\", \"f\"]);\n+}"}, {"sha": "ad7dbeb79c721de0ebb61db486d238294e8556bb", "filename": "src/test/run-pass/ctfe/references.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const FOO: &[u8] = b\"foo\";\n+const BAR: &[u8] = &[1, 2, 3];\n+\n+const BOO: &i32 = &42;\n+\n+fn main() {\n+    match &[1u8, 2, 3] as &[u8] {\n+        FOO => panic!(\"a\"),\n+        BAR => println!(\"b\"),\n+        _ => panic!(\"c\"),\n+    }\n+\n+    match b\"foo\" as &[u8] {\n+        FOO => println!(\"a\"),\n+        BAR => panic!(\"b\"),\n+        _ => panic!(\"c\"),\n+    }\n+\n+    match &43 {\n+        &42 => panic!(),\n+        BOO => panic!(),\n+        _ => println!(\"d\"),\n+    }\n+}"}, {"sha": "dedf5defebb7cf8196b9a205a04495118bebd87d", "filename": "src/test/run-pass/ctfe/repeat_match.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Frepeat_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Frepeat_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Frepeat_match.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/45044\n+\n+const X: [u8; 1] = [0; 1];\n+\n+fn main() {\n+    match &X {\n+        &X => println!(\"a\"),\n+        _ => println!(\"b\"),\n+    };\n+}"}, {"sha": "d57d3bcb49aa8d5c7f6de2be81b5865e1fcfc2f9", "filename": "src/test/run-pass/ctfe/return-in-const-fn.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Freturn-in-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Freturn-in-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Freturn-in-const-fn.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/43754\n+\n+#![feature(const_fn)]\n+const fn foo(x: usize) -> usize {\n+    return x;\n+}\n+fn main() {\n+    [0; foo(2)];\n+}"}, {"sha": "ecc5d3766367949db7f4cc6907fa87b95437cf34", "filename": "src/test/run-pass/ctfe/tuple-struct-constructors.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Ftuple-struct-constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Ftuple-struct-constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Ftuple-struct-constructors.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// https://github.com/rust-lang/rust/issues/41898\n+\n+#![feature(nonzero, const_fn)]\n+extern crate core;\n+use core::nonzero::NonZero;\n+\n+fn main() {\n+    const FOO: NonZero<u64> = unsafe { NonZero::new_unchecked(2) };\n+    if let FOO = FOO {}\n+}"}, {"sha": "f83f49f298b901d2b86227cddffa4bbad821497a", "filename": "src/test/run-pass/ctfe/union-ice.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Funion-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Fctfe%2Funion-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Funion-ice.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+type Field1 = i32;\n+type Field2 = f32;\n+type Field3 = i64;\n+\n+union DummyUnion {\n+    field1: Field1,\n+    field2: Field2,\n+    field3: Field3,\n+}\n+\n+const FLOAT1_AS_I32: i32 = 1065353216;\n+const UNION: DummyUnion = DummyUnion { field1: FLOAT1_AS_I32 };\n+\n+const fn read_field1() -> Field1 {\n+    const FIELD1: Field1 = unsafe { UNION.field1 };\n+    FIELD1\n+}\n+\n+const fn read_field2() -> Field2 {\n+    const FIELD2: Field2 = unsafe { UNION.field2 };\n+    FIELD2\n+}\n+\n+const fn read_field3() -> Field3 {\n+    const FIELD3: Field3 = unsafe { UNION.field3 };\n+    FIELD3\n+}\n+\n+fn main() {\n+    assert_eq!(read_field1(), FLOAT1_AS_I32);\n+    assert_eq!(read_field2(), 1.0);\n+    assert_eq!(read_field3(), unsafe { UNION.field3 });\n+}"}, {"sha": "80ab12482cbb7821c77e4dd5817a2eda40dfa326", "filename": "src/test/run-pass/float-int-invalid-const-cast.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Ffloat-int-invalid-const-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Frun-pass%2Ffloat-int-invalid-const-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-int-invalid-const-cast.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(i128_type)]\n+#![deny(const_err)]\n+\n+use std::{f32, f64};\n+\n+// Forces evaluation of constants, triggering hard error\n+fn force<T>(_: T) {}\n+\n+fn main() {\n+    { const X: u16 = -1. as u16; force(X); }\n+    { const X: u128 = -100. as u128; force(X); }\n+\n+    { const X: i8 = f32::NAN as i8; force(X); }\n+    { const X: i32 = f32::NAN as i32; force(X); }\n+    { const X: u64 = f32::NAN as u64; force(X); }\n+    { const X: u128 = f32::NAN as u128; force(X); }\n+\n+    { const X: i8 = f32::INFINITY as i8; force(X); }\n+    { const X: u32 = f32::INFINITY as u32; force(X); }\n+    { const X: i128 = f32::INFINITY as i128; force(X); }\n+    { const X: u128 = f32::INFINITY as u128; force(X); }\n+\n+    { const X: u8 = f32::NEG_INFINITY as u8; force(X); }\n+    { const X: u16 = f32::NEG_INFINITY as u16; force(X); }\n+    { const X: i64 = f32::NEG_INFINITY as i64; force(X); }\n+    { const X: i128 = f32::NEG_INFINITY as i128; force(X); }\n+\n+    { const X: i8 = f64::NAN as i8; force(X); }\n+    { const X: i32 = f64::NAN as i32; force(X); }\n+    { const X: u64 = f64::NAN as u64; force(X); }\n+    { const X: u128 = f64::NAN as u128; force(X); }\n+\n+    { const X: i8 = f64::INFINITY as i8; force(X); }\n+    { const X: u32 = f64::INFINITY as u32; force(X); }\n+    { const X: i128 = f64::INFINITY as i128; force(X); }\n+    { const X: u128 = f64::INFINITY as u128; force(X); }\n+\n+    { const X: u8 = f64::NEG_INFINITY as u8; force(X); }\n+    { const X: u16 = f64::NEG_INFINITY as u16; force(X); }\n+    { const X: i64 = f64::NEG_INFINITY as i64; force(X); }\n+    { const X: i128 = f64::NEG_INFINITY as i128; force(X); }\n+\n+    { const X: u8 = 256. as u8; force(X); }\n+    { const X: i8 = -129. as i8; force(X); }\n+    { const X: i8 = 128. as i8; force(X); }\n+    { const X: i32 = 2147483648. as i32; force(X); }\n+    { const X: i32 = -2147483904. as i32; force(X); }\n+    { const X: u32 = 4294967296. as u32; force(X); }\n+    { const X: u128 = 1e40 as u128; force(X); }\n+    { const X: i128 = 1e40 as i128; force(X); }\n+}"}, {"sha": "885edb55ed86c9a95ba09cdd68c1eaea1a62463d", "filename": "src/test/ui/const-eval-overflow-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval-overflow-2.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -19,8 +19,7 @@ use std::{u8, u16, u32, u64, usize};\n \n const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n-//~^ ERROR constant evaluation error\n-//~| attempt to negate with overflow\n+//~^ ERROR E0080\n \n fn main() {\n     match -128i8 {"}, {"sha": "f376de7cc4c1746fec1ae7d8ba65aa57d188d427", "filename": "src/test/ui/const-eval-overflow-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval-overflow-2.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -5,7 +5,7 @@ LL | const NEG_NEG_128: i8 = -NEG_128;\n    |                         ^^^^^^^^ attempt to negate with overflow\n    |\n note: for pattern here\n-  --> $DIR/const-eval-overflow-2.rs:27:9\n+  --> $DIR/const-eval-overflow-2.rs:26:9\n    |\n LL |         NEG_NEG_128 => println!(\"A\"),\n    |         ^^^^^^^^^^^"}, {"sha": "24e178152eef0cbd7010c09ebde0e942cd5d2f2d", "filename": "src/test/ui/const-eval-overflow-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval-overflow-4.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -21,8 +21,8 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1i8) as usize]\n-    //~^ ERROR constant evaluation error\n-    //~| WARNING constant evaluation error\n+    //~^ ERROR E0080\n+    //~| WARN attempt to add with overflow\n     = [0; (i8::MAX as usize) + 1];\n \n fn main() {"}, {"sha": "14753038fef04e3468cc8a3fcc574ddc6d6c60c1", "filename": "src/test/ui/const-eval-overflow-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval-overflow-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval-overflow-4.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,8 +1,8 @@\n-warning: constant evaluation error: attempt to add with overflow\n+warning: attempt to add with overflow\n   --> $DIR/const-eval-overflow-4.rs:23:13\n    |\n LL |     : [u32; (i8::MAX as i8 + 1i8) as usize]\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: #[warn(const_err)] on by default\n "}, {"sha": "324bcf60e8ff60d1c2c117b779712af6ce3db47d", "filename": "src/test/ui/const-eval/conditional_array_execution.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const X: u32 = 5;\n+const Y: u32 = 6;\n+const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n+//~^ WARN attempt to subtract with overflow\n+\n+fn main() {\n+    println!(\"{}\", FOO); //~ E0080\n+}"}, {"sha": "4cf12e222831c438be5ac5cb7d0b8a675b617da8", "filename": "src/test/ui/const-eval/conditional_array_execution.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconditional_array_execution.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,17 @@\n+warning: attempt to subtract with overflow\n+  --> $DIR/conditional_array_execution.rs:13:19\n+   |\n+LL | const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n+   |                   ^^^^^\n+   |\n+   = note: #[warn(const_err)] on by default\n+\n+error[E0080]: constant evaluation error\n+  --> $DIR/conditional_array_execution.rs:17:20\n+   |\n+LL |     println!(\"{}\", FOO); //~ E0080\n+   |                    ^^^ referenced constant has errors\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0080\""}, {"sha": "a64a1d212abf3254d8b434eb03ec65cd26f168d7", "filename": "src/test/ui/const-eval/const_transmute.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+// run-pass\n+\n+union Transmute<T: Copy, U: Copy> {\n+    t: T,\n+    u: U,\n+}\n+\n+trait Bar {\n+    fn bar(&self) -> u32;\n+}\n+\n+struct Foo {\n+    foo: u32,\n+    bar: bool,\n+}\n+\n+impl Bar for Foo {\n+    fn bar(&self) -> u32 {\n+        self.foo\n+    }\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        assert!(!self.bar);\n+        self.bar = true;\n+        println!(\"dropping Foo\");\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Fat<'a>(&'a Foo, &'static VTable);\n+\n+struct VTable {\n+    drop: Option<for<'a> fn(&'a mut Foo)>,\n+    size: usize,\n+    align: usize,\n+    bar: for<'a> fn(&'a Foo) -> u32,\n+}\n+\n+const FOO: &Bar = &Foo { foo: 128, bar: false };\n+const G: Fat = unsafe { Transmute { t: FOO }.u };\n+const F: Option<for<'a> fn(&'a mut Foo)> = G.1.drop;\n+const H: for<'a> fn(&'a Foo) -> u32 = G.1.bar;\n+\n+fn main() {\n+    let mut foo = Foo { foo: 99, bar: false };\n+    (F.unwrap())(&mut foo);\n+    std::mem::forget(foo); // already ran the drop impl\n+    assert_eq!(H(&Foo { foo: 42, bar: false }), 42);\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/const-eval/const_transmute.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "e7ffbe81b9ae7469175c3d6ffaeda9d6aeb70e30", "filename": "src/test/ui/const-eval/index_out_of_bound.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static FOO: i32 = [][0];\n+//~^ ERROR E0080\n+\n+fn main() {}"}, {"sha": "7651fb257e3ceb16ddddd3ae4c5f9e7117d17540", "filename": "src/test/ui/const-eval/index_out_of_bound.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bound.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: constant evaluation error\n+  --> $DIR/index_out_of_bound.rs:11:19\n+   |\n+LL | static FOO: i32 = [][0];\n+   |                   ^^^^^ index out of bounds: the len is 0 but the index is 0 at $DIR/index_out_of_bound.rs:11:19: 11:24\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0080\""}, {"sha": "d5c4796d0b497f86d8f98b545291b0e94e2cc2a4", "filename": "src/test/ui/const-eval/issue-43197.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -15,9 +15,11 @@ const fn foo(x: u32) -> u32 {\n }\n \n fn main() {\n-    const X: u32 = 0-1; //~ ERROR constant evaluation error\n-    //~^ WARN constant evaluation error\n-    const Y: u32 = foo(0-1); //~ ERROR constant evaluation error\n-    //~^ WARN constant evaluation error\n+    const X: u32 = 0-1;\n+    //~^ WARN attempt to subtract with overflow\n+    const Y: u32 = foo(0-1);\n+    //~^ WARN attempt to subtract with overflow\n     println!(\"{} {}\", X, Y);\n+    //~^ ERROR constant evaluation error\n+    //~| ERROR constant evaluation error\n }"}, {"sha": "3f10826874754d4987d37b023cdeb91e31c708f1", "filename": "src/test/ui/const-eval/issue-43197.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,28 +1,28 @@\n-warning: constant evaluation error: attempt to subtract with overflow\n+warning: attempt to subtract with overflow\n   --> $DIR/issue-43197.rs:18:20\n    |\n-LL |     const X: u32 = 0-1; //~ ERROR constant evaluation error\n+LL |     const X: u32 = 0-1;\n    |                    ^^^\n    |\n    = note: #[warn(const_err)] on by default\n \n-warning: constant evaluation error: attempt to subtract with overflow\n-  --> $DIR/issue-43197.rs:20:20\n+error[E0080]: constant evaluation error\n+  --> $DIR/issue-43197.rs:22:23\n    |\n-LL |     const Y: u32 = foo(0-1); //~ ERROR constant evaluation error\n-   |                    ^^^^^^^^\n+LL |     println!(\"{} {}\", X, Y);\n+   |                       ^ referenced constant has errors\n \n-error[E0080]: constant evaluation error\n-  --> $DIR/issue-43197.rs:18:20\n+warning: attempt to subtract with overflow\n+  --> $DIR/issue-43197.rs:20:24\n    |\n-LL |     const X: u32 = 0-1; //~ ERROR constant evaluation error\n-   |                    ^^^ attempt to subtract with overflow\n+LL |     const Y: u32 = foo(0-1);\n+   |                        ^^^\n \n error[E0080]: constant evaluation error\n-  --> $DIR/issue-43197.rs:20:24\n+  --> $DIR/issue-43197.rs:22:26\n    |\n-LL |     const Y: u32 = foo(0-1); //~ ERROR constant evaluation error\n-   |                        ^^^ attempt to subtract with overflow\n+LL |     println!(\"{} {}\", X, Y);\n+   |                          ^ referenced constant has errors\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4a2f0a7f38cda285489343fe85c1faf4cc6a2715", "filename": "src/test/ui/const-eval/issue-47971.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fissue-47971.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fissue-47971.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-47971.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(const_fn)]\n+\n+struct S(pub &'static u32, pub u32);\n+\n+const fn g(ss: &S) -> &u32 { &ss.1 }\n+\n+static T: S = S(g(&T), 0);\n+\n+fn main () { }"}, {"sha": "968a7de46910721ec22cbdefb6ea0a8faa0eb65d", "filename": "src/test/ui/const-eval/no_lint_for_statically_known_error.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fno_lint_for_statically_known_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fno_lint_for_statically_known_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fno_lint_for_statically_known_error.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+// if `X` were used instead of `x`, `X - 10` would result in a lint.\n+// This file should never produce a lint, no matter how the const\n+// propagator is improved.\n+\n+#![deny(warnings)]\n+\n+const X: u32 = 5;\n+\n+fn main() {\n+    let x = X;\n+    if x > 10 {\n+        println!(\"{}\", x - 10);\n+    } else {\n+        println!(\"{}\", 10 - x);\n+    }\n+}"}, {"sha": "bdb9f5b19a88541088a6cbcce2be7827e721fc24", "filename": "src/test/ui/const-eval/pub_const_err.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fpub_const_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fpub_const_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fpub_const_err.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(const_err)]\n+\n+#![crate_type = \"lib\"]\n+\n+pub const Z: u32 = 0 - 1;\n+//~^ ERROR attempt to subtract with overflow"}, {"sha": "b77ec38ca1679869a692892c8d8ed94bf3d795f9", "filename": "src/test/ui/const-eval/pub_const_err.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fpub_const_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-eval%2Fpub_const_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fpub_const_err.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -0,0 +1,14 @@\n+error: attempt to subtract with overflow\n+  --> $DIR/pub_const_err.rs:15:20\n+   |\n+LL | pub const Z: u32 = 0 - 1;\n+   |                    ^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/pub_const_err.rs:11:9\n+   |\n+LL | #![deny(const_err)]\n+   |         ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bfd6a4090649b7cfd8bfcef032efe092bdd0939b", "filename": "src/test/ui/const-expr-addr-operator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n // Encountered while testing #44614.\n+// must-compile-successfully\n \n pub fn main() {\n     // Constant of generic type (int)\n-    const X: &'static u32 = &22; //~ ERROR constant evaluation error\n+    const X: &'static u32 = &22;\n     assert_eq!(0, match &22 {\n         X => 0,\n         _ => 1,"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/const-expr-addr-operator.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,15 +0,0 @@\n-error[E0080]: constant evaluation error\n-  --> $DIR/const-expr-addr-operator.rs:15:29\n-   |\n-LL |     const X: &'static u32 = &22; //~ ERROR constant evaluation error\n-   |                             ^^^ unimplemented constant expression: address operator\n-   |\n-note: for pattern here\n-  --> $DIR/const-expr-addr-operator.rs:17:9\n-   |\n-LL |         X => 0,\n-   |         ^\n-\n-error: aborting due to previous error\n-\n-If you want more information on this error, try using \"rustc --explain E0080\""}, {"sha": "9e09f66776c9b04d23a541c11ffcc6932b321a57", "filename": "src/test/ui/const-fn-error.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-fn-error.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -13,17 +13,18 @@\n const X : usize = 2;\n \n const fn f(x: usize) -> usize {\n-    let mut sum = 0; //~ ERROR blocks in constant functions are limited\n-    for i in 0..x { //~ ERROR calls in constant functions\n-    //~| ERROR constant function contains unimplemented\n+    let mut sum = 0;\n+    //~^ ERROR E0016\n+    for i in 0..x {\n+        //~^ ERROR E0015\n+        //~| ERROR E0019\n+        //~| ERROR E0080\n         sum += i;\n     }\n-    sum //~ ERROR E0080\n-        //~| non-constant path in constant\n+    sum\n }\n \n #[allow(unused_variables)]\n fn main() {\n     let a : [i32; f(X)];\n-    //~^ WARNING constant evaluation error: non-constant path\n }"}, {"sha": "d57efce0dffc0a4d8c4a5e5eca4632b05a403c75", "filename": "src/test/ui/const-fn-error.stderr", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-fn-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-fn-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-fn-error.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,37 +1,32 @@\n-warning: constant evaluation error: non-constant path in constant expression\n-  --> $DIR/const-fn-error.rs:27:19\n-   |\n-LL |     let a : [i32; f(X)];\n-   |                   ^^^^\n-   |\n-   = note: #[warn(const_err)] on by default\n-\n error[E0016]: blocks in constant functions are limited to items and tail expressions\n   --> $DIR/const-fn-error.rs:16:19\n    |\n-LL |     let mut sum = 0; //~ ERROR blocks in constant functions are limited\n+LL |     let mut sum = 0;\n    |                   ^\n \n error[E0015]: calls in constant functions are limited to constant functions, struct and enum constructors\n-  --> $DIR/const-fn-error.rs:17:14\n+  --> $DIR/const-fn-error.rs:18:14\n    |\n-LL |     for i in 0..x { //~ ERROR calls in constant functions\n+LL |     for i in 0..x {\n    |              ^^^^\n \n error[E0019]: constant function contains unimplemented expression type\n-  --> $DIR/const-fn-error.rs:17:14\n+  --> $DIR/const-fn-error.rs:18:14\n    |\n-LL |     for i in 0..x { //~ ERROR calls in constant functions\n+LL |     for i in 0..x {\n    |              ^^^^\n \n error[E0080]: constant evaluation error\n-  --> $DIR/const-fn-error.rs:21:5\n+  --> $DIR/const-fn-error.rs:18:14\n    |\n-LL |     sum //~ ERROR E0080\n-   |     ^^^ non-constant path in constant expression\n+LL |     for i in 0..x {\n+   |              ^^^^ calling non-const fn `<I as std::iter::IntoIterator><std::ops::Range<usize>>::into_iter`\n+...\n+LL |     let a : [i32; f(X)];\n+   |                   ---- inside call to `f`\n    |\n note: for constant expression here\n-  --> $DIR/const-fn-error.rs:27:13\n+  --> $DIR/const-fn-error.rs:29:13\n    |\n LL |     let a : [i32; f(X)];\n    |             ^^^^^^^^^^^"}, {"sha": "ee07dabab1fc852c06d2f0c7a2bf486798bc4c5c", "filename": "src/test/ui/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -15,9 +15,10 @@\n const ONE: usize = 1;\n const TWO: usize = 2;\n const LEN: usize = ONE - TWO;\n-//~^ ERROR constant evaluation error [E0080]\n+//~^ ERROR E0080\n //~| WARN attempt to subtract with overflow\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();\n+//~^ ERROR E0080\n }"}, {"sha": "98f4ac9e83fb8ee05f7ff9d59854e9bfe2698c68", "filename": "src/test/ui/const-len-underflow-separate-spans.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,4 +1,4 @@\n-warning: constant evaluation error: attempt to subtract with overflow\n+warning: attempt to subtract with overflow\n   --> $DIR/const-len-underflow-separate-spans.rs:17:20\n    |\n LL | const LEN: usize = ONE - TWO;\n@@ -11,13 +11,13 @@ error[E0080]: constant evaluation error\n    |\n LL | const LEN: usize = ONE - TWO;\n    |                    ^^^^^^^^^ attempt to subtract with overflow\n-   |\n-note: for constant expression here\n-  --> $DIR/const-len-underflow-separate-spans.rs:22:12\n+\n+error[E0080]: constant evaluation error\n+  --> $DIR/const-len-underflow-separate-spans.rs:22:17\n    |\n LL |     let a: [i8; LEN] = unimplemented!();\n-   |            ^^^^^^^^^\n+   |                 ^^^ referenced constant has errors\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n If you want more information on this error, try using \"rustc --explain E0080\""}, {"sha": "09b24d1ffa208ba8d16fa47fea13523f6ccbaccd", "filename": "src/test/ui/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// must-compile-successfully\n+\n #![feature(const_fn)]\n \n #[derive(PartialEq, Eq)]\n@@ -20,8 +22,6 @@ use Cake::*;\n struct Pair<A, B>(A, B);\n \n const BOO: Pair<Cake, Cake> = Pair(Marmor, BlackForest);\n-//~^ ERROR: constant evaluation error [E0080]\n-//~| unimplemented constant expression: tuple struct constructors\n const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/const-pattern-not-const-evaluable.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -1,15 +0,0 @@\n-error[E0080]: constant evaluation error\n-  --> $DIR/const-pattern-not-const-evaluable.rs:22:31\n-   |\n-LL | const BOO: Pair<Cake, Cake> = Pair(Marmor, BlackForest);\n-   |                               ^^^^ unimplemented constant expression: tuple struct constructors\n-   |\n-note: for pattern here\n-  --> $DIR/const-pattern-not-const-evaluable.rs:37:9\n-   |\n-LL |         FOO => println!(\"hi\"),\n-   |         ^^^\n-\n-error: aborting due to previous error\n-\n-If you want more information on this error, try using \"rustc --explain E0080\""}, {"sha": "6162766b58705099f8dd489dec58a0b99e5423c5", "filename": "src/test/ui/discrim-overflow-2.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fdiscrim-overflow-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fdiscrim-overflow-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiscrim-overflow-2.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -2,65 +2,65 @@ error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:27:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 127i8\n+   |         ^^^^ overflowed on value after 127\n    |\n-   = note: explicitly set `OhNo = -128i8` if that is desired outcome\n+   = note: explicitly set `OhNo = -128` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:36:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 255u8\n+   |         ^^^^ overflowed on value after 255\n    |\n-   = note: explicitly set `OhNo = 0u8` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:45:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 32767i16\n+   |         ^^^^ overflowed on value after 32767\n    |\n-   = note: explicitly set `OhNo = -32768i16` if that is desired outcome\n+   = note: explicitly set `OhNo = -32768` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:54:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 65535u16\n+   |         ^^^^ overflowed on value after 65535\n    |\n-   = note: explicitly set `OhNo = 0u16` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:63:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 2147483647i32\n+   |         ^^^^ overflowed on value after 2147483647\n    |\n-   = note: explicitly set `OhNo = -2147483648i32` if that is desired outcome\n+   = note: explicitly set `OhNo = -2147483648` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:72:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 4294967295u32\n+   |         ^^^^ overflowed on value after 4294967295\n    |\n-   = note: explicitly set `OhNo = 0u32` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:81:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 9223372036854775807i64\n+   |         ^^^^ overflowed on value after 9223372036854775807\n    |\n-   = note: explicitly set `OhNo = -9223372036854775808i64` if that is desired outcome\n+   = note: explicitly set `OhNo = -9223372036854775808` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow-2.rs:90:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 18446744073709551615u64\n+   |         ^^^^ overflowed on value after 18446744073709551615\n    |\n-   = note: explicitly set `OhNo = 0u64` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error: aborting due to 8 previous errors\n "}, {"sha": "16b417c61a517d772cd7acb24f7406c764fef360", "filename": "src/test/ui/discrim-overflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fdiscrim-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fdiscrim-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiscrim-overflow.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -56,7 +56,7 @@ fn f_u16() {\n         Ok = u16::MAX - 1,\n         Ok2,\n         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-              //~| overflowed on value after 65535u16\n+              //~| overflowed on value after 65535\n     }\n \n     let x = A::Ok;\n@@ -68,7 +68,7 @@ fn f_i32() {\n         Ok = i32::MAX - 1,\n         Ok2,\n         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-              //~| overflowed on value after 2147483647i32\n+              //~| overflowed on value after 2147483647\n     }\n \n     let x = A::Ok;\n@@ -80,7 +80,7 @@ fn f_u32() {\n         Ok = u32::MAX - 1,\n         Ok2,\n         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-              //~| overflowed on value after 4294967295u32\n+              //~| overflowed on value after 4294967295\n     }\n \n     let x = A::Ok;\n@@ -92,7 +92,7 @@ fn f_i64() {\n         Ok = i64::MAX - 1,\n         Ok2,\n         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-              //~| overflowed on value after 9223372036854775807i64\n+              //~| overflowed on value after 9223372036854775807\n     }\n \n     let x = A::Ok;\n@@ -104,7 +104,7 @@ fn f_u64() {\n         Ok = u64::MAX - 1,\n         Ok2,\n         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-              //~| overflowed on value after 18446744073709551615u64\n+              //~| overflowed on value after 18446744073709551615\n     }\n \n     let x = A::Ok;"}, {"sha": "a713aea1b21ef5e5f45f2a23de5554fd24a3023d", "filename": "src/test/ui/discrim-overflow.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fdiscrim-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fdiscrim-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiscrim-overflow.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -2,65 +2,65 @@ error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:25:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 127i8\n+   |         ^^^^ overflowed on value after 127\n    |\n-   = note: explicitly set `OhNo = -128i8` if that is desired outcome\n+   = note: explicitly set `OhNo = -128` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:36:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 255u8\n+   |         ^^^^ overflowed on value after 255\n    |\n-   = note: explicitly set `OhNo = 0u8` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:47:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 32767i16\n+   |         ^^^^ overflowed on value after 32767\n    |\n-   = note: explicitly set `OhNo = -32768i16` if that is desired outcome\n+   = note: explicitly set `OhNo = -32768` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:58:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 65535u16\n+   |         ^^^^ overflowed on value after 65535\n    |\n-   = note: explicitly set `OhNo = 0u16` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:70:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 2147483647i32\n+   |         ^^^^ overflowed on value after 2147483647\n    |\n-   = note: explicitly set `OhNo = -2147483648i32` if that is desired outcome\n+   = note: explicitly set `OhNo = -2147483648` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:82:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 4294967295u32\n+   |         ^^^^ overflowed on value after 4294967295\n    |\n-   = note: explicitly set `OhNo = 0u32` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:94:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 9223372036854775807i64\n+   |         ^^^^ overflowed on value after 9223372036854775807\n    |\n-   = note: explicitly set `OhNo = -9223372036854775808i64` if that is desired outcome\n+   = note: explicitly set `OhNo = -9223372036854775808` if that is desired outcome\n \n error[E0370]: enum discriminant overflowed\n   --> $DIR/discrim-overflow.rs:106:9\n    |\n LL |         OhNo, //~ ERROR enum discriminant overflowed [E0370]\n-   |         ^^^^ overflowed on value after 18446744073709551615u64\n+   |         ^^^^ overflowed on value after 18446744073709551615\n    |\n-   = note: explicitly set `OhNo = 0u64` if that is desired outcome\n+   = note: explicitly set `OhNo = 0` if that is desired outcome\n \n error: aborting due to 8 previous errors\n "}, {"sha": "c8e425711284e529bfc4bb2d4184a677a1344b32", "filename": "src/test/ui/error-codes/E0080.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466", "patch": "@@ -10,9 +10,12 @@\n \n enum Enum {\n     X = (1 << 500), //~ ERROR E0080\n-    //~| WARNING shift left with overflow\n+    //~| shift left with overflow\n     Y = (1 / 0) //~ ERROR E0080\n-    //~| WARNING divide by zero\n+    //~| const_err\n+    //~| const_err\n+    //~| const_err\n+    //~| divide by zero\n }\n \n fn main() {"}, {"sha": "6db53acd6b9828323d1a8da6dc4bcdc6d1e749ad", "filename": "src/test/ui/error-codes/E0080.stderr", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0080.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0080.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0080.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "c0cdad258687da8c7b9b3d5692063fb37e1e8ea9", "filename": "src/test/ui/error-codes/E0081.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "e1133c1fc587e6b1f592a96e40b38c64812e8ec2", "filename": "src/test/ui/error-codes/E0081.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "60e077e063e09af170aba97b1d55fbceafa082bd", "filename": "src/test/ui/error-codes/E0370.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0370.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ferror-codes%2FE0370.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0370.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "eb5f746774cf13886c8eb9ffa377b8010ad9548e", "filename": "src/test/ui/feature-gate-const-indexing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/feature-gate-const-indexing.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "f98074bc554bbc857b364bb2108db676fd19cc33", "filename": "src/test/ui/infinite-recursion-const-fn.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "bc062ecce2587b21fd0b4020cf67f050c0c7490d", "filename": "src/test/ui/infinite-recursion-const-fn.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "7e696c97595aad27cee4a6b1f5eebb38a9497f96", "filename": "src/test/ui/issue-15524.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-15524.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "e26766eca373de6fb4547b6b7d2dfbeb576bdd68", "filename": "src/test/ui/issue-15524.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-15524.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-15524.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-15524.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "087eae43a299419331bdc20b442bf12dc801e130", "filename": "src/test/ui/issue-23302-1.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-1.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "66ba5c3258211c464295da2c1ff627a46b663a00", "filename": "src/test/ui/issue-23302-2.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-2.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "5903acc8b7a6d51c58079b71af97ebed169818eb", "filename": "src/test/ui/issue-23302-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-3.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "31168579394d3b74958e6facaecf1eb28fc4ac85", "filename": "src/test/ui/issue-23302-3.stderr", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-3.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "4323eb4858f404f7a710dffdbc5c1ad8f9e5bc3b", "filename": "src/test/ui/issue-36163.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36163.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "24cd20a84a9feebd3997a671788a8e90f568a9a0", "filename": "src/test/ui/issue-38875/issue_38875.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/issue-38875/issue_38875.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "aeafb45e6a552658f7e0b3968d0eaafe109cb927", "filename": "src/test/ui/union/union-const-eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Funion%2Funion-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Funion%2Funion-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-const-eval.rs?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/union/union-const-eval.stderr", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Funion%2Funion-const-eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c90f68224b069f5bb2a80e30e2737e4bb17c1466/src%2Ftest%2Fui%2Funion%2Funion-const-eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-const-eval.stderr?ref=c90f68224b069f5bb2a80e30e2737e4bb17c1466"}]}