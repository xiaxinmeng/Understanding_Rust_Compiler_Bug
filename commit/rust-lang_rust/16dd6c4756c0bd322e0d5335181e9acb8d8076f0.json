{"sha": "16dd6c4756c0bd322e0d5335181e9acb8d8076f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZGQ2YzQ3NTZjMGJkMzIyZTBkNTMzNTE4MWU5YWNiOGQ4MDc2ZjA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-17T02:19:37Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-17T02:20:36Z"}, "message": "Fix encoding of class ctors\n\nClass tests still fail at runtime", "tree": {"sha": "0633ea7092c8c014869d7cf39830a3511ec26b69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0633ea7092c8c014869d7cf39830a3511ec26b69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16dd6c4756c0bd322e0d5335181e9acb8d8076f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16dd6c4756c0bd322e0d5335181e9acb8d8076f0", "html_url": "https://github.com/rust-lang/rust/commit/16dd6c4756c0bd322e0d5335181e9acb8d8076f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16dd6c4756c0bd322e0d5335181e9acb8d8076f0/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d958123d8a8f348e022e0647545b9ec920afd9ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/d958123d8a8f348e022e0647545b9ec920afd9ee", "html_url": "https://github.com/rust-lang/rust/commit/d958123d8a8f348e022e0647545b9ec920afd9ee"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "e6615197c01b72a1b2704559eac17bb58b2a4473", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16dd6c4756c0bd322e0d5335181e9acb8d8076f0/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16dd6c4756c0bd322e0d5335181e9acb8d8076f0/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=16dd6c4756c0bd322e0d5335181e9acb8d8076f0", "patch": "@@ -51,6 +51,8 @@ fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n     }\n }\n \n+/* Returns a vector of possible def IDs for a given path,\n+   in a given crate */\n fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n                 path: [ast::ident]) ->\n     [(ast::crate_num, @[u8], ast::def_id)] {"}, {"sha": "aa9c7b2517446480201f1d77b48ca36bf7a3cc8f", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16dd6c4756c0bd322e0d5335181e9acb8d8076f0/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16dd6c4756c0bd322e0d5335181e9acb8d8076f0/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=16dd6c4756c0bd322e0d5335181e9acb8d8076f0", "patch": "@@ -177,8 +177,8 @@ fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n     ret ids;\n }\n \n-// Given a path and serialized crate metadata, returns the ID of the\n-// definition the path refers to.\n+// Given a path and serialized crate metadata, returns the IDs of the\n+// definitions the path may refer to.\n fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     fn eq_item(data: [u8], s: str) -> bool {\n         ret str::eq(str::from_bytes(data), s);"}, {"sha": "5d5ccb81538d5cb1e0eceed1cb1cd93758ece734", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/16dd6c4756c0bd322e0d5335181e9acb8d8076f0/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16dd6c4756c0bd322e0d5335181e9acb8d8076f0/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=16dd6c4756c0bd322e0d5335181e9acb8d8076f0", "patch": "@@ -152,9 +152,8 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n               encode_def_id(ebml_w, local_def(it.id));\n               ebml_w.end_tag();\n               ebml_w.start_tag(tag_paths);\n-              /* a bit confused -- adding the same ident twice\n-               (once for class, once for ctor) */\n               add_to_index(ebml_w, path, index, it.ident);\n+              #debug(\"ctor id: %d\", ctor.node.id);\n               encode_named_def_id(ebml_w, it.ident, local_def(ctor.node.id));\n               encode_class_item_paths(ebml_w, items, path + [it.ident],\n                                       index);\n@@ -364,7 +363,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             ebml_w.start_tag(tag_items_class_member); // ???\n             alt ci.node.decl {\n                instance_var(nm, _, _, id) {\n-                   #debug(\"encode_info_for_class: doing %s\", nm);\n+                   #debug(\"encode_info_for_class: doing %s %d\", nm, id);\n                    encode_family(ebml_w, 'g');\n                    encode_name(ebml_w, nm);\n                    encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n@@ -500,13 +499,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps,items,_) {\n+      item_class(tps,items,ctor) {\n           /* We're not forgetting about the ctor here! It gets\n-           encoded elsewhere */\n-          ebml_w.start_tag(tag_items_data_item);\n-         encode_info_for_class(ecx, ebml_w, item.id, path, item.ident,\n+             encoded elsewhere */\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_info_for_class(ecx, ebml_w, item.id, path, item.ident,\n                                tps, items);\n-         ebml_w.end_tag();\n+        ebml_w.end_tag();\n       }\n       item_res(_, tps, _, _, ctor_id) {\n         let fn_ty = node_id_to_type(tcx, ctor_id);\n@@ -639,23 +638,22 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             alt check ecx.ccx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) {\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n-              }\n-          /* TODO: encode info for class items! */\n-          /* encode ctor, then encode items */\n-          ast_map::node_ctor(i, path) {\n-            alt i.node {\n-               item_class(tps, _, ctor) {\n-                   #debug(\"class, encoding a fn: %d\", ctor.node.id);\n+                /* TODO: encode info for class items! */\n+                /* encode ctor, then encode items */\n+                alt i.node {\n+                  item_class(tps,_,ctor) {\n                    /* this is assuming that ctors aren't inlined...\n                       probably shouldn't assume that */\n+                   #debug(\"encoding info for ctor %s %d\", i.ident,\n+                          ctor.node.id);\n+                   *index += [{val: ctor.node.id, pos: ebml_w.writer.tell()}];\n                    encode_info_for_fn(ecx, ebml_w, ctor.node.id, i.ident,\n-                                      *path, none, tps, ctor.node.dec)\n-               }\n-               _ { /* TODO: should handle item_res, probably */ }\n+                                      *pt, none, tps, ctor.node.dec)\n+                  }\n+                  _ {}\n             }\n+           }\n           }\n-\n-            }\n         },\n         visit_native_item: {|ni, cx, v|\n             visit::visit_native_item(ni, cx, v);"}]}