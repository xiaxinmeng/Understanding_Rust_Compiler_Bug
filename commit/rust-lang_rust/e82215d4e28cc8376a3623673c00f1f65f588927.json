{"sha": "e82215d4e28cc8376a3623673c00f1f65f588927", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MjIxNWQ0ZTI4Y2M4Mzc2YTM2MjM2NzNjMDBmMWY2NWY1ODg5Mjc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-16T03:25:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-23T20:24:59Z"}, "message": "Review changes", "tree": {"sha": "6308c6e8570e0b951929e3d76c30bf77f69105b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6308c6e8570e0b951929e3d76c30bf77f69105b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e82215d4e28cc8376a3623673c00f1f65f588927", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e82215d4e28cc8376a3623673c00f1f65f588927", "html_url": "https://github.com/rust-lang/rust/commit/e82215d4e28cc8376a3623673c00f1f65f588927", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e82215d4e28cc8376a3623673c00f1f65f588927/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e840e49b21ba5af547e8e76003312f97f13f7b4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e840e49b21ba5af547e8e76003312f97f13f7b4f", "html_url": "https://github.com/rust-lang/rust/commit/e840e49b21ba5af547e8e76003312f97f13f7b4f"}], "stats": {"total": 228, "additions": 139, "deletions": 89}, "files": [{"sha": "9c3e53a1aceebd7437ddff9b107fe2dbee7d247a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -2542,6 +2542,64 @@ impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n     }\n }\n \n+\n+/// The `Step` trait identifies objects which can be stepped over in both\n+/// directions. The `steps_between` function provides a way to\n+/// compare two Step objects (it could be provided using `step()` and `Ord`,\n+/// but the implementation would be so inefficient as to be useless).\n+#[unstable = \"Trait is unstable.\"]\n+pub trait Step: Ord {\n+    /// Change self to the next object.\n+    fn step(&mut self);\n+    /// Change self to the previous object.\n+    fn step_back(&mut self);\n+    /// The steps_between two step objects.\n+    /// a should always be less than b, so the result should never be negative.\n+    /// Return None if it is not possible to calculate steps_between without\n+    /// overflow.\n+    fn steps_between(a: &Self, b: &Self) -> Option<uint>;\n+}\n+\n+macro_rules! step_impl {\n+    ($($t:ty)*) => ($(\n+        #[unstable = \"Trait is unstable.\"]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&mut self) { *self += 1; }\n+            #[inline]\n+            fn step_back(&mut self) { *self -= 1; }\n+            #[inline]\n+            fn steps_between(a: &$t, b: &$t) -> Option<uint> {\n+                debug_assert!(a < b);\n+                Some((*a - *b) as uint)\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! step_impl_no_between {\n+    ($($t:ty)*) => ($(\n+        #[unstable = \"Trait is unstable.\"]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&mut self) { *self += 1; }\n+            #[inline]\n+            fn step_back(&mut self) { *self -= 1; }\n+            #[inline]\n+            fn steps_between(_a: &$t, _b: &$t) -> Option<uint> {\n+                None\n+            }\n+        }\n+    )*)\n+}\n+\n+step_impl!(uint u8 u16 u32 int i8 i16 i32);\n+#[cfg(target_word_size = \"64\")]\n+step_impl!(u64 i64);\n+#[cfg(target_word_size = \"32\")]\n+step_impl_no_between!(u64 i64);\n+\n+\n /// An iterator that repeats an element endlessly\n #[deriving(Clone)]\n #[stable]"}, {"sha": "0cd8c1d69d1a1e06677f75856dcbe7df4702e570", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -52,10 +52,8 @@\n //! something to the screen.\n \n use clone::Clone;\n-use cmp::Ord;\n-use iter::{Iterator,DoubleEndedIterator};\n+use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use kinds::Sized;\n-use kinds::Copy;\n use option::Option::{mod, Some, None};\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n@@ -839,53 +837,13 @@ pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n }\n \n \n-\n-/// REVIEW could be in a better module\n-/// The `Countable` trait identifies objects which are countable, i.e., are\n-/// analogous to the natural numbers. A countable object can be incremented and\n-/// and decremented and ordered. The `difference` function provides a way to\n-/// compare two Countable objects (it could be provided using increment and Ord,\n-/// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"Trait is unstable.\"]\n-pub trait Countable: Ord {\n-    // FIXME(#19391) needs a snapshot\n-    //type T;\n-\n-    /// Change self to the next object.\n-    fn increment(&mut self);\n-    /// Change self to the previous object.\n-    fn decrement(&mut self);\n-    /// The difference between two countable objects.\n-    /// Temporarily a uint, should be an associated type, but\n-    // FIXME(#19391) needs a snapshot\n-    fn difference(a: &Self, b: &Self) -> uint;\n-    //fn difference(a: &Self, b: &Self) -> <Self as Countable>::T;\n-}\n-\n-macro_rules! countable_impl(\n-    ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n-        impl Countable for $t {\n-            // FIXME(#19391) needs a snapshot\n-            //type T = uint;\n-\n-            #[inline]\n-            fn increment(&mut self) { *self += 1; }\n-            #[inline]\n-            fn decrement(&mut self) { *self -= 1; }\n-            #[inline]\n-            fn difference(a: &$t, b: &$t) -> uint { (*a - *b) as uint }\n-        }\n-    )*)\n-)\n-\n-countable_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n-\n /// An unbounded range.\n+#[deriving(Copy)]\n #[lang=\"full_range\"]\n pub struct FullRange;\n \n-/// A range which i bounded at both ends.\n+/// A (half-open) range which is bounded at both ends.\n+#[deriving(Copy)]\n #[lang=\"range\"]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -895,13 +853,13 @@ pub struct Range<Idx> {\n }\n \n // FIXME(#19391) needs a snapshot\n-//impl<Idx: Clone + Countable<T=uint>> Iterator<Idx> for Range<Idx> {\n-impl<Idx: Clone + Countable> Iterator<Idx> for Range<Idx> {\n+//impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Step> Iterator<Idx> for Range<Idx> {\n     #[inline]\n     fn next(&mut self) -> Option<Idx> {\n         if self.start < self.end {\n             let result = self.start.clone();\n-            self.start.increment();\n+            self.start.step();\n             return Some(result);\n         }\n \n@@ -910,44 +868,46 @@ impl<Idx: Clone + Countable> Iterator<Idx> for Range<Idx> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let hint = Countable::difference(&self.end, &self.start);\n-        (hint, Some(hint))\n+        if let Some(hint) = Step::steps_between(&self.end, &self.start) {\n+            (hint, Some(hint))\n+        } else {\n+            (0, None)\n+        }\n     }\n }\n \n-impl<Idx: Clone + Countable> DoubleEndedIterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Step> DoubleEndedIterator<Idx> for Range<Idx> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Idx> {\n         if self.start < self.end {\n-            self.end.decrement();\n+            self.end.step_back();\n             return Some(self.end.clone());\n         }\n \n         return None;\n     }\n }\n \n+impl<Idx: Clone + Step> ExactSizeIterator<Idx> for Range<Idx> {}\n+\n /// A range which is only bounded below.\n+#[deriving(Copy)]\n #[lang=\"range_from\"]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n-impl<Idx: Clone + Countable> Iterator<Idx> for RangeFrom<Idx> {\n+impl<Idx: Clone + Step> Iterator<Idx> for RangeFrom<Idx> {\n     #[inline]\n     fn next(&mut self) -> Option<Idx> {\n         // Deliberately overflow so we loop forever.\n         let result = self.start.clone();\n-        self.start.increment();\n+        self.start.step();\n         return Some(result);\n     }\n }\n \n-impl<Idx: Copy> Copy for Range<Idx> {}\n-impl<Idx: Copy> Copy for RangeFrom<Idx> {}\n-impl Copy for FullRange {}\n-\n \n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations like `*v`."}, {"sha": "a8889ce9e348bd00c059582b506a45e479d68350", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -34,19 +34,25 @@ fn alloc_obj_with_dtor(b: &mut Bencher) {\n #[test]\n fn test_range() {\n     let r = Range { start: 2u, end: 10 };\n+    let mut count = 0u;\n     for (i, ri) in r.enumerate() {\n         assert!(ri == i + 2);\n         assert!(ri >= 2u && ri < 10u);\n+        count += 1;\n     }\n+    assert!(count == 8);\n }\n \n #[test]\n fn test_range_from() {\n     let r = RangeFrom { start: 2u };\n+    let mut count = 0u;\n     for (i, ri) in r.take(10).enumerate() {\n         assert!(ri == i + 2);\n         assert!(ri >= 2u && ri < 12u);\n+        count += 1;\n     }\n+    assert!(count == 10);\n }\n \n #[test]"}, {"sha": "b57b5554ed64ffc25de74b50b76c201e6d959915", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -366,6 +366,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n             infer::IfExpression(_) => \"if and else have incompatible types\",\n             infer::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n+            infer::RangeExpression(_) => \"start and end of range have incompatible types\",\n             infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n         };\n \n@@ -1490,6 +1491,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     infer::IfExpressionWithNoElse(_) => {\n                         format!(\"if may be missing an else clause\")\n                     }\n+                    infer::RangeExpression(_) => {\n+                        format!(\"start and end of range have compatible types\")\n+                    }\n                     infer::EquatePredicate(_) => {\n                         format!(\"equality where clause is satisfied\")\n                     }"}, {"sha": "07823779216d96cbe6015f4385348eac6f9e8f20", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -127,6 +127,9 @@ pub enum TypeOrigin {\n     // Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse(Span),\n \n+    // Computing common supertype in a range expression\n+    RangeExpression(Span),\n+\n     // `where a == b`\n     EquatePredicate(Span),\n }\n@@ -1084,6 +1087,7 @@ impl TypeOrigin {\n             MatchExpressionArm(match_span, _) => match_span,\n             IfExpression(span) => span,\n             IfExpressionWithNoElse(span) => span,\n+            RangeExpression(span) => span,\n             EquatePredicate(span) => span,\n         }\n     }\n@@ -1117,6 +1121,9 @@ impl<'tcx> Repr<'tcx> for TypeOrigin {\n             IfExpressionWithNoElse(a) => {\n                 format!(\"IfExpressionWithNoElse({})\", a.repr(tcx))\n             }\n+            RangeExpression(a) => {\n+                format!(\"RangeExpression({})\", a.repr(tcx))\n+            }\n             EquatePredicate(a) => {\n                 format!(\"EquatePredicate({})\", a.repr(tcx))\n             }"}, {"sha": "380f34b144515383c6554d8445317756b71c8db5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -4279,44 +4279,59 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           }\n        }\n        ast::ExprRange(ref start, ref end) => {\n-          let mut some_err = false;\n-\n           check_expr(fcx, &**start);\n           let t_start = fcx.expr_ty(&**start);\n-          if ty::type_is_error(t_start) {\n-            fcx.write_ty(start.id, t_start);\n-            some_err = true;\n-          }\n \n-          if let &Some(ref e) = end {\n-              check_expr_has_type(fcx, &**e, t_start);\n-              let t_end = fcx.expr_ty(&**e);\n-              if ty::type_is_error(t_end) {\n-                fcx.write_ty(e.id, t_end);\n-                some_err = true;\n-              }\n-          }\n+          let idx_type = if let &Some(ref e) = end {\n+            check_expr(fcx, &**e);\n+            let t_end = fcx.expr_ty(&**e);\n+            if ty::type_is_error(t_end) {\n+                ty::mk_err()\n+            } else if t_start == ty::mk_err() {\n+                ty::mk_err()\n+            } else {\n+                infer::common_supertype(fcx.infcx(),\n+                                        infer::RangeExpression(expr.span),\n+                                        true,\n+                                        t_start,\n+                                        t_end)\n+            }\n+          } else {\n+            t_start\n+          };\n \n-          // Note that we don't check the type of the start/end satisfy any\n+          // Note that we don't check the type of start/end satisfy any\n           // bounds because right the range structs do not have any. If we add\n           // some bounds, then we'll need to check `t_start` against them here.\n \n-          if !some_err {\n+          let range_type = if idx_type == ty::mk_err() {\n+            ty::mk_err()\n+          } else {\n             // Find the did from the appropriate lang item.\n             let did = if end.is_some() {\n                 // Range\n-                fcx.tcx().lang_items.range_struct()\n+                tcx.lang_items.range_struct()\n             } else {\n                 // RangeFrom\n-                fcx.tcx().lang_items.range_from_struct()\n+                tcx.lang_items.range_from_struct()\n             };\n+\n             if let Some(did) = did {\n-                let substs = Substs::new_type(vec![t_start], vec![]);\n-                fcx.write_ty(id, ty::mk_struct(tcx, did, substs));\n+                let polytype = ty::lookup_item_type(tcx, did);\n+                let substs = Substs::new_type(vec![idx_type], vec![]);\n+                let bounds = polytype.generics.to_bounds(tcx, &substs);\n+                fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::new(expr.span,\n+                                                 fcx.body_id,\n+                                                 traits::ItemObligation(did)),\n+                    &bounds);\n+\n+                ty::mk_struct(tcx, did, substs)\n             } else {\n-                fcx.write_ty(id, ty::mk_err());\n+                ty::mk_err()\n             }\n-          }\n+          };\n+          fcx.write_ty(id, range_type);\n        }\n \n     }"}, {"sha": "ca7401dc26c8c8e44563cc98e737c1c3e654c8f6", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -13,7 +13,7 @@\n pub fn main() {\n     // Mixed types.\n     let _ = 0u..10i;\n-    //~^ ERROR mismatched types: expected `uint`, found `int`\n+    //~^ ERROR start and end of range have incompatible types\n \n     // Float => does not implement iterator.\n     for i in 0f32..42f32 {}"}, {"sha": "40690bd844bce6f6980e95b770b41c18fa75bcd2", "filename": "src/test/compile-fail/range-2.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-2.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -11,13 +11,6 @@\n // Test range syntax - borrow errors.\n \n pub fn main() {\n-    let x = &42i;\n-    {\n-        let y = 42i;\n-        let r = x..&y;\n-        //~^ ERROR `y` does not live long enough\n-    }\n-\n     let r = {\n         (&42i)..&42\n         //~^ ERROR borrowed value does not live long enough"}, {"sha": "027121dd4229d4d0453cf99297dfb8d6c42abc29", "filename": "src/test/run-pass/range.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Ftest%2Frun-pass%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82215d4e28cc8376a3623673c00f1f65f588927/src%2Ftest%2Frun-pass%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange.rs?ref=e82215d4e28cc8376a3623673c00f1f65f588927", "patch": "@@ -38,4 +38,11 @@ pub fn main() {\n \n     let _ = 0u..4+4-3;\n     let _ = 0..foo();\n+\n+    // Test we can use two different types with a common supertype.\n+    let x = &42i;\n+    {\n+        let y = 42i;\n+        let _ = x..&y;\n+    }\n }"}]}