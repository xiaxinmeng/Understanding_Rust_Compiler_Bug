{"sha": "a3bb8585e89f1eade039111733a2f1efa331e6ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYmI4NTg1ZTg5ZjFlYWRlMDM5MTExNzMzYTJmMWVmYTMzMWU2ZmY=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2014-12-03T14:57:45Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2014-12-03T15:59:52Z"}, "message": "rustdoc: Refactored various uses of ItemType.\n\nIn particular, ItemType variants are no longer reexported. Since\nwe already do namespace them via `item_type` mod, it's fine.", "tree": {"sha": "e0c87b76dcb08a34d35cc2e1879d4848a0351400", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0c87b76dcb08a34d35cc2e1879d4848a0351400"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3bb8585e89f1eade039111733a2f1efa331e6ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3bb8585e89f1eade039111733a2f1efa331e6ff", "html_url": "https://github.com/rust-lang/rust/commit/a3bb8585e89f1eade039111733a2f1efa331e6ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3bb8585e89f1eade039111733a2f1efa331e6ff/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "131d4ed018f43a07324aebdd68a997b731945b0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/131d4ed018f43a07324aebdd68a997b731945b0b", "html_url": "https://github.com/rust-lang/rust/commit/131d4ed018f43a07324aebdd68a997b731945b0b"}], "stats": {"total": 249, "additions": 129, "deletions": 120}, "files": [{"sha": "9861d18ce51f0b245f52f5785487c47a0280db36", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3bb8585e89f1eade039111733a2f1efa331e6ff/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3bb8585e89f1eade039111733a2f1efa331e6ff/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a3bb8585e89f1eade039111733a2f1efa331e6ff", "patch": "@@ -23,7 +23,6 @@ use syntax::ast_util;\n \n use clean;\n use stability_summary::ModuleSummary;\n-use html::item_type;\n use html::item_type::ItemType;\n use html::render;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n@@ -283,7 +282,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n                 url.push_str(\"/\");\n             }\n             match shortty {\n-                item_type::Module => {\n+                ItemType::Module => {\n                     url.push_str(fqp.last().unwrap().as_slice());\n                     url.push_str(\"/index.html\");\n                 }"}, {"sha": "1917184c5a9904beda0fba80d4f3456412068df6", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a3bb8585e89f1eade039111733a2f1efa331e6ff/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3bb8585e89f1eade039111733a2f1efa331e6ff/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=a3bb8585e89f1eade039111733a2f1efa331e6ff", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Item types.\n-pub use self::ItemType::*;\n \n use std::fmt;\n use clean;\n@@ -44,27 +43,64 @@ pub enum ItemType {\n }\n \n impl ItemType {\n+    pub fn from_item(item: &clean::Item) -> ItemType {\n+        match item.inner {\n+            clean::ModuleItem(..)          => ItemType::Module,\n+            clean::StructItem(..)          => ItemType::Struct,\n+            clean::EnumItem(..)            => ItemType::Enum,\n+            clean::FunctionItem(..)        => ItemType::Function,\n+            clean::TypedefItem(..)         => ItemType::Typedef,\n+            clean::StaticItem(..)          => ItemType::Static,\n+            clean::ConstantItem(..)        => ItemType::Constant,\n+            clean::TraitItem(..)           => ItemType::Trait,\n+            clean::ImplItem(..)            => ItemType::Impl,\n+            clean::ViewItemItem(..)        => ItemType::ViewItem,\n+            clean::TyMethodItem(..)        => ItemType::TyMethod,\n+            clean::MethodItem(..)          => ItemType::Method,\n+            clean::StructFieldItem(..)     => ItemType::StructField,\n+            clean::VariantItem(..)         => ItemType::Variant,\n+            clean::ForeignFunctionItem(..) => ItemType::ForeignFunction,\n+            clean::ForeignStaticItem(..)   => ItemType::ForeignStatic,\n+            clean::MacroItem(..)           => ItemType::Macro,\n+            clean::PrimitiveItem(..)       => ItemType::Primitive,\n+            clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n+        }\n+    }\n+\n+    pub fn from_type_kind(kind: clean::TypeKind) -> ItemType {\n+        match kind {\n+            clean::TypeStruct   => ItemType::Struct,\n+            clean::TypeEnum     => ItemType::Enum,\n+            clean::TypeFunction => ItemType::Function,\n+            clean::TypeTrait    => ItemType::Trait,\n+            clean::TypeModule   => ItemType::Module,\n+            clean::TypeStatic   => ItemType::Static,\n+            clean::TypeVariant  => ItemType::Variant,\n+            clean::TypeTypedef  => ItemType::Typedef,\n+        }\n+    }\n+\n     pub fn to_static_str(&self) -> &'static str {\n         match *self {\n-            Module          => \"mod\",\n-            Struct          => \"struct\",\n-            Enum            => \"enum\",\n-            Function        => \"fn\",\n-            Typedef         => \"type\",\n-            Static          => \"static\",\n-            Trait           => \"trait\",\n-            Impl            => \"impl\",\n-            ViewItem        => \"viewitem\",\n-            TyMethod        => \"tymethod\",\n-            Method          => \"method\",\n-            StructField     => \"structfield\",\n-            Variant         => \"variant\",\n-            ForeignFunction => \"ffi\",\n-            ForeignStatic   => \"ffs\",\n-            Macro           => \"macro\",\n-            Primitive       => \"primitive\",\n-            AssociatedType  => \"associatedtype\",\n-            Constant        => \"constant\",\n+            ItemType::Module          => \"mod\",\n+            ItemType::Struct          => \"struct\",\n+            ItemType::Enum            => \"enum\",\n+            ItemType::Function        => \"fn\",\n+            ItemType::Typedef         => \"type\",\n+            ItemType::Static          => \"static\",\n+            ItemType::Trait           => \"trait\",\n+            ItemType::Impl            => \"impl\",\n+            ItemType::ViewItem        => \"viewitem\",\n+            ItemType::TyMethod        => \"tymethod\",\n+            ItemType::Method          => \"method\",\n+            ItemType::StructField     => \"structfield\",\n+            ItemType::Variant         => \"variant\",\n+            ItemType::ForeignFunction => \"ffi\",\n+            ItemType::ForeignStatic   => \"ffs\",\n+            ItemType::Macro           => \"macro\",\n+            ItemType::Primitive       => \"primitive\",\n+            ItemType::AssociatedType  => \"associatedtype\",\n+            ItemType::Constant        => \"constant\",\n         }\n     }\n }\n@@ -75,27 +111,3 @@ impl fmt::Show for ItemType {\n     }\n }\n \n-pub fn shortty(item: &clean::Item) -> ItemType {\n-    match item.inner {\n-        clean::ModuleItem(..)          => Module,\n-        clean::StructItem(..)          => Struct,\n-        clean::EnumItem(..)            => Enum,\n-        clean::FunctionItem(..)        => Function,\n-        clean::TypedefItem(..)         => Typedef,\n-        clean::StaticItem(..)          => Static,\n-        clean::ConstantItem(..)        => Constant,\n-        clean::TraitItem(..)           => Trait,\n-        clean::ImplItem(..)            => Impl,\n-        clean::ViewItemItem(..)        => ViewItem,\n-        clean::TyMethodItem(..)        => TyMethod,\n-        clean::MethodItem(..)          => Method,\n-        clean::StructFieldItem(..)     => StructField,\n-        clean::VariantItem(..)         => Variant,\n-        clean::ForeignFunctionItem(..) => ForeignFunction,\n-        clean::ForeignStaticItem(..)   => ForeignStatic,\n-        clean::MacroItem(..)           => Macro,\n-        clean::PrimitiveItem(..)       => Primitive,\n-        clean::AssociatedTypeItem(..)  => AssociatedType,\n-    }\n-}\n-"}, {"sha": "8c2be47d9c0f4b748050359e906a9c16f87c21fa", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 72, "deletions": 74, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a3bb8585e89f1eade039111733a2f1efa331e6ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3bb8585e89f1eade039111733a2f1efa331e6ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a3bb8585e89f1eade039111733a2f1efa331e6ff", "patch": "@@ -61,8 +61,7 @@ use fold::DocFolder;\n use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace, Stability};\n use html::format::{ConciseStability, TyParamBounds, WhereClause};\n use html::highlight;\n-use html::item_type::{ItemType, shortty};\n-use html::item_type;\n+use html::item_type::ItemType;\n use html::layout;\n use html::markdown::Markdown;\n use html::markdown;\n@@ -314,19 +313,8 @@ pub fn run(mut krate: clean::Crate,\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n-        paths.into_iter().map(|(k, (v, t))| {\n-            (k, (v, match t {\n-                clean::TypeStruct => item_type::Struct,\n-                clean::TypeEnum => item_type::Enum,\n-                clean::TypeFunction => item_type::Function,\n-                clean::TypeTrait => item_type::Trait,\n-                clean::TypeModule => item_type::Module,\n-                clean::TypeStatic => item_type::Static,\n-                clean::TypeVariant => item_type::Variant,\n-                clean::TypeTypedef => item_type::Typedef,\n-            }))\n-        }).collect()\n-    }).unwrap_or(HashMap::new());\n+        paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t)))).collect()\n+      }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n         external_paths: paths.iter().map(|(&k, v)| (k, v.ref0().clone()))\n@@ -359,7 +347,7 @@ pub fn run(mut krate: clean::Crate,\n     for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n+        cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n     // Cache where all known primitives have their documentation located.\n@@ -642,6 +630,11 @@ fn mkdir(path: &Path) -> io::IoResult<()> {\n     }\n }\n \n+/// Returns a documentation-level item type from the item.\n+fn shortty(item: &clean::Item) -> ItemType {\n+    ItemType::from_item(item)\n+}\n+\n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree.\n@@ -855,13 +848,13 @@ impl DocFolder for Cache {\n                         let last = self.parent_stack.last().unwrap();\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n-                            Some(&(_, item_type::Trait)) =>\n+                            Some(&(_, ItemType::Trait)) =>\n                                 Some(self.stack[..self.stack.len() - 1]),\n                             // The current stack not necessarily has correlation for\n                             // where the type was defined. On the other hand,\n                             // `paths` always has the right information if present.\n-                            Some(&(ref fqp, item_type::Struct)) |\n-                            Some(&(ref fqp, item_type::Enum)) =>\n+                            Some(&(ref fqp, ItemType::Struct)) |\n+                            Some(&(ref fqp, ItemType::Enum)) =>\n                                 Some(fqp[..fqp.len() - 1]),\n                             Some(..) => Some(self.stack.as_slice()),\n                             None => None\n@@ -929,7 +922,7 @@ impl DocFolder for Cache {\n             clean::VariantItem(..) if !self.privmod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n-                self.paths.insert(item.def_id, (stack, item_type::Enum));\n+                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n             }\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n@@ -1491,45 +1484,50 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         !cx.ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n+    // the order of item types in the listing\n+    fn reorder(ty: ItemType) -> u8 {\n+        match ty {\n+            ItemType::ViewItem        => 0,\n+            ItemType::Primitive       => 1,\n+            ItemType::Module          => 2,\n+            ItemType::Macro           => 3,\n+            ItemType::Struct          => 4,\n+            ItemType::Enum            => 5,\n+            ItemType::Constant        => 6,\n+            ItemType::Static          => 7,\n+            ItemType::ForeignFunction => 8,\n+            ItemType::ForeignStatic   => 9,\n+            ItemType::Trait           => 10,\n+            ItemType::Function        => 11,\n+            ItemType::Typedef         => 12,\n+            _                         => 13 + ty as u8,\n+        }\n+    }\n+\n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n-        if shortty(i1) == shortty(i2) {\n+        let ty1 = shortty(i1);\n+        let ty2 = shortty(i2);\n+        if ty1 == ty2 {\n             return i1.name.cmp(&i2.name);\n         }\n-        match (&i1.inner, &i2.inner) {\n-            (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n-                match (&a.inner, &b.inner) {\n-                    (&clean::ExternCrate(..), _) => Less,\n-                    (_, &clean::ExternCrate(..)) => Greater,\n-                    _ => idx1.cmp(&idx2),\n+\n+        let tycmp = reorder(ty1).cmp(&reorder(ty2));\n+        if let Equal = tycmp {\n+            // for reexports, `extern crate` takes precedence.\n+            match (&i1.inner, &i2.inner) {\n+                (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n+                    match (&a.inner, &b.inner) {\n+                        (&clean::ExternCrate(..), _) => return Less,\n+                        (_, &clean::ExternCrate(..)) => return Greater,\n+                        _ => {}\n+                    }\n                 }\n+                (_, _) => {}\n             }\n-            (&clean::ViewItemItem(..), _) => Less,\n-            (_, &clean::ViewItemItem(..)) => Greater,\n-            (&clean::PrimitiveItem(..), _) => Less,\n-            (_, &clean::PrimitiveItem(..)) => Greater,\n-            (&clean::ModuleItem(..), _) => Less,\n-            (_, &clean::ModuleItem(..)) => Greater,\n-            (&clean::MacroItem(..), _) => Less,\n-            (_, &clean::MacroItem(..)) => Greater,\n-            (&clean::StructItem(..), _) => Less,\n-            (_, &clean::StructItem(..)) => Greater,\n-            (&clean::EnumItem(..), _) => Less,\n-            (_, &clean::EnumItem(..)) => Greater,\n-            (&clean::ConstantItem(..), _) => Less,\n-            (_, &clean::ConstantItem(..)) => Greater,\n-            (&clean::StaticItem(..), _) => Less,\n-            (_, &clean::StaticItem(..)) => Greater,\n-            (&clean::ForeignFunctionItem(..), _) => Less,\n-            (_, &clean::ForeignFunctionItem(..)) => Greater,\n-            (&clean::ForeignStaticItem(..), _) => Less,\n-            (_, &clean::ForeignStaticItem(..)) => Greater,\n-            (&clean::TraitItem(..), _) => Less,\n-            (_, &clean::TraitItem(..)) => Greater,\n-            (&clean::FunctionItem(..), _) => Less,\n-            (_, &clean::FunctionItem(..)) => Greater,\n-            (&clean::TypedefItem(..), _) => Less,\n-            (_, &clean::TypedefItem(..)) => Greater,\n-            _ => idx1.cmp(&idx2),\n+\n+            idx1.cmp(&idx2)\n+        } else {\n+            tycmp\n         }\n     }\n \n@@ -1546,26 +1544,26 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n-            let (short, name) = match myitem.inner {\n-                clean::ModuleItem(..)          => (\"modules\", \"Modules\"),\n-                clean::StructItem(..)          => (\"structs\", \"Structs\"),\n-                clean::EnumItem(..)            => (\"enums\", \"Enums\"),\n-                clean::FunctionItem(..)        => (\"functions\", \"Functions\"),\n-                clean::TypedefItem(..)         => (\"types\", \"Type Definitions\"),\n-                clean::StaticItem(..)          => (\"statics\", \"Statics\"),\n-                clean::ConstantItem(..)        => (\"constants\", \"Constants\"),\n-                clean::TraitItem(..)           => (\"traits\", \"Traits\"),\n-                clean::ImplItem(..)            => (\"impls\", \"Implementations\"),\n-                clean::ViewItemItem(..)        => (\"reexports\", \"Reexports\"),\n-                clean::TyMethodItem(..)        => (\"tymethods\", \"Type Methods\"),\n-                clean::MethodItem(..)          => (\"methods\", \"Methods\"),\n-                clean::StructFieldItem(..)     => (\"fields\", \"Struct Fields\"),\n-                clean::VariantItem(..)         => (\"variants\", \"Variants\"),\n-                clean::ForeignFunctionItem(..) => (\"ffi-fns\", \"Foreign Functions\"),\n-                clean::ForeignStaticItem(..)   => (\"ffi-statics\", \"Foreign Statics\"),\n-                clean::MacroItem(..)           => (\"macros\", \"Macros\"),\n-                clean::PrimitiveItem(..)       => (\"primitives\", \"Primitive Types\"),\n-                clean::AssociatedTypeItem(..)  => (\"associated-types\", \"Associated Types\"),\n+            let (short, name) = match myty.unwrap() {\n+                ItemType::Module          => (\"modules\", \"Modules\"),\n+                ItemType::Struct          => (\"structs\", \"Structs\"),\n+                ItemType::Enum            => (\"enums\", \"Enums\"),\n+                ItemType::Function        => (\"functions\", \"Functions\"),\n+                ItemType::Typedef         => (\"types\", \"Type Definitions\"),\n+                ItemType::Static          => (\"statics\", \"Statics\"),\n+                ItemType::Constant        => (\"constants\", \"Constants\"),\n+                ItemType::Trait           => (\"traits\", \"Traits\"),\n+                ItemType::Impl            => (\"impls\", \"Implementations\"),\n+                ItemType::ViewItem        => (\"reexports\", \"Reexports\"),\n+                ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n+                ItemType::Method          => (\"methods\", \"Methods\"),\n+                ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n+                ItemType::Variant         => (\"variants\", \"Variants\"),\n+                ItemType::ForeignFunction => (\"ffi-fns\", \"Foreign Functions\"),\n+                ItemType::ForeignStatic   => (\"ffi-statics\", \"Foreign Statics\"),\n+                ItemType::Macro           => (\"macros\", \"Macros\"),\n+                ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n+                ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\"}]}