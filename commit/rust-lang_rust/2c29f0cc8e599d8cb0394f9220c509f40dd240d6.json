{"sha": "2c29f0cc8e599d8cb0394f9220c509f40dd240d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMjlmMGNjOGU1OTlkOGNiMDM5NGY5MjIwYzUwOWY0MGRkMjQwZDY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-05T21:13:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-05-02T16:51:38Z"}, "message": "typeck/wfcheck: require that explicit enum discriminants const-evaluate succesfully.", "tree": {"sha": "deee3d1eeccad241ca53befb7da58fd2a48f82df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deee3d1eeccad241ca53befb7da58fd2a48f82df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c29f0cc8e599d8cb0394f9220c509f40dd240d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c29f0cc8e599d8cb0394f9220c509f40dd240d6", "html_url": "https://github.com/rust-lang/rust/commit/2c29f0cc8e599d8cb0394f9220c509f40dd240d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c29f0cc8e599d8cb0394f9220c509f40dd240d6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c63e48f17323c55844110fbcb3e09ea3d25227", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c63e48f17323c55844110fbcb3e09ea3d25227", "html_url": "https://github.com/rust-lang/rust/commit/50c63e48f17323c55844110fbcb3e09ea3d25227"}], "stats": {"total": 37, "additions": 35, "deletions": 2}, "files": [{"sha": "e82e40503e08b05494d93bca6375eda9fd38b07d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2c29f0cc8e599d8cb0394f9220c509f40dd240d6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c29f0cc8e599d8cb0394f9220c509f40dd240d6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=2c29f0cc8e599d8cb0394f9220c509f40dd240d6", "patch": "@@ -411,6 +411,23 @@ fn check_type_defn<'tcx, F>(\n                     ObligationCauseCode::MiscObligation,\n                 )\n             }\n+\n+            // Explicit `enum` discriminant values must const-evaluate successfully.\n+            if let Some(discr_def_id) = variant.explicit_discr {\n+                let discr_substs =\n+                    InternalSubsts::identity_for_item(fcx.tcx, discr_def_id.to_def_id());\n+\n+                let cause = traits::ObligationCause::new(\n+                    fcx.tcx.def_span(discr_def_id),\n+                    fcx.body_id,\n+                    traits::MiscObligation,\n+                );\n+                fcx.register_predicate(traits::Obligation::new(\n+                    cause,\n+                    fcx.param_env,\n+                    ty::Predicate::ConstEvaluatable(discr_def_id.to_def_id(), discr_substs),\n+                ));\n+            }\n         }\n \n         check_where_clauses(tcx, fcx, item.span, def_id.to_def_id(), None);\n@@ -1287,8 +1304,14 @@ impl ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // ADT\n \n+// FIXME(eddyb) replace this with getting fields/discriminants through `ty::AdtDef`.\n struct AdtVariant<'tcx> {\n+    /// Types of fields in the variant, that must be well-formed.\n     fields: Vec<AdtField<'tcx>>,\n+\n+    /// Explicit discriminant of this variant (e.g. `A = 123`),\n+    /// that must evaluate to a constant value.\n+    explicit_discr: Option<LocalDefId>,\n }\n \n struct AdtField<'tcx> {\n@@ -1297,6 +1320,7 @@ struct AdtField<'tcx> {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n     fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n         let fields = struct_def\n             .fields()\n@@ -1309,11 +1333,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 AdtField { ty: field_ty, span: field.span }\n             })\n             .collect();\n-        AdtVariant { fields }\n+        AdtVariant { fields, explicit_discr: None }\n     }\n \n     fn enum_variants(&self, enum_def: &hir::EnumDef<'_>) -> Vec<AdtVariant<'tcx>> {\n-        enum_def.variants.iter().map(|variant| self.non_enum_variant(&variant.data)).collect()\n+        enum_def\n+            .variants\n+            .iter()\n+            .map(|variant| AdtVariant {\n+                fields: self.non_enum_variant(&variant.data).fields,\n+                explicit_discr: variant\n+                    .disr_expr\n+                    .map(|explicit_discr| self.tcx.hir().local_def_id(explicit_discr.hir_id)),\n+            })\n+            .collect()\n     }\n \n     fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {"}]}