{"sha": "c5046fdce502c743524a307b85011a21be6a2221", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MDQ2ZmRjZTUwMmM3NDM1MjRhMzA3Yjg1MDExYTIxYmU2YTIyMjE=", "commit": {"author": {"name": "Micha Ober", "email": "git@ober-mail.de", "date": "2019-10-05T12:23:52Z"}, "committer": {"name": "Micha Ober", "email": "git@ober-mail.de", "date": "2019-12-28T22:24:45Z"}, "message": "Add real suggestion to option_map_unwrap_or", "tree": {"sha": "9ee301f417de860a389f5bbd1889a3453b46408c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ee301f417de860a389f5bbd1889a3453b46408c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5046fdce502c743524a307b85011a21be6a2221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5046fdce502c743524a307b85011a21be6a2221", "html_url": "https://github.com/rust-lang/rust/commit/c5046fdce502c743524a307b85011a21be6a2221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5046fdce502c743524a307b85011a21be6a2221/comments", "author": {"login": "m-ober", "id": 11992838, "node_id": "MDQ6VXNlcjExOTkyODM4", "avatar_url": "https://avatars.githubusercontent.com/u/11992838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ober", "html_url": "https://github.com/m-ober", "followers_url": "https://api.github.com/users/m-ober/followers", "following_url": "https://api.github.com/users/m-ober/following{/other_user}", "gists_url": "https://api.github.com/users/m-ober/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ober/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ober/subscriptions", "organizations_url": "https://api.github.com/users/m-ober/orgs", "repos_url": "https://api.github.com/users/m-ober/repos", "events_url": "https://api.github.com/users/m-ober/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ober/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ober", "id": 11992838, "node_id": "MDQ6VXNlcjExOTkyODM4", "avatar_url": "https://avatars.githubusercontent.com/u/11992838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ober", "html_url": "https://github.com/m-ober", "followers_url": "https://api.github.com/users/m-ober/followers", "following_url": "https://api.github.com/users/m-ober/following{/other_user}", "gists_url": "https://api.github.com/users/m-ober/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ober/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ober/subscriptions", "organizations_url": "https://api.github.com/users/m-ober/orgs", "repos_url": "https://api.github.com/users/m-ober/repos", "events_url": "https://api.github.com/users/m-ober/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ober/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fec5905d87fdee8d3d6a065cdd450972fb588b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fec5905d87fdee8d3d6a065cdd450972fb588b8", "html_url": "https://github.com/rust-lang/rust/commit/0fec5905d87fdee8d3d6a065cdd450972fb588b8"}], "stats": {"total": 485, "additions": 271, "deletions": 214}, "files": [{"sha": "351e86ae82bd4aa62211d749ea9dffe363afc03f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5046fdce502c743524a307b85011a21be6a2221/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5046fdce502c743524a307b85011a21be6a2221/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=c5046fdce502c743524a307b85011a21be6a2221", "patch": "@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             [\"unwrap\", ..] => lint_unwrap(cx, expr, arg_lists[0]),\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n-            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => lint_option_and_then_some(cx, expr, arg_lists[0]),"}, {"sha": "6d2eadd97c54ec74c51067c6772374987a60802d", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c5046fdce502c743524a307b85011a21be6a2221/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5046fdce502c743524a307b85011a21be6a2221/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=c5046fdce502c743524a307b85011a21be6a2221", "patch": "@@ -1,9 +1,11 @@\n-use crate::utils::paths;\n-use crate::utils::{is_copy, match_type, snippet, span_lint, span_note_and_lint};\n+use crate::utils::{differing_macro_contexts, paths, snippet_with_applicability, span_lint_and_then};\n+use crate::utils::{is_copy, match_type};\n use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n use rustc::hir::{self, *};\n use rustc::lint::LateContext;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use syntax::source_map::Span;\n use syntax_pos::symbol::Symbol;\n \n use super::OPTION_MAP_UNWRAP_OR;\n@@ -14,6 +16,7 @@ pub(super) fn lint<'a, 'tcx>(\n     expr: &hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n+    map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n@@ -39,14 +42,19 @@ pub(super) fn lint<'a, 'tcx>(\n             }\n         }\n \n-        // get snippets for args to map() and unwrap_or()\n-        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        if differing_macro_contexts(unwrap_args[1].span, map_span) {\n+            return;\n+        }\n+\n+        let mut applicability = Applicability::MachineApplicable;\n+        // get snippet for unwrap_or()\n+        let unwrap_snippet = snippet_with_applicability(cx, unwrap_args[1].span, \"..\", &mut applicability);\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n         let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n-        let suggest = if unwrap_snippet == \"None\" {\n+        let unwrap_snippet_none = unwrap_snippet == \"None\";\n+        let suggest = if unwrap_snippet_none {\n             \"and_then(f)\"\n         } else {\n             \"map_or(a, f)\"\n@@ -56,24 +64,24 @@ pub(super) fn lint<'a, 'tcx>(\n              This can be done more directly by calling `{}` instead\",\n             arg, suggest\n         );\n-        // lint, with note if neither arg is > 1 line and both map() and\n-        // unwrap_or() have the same span\n-        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n-        if same_span && !multiline {\n-            let suggest = if unwrap_snippet == \"None\" {\n-                format!(\"and_then({})\", map_snippet)\n-            } else {\n-                format!(\"map_or({}, {})\", unwrap_snippet, map_snippet)\n-            };\n-            let note = format!(\n-                \"replace `map({}).unwrap_or({})` with `{}`\",\n-                map_snippet, unwrap_snippet, suggest\n-            );\n-            span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n-        } else if same_span && multiline {\n-            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n-        };\n+\n+        span_lint_and_then(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, |db| {\n+            let map_arg_span = map_args[1].span;\n+\n+            let mut suggestion = vec![\n+                (\n+                    map_span,\n+                    String::from(if unwrap_snippet_none { \"and_then\" } else { \"map_or\" }),\n+                ),\n+                (expr.span.with_lo(unwrap_args[0].span.hi()), String::from(\"\")),\n+            ];\n+\n+            if !unwrap_snippet_none {\n+                suggestion.push((map_arg_span.with_hi(map_arg_span.lo()), format!(\"{}, \", unwrap_snippet)));\n+            }\n+\n+            db.multipart_suggestion(&format!(\"use `{}` instead\", suggest), suggestion, applicability);\n+        });\n     }\n }\n "}, {"sha": "bc448435829714cb62e836b90e3dbd18931c9464", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=c5046fdce502c743524a307b85011a21be6a2221", "patch": "@@ -164,81 +164,6 @@ impl Mul<T> for T {\n     }\n }\n \n-/// Checks implementation of the following lints:\n-/// * `OPTION_MAP_UNWRAP_OR`\n-/// * `OPTION_MAP_UNWRAP_OR_ELSE`\n-#[rustfmt::skip]\n-fn option_methods() {\n-    let opt = Some(1);\n-\n-    // Check `OPTION_MAP_UNWRAP_OR`.\n-    // Single line case.\n-    let _ = opt.map(|x| x + 1)\n-                // Should lint even though this call is on a separate line.\n-               .unwrap_or(0);\n-    // Multi-line cases.\n-    let _ = opt.map(|x| {\n-                        x + 1\n-                    }\n-              ).unwrap_or(0);\n-    let _ = opt.map(|x| x + 1)\n-               .unwrap_or({\n-                    0\n-                });\n-    // Single line `map(f).unwrap_or(None)` case.\n-    let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n-    // Multi-line `map(f).unwrap_or(None)` cases.\n-    let _ = opt.map(|x| {\n-        Some(x + 1)\n-    }\n-    ).unwrap_or(None);\n-    let _ = opt\n-        .map(|x| Some(x + 1))\n-        .unwrap_or(None);\n-    // macro case\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or(0); // should not lint\n-\n-    // Should not lint if not copyable\n-    let id: String = \"identifier\".to_string();\n-    let _ = Some(\"prefix\").map(|p| format!(\"{}.{}\", p, id)).unwrap_or(id);\n-    // ...but DO lint if the `unwrap_or` argument is not used in the `map`\n-    let id: String = \"identifier\".to_string();\n-    let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n-\n-    // Check OPTION_MAP_UNWRAP_OR_ELSE\n-    // single line case\n-    let _ = opt.map(|x| x + 1)\n-                // Should lint even though this call is on a separate line.\n-               .unwrap_or_else(|| 0);\n-    // Multi-line cases.\n-    let _ = opt.map(|x| {\n-                        x + 1\n-                    }\n-              ).unwrap_or_else(|| 0);\n-    let _ = opt.map(|x| x + 1)\n-               .unwrap_or_else(||\n-                    0\n-                );\n-    // Macro case.\n-    // Should not lint.\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n-\n-    // Issue #4144\n-    {\n-        let mut frequencies = HashMap::new();\n-        let word = \"foo\";\n-\n-        frequencies\n-            .get_mut(word)\n-            .map(|count| {\n-                *count += 1;\n-            })\n-            .unwrap_or_else(|| {\n-                frequencies.insert(word.to_owned(), 1);\n-            });\n-    }\n-}\n-\n /// Checks implementation of `FILTER_NEXT` lint.\n #[rustfmt::skip]\n fn filter_next() {\n@@ -302,7 +227,6 @@ fn search_is_some() {\n }\n \n fn main() {\n-    option_methods();\n     filter_next();\n     search_is_some();\n }"}, {"sha": "878e78fdcc5e19f27d1d76e2edc4be4149ede741", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 12, "deletions": 113, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=c5046fdce502c743524a307b85011a21be6a2221", "patch": "@@ -18,109 +18,8 @@ LL | |     }\n    |\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n-error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:176:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |                 // Should lint even though this call is on a separate line.\n-LL | |                .unwrap_or(0);\n-   | |____________________________^\n-   |\n-   = note: `-D clippy::option-map-unwrap-or` implied by `-D warnings`\n-   = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:180:13\n-   |\n-LL |       let _ = opt.map(|x| {\n-   |  _____________^\n-LL | |                         x + 1\n-LL | |                     }\n-LL | |               ).unwrap_or(0);\n-   | |____________________________^\n-\n-error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:184:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |                .unwrap_or({\n-LL | |                     0\n-LL | |                 });\n-   | |__________________^\n-\n-error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:189:13\n-   |\n-LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n-\n-error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:191:13\n-   |\n-LL |       let _ = opt.map(|x| {\n-   |  _____________^\n-LL | |         Some(x + 1)\n-LL | |     }\n-LL | |     ).unwrap_or(None);\n-   | |_____________________^\n-\n-error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:195:13\n-   |\n-LL |       let _ = opt\n-   |  _____________^\n-LL | |         .map(|x| Some(x + 1))\n-LL | |         .unwrap_or(None);\n-   | |________________________^\n-   |\n-   = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n-\n-error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:206:13\n-   |\n-LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n-\n-error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:210:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |                 // Should lint even though this call is on a separate line.\n-LL | |                .unwrap_or_else(|| 0);\n-   | |____________________________________^\n-   |\n-   = note: `-D clippy::option-map-unwrap-or-else` implied by `-D warnings`\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:214:13\n-   |\n-LL |       let _ = opt.map(|x| {\n-   |  _____________^\n-LL | |                         x + 1\n-LL | |                     }\n-LL | |               ).unwrap_or_else(|| 0);\n-   | |____________________________________^\n-\n-error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:218:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |                .unwrap_or_else(||\n-LL | |                     0\n-LL | |                 );\n-   | |_________________^\n-\n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:248:13\n+  --> $DIR/methods.rs:173:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -129,7 +28,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:251:13\n+  --> $DIR/methods.rs:176:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -139,33 +38,33 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:268:22\n+  --> $DIR/methods.rs:193:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:269:20\n+  --> $DIR/methods.rs:194:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:270:20\n+  --> $DIR/methods.rs:195:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:271:22\n+  --> $DIR/methods.rs:196:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:274:13\n+  --> $DIR/methods.rs:199:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -175,13 +74,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:280:22\n+  --> $DIR/methods.rs:205:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:283:13\n+  --> $DIR/methods.rs:208:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -191,13 +90,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:289:22\n+  --> $DIR/methods.rs:214:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:292:13\n+  --> $DIR/methods.rs:217:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -206,5 +105,5 @@ LL | |                                }\n LL | |                    ).is_some();\n    | |______________________________^\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "0364d83663a06c18ac84049a46b6fe09204bc2c6", "filename": "tests/ui/option_map_unwrap_or.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_unwrap_or.rs?ref=c5046fdce502c743524a307b85011a21be6a2221", "patch": "@@ -0,0 +1,88 @@\n+// FIXME: Add \"run-rustfix\" once it's supported for multipart suggestions\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::option_map_unwrap_or, clippy::option_map_unwrap_or_else)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::HashMap;\n+\n+/// Checks implementation of the following lints:\n+/// * `OPTION_MAP_UNWRAP_OR`\n+/// * `OPTION_MAP_UNWRAP_OR_ELSE`\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check `OPTION_MAP_UNWRAP_OR`.\n+    // Single line case.\n+    let _ = opt.map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or(0);\n+    // Multi-line cases.\n+    let _ = opt.map(|x| {\n+        x + 1\n+    }\n+    ).unwrap_or(0);\n+    let _ = opt.map(|x| x + 1)\n+        .unwrap_or({\n+            0\n+        });\n+    // Single line `map(f).unwrap_or(None)` case.\n+    let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n+    // Multi-line `map(f).unwrap_or(None)` cases.\n+    let _ = opt.map(|x| {\n+        Some(x + 1)\n+    }\n+    ).unwrap_or(None);\n+    let _ = opt\n+        .map(|x| Some(x + 1))\n+        .unwrap_or(None);\n+    // macro case\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or(0); // should not lint\n+\n+    // Should not lint if not copyable\n+    let id: String = \"identifier\".to_string();\n+    let _ = Some(\"prefix\").map(|p| format!(\"{}.{}\", p, id)).unwrap_or(id);\n+    // ...but DO lint if the `unwrap_or` argument is not used in the `map`\n+    let id: String = \"identifier\".to_string();\n+    let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n+\n+    // Check OPTION_MAP_UNWRAP_OR_ELSE\n+    // single line case\n+    let _ = opt.map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or_else(|| 0);\n+    // Multi-line cases.\n+    let _ = opt.map(|x| {\n+        x + 1\n+    }\n+    ).unwrap_or_else(|| 0);\n+    let _ = opt.map(|x| x + 1)\n+        .unwrap_or_else(||\n+            0\n+        );\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+fn main() {\n+    option_methods();\n+}"}, {"sha": "c336c0f63d2e5edfb9eab10d96322a281d6406a8", "filename": "tests/ui/option_map_unwrap_or.stderr", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Foption_map_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5046fdce502c743524a307b85011a21be6a2221/tests%2Fui%2Foption_map_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_unwrap_or.stderr?ref=c5046fdce502c743524a307b85011a21be6a2221", "patch": "@@ -0,0 +1,138 @@\n+error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:20:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // Should lint even though this call is on a separate line.\n+LL | |         .unwrap_or(0);\n+   | |_____________________^\n+   |\n+   = note: `-D clippy::option-map-unwrap-or` implied by `-D warnings`\n+help: use `map_or(a, f)` instead\n+   |\n+LL |     let _ = opt.map_or(0, |x| x + 1);\n+   |                 ^^^^^^ ^^          --\n+\n+error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:24:13\n+   |\n+LL |       let _ = opt.map(|x| {\n+   |  _____________^\n+LL | |         x + 1\n+LL | |     }\n+LL | |     ).unwrap_or(0);\n+   | |__________________^\n+   |\n+help: use `map_or(a, f)` instead\n+   |\n+LL |     let _ = opt.map_or(0, |x| {\n+LL |         x + 1\n+LL |     }\n+LL |     );\n+   |\n+\n+error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:28:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         .unwrap_or({\n+LL | |             0\n+LL | |         });\n+   | |__________^\n+   |\n+help: use `map_or(a, f)` instead\n+   |\n+LL |     let _ = opt.map_or({\n+LL |             0\n+LL |         }, |x| x + 1);\n+   |\n+\n+error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:33:13\n+   |\n+LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `and_then(f)` instead\n+   |\n+LL |     let _ = opt.and_then(|x| Some(x + 1));\n+   |                 ^^^^^^^^                --\n+\n+error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:35:13\n+   |\n+LL |       let _ = opt.map(|x| {\n+   |  _____________^\n+LL | |         Some(x + 1)\n+LL | |     }\n+LL | |     ).unwrap_or(None);\n+   | |_____________________^\n+   |\n+help: use `and_then(f)` instead\n+   |\n+LL |     let _ = opt.and_then(|x| {\n+LL |         Some(x + 1)\n+LL |     }\n+LL |     );\n+   |\n+\n+error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:39:13\n+   |\n+LL |       let _ = opt\n+   |  _____________^\n+LL | |         .map(|x| Some(x + 1))\n+LL | |         .unwrap_or(None);\n+   | |________________________^\n+   |\n+help: use `and_then(f)` instead\n+   |\n+LL |         .and_then(|x| Some(x + 1));\n+   |          ^^^^^^^^                --\n+\n+error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:50:13\n+   |\n+LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `map_or(a, f)` instead\n+   |\n+LL |     let _ = Some(\"prefix\").map_or(id, |p| format!(\"{}.\", p));\n+   |                            ^^^^^^ ^^^                      --\n+\n+error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:54:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // Should lint even though this call is on a separate line.\n+LL | |         .unwrap_or_else(|| 0);\n+   | |_____________________________^\n+   |\n+   = note: `-D clippy::option-map-unwrap-or-else` implied by `-D warnings`\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n+\n+error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:58:13\n+   |\n+LL |       let _ = opt.map(|x| {\n+   |  _____________^\n+LL | |         x + 1\n+LL | |     }\n+LL | |     ).unwrap_or_else(|| 0);\n+   | |__________________________^\n+\n+error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n+  --> $DIR/option_map_unwrap_or.rs:62:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         .unwrap_or_else(||\n+LL | |             0\n+LL | |         );\n+   | |_________^\n+\n+error: aborting due to 10 previous errors\n+"}]}