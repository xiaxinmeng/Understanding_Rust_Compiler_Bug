{"sha": "81d5c3e78374df15c40f463cef27918a80f3b234", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZDVjM2U3ODM3NGRmMTVjNDBmNDYzY2VmMjc5MThhODBmM2IyMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T02:01:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T02:01:49Z"}, "message": "Auto merge of #51428 - alexreg:uninitialized-statics-simplification, r=oli-obk\n\nRemoved `uninitialized_statics` field from `Memory` struct in miri\n\nbased on #51110\n\nr? @oli-obk\n\nCC @eddyb", "tree": {"sha": "6a4e3507d2a6c011e8da3db64c41dc8aeb7d4e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a4e3507d2a6c011e8da3db64c41dc8aeb7d4e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81d5c3e78374df15c40f463cef27918a80f3b234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81d5c3e78374df15c40f463cef27918a80f3b234", "html_url": "https://github.com/rust-lang/rust/commit/81d5c3e78374df15c40f463cef27918a80f3b234", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81d5c3e78374df15c40f463cef27918a80f3b234/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9078d3cdbcbf4aa9390029d49411af72db064858", "url": "https://api.github.com/repos/rust-lang/rust/commits/9078d3cdbcbf4aa9390029d49411af72db064858", "html_url": "https://github.com/rust-lang/rust/commit/9078d3cdbcbf4aa9390029d49411af72db064858"}, {"sha": "6660c25045ec198d80ada12e621634e22d1da619", "url": "https://api.github.com/repos/rust-lang/rust/commits/6660c25045ec198d80ada12e621634e22d1da619", "html_url": "https://github.com/rust-lang/rust/commit/6660c25045ec198d80ada12e621634e22d1da619"}], "stats": {"total": 159, "additions": 65, "deletions": 94}, "files": [{"sha": "ea09bab5d1411f3a444a606522c928dc58062628", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=81d5c3e78374df15c40f463cef27918a80f3b234", "patch": "@@ -1,3 +1,6 @@\n+use std::fmt;\n+use std::error::Error;\n+\n use rustc::hir;\n use rustc::mir::interpret::{ConstEvalErr};\n use rustc::mir;\n@@ -15,9 +18,6 @@ use rustc::mir::interpret::{\n };\n use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory, MemoryKind};\n \n-use std::fmt;\n-use std::error::Error;\n-\n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n@@ -152,7 +152,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     let ptr = ecx.memory.allocate(\n         layout.size,\n         layout.align,\n-        None,\n+        MemoryKind::Stack,\n     )?;\n     let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n     let is_static = tcx.is_static(cid.instance.def_id());\n@@ -486,7 +486,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     let (ptr, align) = match value {\n         Value::ScalarPair(..) | Value::Scalar(_) => {\n             let layout = ecx.layout_of(val.ty)?;\n-            let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?.into();\n+            let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n             ecx.write_value_to_ptr(value, ptr, layout.align, val.ty)?;\n             (ptr, layout.align)\n         },\n@@ -515,7 +515,7 @@ pub fn const_value_to_allocation_provider<'a, 'tcx>(\n             ());\n         let value = ecx.const_to_value(val.val)?;\n         let layout = ecx.layout_of(val.ty)?;\n-        let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?;\n+        let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?;\n         ecx.write_value_to_ptr(value, ptr.into(), layout.align, val.ty)?;\n         let alloc = ecx.memory.get(ptr.alloc_id)?;\n         Ok(tcx.intern_const_alloc(alloc.clone()))"}, {"sha": "031c75013a27b00c684d2e371838c9f868546b47", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=81d5c3e78374df15c40f463cef27918a80f3b234", "patch": "@@ -1,4 +1,5 @@\n use std::fmt::Write;\n+use std::mem;\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n@@ -9,14 +10,13 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc::mir::interpret::FrameInfo;\n-use syntax::codemap::{self, Span};\n-use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n-    GlobalId, Value, Scalar,\n+    FrameInfo, GlobalId, Value, Scalar,\n     EvalResult, EvalErrorKind, Pointer, ConstValue,\n };\n-use std::mem;\n+\n+use syntax::codemap::{self, Span};\n+use syntax::ast::Mutability;\n \n use super::{Place, PlaceExtra, Memory,\n             HasMemory, MemoryKind,\n@@ -206,7 +206,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n-        self.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))\n+        self.memory.allocate(layout.size, layout.align, MemoryKind::Stack)\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n@@ -246,7 +246,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             ConstValue::ByRef(alloc, offset) => {\n                 // FIXME: Allocate new AllocId for all constants inside\n-                let id = self.memory.allocate_value(alloc.clone(), Some(MemoryKind::Stack))?;\n+                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n                 Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n             },\n             ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a, b)),"}, {"sha": "5cf734cce8a3f780f3aab248a3b05b41add99975", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 47, "deletions": 77, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=81d5c3e78374df15c40f463cef27918a80f3b234", "patch": "@@ -6,12 +6,12 @@ use rustc::ty::Instance;\n use rustc::ty::ParamEnv;\n use rustc::ty::query::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n-use syntax::ast::Mutability;\n-\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value,\n                             EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+\n+use syntax::ast::Mutability;\n \n use super::{EvalContext, Machine};\n \n@@ -41,11 +41,6 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     alloc_map: FxHashMap<AllocId, Allocation>,\n \n-    /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    ///\n-    /// Stores statics while they are being processed, before they are interned and thus frozen\n-    uninitialized_statics: FxHashMap<AllocId, Allocation>,\n-\n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n \n@@ -58,7 +53,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             data,\n             alloc_kind: FxHashMap::default(),\n             alloc_map: FxHashMap::default(),\n-            uninitialized_statics: FxHashMap::default(),\n             tcx,\n             cur_frame: usize::max_value(),\n         }\n@@ -82,20 +76,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn allocate_value(\n         &mut self,\n         alloc: Allocation,\n-        kind: Option<MemoryKind<M::MemoryKinds>>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, AllocId> {\n         let id = self.tcx.alloc_map.lock().reserve();\n         M::add_lock(self, id);\n-        match kind {\n-            Some(kind @ MemoryKind::Stack) |\n-            Some(kind @ MemoryKind::Machine(_)) => {\n-                self.alloc_map.insert(id, alloc);\n-                self.alloc_kind.insert(id, kind);\n-            },\n-            None => {\n-                self.uninitialized_statics.insert(id, alloc);\n-            },\n-        }\n+        self.alloc_map.insert(id, alloc);\n+        self.alloc_kind.insert(id, kind);\n         Ok(id)\n     }\n \n@@ -104,7 +90,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &mut self,\n         size: Size,\n         align: Align,\n-        kind: Option<MemoryKind<M::MemoryKinds>>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer> {\n         self.allocate_value(Allocation::undef(size, align), kind).map(Pointer::from)\n     }\n@@ -132,7 +118,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n-        let new_ptr = self.allocate(new_size, new_align, Some(kind))?;\n+        let new_ptr = self.allocate(new_size, new_align, kind)?;\n         self.copy(\n             ptr.into(),\n             old_align,\n@@ -168,12 +154,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n-            None => if self.uninitialized_statics.contains_key(&ptr.alloc_id) {\n-                return err!(DeallocatedWrongMemoryKind(\n-                    \"uninitializedstatic\".to_string(),\n-                    format!(\"{:?}\", kind),\n-                ))\n-            } else {\n+            None => {\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n                     Some(AllocType::Function(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n@@ -299,24 +280,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         // normal alloc?\n         match self.alloc_map.get(&id) {\n-                    Some(alloc) => Ok(alloc),\n+            Some(alloc) => Ok(alloc),\n             // uninitialized static alloc?\n-            None => match self.uninitialized_statics.get(&id) {\n-                Some(alloc) => Ok(alloc),\n-                None => {\n-                    // static alloc?\n-                    let alloc = self.tcx.alloc_map.lock().get(id);\n-                    match alloc {\n-                        Some(AllocType::Memory(mem)) => Ok(mem),\n-                        Some(AllocType::Function(..)) => {\n-                            Err(EvalErrorKind::DerefFunctionPointer.into())\n-                        }\n-                        Some(AllocType::Static(did)) => {\n-                            self.const_eval_static(did)\n-                        }\n-                        None => Err(EvalErrorKind::DanglingPointerDeref.into()),\n+            None => {\n+                // static alloc?\n+                let alloc = self.tcx.alloc_map.lock().get(id);\n+                match alloc {\n+                    Some(AllocType::Memory(mem)) => Ok(mem),\n+                    Some(AllocType::Function(..)) => {\n+                        Err(EvalErrorKind::DerefFunctionPointer.into())\n+                    }\n+                    Some(AllocType::Static(did)) => {\n+                        self.const_eval_static(did)\n                     }\n-                },\n+                    None => Err(EvalErrorKind::DanglingPointerDeref.into()),\n+                }\n             },\n         }\n     }\n@@ -329,17 +307,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         match self.alloc_map.get_mut(&id) {\n             Some(alloc) => Ok(alloc),\n             // uninitialized static alloc?\n-            None => match self.uninitialized_statics.get_mut(&id) {\n-                Some(alloc) => Ok(alloc),\n-                None => {\n-                    // no alloc or immutable alloc? produce an error\n-                    match self.tcx.alloc_map.lock().get(id) {\n-                        Some(AllocType::Memory(..)) |\n-                        Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n-                        Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n-                        None => err!(DanglingPointerDeref),\n-                    }\n-                },\n+            None => {\n+                // no alloc or immutable alloc? produce an error\n+                match self.tcx.alloc_map.lock().get(id) {\n+                    Some(AllocType::Memory(..)) |\n+                    Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n+                    Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n+                    None => err!(DanglingPointerDeref),\n+                }\n             },\n         }\n     }\n@@ -390,27 +365,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n                     }),\n-                    // uninitialized static alloc?\n-                    None => match self.uninitialized_statics.get(&id) {\n-                        Some(a) => (a, \" (static in the process of initialization)\".to_owned()),\n-                        None => {\n-                            // static alloc?\n-                            match self.tcx.alloc_map.lock().get(id) {\n-                                Some(AllocType::Memory(a)) => (a, \"(immutable)\".to_owned()),\n-                                Some(AllocType::Function(func)) => {\n-                                    trace!(\"{} {}\", msg, func);\n-                                    continue;\n-                                }\n-                                Some(AllocType::Static(did)) => {\n-                                    trace!(\"{} {:?}\", msg, did);\n-                                    continue;\n-                                }\n-                                None => {\n-                                    trace!(\"{} (deallocated)\", msg);\n-                                    continue;\n-                                }\n+                    None => {\n+                        // static alloc?\n+                        match self.tcx.alloc_map.lock().get(id) {\n+                            Some(AllocType::Memory(a)) => (a, \"(immutable)\".to_owned()),\n+                            Some(AllocType::Function(func)) => {\n+                                trace!(\"{} {}\", msg, func);\n+                                continue;\n                             }\n-                        },\n+                            Some(AllocType::Static(did)) => {\n+                                trace!(\"{} {:?}\", msg, did);\n+                                continue;\n+                            }\n+                            None => {\n+                                trace!(\"{} (deallocated)\", msg);\n+                                continue;\n+                            }\n+                        }\n                     },\n                 };\n \n@@ -569,8 +540,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Some(MemoryKind::Machine(_)) => bug!(\"machine didn't handle machine alloc\"),\n             Some(MemoryKind::Stack) => {},\n         }\n-        let uninit = self.uninitialized_statics.remove(&alloc_id);\n-        if let Some(mut alloc) = alloc.or(uninit) {\n+        if let Some(mut alloc) = alloc {\n             // ensure llvm knows not to put this into immutable memroy\n             alloc.runtime_mutability = mutability;\n             let alloc = self.tcx.intern_const_alloc(alloc);"}, {"sha": "b6c7feda19fa813377fff50213a3b046deb3b96c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d5c3e78374df15c40f463cef27918a80f3b234/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=81d5c3e78374df15c40f463cef27918a80f3b234", "patch": "@@ -1,9 +1,10 @@\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n+use rustc::mir::interpret::{Scalar, Value, Pointer, EvalResult};\n+\n use syntax::ast::Mutability;\n \n-use rustc::mir::interpret::{Scalar, Value, Pointer, EvalResult};\n-use super::{EvalContext, Machine};\n+use super::{EvalContext, Machine, MemoryKind};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -30,7 +31,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let vtable = self.memory.allocate(\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n-            None,\n+            MemoryKind::Stack,\n         )?;\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);"}, {"sha": "5b7bb32b0e46d195b80c4da09b560ac7fc92015d", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=81d5c3e78374df15c40f463cef27918a80f3b234", "patch": "@@ -1 +1 @@\n-Subproject commit 9143a69f4b3ef4bda77afddefe934be363e39f31\n+Subproject commit 5b7bb32b0e46d195b80c4da09b560ac7fc92015d"}]}