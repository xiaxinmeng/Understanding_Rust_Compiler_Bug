{"sha": "d460aca7204b8252f20b970937838bf70b466efe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NjBhY2E3MjA0YjgyNTJmMjBiOTcwOTM3ODM4YmY3MGI0NjZlZmU=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-08T02:08:14Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-09T23:07:26Z"}, "message": "Move bit ops to module.", "tree": {"sha": "f906f523b87a633b2c230f1af96ee257bfb6003b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f906f523b87a633b2c230f1af96ee257bfb6003b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d460aca7204b8252f20b970937838bf70b466efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d460aca7204b8252f20b970937838bf70b466efe", "html_url": "https://github.com/rust-lang/rust/commit/d460aca7204b8252f20b970937838bf70b466efe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d460aca7204b8252f20b970937838bf70b466efe/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75677e0646a3e110c22b56145b5c586c1f87a741", "url": "https://api.github.com/repos/rust-lang/rust/commits/75677e0646a3e110c22b56145b5c586c1f87a741", "html_url": "https://github.com/rust-lang/rust/commit/75677e0646a3e110c22b56145b5c586c1f87a741"}], "stats": {"total": 1676, "additions": 846, "deletions": 830}, "files": [{"sha": "8743be3557cc4e31f793f4a6d570785de637761a", "filename": "src/libcore/ops/bit.rs", "status": "added", "additions": 839, "deletions": 0, "changes": 839, "blob_url": "https://github.com/rust-lang/rust/blob/d460aca7204b8252f20b970937838bf70b466efe/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d460aca7204b8252f20b970937838bf70b466efe/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=d460aca7204b8252f20b970937838bf70b466efe", "patch": "@@ -0,0 +1,839 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The unary logical negation operator `!`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Not` for `Answer`, which enables the use of `!` to\n+/// invert its value.\n+///\n+/// ```\n+/// use std::ops::Not;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Answer {\n+///     Yes,\n+///     No,\n+/// }\n+///\n+/// impl Not for Answer {\n+///     type Output = Answer;\n+///\n+///     fn not(self) -> Answer {\n+///         match self {\n+///             Answer::Yes => Answer::No,\n+///             Answer::No => Answer::Yes\n+///         }\n+///     }\n+/// }\n+///\n+/// assert_eq!(!Answer::Yes, Answer::No);\n+/// assert_eq!(!Answer::No, Answer::Yes);\n+/// ```\n+#[lang = \"not\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Not {\n+    /// The resulting type after applying the `!` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the unary `!` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn not(self) -> Self::Output;\n+}\n+\n+macro_rules! not_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Not for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn not(self) -> $t { !self }\n+        }\n+\n+        forward_ref_unop! { impl Not, not for $t }\n+    )*)\n+}\n+\n+not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise AND operator `&`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitAnd;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitAnd for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a & b`\n+///     fn bitand(self, rhs: Self) -> Self {\n+///         Scalar(self.0 & rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n+///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitAnd;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitAnd for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitand(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, false, false, false]);\n+///     assert_eq!(bv1 & bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitand\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} & {RHS}`\"]\n+pub trait BitAnd<RHS=Self> {\n+    /// The resulting type after applying the `&` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `&` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitand(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitand_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitAnd for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitand(self, rhs: $t) -> $t { self & rhs }\n+        }\n+\n+        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n+    )*)\n+}\n+\n+bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise OR operator `|`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `|` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitOr;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitOr for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a | b`\n+///     fn bitor(self, rhs: Self) -> Self {\n+///         Scalar(self.0 | rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n+///     assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitOr` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitOr;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitOr for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitor(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, true, true, false]);\n+///     assert_eq!(bv1 | bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitor\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} | {RHS}`\"]\n+pub trait BitOr<RHS=Self> {\n+    /// The resulting type after applying the `|` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `|` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitor_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitOr for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitor(self, rhs: $t) -> $t { self | rhs }\n+        }\n+\n+        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n+    )*)\n+}\n+\n+bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise XOR operator `^`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `^` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitXor;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitXor for Scalar {\n+///     type Output = Self;\n+///\n+///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n+///     fn bitxor(self, rhs: Self) -> Self {\n+///         Scalar(self.0 ^ rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n+///     assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n+///     assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n+///     assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitXor` trait is implemented for a `BooleanVector`\n+/// struct.\n+///\n+/// ```\n+/// use std::ops::BitXor;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitXor for BooleanVector {\n+///     type Output = Self;\n+///\n+///     fn bitxor(self, BooleanVector(rhs): Self) -> Self {\n+///         let BooleanVector(lhs) = self;\n+///         assert_eq!(lhs.len(), rhs.len());\n+///         BooleanVector(lhs.iter()\n+///                          .zip(rhs.iter())\n+///                          .map(|(x, y)| (*x || *y) && !(*x && *y))\n+///                          .collect())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let bv1 = BooleanVector(vec![true, true, false, false]);\n+///     let bv2 = BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![false, true, true, false]);\n+///     assert_eq!(bv1 ^ bv2, expected);\n+/// }\n+/// ```\n+#[lang = \"bitxor\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} ^ {RHS}`\"]\n+pub trait BitXor<RHS=Self> {\n+    /// The resulting type after applying the `^` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `^` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn bitxor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! bitxor_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitXor for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn bitxor(self, other: $t) -> $t { self ^ other }\n+        }\n+\n+        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n+    )*)\n+}\n+\n+bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The left shift operator `<<`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Shl` that lifts the `<<` operation on integers to a\n+/// `Scalar` struct.\n+///\n+/// ```\n+/// use std::ops::Shl;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n+///\n+/// impl Shl<Scalar> for Scalar {\n+///     type Output = Self;\n+///\n+///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs << rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shl` that spins a vector leftward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shl;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shl<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shl(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n+///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n+/// }\n+/// ```\n+#[lang = \"shl\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} << {RHS}`\"]\n+pub trait Shl<RHS> {\n+    /// The resulting type after applying the `<<` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `<<` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn shl(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! shl_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shl<$f> for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shl(self, other: $f) -> $t {\n+                self << other\n+            }\n+        }\n+\n+        forward_ref_binop! { impl Shl, shl for $t, $f }\n+    )\n+}\n+\n+macro_rules! shl_impl_all {\n+    ($($t:ty)*) => ($(\n+        shl_impl! { $t, u8 }\n+        shl_impl! { $t, u16 }\n+        shl_impl! { $t, u32 }\n+        shl_impl! { $t, u64 }\n+        shl_impl! { $t, u128 }\n+        shl_impl! { $t, usize }\n+\n+        shl_impl! { $t, i8 }\n+        shl_impl! { $t, i16 }\n+        shl_impl! { $t, i32 }\n+        shl_impl! { $t, i64 }\n+        shl_impl! { $t, i128 }\n+        shl_impl! { $t, isize }\n+    )*)\n+}\n+\n+shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n+\n+/// The right shift operator `>>`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Shr` that lifts the `>>` operation on integers to a\n+/// `Scalar` struct.\n+///\n+/// ```\n+/// use std::ops::Shr;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct Scalar(usize);\n+///\n+/// impl Shr<Scalar> for Scalar {\n+///     type Output = Self;\n+///\n+///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n+///         let Scalar(lhs) = self;\n+///         Scalar(lhs >> rhs)\n+///     }\n+/// }\n+/// fn main() {\n+///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n+/// }\n+/// ```\n+///\n+/// An implementation of `Shr` that spins a vector rightward by a given amount.\n+///\n+/// ```\n+/// use std::ops::Shr;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SpinVector<T: Clone> {\n+///     vec: Vec<T>,\n+/// }\n+///\n+/// impl<T: Clone> Shr<usize> for SpinVector<T> {\n+///     type Output = Self;\n+///\n+///     fn shr(self, rhs: usize) -> SpinVector<T> {\n+///         // rotate the vector by `rhs` places\n+///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n+///         let mut spun_vector: Vec<T> = vec![];\n+///         spun_vector.extend_from_slice(b);\n+///         spun_vector.extend_from_slice(a);\n+///         SpinVector { vec: spun_vector }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n+///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n+/// }\n+/// ```\n+#[lang = \"shr\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} >> {RHS}`\"]\n+pub trait Shr<RHS> {\n+    /// The resulting type after applying the `>>` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `>>` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn shr(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! shr_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shr<$f> for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shr(self, other: $f) -> $t {\n+                self >> other\n+            }\n+        }\n+\n+        forward_ref_binop! { impl Shr, shr for $t, $f }\n+    )\n+}\n+\n+macro_rules! shr_impl_all {\n+    ($($t:ty)*) => ($(\n+        shr_impl! { $t, u8 }\n+        shr_impl! { $t, u16 }\n+        shr_impl! { $t, u32 }\n+        shr_impl! { $t, u64 }\n+        shr_impl! { $t, u128 }\n+        shr_impl! { $t, usize }\n+\n+        shr_impl! { $t, i8 }\n+        shr_impl! { $t, i16 }\n+        shr_impl! { $t, i32 }\n+        shr_impl! { $t, i64 }\n+        shr_impl! { $t, i128 }\n+        shr_impl! { $t, isize }\n+    )*)\n+}\n+\n+shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+/// The bitwise AND assignment operator `&=`.\n+///\n+/// # Examples\n+///\n+/// In this example, the `&=` operator is lifted to a trivial `Scalar` type.\n+///\n+/// ```\n+/// use std::ops::BitAndAssign;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(bool);\n+///\n+/// impl BitAndAssign for Scalar {\n+///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     fn bitand_assign(&mut self, rhs: Self) {\n+///         *self = Scalar(self.0 & rhs.0)\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut scalar = Scalar(true);\n+///     scalar &= Scalar(true);\n+///     assert_eq!(scalar, Scalar(true));\n+///\n+///     let mut scalar = Scalar(true);\n+///     scalar &= Scalar(false);\n+///     assert_eq!(scalar, Scalar(false));\n+///\n+///     let mut scalar = Scalar(false);\n+///     scalar &= Scalar(true);\n+///     assert_eq!(scalar, Scalar(false));\n+///\n+///     let mut scalar = Scalar(false);\n+///     scalar &= Scalar(false);\n+///     assert_eq!(scalar, Scalar(false));\n+/// }\n+/// ```\n+///\n+/// In this example, the `BitAndAssign` trait is implemented for a\n+/// `BooleanVector` struct.\n+///\n+/// ```\n+/// use std::ops::BitAndAssign;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct BooleanVector(Vec<bool>);\n+///\n+/// impl BitAndAssign for BooleanVector {\n+///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     fn bitand_assign(&mut self, rhs: Self) {\n+///         assert_eq!(self.0.len(), rhs.0.len());\n+///         *self = BooleanVector(self.0\n+///                                   .iter()\n+///                                   .zip(rhs.0.iter())\n+///                                   .map(|(x, y)| *x && *y)\n+///                                   .collect());\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut bv = BooleanVector(vec![true, true, false, false]);\n+///     bv &= BooleanVector(vec![true, false, true, false]);\n+///     let expected = BooleanVector(vec![true, false, false, false]);\n+///     assert_eq!(bv, expected);\n+/// }\n+/// ```\n+#[lang = \"bitand_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} &= {Rhs}`\"]\n+pub trait BitAndAssign<Rhs=Self> {\n+    /// The method for the `&=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitand_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitand_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitAndAssign for $t {\n+            #[inline]\n+            fn bitand_assign(&mut self, other: $t) { *self &= other }\n+        }\n+    )+)\n+}\n+\n+bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise OR assignment operator `|=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n+/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n+///\n+/// ```\n+/// use std::ops::BitOrAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl BitOrAssign for Foo {\n+///     fn bitor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Or-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo |= Foo;\n+/// }\n+/// ```\n+#[lang = \"bitor_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} |= {Rhs}`\"]\n+pub trait BitOrAssign<Rhs=Self> {\n+    /// The method for the `|=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitor_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitOrAssign for $t {\n+            #[inline]\n+            fn bitor_assign(&mut self, other: $t) { *self |= other }\n+        }\n+    )+)\n+}\n+\n+bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The bitwise XOR assignment operator `^=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n+/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+///\n+/// ```\n+/// use std::ops::BitXorAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl BitXorAssign for Foo {\n+///     fn bitxor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Xor-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo ^= Foo;\n+/// }\n+/// ```\n+#[lang = \"bitxor_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} ^= {Rhs}`\"]\n+pub trait BitXorAssign<Rhs=Self> {\n+    /// The method for the `^=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn bitxor_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! bitxor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitXorAssign for $t {\n+            #[inline]\n+            fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n+        }\n+    )+)\n+}\n+\n+bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+/// The left shift assignment operator `<<=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n+/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n+///\n+/// ```\n+/// use std::ops::ShlAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl ShlAssign<Foo> for Foo {\n+///     fn shl_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting left!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo <<= Foo;\n+/// }\n+/// ```\n+#[lang = \"shl_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} <<= {Rhs}`\"]\n+pub trait ShlAssign<Rhs> {\n+    /// The method for the `<<=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn shl_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! shl_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl ShlAssign<$f> for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self <<= other\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! shl_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shl_assign_impl! { $t, u8 }\n+        shl_assign_impl! { $t, u16 }\n+        shl_assign_impl! { $t, u32 }\n+        shl_assign_impl! { $t, u64 }\n+        shl_assign_impl! { $t, u128 }\n+        shl_assign_impl! { $t, usize }\n+\n+        shl_assign_impl! { $t, i8 }\n+        shl_assign_impl! { $t, i16 }\n+        shl_assign_impl! { $t, i32 }\n+        shl_assign_impl! { $t, i64 }\n+        shl_assign_impl! { $t, i128 }\n+        shl_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+/// The right shift assignment operator `>>=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n+/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n+///\n+/// ```\n+/// use std::ops::ShrAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl ShrAssign<Foo> for Foo {\n+///     fn shr_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting right!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo >>= Foo;\n+/// }\n+/// ```\n+#[lang = \"shr_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} >>= {Rhs}`\"]\n+pub trait ShrAssign<Rhs=Self> {\n+    /// The method for the `>>=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn shr_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! shr_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl ShrAssign<$f> for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self >>= other\n+            }\n+        }\n+    )\n+}\n+\n+macro_rules! shr_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shr_assign_impl! { $t, u8 }\n+        shr_assign_impl! { $t, u16 }\n+        shr_assign_impl! { $t, u32 }\n+        shr_assign_impl! { $t, u64 }\n+        shr_assign_impl! { $t, u128 }\n+        shr_assign_impl! { $t, usize }\n+\n+        shr_assign_impl! { $t, i8 }\n+        shr_assign_impl! { $t, i16 }\n+        shr_assign_impl! { $t, i32 }\n+        shr_assign_impl! { $t, i64 }\n+        shr_assign_impl! { $t, i128 }\n+        shr_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+shr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }"}, {"sha": "fdc1b5fc23596afbb00ec1f320b95859878ecbcc", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 7, "deletions": 830, "changes": 837, "blob_url": "https://github.com/rust-lang/rust/blob/d460aca7204b8252f20b970937838bf70b466efe/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d460aca7204b8252f20b970937838bf70b466efe/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=d460aca7204b8252f20b970937838bf70b466efe", "patch": "@@ -148,6 +148,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n mod arith;\n+mod bit;\n mod function;\n mod range;\n \n@@ -157,6 +158,12 @@ pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::bit::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::function::{Fn, FnMut, FnOnce};\n \n@@ -258,836 +265,6 @@ pub trait Drop {\n     fn drop(&mut self);\n }\n \n-/// The unary logical negation operator `!`.\n-///\n-/// # Examples\n-///\n-/// An implementation of `Not` for `Answer`, which enables the use of `!` to\n-/// invert its value.\n-///\n-/// ```\n-/// use std::ops::Not;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// enum Answer {\n-///     Yes,\n-///     No,\n-/// }\n-///\n-/// impl Not for Answer {\n-///     type Output = Answer;\n-///\n-///     fn not(self) -> Answer {\n-///         match self {\n-///             Answer::Yes => Answer::No,\n-///             Answer::No => Answer::Yes\n-///         }\n-///     }\n-/// }\n-///\n-/// assert_eq!(!Answer::Yes, Answer::No);\n-/// assert_eq!(!Answer::No, Answer::Yes);\n-/// ```\n-#[lang = \"not\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Not {\n-    /// The resulting type after applying the `!` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the unary `!` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn not(self) -> Self::Output;\n-}\n-\n-macro_rules! not_impl {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Not for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn not(self) -> $t { !self }\n-        }\n-\n-        forward_ref_unop! { impl Not, not for $t }\n-    )*)\n-}\n-\n-not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-/// The bitwise AND operator `&`.\n-///\n-/// # Examples\n-///\n-/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n-///\n-/// ```\n-/// use std::ops::BitAnd;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct Scalar(bool);\n-///\n-/// impl BitAnd for Scalar {\n-///     type Output = Self;\n-///\n-///     // rhs is the \"right-hand side\" of the expression `a & b`\n-///     fn bitand(self, rhs: Self) -> Self {\n-///         Scalar(self.0 & rhs.0)\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n-/// }\n-/// ```\n-///\n-/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n-/// struct.\n-///\n-/// ```\n-/// use std::ops::BitAnd;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct BooleanVector(Vec<bool>);\n-///\n-/// impl BitAnd for BooleanVector {\n-///     type Output = Self;\n-///\n-///     fn bitand(self, BooleanVector(rhs): Self) -> Self {\n-///         let BooleanVector(lhs) = self;\n-///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv1 & bv2, expected);\n-/// }\n-/// ```\n-#[lang = \"bitand\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} & {RHS}`\"]\n-pub trait BitAnd<RHS=Self> {\n-    /// The resulting type after applying the `&` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `&` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn bitand(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! bitand_impl {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl BitAnd for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn bitand(self, rhs: $t) -> $t { self & rhs }\n-        }\n-\n-        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n-    )*)\n-}\n-\n-bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-/// The bitwise OR operator `|`.\n-///\n-/// # Examples\n-///\n-/// In this example, the `|` operator is lifted to a trivial `Scalar` type.\n-///\n-/// ```\n-/// use std::ops::BitOr;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct Scalar(bool);\n-///\n-/// impl BitOr for Scalar {\n-///     type Output = Self;\n-///\n-///     // rhs is the \"right-hand side\" of the expression `a | b`\n-///     fn bitor(self, rhs: Self) -> Self {\n-///         Scalar(self.0 | rhs.0)\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n-/// }\n-/// ```\n-///\n-/// In this example, the `BitOr` trait is implemented for a `BooleanVector`\n-/// struct.\n-///\n-/// ```\n-/// use std::ops::BitOr;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct BooleanVector(Vec<bool>);\n-///\n-/// impl BitOr for BooleanVector {\n-///     type Output = Self;\n-///\n-///     fn bitor(self, BooleanVector(rhs): Self) -> Self {\n-///         let BooleanVector(lhs) = self;\n-///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, true, true, false]);\n-///     assert_eq!(bv1 | bv2, expected);\n-/// }\n-/// ```\n-#[lang = \"bitor\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} | {RHS}`\"]\n-pub trait BitOr<RHS=Self> {\n-    /// The resulting type after applying the `|` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `|` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn bitor(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! bitor_impl {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl BitOr for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn bitor(self, rhs: $t) -> $t { self | rhs }\n-        }\n-\n-        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n-    )*)\n-}\n-\n-bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-/// The bitwise XOR operator `^`.\n-///\n-/// # Examples\n-///\n-/// In this example, the `^` operator is lifted to a trivial `Scalar` type.\n-///\n-/// ```\n-/// use std::ops::BitXor;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct Scalar(bool);\n-///\n-/// impl BitXor for Scalar {\n-///     type Output = Self;\n-///\n-///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n-///     fn bitxor(self, rhs: Self) -> Self {\n-///         Scalar(self.0 ^ rhs.0)\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n-/// }\n-/// ```\n-///\n-/// In this example, the `BitXor` trait is implemented for a `BooleanVector`\n-/// struct.\n-///\n-/// ```\n-/// use std::ops::BitXor;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct BooleanVector(Vec<bool>);\n-///\n-/// impl BitXor for BooleanVector {\n-///     type Output = Self;\n-///\n-///     fn bitxor(self, BooleanVector(rhs): Self) -> Self {\n-///         let BooleanVector(lhs) = self;\n-///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter()\n-///                          .zip(rhs.iter())\n-///                          .map(|(x, y)| (*x || *y) && !(*x && *y))\n-///                          .collect())\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![false, true, true, false]);\n-///     assert_eq!(bv1 ^ bv2, expected);\n-/// }\n-/// ```\n-#[lang = \"bitxor\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} ^ {RHS}`\"]\n-pub trait BitXor<RHS=Self> {\n-    /// The resulting type after applying the `^` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `^` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn bitxor(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! bitxor_impl {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl BitXor for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn bitxor(self, other: $t) -> $t { self ^ other }\n-        }\n-\n-        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n-    )*)\n-}\n-\n-bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-/// The left shift operator `<<`.\n-///\n-/// # Examples\n-///\n-/// An implementation of `Shl` that lifts the `<<` operation on integers to a\n-/// `Scalar` struct.\n-///\n-/// ```\n-/// use std::ops::Shl;\n-///\n-/// #[derive(PartialEq, Debug)]\n-/// struct Scalar(usize);\n-///\n-/// impl Shl<Scalar> for Scalar {\n-///     type Output = Self;\n-///\n-///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n-///         let Scalar(lhs) = self;\n-///         Scalar(lhs << rhs)\n-///     }\n-/// }\n-/// fn main() {\n-///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n-/// }\n-/// ```\n-///\n-/// An implementation of `Shl` that spins a vector leftward by a given amount.\n-///\n-/// ```\n-/// use std::ops::Shl;\n-///\n-/// #[derive(PartialEq, Debug)]\n-/// struct SpinVector<T: Clone> {\n-///     vec: Vec<T>,\n-/// }\n-///\n-/// impl<T: Clone> Shl<usize> for SpinVector<T> {\n-///     type Output = Self;\n-///\n-///     fn shl(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n-///         let (a, b) = self.vec.split_at(rhs);\n-///         let mut spun_vector: Vec<T> = vec![];\n-///         spun_vector.extend_from_slice(b);\n-///         spun_vector.extend_from_slice(a);\n-///         SpinVector { vec: spun_vector }\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n-///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n-/// }\n-/// ```\n-#[lang = \"shl\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} << {RHS}`\"]\n-pub trait Shl<RHS> {\n-    /// The resulting type after applying the `<<` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `<<` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn shl(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! shl_impl {\n-    ($t:ty, $f:ty) => (\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Shl<$f> for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn shl(self, other: $f) -> $t {\n-                self << other\n-            }\n-        }\n-\n-        forward_ref_binop! { impl Shl, shl for $t, $f }\n-    )\n-}\n-\n-macro_rules! shl_impl_all {\n-    ($($t:ty)*) => ($(\n-        shl_impl! { $t, u8 }\n-        shl_impl! { $t, u16 }\n-        shl_impl! { $t, u32 }\n-        shl_impl! { $t, u64 }\n-        shl_impl! { $t, u128 }\n-        shl_impl! { $t, usize }\n-\n-        shl_impl! { $t, i8 }\n-        shl_impl! { $t, i16 }\n-        shl_impl! { $t, i32 }\n-        shl_impl! { $t, i64 }\n-        shl_impl! { $t, i128 }\n-        shl_impl! { $t, isize }\n-    )*)\n-}\n-\n-shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n-\n-/// The right shift operator `>>`.\n-///\n-/// # Examples\n-///\n-/// An implementation of `Shr` that lifts the `>>` operation on integers to a\n-/// `Scalar` struct.\n-///\n-/// ```\n-/// use std::ops::Shr;\n-///\n-/// #[derive(PartialEq, Debug)]\n-/// struct Scalar(usize);\n-///\n-/// impl Shr<Scalar> for Scalar {\n-///     type Output = Self;\n-///\n-///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n-///         let Scalar(lhs) = self;\n-///         Scalar(lhs >> rhs)\n-///     }\n-/// }\n-/// fn main() {\n-///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n-/// }\n-/// ```\n-///\n-/// An implementation of `Shr` that spins a vector rightward by a given amount.\n-///\n-/// ```\n-/// use std::ops::Shr;\n-///\n-/// #[derive(PartialEq, Debug)]\n-/// struct SpinVector<T: Clone> {\n-///     vec: Vec<T>,\n-/// }\n-///\n-/// impl<T: Clone> Shr<usize> for SpinVector<T> {\n-///     type Output = Self;\n-///\n-///     fn shr(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n-///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n-///         let mut spun_vector: Vec<T> = vec![];\n-///         spun_vector.extend_from_slice(b);\n-///         spun_vector.extend_from_slice(a);\n-///         SpinVector { vec: spun_vector }\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n-///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n-/// }\n-/// ```\n-#[lang = \"shr\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} >> {RHS}`\"]\n-pub trait Shr<RHS> {\n-    /// The resulting type after applying the `>>` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `>>` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn shr(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! shr_impl {\n-    ($t:ty, $f:ty) => (\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Shr<$f> for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn shr(self, other: $f) -> $t {\n-                self >> other\n-            }\n-        }\n-\n-        forward_ref_binop! { impl Shr, shr for $t, $f }\n-    )\n-}\n-\n-macro_rules! shr_impl_all {\n-    ($($t:ty)*) => ($(\n-        shr_impl! { $t, u8 }\n-        shr_impl! { $t, u16 }\n-        shr_impl! { $t, u32 }\n-        shr_impl! { $t, u64 }\n-        shr_impl! { $t, u128 }\n-        shr_impl! { $t, usize }\n-\n-        shr_impl! { $t, i8 }\n-        shr_impl! { $t, i16 }\n-        shr_impl! { $t, i32 }\n-        shr_impl! { $t, i64 }\n-        shr_impl! { $t, i128 }\n-        shr_impl! { $t, isize }\n-    )*)\n-}\n-\n-shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-\n-/// The bitwise AND assignment operator `&=`.\n-///\n-/// # Examples\n-///\n-/// In this example, the `&=` operator is lifted to a trivial `Scalar` type.\n-///\n-/// ```\n-/// use std::ops::BitAndAssign;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct Scalar(bool);\n-///\n-/// impl BitAndAssign for Scalar {\n-///     // rhs is the \"right-hand side\" of the expression `a &= b`\n-///     fn bitand_assign(&mut self, rhs: Self) {\n-///         *self = Scalar(self.0 & rhs.0)\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(true));\n-///\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n-///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(false));\n-///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n-/// }\n-/// ```\n-///\n-/// In this example, the `BitAndAssign` trait is implemented for a\n-/// `BooleanVector` struct.\n-///\n-/// ```\n-/// use std::ops::BitAndAssign;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct BooleanVector(Vec<bool>);\n-///\n-/// impl BitAndAssign for BooleanVector {\n-///     // rhs is the \"right-hand side\" of the expression `a &= b`\n-///     fn bitand_assign(&mut self, rhs: Self) {\n-///         assert_eq!(self.0.len(), rhs.0.len());\n-///         *self = BooleanVector(self.0\n-///                                   .iter()\n-///                                   .zip(rhs.0.iter())\n-///                                   .map(|(x, y)| *x && *y)\n-///                                   .collect());\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let mut bv = BooleanVector(vec![true, true, false, false]);\n-///     bv &= BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv, expected);\n-/// }\n-/// ```\n-#[lang = \"bitand_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} &= {Rhs}`\"]\n-pub trait BitAndAssign<Rhs=Self> {\n-    /// The method for the `&=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn bitand_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! bitand_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl BitAndAssign for $t {\n-            #[inline]\n-            fn bitand_assign(&mut self, other: $t) { *self &= other }\n-        }\n-    )+)\n-}\n-\n-bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-/// The bitwise OR assignment operator `|=`.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n-/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n-///\n-/// ```\n-/// use std::ops::BitOrAssign;\n-///\n-/// struct Foo;\n-///\n-/// impl BitOrAssign for Foo {\n-///     fn bitor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Or-ing!\");\n-///     }\n-/// }\n-///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo |= Foo;\n-/// }\n-/// ```\n-#[lang = \"bitor_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} |= {Rhs}`\"]\n-pub trait BitOrAssign<Rhs=Self> {\n-    /// The method for the `|=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn bitor_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! bitor_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl BitOrAssign for $t {\n-            #[inline]\n-            fn bitor_assign(&mut self, other: $t) { *self |= other }\n-        }\n-    )+)\n-}\n-\n-bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-/// The bitwise XOR assignment operator `^=`.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n-/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n-///\n-/// ```\n-/// use std::ops::BitXorAssign;\n-///\n-/// struct Foo;\n-///\n-/// impl BitXorAssign for Foo {\n-///     fn bitxor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Xor-ing!\");\n-///     }\n-/// }\n-///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo ^= Foo;\n-/// }\n-/// ```\n-#[lang = \"bitxor_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} ^= {Rhs}`\"]\n-pub trait BitXorAssign<Rhs=Self> {\n-    /// The method for the `^=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn bitxor_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! bitxor_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl BitXorAssign for $t {\n-            #[inline]\n-            fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n-        }\n-    )+)\n-}\n-\n-bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-/// The left shift assignment operator `<<=`.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n-/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n-///\n-/// ```\n-/// use std::ops::ShlAssign;\n-///\n-/// struct Foo;\n-///\n-/// impl ShlAssign<Foo> for Foo {\n-///     fn shl_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting left!\");\n-///     }\n-/// }\n-///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo <<= Foo;\n-/// }\n-/// ```\n-#[lang = \"shl_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} <<= {Rhs}`\"]\n-pub trait ShlAssign<Rhs> {\n-    /// The method for the `<<=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn shl_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! shl_assign_impl {\n-    ($t:ty, $f:ty) => (\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl ShlAssign<$f> for $t {\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn shl_assign(&mut self, other: $f) {\n-                *self <<= other\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! shl_assign_impl_all {\n-    ($($t:ty)*) => ($(\n-        shl_assign_impl! { $t, u8 }\n-        shl_assign_impl! { $t, u16 }\n-        shl_assign_impl! { $t, u32 }\n-        shl_assign_impl! { $t, u64 }\n-        shl_assign_impl! { $t, u128 }\n-        shl_assign_impl! { $t, usize }\n-\n-        shl_assign_impl! { $t, i8 }\n-        shl_assign_impl! { $t, i16 }\n-        shl_assign_impl! { $t, i32 }\n-        shl_assign_impl! { $t, i64 }\n-        shl_assign_impl! { $t, i128 }\n-        shl_assign_impl! { $t, isize }\n-    )*)\n-}\n-\n-shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-\n-/// The right shift assignment operator `>>=`.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n-/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n-///\n-/// ```\n-/// use std::ops::ShrAssign;\n-///\n-/// struct Foo;\n-///\n-/// impl ShrAssign<Foo> for Foo {\n-///     fn shr_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting right!\");\n-///     }\n-/// }\n-///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo >>= Foo;\n-/// }\n-/// ```\n-#[lang = \"shr_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} >>= {Rhs}`\"]\n-pub trait ShrAssign<Rhs=Self> {\n-    /// The method for the `>>=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn shr_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! shr_assign_impl {\n-    ($t:ty, $f:ty) => (\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl ShrAssign<$f> for $t {\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn shr_assign(&mut self, other: $f) {\n-                *self >>= other\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! shr_assign_impl_all {\n-    ($($t:ty)*) => ($(\n-        shr_assign_impl! { $t, u8 }\n-        shr_assign_impl! { $t, u16 }\n-        shr_assign_impl! { $t, u32 }\n-        shr_assign_impl! { $t, u64 }\n-        shr_assign_impl! { $t, u128 }\n-        shr_assign_impl! { $t, usize }\n-\n-        shr_assign_impl! { $t, i8 }\n-        shr_assign_impl! { $t, i16 }\n-        shr_assign_impl! { $t, i32 }\n-        shr_assign_impl! { $t, i64 }\n-        shr_assign_impl! { $t, i128 }\n-        shr_assign_impl! { $t, isize }\n-    )*)\n-}\n-\n-shr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-\n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `container[index]` when used in an immutable context.\n ///"}]}