{"sha": "ed636c5c5a9104f1ac55a5610d162ea224965025", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNjM2YzVjNWE5MTA0ZjFhYzU1YTU2MTBkMTYyZWEyMjQ5NjUwMjU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-07T19:11:10Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-10T15:46:31Z"}, "message": "remove is_unique", "tree": {"sha": "d1832d608ceff86bd61e52f425ab5c26ba40fd1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1832d608ceff86bd61e52f425ab5c26ba40fd1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed636c5c5a9104f1ac55a5610d162ea224965025", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed636c5c5a9104f1ac55a5610d162ea224965025", "html_url": "https://github.com/rust-lang/rust/commit/ed636c5c5a9104f1ac55a5610d162ea224965025", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed636c5c5a9104f1ac55a5610d162ea224965025/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "url": "https://api.github.com/repos/rust-lang/rust/commits/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "html_url": "https://github.com/rust-lang/rust/commit/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453"}], "stats": {"total": 89, "additions": 15, "deletions": 74}, "files": [{"sha": "41bdc098dcaa97d3f3d19a05f3be7606bc8d46dd", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 74, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ed636c5c5a9104f1ac55a5610d162ea224965025/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed636c5c5a9104f1ac55a5610d162ea224965025/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ed636c5c5a9104f1ac55a5610d162ea224965025", "patch": "@@ -1251,7 +1251,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut error_reported = false;\n         match kind {\n             Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n-                if let Err(_place_err) = self.is_unique(place) {\n+                if let Err(_place_err) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n                     span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             }\n@@ -1358,25 +1358,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        match self.is_upvar_field_projection(&proj.base) {\n+                                        let mode = match self.is_upvar_field_projection(&proj.base) {\n                                             Some(field) if {\n                                                 self.mir.upvar_decls[field.index()].by_ref\n-                                            } => {\n-                                                self.is_mutable(&proj.base,\n-                                                                is_local_mutation_allowed)\n-                                            }\n-                                            _ => self.is_unique(&proj.base)\n-                                        }\n+                                            } => is_local_mutation_allowed,\n+                                            _ => LocalMutationIsAllowed::Yes\n+                                        };\n+\n+                                        self.is_mutable(&proj.base, mode)\n                                     }\n                                 }\n                             }\n                             ty::TyRawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::MutImmutable => return Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of context\n                                     // The users have to check by themselve.\n-                                    hir::MutMutable => Ok(()),\n+                                    hir::MutMutable => return Ok(()),\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n@@ -1394,80 +1393,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::ConstantIndex { .. } |\n                     ProjectionElem::Subslice { .. } |\n                     ProjectionElem::Downcast(..) => {\n-                        let field_projection = self.is_upvar_field_projection(place);\n-\n-                        if let Some(field) = field_projection {\n+                        if let Some(field) = self.is_upvar_field_projection(place) {\n                             let decl = &self.mir.upvar_decls[field.index()];\n                             debug!(\"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n                                    decl, is_local_mutation_allowed, place);\n-                            return match (decl.mutability, is_local_mutation_allowed) {\n+                            match (decl.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No) |\n                                 (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars)\n                                     => Err(place),\n                                 (Mutability::Not, LocalMutationIsAllowed::Yes) |\n-                                (Mutability::Mut, _) => self.is_unique(&proj.base),\n-                            };\n-                        }\n-\n-                        self.is_mutable(&proj.base, is_local_mutation_allowed)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Does this place have a unique path\n-    fn is_unique<'d>(&self, place: &'d Place<'tcx>) -> Result<(), &'d Place<'tcx>> {\n-        match *place {\n-            Place::Local(..) => {\n-                // Local variables are unique\n-                Ok(())\n-            }\n-            Place::Static(ref static_) => {\n-                if !self.tcx.is_static_mut(static_.def_id) {\n-                    Err(place)\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Place::Projection(ref proj) => {\n-                match proj.elem {\n-                    ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-                        // `Box<T>` referent is unique if box is a unique spot\n-                        if base_ty.is_box() {\n-                            return self.is_unique(&proj.base);\n-                        }\n-\n-                        // Otherwise we check the kind of deref to decide\n-                        match base_ty.sty {\n-                            ty::TyRef(_, tnm) => {\n-                                match tnm.mutbl {\n-                                    // place represent an aliased location\n-                                    hir::MutImmutable => Err(place),\n-                                    // `&mut T` is as unique as the context in which it is found\n-                                    hir::MutMutable => self.is_unique(&proj.base),\n-                                }\n-                            }\n-                            ty::TyRawPtr(tnm) => {\n-                                match tnm.mutbl {\n-                                    // `*mut` can be aliased, but we leave it to user\n-                                    hir::MutMutable => Ok(()),\n-                                    // `*const` is treated the same as `*mut`\n-                                    hir::MutImmutable => Ok(()),\n-                                }\n+                                (Mutability::Mut, _) =>\n+                                    self.is_mutable(&proj.base, is_local_mutation_allowed)\n                             }\n-                            // Deref should only be for reference, pointers or boxes\n-                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n+                        } else {\n+                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n                         }\n                     }\n-                    // Other projections are unique if the base is unique\n-                    ProjectionElem::Field(..) |\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Downcast(..) => self.is_unique(&proj.base),\n                 }\n             }\n         }"}]}