{"sha": "313d474b35fd6e60302324f75622d77765e1cbf8", "node_id": "C_kwDOAAsO6NoAKDMxM2Q0NzRiMzVmZDZlNjAzMDIzMjRmNzU2MjJkNzc3NjVlMWNiZjg", "commit": {"author": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-08-21T17:56:00Z"}, "committer": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-08-23T11:47:07Z"}, "message": "Migrate OpaqueHiddenType, E0282, E0283, E0284, E0698", "tree": {"sha": "43f00faee46c0254b5e140a1de8e468d5ee97d13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43f00faee46c0254b5e140a1de8e468d5ee97d13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/313d474b35fd6e60302324f75622d77765e1cbf8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEAWou4Gq79HasRseDspeR1Nh440UFAmMEvjsACgkQspeR1Nh4\n40X6tQ/+Lt0dlc7ys0SHbevyvyGR5xSJM5IzLSEEOpXhmQ8uEPm9C4NHbCwobUxr\n0fNQi6qm2yZAJqxoFWNvYyg+GeyovqNHQaBwogiy54eHIpHfK7JXm7MzTF1OimQA\nIomtghsmACuEdED1eknFDRvhDNlxcXWHayaVHKF3tQzUqP1scWQELtWKbqTkf+xM\nFXeSNdUGNPlt35LD5W506PHjzEfHlgh1Uhk+tHjap6adZD1wEhEAg9MAz/MoEgdC\noYK5hNGrdQ4SC0WLH4wP7Rz+g62eiB1k6UgMcZvbDQuIrooutqQTpVWvjd7FO4Sf\nfG1rdnNLFuBEwZVhlK6XXRjwbgir9l5GRCEvvZ3k9/kJnhHuiHYYDHf4+cEOTMkd\nNGKvkZWbxDtXA1s0YMowy/+/ftyMI1kYB37bHCAicyRbTN3oXjw/ZFtZ3XrJeuSq\na605/KiyEd2PY39fo5DDJZjPQbG1mE9DshA+tjobCwFnUVL0WW9Jzqc5RS4vYeAW\nb0FLIE22Vt7oL3M+YM7hauhwpVxvIzvbMiWbFtzceyO7yeIb2leyNbwqI0NowUX1\n1eR2BF27DqTKcKLNO3llu0O6jvPa9uAJUrpIPbilXtQn1BX9DC5O3gwxFrz5uUm3\nSIQntS9F9Uwsm1FRHJmUaHISDHtCaKg0r0fuh/2L0a8cnFEnC1o=\n=26QE\n-----END PGP SIGNATURE-----", "payload": "tree 43f00faee46c0254b5e140a1de8e468d5ee97d13\nparent 1cff5642037b83ce1239a624bbe617a9aa0d59b1\nauthor Nikita Tomashevich <quant3234@gmail.com> 1661104560 +0300\ncommitter Nikita Tomashevich <quant3234@gmail.com> 1661255227 +0300\n\nMigrate OpaqueHiddenType, E0282, E0283, E0284, E0698\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/313d474b35fd6e60302324f75622d77765e1cbf8", "html_url": "https://github.com/rust-lang/rust/commit/313d474b35fd6e60302324f75622d77765e1cbf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/313d474b35fd6e60302324f75622d77765e1cbf8/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cff5642037b83ce1239a624bbe617a9aa0d59b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cff5642037b83ce1239a624bbe617a9aa0d59b1", "html_url": "https://github.com/rust-lang/rust/commit/1cff5642037b83ce1239a624bbe617a9aa0d59b1"}], "stats": {"total": 570, "additions": 440, "deletions": 130}, "files": [{"sha": "853a2976bc61d115412cfea90f57881899b69b5f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/313d474b35fd6e60302324f75622d77765e1cbf8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/313d474b35fd6e60302324f75622d77765e1cbf8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=313d474b35fd6e60302324f75622d77765e1cbf8", "patch": "@@ -3983,6 +3983,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\","}, {"sha": "9250363551dbb743daf11f04c3dae64ca97e0710", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=313d474b35fd6e60302324f75622d77765e1cbf8", "patch": "@@ -0,0 +1,65 @@\n+infer_opaque_hidden_type = \n+    opaque type's hidden type cannot be another opaque type from the same scope\n+    .label = one of the two opaque types used here has to be outside its defining scope\n+    .opaque_type = opaque type whose hidden type is being assigned\n+    .hidden_type = opaque type being used as hidden type\n+\n+infer_type_annotations_needed = {$source_kind ->\n+    [closure] type annotations needed for the closure `{$source_name}`\n+    [normal] type annotations needed for `{$source_name}`\n+    *[other] type annotations needed\n+} \n+    .label = type must be known at this point\n+\n+infer_label_bad = {$bad_kind ->\n+    *[other] cannot infer type\n+    [more_info] cannot infer {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$name}`{$has_parent ->\n+        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n+        *[false] {\"\"}\n+    }\n+}\n+\n+infer_source_kind_subdiag_let = {$kind ->\n+    [with_pattern] consider giving `{$name}` an explicit type\n+    [closure] consider giving this closure parameter an explicit type\n+    *[other] consider giving this pattern a type\n+}{$x_kind ->\n+    [has_name] , where the {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$arg_name}` is specified\n+    [underscore] , where the placeholders `_` are specified\n+    *[empty] {\"\"}\n+}\n+\n+infer_source_kind_subdiag_generic_label =\n+    cannot infer {$is_type -> \n+    [true] type\n+    *[false] the value\n+    } of the {$is_type -> \n+    [true] type\n+    *[false] const\n+    } {$parent_exists ->\n+    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n+    *[false] parameter {$param_name} \n+    }\n+\n+infer_source_kind_subdiag_generic_suggestion =\n+    consider specifying the generic {$arg_count -> \n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+infer_source_kind_fully_qualified = \n+    try using a fully qualified path to specify the expected types\n+\n+infer_source_kind_closure_return =\n+    try giving this closure an explicit return type\n+\n+infer_need_type_info_in_generator =\n+    type inside {$generator_kind} must be known in this context"}, {"sha": "a24ab3072925f497fa560c810602badb14282f68", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=313d474b35fd6e60302324f75622d77765e1cbf8", "patch": "@@ -38,6 +38,7 @@ fluent_messages! {\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n+    infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\","}, {"sha": "aced787d6711600ee0337b7ee4dd16a3c736973b", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=313d474b35fd6e60302324f75622d77765e1cbf8", "patch": "@@ -15,6 +15,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "7bd418ddf5f4c6e20e3ec3510184c06023128b27", "filename": "compiler/rustc_infer/src/errors.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=313d474b35fd6e60302324f75622d77765e1cbf8", "patch": "@@ -0,0 +1,187 @@\n+use rustc_errors::{fluent, AddSubdiagnostic};\n+use rustc_hir::FnRetTy;\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{BytePos, Span};\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::opaque_hidden_type)]\n+pub struct OpaqueHiddenTypeDiag {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(infer::opaque_type)]\n+    pub opaque_type: Span,\n+    #[note(infer::hidden_type)]\n+    pub hidden_type: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+pub struct AnnotationRequired<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0283\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+pub struct AmbigousImpl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0284\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+pub struct AmbigousReturn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+pub struct NeedTypeInfoInGenerator<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub generator_kind: String,\n+    #[subdiagnostic]\n+    pub bad_label: InferenceBadError<'a>,\n+}\n+\n+// Used when a better one isn't available\n+#[derive(SessionSubdiagnostic)]\n+#[label(infer::label_bad)]\n+pub struct InferenceBadError<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub bad_kind: &'static str,\n+    pub prefix_kind: &'static str,\n+    pub has_parent: bool,\n+    pub prefix: &'a str,\n+    pub parent_prefix: &'a str,\n+    pub parent_name: String,\n+    pub name: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindSubdiag<'a> {\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_let,\n+        code = \": {type_name}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    LetLike {\n+        #[primary_span]\n+        span: Span,\n+        name: String,\n+        type_name: String,\n+        kind: &'static str,\n+        x_kind: &'static str,\n+        prefix_kind: &'static str,\n+        prefix: &'a str,\n+        arg_name: String,\n+    },\n+    #[label(infer::source_kind_subdiag_generic_label)]\n+    GenericLabel {\n+        #[primary_span]\n+        span: Span,\n+        is_type: bool,\n+        param_name: String,\n+        parent_exists: bool,\n+        parent_prefix: String,\n+        parent_name: String,\n+    },\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_generic_suggestion,\n+        code = \"::<{args}>\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    GenericSuggestion {\n+        #[primary_span]\n+        span: Span,\n+        arg_count: usize,\n+        args: String,\n+    },\n+}\n+\n+// Has to be implemented manually because multipart suggestions are not supported by the derive macro.\n+// Would be a part of `SourceKindSubdiag` otherwise.\n+pub enum SourceKindMultiSuggestion<'a> {\n+    FullyQualified {\n+        span: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor: (&'a str, BytePos),\n+    },\n+    ClosureReturn {\n+        ty_info: String,\n+        data: &'a FnRetTy<'a>,\n+        should_wrap_expr: Option<Span>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for SourceKindMultiSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            Self::FullyQualified { span, def_path, adjustment, successor } => {\n+                let suggestion = vec![\n+                    (span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n+                    (span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n+                ];\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_fully_qualified,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+            Self::ClosureReturn { ty_info, data, should_wrap_expr } => {\n+                let (arrow, post) = match data {\n+                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+                    _ => (\"\", \"\"),\n+                };\n+                let suggestion = match should_wrap_expr {\n+                    Some(end_span) => vec![\n+                        (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post)),\n+                        (end_span, \" }\".to_string()),\n+                    ],\n+                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ty_info, post))],\n+                };\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_closure_return,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "da0035d2519f1d5b2e27b716c380ee3365c7debd", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 182, "deletions": 130, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=313d474b35fd6e60302324f75622d77765e1cbf8", "patch": "@@ -1,6 +1,10 @@\n+use crate::errors::{\n+    AmbigousImpl, AmbigousReturn, AnnotationRequired, InferenceBadError, NeedTypeInfoInGenerator,\n+    SourceKindMultiSuggestion, SourceKindSubdiag,\n+};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::InferCtxt;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n@@ -14,6 +18,7 @@ use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{IsSuggestable, Ty, TyCtxt, TypeckResults};\n+use rustc_session::SessionDiagnostic;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n@@ -66,32 +71,42 @@ pub enum UnderspecifiedArgKind {\n }\n \n impl InferenceDiagnosticsData {\n-    /// Generate a label for a generic argument which can't be inferred. When not\n-    /// much is known about the argument, `use_diag` may be used to describe the\n-    /// labeled value.\n-    fn cannot_infer_msg(&self) -> String {\n-        if self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }) {\n-            return \"cannot infer type\".to_string();\n-        }\n-\n-        let suffix = match &self.parent {\n-            Some(parent) => parent.suffix_string(),\n-            None => String::new(),\n-        };\n-\n-        // For example: \"cannot infer type for type parameter `T`\"\n-        format!(\"cannot infer {} `{}`{}\", self.kind.prefix_string(), self.name, suffix)\n+    fn can_add_more_info(&self) -> bool {\n+        !(self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }))\n     }\n \n-    fn where_x_is_specified(&self, in_type: Ty<'_>) -> String {\n+    fn where_x_is_kind(&self, in_type: Ty<'_>) -> &'static str {\n         if in_type.is_ty_infer() {\n-            String::new()\n+            \"empty\"\n         } else if self.name == \"_\" {\n             // FIXME: Consider specializing this message if there is a single `_`\n             // in the type.\n-            \", where the placeholders `_` are specified\".to_string()\n+            \"underscore\"\n         } else {\n-            format!(\", where the {} `{}` is specified\", self.kind.prefix_string(), self.name)\n+            \"has_name\"\n+        }\n+    }\n+\n+    /// Generate a label for a generic argument which can't be inferred. When not\n+    /// much is known about the argument, `use_diag` may be used to describe the\n+    /// labeled value.\n+    fn make_bad_error(&self, span: Span) -> InferenceBadError<'_> {\n+        let has_parent = self.parent.is_some();\n+        let bad_kind = if self.can_add_more_info() { \"more_info\" } else { \"other\" };\n+        let (parent_prefix, parent_name) = self\n+            .parent\n+            .as_ref()\n+            .map(|parent| (parent.prefix, parent.name.clone()))\n+            .unwrap_or_default();\n+        InferenceBadError {\n+            span,\n+            bad_kind,\n+            prefix_kind: self.kind.prefix_kind(),\n+            prefix: self.kind.try_get_prefix().unwrap_or_default(),\n+            name: self.name.clone(),\n+            has_parent,\n+            parent_prefix,\n+            parent_name,\n         }\n     }\n }\n@@ -113,18 +128,20 @@ impl InferenceDiagnosticsParentData {\n     fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n         Self::for_parent_def_id(tcx, tcx.parent(def_id))\n     }\n-\n-    fn suffix_string(&self) -> String {\n-        format!(\" declared on the {} `{}`\", self.prefix, self.name)\n-    }\n }\n \n impl UnderspecifiedArgKind {\n-    fn prefix_string(&self) -> Cow<'static, str> {\n+    fn prefix_kind(&self) -> &'static str {\n+        match self {\n+            Self::Type { .. } => \"type\",\n+            Self::Const { is_parameter: true } => \"const_with_param\",\n+            Self::Const { is_parameter: false } => \"const\",\n+        }\n+    }\n+    fn try_get_prefix(&self) -> Option<&str> {\n         match self {\n-            Self::Type { prefix } => format!(\"type for {}\", prefix).into(),\n-            Self::Const { is_parameter: true } => \"the value of const parameter\".into(),\n-            Self::Const { is_parameter: false } => \"the value of the constant\".into(),\n+            Self::Type { prefix } => Some(prefix.as_ref()),\n+            Self::Const { .. } => None,\n         }\n     }\n }\n@@ -303,11 +320,44 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         arg_data: InferenceDiagnosticsData,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let error_code = error_code.into();\n-        let mut err =\n-            self.tcx.sess.struct_span_err_with_code(span, \"type annotations needed\", error_code);\n-        err.span_label(span, arg_data.cannot_infer_msg());\n-        err\n+        let source_kind = \"other\";\n+        let source_name = \"\";\n+        let failure_span = None;\n+        let infer_subdiags = Vec::new();\n+        let multi_suggestions = Vec::new();\n+        let bad_label = Some(arg_data.make_bad_error(span));\n+        match error_code {\n+            TypeAnnotationNeeded::E0282 => AnnotationRequired {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0284 => AmbigousReturn {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+        }\n     }\n \n     pub fn emit_inference_failure_err(\n@@ -340,48 +390,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return self.bad_inference_failure_err(failure_span, arg_data, error_code)\n         };\n \n-        let error_code = error_code.into();\n-        let mut err = self.tcx.sess.struct_span_err_with_code(\n-            span,\n-            &format!(\"type annotations needed{}\", kind.ty_msg(self)),\n-            error_code,\n-        );\n-\n-        if should_label_span && !failure_span.overlaps(span) {\n-            err.span_label(failure_span, \"type must be known at this point\");\n-        }\n+        let (source_kind, name) = kind.ty_localized_msg(self);\n+        let failure_span = if should_label_span && !failure_span.overlaps(span) {\n+            Some(failure_span)\n+        } else {\n+            None\n+        };\n \n+        let mut infer_subdiags = Vec::new();\n+        let mut multi_suggestions = Vec::new();\n         match kind {\n             InferSourceKind::LetBinding { insert_span, pattern_name, ty } => {\n-                let suggestion_msg = if let Some(name) = pattern_name {\n-                    format!(\n-                        \"consider giving `{}` an explicit type{}\",\n-                        name,\n-                        arg_data.where_x_is_specified(ty)\n-                    )\n-                } else {\n-                    format!(\n-                        \"consider giving this pattern a type{}\",\n-                        arg_data.where_x_is_specified(ty)\n-                    )\n-                };\n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &suggestion_msg,\n-                    format!(\": {}\", ty_to_string(self, ty)),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::LetLike {\n+                    span: insert_span,\n+                    name: pattern_name.map(|name| name.to_string()).unwrap_or_else(String::new),\n+                    x_kind: arg_data.where_x_is_kind(ty),\n+                    prefix_kind: arg_data.kind.prefix_kind(),\n+                    prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n+                    arg_name: arg_data.name,\n+                    kind: if pattern_name.is_some() { \"with_pattern\" } else { \"other\" },\n+                    type_name: ty_to_string(self, ty),\n+                });\n             }\n             InferSourceKind::ClosureArg { insert_span, ty } => {\n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &format!(\n-                        \"consider giving this closure parameter an explicit type{}\",\n-                        arg_data.where_x_is_specified(ty)\n-                    ),\n-                    format!(\": {}\", ty_to_string(self, ty)),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::LetLike {\n+                    span: insert_span,\n+                    name: String::new(),\n+                    x_kind: arg_data.where_x_is_kind(ty),\n+                    prefix_kind: arg_data.kind.prefix_kind(),\n+                    prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n+                    arg_name: arg_data.name,\n+                    kind: \"closure\",\n+                    type_name: ty_to_string(self, ty),\n+                });\n             }\n             InferSourceKind::GenericArg {\n                 insert_span,\n@@ -393,19 +434,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let generics = self.tcx.generics_of(generics_def_id);\n                 let is_type = matches!(arg.unpack(), GenericArgKind::Type(_));\n \n-                let cannot_infer_msg = format!(\n-                    \"cannot infer {} of the {} parameter `{}`{}\",\n-                    if is_type { \"type\" } else { \"the value\" },\n-                    if is_type { \"type\" } else { \"const\" },\n-                    generics.params[argument_index].name,\n-                    // We use the `generics_def_id` here, as even when suggesting `None::<T>`,\n-                    // the type parameter `T` was still declared on the enum, not on the\n-                    // variant.\n+                let (parent_exists, parent_prefix, parent_name) =\n                     InferenceDiagnosticsParentData::for_parent_def_id(self.tcx, generics_def_id)\n-                        .map_or(String::new(), |parent| parent.suffix_string()),\n-                );\n+                        .map_or((false, String::new(), String::new()), |parent| {\n+                            (true, parent.prefix.to_string(), parent.name)\n+                        });\n \n-                err.span_label(span, cannot_infer_msg);\n+                infer_subdiags.push(SourceKindSubdiag::GenericLabel {\n+                    span,\n+                    is_type,\n+                    param_name: generics.params[argument_index].name.to_string(),\n+                    parent_exists,\n+                    parent_prefix,\n+                    parent_name,\n+                });\n \n                 let args = fmt_printer(self, Namespace::TypeNS)\n                     .comma_sep(generic_args.iter().copied().map(|arg| {\n@@ -435,15 +477,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .unwrap()\n                     .into_buffer();\n \n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &format!(\n-                        \"consider specifying the generic argument{}\",\n-                        pluralize!(generic_args.len()),\n-                    ),\n-                    format!(\"::<{}>\", args),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::GenericSuggestion {\n+                    span: insert_span,\n+                    arg_count: generic_args.len(),\n+                    args,\n+                });\n             }\n             InferSourceKind::FullyQualifiedMethodCall { receiver, successor, substs, def_id } => {\n                 let printer = fmt_printer(self, Namespace::ValueNS);\n@@ -468,37 +506,54 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     _ => \"\",\n                 };\n \n-                let suggestion = vec![\n-                    (receiver.span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n-                    (receiver.span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n-                ];\n-                err.multipart_suggestion_verbose(\n-                    \"try using a fully qualified path to specify the expected types\",\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n+                multi_suggestions.push(SourceKindMultiSuggestion::FullyQualified {\n+                    span: receiver.span,\n+                    def_path,\n+                    adjustment,\n+                    successor,\n+                });\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n-                let ret = ty_to_string(self, ty);\n-                let (arrow, post) = match data {\n-                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-                    _ => (\"\", \"\"),\n-                };\n-                let suggestion = match should_wrap_expr {\n-                    Some(end_span) => vec![\n-                        (data.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n-                        (end_span, \" }\".to_string()),\n-                    ],\n-                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ret, post))],\n-                };\n-                err.multipart_suggestion_verbose(\n-                    \"try giving this closure an explicit return type\",\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n+                let ty_info = ty_to_string(self, ty);\n+                multi_suggestions.push(SourceKindMultiSuggestion::ClosureReturn {\n+                    ty_info,\n+                    data,\n+                    should_wrap_expr,\n+                });\n+            }\n+        }\n+        match error_code {\n+            TypeAnnotationNeeded::E0282 => AnnotationRequired {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n             }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0284 => AmbigousReturn {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n         }\n-        err\n     }\n \n     pub fn need_type_info_err_in_generator(\n@@ -510,15 +565,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);\n \n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n+        NeedTypeInfoInGenerator {\n+            bad_label: data.make_bad_error(span),\n             span,\n-            E0698,\n-            \"type inside {} must be known in this context\",\n-            kind,\n-        );\n-        err.span_label(span, data.cannot_infer_msg());\n-        err\n+            generator_kind: kind.to_string(),\n+        }\n+        .into_diagnostic(&self.tcx.sess.parse_sess)\n     }\n }\n \n@@ -579,22 +631,22 @@ impl<'tcx> InferSource<'tcx> {\n }\n \n impl<'tcx> InferSourceKind<'tcx> {\n-    fn ty_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> String {\n+    fn ty_localized_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> (&'static str, String) {\n         match *self {\n             InferSourceKind::LetBinding { ty, .. }\n             | InferSourceKind::ClosureArg { ty, .. }\n             | InferSourceKind::ClosureReturn { ty, .. } => {\n                 if ty.is_closure() {\n-                    format!(\" for the closure `{}`\", closure_as_fn_str(infcx, ty))\n+                    (\"closure\", closure_as_fn_str(infcx, ty))\n                 } else if !ty.is_ty_infer() {\n-                    format!(\" for `{}`\", ty_to_string(infcx, ty))\n+                    (\"normal\", ty_to_string(infcx, ty))\n                 } else {\n-                    String::new()\n+                    (\"other\", String::new())\n                 }\n             }\n             // FIXME: We should be able to add some additional info here.\n             InferSourceKind::GenericArg { .. }\n-            | InferSourceKind::FullyQualifiedMethodCall { .. } => String::new(),\n+            | InferSourceKind::FullyQualifiedMethodCall { .. } => (\"other\", String::new()),\n         }\n     }\n }"}, {"sha": "2c1d339b578fe21f4ff93ac166f718b244c3770f", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/313d474b35fd6e60302324f75622d77765e1cbf8/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=313d474b35fd6e60302324f75622d77765e1cbf8", "patch": "@@ -23,6 +23,8 @@\n #![feature(never_type)]\n #![feature(try_blocks)]\n #![recursion_limit = \"512\"] // For rustdoc\n+// #![deny(rustc::untranslatable_diagnostic)]\n+// #![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -34,5 +36,6 @@ extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n \n+mod errors;\n pub mod infer;\n pub mod traits;"}]}