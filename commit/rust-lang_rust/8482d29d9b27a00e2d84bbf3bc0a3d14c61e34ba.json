{"sha": "8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ODJkMjlkOWIyN2EwMGUyZDg0YmJmM2JjMGEzZDE0YzYxZTM0YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T06:10:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T06:10:12Z"}, "message": "auto merge of #7149 : thestinger/rust/vec, r=graydon", "tree": {"sha": "2f9642874bcf470b735cb179be96ecbd77db56e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f9642874bcf470b735cb179be96ecbd77db56e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "html_url": "https://github.com/rust-lang/rust/commit/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5572023cd868c5b6045bc91355cd21465c59ff6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5572023cd868c5b6045bc91355cd21465c59ff6d", "html_url": "https://github.com/rust-lang/rust/commit/5572023cd868c5b6045bc91355cd21465c59ff6d"}, {"sha": "7f00ab3df10b8b648872edf25fb1700168b306de", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f00ab3df10b8b648872edf25fb1700168b306de", "html_url": "https://github.com/rust-lang/rust/commit/7f00ab3df10b8b648872edf25fb1700168b306de"}], "stats": {"total": 167, "additions": 52, "deletions": 115}, "files": [{"sha": "2e3ce40c9f7dcb2e5da22fd6c4621bb65eda89aa", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -359,7 +359,7 @@ fn pnorm(nums: &~[float], p: uint) -> float {\n \n fn main() {\n     let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n-    println(fmt!(\"Inf-norm = %?\",  numbers.max()));\n+    println(fmt!(\"Inf-norm = %?\",  *numbers.iter().max().unwrap()));\n \n     let numbers_arc = ARC(numbers);\n "}, {"sha": "c0b939ddac50fa5f6115baa7b36f0e8f5accac5b", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -2039,17 +2039,12 @@ themselves contain type parameters. A trait for generalized sequence\n types might look like the following:\n \n ~~~~\n-# use std::vec;\n trait Seq<T> {\n-    fn len(&self) -> uint;\n-    fn iter(&self, b: &fn(v: &T));\n+    fn length(&self) -> uint;\n }\n \n impl<T> Seq<T> for ~[T] {\n-    fn len(&self) -> uint { self.len() }\n-    fn iter(&self, b: &fn(v: &T)) {\n-        for vec::each(*self) |elt| { b(elt); }\n-    }\n+    fn length(&self) -> uint { self.len() }\n }\n ~~~~\n "}, {"sha": "4ff67fc3f42c297580b9a3bef3f09402ffc63a7a", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -583,12 +583,12 @@ pub mod bytepipes {\n \n     impl BytePort for PipeBytePort {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n-            if vec::uniq_len(&const *self.buf) >= count {\n+            if self.buf.len() >= count {\n                 let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n                 *self.buf = bytes.slice(count, bytes.len()).to_owned();\n                 bytes.truncate(count);\n                 return Some(bytes);\n-            } else if vec::uniq_len(&const *self.buf) > 0 {\n+            } else if !self.buf.is_empty() {\n                 let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n                 assert!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n@@ -598,7 +598,7 @@ pub mod bytepipes {\n                     }\n                     None => return None\n                 }\n-            } else if vec::uniq_len(&const *self.buf) == 0 {\n+            } else /* empty */ {\n                 match self.port.try_recv() {\n                     Some(buf) => {\n                         assert!(!buf.is_empty());\n@@ -607,8 +607,6 @@ pub mod bytepipes {\n                     }\n                     None => return None\n                 }\n-            } else {\n-                ::core::util::unreachable()\n             }\n         }\n     }"}, {"sha": "28b3700399a6e5cb89e205e9c7dc259a3d33cf8c", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -879,8 +879,7 @@ impl io::Reader for TcpSocketBuf {\n \n           // If possible, copy up to `len` bytes from the internal\n           // `data.buf` into `buf`\n-          let nbuffered = vec::uniq_len(&const self.data.buf) -\n-                self.data.buf_off;\n+          let nbuffered = self.data.buf.len() - self.data.buf_off;\n           let needed = len - count;\n             if nbuffered > 0 {\n                 unsafe {\n@@ -934,7 +933,7 @@ impl io::Reader for TcpSocketBuf {\n     }\n     fn read_byte(&self) -> int {\n         loop {\n-          if vec::uniq_len(&const self.data.buf) > self.data.buf_off {\n+          if self.data.buf.len() > self.data.buf_off {\n             let c = self.data.buf[self.data.buf_off];\n             self.data.buf_off += 1;\n             return c as int"}, {"sha": "efbf23f11b15c3ffb86c8ac3cd9068927fe8a5db", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -35,10 +35,10 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n \n impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n-    fn len(&const self) -> uint { vec::uniq_len(&const self.data) }\n+    fn len(&self) -> uint { self.data.len() }\n \n     /// Returns true if a queue contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T:Ord> Mutable for PriorityQueue<T> {"}, {"sha": "0c35630345b4dfbc2102f9e9ab692290904f717b", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -93,7 +93,7 @@ pub fn sha1() -> @Sha1 {\n     }\n     fn process_msg_block(st: &mut Sha1State) {\n         assert_eq!(st.h.len(), digest_buf_len);\n-        assert_eq!(vec::uniq_len(st.work_buf), work_buf_len);\n+        assert_eq!(st.work_buf.len(), work_buf_len);\n         let mut t: int; // Loop counter\n         let w = st.work_buf;\n "}, {"sha": "dae9113b3a9dabb1113277f2b2d13ec7950144ef", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -32,9 +32,9 @@ pub struct SmallIntMap<T> {\n \n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint {\n+    fn len(&self) -> uint {\n         let mut sz = 0;\n-        for uint::range(0, vec::uniq_len(&const self.v)) |i| {\n+        for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n                 Some(_) => sz += 1,\n                 None => {}\n@@ -44,7 +44,7 @@ impl<V> Container for SmallIntMap<V> {\n     }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<V> Mutable for SmallIntMap<V> {\n@@ -199,12 +199,12 @@ pub struct SmallIntSet {\n \n impl Container for SmallIntSet {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint {\n+    fn len(&self) -> uint {\n         self.map.len()\n     }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl Mutable for SmallIntSet {"}, {"sha": "a465cef09e6be68fac89b59c32e072283db802e3", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -365,7 +365,7 @@ pub fn run_tests_console(opts: &TestOpts,\n fn print_failures(st: &ConsoleTestState) {\n     st.out.write_line(\"\\nfailures:\");\n     let mut failures = ~[];\n-    for uint::range(0, vec::uniq_len(&const st.failures)) |i| {\n+    for uint::range(0, st.failures.len()) |i| {\n         let name = copy st.failures[i].name;\n         failures.push(name.to_str());\n     }"}, {"sha": "9ae241c7030fcb96302a90d652d67f3a6062b3ed", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -165,7 +165,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n-                return CEnum(discrs.min(), discrs.max());\n+                return CEnum(*discrs.iter().min().unwrap(), *discrs.iter().max().unwrap());\n             }\n \n             if cases.len() == 1 {\n@@ -509,7 +509,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n         }\n         General(ref cases) => {\n             let case = &cases[discr as uint];\n-            let max_sz = cases.map(|s| s.size).max();\n+            let max_sz = cases.iter().transform(|x| x.size).max().unwrap();\n             let discr_ty = C_int(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);"}, {"sha": "bcdd6cd0bfa60cd9faf7e1825c75ea16c82d41ea", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -209,7 +209,7 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n     fn peek(&self) -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n-        for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n+        for uint::range(0, self.ports.len()) |i| {\n             let port: &pipesy::Port<T> = &self.ports[i];\n             if port.peek() {\n                 return true;"}, {"sha": "c1b656f1cd9e6bdc71d818d01f069053bef373d5", "filename": "src/libstd/container.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -16,10 +16,10 @@ use option::Option;\n /// knowledge known is the number of elements contained within.\n pub trait Container {\n     /// Return the number of elements in the container\n-    fn len(&const self) -> uint;\n+    fn len(&self) -> uint;\n \n     /// Return true if the container contains no elements\n-    fn is_empty(&const self) -> bool;\n+    fn is_empty(&self) -> bool;\n }\n \n /// A trait to represent mutable containers"}, {"sha": "d3faa75e3b044f4b67bd0bd46545f313261b5955", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -1667,7 +1667,7 @@ impl Writer for BytesWriter {\n \n     fn seek(&self, offset: int, whence: SeekStyle) {\n         let pos = *self.pos;\n-        let len = vec::uniq_len(&const *self.bytes);\n+        let len = self.bytes.len();\n         *self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n "}, {"sha": "347b477442287c8f85161c79c1cba7439806d435", "filename": "src/libstd/old_iter.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -54,11 +54,6 @@ pub trait CopyableIter<A:Copy> {\n     fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n }\n \n-pub trait CopyableOrderedIter<A:Copy + Ord> {\n-    fn min(&self) -> A;\n-    fn max(&self) -> A;\n-}\n-\n // A trait for sequences that can be built by imperatively pushing elements\n // onto them.\n pub trait Buildable<A> {\n@@ -192,40 +187,6 @@ pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n     return None;\n }\n \n-// note: 'rposition' would only make sense to provide with a bidirectional\n-// iter interface, such as would provide \"reach\" in addition to \"each\". As is,\n-// it would have to be implemented with foldr, which is too inefficient.\n-\n-#[inline(always)]\n-pub fn min<A:Copy + Ord,IA:BaseIter<A>>(this: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(this, None) |a, b| {\n-        match a {\n-          &Some(ref a_) if *a_ < *b => {\n-             *(a)\n-          }\n-          _ => Some(*b)\n-        }\n-    } {\n-        Some(val) => val,\n-        None => fail!(\"min called on empty iterator\")\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn max<A:Copy + Ord,IA:BaseIter<A>>(this: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(this, None) |a, b| {\n-        match a {\n-          &Some(ref a_) if *a_ > *b => {\n-              *(a)\n-          }\n-          _ => Some(*b)\n-        }\n-    } {\n-        Some(val) => val,\n-        None => fail!(\"max called on empty iterator\")\n-    }\n-}\n-\n #[inline(always)]\n pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                 -> Option<A> {"}, {"sha": "fffcb34dc09c9c412f4de8f8b467379b8458099f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -1685,10 +1685,11 @@ mod tests {\n           assert!((ostream as uint != 0u));\n           let s = ~\"hello\";\n           let mut buf = s.as_bytes_with_null().to_owned();\n+          let len = buf.len();\n           do vec::as_mut_buf(buf) |b, _len| {\n-              assert!((libc::fwrite(b as *c_void, 1u as size_t,\n-                                   (s.len() + 1u) as size_t, ostream)\n-                      == buf.len() as size_t))\n+              assert_eq!(libc::fwrite(b as *c_void, 1u as size_t,\n+                                      (s.len() + 1u) as size_t, ostream),\n+                         len as size_t)\n           }\n           assert_eq!(libc::fclose(ostream), (0u as c_int));\n           let in_mode = in.get_mode();"}, {"sha": "60165ed5daebef8c3ad79d0de947f8f183a47720", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -47,9 +47,9 @@ pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use old_iter::{BaseIter, ReverseIter, ExtendedIter, EqIter};\n-pub use old_iter::{CopyableIter, CopyableOrderedIter};\n+pub use old_iter::CopyableIter;\n pub use iter::{Times, FromIter};\n-pub use iterator::{Iterator, IteratorUtil};\n+pub use iterator::{Iterator, IteratorUtil, OrdIterator};\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};"}, {"sha": "b7ff1acea139430ecec443e7783e81bf4fcc3c9c", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -18,6 +18,7 @@ More runtime type reflection\n \n use cast::transmute;\n use char;\n+use container::Container;\n use intrinsic;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use intrinsic::Opaque;\n@@ -502,7 +503,7 @@ impl TyVisitor for ReprVisitor {\n                                 _offset: uint,\n                                 inner: *TyDesc)\n                                 -> bool {\n-        match self.var_stk[vec::uniq_len(&const *self.var_stk) - 1] {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if i != 0 {\n                     self.writer.write_str(\", \");\n@@ -520,7 +521,7 @@ impl TyVisitor for ReprVisitor {\n                                 _disr_val: int,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match self.var_stk[vec::uniq_len(&const *self.var_stk) - 1] {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n                     self.writer.write_char(')');"}, {"sha": "a5e68bcdac4cf2217b6d587608f430867562fd5c", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -297,7 +297,8 @@ impl<T: Reader> ReaderUtil for T {\n \n             do (|| {\n                 while total_read < len {\n-                    let slice = vec::mut_slice(*buf, start_len + total_read, buf.len());\n+                    let len = buf.len();\n+                    let slice = vec::mut_slice(*buf, start_len + total_read, len);\n                     match self.read(slice) {\n                         Some(nread) => {\n                             total_read += nread;"}, {"sha": "7b4764164b54c49f17ab1ebb73941055fc1b86dc", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -118,15 +118,6 @@ pub fn capacity<T>(v: &const ~[T]) -> uint {\n     }\n }\n \n-// A botch to tide us over until core and std are fully demuted.\n-#[allow(missing_doc)]\n-pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n-    unsafe {\n-        let v: &~[T] = transmute(v);\n-        as_const_buf(*v, |_p, len| len)\n-    }\n-}\n-\n /**\n  * Creates and initializes an owned vector.\n  *\n@@ -1767,19 +1758,32 @@ pub mod traits {\n     }\n }\n \n-impl<'self,T> Container for &'self const [T] {\n+impl<'self, T> Container for &'self const [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool {\n+    fn is_empty(&self) -> bool {\n         as_const_buf(*self, |_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n-    fn len(&const self) -> uint {\n+    fn len(&self) -> uint {\n         as_const_buf(*self, |_p, len| len)\n     }\n+}\n+\n+impl<T> Container for ~[T] {\n+    /// Returns true if a vector contains no elements\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        as_const_buf(*self, |_p, len| len == 0u)\n+    }\n \n+    /// Returns the length of a vector\n+    #[inline]\n+    fn len(&self) -> uint {\n+        as_const_buf(*self, |_p, len| len)\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -2615,23 +2619,6 @@ impl<A:Copy> old_iter::CopyableIter<A> for @[A] {\n     }\n }\n \n-impl<'self,A:Copy + Ord> old_iter::CopyableOrderedIter<A> for &'self [A] {\n-    fn min(&self) -> A { old_iter::min(self) }\n-    fn max(&self) -> A { old_iter::max(self) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A:Copy + Ord> old_iter::CopyableOrderedIter<A> for ~[A] {\n-    fn min(&self) -> A { old_iter::min(self) }\n-    fn max(&self) -> A { old_iter::max(self) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A:Copy + Ord> old_iter::CopyableOrderedIter<A> for @[A] {\n-    fn min(&self) -> A { old_iter::min(self) }\n-    fn max(&self) -> A { old_iter::max(self) }\n-}\n-\n impl<A:Clone> Clone for ~[A] {\n     #[inline]\n     fn clone(&self) -> ~[A] {"}, {"sha": "67e712f0596c9bddb89f3520392eff12d4ec8994", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -196,10 +196,3 @@ impl<A: Copy> old_iter::CopyableIter<A> for OptVec<A> {\n         old_iter::find(self, f)\n     }\n }\n-\n-impl<A: Copy+Ord> old_iter::CopyableOrderedIter<A> for OptVec<A> {\n-    #[inline(always)]\n-    fn min(&self) -> A { old_iter::min(self) }\n-    #[inline(always)]\n-    fn max(&self) -> A { old_iter::max(self) }\n-}"}, {"sha": "8c8b26afa08b117cf080487a43b4fca4a376837d", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "patch": "@@ -95,7 +95,8 @@ impl RepeatFasta {\n             let alu: &[u8] = self.alu.as_bytes();\n \n             copy_memory(buf, alu, alu_len);\n-            copy_memory(vec::mut_slice(buf, alu_len, buf.len()),\n+            let buf_len = buf.len();\n+            copy_memory(vec::mut_slice(buf, alu_len, buf_len),\n                         alu,\n                         LINE_LEN);\n "}]}