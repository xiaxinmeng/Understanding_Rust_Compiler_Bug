{"sha": "a79f5174ea1be8a90d7e02957ebbf7837916931b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3OWY1MTc0ZWExYmU4YTkwZDdlMDI5NTdlYmJmNzgzNzkxNjkzMWI=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-16T22:03:03Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T22:31:38Z"}, "message": "A parallel BFS.", "tree": {"sha": "fef9ae740dc41fe59c80caf03ebf645fd9ee26b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fef9ae740dc41fe59c80caf03ebf645fd9ee26b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a79f5174ea1be8a90d7e02957ebbf7837916931b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a79f5174ea1be8a90d7e02957ebbf7837916931b", "html_url": "https://github.com/rust-lang/rust/commit/a79f5174ea1be8a90d7e02957ebbf7837916931b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a79f5174ea1be8a90d7e02957ebbf7837916931b/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a785f3fc95752dc2cfced5e7ccef710e189acb9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a785f3fc95752dc2cfced5e7ccef710e189acb9c", "html_url": "https://github.com/rust-lang/rust/commit/a785f3fc95752dc2cfced5e7ccef710e189acb9c"}], "stats": {"total": 109, "additions": 103, "deletions": 6}, "files": [{"sha": "4feb47f1b3e13c53b9ac79bb7fe3f8c69851f242", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 103, "deletions": 6, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a79f5174ea1be8a90d7e02957ebbf7837916931b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79f5174ea1be8a90d7e02957ebbf7837916931b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a79f5174ea1be8a90d7e02957ebbf7837916931b", "patch": "@@ -16,7 +16,7 @@ import comm::*;\n import int::abs;\n \n type node_id = i64;\n-type graph = [map::set<node_id>];\n+type graph = [[node_id]];\n type bfs_result = [node_id];\n \n iface queue<T: send> {\n@@ -114,7 +114,15 @@ fn make_graph(N: uint, edges: [(node_id, node_id)]) -> graph {\n         true\n     }\n \n-    graph\n+    graph.map() {|v|\n+        let mut neighbors = [];\n+        v.each_key() {|u|\n+            neighbors += [u];\n+            true\n+        };\n+\n+        neighbors\n+    }\n }\n \n #[doc=\"Returns a vector of all the parents in the BFS tree rooted at key.\n@@ -132,7 +140,7 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     while Q.size() > 0u {\n         let t = Q.pop_front();\n \n-        graph[t].each_key() {|k| \n+        graph[t].each() {|k| \n             if marks[k] == -1 {\n                 marks[k] = t;\n                 Q.add_back(k);\n@@ -144,6 +152,75 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     vec::from_mut(marks)\n }\n \n+#[doc=\"A parallel version of the bfs function.\"]\n+fn pbfs(graph: graph, key: node_id) -> bfs_result {\n+    // This works by doing functional updates of a color vector.\n+\n+    enum color {\n+        white,\n+        // node_id marks which node turned this gray/black.\n+        // the node id later becomes the parent.\n+        gray(node_id),\n+        black(node_id)\n+    };\n+\n+    let mut colors = vec::from_fn(graph.len()) {|i|\n+        if i as node_id == key {\n+            gray(key)\n+        }\n+        else {\n+            white\n+        }\n+    };\n+\n+    fn is_gray(c: color) -> bool {\n+        alt c {\n+          gray(_) { true }\n+          _ { false }\n+        }\n+    }\n+\n+    let mut i = 0u;\n+    while par::any(colors, is_gray) {\n+        // Do the BFS.\n+        log(info, #fmt(\"PBFS iteration %?\", i));\n+        i += 1u;\n+        colors = par::mapi(colors) {|i, c, copy colors|\n+            let c : color = c;\n+            alt c {\n+              white {\n+                let i = i as node_id;\n+                \n+                let neighbors = graph[i];\n+                \n+                let mut color = white;\n+\n+                neighbors.each() {|k|\n+                    if is_gray(colors[k]) {\n+                        color = gray(k);\n+                        false\n+                    }\n+                    else { true }\n+                };\n+\n+                color\n+              }\n+              gray(parent) { black(parent) }\n+              black(parent) { black(parent) }\n+            }\n+        }\n+    }\n+\n+    // Convert the results.\n+    par::map(colors) {|c|\n+        alt c {\n+          white { -1 }\n+          black(parent) { parent }\n+          _ { fail \"Found remaining gray nodes in BFS\" }\n+        }\n+    }\n+}\n+\n #[doc=\"Performs at least some of the validation in the Graph500 spec.\"]\n fn validate(edges: [(node_id, node_id)], \n             root: node_id, tree: bfs_result) -> bool {\n@@ -252,7 +329,7 @@ fn main() {\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0u;\n-    vec::each(graph) {|edges| total_edges += edges.size(); true };\n+    vec::each(graph) {|edges| total_edges += edges.len(); true };\n \n     io::stdout().write_line(#fmt(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2u,\n@@ -261,7 +338,7 @@ fn main() {\n     let root = 0;\n     \n     let start = time::precise_time_s();\n-    let bfs_tree = bfs(graph, root);\n+    let bfs_tree = pbfs(graph, root);\n     let stop = time::precise_time_s();\n \n     io::stdout().write_line(#fmt(\"BFS completed in %? seconds.\",\n@@ -342,6 +419,7 @@ like map or alli.\"]\n fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n     let len = xs.len();\n     if len < min_granularity {\n+        log(info, \"small slice\");\n         // This is a small vector, fall back on the normal map.\n         [f(0u, xs)]\n     }\n@@ -352,6 +430,7 @@ fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n \n         let mut futures = [];\n         let mut base = 0u;\n+        log(info, \"spawning tasks\");\n         while base < len {\n             let slice = vec::slice(xs, base,\n                                    uint::min(len, base + items_per_task));\n@@ -360,6 +439,7 @@ fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n             }];\n             base += items_per_task;\n         }\n+        log(info, \"tasks spawned\");\n \n         futures.map() {|ys|\n             ys.get()\n@@ -370,7 +450,16 @@ fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n #[doc=\"A parallel version of map.\"]\n fn map<A: send, B: send>(xs: [A], f: fn~(A) -> B) -> [B] {\n     vec::concat(map_slices(xs) {|_base, slice|\n-        map(slice, f)\n+        vec::map(slice, f)\n+    })\n+}\n+\n+#[doc=\"A parallel version of mapi.\"]\n+fn mapi<A: send, B: send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n+    vec::concat(map_slices(xs) {|base, slice|\n+        slice.mapi() {|i, x|\n+            f(i + base, x)\n+        }\n     })\n }\n \n@@ -382,4 +471,12 @@ fn alli<A: send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n         }\n     }) {|x| x }\n }\n+\n+    #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n+    fn any<A: send>(xs: [A], f: fn~(A) -> bool) -> bool {\n+        vec::any(map_slices(xs) {|_base, slice|\n+            slice.any(f)\n+        }) {|x| x }\n+    }\n+\n }\n\\ No newline at end of file"}]}