{"sha": "7ae95e548929f4924905b2e8f87f2dd57d8bc887", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZTk1ZTU0ODkyOWY0OTI0OTA1YjJlOGY4N2YyZGQ1N2Q4YmM4ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-30T14:20:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-30T14:20:20Z"}, "message": "Auto merge of #40224 - nikomatsakis:issue-39808, r=eddyb\n\nchange the strategy for diverging types\n\nThe new strategy is as follows. First, the `!` type is assigned\nin two cases:\n\n- a block with a diverging statement and no tail expression (e.g.,\n  `{return;}`);\n- any expression with the type `!` is considered diverging.\n\nSecond, we track when we are in a diverging state, and we permit a value\nof any type to be coerced **into** `!` if the expression that produced\nit is diverging. This means that `fn foo() -> ! { panic!(); 22 }`\ntype-checks, even though the block has a type of `usize`.\n\nFinally, coercions **from** the `!` type to any other are always\npermitted.\n\nFixes #39808.\nFixes #39984.", "tree": {"sha": "aceb2641992bb0d995e317bb38e119a6ad13710d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aceb2641992bb0d995e317bb38e119a6ad13710d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ae95e548929f4924905b2e8f87f2dd57d8bc887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae95e548929f4924905b2e8f87f2dd57d8bc887", "html_url": "https://github.com/rust-lang/rust/commit/7ae95e548929f4924905b2e8f87f2dd57d8bc887", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ae95e548929f4924905b2e8f87f2dd57d8bc887/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe151194e9a919ab23c2bb356767a5cbfa3811e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe151194e9a919ab23c2bb356767a5cbfa3811e7", "html_url": "https://github.com/rust-lang/rust/commit/fe151194e9a919ab23c2bb356767a5cbfa3811e7"}, {"sha": "2414222b17f45e33d68582dd5ebe0083ed27b8cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2414222b17f45e33d68582dd5ebe0083ed27b8cc", "html_url": "https://github.com/rust-lang/rust/commit/2414222b17f45e33d68582dd5ebe0083ed27b8cc"}], "stats": {"total": 5025, "additions": 2433, "deletions": 2592}, "files": [{"sha": "20b322ec189511bde830fb8ecb8ae0f45cd278e4", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -74,11 +74,11 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n-        if let Some(break_to_expr_id) = blk.break_to_expr_id {\n+        if blk.targeted_by_break {\n             let expr_exit = self.add_ast_node(blk.id, &[]);\n \n             self.breakable_block_scopes.push(BlockScope {\n-                block_expr_id: break_to_expr_id,\n+                block_expr_id: blk.id,\n                 break_index: expr_exit,\n             });\n \n@@ -195,7 +195,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //   [..expr..]\n                 //\n                 let cond_exit = self.expr(&cond, pred);                // 1\n-                let then_exit = self.block(&then, cond_exit);          // 2\n+                let then_exit = self.expr(&then, cond_exit);          // 2\n                 self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n             }\n \n@@ -215,7 +215,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //   [..expr..]\n                 //\n                 let cond_exit = self.expr(&cond, pred);                // 1\n-                let then_exit = self.block(&then, cond_exit);          // 2\n+                let then_exit = self.expr(&then, cond_exit);          // 2\n                 let else_exit = self.expr(&otherwise, cond_exit);      // 3\n                 self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n             }"}, {"sha": "c7ad143c94979762f7ac060dc2be4ba9e91a865a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -960,7 +960,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         }\n         ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);\n-            visitor.visit_block(if_block);\n+            visitor.visit_expr(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n         ExprWhile(ref subexpression, ref block, ref opt_sp_name) => {"}, {"sha": "17185a6ab69f493399e327afc94c8504c5f84a11", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1156,7 +1156,7 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, break_to: Option<NodeId>) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n         let mut expr = None;\n \n         let mut stmts = vec![];\n@@ -1179,7 +1179,7 @@ impl<'a> LoweringContext<'a> {\n             expr: expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n-            break_to_expr_id: break_to,\n+            targeted_by_break: targeted_by_break,\n         })\n     }\n \n@@ -1274,7 +1274,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 self.with_new_scopes(|this| {\n-                    let body = this.lower_block(body, None);\n+                    let body = this.lower_block(body, false);\n                     let body = this.expr_block(body, ThinVec::new());\n                     let body_id = this.record_body(body, Some(decl));\n                     hir::ItemFn(this.lower_fn_decl(decl),\n@@ -1368,7 +1368,7 @@ impl<'a> LoweringContext<'a> {\n                                                    hir::TraitMethod::Required(names))\n                     }\n                     TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                        let body = this.lower_block(body, None);\n+                        let body = this.lower_block(body, false);\n                         let expr = this.expr_block(body, ThinVec::new());\n                         let body_id = this.record_body(expr, Some(&sig.decl));\n                         hir::TraitItemKind::Method(this.lower_method_sig(sig),\n@@ -1424,7 +1424,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n-                        let body = this.lower_block(body, None);\n+                        let body = this.lower_block(body, false);\n                         let expr = this.expr_block(body, ThinVec::new());\n                         let body_id = this.record_body(expr, Some(&sig.decl));\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n@@ -1848,32 +1848,35 @@ impl<'a> LoweringContext<'a> {\n                                 id: id,\n                                 rules: hir::DefaultBlock,\n                                 span: span,\n-                                break_to_expr_id: None,\n+                                targeted_by_break: false,\n                             });\n                             P(self.expr_block(blk, ThinVec::new()))\n                         }\n                         _ => P(self.lower_expr(els)),\n                     }\n                 });\n \n-                hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk, None), else_opt)\n+                let then_blk = self.lower_block(blk, false);\n+                let then_expr = self.expr_block(then_blk, ThinVec::new());\n+\n+                hir::ExprIf(P(self.lower_expr(cond)), P(then_expr), else_opt)\n             }\n             ExprKind::While(ref cond, ref body, opt_ident) => {\n                 self.with_loop_scope(e.id, |this|\n                     hir::ExprWhile(\n                         this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n-                        this.lower_block(body, None),\n+                        this.lower_block(body, false),\n                         this.lower_opt_sp_ident(opt_ident)))\n             }\n             ExprKind::Loop(ref body, opt_ident) => {\n                 self.with_loop_scope(e.id, |this|\n-                    hir::ExprLoop(this.lower_block(body, None),\n+                    hir::ExprLoop(this.lower_block(body, false),\n                                   this.lower_opt_sp_ident(opt_ident),\n                                   hir::LoopSource::Loop))\n             }\n             ExprKind::Catch(ref body) => {\n-                self.with_catch_scope(e.id, |this|\n-                    hir::ExprBlock(this.lower_block(body, Some(e.id))))\n+                self.with_catch_scope(body.id, |this|\n+                    hir::ExprBlock(this.lower_block(body, true)))\n             }\n             ExprKind::Match(ref expr, ref arms) => {\n                 hir::ExprMatch(P(self.lower_expr(expr)),\n@@ -1891,7 +1894,7 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 })\n             }\n-            ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk, None)),\n+            ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk, false)),\n             ExprKind::Assign(ref el, ref er) => {\n                 hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n@@ -2037,7 +2040,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // `<pat> => <body>`\n                 {\n-                    let body = self.lower_block(body, None);\n+                    let body = self.lower_block(body, false);\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n                     let pat = self.lower_pat(pat);\n                     arms.push(self.arm(hir_vec![pat], body_expr));\n@@ -2109,7 +2112,7 @@ impl<'a> LoweringContext<'a> {\n                             let (guard, body) = if let ExprKind::If(ref cond,\n                                                                     ref then,\n                                                                     _) = else_expr.node {\n-                                let then = self.lower_block(then, None);\n+                                let then = self.lower_block(then, false);\n                                 (Some(cond),\n                                  self.expr_block(then, ThinVec::new()))\n                             } else {\n@@ -2159,7 +2162,7 @@ impl<'a> LoweringContext<'a> {\n                 // Note that the block AND the condition are evaluated in the loop scope.\n                 // This is done to allow `break` from inside the condition of the loop.\n                 let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| (\n-                    this.lower_block(body, None),\n+                    this.lower_block(body, false),\n                     this.expr_break(e.span, ThinVec::new()),\n                     this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n                 ));\n@@ -2220,7 +2223,7 @@ impl<'a> LoweringContext<'a> {\n                 // `::std::option::Option::Some(<pat>) => <body>`\n                 let pat_arm = {\n                     let body_block = self.with_loop_scope(e.id,\n-                                                          |this| this.lower_block(body, None));\n+                                                          |this| this.lower_block(body, false));\n                     let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                     let pat = self.lower_pat(pat);\n                     let some_pat = self.pat_some(e.span, pat);\n@@ -2652,7 +2655,7 @@ impl<'a> LoweringContext<'a> {\n             id: self.next_id(),\n             rules: hir::DefaultBlock,\n             span: span,\n-            break_to_expr_id: None,\n+            targeted_by_break: false,\n         }\n     }\n \n@@ -2760,7 +2763,7 @@ impl<'a> LoweringContext<'a> {\n             id: id,\n             stmts: stmts,\n             expr: Some(expr),\n-            break_to_expr_id: None,\n+            targeted_by_break: false,\n         });\n         self.expr_block(block, attrs)\n     }"}, {"sha": "d5000ac9c18669a3940bbea0a4629eaa6645d614", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -549,9 +549,11 @@ pub struct Block {\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n-    /// The id of the expression that `break` breaks to if the block can be broken out of.\n-    /// Currently only `Some(_)` for `catch {}` blocks\n-    pub break_to_expr_id: Option<NodeId>,\n+    /// If true, then there may exist `break 'a` values that aim to\n+    /// break out of this block early. As of this writing, this is not\n+    /// currently permitted in Rust itself, but it is generated as\n+    /// part of `catch` statements.\n+    pub targeted_by_break: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n@@ -993,8 +995,8 @@ pub enum Expr_ {\n     ExprType(P<Expr>, P<Ty>),\n     /// An `if` block, with an optional else block\n     ///\n-    /// `if expr { block } else { expr }`\n-    ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    /// `if expr { expr } else { expr }`\n+    ExprIf(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`"}, {"sha": "04a65fd5e3aa47c0a748993578135da24124bf5b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1036,7 +1036,7 @@ impl<'a> State<'a> {\n                         word(&mut self.s, \" else if \")?;\n                         self.print_expr(&i)?;\n                         space(&mut self.s)?;\n-                        self.print_block(&then)?;\n+                        self.print_expr(&then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n@@ -1058,13 +1058,13 @@ impl<'a> State<'a> {\n \n     pub fn print_if(&mut self,\n                     test: &hir::Expr,\n-                    blk: &hir::Block,\n+                    blk: &hir::Expr,\n                     elseopt: Option<&hir::Expr>)\n                     -> io::Result<()> {\n         self.head(\"if\")?;\n         self.print_expr(test)?;\n         space(&mut self.s)?;\n-        self.print_block(blk)?;\n+        self.print_expr(blk)?;\n         self.print_else(elseopt)\n     }\n "}, {"sha": "67f37e5f9272e85c058beb616995a89dbd92b227", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -30,6 +30,7 @@ pub struct TypeVariableTable<'tcx> {\n }\n \n /// Reasons to create a type inference variable\n+#[derive(Debug)]\n pub enum TypeVariableOrigin {\n     MiscVariable(Span),\n     NormalizeProjectionType(Span),\n@@ -41,6 +42,7 @@ pub enum TypeVariableOrigin {\n     AdjustmentType(Span),\n     DivergingStmt(Span),\n     DivergingBlockExpr(Span),\n+    DivergingFn(Span),\n     LatticeVariable(Span),\n }\n \n@@ -196,14 +198,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                    diverging: bool,\n                    origin: TypeVariableOrigin,\n                    default: Option<Default<'tcx>>,) -> ty::TyVid {\n+        debug!(\"new_var(diverging={:?}, origin={:?})\", diverging, origin);\n         self.eq_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n             value: Bounded { relations: vec![], default: default },\n             origin: origin,\n             diverging: diverging\n         });\n         let v = ty::TyVid { index: index as u32 };\n-        debug!(\"new_var() -> {:?}\", v);\n+        debug!(\"new_var: diverging={:?} index={:?}\", diverging, v);\n         v\n     }\n "}, {"sha": "c7cf4a35a4bc780a6f16b45b65325945409af24e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -414,9 +414,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n+            hir::ExprIf(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n                 self.consume_expr(&cond_expr);\n-                self.walk_block(&then_blk);\n+                self.walk_expr(&then_expr);\n                 if let Some(ref else_expr) = *opt_else_expr {\n                     self.consume_expr(&else_expr);\n                 }"}, {"sha": "7cae08efc0de057a14815832c82db859f5c907c7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -821,8 +821,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n-        if let Some(break_to_expr_id) = blk.break_to_expr_id {\n-            self.breakable_block_ln.insert(break_to_expr_id, succ);\n+        if blk.targeted_by_break {\n+            self.breakable_block_ln.insert(blk.id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n@@ -951,7 +951,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             //   (  succ  )\n             //\n             let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n-            let then_ln = self.propagate_through_block(&then, succ);\n+            let then_ln = self.propagate_through_expr(&then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);"}, {"sha": "152dd6ac3000f71f8b6beb69a5525b64350cd3ff", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -904,6 +904,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::StartFunctionType |\n             ObligationCauseCode::IntrinsicType |\n             ObligationCauseCode::MethodReceiver |\n+            ObligationCauseCode::ReturnNoExpression |\n             ObligationCauseCode::MiscObligation => {\n             }\n             ObligationCauseCode::SliceOrArrayElem => {"}, {"sha": "47cbccdd2ab107ef673483a8e201cf88ead77ce4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -173,6 +173,9 @@ pub enum ObligationCauseCode<'tcx> {\n \n     // method receiver\n     MethodReceiver,\n+\n+    // `return` with no expression\n+    ReturnNoExpression,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "44ef461327ddbf868837dd5b2b00559a3af4528e", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -167,6 +167,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n     type Lifted = traits::ObligationCauseCode<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n+            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n             super::MiscObligation => Some(super::MiscObligation),\n             super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n             super::TupleElem => Some(super::TupleElem),\n@@ -489,6 +490,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::StructInitializerSized |\n             super::VariableType(_) |\n             super::ReturnType |\n+            super::ReturnNoExpression |\n             super::RepeatVec |\n             super::FieldSized |\n             super::ConstSized |\n@@ -533,6 +535,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::StructInitializerSized |\n             super::VariableType(_) |\n             super::ReturnType |\n+            super::ReturnNoExpression |\n             super::RepeatVec |\n             super::FieldSized |\n             super::ConstSized |"}, {"sha": "7739766182cfa3ef7f2f045e90f443365a54052f", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 98, "deletions": 72, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -12,90 +12,116 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n use rustc::mir::*;\n use rustc::hir;\n+use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Lvalue<'tcx>,\n-                     mut block: BasicBlock,\n-                     ast_block: &'tcx hir::Block)\n+                     block: BasicBlock,\n+                     ast_block: &'tcx hir::Block,\n+                     source_info: SourceInfo)\n                      -> BlockAnd<()> {\n-        let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n+        let Block { extent, span, stmts, expr, targeted_by_break } = self.hir.mirror(ast_block);\n         self.in_scope(extent, block, move |this| {\n-            // This convoluted structure is to avoid using recursion as we walk down a list\n-            // of statements. Basically, the structure we get back is something like:\n-            //\n-            //    let x = <init> in {\n-            //       expr1;\n-            //       let y = <init> in {\n-            //           expr2;\n-            //           expr3;\n-            //           ...\n-            //       }\n-            //    }\n-            //\n-            // The let bindings are valid till the end of block so all we have to do is to pop all\n-            // the let-scopes at the end.\n-            //\n-            // First we build all the statements in the block.\n-            let mut let_extent_stack = Vec::with_capacity(8);\n-            let outer_visibility_scope = this.visibility_scope;\n-            for stmt in stmts {\n-                let Stmt { span: _, kind } = this.hir.mirror(stmt);\n-                match kind {\n-                    StmtKind::Expr { scope, expr } => {\n-                        unpack!(block = this.in_scope(scope, block, |this| {\n-                            let expr = this.hir.mirror(expr);\n-                            this.stmt_expr(block, expr)\n-                        }));\n-                    }\n-                    StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                        let tcx = this.hir.tcx();\n+            if targeted_by_break {\n+                // This is a `break`-able block (currently only `catch { ... }`)\n+                let exit_block = this.cfg.start_new_block();\n+                let block_exit = this.in_breakable_scope(None, exit_block,\n+                                                         destination.clone(), |this| {\n+                    this.ast_block_stmts(destination, block, span, stmts, expr)\n+                });\n+                this.cfg.terminate(unpack!(block_exit), source_info,\n+                                   TerminatorKind::Goto { target: exit_block });\n+                exit_block.unit()\n+            } else {\n+                this.ast_block_stmts(destination, block, span, stmts, expr)\n+            }\n+        })\n+    }\n \n-                        // Enter the remainder scope, i.e. the bindings' destruction scope.\n-                        this.push_scope(remainder_scope);\n-                        let_extent_stack.push(remainder_scope);\n+    fn ast_block_stmts(&mut self,\n+                       destination: &Lvalue<'tcx>,\n+                       mut block: BasicBlock,\n+                       span: Span,\n+                       stmts: Vec<StmtRef<'tcx>>,\n+                       expr: Option<ExprRef<'tcx>>)\n+                       -> BlockAnd<()> {\n+        let this = self;\n+\n+        // This convoluted structure is to avoid using recursion as we walk down a list\n+        // of statements. Basically, the structure we get back is something like:\n+        //\n+        //    let x = <init> in {\n+        //       expr1;\n+        //       let y = <init> in {\n+        //           expr2;\n+        //           expr3;\n+        //           ...\n+        //       }\n+        //    }\n+        //\n+        // The let bindings are valid till the end of block so all we have to do is to pop all\n+        // the let-scopes at the end.\n+        //\n+        // First we build all the statements in the block.\n+        let mut let_extent_stack = Vec::with_capacity(8);\n+        let outer_visibility_scope = this.visibility_scope;\n+        for stmt in stmts {\n+            let Stmt { span: _, kind } = this.hir.mirror(stmt);\n+            match kind {\n+                StmtKind::Expr { scope, expr } => {\n+                    unpack!(block = this.in_scope(scope, block, |this| {\n+                        let expr = this.hir.mirror(expr);\n+                        this.stmt_expr(block, expr)\n+                    }));\n+                }\n+                StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n+                    let tcx = this.hir.tcx();\n \n-                        // Declare the bindings, which may create a visibility scope.\n-                        let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.hir);\n-                        let remainder_span = remainder_span.unwrap_or(span);\n-                        let scope = this.declare_bindings(None, remainder_span, &pattern);\n+                    // Enter the remainder scope, i.e. the bindings' destruction scope.\n+                    this.push_scope(remainder_scope);\n+                    let_extent_stack.push(remainder_scope);\n \n-                        // Evaluate the initializer, if present.\n-                        if let Some(init) = initializer {\n-                            unpack!(block = this.in_scope(init_scope, block, move |this| {\n-                                // FIXME #30046                              ^~~~\n-                                this.expr_into_pattern(block, pattern, init)\n-                            }));\n-                        } else {\n-                            this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n-                                this.storage_live_binding(block, node, span);\n-                                this.schedule_drop_for_binding(node, span);\n-                            })\n-                        }\n+                    // Declare the bindings, which may create a visibility scope.\n+                    let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.hir);\n+                    let remainder_span = remainder_span.unwrap_or(span);\n+                    let scope = this.declare_bindings(None, remainder_span, &pattern);\n \n-                        // Enter the visibility scope, after evaluating the initializer.\n-                        if let Some(visibility_scope) = scope {\n-                            this.visibility_scope = visibility_scope;\n-                        }\n+                    // Evaluate the initializer, if present.\n+                    if let Some(init) = initializer {\n+                        unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                            // FIXME #30046                              ^~~~\n+                            this.expr_into_pattern(block, pattern, init)\n+                        }));\n+                    } else {\n+                        this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n+                            this.storage_live_binding(block, node, span);\n+                            this.schedule_drop_for_binding(node, span);\n+                        })\n+                    }\n+\n+                    // Enter the visibility scope, after evaluating the initializer.\n+                    if let Some(visibility_scope) = scope {\n+                        this.visibility_scope = visibility_scope;\n                     }\n                 }\n             }\n-            // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n-            // of the block.\n-            if let Some(expr) = expr {\n-                unpack!(block = this.into(destination, block, expr));\n-            } else {\n-                let source_info = this.source_info(span);\n-                this.cfg.push_assign_unit(block, source_info, destination);\n-            }\n-            // Finally, we pop all the let scopes before exiting out from the scope of block\n-            // itself.\n-            for extent in let_extent_stack.into_iter().rev() {\n-                unpack!(block = this.pop_scope(extent, block));\n-            }\n-            // Restore the original visibility scope.\n-            this.visibility_scope = outer_visibility_scope;\n-            block.unit()\n-        })\n+        }\n+        // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n+        // of the block.\n+        if let Some(expr) = expr {\n+            unpack!(block = this.into(destination, block, expr));\n+        } else {\n+            let source_info = this.source_info(span);\n+            this.cfg.push_assign_unit(block, source_info, destination);\n+        }\n+        // Finally, we pop all the let scopes before exiting out from the scope of block\n+        // itself.\n+        for extent in let_extent_stack.into_iter().rev() {\n+            unpack!(block = this.pop_scope(extent, block));\n+        }\n+        // Restore the original visibility scope.\n+        this.visibility_scope = outer_visibility_scope;\n+        block.unit()\n     }\n }"}, {"sha": "a5a114c61bcf6afd46fbb882f7aaef6ce18301bb", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -40,19 +40,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.in_scope(extent, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n-                if let Some(_) = ast_block.break_to_expr_id {\n-                    // This is a `break`-able block (currently only `catch { ... }`)\n-                    let exit_block = this.cfg.start_new_block();\n-                    let block_exit = this.in_breakable_scope(None, exit_block,\n-                                                             destination.clone(), |this| {\n-                        this.ast_block(destination, block, ast_block)\n-                    });\n-                    this.cfg.terminate(unpack!(block_exit), source_info,\n-                                       TerminatorKind::Goto { target: exit_block });\n-                    exit_block.unit()\n-                } else {\n-                    this.ast_block(destination, block, ast_block)\n-                }\n+                this.ast_block(destination, block, ast_block, source_info)\n             }\n             ExprKind::Match { discriminant, arms } => {\n                 this.match_expr(destination, expr_span, block, discriminant, arms)"}, {"sha": "d2465331df353c9db0c0ebbd28892fee34339b71", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -23,6 +23,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n         Block {\n+            targeted_by_break: self.targeted_by_break,\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,"}, {"sha": "d9b8d04ad386ff6e98833472b4cadfa2212b40ad", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -636,7 +636,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprIf(ref cond, ref then, ref otherwise) => {\n             ExprKind::If {\n                 condition: cond.to_ref(),\n-                then: block::to_expr_ref(cx, then),\n+                then: then.to_ref(),\n                 otherwise: otherwise.to_ref(),\n             }\n         }"}, {"sha": "a3982efd2d695b6e50fdae1af2bd582f21f0f506", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -31,6 +31,7 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n \n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n+    pub targeted_by_break: bool,\n     pub extent: CodeExtent,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,"}, {"sha": "453f65eb762f86522f32de212f788662469f9a28", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -369,7 +369,7 @@ impl FnType {\n             match sig.inputs().last().unwrap().sty {\n                 ty::TyTuple(ref tupled_arguments, _) => {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    &tupled_arguments\n+                    tupled_arguments\n                 }\n                 _ => {\n                     bug!(\"argument to function with \\\"rust-call\\\" ABI \\"}, {"sha": "4a04464244442a2763b3c9124dc7074b35d31adc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -16,6 +16,7 @@ use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation, Diverges};\n+use check::coercion::CoerceMany;\n use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -414,6 +415,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type(discrim, discrim_ty);\n         };\n+\n+        // If the discriminant diverges, the match is pointless (e.g.,\n+        // `match (return) { }`).\n+        self.warn_if_unreachable(expr.id, expr.span, \"expression\");\n+\n+        // If there are no arms, that is a diverging match; a special case.\n+        if arms.is_empty() {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+            return tcx.types.never;\n+        }\n+\n+        // Otherwise, we have to union together the types that the\n+        // arms produce and so forth.\n+\n         let discrim_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n@@ -426,6 +441,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_pat(&p, discrim_ty);\n                 all_pats_diverge &= self.diverges.get();\n             }\n+\n             // As discussed with @eddyb, this is for disabling unreachable_code\n             // warnings on patterns (they're now subsumed by unreachable_patterns\n             // warnings).\n@@ -444,20 +460,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // on any empty type and is therefore unreachable; should the flow\n         // of execution reach it, we will panic, so bottom is an appropriate\n         // type in that case)\n-        let expected = expected.adjust_for_branches(self);\n-        let mut result_ty = self.next_diverging_ty_var(\n-            TypeVariableOrigin::DivergingBlockExpr(expr.span));\n         let mut all_arms_diverge = Diverges::WarnedAlways;\n-        let coerce_first = match expected {\n-            // We don't coerce to `()` so that if the match expression is a\n-            // statement it's branches can have any consistent type. That allows\n-            // us to give better error messages (pointing to a usually better\n-            // arm for inconsistent arms or to the whole match when a `()` type\n-            // is required).\n-            Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => {\n-                ety\n-            }\n-            _ => result_ty\n+\n+        let expected = expected.adjust_for_branches(self);\n+\n+        let mut coercion = {\n+            let coerce_first = match expected {\n+                // We don't coerce to `()` so that if the match expression is a\n+                // statement it's branches can have any consistent type. That allows\n+                // us to give better error messages (pointing to a usually better\n+                // arm for inconsistent arms or to the whole match when a `()` type\n+                // is required).\n+                Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n+                _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n+            };\n+            CoerceMany::with_coercion_sites(coerce_first, arms)\n         };\n \n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n@@ -470,11 +487,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            if result_ty.references_error() || arm_ty.references_error() {\n-                result_ty = tcx.types.err;\n-                continue;\n-            }\n-\n             // Handle the fallback arm of a desugared if-let like a missing else.\n             let is_if_let_fallback = match match_src {\n                 hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n@@ -483,47 +495,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => false\n             };\n \n-            let cause = if is_if_let_fallback {\n-                self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse)\n+            if is_if_let_fallback {\n+                let cause = self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse);\n+                assert!(arm_ty.is_nil());\n+                coercion.coerce_forced_unit(self, &cause, &mut |_| ());\n             } else {\n-                self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n+                let cause = self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n                     arm_span: arm.body.span,\n                     source: match_src\n-                })\n-            };\n-\n-            let result = if is_if_let_fallback {\n-                self.eq_types(true, &cause, arm_ty, result_ty)\n-                    .map(|infer_ok| {\n-                        self.register_infer_ok_obligations(infer_ok);\n-                        arm_ty\n-                    })\n-            } else if i == 0 {\n-                // Special-case the first arm, as it has no \"previous expressions\".\n-                self.try_coerce(&arm.body, arm_ty, coerce_first)\n-            } else {\n-                let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-                self.try_find_coercion_lub(&cause, prev_arms, result_ty, &arm.body, arm_ty)\n-            };\n-\n-            result_ty = match result {\n-                Ok(ty) => ty,\n-                Err(e) => {\n-                    let (expected, found) = if is_if_let_fallback {\n-                        (arm_ty, result_ty)\n-                    } else {\n-                        (result_ty, arm_ty)\n-                    };\n-                    self.report_mismatched_types(&cause, expected, found, e).emit();\n-                    self.tcx.types.err\n-                }\n-            };\n+                });\n+                coercion.coerce(self, &cause, &arm.body, arm_ty, self.diverges.get());\n+            }\n         }\n \n         // We won't diverge unless the discriminant or all arms diverge.\n         self.diverges.set(discrim_diverges | all_arms_diverge);\n \n-        result_ty\n+        coercion.complete(self)\n     }\n \n     fn check_pat_struct(&self,"}, {"sha": "647adbbb82f2d02dc5f1becda4c5c0c657e8df8c", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -12,6 +12,7 @@ use astconv::AstConv;\n \n use super::FnCtxt;\n \n+use check::coercion::AsCoercionSite;\n use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n@@ -148,16 +149,16 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n     }\n \n-    pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n-        where I: IntoIterator<Item = &'b hir::Expr>\n+    pub fn finalize<E>(self, pref: LvaluePreference, exprs: &[E])\n+        where E: AsCoercionSite\n     {\n         let fcx = self.fcx;\n         fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, exprs));\n     }\n \n-    pub fn finalize_as_infer_ok<'b, I>(self, pref: LvaluePreference, exprs: I)\n-                                       -> InferOk<'tcx, ()>\n-        where I: IntoIterator<Item = &'b hir::Expr>\n+    pub fn finalize_as_infer_ok<E>(self, pref: LvaluePreference, exprs: &[E])\n+                                   -> InferOk<'tcx, ()>\n+        where E: AsCoercionSite\n     {\n         let methods: Vec<_> = self.steps\n             .iter()\n@@ -176,6 +177,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                self.obligations);\n \n         for expr in exprs {\n+            let expr = expr.as_coercion_site();\n             debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n             for (n, method) in methods.iter().enumerate() {\n                 if let &Some(method) = method {"}, {"sha": "f9bc947a973584a270acb9e82cc3ea7c9be60447", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             })\n             .next();\n         let callee_ty = autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, Some(callee_expr));\n+        autoderef.finalize(LvaluePreference::NoPreference, &[callee_expr]);\n \n         let output = match result {\n             None => {"}, {"sha": "32b363ed755f4cca5860c4f333b11db273e72386", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -38,7 +38,7 @@\n //! expression, `e as U2` is not necessarily so (in fact it will only be valid if\n //! `U1` coerces to `U2`).\n \n-use super::FnCtxt;\n+use super::{Diverges, FnCtxt};\n \n use lint;\n use hir::def_id::DefId;\n@@ -56,6 +56,7 @@ use util::common::ErrorReported;\n pub struct CastCheck<'tcx> {\n     expr: &'tcx hir::Expr,\n     expr_ty: Ty<'tcx>,\n+    expr_diverges: Diverges,\n     cast_ty: Ty<'tcx>,\n     cast_span: Span,\n     span: Span,\n@@ -115,13 +116,15 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     pub fn new(fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                expr: &'tcx hir::Expr,\n                expr_ty: Ty<'tcx>,\n+               expr_diverges: Diverges,\n                cast_ty: Ty<'tcx>,\n                cast_span: Span,\n                span: Span)\n                -> Result<CastCheck<'tcx>, ErrorReported> {\n         let check = CastCheck {\n             expr: expr,\n             expr_ty: expr_ty,\n+            expr_diverges: expr_diverges,\n             cast_ty: cast_ty,\n             cast_span: cast_span,\n             span: span,\n@@ -376,7 +379,10 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (None, Some(t_cast)) => {\n                 if let ty::TyFnDef(.., f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n-                    let res = fcx.try_coerce(self.expr, self.expr_ty, fcx.tcx.mk_fn_ptr(f));\n+                    let res = fcx.try_coerce(self.expr,\n+                                             self.expr_ty,\n+                                             self.expr_diverges,\n+                                             fcx.tcx.mk_fn_ptr(f));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -542,7 +548,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty).is_ok()\n+        fcx.try_coerce(self.expr, self.expr_ty, self.expr_diverges, self.cast_ty).is_ok()\n     }\n }\n "}, {"sha": "a5acd0c7e530047368f0d2abdd4ce89e59532ee7", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 411, "deletions": 37, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::FnCtxt;\n+use check::{Diverges, FnCtxt};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -74,8 +74,10 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n+use errors::DiagnosticBuilder;\n use syntax::abi;\n use syntax::feature_gate;\n+use syntax::ptr::P;\n \n use std::collections::VecDeque;\n use std::ops::Deref;\n@@ -155,11 +157,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item = &'a hir::Expr>\n+    fn coerce<E>(&self,\n+                 exprs: &[E],\n+                 a: Ty<'tcx>,\n+                 b: Ty<'tcx>)\n+                 -> CoerceResult<'tcx>\n+        where E: AsCoercionSite\n     {\n-\n         let a = self.shallow_resolve(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n@@ -169,7 +173,23 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         if a.is_never() {\n-            return success(Adjust::NeverToAny, b, vec![]);\n+            // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n+            // type variable, we want `?T` to fallback to `!` if not\n+            // otherwise constrained. An example where this arises:\n+            //\n+            //     let _: Option<?T> = Some({ return; });\n+            //\n+            // here, we would coerce from `!` to `?T`.\n+            let b = self.shallow_resolve(b);\n+            return if self.shallow_resolve(b).is_ty_var() {\n+                // micro-optimization: no need for this if `b` is\n+                // already resolved in some way.\n+                let diverging_ty = self.next_diverging_ty_var(\n+                    TypeVariableOrigin::AdjustmentType(self.cause.span));\n+                self.unify_and(&b, &diverging_ty, Adjust::NeverToAny)\n+            } else {\n+                success(Adjust::NeverToAny, b, vec![])\n+            };\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -223,15 +243,14 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_borrowed_pointer<'a, E, I>(&self,\n-                                         exprs: &E,\n-                                         a: Ty<'tcx>,\n-                                         b: Ty<'tcx>,\n-                                         r_b: &'tcx ty::Region,\n-                                         mt_b: TypeAndMut<'tcx>)\n-                                         -> CoerceResult<'tcx>\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item = &'a hir::Expr>\n+    fn coerce_borrowed_pointer<E>(&self,\n+                                  exprs: &[E],\n+                                  a: Ty<'tcx>,\n+                                  b: Ty<'tcx>,\n+                                  r_b: &'tcx ty::Region,\n+                                  mt_b: TypeAndMut<'tcx>)\n+                                  -> CoerceResult<'tcx>\n+        where E: AsCoercionSite\n     {\n \n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n@@ -408,7 +427,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                autoref);\n \n         let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n-        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs()).obligations);\n+        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs).obligations);\n \n         success(Adjust::DerefRef {\n             autoderefs: autoderefs,\n@@ -675,47 +694,66 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_coerce(&self,\n                       expr: &hir::Expr,\n                       expr_ty: Ty<'tcx>,\n+                      expr_diverges: Diverges,\n                       target: Ty<'tcx>)\n                       -> RelateResult<'tcx, Ty<'tcx>> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n+        // Special-ish case: we can coerce any type `T` into the `!`\n+        // type, but only if the source expression diverges.\n+        if target.is_never() && expr_diverges.always() {\n+            debug!(\"permit coercion to `!` because expr diverges\");\n+            return Ok(target);\n+        }\n+\n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n-            let ok = coerce.coerce(&|| Some(expr), source, target)?;\n+            let ok = coerce.coerce(&[expr], source, target)?;\n             let adjustment = self.register_infer_ok_obligations(ok);\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n-                match self.tables.borrow().adjustments.get(&expr.id) {\n-                    None |\n-                    Some(&Adjustment { kind: Adjust::NeverToAny, .. }) => (),\n-                    _ => bug!(\"expr already has an adjustment on it!\"),\n-                };\n+                if self.tables.borrow().adjustments.get(&expr.id).is_some() {\n+                    bug!(\"expr already has an adjustment on it!\");\n+                }\n                 self.write_adjustment(expr.id, adjustment);\n             }\n-            Ok(adjustment.target)\n+\n+            // We should now have added sufficient adjustments etc to\n+            // ensure that the type of expression, post-adjustment, is\n+            // a subtype of target.\n+            Ok(target)\n         })\n     }\n \n     /// Given some expressions, their known unified type and another expression,\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\").\n-    pub fn try_find_coercion_lub<'b, E, I>(&self,\n-                                           cause: &ObligationCause<'tcx>,\n-                                           exprs: E,\n-                                           prev_ty: Ty<'tcx>,\n-                                           new: &'b hir::Expr,\n-                                           new_ty: Ty<'tcx>)\n-                                           -> RelateResult<'tcx, Ty<'tcx>>\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item = &'b hir::Expr>\n+    ///\n+    /// This is really an internal helper. From outside the coercion\n+    /// module, you should instantiate a `CoerceMany` instance.\n+    fn try_find_coercion_lub<E>(&self,\n+                                cause: &ObligationCause<'tcx>,\n+                                exprs: &[E],\n+                                prev_ty: Ty<'tcx>,\n+                                new: &hir::Expr,\n+                                new_ty: Ty<'tcx>,\n+                                new_diverges: Diverges)\n+                                -> RelateResult<'tcx, Ty<'tcx>>\n+        where E: AsCoercionSite\n     {\n-\n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n+        // Special-ish case: we can coerce any type `T` into the `!`\n+        // type, but only if the source expression diverges.\n+        if prev_ty.is_never() && new_diverges.always() {\n+            debug!(\"permit coercion to `!` because expr diverges\");\n+            return Ok(prev_ty);\n+        }\n+\n         let trace = TypeTrace::types(cause, true, prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n@@ -741,7 +779,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // Reify both sides and return the reified fn pointer type.\n                 let fn_ptr = self.tcx.mk_fn_ptr(fty);\n-                for expr in exprs().into_iter().chain(Some(new)) {\n+                for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n                     // No adjustments can produce a fn item, so this should never trip.\n                     assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n                     self.write_adjustment(expr.id, Adjustment {\n@@ -761,7 +799,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| coerce.coerce(&|| Some(new), new_ty, prev_ty));\n+            let result = self.commit_if_ok(|_| coerce.coerce(&[new], new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n                     let adjustment = self.register_infer_ok_obligations(ok);\n@@ -777,7 +815,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Then try to coerce the previous expressions to the type of the new one.\n         // This requires ensuring there are no coercions applied to *any* of the\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n-        for expr in exprs() {\n+        for expr in exprs {\n+            let expr = expr.as_coercion_site();\n             let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| adj.kind) {\n                 Some(Adjust::DerefRef {\n                     autoderefs: 1,\n@@ -821,7 +860,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let adjustment = self.register_infer_ok_obligations(ok);\n                 if !adjustment.is_identity() {\n                     let mut tables = self.tables.borrow_mut();\n-                    for expr in exprs() {\n+                    for expr in exprs {\n+                        let expr = expr.as_coercion_site();\n                         if let Some(&mut Adjustment {\n                             kind: Adjust::NeverToAny,\n                             ref mut target\n@@ -837,3 +877,337 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n }\n+\n+/// CoerceMany encapsulates the pattern you should use when you have\n+/// many expressions that are all getting coerced to a common\n+/// type. This arises, for example, when you have a match (the result\n+/// of each arm is coerced to a common type). It also arises in less\n+/// obvious places, such as when you have many `break foo` expressions\n+/// that target the same loop, or the various `return` expressions in\n+/// a function.\n+///\n+/// The basic protocol is as follows:\n+///\n+/// - Instantiate the `CoerceMany` with an initial `expected_ty`.\n+///   This will also serve as the \"starting LUB\". The expectation is\n+///   that this type is something which all of the expressions *must*\n+///   be coercible to. Use a fresh type variable if needed.\n+/// - For each expression whose result is to be coerced, invoke `coerce()` with.\n+///   - In some cases we wish to coerce \"non-expressions\" whose types are implicitly\n+///     unit. This happens for example if you have a `break` with no expression,\n+///     or an `if` with no `else`. In that case, invoke `coerce_forced_unit()`.\n+///   - `coerce()` and `coerce_forced_unit()` may report errors. They hide this\n+///     from you so that you don't have to worry your pretty head about it.\n+///     But if an error is reported, the final type will be `err`.\n+///   - Invoking `coerce()` may cause us to go and adjust the \"adjustments\" on\n+///     previously coerced expressions.\n+/// - When all done, invoke `complete()`. This will return the LUB of\n+///   all your expressions.\n+///   - WARNING: I don't believe this final type is guaranteed to be\n+///     related to your initial `expected_ty` in any particular way,\n+///     although it will typically be a subtype, so you should check it.\n+///   - Invoking `complete()` may cause us to go and adjust the \"adjustments\" on\n+///     previously coerced expressions.\n+///\n+/// Example:\n+///\n+/// ```\n+/// let mut coerce = CoerceMany::new(expected_ty);\n+/// for expr in exprs {\n+///     let expr_ty = fcx.check_expr_with_expectation(expr, expected);\n+///     coerce.coerce(fcx, &cause, expr, expr_ty);\n+/// }\n+/// let final_ty = coerce.complete(fcx);\n+/// ```\n+pub struct CoerceMany<'gcx, 'tcx, 'exprs, E>\n+    where 'gcx: 'tcx, E: 'exprs + AsCoercionSite,\n+{\n+    expected_ty: Ty<'tcx>,\n+    final_ty: Option<Ty<'tcx>>,\n+    expressions: Expressions<'gcx, 'exprs, E>,\n+    pushed: usize,\n+}\n+\n+/// The type of a `CoerceMany` that is storing up the expressions into\n+/// a buffer. We use this in `check/mod.rs` for things like `break`.\n+pub type DynamicCoerceMany<'gcx, 'tcx> = CoerceMany<'gcx, 'tcx, 'gcx, P<hir::Expr>>;\n+\n+enum Expressions<'gcx, 'exprs, E>\n+    where E: 'exprs + AsCoercionSite,\n+{\n+    Dynamic(Vec<&'gcx hir::Expr>),\n+    UpFront(&'exprs [E]),\n+}\n+\n+impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n+    where 'gcx: 'tcx, E: 'exprs + AsCoercionSite,\n+{\n+    /// The usual case; collect the set of expressions dynamically.\n+    /// If the full set of coercion sites is known before hand,\n+    /// consider `with_coercion_sites()` instead to avoid allocation.\n+    pub fn new(expected_ty: Ty<'tcx>) -> Self {\n+        Self::make(expected_ty, Expressions::Dynamic(vec![]))\n+    }\n+\n+    /// As an optimization, you can create a `CoerceMany` with a\n+    /// pre-existing slice of expressions. In this case, you are\n+    /// expected to pass each element in the slice to `coerce(...)` in\n+    /// order. This is used with arrays in particular to avoid\n+    /// needlessly cloning the slice.\n+    pub fn with_coercion_sites(expected_ty: Ty<'tcx>,\n+                               coercion_sites: &'exprs [E])\n+                      -> Self {\n+        Self::make(expected_ty, Expressions::UpFront(coercion_sites))\n+    }\n+\n+    fn make(expected_ty: Ty<'tcx>, expressions: Expressions<'gcx, 'exprs, E>) -> Self {\n+        CoerceMany {\n+            expected_ty,\n+            final_ty: None,\n+            expressions,\n+            pushed: 0,\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.pushed == 0\n+    }\n+\n+    /// Return the \"expected type\" with which this coercion was\n+    /// constructed.  This represents the \"downward propagated\" type\n+    /// that was given to us at the start of typing whatever construct\n+    /// we are typing (e.g., the match expression).\n+    ///\n+    /// Typically, this is used as the expected type when\n+    /// type-checking each of the alternative expressions whose types\n+    /// we are trying to merge.\n+    pub fn expected_ty(&self) -> Ty<'tcx> {\n+        self.expected_ty\n+    }\n+\n+    /// Returns the current \"merged type\", representing our best-guess\n+    /// at the LUB of the expressions we've seen so far (if any). This\n+    /// isn't *final* until you call `self.final()`, which will return\n+    /// the merged type.\n+    pub fn merged_ty(&self) -> Ty<'tcx> {\n+        self.final_ty.unwrap_or(self.expected_ty)\n+    }\n+\n+    /// Indicates that the value generated by `expression`, which is\n+    /// of type `expression_ty`, is one of the possibility that we\n+    /// could coerce from. This will record `expression` and later\n+    /// calls to `coerce` may come back and add adjustments and things\n+    /// if necessary.\n+    pub fn coerce<'a>(&mut self,\n+                      fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+                      cause: &ObligationCause<'tcx>,\n+                      expression: &'gcx hir::Expr,\n+                      expression_ty: Ty<'tcx>,\n+                      expression_diverges: Diverges)\n+    {\n+        self.coerce_inner(fcx, cause, Some(expression), expression_ty, expression_diverges, None)\n+    }\n+\n+    /// Indicates that one of the inputs is a \"forced unit\". This\n+    /// occurs in a case like `if foo { ... };`, where the issing else\n+    /// generates a \"forced unit\". Another example is a `loop { break;\n+    /// }`, where the `break` has no argument expression. We treat\n+    /// these cases slightly differently for error-reporting\n+    /// purposes. Note that these tend to correspond to cases where\n+    /// the `()` expression is implicit in the source, and hence we do\n+    /// not take an expression argument.\n+    ///\n+    /// The `augment_error` gives you a chance to extend the error\n+    /// message, in case any results (e.g., we use this to suggest\n+    /// removing a `;`).\n+    pub fn coerce_forced_unit<'a>(&mut self,\n+                                  fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+                                  cause: &ObligationCause<'tcx>,\n+                                  augment_error: &mut FnMut(&mut DiagnosticBuilder))\n+    {\n+        self.coerce_inner(fcx,\n+                          cause,\n+                          None,\n+                          fcx.tcx.mk_nil(),\n+                          Diverges::Maybe,\n+                          Some(augment_error))\n+    }\n+\n+    /// The inner coercion \"engine\". If `expression` is `None`, this\n+    /// is a forced-unit case, and hence `expression_ty` must be\n+    /// `Nil`.\n+    fn coerce_inner<'a>(&mut self,\n+                        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+                        cause: &ObligationCause<'tcx>,\n+                        expression: Option<&'gcx hir::Expr>,\n+                        mut expression_ty: Ty<'tcx>,\n+                        expression_diverges: Diverges,\n+                        augment_error: Option<&mut FnMut(&mut DiagnosticBuilder)>)\n+    {\n+        // Incorporate whatever type inference information we have\n+        // until now; in principle we might also want to process\n+        // pending obligations, but doing so should only improve\n+        // compatibility (hopefully that is true) by helping us\n+        // uncover never types better.\n+        if expression_ty.is_ty_var() {\n+            expression_ty = fcx.infcx.shallow_resolve(expression_ty);\n+        }\n+\n+        // If we see any error types, just propagate that error\n+        // upwards.\n+        if expression_ty.references_error() || self.merged_ty().references_error() {\n+            self.final_ty = Some(fcx.tcx.types.err);\n+            return;\n+        }\n+\n+        // Handle the actual type unification etc.\n+        let result = if let Some(expression) = expression {\n+            if self.pushed == 0 {\n+                // Special-case the first expression we are coercing.\n+                // To be honest, I'm not entirely sure why we do this.\n+                fcx.try_coerce(expression, expression_ty, expression_diverges, self.expected_ty)\n+            } else {\n+                match self.expressions {\n+                    Expressions::Dynamic(ref exprs) =>\n+                        fcx.try_find_coercion_lub(cause,\n+                                                  exprs,\n+                                                  self.merged_ty(),\n+                                                  expression,\n+                                                  expression_ty,\n+                                                  expression_diverges),\n+                    Expressions::UpFront(ref coercion_sites) =>\n+                        fcx.try_find_coercion_lub(cause,\n+                                                  &coercion_sites[0..self.pushed],\n+                                                  self.merged_ty(),\n+                                                  expression,\n+                                                  expression_ty,\n+                                                  expression_diverges),\n+                }\n+            }\n+        } else {\n+            // this is a hack for cases where we default to `()` because\n+            // the expression etc has been omitted from the source. An\n+            // example is an `if let` without an else:\n+            //\n+            //     if let Some(x) = ... { }\n+            //\n+            // we wind up with a second match arm that is like `_ =>\n+            // ()`.  That is the case we are considering here. We take\n+            // a different path to get the right \"expected, found\"\n+            // message and so forth (and because we know that\n+            // `expression_ty` will be unit).\n+            //\n+            // Another example is `break` with no argument expression.\n+            assert!(expression_ty.is_nil());\n+            assert!(expression_ty.is_nil(), \"if let hack without unit type\");\n+            fcx.eq_types(true, cause, expression_ty, self.merged_ty())\n+               .map(|infer_ok| {\n+                   fcx.register_infer_ok_obligations(infer_ok);\n+                   expression_ty\n+               })\n+        };\n+\n+        match result {\n+            Ok(v) => {\n+                self.final_ty = Some(v);\n+                if let Some(e) = expression {\n+                    match self.expressions {\n+                        Expressions::Dynamic(ref mut buffer) => buffer.push(e),\n+                        Expressions::UpFront(coercion_sites) => {\n+                            // if the user gave us an array to validate, check that we got\n+                            // the next expression in the list, as expected\n+                            assert_eq!(coercion_sites[self.pushed].as_coercion_site().id, e.id);\n+                        }\n+                    }\n+                    self.pushed += 1;\n+                }\n+            }\n+            Err(err) => {\n+                let (expected, found) = if expression.is_none() {\n+                    // In the case where this is a \"forced unit\", like\n+                    // `break`, we want to call the `()` \"expected\"\n+                    // since it is implied by the syntax.\n+                    assert!(expression_ty.is_nil());\n+                    (expression_ty, self.final_ty.unwrap_or(self.expected_ty))\n+                } else {\n+                    // Otherwise, the \"expected\" type for error\n+                    // reporting is the current unification type,\n+                    // which is basically the LUB of the expressions\n+                    // we've seen so far (combined with the expected\n+                    // type)\n+                    (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n+                };\n+\n+                let mut db;\n+                match cause.code {\n+                    ObligationCauseCode::ReturnNoExpression => {\n+                        db = struct_span_err!(\n+                            fcx.tcx.sess, cause.span, E0069,\n+                            \"`return;` in a function whose return type is not `()`\");\n+                        db.span_label(cause.span, &format!(\"return type is not ()\"));\n+                    }\n+                    _ => {\n+                        db = fcx.report_mismatched_types(cause, expected, found, err);\n+                    }\n+                }\n+\n+                if let Some(mut augment_error) = augment_error {\n+                    augment_error(&mut db);\n+                }\n+\n+                db.emit();\n+\n+                self.final_ty = Some(fcx.tcx.types.err);\n+            }\n+        }\n+    }\n+\n+    pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        if let Some(final_ty) = self.final_ty {\n+            final_ty\n+        } else {\n+            // If we only had inputs that were of type `!` (or no\n+            // inputs at all), then the final type is `!`.\n+            assert_eq!(self.pushed, 0);\n+            fcx.tcx.types.never\n+        }\n+    }\n+}\n+\n+/// Something that can be converted into an expression to which we can\n+/// apply a coercion.\n+pub trait AsCoercionSite {\n+    fn as_coercion_site(&self) -> &hir::Expr;\n+}\n+\n+impl AsCoercionSite for hir::Expr {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        self\n+    }\n+}\n+\n+impl AsCoercionSite for P<hir::Expr> {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        self\n+    }\n+}\n+\n+impl<'a, T> AsCoercionSite for &'a T\n+    where T: AsCoercionSite\n+{\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        (**self).as_coercion_site()\n+    }\n+}\n+\n+impl AsCoercionSite for ! {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        unreachable!()\n+    }\n+}\n+\n+impl AsCoercionSite for hir::Arm {\n+    fn as_coercion_site(&self) -> &hir::Expr {\n+        &self.body\n+    }\n+}"}, {"sha": "905d8688ea194a42e7d431bb417924950084b858", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -362,7 +362,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 &infcx.parameter_environment.caller_bounds);\n             infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n         } else {\n-            let fcx = FnCtxt::new(&inh, Some(tcx.types.err), impl_m_body_id);\n+            let fcx = FnCtxt::new(&inh, impl_m_body_id);\n             fcx.regionck_item(impl_m_body_id, impl_m_span, &[]);\n         }\n "}, {"sha": "e922c7447ff85384ceb3b9822e9f9058482ec33d", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -67,9 +67,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Checks that the type of `expr` can be coerced to `expected`.\n-    pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n+    //\n+    // NB: This code relies on `self.diverges` to be accurate.  In\n+    // particular, assignments to `!` will be permitted if the\n+    // diverges flag is currently \"always\".\n+    pub fn demand_coerce(&self,\n+                         expr: &hir::Expr,\n+                         checked_ty: Ty<'tcx>,\n+                         expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n-        if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n+\n+        if let Err(e) = self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n             let mode = probe::Mode::MethodCall;"}, {"sha": "73f6cd76290aa0a82fb9f835a16ece2d778dbaf7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         assert_eq!(n, pick.autoderefs);\n \n         autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n+        autoderef.finalize(LvaluePreference::NoPreference, &[self.self_expr]);\n \n         let target = pick.unsize.unwrap_or(autoderefd_ty);\n         let target = target.adjust_for_autoref(self.tcx, autoref);\n@@ -444,7 +444,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                       \"expr was deref-able {} times but now isn't?\",\n                                       autoderefs);\n                         });\n-                        autoderef.finalize(PreferMutLvalue, Some(expr));\n+                        autoderef.finalize(PreferMutLvalue, &[expr]);\n                     }\n                 }\n                 Some(_) | None => {}"}, {"sha": "aaa3cf0f29e74c389bc2f5a65235b505a348dbd5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 429, "deletions": 368, "changes": 797, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -77,6 +77,7 @@ type parameter).\n */\n \n pub use self::Expectation::*;\n+use self::coercion::{CoerceMany, DynamicCoerceMany};\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n@@ -85,7 +86,8 @@ use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin, TypeTrace};\n+use rustc_back::slice::ref_slice;\n+use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::type_variable::{self, TypeVariableOrigin};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n@@ -97,6 +99,7 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n+use errors::DiagnosticBuilder;\n use require_c_abi_if_variadic;\n use session::{Session, CompileResult};\n use TypeAndSubsts;\n@@ -299,12 +302,23 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n+    /// It sometimes happens that we want to turn an expectation into\n+    /// a **hard constraint** (i.e., something that must be satisfied\n+    /// for the program to type-check). `only_has_type` will return\n+    /// such a constraint, if it exists.\n     fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n             _ => None\n         }\n     }\n+\n+    /// Like `only_has_type`, but instead of returning `None` if no\n+    /// hard constraint exists, creates a fresh type variable.\n+    fn coercion_target_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, span: Span) -> Ty<'tcx> {\n+        self.only_has_type(fcx)\n+            .unwrap_or_else(|| fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span)))\n+    }\n }\n \n #[derive(Copy, Clone)]\n@@ -348,12 +362,13 @@ impl UnsafetyState {\n     }\n }\n \n-/// Whether a node ever exits normally or not.\n-/// Tracked semi-automatically (through type variables\n-/// marked as diverging), with some manual adjustments\n-/// for control-flow primitives (approximating a CFG).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-enum Diverges {\n+/// Tracks whether executing a node may exit normally (versus\n+/// return/break/panic, which \"diverge\", leaving dead code in their\n+/// wake). Tracked semi-automatically (through type variables marked\n+/// as diverging), with some manual adjustments for control-flow\n+/// primitives (approximating a CFG).\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum Diverges {\n     /// Potentially unknown, some cases converge,\n     /// others require a CFG to determine them.\n     Maybe,\n@@ -401,34 +416,28 @@ impl Diverges {\n     }\n }\n \n-#[derive(Clone)]\n-pub struct BreakableCtxt<'gcx, 'tcx> {\n-    unified: Ty<'tcx>,\n-    coerce_to: Ty<'tcx>,\n-    break_exprs: Vec<&'gcx hir::Expr>,\n+pub struct BreakableCtxt<'gcx: 'tcx, 'tcx> {\n     may_break: bool,\n+\n+    // this is `null` for loops where break with a value is illegal,\n+    // such as `while`, `for`, and `while let`\n+    coerce: Option<DynamicCoerceMany<'gcx, 'tcx>>,\n }\n \n-#[derive(Clone)]\n-pub struct EnclosingBreakables<'gcx, 'tcx> {\n+pub struct EnclosingBreakables<'gcx: 'tcx, 'tcx> {\n     stack: Vec<BreakableCtxt<'gcx, 'tcx>>,\n     by_id: NodeMap<usize>,\n }\n \n impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n-    fn find_breakable(&mut self, target: hir::ScopeTarget)\n-        -> Option<&mut BreakableCtxt<'gcx, 'tcx>>\n-    {\n-        let opt_index = target.opt_id().and_then(|id| self.by_id.get(&id).cloned());\n-        if let Some(ix) = opt_index {\n-            Some(&mut self.stack[ix])\n-        } else {\n-            None\n-        }\n+    fn find_breakable(&mut self, target_id: ast::NodeId) -> &mut BreakableCtxt<'gcx, 'tcx> {\n+        let ix = *self.by_id.get(&target_id).unwrap_or_else(|| {\n+            bug!(\"could not find enclosing breakable with id {}\", target_id);\n+        });\n+        &mut self.stack[ix]\n     }\n }\n \n-#[derive(Clone)]\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n \n@@ -440,11 +449,49 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // expects the types within the function to be consistent.\n     err_count_on_creation: usize,\n \n-    ret_ty: Option<Ty<'tcx>>,\n+    ret_coercion: Option<RefCell<DynamicCoerceMany<'gcx, 'tcx>>>,\n \n     ps: RefCell<UnsafetyState>,\n \n-    /// Whether the last checked node can ever exit.\n+    /// Whether the last checked node generates a divergence (e.g.,\n+    /// `return` will set this to Always). In general, when entering\n+    /// an expression or other node in the tree, the initial value\n+    /// indicates whether prior parts of the containing expression may\n+    /// have diverged. It is then typically set to `Maybe` (and the\n+    /// old value remembered) for processing the subparts of the\n+    /// current expression. As each subpart is processed, they may set\n+    /// the flag to `Always` etc.  Finally, at the end, we take the\n+    /// result and \"union\" it with the original value, so that when we\n+    /// return the flag indicates if any subpart of the the parent\n+    /// expression (up to and including this part) has diverged.  So,\n+    /// if you read it after evaluating a subexpression `X`, the value\n+    /// you get indicates whether any subexpression that was\n+    /// evaluating up to and including `X` diverged.\n+    ///\n+    /// We use this flag for two purposes:\n+    ///\n+    /// - To warn about unreachable code: if, after processing a\n+    ///   sub-expression but before we have applied the effects of the\n+    ///   current node, we see that the flag is set to `Always`, we\n+    ///   can issue a warning. This corresponds to something like\n+    ///   `foo(return)`; we warn on the `foo()` expression. (We then\n+    ///   update the flag to `WarnedAlways` to suppress duplicate\n+    ///   reports.) Similarly, if we traverse to a fresh statement (or\n+    ///   tail expression) from a `Always` setting, we will isssue a\n+    ///   warning. This corresponds to something like `{return;\n+    ///   foo();}` or `{return; 22}`, where we would warn on the\n+    ///   `foo()` or `22`.\n+    ///\n+    /// - To permit assignment into a local variable or other lvalue\n+    ///   (including the \"return slot\") of type `!`.  This is allowed\n+    ///   if **either** the type of value being assigned is `!`, which\n+    ///   means the current code is dead, **or** the expression's\n+    ///   divering flag is true, which means that a divering value was\n+    ///   wrapped (e.g., `let x: ! = foo(return)`).\n+    ///\n+    /// To repeat the last point: an expression represents dead-code\n+    /// if, after checking it, **either** its type is `!` OR the\n+    /// diverges flag is set to something other than `Maybe`.\n     diverges: Cell<Diverges>,\n \n     /// Whether any child nodes have any type errors.\n@@ -671,7 +718,7 @@ fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             check_fn(&inh, fn_sig, decl, id, body)\n         } else {\n-            let fcx = FnCtxt::new(&inh, None, body.value.id);\n+            let fcx = FnCtxt::new(&inh, body.value.id);\n             let expected_type = tcx.item_type(def_id);\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n@@ -792,15 +839,16 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, None, body.value.id);\n-    let ret_ty = fn_sig.output();\n+    let mut fcx = FnCtxt::new(inherited, body.value.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n+    let ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n-    fcx.ret_ty = fcx.instantiate_anon_types(&Some(ret_ty));\n+    let ret_ty = fcx.instantiate_anon_types(&ret_ty);\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n-        fcx.ret_ty.unwrap(),\n+        ret_ty,\n         fn_sig.variadic,\n         fn_sig.unsafety,\n         fn_sig.abi\n@@ -825,7 +873,38 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n-    fcx.check_expr_coercable_to_type(&body.value, fcx.ret_ty.unwrap());\n+    fcx.check_return_expr(&body.value);\n+\n+    // Finalize the return check by taking the LUB of the return types\n+    // we saw and assigning it to the expected return type. This isn't\n+    // really expected to fail, since the coercions would have failed\n+    // earlier when trying to find a LUB.\n+    //\n+    // However, the behavior around `!` is sort of complex. In the\n+    // event that the `actual_return_ty` comes back as `!`, that\n+    // indicates that the fn either does not return or \"returns\" only\n+    // values of type `!`. In this case, if there is an expected\n+    // return type that is *not* `!`, that should be ok. But if the\n+    // return type is being inferred, we want to \"fallback\" to `!`:\n+    //\n+    //     let x = move || panic!();\n+    //\n+    // To allow for that, I am creating a type variable with diverging\n+    // fallback. This was deemed ever so slightly better than unifying\n+    // the return value with `!` because it allows for the caller to\n+    // make more assumptions about the return type (e.g., they could do\n+    //\n+    //     let y: Option<u32> = Some(x());\n+    //\n+    // which would then cause this return type to become `u32`, not\n+    // `!`).\n+    let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n+    let mut actual_return_ty = coercion.complete(&fcx);\n+    if actual_return_ty.is_never() {\n+        actual_return_ty = fcx.next_diverging_ty_var(\n+            TypeVariableOrigin::DivergingFn(body.value.span));\n+    }\n+    fcx.demand_suptype(body.value.span, ret_ty, actual_return_ty);\n \n     fcx\n }\n@@ -1421,14 +1500,13 @@ enum TupleArgumentsFlag {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n-               rty: Option<Ty<'tcx>>,\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n             body_id: body_id,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n-            ret_ty: rty,\n+            ret_coercion: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n                                                      ast::CRATE_NODE_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n@@ -1455,6 +1533,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if self.diverges.get() == Diverges::Always {\n             self.diverges.set(Diverges::WarnedAlways);\n \n+            debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n+\n             self.tables.borrow_mut().lints.add_lint(\n                 lint::builtin::UNREACHABLE_CODE,\n                 id, span,\n@@ -1537,18 +1617,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n-               node_id, ty, self.tag());\n+               node_id, self.resolve_type_vars_if_possible(&ty), self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n             self.set_tainted_by_errors();\n         }\n-\n-        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-        if ty.is_never() || self.type_var_diverges(ty) {\n-            self.diverges.set(self.diverges.get() | Diverges::Always);\n-        }\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -2177,12 +2252,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 expr, base_expr, adj_ty, autoderefs,\n                 false, lvalue_pref, idx_ty)\n             {\n-                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                autoderef.finalize(lvalue_pref, &[base_expr]);\n                 return Some(final_mt);\n             }\n \n             if let ty::TyArray(element_ty, _) = adj_ty.sty {\n-                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                autoderef.finalize(lvalue_pref, &[base_expr]);\n                 let adjusted_ty = self.tcx.mk_slice(element_ty);\n                 return self.try_index_step(\n                     MethodCall::expr(expr.id), expr, base_expr,\n@@ -2479,8 +2554,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Expectation::rvalue_hint(self, ty)\n                 });\n \n-                let checked_ty = self.check_expr_with_expectation(&arg,\n-                                        expected.unwrap_or(ExpectHasType(formal_ty)));\n+                let checked_ty = self.check_expr_with_expectation(\n+                    &arg,\n+                    expected.unwrap_or(ExpectHasType(formal_ty)));\n+\n                 // 2. Coerce to the most detailed type that could be coerced\n                 //    to, which is `expected_ty` if `rvalue_hint` returns an\n                 //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n@@ -2599,7 +2676,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_expr_has_type(&self,\n                                expr: &'gcx hir::Expr,\n                                expected: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.check_expr_with_hint(expr, expected);\n+        let mut ty = self.check_expr_with_hint(expr, expected);\n+\n+        // While we don't allow *arbitrary* coercions here, we *do* allow\n+        // coercions from ! to `expected`.\n+        if ty.is_never() {\n+            assert!(!self.tables.borrow().adjustments.contains_key(&expr.id),\n+                    \"expression with never type wound up being adjusted\");\n+            let adj_ty = self.next_diverging_ty_var(\n+                TypeVariableOrigin::AdjustmentType(expr.span));\n+            self.write_adjustment(expr.id, adjustment::Adjustment {\n+                kind: adjustment::Adjust::NeverToAny,\n+                target: adj_ty\n+            });\n+            ty = adj_ty;\n+        }\n+\n         self.demand_suptype(expr.span, expected, ty);\n         ty\n     }\n@@ -2735,11 +2827,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ret_ty\n     }\n \n+    fn check_return_expr(&self, return_expr: &'gcx hir::Expr) {\n+        let ret_coercion =\n+            self.ret_coercion\n+                .as_ref()\n+                .unwrap_or_else(|| span_bug!(return_expr.span,\n+                                             \"check_return_expr called outside fn body\"));\n+\n+        let ret_ty = ret_coercion.borrow().expected_ty();\n+        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty);\n+        ret_coercion.borrow_mut()\n+                    .coerce(self,\n+                            &self.misc(return_expr.span),\n+                            return_expr,\n+                            return_expr_ty,\n+                            self.diverges.get());\n+    }\n+\n+\n     // A generic function for checking the then and else in an if\n     // or if-else.\n     fn check_then_else(&self,\n                        cond_expr: &'gcx hir::Expr,\n-                       then_blk: &'gcx hir::Block,\n+                       then_expr: &'gcx hir::Expr,\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n@@ -2748,71 +2858,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n \n         let expected = expected.adjust_for_branches(self);\n-        let then_ty = self.check_block_with_expected(then_blk, expected);\n+        let then_ty = self.check_expr_with_expectation(then_expr, expected);\n         let then_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n-        let unit = self.tcx.mk_nil();\n-        let (cause, expected_ty, found_ty, result);\n+        // We've already taken the expected type's preferences\n+        // into account when typing the `then` branch. To figure\n+        // out the initial shot at a LUB, we thus only consider\n+        // `expected` if it represents a *hard* constraint\n+        // (`only_has_type`); otherwise, we just go with a\n+        // fresh type variable.\n+        let coerce_to_ty = expected.coercion_target_type(self, sp);\n+        let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n+\n+        let if_cause = self.cause(sp, ObligationCauseCode::IfExpression);\n+        coerce.coerce(self, &if_cause, then_expr, then_ty, then_diverges);\n+\n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n-            cause = self.cause(sp, ObligationCauseCode::IfExpression);\n-\n-            // Only try to coerce-unify if we have a then expression\n-            // to assign coercions to, otherwise it's () or diverging.\n-            expected_ty = then_ty;\n-            found_ty = else_ty;\n-            result = if let Some(ref then) = then_blk.expr {\n-                let res = self.try_find_coercion_lub(&cause, || Some(&**then),\n-                                                     then_ty, else_expr, else_ty);\n-\n-                // In case we did perform an adjustment, we have to update\n-                // the type of the block, because old trans still uses it.\n-                if res.is_ok() {\n-                    let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n-                    if let Some(adj) = adj {\n-                        self.write_ty(then_blk.id, adj.target);\n-                    }\n-                }\n \n-                res\n-            } else {\n-                self.commit_if_ok(|_| {\n-                    let trace = TypeTrace::types(&cause, true, then_ty, else_ty);\n-                    self.lub(true, trace, &then_ty, &else_ty)\n-                        .map(|ok| self.register_infer_ok_obligations(ok))\n-                })\n-            };\n+            coerce.coerce(self, &if_cause, else_expr, else_ty, else_diverges);\n \n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n         } else {\n+            let else_cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n+            coerce.coerce_forced_unit(self, &else_cause, &mut |_| ());\n+\n             // If the condition is false we can't diverge.\n             self.diverges.set(cond_diverges);\n-\n-            cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n-            expected_ty = unit;\n-            found_ty = then_ty;\n-            result = self.eq_types(true, &cause, unit, then_ty)\n-                         .map(|ok| {\n-                             self.register_infer_ok_obligations(ok);\n-                             unit\n-                         });\n         }\n \n-        match result {\n-            Ok(ty) => {\n-                if cond_ty.references_error() {\n-                    self.tcx.types.err\n-                } else {\n-                    ty\n-                }\n-            }\n-            Err(e) => {\n-                self.report_mismatched_types(&cause, expected_ty, found_ty, e).emit();\n-                self.tcx.types.err\n-            }\n+        let result_ty = coerce.complete(self);\n+        if cond_ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            result_ty\n         }\n     }\n \n@@ -2834,7 +2916,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n-                            autoderef.finalize(lvalue_pref, Some(base));\n+                            autoderef.finalize(lvalue_pref, &[base]);\n                             self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n@@ -2958,7 +3040,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                autoderef.finalize(lvalue_pref, Some(base));\n+                autoderef.finalize(lvalue_pref, &[base]);\n                 self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n@@ -3299,6 +3381,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n         }\n \n+        // Any expression that produces a value of type `!` must have diverged\n+        if ty.is_never() {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+        }\n+\n         // Record the type, which applies it effects.\n         // We need to do this after the warning above, so that\n         // we don't warn for the diverging expression itself.\n@@ -3311,18 +3398,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"type of {} is...\", self.tcx.hir.node_to_string(expr.id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n-        // Add adjustments to !-expressions\n-        if ty.is_never() {\n-            if let Some(hir::map::NodeExpr(node_expr)) = self.tcx.hir.find(expr.id) {\n-                let adj_ty = self.next_diverging_ty_var(\n-                    TypeVariableOrigin::AdjustmentType(node_expr.span));\n-                self.write_adjustment(expr.id, adjustment::Adjustment {\n-                    kind: adjustment::Adjust::NeverToAny,\n-                    target: adj_ty\n-                });\n-                return adj_ty;\n-            }\n-        }\n         ty\n     }\n \n@@ -3485,81 +3560,82 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_nil()\n           }\n           hir::ExprBreak(destination, ref expr_opt) => {\n-            let coerce_to = {\n-                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                enclosing_breakables\n-                    .find_breakable(destination.target_id).map(|ctxt| ctxt.coerce_to)\n-            };\n-            if let Some(coerce_to) = coerce_to {\n-                let e_ty;\n-                let cause;\n-                if let Some(ref e) = *expr_opt {\n-                    // Recurse without `enclosing_loops` borrowed.\n-                    e_ty = self.check_expr_with_hint(e, coerce_to);\n-                    cause = self.misc(e.span);\n-                    // Notably, the recursive call may alter coerce_to - must not keep using it!\n-                } else {\n-                    // `break` without argument acts like `break ()`.\n-                    e_ty = tcx.mk_nil();\n-                    cause = self.misc(expr.span);\n-                }\n-\n-                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                let ctxt = enclosing_breakables.find_breakable(destination.target_id).unwrap();\n+              if let Some(target_id) = destination.target_id.opt_id() {\n+                  let (e_ty, e_diverges, cause);\n+                  if let Some(ref e) = *expr_opt {\n+                      // If this is a break with a value, we need to type-check\n+                      // the expression. Get an expected type from the loop context.\n+                      let opt_coerce_to = {\n+                          let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                          enclosing_breakables.find_breakable(target_id)\n+                                              .coerce\n+                                              .as_ref()\n+                                              .map(|coerce| coerce.expected_ty())\n+                      };\n+\n+                      // If the loop context is not a `loop { }`, then break with\n+                      // a value is illegal, and `opt_coerce_to` will be `None`.\n+                      // Just set expectation to error in that case.\n+                      let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+\n+                      // Recurse without `enclosing_breakables` borrowed.\n+                      e_ty = self.check_expr_with_hint(e, coerce_to);\n+                      e_diverges = self.diverges.get();\n+                      cause = self.misc(e.span);\n+                  } else {\n+                      // Otherwise, this is a break *without* a value. That's\n+                      // always legal, and is equivalent to `break ()`.\n+                      e_ty = tcx.mk_nil();\n+                      e_diverges = Diverges::Maybe;\n+                      cause = self.misc(expr.span);\n+                  }\n \n-                let result = if let Some(ref e) = *expr_opt {\n-                    // Special-case the first element, as it has no \"previous expressions\".\n-                    let result = if !ctxt.may_break {\n-                        self.try_coerce(e, e_ty, ctxt.coerce_to)\n-                    } else {\n-                        self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n-                                                   ctxt.unified, e, e_ty)\n-                    };\n+                  // Now that we have type-checked `expr_opt`, borrow\n+                  // the `enclosing_loops` field and let's coerce the\n+                  // type of `expr_opt` into what is expected.\n+                  let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                  let ctxt = enclosing_breakables.find_breakable(target_id);\n+                  if let Some(ref mut coerce) = ctxt.coerce {\n+                      if let Some(ref e) = *expr_opt {\n+                          coerce.coerce(self, &cause, e, e_ty, e_diverges);\n+                      } else {\n+                          assert!(e_ty.is_nil());\n+                          coerce.coerce_forced_unit(self, &cause, &mut |_| ());\n+                      }\n+                  } else {\n+                      // If `ctxt.coerce` is `None`, we can just ignore\n+                      // the type of the expresison.  This is because\n+                      // either this was a break *without* a value, in\n+                      // which case it is always a legal type (`()`), or\n+                      // else an error would have been flagged by the\n+                      // `loops` pass for using break with an expression\n+                      // where you are not supposed to.\n+                      assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+                  }\n \n-                    ctxt.break_exprs.push(e);\n-                    result\n-                } else {\n-                    self.eq_types(true, &cause, e_ty, ctxt.unified)\n-                        .map(|InferOk { obligations, .. }| {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n-                            e_ty\n-                        })\n-                };\n-                match result {\n-                    Ok(ty) => ctxt.unified = ty,\n-                    Err(err) => {\n-                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit();\n-                    }\n-                }\n+                  ctxt.may_break = true;\n+              } else {\n+                  // Otherwise, we failed to find the enclosing loop;\n+                  // this can only happen if the `break` was not\n+                  // inside a loop at all, which is caught by the\n+                  // loop-checking pass.\n+                  assert!(self.tcx.sess.err_count() > 0);\n+              }\n \n-                ctxt.may_break = true;\n-            }\n-            // Otherwise, we failed to find the enclosing breakable; this can only happen if the\n-            // `break` target was not found, which is caught in HIR lowering and reported by the\n-            // loop-checking pass.\n-            tcx.types.never\n+              // the type of a `break` is always `!`, since it diverges\n+              tcx.types.never\n           }\n           hir::ExprAgain(_) => { tcx.types.never }\n           hir::ExprRet(ref expr_opt) => {\n-            if self.ret_ty.is_none() {\n+            if self.ret_coercion.is_none() {\n                 struct_span_err!(self.tcx.sess, expr.span, E0572,\n                                  \"return statement outside of function body\").emit();\n             } else if let Some(ref e) = *expr_opt {\n-                self.check_expr_coercable_to_type(&e, self.ret_ty.unwrap());\n+                self.check_return_expr(e);\n             } else {\n-                match self.eq_types(false,\n-                                    &self.misc(expr.span),\n-                                    self.ret_ty.unwrap(),\n-                                    tcx.mk_nil()) {\n-                    Ok(ok) => self.register_infer_ok_obligations(ok),\n-                    Err(_) => {\n-                        struct_span_err!(tcx.sess, expr.span, E0069,\n-                                         \"`return;` in a function whose return type is not `()`\")\n-                            .span_label(expr.span, &format!(\"return type is not ()\"))\n-                            .emit();\n-                    }\n-                }\n+                let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n+                let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n+                coercion.coerce_forced_unit(self, &cause, &mut |_| ());\n             }\n             tcx.types.never\n           }\n@@ -3587,56 +3663,64 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_nil()\n             }\n           }\n-          hir::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n-            self.check_then_else(&cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n-                                 expr.span, expected)\n+          hir::ExprIf(ref cond, ref then_expr, ref opt_else_expr) => {\n+              self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n+                                   expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            let unified = self.tcx.mk_nil();\n-            let coerce_to = unified;\n-            let ctxt = BreakableCtxt {\n-                unified: unified,\n-                coerce_to: coerce_to,\n-                break_exprs: vec![],\n-                may_break: true,\n-            };\n-            self.with_breakable_ctxt(expr.id, ctxt, || {\n-                self.check_expr_has_type(&cond, tcx.types.bool);\n-                let cond_diverging = self.diverges.get();\n-                self.check_block_no_value(&body);\n+              let ctxt = BreakableCtxt {\n+                  // cannot use break with a value from a while loop\n+                  coerce: None,\n+                  may_break: true,\n+              };\n \n-                // We may never reach the body so it diverging means nothing.\n-                self.diverges.set(cond_diverging);\n-            });\n+              self.with_breakable_ctxt(expr.id, ctxt, || {\n+                  self.check_expr_has_type(&cond, tcx.types.bool);\n+                  let cond_diverging = self.diverges.get();\n+                  self.check_block_no_value(&body);\n \n-            if self.has_errors.get() {\n-                tcx.types.err\n-            } else {\n-                tcx.mk_nil()\n-            }\n+                  // We may never reach the body so it diverging means nothing.\n+                  self.diverges.set(cond_diverging);\n+              });\n+\n+              self.tcx.mk_nil()\n           }\n-          hir::ExprLoop(ref body, _, _) => {\n-            let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(body.span));\n-            let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n-            let ctxt = BreakableCtxt {\n-                unified: unified,\n-                coerce_to: coerce_to,\n-                break_exprs: vec![],\n-                may_break: false,\n-            };\n+          hir::ExprLoop(ref body, _, source) => {\n+              let coerce = match source {\n+                  // you can only use break with a value from a normal `loop { }`\n+                  hir::LoopSource::Loop => {\n+                      let coerce_to = expected.coercion_target_type(self, body.span);\n+                      Some(CoerceMany::new(coerce_to))\n+                  }\n \n-            let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n-                self.check_block_no_value(&body);\n-            });\n-            if ctxt.may_break {\n-                // No way to know whether it's diverging because\n-                // of a `break` or an outer `break` or `return.\n-                self.diverges.set(Diverges::Maybe);\n+                  hir::LoopSource::WhileLet |\n+                  hir::LoopSource::ForLoop => {\n+                      None\n+                  }\n+              };\n \n-                ctxt.unified\n-            } else {\n-                tcx.types.never\n-            }\n+              let ctxt = BreakableCtxt {\n+                  coerce: coerce,\n+                  may_break: false, // will get updated if/when we find a `break`\n+              };\n+\n+              let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                  self.check_block_no_value(&body);\n+              });\n+\n+              if ctxt.may_break {\n+                  // No way to know whether it's diverging because\n+                  // of a `break` or an outer `break` or `return.\n+                  self.diverges.set(Diverges::Maybe);\n+              }\n+\n+              // If we permit break with a value, then result type is\n+              // the LUB of the breaks (possibly ! if none); else, it\n+              // is nil. This makes sense because infinite loops\n+              // (which would have type !) are only possible iff we\n+              // permit break with a value [1].\n+              assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n+              ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n             self.check_match(expr, &discrim, arms, expected, match_src)\n@@ -3660,14 +3744,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n             let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n             let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+            let diverges = self.diverges.get();\n \n             // Eagerly check for some obvious errors.\n             if t_expr.references_error() || t_cast.references_error() {\n                 tcx.types.err\n             } else {\n                 // Defer other checks until we're done type checking.\n                 let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-                match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+                match cast::CastCheck::new(self, e, t_expr, diverges, t_cast, t.span, expr.span) {\n                     Ok(cast_check) => {\n                         deferred_cast_checks.push(cast_check);\n                         t_cast\n@@ -3684,36 +3769,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             typ\n           }\n           hir::ExprArray(ref args) => {\n-            let uty = expected.to_option(self).and_then(|uty| {\n-                match uty.sty {\n-                    ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n-                    _ => None\n-                }\n-            });\n-\n-            let mut unified = self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span));\n-            let coerce_to = uty.unwrap_or(unified);\n-\n-            for (i, e) in args.iter().enumerate() {\n-                let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                let cause = self.misc(e.span);\n-\n-                // Special-case the first element, as it has no \"previous expressions\".\n-                let result = if i == 0 {\n-                    self.try_coerce(e, e_ty, coerce_to)\n-                } else {\n-                    let prev_elems = || args[..i].iter().map(|e| &*e);\n-                    self.try_find_coercion_lub(&cause, prev_elems, unified, e, e_ty)\n-                };\n+              let uty = expected.to_option(self).and_then(|uty| {\n+                  match uty.sty {\n+                      ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                      _ => None\n+                  }\n+              });\n \n-                match result {\n-                    Ok(ty) => unified = ty,\n-                    Err(e) => {\n-                        self.report_mismatched_types(&cause, unified, e_ty, e).emit();\n-                    }\n-                }\n-            }\n-            tcx.mk_array(unified, args.len())\n+              let element_ty = if !args.is_empty() {\n+                  let coerce_to = uty.unwrap_or_else(\n+                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n+                  let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n+                  assert_eq!(self.diverges.get(), Diverges::Maybe);\n+                  for e in args {\n+                      let e_ty = self.check_expr_with_hint(e, coerce_to);\n+                      let cause = self.misc(e.span);\n+                      coerce.coerce(self, &cause, e, e_ty, self.diverges.get());\n+                  }\n+                  coerce.complete(self)\n+              } else {\n+                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n+              };\n+              tcx.mk_array(element_ty, args.len())\n           }\n           hir::ExprRepeat(ref element, count) => {\n             let count = eval_length(self.tcx.global_tcx(), count, \"repeat count\")\n@@ -3984,7 +4061,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n         self.has_errors.set(false);\n \n-        let (node_id, span) = match stmt.node {\n+        let (node_id, _span) = match stmt.node {\n             hir::StmtDecl(ref decl, id) => {\n                 let span = match decl.node {\n                     hir::DeclLocal(ref l) => {\n@@ -4010,9 +4087,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if self.has_errors.get() {\n             self.write_error(node_id);\n-        } else if self.diverges.get().always() {\n-            self.write_ty(node_id, self.next_diverging_ty_var(\n-                TypeVariableOrigin::DivergingStmt(span)));\n         } else {\n             self.write_nil(node_id);\n         }\n@@ -4025,7 +4099,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n         let unit = self.tcx.mk_nil();\n         let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n-        self.demand_suptype(blk.span, unit, ty);\n+\n+        // if the block produces a `!` value, that can always be\n+        // (effectively) coerced to unit.\n+        if !ty.is_never() {\n+            self.demand_suptype(blk.span, unit, ty);\n+        }\n     }\n \n     fn check_block_with_expected(&self,\n@@ -4037,96 +4116,79 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             replace(&mut *fcx_ps, unsafety_state)\n         };\n \n-        let mut ty = if let Some(break_to_expr_id) = blk.break_to_expr_id {\n-            let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(blk.span));\n-            let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n-            let ctxt = BreakableCtxt {\n-                unified: unified,\n-                coerce_to: coerce_to,\n-                break_exprs: vec![],\n-                may_break: false,\n+        // In some cases, blocks have just one exit, but other blocks\n+        // can be targeted by multiple breaks. This cannot happen in\n+        // normal Rust syntax today, but it can happen when we desugar\n+        // a `do catch { ... }` expression.\n+        //\n+        // Example 1:\n+        //\n+        //    'a: { if true { break 'a Err(()); } Ok(()) }\n+        //\n+        // Here we would wind up with two coercions, one from\n+        // `Err(())` and the other from the tail expression\n+        // `Ok(())`. If the tail expression is omitted, that's a\n+        // \"forced unit\" -- unless the block diverges, in which\n+        // case we can ignore the tail expression (e.g., `'a: {\n+        // break 'a 22; }` would not force the type of the block\n+        // to be `()`).\n+        let tail_expr = blk.expr.as_ref();\n+        let coerce_to_ty = expected.coercion_target_type(self, blk.span);\n+        let coerce = if blk.targeted_by_break {\n+            CoerceMany::new(coerce_to_ty)\n+        } else {\n+            let tail_expr: &[P<hir::Expr>] = match tail_expr {\n+                Some(e) => ref_slice(e),\n+                None => &[],\n             };\n+            CoerceMany::with_coercion_sites(coerce_to_ty, tail_expr)\n+        };\n \n-            let (mut ctxt, (e_ty, cause)) = self.with_breakable_ctxt(break_to_expr_id, ctxt, || {\n-                for s in &blk.stmts {\n-                    self.check_stmt(s);\n-                }\n-                let coerce_to = {\n-                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                    enclosing_breakables.find_breakable(\n-                        hir::ScopeTarget::Block(break_to_expr_id)\n-                    ).unwrap().coerce_to\n-                };\n-                let e_ty;\n-                let cause;\n-                match blk.expr {\n-                    Some(ref e) => {\n-                        e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        cause = self.misc(e.span);\n-                    },\n-                    None => {\n-                        e_ty = self.tcx.mk_nil();\n-                        cause = self.misc(blk.span);\n-                    }\n-                };\n-\n-                (e_ty, cause)\n-            });\n-\n-            if let Some(ref e) = blk.expr {\n-                let result = if !ctxt.may_break {\n-                    self.try_coerce(e, e_ty, ctxt.coerce_to)\n-                } else {\n-                    self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n-                                               ctxt.unified, e, e_ty)\n-                };\n-                match result {\n-                    Ok(ty) => ctxt.unified = ty,\n-                    Err(err) =>\n-                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit(),\n-                }\n-            } else {\n-                self.check_block_no_expr(blk, self.tcx.mk_nil(), e_ty);\n-            };\n+        let ctxt = BreakableCtxt {\n+            coerce: Some(coerce),\n+            may_break: false,\n+        };\n \n-            ctxt.unified\n-        } else {\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.id, ctxt, || {\n             for s in &blk.stmts {\n                 self.check_stmt(s);\n             }\n \n-            let mut ty = match blk.expr {\n-                Some(ref e) => self.check_expr_with_expectation(e, expected),\n-                None => self.tcx.mk_nil()\n-            };\n+            // check the tail expression **without** holding the\n+            // `enclosing_breakables` lock below.\n+            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n \n-            if self.diverges.get().always() {\n-                if let ExpectHasType(ety) = expected {\n-                    // Avoid forcing a type (only `!` for now) in unreachable code.\n-                    // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n-                    if !ety.is_never() {\n-                        if let Some(ref e) = blk.expr {\n-                            // Coerce the tail expression to the right type.\n-                            self.demand_coerce(e, ty, ety);\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let mut ctxt = enclosing_breakables.find_breakable(blk.id);\n+            let mut coerce = ctxt.coerce.as_mut().unwrap();\n+            if let Some(tail_expr_ty) = tail_expr_ty {\n+                let tail_expr = tail_expr.unwrap();\n+                coerce.coerce(self,\n+                              &self.misc(tail_expr.span),\n+                              tail_expr,\n+                              tail_expr_ty,\n+                              self.diverges.get());\n+            } else {\n+                // Subtle: if there is no explicit tail expression,\n+                // that is typically equivalent to a tail expression\n+                // of `()` -- except if the block diverges. In that\n+                // case, there is no value supplied from the tail\n+                // expression (assuming there are no other breaks,\n+                // this implies that the type of the block will be\n+                // `!`).\n+                if !self.diverges.get().always() {\n+                    coerce.coerce_forced_unit(self, &self.misc(blk.span), &mut |err| {\n+                        if let Some(expected_ty) = expected.only_has_type(self) {\n+                            self.consider_hint_about_removing_semicolon(blk,\n+                                                                        expected_ty,\n+                                                                        err);\n                         }\n-                    }\n-                }\n-\n-                ty = self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span));\n-            } else if let ExpectHasType(ety) = expected {\n-                if let Some(ref e) = blk.expr {\n-                    // Coerce the tail expression to the right type.\n-                    self.demand_coerce(e, ty, ety);\n-                } else {\n-                    self.check_block_no_expr(blk, ty, ety);\n+                    });\n                 }\n-\n-                // We already applied the type (and potentially errored),\n-                // use the expected type to avoid further errors out.\n-                ty = ety;\n             }\n-            ty\n-        };\n+        });\n+\n+        let mut ty = ctxt.coerce.unwrap().complete(self);\n \n         if self.has_errors.get() || ty.references_error() {\n             ty = self.tcx.types.err\n@@ -4138,43 +4200,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n-    pub fn check_block_no_expr(&self, blk: &'gcx hir::Block, ty: Ty<'tcx>, ety: Ty<'tcx>) {\n-        // We're not diverging and there's an expected type, which,\n-        // in case it's not `()`, could result in an error higher-up.\n-        // We have a chance to error here early and be more helpful.\n-        let cause = self.misc(blk.span);\n-        let trace = TypeTrace::types(&cause, false, ty, ety);\n-        match self.sub_types(false, &cause, ty, ety) {\n-            Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n-            },\n-            Err(err) => {\n-                let mut err = self.report_and_explain_type_error(trace, &err);\n-\n-                // Be helpful when the user wrote `{... expr;}` and\n-                // taking the `;` off is enough to fix the error.\n-                let mut extra_semi = None;\n-                if let Some(stmt) = blk.stmts.last() {\n-                    if let hir::StmtSemi(ref e, _) = stmt.node {\n-                        if self.can_sub_types(self.node_ty(e.id), ety).is_ok() {\n-                            extra_semi = Some(stmt);\n-                        }\n-                    }\n-                }\n-                if let Some(last_stmt) = extra_semi {\n-                    let original_span = original_sp(last_stmt.span, blk.span);\n-                    let span_semi = Span {\n-                        lo: original_span.hi - BytePos(1),\n-                        hi: original_span.hi,\n-                        ctxt: original_span.ctxt,\n-                    };\n-                    err.span_help(span_semi, \"consider removing this semicolon:\");\n-                }\n-\n-                err.emit();\n-            }\n+    /// A common error is to add an extra semicolon:\n+    ///\n+    /// ```\n+    /// fn foo() -> usize {\n+    ///     22;\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the final statement in a block is an\n+    /// expression with an explicit semicolon whose type is compatible\n+    /// with `expected_ty`. If so, it suggests removing the semicolon.\n+    fn consider_hint_about_removing_semicolon(&self,\n+                                              blk: &'gcx hir::Block,\n+                                              expected_ty: Ty<'tcx>,\n+                                              err: &mut DiagnosticBuilder) {\n+        // Be helpful when the user wrote `{... expr;}` and\n+        // taking the `;` off is enough to fix the error.\n+        let last_stmt = match blk.stmts.last() {\n+            Some(s) => s,\n+            None => return,\n+        };\n+        let last_expr = match last_stmt.node {\n+            hir::StmtSemi(ref e, _) => e,\n+            _ => return,\n+        };\n+        let last_expr_ty = self.expr_ty(last_expr);\n+        if self.can_sub_types(last_expr_ty, expected_ty).is_err() {\n+            return;\n         }\n+        let original_span = original_sp(last_stmt.span, blk.span);\n+        let span_semi = Span {\n+            lo: original_span.hi - BytePos(1),\n+            hi: original_span.hi,\n+            ctxt: original_span.ctxt,\n+        };\n+        err.span_help(span_semi, \"consider removing this semicolon:\");\n     }\n \n     // Instantiates the given path, which must refer to an item with the given"}, {"sha": "85c87adf9be68a01e2865d908a3f7347c6b9a287", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         let id = self.id;\n         let span = self.span;\n         self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, None, id);\n+            let fcx = FnCtxt::new(&inh, id);\n             let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n                 tcx: fcx.tcx.global_tcx(),\n                 code: code"}, {"sha": "0bde9fefeba0c833d53c7b66f820aacf944e85a0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -79,6 +79,7 @@ This API is completely unstable and subject to change.\n #![feature(conservative_impl_trait)]\n #![cfg_attr(stage0,feature(field_init_shorthand))]\n #![feature(loop_break_value)]\n+#![feature(never_type)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "d5baec675e44f2116ee1707c94315c7ba11ba2c7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -36,6 +36,7 @@ pub trait ParserObsoleteMethods {\n impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     #[allow(unused_variables)]\n+    #[allow(unreachable_code)]\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc, error) = match kind {\n             // Nothing here at the moment"}, {"sha": "57d2192e6356b854d3e53db7ad85ed526874f649", "filename": "src/test/compile-fail/coerce-to-bang-cast.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+fn foo(x: usize, y: !, z: usize) { }\n+\n+fn cast_a() {\n+    let y = {return; 22} as !;\n+}\n+\n+fn cast_b() {\n+    let y = 22 as !; //~ ERROR non-scalar cast\n+}\n+\n+fn main() { }"}, {"sha": "870665bb49ee620e70a023a5b61bbcf77a218e17", "filename": "src/test/compile-fail/coerce-to-bang.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+fn foo(x: usize, y: !, z: usize) { }\n+\n+fn call_foo_a() {\n+    // FIXME(#40800) -- accepted beacuse divergence happens **before**\n+    // the coercion to `!`, but within same expression. Not clear that\n+    // these are the rules we want.\n+    foo(return, 22, 44);\n+}\n+\n+fn call_foo_b() {\n+    // Divergence happens in the argument itself, definitely ok.\n+    foo(22, return, 44);\n+}\n+\n+fn call_foo_c() {\n+    // This test fails because the divergence happens **after** the\n+    // coercion to `!`:\n+    foo(22, 44, return); //~ ERROR mismatched types\n+}\n+\n+fn call_foo_d() {\n+    // This test passes because `a` has type `!`:\n+    let a: ! = return;\n+    let b = 22;\n+    let c = 44;\n+    foo(a, b, c); // ... and hence a reference to `a` is expected to diverge.\n+}\n+\n+fn call_foo_e() {\n+    // This test probably could pass but we don't *know* that `a`\n+    // has type `!` so we don't let it work.\n+    let a = return;\n+    let b = 22;\n+    let c = 44;\n+    foo(a, b, c); //~ ERROR mismatched types\n+}\n+\n+fn call_foo_f() {\n+    // This fn fails because `a` has type `usize`, and hence a\n+    // reference to is it **not** considered to diverge.\n+    let a: usize = return;\n+    let b = 22;\n+    let c = 44;\n+    foo(a, b, c); //~ ERROR mismatched types\n+}\n+\n+fn array_a() {\n+    // Accepted: return is coerced to `!` just fine, and then `22` can be\n+    // because we already diverged.\n+    let x: [!; 2] = [return, 22];\n+}\n+\n+fn array_b() {\n+    // Error: divergence has not yet occurred.\n+    let x: [!; 2] = [22, return]; //~ ERROR mismatched types\n+}\n+\n+fn tuple_a() {\n+    // No divergence at all.\n+    let x: (usize, !, usize) = (22, 44, 66); //~ ERROR mismatched types\n+}\n+\n+fn tuple_b() {\n+    // Divergence happens before coercion: OK\n+    let x: (usize, !, usize) = (return, 44, 66);\n+}\n+\n+fn tuple_c() {\n+    // Divergence happens before coercion: OK\n+    let x: (usize, !, usize) = (22, return, 66);\n+}\n+\n+fn tuple_d() {\n+    // Error: divergence happens too late\n+    let x: (usize, !, usize) = (22, 44, return); //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "ed6263d0fdbd13b97812cbd889d331f6496b3d79", "filename": "src/test/compile-fail/defaulted-unit-warning.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fdefaulted-unit-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fdefaulted-unit-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefaulted-unit-warning.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -22,16 +22,6 @@ impl Deserialize for () {\n     }\n }\n \n-fn doit() -> Result<(), String> {\n-    let _ = match Deserialize::deserialize() {\n-        //~^ ERROR code relies on type\n-        //~| WARNING previously accepted\n-        Ok(x) => x,\n-        Err(e) => return Err(e),\n-    };\n-    Ok(())\n-}\n-\n trait ImplementedForUnitButNotNever {}\n \n impl ImplementedForUnitButNotNever for () {}\n@@ -46,6 +36,6 @@ fn smeg() {\n }\n \n fn main() {\n-    let _ = doit();\n+    smeg();\n }\n "}, {"sha": "eedad08ab5536708f63148611b20e31fae24b5a4", "filename": "src/test/compile-fail/diverging-tuple-parts-39485.rs", "status": "renamed", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fdiverging-tuple-parts-39485.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fdiverging-tuple-parts-39485.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiverging-tuple-parts-39485.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -8,24 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(unreachable_code)]\n-pub fn expr_while_23() {\n-    let mut x = 23;\n-    let mut y = 23;\n-    let mut z = 23;\n+// After #39485, this test used to pass, but that change was reverted\n+// due to numerous inference failures like #39808, so it now fails\n+// again. #39485 made it so that diverging types never propagate\n+// upward; but we now do propagate such types upward in many more\n+// cases.\n \n-    while x > 0 {\n-        x -= 1;\n-\n-        while y > 0 {\n-            y -= 1;\n-\n-            while z > 0 { z -= 1; }\n+fn g() {\n+    &panic!() //~ ERROR mismatched types\n+}\n \n-            if x > 10 {\n-                return;\n-                \"unreachable\";\n-            }\n-        }\n-    }\n+fn f() -> isize {\n+    (return 1, return 2) //~ ERROR mismatched types\n }\n+\n+fn main() {}", "previous_filename": "src/test/run-make/graphviz-flowgraph/f23.rs"}, {"sha": "05b04723300482fb1b58e3b1f33101016cbecef0", "filename": "src/test/compile-fail/index-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Findex-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Findex-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findex-bot.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    (return)[0]; //~ ERROR the type of this value must be known in this context\n+    (return)[0]; //~ ERROR cannot index a value of type `!`\n }"}, {"sha": "c968844ae21ac87c7c8d08ba8822c02ad5bd11ff", "filename": "src/test/compile-fail/issue-10176.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-10176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-10176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10176.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -12,7 +12,7 @@ fn f() -> isize {\n     (return 1, return 2)\n //~^ ERROR mismatched types\n //~| expected type `isize`\n-//~| found type `(_, _)`\n+//~| found type `(!, !)`\n //~| expected isize, found tuple\n }\n "}, {"sha": "0314f109a7c8129a7184b936f8900300ca03d86d", "filename": "src/test/compile-fail/issue-13847.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    return.is_failure //~ ERROR the type of this value must be known in this context\n+    return.is_failure //~ ERROR no field `is_failure` on type `!`\n }"}, {"sha": "70da8cf4169bd64c93cf3f88136c1782ccf77ec2", "filename": "src/test/compile-fail/issue-15207.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     loop {\n-        break.push(1) //~ ERROR the type of this value must be known in this context\n+        break.push(1) //~ ERROR no method named `push` found for type `!`\n         ;\n     }\n }"}, {"sha": "f6e6a8a0852dd290b5a847c88c03e1114bea037c", "filename": "src/test/compile-fail/issue-17373.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-17373.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-17373.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17373.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    *return //~ ERROR the type of this value must be known in this context\n+    *return //~ ERROR type `!` cannot be dereferenced\n     ;\n }"}, {"sha": "2be5fdcac4ede37b2cc4d97073f57da3bcfa38c2", "filename": "src/test/compile-fail/issue-18532.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -13,6 +13,5 @@\n // into it.\n \n fn main() {\n-    (return)((),());\n-    //~^ ERROR the type of this value must be known\n+    (return)((),()); //~ ERROR expected function, found `!`\n }"}, {"sha": "256c5d8e6f72cc08d375e1e45caba593528c0e77", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -21,5 +21,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR no method named `bind` found for type `[&'static str; 1]` in the current scope\n+    //~^ ERROR no method named `bind` found for type `[&str; 1]` in the current scope\n }"}, {"sha": "23afa4b629636ac94e3e856b736d840466b9cba8", "filename": "src/test/compile-fail/issue-27042.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -12,14 +12,14 @@\n \n fn main() {\n     let _: i32 =\n-        'a: //~ ERROR mismatched types\n-        loop { break };\n+        'a: // in this case, the citation is just the `break`:\n+        loop { break }; //~ ERROR mismatched types\n     let _: i32 =\n         'b: //~ ERROR mismatched types\n-        while true { break };\n+        while true { break }; // but here we cite the whole loop\n     let _: i32 =\n         'c: //~ ERROR mismatched types\n-        for _ in None { break };\n+        for _ in None { break }; // but here we cite the whole loop\n     let _: i32 =\n         'd: //~ ERROR mismatched types\n         while let Some(_) = None { break };"}, {"sha": "a414321899203d17b0f16642a9e8fc0e67170d18", "filename": "src/test/compile-fail/loop-break-value.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -40,37 +40,40 @@ fn main() {\n         loop {\n             break 'while_loop 123;\n             //~^ ERROR `break` with value from a `while` loop\n-            //~| ERROR mismatched types\n             break 456;\n             break 789;\n         };\n     }\n \n-    'while_let_loop: while let Some(_) = Some(()) {\n+    while let Some(_) = Some(()) {\n         if break () { //~ ERROR `break` with value from a `while let` loop\n-            break;\n-            break None;\n-            //~^ ERROR `break` with value from a `while let` loop\n-            //~| ERROR mismatched types\n         }\n+    }\n+\n+    while let Some(_) = Some(()) {\n+        break None;\n+        //~^ ERROR `break` with value from a `while let` loop\n+    }\n+\n+    'while_let_loop: while let Some(_) = Some(()) {\n         loop {\n             break 'while_let_loop \"nope\";\n             //~^ ERROR `break` with value from a `while let` loop\n-            //~| ERROR mismatched types\n             break 33;\n         };\n     }\n \n-    'for_loop: for _ in &[1,2,3] {\n+    for _ in &[1,2,3] {\n         break (); //~ ERROR `break` with value from a `for` loop\n         break [()];\n         //~^ ERROR `break` with value from a `for` loop\n-        //~| ERROR mismatched types\n+    }\n+\n+    'for_loop: for _ in &[1,2,3] {\n         loop {\n             break Some(3);\n             break 'for_loop Some(17);\n             //~^ ERROR `break` with value from a `for` loop\n-            //~| ERROR mismatched types\n         };\n     }\n "}, {"sha": "db08f5e5e66a38fac2700e36f053bdd92384604c", "filename": "src/test/compile-fail/match-no-arms-unreachable-after.rs", "status": "renamed", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fmatch-no-arms-unreachable-after.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fmatch-no-arms-unreachable-after.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-no-arms-unreachable-after.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn lit_1() {\n-    1;\n+#![allow(warnings)]\n+#![deny(unreachable_code)]\n+\n+enum Void { }\n+\n+fn foo(v: Void) {\n+    match v { }\n+    let x = 2; //~ ERROR unreachable\n+}\n+\n+fn main() {\n }", "previous_filename": "src/test/run-make/graphviz-flowgraph/f01.rs"}, {"sha": "aae0f3135d8f5a2505b391ada3c8c8bb0deb4d63", "filename": "src/test/compile-fail/match-unreachable-warning-with-diverging-discrim.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fmatch-unreachable-warning-with-diverging-discrim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fmatch-unreachable-warning-with-diverging-discrim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-unreachable-warning-with-diverging-discrim.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slice_patterns)]\n+#![allow(unused_parens)]\n+#![deny(unreachable_code)]\n \n-pub fn pat_vec_7() {\n-    match [7, 77, 777, 7777] {\n-        [x, y, ..] => x + y\n-    };\n+fn main() {\n+    match (return) { } //~ ERROR unreachable expression\n }", "previous_filename": "src/test/run-make/graphviz-flowgraph/f07.rs"}, {"sha": "ea0f8db99e893b57229d80be8f729e35a04142ba", "filename": "src/test/compile-fail/match-unresolved-one-arm.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fmatch-unresolved-one-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fmatch-unresolved-one-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-unresolved-one-arm.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<T>() -> T { panic!(\"Rocks for my pillow\") }\n+\n+fn main() {\n+    let x = match () { //~ ERROR type annotations needed\n+        () => foo() // T here should be unresolved\n+    };\n+}"}, {"sha": "d8752e1c050fce37c2d5d7630c62915584ee3b85", "filename": "src/test/compile-fail/never-assign-dead-code.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -16,5 +16,6 @@\n fn main() {\n     let x: ! = panic!(\"aah\"); //~ ERROR unused\n     drop(x); //~ ERROR unreachable\n+    //~^ ERROR unreachable\n }\n "}, {"sha": "d854e6eb20388c856a7c9e259557a942c09124cf", "filename": "src/test/compile-fail/never-assign-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -11,6 +11,7 @@\n // Test that we can't use another type in place of !\n \n #![feature(never_type)]\n+#![deny(warnings)]\n \n fn main() {\n     let x: ! = \"hello\"; //~ ERROR mismatched types"}, {"sha": "a43b1a45fe939fdc88adbb71593c24d797cccecb", "filename": "src/test/compile-fail/never-fallback.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fnever-fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fnever-fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-fallback.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that diverging types default to ! when feature(never_type) is enabled. This test is the\n-// same as run-pass/unit-fallback.rs except that ! is enabled.\n-\n-#![feature(never_type)]\n-\n-trait Balls: Sized {\n-    fn smeg() -> Result<Self, ()>;\n-}\n-\n-impl Balls for () {\n-    fn smeg() -> Result<(), ()> { Ok(()) }\n-}\n-\n-struct Flah;\n-\n-impl Flah {\n-    fn flah<T: Balls>(&self) -> Result<T, ()> {\n-        T::smeg()\n-    }\n-}\n-\n-fn doit() -> Result<(), ()> {\n-    // The type of _ is unconstrained here and should default to !\n-    let _ = try!(Flah.flah()); //~ ERROR the trait bound\n-    Ok(())\n-}\n-\n-fn main() {\n-    let _ = doit();\n-}\n-"}, {"sha": "d25674a74b1d37e563adcbe82728b269e3a70626", "filename": "src/test/compile-fail/region-invariant-static-error-reporting.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -13,9 +13,6 @@\n // over time, but this test used to exhibit some pretty bogus messages\n // that were not remotely helpful.\n \n-// error-pattern:cannot infer\n-// error-pattern:cannot outlive the lifetime 'a\n-// error-pattern:must be valid for the static lifetime\n // error-pattern:cannot infer\n // error-pattern:cannot outlive the lifetime 'a\n // error-pattern:must be valid for the static lifetime"}, {"sha": "5ce80be98d9741320d1c430a733f55710113bafd", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -16,17 +16,11 @@ struct an_enum<'a>(&'a isize);\n struct a_class<'a> { x:&'a isize }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n-    return e; //~  ERROR mismatched types\n-              //~| expected type `an_enum<'b>`\n-              //~| found type `an_enum<'a>`\n-              //~| lifetime mismatch\n+    return e; //~ ERROR mismatched types\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n-    return e; //~  ERROR mismatched types\n-              //~| expected type `a_class<'b>`\n-              //~| found type `a_class<'a>`\n-              //~| lifetime mismatch\n+    return e; //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "5740a36359c9cdf428353d954625af488b064d92", "filename": "src/test/run-make/graphviz-flowgraph/Makefile", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,38 +0,0 @@\n--include ../tools.mk\n-\n-FILES=f00.rs f01.rs f02.rs f03.rs f04.rs f05.rs f06.rs f07.rs \\\n-      f08.rs f09.rs f10.rs f11.rs f12.rs f13.rs f14.rs f15.rs \\\n-      f16.rs f17.rs f18.rs f19.rs f20.rs f21.rs f22.rs f23.rs \\\n-      f24.rs f25.rs\n-\n-\n-# all: $(patsubst %.rs,$(TMPDIR)/%.dot,$(FILES)) $(patsubst %.rs,$(TMPDIR)/%.pp,$(FILES))\n-all: $(patsubst %.rs,$(TMPDIR)/%.check,$(FILES))\n-\n-\n-RUSTC_LIB=$(RUSTC) --crate-type=lib\n-\n-define FIND_LAST_BLOCK\n-LASTBLOCKNUM_$(1) := $(shell $(RUSTC_LIB) -Z unstable-options --pretty=expanded,identified $(1) \\\n-\t\t\t | grep block\n-\t\t\t | tail -1\n-\t\t\t | sed -e 's@.*/\\* block \\([0-9]*\\) \\*/.*@\\1@')\n-endef\n-\n-ifeq ($(findstring rustc,$(RUSTC)),)\n-$(error Must set RUSTC)\n-endif\n-\n-$(TMPDIR)/%.pp: %.rs\n-\t$(RUSTC_LIB) --pretty=expanded,identified $< -o $@\n-\n-$(TMPDIR)/%.dot: %.rs\n-\t$(eval $(call FIND_LAST_BLOCK,$<))\n-\t$(RUSTC_LIB) -Z unstable-options --unpretty flowgraph,unlabelled=$(LASTBLOCKNUM_$<) $< -o $@.tmp\n-\tcat $@.tmp | sed -e 's@ (id=[0-9]*)@@g' \\\n-                         -e 's@\\[label=\"\"\\]@@' \\\n-                         -e 's@digraph [a-zA-Z0-9_]* @digraph block @' \\\n-                     > $@\n-\n-$(TMPDIR)/%.check: %.rs $(TMPDIR)/%.dot\n-\tdiff -u $(patsubst %.rs,$(TMPDIR)/%.dot,$<) $(patsubst %.rs,%.dot-expected.dot,$<)"}, {"sha": "8ea8370ab235d1308b4ff3d19d67e5be9f409405", "filename": "src/test/run-make/graphviz-flowgraph/f00.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff00.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,9 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"block { }\"];\n-    N3[label=\"expr { }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N1;\n-}"}, {"sha": "5982fbea76902905e78eaa4dc307eacdb10ddf56", "filename": "src/test/run-make/graphviz-flowgraph/f01.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff01.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,13 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 1\"];\n-    N3[label=\"stmt 1;\"];\n-    N4[label=\"block { 1; }\"];\n-    N5[label=\"expr { 1; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N1;\n-}"}, {"sha": "1639785bd68c0abe7c1df7b2e11ae36e37004915", "filename": "src/test/run-make/graphviz-flowgraph/f02.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff02.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,13 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"local _x\"];\n-    N3[label=\"stmt let _x: isize;\"];\n-    N4[label=\"block { let _x: isize; }\"];\n-    N5[label=\"expr { let _x: isize; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N1;\n-}"}, {"sha": "b0ae00d81675a6ee3ccc4a5f4dec9db63cdad371", "filename": "src/test/run-make/graphviz-flowgraph/f03.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,17 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 3\"];\n-    N3[label=\"expr 4\"];\n-    N4[label=\"expr 3 + 4\"];\n-    N5[label=\"stmt 3 + 4;\"];\n-    N6[label=\"block { 3 + 4; }\"];\n-    N7[label=\"expr { 3 + 4; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N1;\n-}"}, {"sha": "2dd71b623c24d9e148b73938c626e75256a0d81e", "filename": "src/test/run-make/graphviz-flowgraph/f03.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff03.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn expr_add_3() {\n-    3 + 4;\n-}"}, {"sha": "41ace15a4c680d18194f79a45d832ab27e8b92ba", "filename": "src/test/run-make/graphviz-flowgraph/f04.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,15 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 4\"];\n-    N3[label=\"local _x\"];\n-    N4[label=\"stmt let _x = 4;\"];\n-    N5[label=\"block { let _x = 4; }\"];\n-    N6[label=\"expr { let _x = 4; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N1;\n-}"}, {"sha": "2a0ac8ac9e57080224887d5891db71bc5a6b72c4", "filename": "src/test/run-make/graphviz-flowgraph/f04.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff04.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn pat_id_4() {\n-    let _x = 4;\n-}"}, {"sha": "72b8ae71751c2f7d7493ae3ed3a2157c5cb4a02d", "filename": "src/test/run-make/graphviz-flowgraph/f05.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,23 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 5\"];\n-    N3[label=\"expr 55\"];\n-    N4[label=\"expr (5, 55)\"];\n-    N5[label=\"local _x\"];\n-    N6[label=\"local _y\"];\n-    N7[label=\"pat (_x, _y)\"];\n-    N8[label=\"stmt let (_x, _y) = (5, 55);\"];\n-    N9[label=\"block { let (_x, _y) = (5, 55); }\"];\n-    N10[label=\"expr { let (_x, _y) = (5, 55); }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N1;\n-}"}, {"sha": "616d822bed07bf61283be397aff1ba42d61790c7", "filename": "src/test/run-make/graphviz-flowgraph/f05.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff05.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn pat_tup_5() {\n-    let (_x, _y) = (5, 55);\n-}"}, {"sha": "acba71ef625ff2db3f0afe2ca9ddae3566ab5b98", "filename": "src/test/run-make/graphviz-flowgraph/f06.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,19 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 6\"];\n-    N3[label=\"expr S6{val: 6,}\"];\n-    N4[label=\"local _x\"];\n-    N5[label=\"pat S6 { val: _x }\"];\n-    N6[label=\"stmt let S6 { val: _x } = S6{val: 6,};\"];\n-    N7[label=\"block { let S6 { val: _x } = S6{val: 6,}; }\"];\n-    N8[label=\"expr { let S6 { val: _x } = S6{val: 6,}; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N1;\n-}"}, {"sha": "538ef2af89896f328e68a37ae21190fd251f81c4", "filename": "src/test/run-make/graphviz-flowgraph/f06.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff06.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct S6 { val: isize }\n-pub fn pat_struct_6() {\n-    let S6 { val: _x } = S6{ val: 6 };\n-}"}, {"sha": "251e2b39f14c8fa6be9f4d142417493c62440caa", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,39 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 7\"];\n-    N3[label=\"expr 77\"];\n-    N4[label=\"expr 777\"];\n-    N5[label=\"expr 7777\"];\n-    N6[label=\"expr [7, 77, 777, 7777]\"];\n-    N7[label=\"expr match [7, 77, 777, 7777] { [x, y, ..] => x + y, }\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"local x\"];\n-    N10[label=\"local y\"];\n-    N11[label=\"pat _\"];\n-    N12[label=\"pat [x, y, ..]\"];\n-    N13[label=\"expr x\"];\n-    N14[label=\"expr y\"];\n-    N15[label=\"expr x + y\"];\n-    N16[label=\"stmt match [7, 77, 777, 7777] { [x, y, ..] => x + y, };\"];\n-    N17[label=\"block { match [7, 77, 777, 7777] { [x, y, ..] => x + y, }; }\"];\n-    N18[label=\"expr { match [7, 77, 777, 7777] { [x, y, ..] => x + y, }; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N8;\n-    N8 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N7;\n-    N7 -> N16;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N1;\n-}"}, {"sha": "e2779c9414a9e5a9d1e7d75ad9121f313b6c992f", "filename": "src/test/run-make/graphviz-flowgraph/f08.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff08.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,38 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 8\"];\n-    N3[label=\"local x\"];\n-    N4[label=\"stmt let x = 8;\"];\n-    N5[label=\"local _y\"];\n-    N6[label=\"stmt let _y;\"];\n-    N7[label=\"expr x\"];\n-    N8[label=\"expr 88\"];\n-    N9[label=\"expr x > 88\"];\n-    N10[label=\"expr 888\"];\n-    N11[label=\"expr _y\"];\n-    N12[label=\"expr _y = 888\"];\n-    N13[label=\"stmt _y = 888;\"];\n-    N14[label=\"block { _y = 888; }\"];\n-    N15[label=\"expr if x > 88 { _y = 888; }\"];\n-    N16[label=\"block { let x = 8; let _y; if x > 88 { _y = 888; } }\"];\n-    N17[label=\"expr { let x = 8; let _y; if x > 88 { _y = 888; } }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N9 -> N15;\n-    N14 -> N15;\n-    N15 -> N16;\n-    N16 -> N17;\n-    N17 -> N1;\n-}"}, {"sha": "536abde91e81a9c3a5323ea77ccb980384c08024", "filename": "src/test/run-make/graphviz-flowgraph/f09.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,54 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 91\"];\n-    N3[label=\"local x\"];\n-    N4[label=\"stmt let x = 91;\"];\n-    N5[label=\"local _y\"];\n-    N6[label=\"stmt let _y;\"];\n-    N7[label=\"expr x\"];\n-    N8[label=\"expr 92\"];\n-    N9[label=\"expr x > 92\"];\n-    N10[label=\"expr 93\"];\n-    N11[label=\"expr _y\"];\n-    N12[label=\"expr _y = 93\"];\n-    N13[label=\"stmt _y = 93;\"];\n-    N14[label=\"block { _y = 93; }\"];\n-    N15[label=\"expr 94\"];\n-    N16[label=\"expr 95\"];\n-    N17[label=\"expr 94 + 95\"];\n-    N18[label=\"expr _y\"];\n-    N19[label=\"expr _y = 94 + 95\"];\n-    N20[label=\"stmt _y = 94 + 95;\"];\n-    N21[label=\"block { _y = 94 + 95; }\"];\n-    N22[label=\"expr { _y = 94 + 95; }\"];\n-    N23[label=\"expr if x > 92 { _y = 93; } else { _y = 94 + 95; }\"];\n-    N24[label=\"block { let x = 91; let _y; if x > 92 { _y = 93; } else { _y = 94 + 95; } }\"];\n-    N25[label=\"expr { let x = 91; let _y; if x > 92 { _y = 93; } else { _y = 94 + 95; } }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N9 -> N15;\n-    N15 -> N16;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N20 -> N21;\n-    N21 -> N22;\n-    N14 -> N23;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N25;\n-    N25 -> N1;\n-}"}, {"sha": "a78ccb8a93741a174368a5df7232510281d7d63a", "filename": "src/test/run-make/graphviz-flowgraph/f09.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff09.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn expr_if_twoarm_9() {\n-    let x = 91; let _y;\n-    if x > 92 {\n-        _y = 93;\n-    } else {\n-        _y = 94+95;\n-    }\n-}"}, {"sha": "07b9c744a71711c33f87bad824fbdd4746dc8140", "filename": "src/test/run-make/graphviz-flowgraph/f10.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,36 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 10\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 10;\"];\n-    N5[label=\"(dummy_node)\"];\n-    N6[label=\"expr while x > 0 { x -= 1; }\"];\n-    N7[label=\"expr x\"];\n-    N8[label=\"expr 0\"];\n-    N9[label=\"expr x > 0\"];\n-    N10[label=\"expr 1\"];\n-    N11[label=\"expr x\"];\n-    N12[label=\"expr x -= 1\"];\n-    N13[label=\"stmt x -= 1;\"];\n-    N14[label=\"block { x -= 1; }\"];\n-    N15[label=\"block { let mut x = 10; while x > 0 { x -= 1; } }\"];\n-    N16[label=\"expr { let mut x = 10; while x > 0 { x -= 1; } }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N6;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N14 -> N5;\n-    N6 -> N15;\n-    N15 -> N16;\n-    N16 -> N1;\n-}"}, {"sha": "70034d299ba95f7c1bb03fa7072f15213e6cd73d", "filename": "src/test/run-make/graphviz-flowgraph/f11.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,35 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 11\"];\n-    N3[label=\"local mut _x\"];\n-    N4[label=\"stmt let mut _x = 11;\"];\n-    N5[label=\"(dummy_node)\"];\n-    N6[label=\"expr loop  { _x -= 1; }\"];\n-    N7[label=\"expr 1\"];\n-    N8[label=\"expr _x\"];\n-    N9[label=\"expr _x -= 1\"];\n-    N10[label=\"stmt _x -= 1;\"];\n-    N11[label=\"block { _x -= 1; }\"];\n-    N12[label=\"stmt loop  { _x -= 1; }\"];\n-    N13[label=\"expr \\\"unreachable\\\"\"];\n-    N14[label=\"stmt \\\"unreachable\\\";\"];\n-    N15[label=\"block { let mut _x = 11; loop  { _x -= 1; } \\\"unreachable\\\"; }\"];\n-    N16[label=\"expr { let mut _x = 11; loop  { _x -= 1; } \\\"unreachable\\\"; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N5;\n-    N6 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N16;\n-    N16 -> N1;\n-}"}, {"sha": "d0f3452119e16b512712c5b22673aec811cd9122", "filename": "src/test/run-make/graphviz-flowgraph/f11.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff11.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_loop_11() {\n-    let mut _x = 11;\n-    loop {\n-        _x -= 1;\n-    }\n-    \"unreachable\";\n-}"}, {"sha": "245afc43504c473660a2bc23c11374722c5c78c9", "filename": "src/test/run-make/graphviz-flowgraph/f12.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,50 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 12\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 12;\"];\n-    N5[label=\"(dummy_node)\"];\n-    N6[label=\"expr loop  { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } }\"];\n-    N7[label=\"expr 1\"];\n-    N8[label=\"expr x\"];\n-    N9[label=\"expr x -= 1\"];\n-    N10[label=\"stmt x -= 1;\"];\n-    N11[label=\"expr x\"];\n-    N12[label=\"expr 2\"];\n-    N13[label=\"expr x == 2\"];\n-    N14[label=\"expr break\"];\n-    N15[label=\"(dummy_node)\"];\n-    N16[label=\"stmt break ;\"];\n-    N17[label=\"expr \\\"unreachable\\\"\"];\n-    N18[label=\"stmt \\\"unreachable\\\";\"];\n-    N19[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N20[label=\"expr if x == 2 { break ; \\\"unreachable\\\"; }\"];\n-    N21[label=\"block { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } }\"];\n-    N22[label=\"block { let mut x = 12; loop  { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } } }\"];\n-    N23[label=\"expr { let mut x = 12; loop  { x -= 1; if x == 2 { break ; \\\"unreachable\\\"; } } }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N14 -> N6;\n-    N15 -> N16;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N13 -> N20;\n-    N19 -> N20;\n-    N20 -> N21;\n-    N21 -> N5;\n-    N6 -> N22;\n-    N22 -> N23;\n-    N23 -> N1;\n-}"}, {"sha": "90b146340b6f5ddf53f674e239c0a55ce9f169f4", "filename": "src/test/run-make/graphviz-flowgraph/f12.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_loop_12() {\n-    let mut x = 12;\n-    loop {\n-        x -= 1;\n-        if x == 2 { break; \"unreachable\"; }\n-    }\n-}"}, {"sha": "0f268bd0f2aeb530f58a0ad19ab250e5c585c23f", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,54 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr E13::E13b\"];\n-    N3[label=\"expr 13\"];\n-    N4[label=\"expr E13::E13b(13)\"];\n-    N5[label=\"local x\"];\n-    N6[label=\"stmt let x = E13::E13b(13);\"];\n-    N7[label=\"local _y\"];\n-    N8[label=\"stmt let _y;\"];\n-    N9[label=\"expr x\"];\n-    N10[label=\"expr match x { E13::E13a => _y = 1, E13::E13b(v) => _y = v + 1, }\"];\n-    N11[label=\"(dummy_node)\"];\n-    N12[label=\"pat E13::E13a\"];\n-    N13[label=\"expr 1\"];\n-    N14[label=\"expr _y\"];\n-    N15[label=\"expr _y = 1\"];\n-    N16[label=\"(dummy_node)\"];\n-    N17[label=\"local v\"];\n-    N18[label=\"pat E13::E13b(v)\"];\n-    N19[label=\"expr v\"];\n-    N20[label=\"expr 1\"];\n-    N21[label=\"expr v + 1\"];\n-    N22[label=\"expr _y\"];\n-    N23[label=\"expr _y = v + 1\"];\n-    N24[label=\"block {\\l    let x = E13::E13b(13);\\l    let _y;\\l    match x { E13::E13a => _y = 1, E13::E13b(v) => _y = v + 1, }\\l}\\l\"];\n-    N25[label=\"expr {\\l    let x = E13::E13b(13);\\l    let _y;\\l    match x { E13::E13a => _y = 1, E13::E13b(v) => _y = v + 1, }\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N12;\n-    N12 -> N11;\n-    N11 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N10;\n-    N9 -> N17;\n-    N17 -> N18;\n-    N18 -> N16;\n-    N16 -> N19;\n-    N19 -> N20;\n-    N20 -> N21;\n-    N21 -> N22;\n-    N22 -> N23;\n-    N23 -> N10;\n-    N10 -> N24;\n-    N24 -> N25;\n-    N25 -> N1;\n-}"}, {"sha": "babb283c7342c04e6d3153bb79053ab016bf5e63", "filename": "src/test/run-make/graphviz-flowgraph/f13.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum E13 { E13a, E13b(isize) }\n-pub fn expr_match_13() {\n-    let x = E13::E13b(13); let _y;\n-    match x {\n-        E13::E13a => _y = 1,\n-        E13::E13b(v) => _y = v + 1,\n-    }\n-}"}, {"sha": "719a6cf2619d37f8dfc6f09bc5b390dcd6a90e8a", "filename": "src/test/run-make/graphviz-flowgraph/f14.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,36 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 14\"];\n-    N3[label=\"local x\"];\n-    N4[label=\"stmt let x = 14;\"];\n-    N5[label=\"expr x\"];\n-    N6[label=\"expr 1\"];\n-    N7[label=\"expr x > 1\"];\n-    N8[label=\"expr return\"];\n-    N9[label=\"(dummy_node)\"];\n-    N10[label=\"stmt return;\"];\n-    N11[label=\"expr \\\"unreachable\\\"\"];\n-    N12[label=\"stmt \\\"unreachable\\\";\"];\n-    N13[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N14[label=\"expr if x > 1 { return; \\\"unreachable\\\"; }\"];\n-    N15[label=\"block { let x = 14; if x > 1 { return; \\\"unreachable\\\"; } }\"];\n-    N16[label=\"expr { let x = 14; if x > 1 { return; \\\"unreachable\\\"; } }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N1;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N7 -> N14;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N16;\n-    N16 -> N1;\n-}"}, {"sha": "98ff095c8317cf1fc49004f18fb3209fd4bfe0d3", "filename": "src/test/run-make/graphviz-flowgraph/f14.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff14.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_ret_14() {\n-    let x = 14;\n-    if x > 1 {\n-        return;\n-        \"unreachable\";\n-    }\n-}"}, {"sha": "d8cbd8411e2095b47d48b9c2222a3d70881b4772", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,105 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 15\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 15;\"];\n-    N5[label=\"expr 151\"];\n-    N6[label=\"local mut y\"];\n-    N7[label=\"stmt let mut y = 151;\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2 { break ; \\\"unreachable\\\"; }\\l                y -= 3;\\l            }\\l        y -= 4;\\l        x -= 5;\\l    }\\l\"];\n-    N10[label=\"(dummy_node)\"];\n-    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { break ; \\\"unreachable\\\"; }\\l        y -= 3;\\l    }\\l\"];\n-    N12[label=\"expr x\"];\n-    N13[label=\"expr 1\"];\n-    N14[label=\"expr x == 1\"];\n-    N15[label=\"expr break \\'outer\"];\n-    N16[label=\"(dummy_node)\"];\n-    N17[label=\"stmt break \\'outer ;\"];\n-    N18[label=\"expr \\\"unreachable\\\"\"];\n-    N19[label=\"stmt \\\"unreachable\\\";\"];\n-    N20[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N21[label=\"expr if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N22[label=\"stmt if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N23[label=\"expr y\"];\n-    N24[label=\"expr 2\"];\n-    N25[label=\"expr y >= 2\"];\n-    N26[label=\"expr break\"];\n-    N27[label=\"(dummy_node)\"];\n-    N28[label=\"stmt break ;\"];\n-    N29[label=\"expr \\\"unreachable\\\"\"];\n-    N30[label=\"stmt \\\"unreachable\\\";\"];\n-    N31[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N32[label=\"expr if y >= 2 { break ; \\\"unreachable\\\"; }\"];\n-    N33[label=\"stmt if y >= 2 { break ; \\\"unreachable\\\"; }\"];\n-    N34[label=\"expr 3\"];\n-    N35[label=\"expr y\"];\n-    N36[label=\"expr y -= 3\"];\n-    N37[label=\"stmt y -= 3;\"];\n-    N38[label=\"block {\\l    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2 { break ; \\\"unreachable\\\"; }\\l    y -= 3;\\l}\\l\"];\n-    N39[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { break ; \\\"unreachable\\\"; }\\l        y -= 3;\\l    }\\l\"];\n-    N40[label=\"expr 4\"];\n-    N41[label=\"expr y\"];\n-    N42[label=\"expr y -= 4\"];\n-    N43[label=\"stmt y -= 4;\"];\n-    N44[label=\"expr 5\"];\n-    N45[label=\"expr x\"];\n-    N46[label=\"expr x -= 5\"];\n-    N47[label=\"stmt x -= 5;\"];\n-    N48[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { break ; \\\"unreachable\\\"; }\\l            y -= 3;\\l        }\\l    y -= 4;\\l    x -= 5;\\l}\\l\"];\n-    N49[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { break ; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                }\\l            y -= 4;\\l            x -= 5;\\l        }\\l}\\l\"];\n-    N50[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { break ; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                }\\l            y -= 4;\\l            x -= 5;\\l        }\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N10;\n-    N10 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N9;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N14 -> N21;\n-    N20 -> N21;\n-    N21 -> N22;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N25;\n-    N25 -> N26;\n-    N26 -> N11;\n-    N27 -> N28;\n-    N28 -> N29;\n-    N29 -> N30;\n-    N30 -> N31;\n-    N25 -> N32;\n-    N31 -> N32;\n-    N32 -> N33;\n-    N33 -> N34;\n-    N34 -> N35;\n-    N35 -> N36;\n-    N36 -> N37;\n-    N37 -> N38;\n-    N38 -> N10;\n-    N11 -> N39;\n-    N39 -> N40;\n-    N40 -> N41;\n-    N41 -> N42;\n-    N42 -> N43;\n-    N43 -> N44;\n-    N44 -> N45;\n-    N45 -> N46;\n-    N46 -> N47;\n-    N47 -> N48;\n-    N48 -> N8;\n-    N9 -> N49;\n-    N49 -> N50;\n-    N50 -> N1;\n-}"}, {"sha": "056458e5558de5d656f4ad9cb7f0cce00a371673", "filename": "src/test/run-make/graphviz-flowgraph/f15.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_break_label_15() {\n-    let mut x = 15;\n-    let mut y = 151;\n-    'outer: loop {\n-        'inner: loop {\n-            if x == 1 {\n-                break 'outer;\n-                \"unreachable\";\n-            }\n-            if y >= 2 {\n-                break;\n-                \"unreachable\";\n-            }\n-            y -= 3;\n-        }\n-        y -= 4;\n-        x -= 5;\n-    }\n-}"}, {"sha": "b11881247fb6a3d8dd1d2dfb9b7aaa0da916689b", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,111 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 16\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 16;\"];\n-    N5[label=\"expr 16\"];\n-    N6[label=\"local mut y\"];\n-    N7[label=\"stmt let mut y = 16;\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 1 { break ; \\\"unreachable\\\"; }\\l                y -= 1;\\l            }\\l        y -= 1;\\l        x -= 1;\\l    }\\l\"];\n-    N10[label=\"(dummy_node)\"];\n-    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l    }\\l\"];\n-    N12[label=\"expr x\"];\n-    N13[label=\"expr 1\"];\n-    N14[label=\"expr x == 1\"];\n-    N15[label=\"expr continue \\'outer\"];\n-    N16[label=\"(dummy_node)\"];\n-    N17[label=\"stmt continue \\'outer ;\"];\n-    N18[label=\"expr \\\"unreachable\\\"\"];\n-    N19[label=\"stmt \\\"unreachable\\\";\"];\n-    N20[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N21[label=\"expr if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N22[label=\"stmt if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N23[label=\"expr y\"];\n-    N24[label=\"expr 1\"];\n-    N25[label=\"expr y >= 1\"];\n-    N26[label=\"expr break\"];\n-    N27[label=\"(dummy_node)\"];\n-    N28[label=\"stmt break ;\"];\n-    N29[label=\"expr \\\"unreachable\\\"\"];\n-    N30[label=\"stmt \\\"unreachable\\\";\"];\n-    N31[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N32[label=\"expr if y >= 1 { break ; \\\"unreachable\\\"; }\"];\n-    N33[label=\"stmt if y >= 1 { break ; \\\"unreachable\\\"; }\"];\n-    N34[label=\"expr 1\"];\n-    N35[label=\"expr y\"];\n-    N36[label=\"expr y -= 1\"];\n-    N37[label=\"stmt y -= 1;\"];\n-    N38[label=\"block {\\l    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l}\\l\"];\n-    N39[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l    }\\l\"];\n-    N40[label=\"expr 1\"];\n-    N41[label=\"expr y\"];\n-    N42[label=\"expr y -= 1\"];\n-    N43[label=\"stmt y -= 1;\"];\n-    N44[label=\"expr 1\"];\n-    N45[label=\"expr x\"];\n-    N46[label=\"expr x -= 1\"];\n-    N47[label=\"stmt x -= 1;\"];\n-    N48[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l        }\\l    y -= 1;\\l    x -= 1;\\l}\\l\"];\n-    N49[label=\"stmt \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 1 { break ; \\\"unreachable\\\"; }\\l                y -= 1;\\l            }\\l        y -= 1;\\l        x -= 1;\\l    }\\l\"];\n-    N50[label=\"expr \\\"unreachable\\\"\"];\n-    N51[label=\"stmt \\\"unreachable\\\";\"];\n-    N52[label=\"block {\\l    let mut x = 16;\\l    let mut y = 16;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                }\\l            y -= 1;\\l            x -= 1;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N53[label=\"expr {\\l    let mut x = 16;\\l    let mut y = 16;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                }\\l            y -= 1;\\l            x -= 1;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N10;\n-    N10 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N8;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N14 -> N21;\n-    N20 -> N21;\n-    N21 -> N22;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N25;\n-    N25 -> N26;\n-    N26 -> N11;\n-    N27 -> N28;\n-    N28 -> N29;\n-    N29 -> N30;\n-    N30 -> N31;\n-    N25 -> N32;\n-    N31 -> N32;\n-    N32 -> N33;\n-    N33 -> N34;\n-    N34 -> N35;\n-    N35 -> N36;\n-    N36 -> N37;\n-    N37 -> N38;\n-    N38 -> N10;\n-    N11 -> N39;\n-    N39 -> N40;\n-    N40 -> N41;\n-    N41 -> N42;\n-    N42 -> N43;\n-    N43 -> N44;\n-    N44 -> N45;\n-    N45 -> N46;\n-    N46 -> N47;\n-    N47 -> N48;\n-    N48 -> N8;\n-    N9 -> N49;\n-    N49 -> N50;\n-    N50 -> N51;\n-    N51 -> N52;\n-    N52 -> N53;\n-    N53 -> N1;\n-}"}, {"sha": "e225b0080e59abdb399cfe3f9129bdb57204e3ed", "filename": "src/test/run-make/graphviz-flowgraph/f16.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_continue_label_16() {\n-    let mut x = 16;\n-    let mut y = 16;\n-    'outer: loop {\n-        'inner: loop {\n-            if x == 1 {\n-                continue 'outer;\n-                \"unreachable\";\n-            }\n-            if y >= 1 {\n-                break;\n-                \"unreachable\";\n-            }\n-            y -= 1;\n-        }\n-        y -= 1;\n-        x -= 1;\n-    }\n-    \"unreachable\";\n-}"}, {"sha": "705eece77558dcc38d262cd116f6ea9fd5f19084", "filename": "src/test/run-make/graphviz-flowgraph/f17.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,21 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 1\"];\n-    N3[label=\"expr 7\"];\n-    N4[label=\"expr 17\"];\n-    N5[label=\"expr [1, 7, 17]\"];\n-    N6[label=\"local _v\"];\n-    N7[label=\"stmt let _v = [1, 7, 17];\"];\n-    N8[label=\"block { let _v = [1, 7, 17]; }\"];\n-    N9[label=\"expr { let _v = [1, 7, 17]; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N1;\n-}"}, {"sha": "23f5bb8a1eb17b993fe026cc2c11f63f85f52fd8", "filename": "src/test/run-make/graphviz-flowgraph/f17.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff17.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn expr_vec_17() {\n-    let _v = [1, 7, 17];\n-}"}, {"sha": "b0491fe6e27fd44e7a1e01950641dcdfeb96ebaf", "filename": "src/test/run-make/graphviz-flowgraph/f18.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,23 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"stmt fn inner(x: isize) -> isize { x + x }\"];\n-    N3[label=\"expr inner\"];\n-    N4[label=\"expr inner\"];\n-    N5[label=\"expr 18\"];\n-    N6[label=\"expr inner(18)\"];\n-    N7[label=\"expr inner(inner(18))\"];\n-    N8[label=\"stmt inner(inner(18));\"];\n-    N9[label=\"block {\\l    fn inner(x: isize) -> isize { x + x }\\l    inner(inner(18));\\l}\\l\"];\n-    N10[label=\"expr {\\l    fn inner(x: isize) -> isize { x + x }\\l    inner(inner(18));\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N1;\n-}"}, {"sha": "cbf8aa5db43911d9ffc14e499bda07a2cac5e9c2", "filename": "src/test/run-make/graphviz-flowgraph/f18.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn expr_call_18() {\n-    fn inner(x:isize) -> isize { x + x }\n-    inner(inner(18));\n-}"}, {"sha": "223978c3d7634f7380960dc81d32f2c8eadda422", "filename": "src/test/run-make/graphviz-flowgraph/f19.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,29 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"stmt struct S19 {\\l    x: isize,\\l}\\l\"];\n-    N3[label=\"stmt impl S19 {\\l    fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l}\\l\"];\n-    N4[label=\"expr 19\"];\n-    N5[label=\"expr S19{x: 19,}\"];\n-    N6[label=\"local s\"];\n-    N7[label=\"stmt let s = S19{x: 19,};\"];\n-    N8[label=\"expr s\"];\n-    N9[label=\"expr s.inner()\"];\n-    N10[label=\"expr s.inner().inner()\"];\n-    N11[label=\"stmt s.inner().inner();\"];\n-    N12[label=\"block {\\l    struct S19 {\\l        x: isize,\\l    }\\l    impl S19 {\\l        fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n-    N13[label=\"expr {\\l    struct S19 {\\l        x: isize,\\l    }\\l    impl S19 {\\l        fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N1;\n-}"}, {"sha": "78c15dd64adc44dc26e10ab76faaa73268789131", "filename": "src/test/run-make/graphviz-flowgraph/f19.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn expr_method_call_19() {\n-    struct S19 { x: isize }\n-    impl S19 { fn inner(self) -> S19 { S19 { x: self.x + self.x } } }\n-    let s = S19 { x: 19 };\n-    s.inner().inner();\n-}"}, {"sha": "120eab4dac909e6652a53c9688a7220476a6f8b6", "filename": "src/test/run-make/graphviz-flowgraph/f20.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,29 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 2\"];\n-    N3[label=\"expr 0\"];\n-    N4[label=\"expr 20\"];\n-    N5[label=\"expr [2, 0, 20]\"];\n-    N6[label=\"local v\"];\n-    N7[label=\"stmt let v = [2, 0, 20];\"];\n-    N8[label=\"expr v\"];\n-    N9[label=\"expr 20\"];\n-    N10[label=\"expr v[20]\"];\n-    N11[label=\"stmt v[20];\"];\n-    N12[label=\"block { let v = [2, 0, 20]; v[20]; }\"];\n-    N13[label=\"expr { let v = [2, 0, 20]; v[20]; }\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n-    N13 -> N1;\n-}"}, {"sha": "d7349932355b10c92a06c3a1d93af996a6b7e7cb", "filename": "src/test/run-make/graphviz-flowgraph/f20.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff20.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn expr_index_20() {\n-    let v = [2, 0, 20];\n-    v[20];\n-}"}, {"sha": "370dcdd8554da3071f7f2f0609f3277173b853f2", "filename": "src/test/run-make/graphviz-flowgraph/f21.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,101 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 15\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 15;\"];\n-    N5[label=\"expr 151\"];\n-    N6[label=\"local mut y\"];\n-    N7[label=\"stmt let mut y = 151;\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2 { return; \\\"unreachable\\\"; }\\l                y -= 3;\\l                x -= 5;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n-    N10[label=\"(dummy_node)\"];\n-    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { return; \\\"unreachable\\\"; }\\l        y -= 3;\\l        x -= 5;\\l    }\\l\"];\n-    N12[label=\"expr x\"];\n-    N13[label=\"expr 1\"];\n-    N14[label=\"expr x == 1\"];\n-    N15[label=\"expr break \\'outer\"];\n-    N16[label=\"(dummy_node)\"];\n-    N17[label=\"stmt break \\'outer ;\"];\n-    N18[label=\"expr \\\"unreachable\\\"\"];\n-    N19[label=\"stmt \\\"unreachable\\\";\"];\n-    N20[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N21[label=\"expr if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N22[label=\"stmt if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\"];\n-    N23[label=\"expr y\"];\n-    N24[label=\"expr 2\"];\n-    N25[label=\"expr y >= 2\"];\n-    N26[label=\"expr return\"];\n-    N27[label=\"(dummy_node)\"];\n-    N28[label=\"stmt return;\"];\n-    N29[label=\"expr \\\"unreachable\\\"\"];\n-    N30[label=\"stmt \\\"unreachable\\\";\"];\n-    N31[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N32[label=\"expr if y >= 2 { return; \\\"unreachable\\\"; }\"];\n-    N33[label=\"stmt if y >= 2 { return; \\\"unreachable\\\"; }\"];\n-    N34[label=\"expr 3\"];\n-    N35[label=\"expr y\"];\n-    N36[label=\"expr y -= 3\"];\n-    N37[label=\"stmt y -= 3;\"];\n-    N38[label=\"expr 5\"];\n-    N39[label=\"expr x\"];\n-    N40[label=\"expr x -= 5\"];\n-    N41[label=\"stmt x -= 5;\"];\n-    N42[label=\"block {\\l    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2 { return; \\\"unreachable\\\"; }\\l    y -= 3;\\l    x -= 5;\\l}\\l\"];\n-    N43[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { return; \\\"unreachable\\\"; }\\l        y -= 3;\\l        x -= 5;\\l    }\\l\"];\n-    N44[label=\"expr \\\"unreachable\\\"\"];\n-    N45[label=\"stmt \\\"unreachable\\\";\"];\n-    N46[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { return; \\\"unreachable\\\"; }\\l            y -= 3;\\l            x -= 5;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N47[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                    x -= 5;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n-    N48[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    y -= 3;\\l                    x -= 5;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N10;\n-    N10 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N9;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N14 -> N21;\n-    N20 -> N21;\n-    N21 -> N22;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N25;\n-    N25 -> N26;\n-    N26 -> N1;\n-    N27 -> N28;\n-    N28 -> N29;\n-    N29 -> N30;\n-    N30 -> N31;\n-    N25 -> N32;\n-    N31 -> N32;\n-    N32 -> N33;\n-    N33 -> N34;\n-    N34 -> N35;\n-    N35 -> N36;\n-    N36 -> N37;\n-    N37 -> N38;\n-    N38 -> N39;\n-    N39 -> N40;\n-    N40 -> N41;\n-    N41 -> N42;\n-    N42 -> N10;\n-    N11 -> N43;\n-    N43 -> N44;\n-    N44 -> N45;\n-    N45 -> N46;\n-    N46 -> N8;\n-    N9 -> N47;\n-    N47 -> N48;\n-    N48 -> N1;\n-}"}, {"sha": "70083ed8312cbbb181e5d5652f8150646e496dc3", "filename": "src/test/run-make/graphviz-flowgraph/f21.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_break_label_21() {\n-    let mut x = 15;\n-    let mut y = 151;\n-    'outer: loop {\n-        'inner: loop {\n-            if x == 1 {\n-                break 'outer;\n-                \"unreachable\";\n-            }\n-            if y >= 2 {\n-                return;\n-                \"unreachable\";\n-            }\n-            y -= 3;\n-            x -= 5;\n-        }\n-        \"unreachable\";\n-    }\n-}"}, {"sha": "9d3bc22831a139f1aee227b24747d12cee5efcbb", "filename": "src/test/run-make/graphviz-flowgraph/f22.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,107 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 15\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 15;\"];\n-    N5[label=\"expr 151\"];\n-    N6[label=\"local mut y\"];\n-    N7[label=\"stmt let mut y = 151;\"];\n-    N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2 { return; \\\"unreachable\\\"; }\\l                x -= 1;\\l                y -= 3;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n-    N10[label=\"(dummy_node)\"];\n-    N11[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { return; \\\"unreachable\\\"; }\\l        x -= 1;\\l        y -= 3;\\l    }\\l\"];\n-    N12[label=\"expr x\"];\n-    N13[label=\"expr 1\"];\n-    N14[label=\"expr x == 1\"];\n-    N15[label=\"expr continue \\'outer\"];\n-    N16[label=\"(dummy_node)\"];\n-    N17[label=\"stmt continue \\'outer ;\"];\n-    N18[label=\"expr \\\"unreachable\\\"\"];\n-    N19[label=\"stmt \\\"unreachable\\\";\"];\n-    N20[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N21[label=\"expr if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N22[label=\"stmt if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\"];\n-    N23[label=\"expr y\"];\n-    N24[label=\"expr 2\"];\n-    N25[label=\"expr y >= 2\"];\n-    N26[label=\"expr return\"];\n-    N27[label=\"(dummy_node)\"];\n-    N28[label=\"stmt return;\"];\n-    N29[label=\"expr \\\"unreachable\\\"\"];\n-    N30[label=\"stmt \\\"unreachable\\\";\"];\n-    N31[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N32[label=\"expr if y >= 2 { return; \\\"unreachable\\\"; }\"];\n-    N33[label=\"stmt if y >= 2 { return; \\\"unreachable\\\"; }\"];\n-    N34[label=\"expr 1\"];\n-    N35[label=\"expr x\"];\n-    N36[label=\"expr x -= 1\"];\n-    N37[label=\"stmt x -= 1;\"];\n-    N38[label=\"expr 3\"];\n-    N39[label=\"expr y\"];\n-    N40[label=\"expr y -= 3\"];\n-    N41[label=\"stmt y -= 3;\"];\n-    N42[label=\"block {\\l    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2 { return; \\\"unreachable\\\"; }\\l    x -= 1;\\l    y -= 3;\\l}\\l\"];\n-    N43[label=\"stmt \\'inner:\\l    loop  {\\l        if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { return; \\\"unreachable\\\"; }\\l        x -= 1;\\l        y -= 3;\\l    }\\l\"];\n-    N44[label=\"expr \\\"unreachable\\\"\"];\n-    N45[label=\"stmt \\\"unreachable\\\";\"];\n-    N46[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { return; \\\"unreachable\\\"; }\\l            x -= 1;\\l            y -= 3;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N47[label=\"stmt \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2 { return; \\\"unreachable\\\"; }\\l                x -= 1;\\l                y -= 3;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n-    N48[label=\"expr \\\"unreachable\\\"\"];\n-    N49[label=\"stmt \\\"unreachable\\\";\"];\n-    N50[label=\"block {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    x -= 1;\\l                    y -= 3;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N51[label=\"expr {\\l    let mut x = 15;\\l    let mut y = 151;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1 { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2 { return; \\\"unreachable\\\"; }\\l                    x -= 1;\\l                    y -= 3;\\l                }\\l            \\\"unreachable\\\";\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N10;\n-    N10 -> N12;\n-    N12 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N8;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N14 -> N21;\n-    N20 -> N21;\n-    N21 -> N22;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N25;\n-    N25 -> N26;\n-    N26 -> N1;\n-    N27 -> N28;\n-    N28 -> N29;\n-    N29 -> N30;\n-    N30 -> N31;\n-    N25 -> N32;\n-    N31 -> N32;\n-    N32 -> N33;\n-    N33 -> N34;\n-    N34 -> N35;\n-    N35 -> N36;\n-    N36 -> N37;\n-    N37 -> N38;\n-    N38 -> N39;\n-    N39 -> N40;\n-    N40 -> N41;\n-    N41 -> N42;\n-    N42 -> N10;\n-    N11 -> N43;\n-    N43 -> N44;\n-    N44 -> N45;\n-    N45 -> N46;\n-    N46 -> N8;\n-    N9 -> N47;\n-    N47 -> N48;\n-    N48 -> N49;\n-    N49 -> N50;\n-    N50 -> N51;\n-    N51 -> N1;\n-}"}, {"sha": "b35aac9ec422e924e3f4d167ae0ba0ab080de24b", "filename": "src/test/run-make/graphviz-flowgraph/f22.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_break_label_21() {\n-    let mut x = 15;\n-    let mut y = 151;\n-    'outer: loop {\n-        'inner: loop {\n-            if x == 1 {\n-                continue 'outer;\n-                \"unreachable\";\n-            }\n-            if y >= 2 {\n-                return;\n-                \"unreachable\";\n-            }\n-            x -= 1;\n-            y -= 3;\n-        }\n-        \"unreachable\";\n-    }\n-    \"unreachable\";\n-}"}, {"sha": "c8bfcd6510b30054fd02295cc34bd62e033d5e94", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,113 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 23\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 23;\"];\n-    N5[label=\"expr 23\"];\n-    N6[label=\"local mut y\"];\n-    N7[label=\"stmt let mut y = 23;\"];\n-    N8[label=\"expr 23\"];\n-    N9[label=\"local mut z\"];\n-    N10[label=\"stmt let mut z = 23;\"];\n-    N11[label=\"(dummy_node)\"];\n-    N12[label=\"expr while x > 0 {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N13[label=\"expr x\"];\n-    N14[label=\"expr 0\"];\n-    N15[label=\"expr x > 0\"];\n-    N16[label=\"expr 1\"];\n-    N17[label=\"expr x\"];\n-    N18[label=\"expr x -= 1\"];\n-    N19[label=\"stmt x -= 1;\"];\n-    N20[label=\"(dummy_node)\"];\n-    N21[label=\"expr while y > 0 {\\l    y -= 1;\\l    while z > 0 { z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N22[label=\"expr y\"];\n-    N23[label=\"expr 0\"];\n-    N24[label=\"expr y > 0\"];\n-    N25[label=\"expr 1\"];\n-    N26[label=\"expr y\"];\n-    N27[label=\"expr y -= 1\"];\n-    N28[label=\"stmt y -= 1;\"];\n-    N29[label=\"(dummy_node)\"];\n-    N30[label=\"expr while z > 0 { z -= 1; }\"];\n-    N31[label=\"expr z\"];\n-    N32[label=\"expr 0\"];\n-    N33[label=\"expr z > 0\"];\n-    N34[label=\"expr 1\"];\n-    N35[label=\"expr z\"];\n-    N36[label=\"expr z -= 1\"];\n-    N37[label=\"stmt z -= 1;\"];\n-    N38[label=\"block { z -= 1; }\"];\n-    N39[label=\"stmt while z > 0 { z -= 1; }\"];\n-    N40[label=\"expr x\"];\n-    N41[label=\"expr 10\"];\n-    N42[label=\"expr x > 10\"];\n-    N43[label=\"expr return\"];\n-    N44[label=\"(dummy_node)\"];\n-    N45[label=\"stmt return;\"];\n-    N46[label=\"expr \\\"unreachable\\\"\"];\n-    N47[label=\"stmt \\\"unreachable\\\";\"];\n-    N48[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N49[label=\"expr if x > 10 { return; \\\"unreachable\\\"; }\"];\n-    N50[label=\"block { y -= 1; while z > 0 { z -= 1; } if x > 10 { return; \\\"unreachable\\\"; } }\"];\n-    N51[label=\"block {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N52[label=\"block {\\l    let mut x = 23;\\l    let mut y = 23;\\l    let mut z = 23;\\l    while x > 0 {\\l        x -= 1;\\l        while y > 0 {\\l            y -= 1;\\l            while z > 0 { z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n-    N53[label=\"expr {\\l    let mut x = 23;\\l    let mut y = 23;\\l    let mut z = 23;\\l    while x > 0 {\\l        x -= 1;\\l        while y > 0 {\\l            y -= 1;\\l            while z > 0 { z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N12;\n-    N15 -> N16;\n-    N16 -> N17;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N20 -> N22;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N21;\n-    N24 -> N25;\n-    N25 -> N26;\n-    N26 -> N27;\n-    N27 -> N28;\n-    N28 -> N29;\n-    N29 -> N31;\n-    N31 -> N32;\n-    N32 -> N33;\n-    N33 -> N30;\n-    N33 -> N34;\n-    N34 -> N35;\n-    N35 -> N36;\n-    N36 -> N37;\n-    N37 -> N38;\n-    N38 -> N29;\n-    N30 -> N39;\n-    N39 -> N40;\n-    N40 -> N41;\n-    N41 -> N42;\n-    N42 -> N43;\n-    N43 -> N1;\n-    N44 -> N45;\n-    N45 -> N46;\n-    N46 -> N47;\n-    N47 -> N48;\n-    N42 -> N49;\n-    N48 -> N49;\n-    N49 -> N50;\n-    N50 -> N20;\n-    N21 -> N51;\n-    N51 -> N11;\n-    N12 -> N52;\n-    N52 -> N53;\n-    N53 -> N1;\n-}"}, {"sha": "e40dd014f0a4de54a49a3057ddc612f9ebb0a15a", "filename": "src/test/run-make/graphviz-flowgraph/f24.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,161 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 24\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 24;\"];\n-    N5[label=\"expr 24\"];\n-    N6[label=\"local mut y\"];\n-    N7[label=\"stmt let mut y = 24;\"];\n-    N8[label=\"expr 24\"];\n-    N9[label=\"local mut z\"];\n-    N10[label=\"stmt let mut z = 24;\"];\n-    N11[label=\"(dummy_node)\"];\n-    N12[label=\"expr loop  {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N13[label=\"expr x\"];\n-    N14[label=\"expr 0\"];\n-    N15[label=\"expr x == 0\"];\n-    N16[label=\"expr break\"];\n-    N17[label=\"(dummy_node)\"];\n-    N18[label=\"stmt break ;\"];\n-    N19[label=\"expr \\\"unreachable\\\"\"];\n-    N20[label=\"stmt \\\"unreachable\\\";\"];\n-    N21[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N22[label=\"expr if x == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N23[label=\"stmt if x == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N24[label=\"expr 1\"];\n-    N25[label=\"expr x\"];\n-    N26[label=\"expr x -= 1\"];\n-    N27[label=\"stmt x -= 1;\"];\n-    N28[label=\"(dummy_node)\"];\n-    N29[label=\"expr loop  {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N30[label=\"expr y\"];\n-    N31[label=\"expr 0\"];\n-    N32[label=\"expr y == 0\"];\n-    N33[label=\"expr break\"];\n-    N34[label=\"(dummy_node)\"];\n-    N35[label=\"stmt break ;\"];\n-    N36[label=\"expr \\\"unreachable\\\"\"];\n-    N37[label=\"stmt \\\"unreachable\\\";\"];\n-    N38[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N39[label=\"expr if y == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N40[label=\"stmt if y == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N41[label=\"expr 1\"];\n-    N42[label=\"expr y\"];\n-    N43[label=\"expr y -= 1\"];\n-    N44[label=\"stmt y -= 1;\"];\n-    N45[label=\"(dummy_node)\"];\n-    N46[label=\"expr loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n-    N47[label=\"expr z\"];\n-    N48[label=\"expr 0\"];\n-    N49[label=\"expr z == 0\"];\n-    N50[label=\"expr break\"];\n-    N51[label=\"(dummy_node)\"];\n-    N52[label=\"stmt break ;\"];\n-    N53[label=\"expr \\\"unreachable\\\"\"];\n-    N54[label=\"stmt \\\"unreachable\\\";\"];\n-    N55[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N56[label=\"expr if z == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N57[label=\"stmt if z == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N58[label=\"expr 1\"];\n-    N59[label=\"expr z\"];\n-    N60[label=\"expr z -= 1\"];\n-    N61[label=\"stmt z -= 1;\"];\n-    N62[label=\"block { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n-    N63[label=\"stmt loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n-    N64[label=\"expr x\"];\n-    N65[label=\"expr 10\"];\n-    N66[label=\"expr x > 10\"];\n-    N67[label=\"expr return\"];\n-    N68[label=\"(dummy_node)\"];\n-    N69[label=\"stmt return;\"];\n-    N70[label=\"expr \\\"unreachable\\\"\"];\n-    N71[label=\"stmt \\\"unreachable\\\";\"];\n-    N72[label=\"block { return; \\\"unreachable\\\"; }\"];\n-    N73[label=\"expr if x > 10 { return; \\\"unreachable\\\"; }\"];\n-    N74[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N75[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n-    N76[label=\"block {\\l    let mut x = 24;\\l    let mut y = 24;\\l    let mut z = 24;\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n-    N77[label=\"expr {\\l    let mut x = 24;\\l    let mut y = 24;\\l    let mut z = 24;\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N16;\n-    N16 -> N12;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N20 -> N21;\n-    N15 -> N22;\n-    N21 -> N22;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N25;\n-    N25 -> N26;\n-    N26 -> N27;\n-    N27 -> N28;\n-    N28 -> N30;\n-    N30 -> N31;\n-    N31 -> N32;\n-    N32 -> N33;\n-    N33 -> N29;\n-    N34 -> N35;\n-    N35 -> N36;\n-    N36 -> N37;\n-    N37 -> N38;\n-    N32 -> N39;\n-    N38 -> N39;\n-    N39 -> N40;\n-    N40 -> N41;\n-    N41 -> N42;\n-    N42 -> N43;\n-    N43 -> N44;\n-    N44 -> N45;\n-    N45 -> N47;\n-    N47 -> N48;\n-    N48 -> N49;\n-    N49 -> N50;\n-    N50 -> N46;\n-    N51 -> N52;\n-    N52 -> N53;\n-    N53 -> N54;\n-    N54 -> N55;\n-    N49 -> N56;\n-    N55 -> N56;\n-    N56 -> N57;\n-    N57 -> N58;\n-    N58 -> N59;\n-    N59 -> N60;\n-    N60 -> N61;\n-    N61 -> N62;\n-    N62 -> N45;\n-    N46 -> N63;\n-    N63 -> N64;\n-    N64 -> N65;\n-    N65 -> N66;\n-    N66 -> N67;\n-    N67 -> N1;\n-    N68 -> N69;\n-    N69 -> N70;\n-    N70 -> N71;\n-    N71 -> N72;\n-    N66 -> N73;\n-    N72 -> N73;\n-    N73 -> N74;\n-    N74 -> N28;\n-    N29 -> N75;\n-    N75 -> N11;\n-    N12 -> N76;\n-    N76 -> N77;\n-    N77 -> N1;\n-}"}, {"sha": "f796d660a185634d3cb033241752fefe39eb6e3c", "filename": "src/test/run-make/graphviz-flowgraph/f24.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_while_24() {\n-    let mut x = 24;\n-    let mut y = 24;\n-    let mut z = 24;\n-\n-    loop {\n-        if x == 0 { break; \"unreachable\"; }\n-        x -= 1;\n-\n-        loop {\n-            if y == 0 { break; \"unreachable\"; }\n-            y -= 1;\n-\n-            loop {\n-                if z == 0 { break; \"unreachable\"; }\n-                z -= 1;\n-            }\n-\n-            if x > 10 {\n-                return;\n-                \"unreachable\";\n-            }\n-        }\n-    }\n-}"}, {"sha": "1e2df1ab5e7b7ba10baf7d45462bf8b808ca8e98", "filename": "src/test/run-make/graphviz-flowgraph/f25.dot-expected.dot", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,161 +0,0 @@\n-digraph block {\n-    N0[label=\"entry\"];\n-    N1[label=\"exit\"];\n-    N2[label=\"expr 25\"];\n-    N3[label=\"local mut x\"];\n-    N4[label=\"stmt let mut x = 25;\"];\n-    N5[label=\"expr 25\"];\n-    N6[label=\"local mut y\"];\n-    N7[label=\"stmt let mut y = 25;\"];\n-    N8[label=\"expr 25\"];\n-    N9[label=\"local mut z\"];\n-    N10[label=\"stmt let mut z = 25;\"];\n-    N11[label=\"(dummy_node)\"];\n-    N12[label=\"expr \\'a:\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        \\'a:\\l            loop  {\\l                if y == 0 { break ; \\\"unreachable\\\"; }\\l                y -= 1;\\l                \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l            }\\l    }\\l\"];\n-    N13[label=\"expr x\"];\n-    N14[label=\"expr 0\"];\n-    N15[label=\"expr x == 0\"];\n-    N16[label=\"expr break\"];\n-    N17[label=\"(dummy_node)\"];\n-    N18[label=\"stmt break ;\"];\n-    N19[label=\"expr \\\"unreachable\\\"\"];\n-    N20[label=\"stmt \\\"unreachable\\\";\"];\n-    N21[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N22[label=\"expr if x == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N23[label=\"stmt if x == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N24[label=\"expr 1\"];\n-    N25[label=\"expr x\"];\n-    N26[label=\"expr x -= 1\"];\n-    N27[label=\"stmt x -= 1;\"];\n-    N28[label=\"(dummy_node)\"];\n-    N29[label=\"expr \\'a:\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l    }\\l\"];\n-    N30[label=\"expr y\"];\n-    N31[label=\"expr 0\"];\n-    N32[label=\"expr y == 0\"];\n-    N33[label=\"expr break\"];\n-    N34[label=\"(dummy_node)\"];\n-    N35[label=\"stmt break ;\"];\n-    N36[label=\"expr \\\"unreachable\\\"\"];\n-    N37[label=\"stmt \\\"unreachable\\\";\"];\n-    N38[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N39[label=\"expr if y == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N40[label=\"stmt if y == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N41[label=\"expr 1\"];\n-    N42[label=\"expr y\"];\n-    N43[label=\"expr y -= 1\"];\n-    N44[label=\"stmt y -= 1;\"];\n-    N45[label=\"(dummy_node)\"];\n-    N46[label=\"expr \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n-    N47[label=\"expr z\"];\n-    N48[label=\"expr 0\"];\n-    N49[label=\"expr z == 0\"];\n-    N50[label=\"expr break\"];\n-    N51[label=\"(dummy_node)\"];\n-    N52[label=\"stmt break ;\"];\n-    N53[label=\"expr \\\"unreachable\\\"\"];\n-    N54[label=\"stmt \\\"unreachable\\\";\"];\n-    N55[label=\"block { break ; \\\"unreachable\\\"; }\"];\n-    N56[label=\"expr if z == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N57[label=\"stmt if z == 0 { break ; \\\"unreachable\\\"; }\"];\n-    N58[label=\"expr 1\"];\n-    N59[label=\"expr z\"];\n-    N60[label=\"expr z -= 1\"];\n-    N61[label=\"stmt z -= 1;\"];\n-    N62[label=\"block { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n-    N63[label=\"stmt \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n-    N64[label=\"expr x\"];\n-    N65[label=\"expr 10\"];\n-    N66[label=\"expr x > 10\"];\n-    N67[label=\"expr continue \\'a\"];\n-    N68[label=\"(dummy_node)\"];\n-    N69[label=\"stmt continue \\'a ;\"];\n-    N70[label=\"expr \\\"unreachable\\\"\"];\n-    N71[label=\"stmt \\\"unreachable\\\";\"];\n-    N72[label=\"block { continue \\'a ; \\\"unreachable\\\"; }\"];\n-    N73[label=\"expr if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\"];\n-    N74[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n-    N75[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    \\'a:\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n-    N76[label=\"block {\\l    let mut x = 25;\\l    let mut y = 25;\\l    let mut z = 25;\\l    \\'a:\\l        loop  {\\l            if x == 0 { break ; \\\"unreachable\\\"; }\\l            x -= 1;\\l            \\'a:\\l                loop  {\\l                    if y == 0 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n-    N77[label=\"expr {\\l    let mut x = 25;\\l    let mut y = 25;\\l    let mut z = 25;\\l    \\'a:\\l        loop  {\\l            if x == 0 { break ; \\\"unreachable\\\"; }\\l            x -= 1;\\l            \\'a:\\l                loop  {\\l                    if y == 0 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n-    N0 -> N2;\n-    N2 -> N3;\n-    N3 -> N4;\n-    N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n-    N7 -> N8;\n-    N8 -> N9;\n-    N9 -> N10;\n-    N10 -> N11;\n-    N11 -> N13;\n-    N13 -> N14;\n-    N14 -> N15;\n-    N15 -> N16;\n-    N16 -> N12;\n-    N17 -> N18;\n-    N18 -> N19;\n-    N19 -> N20;\n-    N20 -> N21;\n-    N15 -> N22;\n-    N21 -> N22;\n-    N22 -> N23;\n-    N23 -> N24;\n-    N24 -> N25;\n-    N25 -> N26;\n-    N26 -> N27;\n-    N27 -> N28;\n-    N28 -> N30;\n-    N30 -> N31;\n-    N31 -> N32;\n-    N32 -> N33;\n-    N33 -> N29;\n-    N34 -> N35;\n-    N35 -> N36;\n-    N36 -> N37;\n-    N37 -> N38;\n-    N32 -> N39;\n-    N38 -> N39;\n-    N39 -> N40;\n-    N40 -> N41;\n-    N41 -> N42;\n-    N42 -> N43;\n-    N43 -> N44;\n-    N44 -> N45;\n-    N45 -> N47;\n-    N47 -> N48;\n-    N48 -> N49;\n-    N49 -> N50;\n-    N50 -> N46;\n-    N51 -> N52;\n-    N52 -> N53;\n-    N53 -> N54;\n-    N54 -> N55;\n-    N49 -> N56;\n-    N55 -> N56;\n-    N56 -> N57;\n-    N57 -> N58;\n-    N58 -> N59;\n-    N59 -> N60;\n-    N60 -> N61;\n-    N61 -> N62;\n-    N62 -> N45;\n-    N46 -> N63;\n-    N63 -> N64;\n-    N64 -> N65;\n-    N65 -> N66;\n-    N66 -> N67;\n-    N67 -> N28;\n-    N68 -> N69;\n-    N69 -> N70;\n-    N70 -> N71;\n-    N71 -> N72;\n-    N66 -> N73;\n-    N72 -> N73;\n-    N73 -> N74;\n-    N74 -> N28;\n-    N29 -> N75;\n-    N75 -> N11;\n-    N12 -> N76;\n-    N76 -> N77;\n-    N77 -> N1;\n-}"}, {"sha": "2ee2e48fd10e0d2a451644cc6575623f574184e2", "filename": "src/test/run-make/graphviz-flowgraph/f25.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unreachable_code)]\n-pub fn expr_while_25() {\n-    let mut x = 25;\n-    let mut y = 25;\n-    let mut z = 25;\n-\n-    'a: loop {\n-        if x == 0 { break; \"unreachable\"; }\n-        x -= 1;\n-\n-        'a: loop {\n-            if y == 0 { break; \"unreachable\"; }\n-            y -= 1;\n-\n-            'a: loop {\n-                if z == 0 { break; \"unreachable\"; }\n-                z -= 1;\n-            }\n-\n-            if x > 10 {\n-                continue 'a;\n-                \"unreachable\";\n-            }\n-        }\n-    }\n-}"}, {"sha": "656e90d2d52d7e0f57cf3f1d1add2791df92bd7a", "filename": "src/test/run-pass/diverging-fallback-control-flow.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fdiverging-fallback-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fdiverging-fallback-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiverging-fallback-control-flow.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various cases where we permit an unconstrained variable\n+// to fallback based on control-flow.\n+//\n+// These represent current behavior, but are pretty dubious.  I would\n+// like to revisit these and potentially change them. --nmatsakis\n+\n+#![feature(never_type)]\n+#![feature(loop_break_value)]\n+\n+trait BadDefault {\n+    fn default() -> Self;\n+}\n+\n+impl BadDefault for u32 {\n+    fn default() -> Self {\n+        0\n+    }\n+}\n+\n+impl BadDefault for ! {\n+    fn default() -> ! {\n+        panic!()\n+    }\n+}\n+\n+fn assignment() {\n+    let x;\n+\n+    if true {\n+        x = BadDefault::default();\n+    } else {\n+        x = return;\n+    }\n+}\n+\n+fn assignment_rev() {\n+    let x;\n+\n+    if true {\n+        x = return;\n+    } else {\n+        x = BadDefault::default();\n+    }\n+}\n+\n+fn if_then_else() {\n+    let _x = if true {\n+        BadDefault::default()\n+    } else {\n+        return;\n+    };\n+}\n+\n+fn if_then_else_rev() {\n+    let _x = if true {\n+        return;\n+    } else {\n+        BadDefault::default()\n+    };\n+}\n+\n+fn match_arm() {\n+    let _x = match Ok(BadDefault::default()) {\n+        Ok(v) => v,\n+        Err(()) => return,\n+    };\n+}\n+\n+fn match_arm_rev() {\n+    let _x = match Ok(BadDefault::default()) {\n+        Err(()) => return,\n+        Ok(v) => v,\n+    };\n+}\n+\n+fn loop_break() {\n+    let _x = loop {\n+        if false {\n+            break return;\n+        } else {\n+            break BadDefault::default();\n+        }\n+    };\n+}\n+\n+fn loop_break_rev() {\n+    let _x = loop {\n+        if false {\n+            break return;\n+        } else {\n+            break BadDefault::default();\n+        }\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "664a329c228ae4a3ca52050ee6a2b1812ff38788", "filename": "src/test/run-pass/diverging-fallback-method-chain.rs", "status": "renamed", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fdiverging-fallback-method-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fdiverging-fallback-method-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiverging-fallback-method-chain.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -8,31 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that diverging types default to () (with feature(never_type) disabled).\n+// Test a regression found when building compiler. The `produce()`\n+// error type `T` winds up getting unified with result of `x.parse()`;\n+// the type of the closure given to `unwrap_or_else` needs to be\n+// inferred to `usize`.\n \n-trait Balls: Sized {\n-    fn smeg() -> Result<Self, ()>;\n-}\n-\n-impl Balls for () {\n-    fn smeg() -> Result<(), ()> { Ok(()) }\n-}\n-\n-struct Flah;\n+use std::num::ParseIntError;\n \n-impl Flah {\n-    fn flah<T: Balls>(&self) -> Result<T, ()> {\n-        T::smeg()\n-    }\n-}\n-\n-fn doit() -> Result<(), ()> {\n-    // The type of _ is unconstrained here and should default to ()\n-    let _ = try!(Flah.flah());\n-    Ok(())\n+fn produce<T>() -> Result<&'static str, T> {\n+    Ok(\"22\")\n }\n \n fn main() {\n-    let _ = doit();\n+    let x: usize = produce()\n+        .and_then(|x| x.parse())\n+        .unwrap_or_else(|_| panic!());\n+    println!(\"{}\", x);\n }\n-", "previous_filename": "src/test/run-pass/unit-fallback.rs"}, {"sha": "49f90e7c91f34585597d2709c1472cb0153c1b1b", "filename": "src/test/run-pass/diverging-fallback-option.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fdiverging-fallback-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fdiverging-fallback-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiverging-fallback-option.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+\n+// Here the type of `c` is `Option<?T>`, where `?T` is unconstrained.\n+// Because there is data-flow from the `{ return; }` block, which\n+// diverges and hence has type `!`, into `c`, we will default `?T` to\n+// `!`, and hence this code compiles rather than failing and requiring\n+// a type annotation.\n+\n+fn main() {\n+    let c = Some({ return; });\n+    c.unwrap();\n+}"}, {"sha": "91c70d76eefbcfd436d7ec0758b5af9bde3e7f09", "filename": "src/test/run-pass/issue-39808.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fissue-39808.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Frun-pass%2Fissue-39808.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39808.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unreachable_code)]\n+\n+// Regression test for #39808. The type parameter of `Owned` was\n+// considered to be \"unconstrained\" because the type resulting from\n+// `format!` (`String`) was not being propagated upward, owing to the\n+// fact that the expression diverges.\n+\n+use std::borrow::Cow;\n+\n+fn main() {\n+    let _ = if false {\n+        Cow::Owned(format!(\"{:?}\", panic!()))\n+    } else {\n+        Cow::Borrowed(\"\")\n+    };\n+}"}, {"sha": "790f796fae07f787a64fba8266b46ede5ed7bb65", "filename": "src/test/ui/loop-break-value-no-repeat.rs", "status": "renamed", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Floop-break-value-no-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Floop-break-value-no-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floop-break-value-no-repeat.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn expr_if_onearm_8() {\n-    let x = 8; let _y;\n-    if x > 88 {\n-        _y = 888;\n+#![feature(loop_break_value)]\n+#![allow(unused_variables)]\n+\n+use std::ptr;\n+\n+// Test that we only report **one** error here and that is that\n+// `break` with an expression is illegal in this context. In\n+// particular, we don't report any mismatched types error, which is\n+// besides the point.\n+\n+fn main() {\n+    for _ in &[1,2,3] {\n+        break 22\n     }\n }", "previous_filename": "src/test/run-make/graphviz-flowgraph/f08.rs"}, {"sha": "0d99abd3907d81b40a67e8959a1d9edf747db9f5", "filename": "src/test/ui/loop-break-value-no-repeat.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,8 @@\n+error[E0571]: `break` with value from a `for` loop\n+  --> $DIR/loop-break-value-no-repeat.rs:23:9\n+   |\n+23 |         break 22\n+   |         ^^^^^^^^ can only break with a value inside `loop`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8bed5fba7a2e812346e96ad7e5c75ecd5c8ca6f2", "filename": "src/test/ui/reachable/README.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2FREADME.md?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,7 @@\n+A variety of tests around reachability. These tests in general check\n+two things:\n+\n+- that we get unreachable code warnings in reasonable locations;\n+- that we permit coercions **into** `!` from expressions which\n+  diverge, where an expression \"diverges\" if it must execute some\n+  subexpression of type `!`, or it has type `!` itself."}, {"sha": "87d017adf68193e9e9339abf3a3d767dc341f98d", "filename": "src/test/ui/reachable/expr_add.rs", "status": "renamed", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_add.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn expr_while_10() {\n-    let mut x = 10;\n-    while x > 0 {\n-        x -= 1;\n+#![feature(never_type)]\n+#![allow(unused_variables)]\n+#![deny(unreachable_code)]\n+\n+use std::ops;\n+\n+struct Foo;\n+\n+impl ops::Add<!> for Foo {\n+    type Output = !;\n+    fn add(self, rhs: !) -> ! {\n+        unimplemented!()\n     }\n }\n+\n+fn main() {\n+    let x = Foo + return;\n+}", "previous_filename": "src/test/run-make/graphviz-flowgraph/f10.rs"}, {"sha": "1a2cc252051bfb9dffc07e18fdf0b86b2ff0ed71", "filename": "src/test/ui/reachable/expr_add.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_add.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable expression\n+  --> $DIR/expr_add.rs:27:13\n+   |\n+27 |     let x = Foo + return;\n+   |             ^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_add.rs:13:9\n+   |\n+13 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "cdbdb8dc0dbb3bdbbc8a03ce29b8206ce4330a9e", "filename": "src/test/ui/reachable/expr_again.rs", "status": "renamed", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_again.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_again.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_again.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn decl_x_2() {\n-    let _x : isize;\n+#![feature(box_syntax)]\n+#![allow(unused_variables)]\n+#![deny(unreachable_code)]\n+\n+fn main() {\n+    let x = loop {\n+        continue;\n+        println!(\"hi\");\n+    };\n }", "previous_filename": "src/test/run-make/graphviz-flowgraph/f02.rs"}, {"sha": "bf4e4dc4711cbcfbd6ef39069ae3536ac956a924", "filename": "src/test/ui/reachable/expr_again.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_again.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_again.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_again.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,15 @@\n+error: unreachable statement\n+  --> $DIR/expr_again.rs:18:9\n+   |\n+18 |         println!(\"hi\");\n+   |         ^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_again.rs:13:9\n+   |\n+13 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to previous error\n+"}, {"sha": "af404d03097b62b67fec8a4dfd5c9971e86b6e30", "filename": "src/test/ui/reachable/expr_andand.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+\n+fn foo() {\n+    // No error here.\n+    let x = false && (return);\n+    println!(\"I am not dead.\");\n+}\n+\n+fn main() { }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/reachable/expr_andand.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887"}, {"sha": "00e8be077254706cb716bef81543ed314e0bbe95", "filename": "src/test/ui/reachable/expr_array.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_array.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+#![feature(type_ascription)]\n+\n+fn a() {\n+    // the `22` is unreachable:\n+    let x: [usize; 2] = [return, 22];\n+}\n+\n+fn b() {\n+    // the `array is unreachable:\n+    let x: [usize; 2] = [22, return];\n+}\n+\n+fn main() { }"}, {"sha": "f8dbdb5f8bb66aa9c6097c5a6d18cb6944e80920", "filename": "src/test/ui/reachable/expr_array.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_array.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,20 @@\n+error: unreachable expression\n+  --> $DIR/expr_array.rs:20:34\n+   |\n+20 |     let x: [usize; 2] = [return, 22];\n+   |                                  ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_array.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_array.rs:25:25\n+   |\n+25 |     let x: [usize; 2] = [22, return];\n+   |                         ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1b9357013d27038773fe2ba5280635c96b22017b", "filename": "src/test/ui/reachable/expr_assign.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_assign.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn foo() {\n+    // No error here.\n+    let x;\n+    x = return;\n+}\n+\n+fn bar() {\n+    use std::ptr;\n+    let p: *mut ! = ptr::null_mut::<!>();\n+    unsafe {\n+        // Here we consider the `return` unreachable because\n+        // \"evaluating\" the `*p` has type `!`. This is somewhat\n+        // dubious, I suppose.\n+        *p = return;\n+    }\n+}\n+\n+fn baz() {\n+    let mut i = 0;\n+    *{return; &mut i} = 22;\n+}\n+\n+fn main() { }"}, {"sha": "807f6a1c1d5847eb383d2e1f6bcfcb24ee2f2ea2", "filename": "src/test/ui/reachable/expr_assign.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_assign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_assign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_assign.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,26 @@\n+error: unreachable expression\n+  --> $DIR/expr_assign.rs:20:5\n+   |\n+20 |     x = return;\n+   |     ^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_assign.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_assign.rs:30:14\n+   |\n+30 |         *p = return;\n+   |              ^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_assign.rs:36:15\n+   |\n+36 |     *{return; &mut i} = 22;\n+   |               ^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "093589b4dc83980b94e038ed3d92260440317f85", "filename": "src/test/ui/reachable/expr_block.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_block.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn a() {\n+    // Here the tail expression is considered unreachable:\n+    let x = {\n+        return;\n+        22\n+    };\n+}\n+\n+fn b() {\n+    // Here the `x` assignment is considered unreachable, not the block:\n+    let x = {\n+        return;\n+    };\n+}\n+\n+fn c() {\n+    // Here the `println!` is unreachable:\n+    let x = {\n+        return;\n+        println!(\"foo\");\n+        22\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "542ce1c3fd9cb5b49e7f41743d623128be4505bc", "filename": "src/test/ui/reachable/expr_block.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_block.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,22 @@\n+error: unreachable expression\n+  --> $DIR/expr_block.rs:21:9\n+   |\n+21 |         22\n+   |         ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_block.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable statement\n+  --> $DIR/expr_block.rs:36:9\n+   |\n+36 |         println!(\"foo\");\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "6509b608335afc5b825f5f07a326ec9a6895e0ca", "filename": "src/test/ui/reachable/expr_box.rs", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_box.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn empty_0() {\n+#![feature(box_syntax)]\n+#![allow(unused_variables)]\n+#![deny(unreachable_code)]\n \n+fn main() {\n+    let x = box return;\n+    println!(\"hi\");\n }", "previous_filename": "src/test/run-make/graphviz-flowgraph/f00.rs"}, {"sha": "78ba231cef9fcf2121f0173688ab3710823c13fa", "filename": "src/test/ui/reachable/expr_box.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_box.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable expression\n+  --> $DIR/expr_box.rs:16:13\n+   |\n+16 |     let x = box return;\n+   |             ^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_box.rs:13:9\n+   |\n+13 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "8d9f303df7fdcb74f98048aae943d8a70b166929", "filename": "src/test/ui/reachable/expr_call.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_call.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn foo(x: !, y: usize) { }\n+\n+fn bar(x: !) { }\n+\n+fn a() {\n+    // the `22` is unreachable:\n+    foo(return, 22);\n+}\n+\n+fn b() {\n+    // the call is unreachable:\n+    bar(return);\n+}\n+\n+fn main() { }"}, {"sha": "5526827f59fc9965853df9bc66eb3674e29572ea", "filename": "src/test/ui/reachable/expr_call.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_call.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,20 @@\n+error: unreachable expression\n+  --> $DIR/expr_call.rs:23:17\n+   |\n+23 |     foo(return, 22);\n+   |                 ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_call.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_call.rs:28:5\n+   |\n+28 |     bar(return);\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "926ef864ebf21bb5058e921298035c14018fc57f", "filename": "src/test/ui/reachable/expr_cast.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_cast.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+#![feature(type_ascription)]\n+\n+fn a() {\n+    // the cast is unreachable:\n+    let x = {return} as !;\n+}\n+\n+fn main() { }"}, {"sha": "a22300dcc1398f37c6c0dbee1b349266864a90a1", "filename": "src/test/ui/reachable/expr_cast.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_cast.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable expression\n+  --> $DIR/expr_cast.rs:20:13\n+   |\n+20 |     let x = {return} as !;\n+   |             ^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_cast.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a265e772f359d5cc231d388a04a99a749265ce5", "filename": "src/test/ui/reachable/expr_if.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_if.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn foo() {\n+    if {return} {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+\n+fn bar() {\n+    if {true} {\n+        return;\n+    }\n+    println!(\"I am not dead.\");\n+}\n+\n+fn baz() {\n+    if {true} {\n+        return;\n+    } else {\n+        return;\n+    }\n+    // As the next action to be taken after the if arms, we should\n+    // report the `println!` as unreachable:\n+    println!(\"But I am.\");\n+}\n+\n+fn main() { }"}, {"sha": "2cf17474f6e9dd2ab1ddd152addf393ab004971a", "filename": "src/test/ui/reachable/expr_if.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_if.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,15 @@\n+error: unreachable statement\n+  --> $DIR/expr_if.rs:38:5\n+   |\n+38 |     println!(\"But I am.\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_if.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to previous error\n+"}, {"sha": "3ed4b2dcf0cf843e40b7aac7d883812e1fdaaa21", "filename": "src/test/ui/reachable/expr_loop.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_loop.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn a() {\n+    loop { return; }\n+    println!(\"I am dead.\");\n+}\n+\n+fn b() {\n+    loop {\n+        break;\n+    }\n+    println!(\"I am not dead.\");\n+}\n+\n+fn c() {\n+    loop { return; }\n+    println!(\"I am dead.\");\n+}\n+\n+fn d() {\n+    'outer: loop { loop { break 'outer; } }\n+    println!(\"I am not dead.\");\n+}\n+\n+fn e() {\n+    loop { 'middle: loop { loop { break 'middle; } } }\n+    println!(\"I am dead.\");\n+}\n+\n+fn main() { }"}, {"sha": "6e98e754c54db30d1078dd882e45d004bfaeec0a", "filename": "src/test/ui/reachable/expr_loop.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_loop.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,31 @@\n+error: unreachable statement\n+  --> $DIR/expr_loop.rs:19:5\n+   |\n+19 |     println!(\"I am dead.\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_loop.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: unreachable statement\n+  --> $DIR/expr_loop.rs:31:5\n+   |\n+31 |     println!(\"I am dead.\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: unreachable statement\n+  --> $DIR/expr_loop.rs:41:5\n+   |\n+41 |     println!(\"I am dead.\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "23bdcc035b22773430eadd244a359d9fada4ff83", "filename": "src/test/ui/reachable/expr_match.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_match.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn a() {\n+    // The match is considered unreachable here, because the `return`\n+    // diverges:\n+    match {return} { }\n+}\n+\n+fn b() {\n+    match () { () => return }\n+    println!(\"I am dead\");\n+}\n+\n+fn c() {\n+    match () { () if false => return, () => () }\n+    println!(\"I am not dead\");\n+}\n+\n+fn d() {\n+    match () { () if false => return, () => return }\n+    println!(\"I am dead\");\n+}\n+\n+fn e() {\n+    // Here the compiler fails to figure out that the `println` is dead.\n+    match () { () if return => (), () => return }\n+    println!(\"I am dead\");\n+}\n+\n+fn f() {\n+    match Some(()) { None => (), Some(()) => return }\n+    println!(\"I am not dead\");\n+}\n+\n+fn g() {\n+    match Some(()) { None => return, Some(()) => () }\n+    println!(\"I am not dead\");\n+}\n+\n+fn main() { }"}, {"sha": "f5857a5b345eccbb27c0ee1159574737e9897002", "filename": "src/test/ui/reachable/expr_match.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_match.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,30 @@\n+error: unreachable expression\n+  --> $DIR/expr_match.rs:20:5\n+   |\n+20 |     match {return} { }\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_match.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable statement\n+  --> $DIR/expr_match.rs:25:5\n+   |\n+25 |     println!(\"I am dead\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: unreachable statement\n+  --> $DIR/expr_match.rs:35:5\n+   |\n+35 |     println!(\"I am dead\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "f1d979d7df79d3a19686eca87ac4e82585363951", "filename": "src/test/ui/reachable/expr_method.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_method.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self, x: !, y: usize) { }\n+    fn bar(&self, x: !) { }\n+}\n+\n+fn a() {\n+    // the `22` is unreachable:\n+    Foo.foo(return, 22);\n+}\n+\n+fn b() {\n+    // the call is unreachable:\n+    Foo.bar(return);\n+}\n+\n+fn main() { }"}, {"sha": "177d4352a376ddb175125c1425e7e57891a8d659", "filename": "src/test/ui/reachable/expr_method.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_method.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,20 @@\n+error: unreachable expression\n+  --> $DIR/expr_method.rs:26:21\n+   |\n+26 |     Foo.foo(return, 22);\n+   |                     ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_method.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_method.rs:31:5\n+   |\n+31 |     Foo.bar(return);\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d01304d4034b55cf6102b1fc3f36645d745007cb", "filename": "src/test/ui/reachable/expr_oror.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+\n+fn foo() {\n+    let x = false || (return);\n+    println!(\"I am not dead.\");\n+}\n+\n+fn main() { }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/reachable/expr_oror.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887"}, {"sha": "6078d6d5bde461fcdc82abe0a983b60941615c18", "filename": "src/test/ui/reachable/expr_repeat.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_repeat.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+#![feature(type_ascription)]\n+\n+fn a() {\n+    // the repeat is unreachable:\n+    let x: [usize; 2] = [return; 2];\n+}\n+\n+fn main() { }"}, {"sha": "19afc5dd7b5ee192dc8307c046a6fabaa6d08100", "filename": "src/test/ui/reachable/expr_repeat.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_repeat.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable expression\n+  --> $DIR/expr_repeat.rs:20:25\n+   |\n+20 |     let x: [usize; 2] = [return; 2];\n+   |                         ^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_repeat.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "c640ca06630293615bccaef35ed2f0835a0d59bc", "filename": "src/test/ui/reachable/expr_return.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_return.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+#![feature(type_ascription)]\n+\n+fn a() {\n+    // Here we issue that the \"2nd-innermost\" return is unreachable,\n+    // but we stop there.\n+    let x = {return {return {return;}}};\n+}\n+\n+fn main() { }"}, {"sha": "3eb70a4dd7c848ecc53b7b50d5ce47035c876da5", "filename": "src/test/ui/reachable/expr_return.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_return.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable expression\n+  --> $DIR/expr_return.rs:21:22\n+   |\n+21 |     let x = {return {return {return;}}};\n+   |                      ^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_return.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "09e31819279f2f7cd48cead8fd7258cbad2121a7", "filename": "src/test/ui/reachable/expr_struct.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_struct.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+#![feature(type_ascription)]\n+\n+struct Foo {\n+    a: usize,\n+    b: usize,\n+}\n+\n+fn a() {\n+    // struct expr is unreachable:\n+    let x = Foo { a: 22, b: 33, ..return };\n+}\n+\n+fn b() {\n+    // the `33` is unreachable:\n+    let x = Foo { a: return, b: 33, ..return };\n+}\n+\n+fn c() {\n+    // the `..return` is unreachable:\n+    let x = Foo { a: 22, b: return, ..return };\n+}\n+\n+fn d() {\n+    // the struct expr is unreachable:\n+    let x = Foo { a: 22, b: return };\n+}\n+\n+fn main() { }"}, {"sha": "4b7ac6604132c165b255200be13f61c49b0ae77f", "filename": "src/test/ui/reachable/expr_struct.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_struct.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,32 @@\n+error: unreachable expression\n+  --> $DIR/expr_struct.rs:25:13\n+   |\n+25 |     let x = Foo { a: 22, b: 33, ..return };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_struct.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_struct.rs:30:33\n+   |\n+30 |     let x = Foo { a: return, b: 33, ..return };\n+   |                                 ^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_struct.rs:35:39\n+   |\n+35 |     let x = Foo { a: 22, b: return, ..return };\n+   |                                       ^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_struct.rs:40:13\n+   |\n+40 |     let x = Foo { a: 22, b: return };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "7c75296de6c54c83daa862e37fc4849794a4b2bd", "filename": "src/test/ui/reachable/expr_tup.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_tup.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+#![feature(type_ascription)]\n+\n+fn a() {\n+    // the `2` is unreachable:\n+    let x: (usize, usize) = (return, 2);\n+}\n+\n+fn b() {\n+    // the tuple is unreachable:\n+    let x: (usize, usize) = (2, return);\n+}\n+\n+fn main() { }"}, {"sha": "63f477fd0c373a9a8b37111b1657380e410b8733", "filename": "src/test/ui/reachable/expr_tup.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_tup.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_tup.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_tup.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,20 @@\n+error: unreachable expression\n+  --> $DIR/expr_tup.rs:20:38\n+   |\n+20 |     let x: (usize, usize) = (return, 2);\n+   |                                      ^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_tup.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable expression\n+  --> $DIR/expr_tup.rs:25:29\n+   |\n+25 |     let x: (usize, usize) = (2, return);\n+   |                             ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2fa277c382e87131a95f27db402f5293c3e874b4", "filename": "src/test/ui/reachable/expr_type.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_type.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+#![feature(type_ascription)]\n+\n+fn a() {\n+    // the cast is unreachable:\n+    let x = {return}: !;\n+}\n+\n+fn main() { }"}, {"sha": "6ed79974ccb77c1aea43d4eddfbecc92102215fd", "filename": "src/test/ui/reachable/expr_type.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_type.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable expression\n+  --> $DIR/expr_type.rs:20:13\n+   |\n+20 |     let x = {return}: !;\n+   |             ^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_type.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "57901fbaa7c44881ec6ad0bc6700a49b079f7cee", "filename": "src/test/ui/reachable/expr_unary.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn foo() {\n+    let x: ! = ! { return; 22 };\n+}\n+\n+fn main() { }"}, {"sha": "11172652d84450bde5cfa592d09b015c78f99ad1", "filename": "src/test/ui/reachable/expr_unary.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,8 @@\n+error: cannot apply unary operator `!` to type `!`\n+  --> $DIR/expr_unary.rs:18:16\n+   |\n+18 |     let x: ! = ! { return; 22 };\n+   |                ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7dcd609fbc8f4ba04afc56dd1dab2f9cf8c730bb", "filename": "src/test/ui/reachable/expr_while.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+#![deny(unreachable_code)]\n+#![feature(never_type)]\n+\n+fn foo() {\n+    while {return} {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+\n+fn bar() {\n+    while {true} {\n+        return;\n+    }\n+    println!(\"I am not dead.\");\n+}\n+\n+fn baz() {\n+    // Here, we cite the `while` loop as dead.\n+    while {return} {\n+        println!(\"I am dead.\");\n+    }\n+    println!(\"I am, too.\");\n+}\n+\n+fn main() { }"}, {"sha": "066cfc86c6462c534a35260d76975bd5c40b091a", "filename": "src/test/ui/reachable/expr_while.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -0,0 +1,31 @@\n+error: unreachable statement\n+  --> $DIR/expr_while.rs:19:9\n+   |\n+19 |         println!(\"Hello, world!\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_while.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: unreachable statement\n+  --> $DIR/expr_while.rs:33:9\n+   |\n+33 |         println!(\"I am dead.\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: unreachable statement\n+  --> $DIR/expr_while.rs:35:5\n+   |\n+35 |     println!(\"I am, too.\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "5be23d8ca48c8cc5a2717733cf0dbd66bce576a0", "filename": "src/test/ui/resolve/token-error-correct-3.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ae95e548929f4924905b2e8f87f2dd57d8bc887/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr?ref=7ae95e548929f4924905b2e8f87f2dd57d8bc887", "patch": "@@ -36,10 +36,6 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `()`\n               found type `std::result::Result<bool, std::io::Error>`\n-   = help: here are some functions which might fulfill your needs:\n-           - .unwrap()\n-           - .unwrap_err()\n-           - .unwrap_or_default()\n \n error: aborting due to previous error\n "}]}