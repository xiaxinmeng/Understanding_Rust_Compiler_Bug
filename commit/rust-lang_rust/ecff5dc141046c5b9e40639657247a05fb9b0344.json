{"sha": "ecff5dc141046c5b9e40639657247a05fb9b0344", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZmY1ZGMxNDEwNDZjNWI5ZTQwNjM5NjU3MjQ3YTA1ZmI5YjAzNDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-08T12:54:29Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-08T12:55:28Z"}, "message": "Cleanup", "tree": {"sha": "871ebe102579fd2c8a35d2d5df4ed18b27219fd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/871ebe102579fd2c8a35d2d5df4ed18b27219fd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecff5dc141046c5b9e40639657247a05fb9b0344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecff5dc141046c5b9e40639657247a05fb9b0344", "html_url": "https://github.com/rust-lang/rust/commit/ecff5dc141046c5b9e40639657247a05fb9b0344", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecff5dc141046c5b9e40639657247a05fb9b0344/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c0409e0c7249fe793b5d05829fcd984d06ec770", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0409e0c7249fe793b5d05829fcd984d06ec770", "html_url": "https://github.com/rust-lang/rust/commit/7c0409e0c7249fe793b5d05829fcd984d06ec770"}], "stats": {"total": 164, "additions": 64, "deletions": 100}, "files": [{"sha": "41855f22e85d62d6d8c8d282262e6d84c68f16be", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecff5dc141046c5b9e40639657247a05fb9b0344/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ecff5dc141046c5b9e40639657247a05fb9b0344/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ecff5dc141046c5b9e40639657247a05fb9b0344", "patch": "@@ -1209,7 +1209,6 @@ dependencies = [\n name = \"ra_toolchain\"\n version = \"0.1.0\"\n dependencies = [\n- \"anyhow\",\n  \"home\",\n ]\n "}, {"sha": "68dcee2851d3191d08ddac39b0eb365f4f946a50", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=ecff5dc141046c5b9e40639657247a05fb9b0344", "patch": "@@ -16,7 +16,6 @@ use lsp_types::{\n     CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n     WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n-use ra_toolchain::get_path_for_executable;\n \n use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n@@ -216,10 +215,10 @@ impl FlycheckThread {\n \n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand { command, all_targets, all_features, extra_args } => {\n-                let mut cmd = Command::new(get_path_for_executable(\"cargo\").unwrap());\n+                let mut cmd = Command::new(ra_toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"]);\n-                cmd.arg(self.workspace_root.join(\"Cargo.toml\"));\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.workspace_root.join(\"Cargo.toml\"));\n                 if *all_targets {\n                     cmd.arg(\"--all-targets\");\n                 }"}, {"sha": "082af4f9699d06b5ec86c9d50d9a191b0d25d7fe", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=ecff5dc141046c5b9e40639657247a05fb9b0344", "patch": "@@ -11,7 +11,6 @@ use anyhow::{Context, Result};\n use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId};\n use ra_arena::{Arena, Idx};\n use ra_db::Edition;\n-use ra_toolchain::get_path_for_executable;\n use rustc_hash::FxHashMap;\n \n /// `CargoWorkspace` represents the logical structure of, well, a Cargo\n@@ -147,7 +146,7 @@ impl CargoWorkspace {\n         cargo_features: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n         let mut meta = MetadataCommand::new();\n-        meta.cargo_path(get_path_for_executable(\"cargo\")?);\n+        meta.cargo_path(ra_toolchain::cargo());\n         meta.manifest_path(cargo_toml);\n         if cargo_features.all_features {\n             meta.features(CargoOpt::AllFeatures);\n@@ -289,7 +288,7 @@ pub fn load_extern_resources(\n     cargo_toml: &Path,\n     cargo_features: &CargoConfig,\n ) -> Result<ExternResources> {\n-    let mut cmd = Command::new(get_path_for_executable(\"cargo\")?);\n+    let mut cmd = Command::new(ra_toolchain::cargo());\n     cmd.args(&[\"check\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n     if cargo_features.all_features {\n         cmd.arg(\"--all-features\");"}, {"sha": "5a0a87ed7d44428df5655d23ba62427534e8b670", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=ecff5dc141046c5b9e40639657247a05fb9b0344", "patch": "@@ -8,13 +8,12 @@ use std::{\n     fs::{read_dir, File, ReadDir},\n     io::{self, BufReader},\n     path::{Path, PathBuf},\n-    process::Command,\n+    process::{Command, Output},\n };\n \n use anyhow::{bail, Context, Result};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateName, Edition, Env, ExternSource, ExternSourceId, FileId};\n-use ra_toolchain::get_path_for_executable;\n use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n \n@@ -568,25 +567,18 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n         }\n     }\n \n-    match (|| -> Result<String> {\n+    let rustc_cfgs = || -> Result<String> {\n         // `cfg(test)` and `cfg(debug_assertion)` are handled outside, so we suppress them here.\n-        let mut cmd = Command::new(get_path_for_executable(\"rustc\")?);\n+        let mut cmd = Command::new(ra_toolchain::rustc());\n         cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n         if let Some(target) = target {\n             cmd.args(&[\"--target\", target.as_str()]);\n         }\n-        let output = cmd.output().context(\"Failed to get output from rustc --print cfg -O\")?;\n-        if !output.status.success() {\n-            bail!(\n-                \"rustc --print cfg -O exited with exit code ({})\",\n-                output\n-                    .status\n-                    .code()\n-                    .map_or(String::from(\"no exit code\"), |code| format!(\"{}\", code))\n-            );\n-        }\n+        let output = output(cmd)?;\n         Ok(String::from_utf8(output.stdout)?)\n-    })() {\n+    }();\n+\n+    match rustc_cfgs {\n         Ok(rustc_cfgs) => {\n             for line in rustc_cfgs.lines() {\n                 match line.find('=') {\n@@ -599,8 +591,16 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n                 }\n             }\n         }\n-        Err(e) => log::error!(\"failed to get rustc cfgs: {}\", e),\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n     }\n \n     cfg_options\n }\n+\n+fn output(mut cmd: Command) -> Result<Output> {\n+    let output = cmd.output().with_context(|| format!(\"{:?} failed\", cmd))?;\n+    if !output.status.success() {\n+        bail!(\"{:?} failed, {}\", cmd, output.status)\n+    }\n+    Ok(output)\n+}"}, {"sha": "a8a196e64c963f68435babe2ec8d703f9b292032", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=ecff5dc141046c5b9e40639657247a05fb9b0344", "patch": "@@ -3,12 +3,13 @@\n use std::{\n     env, ops,\n     path::{Path, PathBuf},\n-    process::{Command, Output},\n+    process::Command,\n };\n \n-use anyhow::{bail, Context, Result};\n+use anyhow::{bail, Result};\n use ra_arena::{Arena, Idx};\n-use ra_toolchain::get_path_for_executable;\n+\n+use crate::output;\n \n #[derive(Default, Debug, Clone)]\n pub struct Sysroot {\n@@ -85,50 +86,22 @@ impl Sysroot {\n     }\n }\n \n-fn create_command_text(program: &str, args: &[&str]) -> String {\n-    format!(\"{} {}\", program, args.join(\" \"))\n-}\n-\n-fn run_command_in_cargo_dir(\n-    cargo_toml: impl AsRef<Path>,\n-    program: impl AsRef<Path>,\n-    args: &[&str],\n-) -> Result<Output> {\n-    let program = program.as_ref().as_os_str().to_str().expect(\"Invalid Unicode in path\");\n-    let output = Command::new(program)\n-        .current_dir(cargo_toml.as_ref().parent().unwrap())\n-        .args(args)\n-        .output()\n-        .context(format!(\"{} failed\", create_command_text(program, args)))?;\n-    if !output.status.success() {\n-        match output.status.code() {\n-            Some(code) => bail!(\n-                \"failed to run the command: '{}' exited with code {}\",\n-                create_command_text(program, args),\n-                code\n-            ),\n-            None => bail!(\n-                \"failed to run the command: '{}' terminated by signal\",\n-                create_command_text(program, args)\n-            ),\n-        };\n-    }\n-    Ok(output)\n-}\n-\n fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         return Ok(path.into());\n     }\n-    let rustc = get_path_for_executable(\"rustc\")?;\n-    let rustc_output = run_command_in_cargo_dir(cargo_toml, &rustc, &[\"--print\", \"sysroot\"])?;\n+    let current_dir = cargo_toml.parent().unwrap();\n+    let mut rustc = Command::new(ra_toolchain::rustc());\n+    rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n+    let rustc_output = output(rustc)?;\n     let stdout = String::from_utf8(rustc_output.stdout)?;\n     let sysroot_path = Path::new(stdout.trim());\n     let src_path = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n \n     if !src_path.exists() {\n-        let rustup = get_path_for_executable(\"rustup\")?;\n-        run_command_in_cargo_dir(cargo_toml, &rustup, &[\"component\", \"add\", \"rust-src\"])?;\n+        let mut rustup = Command::new(ra_toolchain::rustup());\n+        rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n+        let _output = output(rustup)?;\n     }\n     if !src_path.exists() {\n         bail!("}, {"sha": "1873fbe16783f8d33523f6d32399137c72e89e01", "filename": "crates/ra_toolchain/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_toolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_toolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2FCargo.toml?ref=ecff5dc141046c5b9e40639657247a05fb9b0344", "patch": "@@ -5,5 +5,4 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n-anyhow = \"1.0.26\"\n home = \"0.5.3\""}, {"sha": "3c307a0eace45e4be22bdb2b2eb8de6a91f2695c", "filename": "crates/ra_toolchain/src/lib.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecff5dc141046c5b9e40639657247a05fb9b0344/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2Fsrc%2Flib.rs?ref=ecff5dc141046c5b9e40639657247a05fb9b0344", "patch": "@@ -1,21 +1,26 @@\n //! This crate contains a single public function\n //! [`get_path_for_executable`](fn.get_path_for_executable.html).\n //! See docs there for more information.\n-use std::{\n-    env,\n-    path::{Path, PathBuf},\n-    process::Command,\n-};\n+use std::{env, iter, path::PathBuf};\n \n-use anyhow::{bail, Result};\n+pub fn cargo() -> PathBuf {\n+    get_path_for_executable(\"cargo\")\n+}\n+\n+pub fn rustc() -> PathBuf {\n+    get_path_for_executable(\"rustc\")\n+}\n+\n+pub fn rustup() -> PathBuf {\n+    get_path_for_executable(\"rustup\")\n+}\n \n /// Return a `PathBuf` to use for the given executable.\n ///\n /// E.g., `get_path_for_executable(\"cargo\")` may return just `cargo` if that\n /// gives a valid Cargo executable; or it may return a full path to a valid\n /// Cargo.\n-pub fn get_path_for_executable(executable_name: &'static str) -> Result<PathBuf> {\n-    assert!(executable_name == \"rustc\" || executable_name == \"cargo\");\n+fn get_path_for_executable(executable_name: &'static str) -> PathBuf {\n     // The current implementation checks three places for an executable to use:\n     // 1) Appropriate environment variable (erroring if this is set but not a usable executable)\n     //      example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc\n@@ -25,45 +30,35 @@ pub fn get_path_for_executable(executable_name: &'static str) -> Result<PathBuf>\n     //      example: for cargo, this tries ~/.cargo/bin/cargo\n     //      It seems that this is a reasonable place to try for cargo, rustc, and rustup\n     let env_var = executable_name.to_ascii_uppercase();\n-    if let Ok(path) = env::var(&env_var) {\n-        return if is_valid_executable(&path) {\n-            Ok(path.into())\n-        } else {\n-            bail!(\n-                \"`{}` environment variable points to something that's not a valid executable\",\n-                env_var\n-            )\n-        };\n+    if let Some(path) = env::var_os(&env_var) {\n+        return path.into();\n     }\n \n-    if is_valid_executable(executable_name) {\n-        return Ok(executable_name.into());\n+    if lookup_in_path(executable_name) {\n+        return executable_name.into();\n     }\n \n     if let Some(mut path) = home::home_dir() {\n         path.push(\".cargo\");\n         path.push(\"bin\");\n         path.push(executable_name);\n-        if is_valid_executable(&path) {\n-            return Ok(path);\n+        if path.is_file() {\n+            return path;\n         }\n     }\n-    // This error message may also be caused by $PATH or $CARGO/$RUSTC/etc not being set correctly\n-    // for VSCode, even if they are set correctly in a terminal.\n-    // On macOS in particular, launching VSCode from terminal with `code <dirname>` causes VSCode\n-    // to inherit environment variables including $PATH, $CARGO, $RUSTC, etc from that terminal;\n-    // but launching VSCode from Dock does not inherit environment variables from a terminal.\n-    // For more discussion, see #3118.\n-    bail!(\n-        \"Failed to find `{}` executable. Make sure `{}` is in `$PATH`, or set `${}` to point to a valid executable.\",\n-        executable_name, executable_name, env_var\n-    )\n+    executable_name.into()\n }\n \n-/// Does the given `Path` point to a usable executable?\n-///\n-/// (assumes the executable takes a `--version` switch and writes to stdout,\n-/// which is true for `cargo`, `rustc`, and `rustup`)\n-fn is_valid_executable(p: &'static str) -> bool {\n-    Command::new(p).arg(\"--version\").output().is_ok()\n+fn lookup_in_path(exec: &str) -> bool {\n+    let paths = env::var_os(\"PATH\").unwrap_or_default();\n+    let mut candidates = env::split_paths(&paths).flat_map(|path| {\n+        let candidate = path.join(&exec);\n+        let with_exe = if env::consts::EXE_EXTENSION == \"\" {\n+            None\n+        } else {\n+            Some(candidate.with_extension(env::consts::EXE_EXTENSION))\n+        };\n+        iter::once(candidate).chain(with_exe)\n+    });\n+    candidates.any(|it| it.is_file())\n }"}]}