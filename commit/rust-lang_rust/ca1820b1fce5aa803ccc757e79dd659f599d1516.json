{"sha": "ca1820b1fce5aa803ccc757e79dd659f599d1516", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMTgyMGIxZmNlNWFhODAzY2NjNzU3ZTc5ZGQ2NTlmNTk5ZDE1MTY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-10-14T20:08:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-11-21T21:18:08Z"}, "message": "core: Convert Char methods to by-val self\n\nMethods on primitmive Copy types generally should take `self`.\n\n[breaking-change]", "tree": {"sha": "5965bddb8efdc6d6a8118369faea709259c4da35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5965bddb8efdc6d6a8118369faea709259c4da35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca1820b1fce5aa803ccc757e79dd659f599d1516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1820b1fce5aa803ccc757e79dd659f599d1516", "html_url": "https://github.com/rust-lang/rust/commit/ca1820b1fce5aa803ccc757e79dd659f599d1516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca1820b1fce5aa803ccc757e79dd659f599d1516/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5928f6c8b672b7569bc9349dda94cdde0a8a3117", "url": "https://api.github.com/repos/rust-lang/rust/commits/5928f6c8b672b7569bc9349dda94cdde0a8a3117", "html_url": "https://github.com/rust-lang/rust/commit/5928f6c8b672b7569bc9349dda94cdde0a8a3117"}], "stats": {"total": 54, "additions": 27, "deletions": 27}, "files": [{"sha": "55d2424eba6e3dfd2ad93b118b6354f419be9431", "filename": "src/libcore/char.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ca1820b1fce5aa803ccc757e79dd659f599d1516/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1820b1fce5aa803ccc757e79dd659f599d1516/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=ca1820b1fce5aa803ccc757e79dd659f599d1516", "patch": "@@ -209,7 +209,7 @@ pub trait Char {\n     ///\n     /// Panics if given a radix > 36.\n     #[deprecated = \"use is_digit\"]\n-    fn is_digit_radix(&self, radix: uint) -> bool;\n+    fn is_digit_radix(self, radix: uint) -> bool;\n \n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -225,7 +225,7 @@ pub trait Char {\n     ///\n     /// Fails if given a radix > 36.\n     #[unstable = \"pending error conventions\"]\n-    fn is_digit(&self, radix: uint) -> bool;\n+    fn is_digit(self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -239,7 +239,7 @@ pub trait Char {\n     ///\n     /// Panics if given a radix outside the range [0..36].\n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn to_digit(&self, radix: uint) -> Option<uint>;\n+    fn to_digit(self, radix: uint) -> Option<uint>;\n \n     /// Converts a number to the character representing it.\n     ///\n@@ -266,7 +266,7 @@ pub trait Char {\n     /// * Characters in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`.\n     /// * Characters above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`.\n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_unicode(&self, f: |char|);\n+    fn escape_unicode(self, f: |char|);\n \n     /// Returns a 'default' ASCII and C++11-like literal escape of a\n     /// character.\n@@ -281,22 +281,22 @@ pub trait Char {\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_default(&self, f: |char|);\n+    fn escape_default(self, f: |char|);\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n     #[deprecated = \"use len_utf8\"]\n-    fn len_utf8_bytes(&self) -> uint;\n+    fn len_utf8_bytes(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n     #[unstable = \"pending trait organization\"]\n-    fn len_utf8(&self) -> uint;\n+    fn len_utf8(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n     #[unstable = \"pending trait organization\"]\n-    fn len_utf16(&self) -> uint;\n+    fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n@@ -318,25 +318,25 @@ pub trait Char {\n #[experimental = \"trait is experimental\"]\n impl Char for char {\n     #[deprecated = \"use is_digit\"]\n-    fn is_digit_radix(&self, radix: uint) -> bool { self.is_digit(radix) }\n+    fn is_digit_radix(self, radix: uint) -> bool { self.is_digit(radix) }\n \n     #[unstable = \"pending trait organization\"]\n-    fn is_digit(&self, radix: uint) -> bool {\n+    fn is_digit(self, radix: uint) -> bool {\n         match self.to_digit(radix) {\n             Some(_) => true,\n             None    => false,\n         }\n     }\n \n     #[unstable = \"pending trait organization\"]\n-    fn to_digit(&self, radix: uint) -> Option<uint> {\n+    fn to_digit(self, radix: uint) -> Option<uint> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n         }\n-        let val = match *self {\n-          '0' ... '9' => *self as uint - ('0' as uint),\n-          'a' ... 'z' => *self as uint + 10u - ('a' as uint),\n-          'A' ... 'Z' => *self as uint + 10u - ('A' as uint),\n+        let val = match self {\n+          '0' ... '9' => self as uint - ('0' as uint),\n+          'a' ... 'z' => self as uint + 10u - ('a' as uint),\n+          'A' ... 'Z' => self as uint + 10u - ('A' as uint),\n           _ => return None,\n         };\n         if val < radix { Some(val) }\n@@ -351,19 +351,19 @@ impl Char for char {\n     fn from_u32(i: u32) -> Option<char> { from_u32(i) }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_unicode(&self, f: |char|) {\n+    fn escape_unicode(self, f: |char|) {\n         // avoid calling str::to_str_radix because we don't really need to allocate\n         // here.\n         f('\\\\');\n         let pad = match () {\n-            _ if *self <= '\\xff'    => { f('x'); 2 }\n-            _ if *self <= '\\uffff'  => { f('u'); 4 }\n+            _ if self <= '\\xff'    => { f('x'); 2 }\n+            _ if self <= '\\uffff'  => { f('u'); 4 }\n             _                   => { f('U'); 8 }\n         };\n         for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n             let offset = offset as uint;\n             unsafe {\n-                match ((*self as i32) >> offset) & 0xf {\n+                match ((self as i32) >> offset) & 0xf {\n                     i @ 0 ... 9 => { f(transmute('0' as i32 + i)); }\n                     i => { f(transmute('a' as i32 + (i - 10))); }\n                 }\n@@ -372,27 +372,27 @@ impl Char for char {\n     }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_default(&self, f: |char|) {\n-        match *self {\n+    fn escape_default(self, f: |char|) {\n+        match self {\n             '\\t' => { f('\\\\'); f('t'); }\n             '\\r' => { f('\\\\'); f('r'); }\n             '\\n' => { f('\\\\'); f('n'); }\n             '\\\\' => { f('\\\\'); f('\\\\'); }\n             '\\'' => { f('\\\\'); f('\\''); }\n             '\"'  => { f('\\\\'); f('\"'); }\n-            '\\x20' ... '\\x7e' => { f(*self); }\n+            '\\x20' ... '\\x7e' => { f(self); }\n             _ => self.escape_unicode(f),\n         }\n     }\n \n     #[inline]\n     #[deprecated = \"use len_utf8\"]\n-    fn len_utf8_bytes(&self) -> uint { self.len_utf8() }\n+    fn len_utf8_bytes(self) -> uint { self.len_utf8() }\n \n     #[inline]\n     #[unstable = \"pending trait organization\"]\n-    fn len_utf8(&self) -> uint {\n-        let code = *self as u32;\n+    fn len_utf8(self) -> uint {\n+        let code = self as u32;\n         match () {\n             _ if code < MAX_ONE_B   => 1u,\n             _ if code < MAX_TWO_B   => 2u,\n@@ -403,8 +403,8 @@ impl Char for char {\n \n     #[inline]\n     #[unstable = \"pending trait organization\"]\n-    fn len_utf16(&self) -> uint {\n-        let ch = *self as u32;\n+    fn len_utf16(self) -> uint {\n+        let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n     }\n "}]}