{"sha": "0b54d313592c76e7beebaa12ad029925b63dd971", "node_id": "C_kwDOAAsO6NoAKDBiNTRkMzEzNTkyYzc2ZTdiZWViYWExMmFkMDI5OTI1YjYzZGQ5NzE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-12T00:59:01Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-12T01:12:00Z"}, "message": "Remove no_completions_required from CompletionContext", "tree": {"sha": "9bf0e4bda6e36c792538db11bd288c770c5cd2f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bf0e4bda6e36c792538db11bd288c770c5cd2f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b54d313592c76e7beebaa12ad029925b63dd971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b54d313592c76e7beebaa12ad029925b63dd971", "html_url": "https://github.com/rust-lang/rust/commit/0b54d313592c76e7beebaa12ad029925b63dd971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b54d313592c76e7beebaa12ad029925b63dd971/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119ba82e4b099bf33a9eb266e518f010a6bae7be", "url": "https://api.github.com/repos/rust-lang/rust/commits/119ba82e4b099bf33a9eb266e518f010a6bae7be", "html_url": "https://github.com/rust-lang/rust/commit/119ba82e4b099bf33a9eb266e518f010a6bae7be"}], "stats": {"total": 146, "additions": 52, "deletions": 94}, "files": [{"sha": "ac782352fcb54928116c78b212845aaccb0ef4fd", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=0b54d313592c76e7beebaa12ad029925b63dd971", "patch": "@@ -163,6 +163,7 @@ fn add_keyword(acc: &mut Completions, ctx: &CompletionContext, kw: &str, snippet\n     match ctx.config.snippet_cap {\n         Some(cap) => {\n             if snippet.ends_with('}') && ctx.incomplete_let {\n+                // complete block expression snippets with a trailing semicolon, if inside an incomplete let\n                 cov_mark::hit!(let_semi);\n                 item.insert_snippet(cap, format!(\"{};\", snippet));\n             } else {"}, {"sha": "b8a50442bc6e80fb56eb20871eb5c6c5b202f1a2", "filename": "crates/ide_completion/src/completions/lifetime.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=0b54d313592c76e7beebaa12ad029925b63dd971", "patch": "@@ -8,7 +8,7 @@\n //! show up for normal completions, or they won't show completions other than lifetimes depending\n //! on the fixture input.\n use hir::{known, ScopeDef};\n-use syntax::ast;\n+use syntax::{ast, TokenText};\n \n use crate::{\n     completions::Completions,\n@@ -19,24 +19,24 @@ use crate::{\n pub(crate) fn complete_lifetime(acc: &mut Completions, ctx: &CompletionContext) {\n     let lp = match &ctx.lifetime_ctx {\n         Some(LifetimeContext::Lifetime) => None,\n-        Some(LifetimeContext::LifetimeParam(param)) => param.as_ref(),\n+        Some(LifetimeContext::LifetimeParam { is_decl: false, param }) => Some(param),\n         _ => return,\n     };\n-    let lp_string;\n     let param_lifetime = match (&ctx.name_syntax, lp.and_then(|lp| lp.lifetime())) {\n         (Some(ast::NameLike::Lifetime(lt)), Some(lp)) if lp == lt.clone() => return,\n-        (Some(_), Some(lp)) => {\n-            lp_string = lp.to_string();\n-            Some(&*lp_string)\n-        }\n+        (Some(_), Some(lp)) => Some(lp),\n         _ => None,\n     };\n+    let param_lifetime = param_lifetime.as_ref().map(ast::Lifetime::text);\n+    let param_lifetime = param_lifetime.as_ref().map(TokenText::as_str);\n \n     ctx.scope.process_all_names(&mut |name, res| {\n-        if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) = res {\n-            if param_lifetime != Some(&*name.to_smol_str()) {\n-                acc.add_lifetime(ctx, name);\n-            }\n+        if matches!(\n+            res,\n+            ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_))\n+                 if param_lifetime != Some(&*name.to_smol_str())\n+        ) {\n+            acc.add_lifetime(ctx, name);\n         }\n     });\n     if param_lifetime.is_none() {\n@@ -195,6 +195,12 @@ fn foo2<'lifetime, T>() where T: Trait<Item = 'a$0> {}\n     fn complete_lifetime_in_param_list() {\n         check(\n             r#\"\n+fn foo<'$0>() {}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+        check(\n+            r#\"\n fn foo<'a$0>() {}\n \"#,\n             expect![[r#\"\"#]],"}, {"sha": "bf841ee2b7600f88deb8b41c0a970f0bccc8e433", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=0b54d313592c76e7beebaa12ad029925b63dd971", "patch": "@@ -24,8 +24,8 @@ use text_edit::Indel;\n \n use crate::{\n     patterns::{\n-        determine_location, determine_prev_sibling, for_is_prev2, inside_impl_trait_block,\n-        is_in_loop_body, previous_token, ImmediateLocation, ImmediatePrevSibling,\n+        determine_location, determine_prev_sibling, for_is_prev2, is_in_loop_body, previous_token,\n+        ImmediateLocation, ImmediatePrevSibling,\n     },\n     CompletionConfig,\n };\n@@ -94,7 +94,7 @@ pub(super) struct PatternContext {\n \n #[derive(Debug)]\n pub(super) enum LifetimeContext {\n-    LifetimeParam(Option<ast::LifetimeParam>),\n+    LifetimeParam { is_decl: bool, param: ast::LifetimeParam },\n     Lifetime,\n     LabelRef,\n     LabelDef,\n@@ -115,6 +115,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a RootDatabase,\n     pub(super) config: &'a CompletionConfig,\n     pub(super) position: FilePosition,\n+\n     /// The token before the cursor, in the original file.\n     pub(super) original_token: SyntaxToken,\n     /// The token before the cursor, in the macro-expanded file.\n@@ -146,32 +147,22 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) existing_derives: FxHashSet<hir::Macro>,\n \n     pub(super) locals: Vec<(Name, Local)>,\n-\n-    no_completion_required: bool,\n }\n \n impl<'a> CompletionContext<'a> {\n-    /// Checks whether completions in that particular case don't make much sense.\n-    /// Examples:\n-    /// - `fn $0` -- we expect function name, it's unlikely that \"hint\" will be helpful.\n-    ///   Exception for this case is `impl Trait for Foo`, where we would like to hint trait method names.\n-    /// - `for _ i$0` -- obviously, it'll be \"in\" keyword.\n-    pub(crate) fn no_completion_required(&self) -> bool {\n-        self.no_completion_required\n-    }\n-\n     /// The range of the identifier that is being completed.\n     pub(crate) fn source_range(&self) -> TextRange {\n         // check kind of macro-expanded token, but use range of original token\n         let kind = self.token.kind();\n-        if kind == IDENT || kind == LIFETIME_IDENT || kind == UNDERSCORE || kind.is_keyword() {\n-            self.original_token.text_range()\n-        } else if kind == CHAR {\n-            // assume we are completing a lifetime but the user has only typed the '\n-            cov_mark::hit!(completes_if_lifetime_without_idents);\n-            TextRange::at(self.original_token.text_range().start(), TextSize::from(1))\n-        } else {\n-            TextRange::empty(self.position.offset)\n+        match kind {\n+            CHAR => {\n+                // assume we are completing a lifetime but the user has only typed the '\n+                cov_mark::hit!(completes_if_lifetime_without_idents);\n+                TextRange::at(self.original_token.text_range().start(), TextSize::from(1))\n+            }\n+            IDENT | LIFETIME_IDENT | UNDERSCORE => self.original_token.text_range(),\n+            _ if kind.is_keyword() => self.original_token.text_range(),\n+            _ => TextRange::empty(self.position.offset),\n         }\n     }\n \n@@ -453,7 +444,6 @@ impl<'a> CompletionContext<'a> {\n             path_context: None,\n             locals,\n             incomplete_let: false,\n-            no_completion_required: false,\n             existing_derives: Default::default(),\n         };\n         ctx.expand_and_fill(\n@@ -740,24 +730,24 @@ impl<'a> CompletionContext<'a> {\n     ) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n-        self.previous_token = previous_token(syntax_element.clone());\n-        self.no_completion_required = {\n-            let inside_impl_trait_block = inside_impl_trait_block(syntax_element.clone());\n-            let fn_is_prev = self.previous_token_is(T![fn]);\n-            let for_is_prev2 = for_is_prev2(syntax_element.clone());\n-            (fn_is_prev && !inside_impl_trait_block) || for_is_prev2\n-        };\n+        if for_is_prev2(syntax_element.clone()) {\n+            // for pat $0\n+            // there is nothing to complete here except `in` keyword\n+            // don't bother populating the context\n+            // FIXME: the completion calculations should end up good enough\n+            // such that this special case becomes unnecessary\n+            return;\n+        }\n \n+        self.previous_token = previous_token(syntax_element.clone());\n         self.fake_attribute_under_caret = syntax_element.ancestors().find_map(ast::Attr::cast);\n \n         self.incomplete_let =\n             syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n                 it.syntax().text_range().end() == syntax_element.text_range().end()\n             });\n \n-        let (expected_type, expected_name) = self.expected_type_and_name();\n-        self.expected_type = expected_type;\n-        self.expected_name = expected_name;\n+        (self.expected_type, self.expected_name) = self.expected_type_and_name();\n \n         // Overwrite the path kind for derives\n         if let Some((original_file, file_with_fake_ident, offset)) = derive_ctx {\n@@ -808,8 +798,7 @@ impl<'a> CompletionContext<'a> {\n \n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n-                self.lifetime_ctx =\n-                    Self::classify_lifetime(&self.sema, original_file, lifetime, offset);\n+                self.lifetime_ctx = Self::classify_lifetime(&self.sema, original_file, lifetime);\n             }\n             ast::NameLike::NameRef(name_ref) => {\n                 if let Some((path_ctx, pat_ctx)) =\n@@ -826,10 +815,9 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_lifetime(\n-        sema: &Semantics<RootDatabase>,\n-        original_file: &SyntaxNode,\n+        _sema: &Semantics<RootDatabase>,\n+        _original_file: &SyntaxNode,\n         lifetime: ast::Lifetime,\n-        offset: TextSize,\n     ) -> Option<LifetimeContext> {\n         let parent = lifetime.syntax().parent()?;\n         if parent.kind() == ERROR {\n@@ -838,7 +826,10 @@ impl<'a> CompletionContext<'a> {\n \n         Some(match_ast! {\n             match parent {\n-                ast::LifetimeParam(_) => LifetimeContext::LifetimeParam(sema.find_node_at_offset_with_macros(original_file, offset)),\n+                ast::LifetimeParam(param) => LifetimeContext::LifetimeParam {\n+                    is_decl: param.lifetime().as_ref() == Some(&lifetime),\n+                    param\n+                },\n                 ast::BreakExpr(_) => LifetimeContext::LabelRef,\n                 ast::ContinueExpr(_) => LifetimeContext::LabelRef,\n                 ast::Label(_) => LifetimeContext::LabelDef,"}, {"sha": "422bda646038603e2757b180ff3e6c6a403b7bec", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=0b54d313592c76e7beebaa12ad029925b63dd971", "patch": "@@ -144,12 +144,6 @@ pub fn completions(\n ) -> Option<Completions> {\n     let ctx = CompletionContext::new(db, position, config)?;\n \n-    if ctx.no_completion_required() {\n-        cov_mark::hit!(no_completion_required);\n-        // No work required here.\n-        return None;\n-    }\n-\n     let mut acc = Completions::default();\n     completions::attribute::complete_attribute(&mut acc, &ctx);\n     completions::attribute::complete_derive(&mut acc, &ctx);"}, {"sha": "8a53d6e4d4a66feab916baa95db19c9e9bd9b2e6", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=0b54d313592c76e7beebaa12ad029925b63dd971", "patch": "@@ -15,7 +15,7 @@ use syntax::{\n };\n \n #[cfg(test)]\n-use crate::tests::{check_pattern_is_applicable, check_pattern_is_not_applicable};\n+use crate::tests::check_pattern_is_applicable;\n \n /// Immediate previous node to what we are completing.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -291,24 +291,6 @@ fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Op\n     syntax.covering_element(range).ancestors().find_map(N::cast)\n }\n \n-pub(crate) fn inside_impl_trait_block(element: SyntaxElement) -> bool {\n-    // Here we search `impl` keyword up through the all ancestors, unlike in `has_impl_parent`,\n-    // where we only check the first parent with different text range.\n-    element\n-        .ancestors()\n-        .find(|it| it.kind() == IMPL)\n-        .map(|it| ast::Impl::cast(it).unwrap())\n-        .map(|it| it.trait_().is_some())\n-        .unwrap_or(false)\n-}\n-#[test]\n-fn test_inside_impl_trait_block() {\n-    check_pattern_is_applicable(r\"impl Foo for Bar { f$0 }\", inside_impl_trait_block);\n-    check_pattern_is_applicable(r\"impl Foo for Bar { fn f$0 }\", inside_impl_trait_block);\n-    check_pattern_is_not_applicable(r\"impl A { f$0 }\", inside_impl_trait_block);\n-    check_pattern_is_not_applicable(r\"impl A { fn f$0 }\", inside_impl_trait_block);\n-}\n-\n pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n     element.into_token().and_then(previous_non_trivia_token)\n }"}, {"sha": "f505e82d2204c83559d62da8b2108e9f0f69cd38", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b54d313592c76e7beebaa12ad029925b63dd971/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=0b54d313592c76e7beebaa12ad029925b63dd971", "patch": "@@ -154,10 +154,12 @@ fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n         .collect()\n }\n \n+#[track_caller]\n pub(crate) fn check_edit(what: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n     check_edit_with_config(TEST_CONFIG, what, ra_fixture_before, ra_fixture_after)\n }\n \n+#[track_caller]\n pub(crate) fn check_edit_with_config(\n     config: CompletionConfig,\n     what: &str,\n@@ -199,32 +201,14 @@ pub(crate) fn check_pattern_is_applicable(code: &str, check: impl FnOnce(SyntaxE\n     assert!(check(NodeOrToken::Token(token)));\n }\n \n-pub(crate) fn check_pattern_is_not_applicable(code: &str, check: fn(SyntaxElement) -> bool) {\n-    let (db, pos) = position(code);\n-    let sema = Semantics::new(&db);\n-    let original_file = sema.parse(pos.file_id);\n-    let token = original_file.syntax().token_at_offset(pos.offset).left_biased().unwrap();\n-    assert!(!check(NodeOrToken::Token(token)));\n-}\n-\n pub(crate) fn get_all_items(config: CompletionConfig, code: &str) -> Vec<CompletionItem> {\n     let (db, position) = position(code);\n     crate::completions(&db, &config, position).map_or_else(Vec::default, Into::into)\n }\n \n-fn check_no_completion(ra_fixture: &str) {\n-    let (db, position) = position(ra_fixture);\n-\n-    assert!(\n-        crate::completions(&db, &TEST_CONFIG, position).is_none(),\n-        \"Completions were generated, but weren't expected\"\n-    );\n-}\n-\n #[test]\n fn test_no_completions_required() {\n-    cov_mark::check!(no_completion_required);\n-    check_no_completion(r#\"fn foo() { for i i$0 }\"#);\n+    assert_eq!(completion_list(r#\"fn foo() { for i i$0 }\"#), String::new());\n }\n \n #[test]"}]}