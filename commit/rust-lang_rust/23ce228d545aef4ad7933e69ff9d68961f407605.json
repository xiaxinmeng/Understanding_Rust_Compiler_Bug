{"sha": "23ce228d545aef4ad7933e69ff9d68961f407605", "node_id": "C_kwDOAAsO6NoAKDIzY2UyMjhkNTQ1YWVmNGFkNzkzM2U2OWZmOWQ2ODk2MWY0MDc2MDU", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-18T20:46:52Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-18T20:46:52Z"}, "message": "Reduce MIR memory usage", "tree": {"sha": "b3bdf8bf7141b8e8af30f4ff84f7a05367717e9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3bdf8bf7141b8e8af30f4ff84f7a05367717e9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23ce228d545aef4ad7933e69ff9d68961f407605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23ce228d545aef4ad7933e69ff9d68961f407605", "html_url": "https://github.com/rust-lang/rust/commit/23ce228d545aef4ad7933e69ff9d68961f407605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23ce228d545aef4ad7933e69ff9d68961f407605/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae9660a1d076ddd78f28e65a7ac78b2c663ddda", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae9660a1d076ddd78f28e65a7ac78b2c663ddda", "html_url": "https://github.com/rust-lang/rust/commit/cae9660a1d076ddd78f28e65a7ac78b2c663ddda"}], "stats": {"total": 138, "additions": 83, "deletions": 55}, "files": [{"sha": "f8451f28d732a498aa276e848d9bc50d3cc94316", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=23ce228d545aef4ad7933e69ff9d68961f407605", "patch": "@@ -205,7 +205,7 @@ type PlaceElem = ProjectionElem<LocalId, Ty>;\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Place {\n     pub local: LocalId,\n-    pub projection: Vec<PlaceElem>,\n+    pub projection: Box<[PlaceElem]>,\n }\n \n impl Place {\n@@ -216,13 +216,20 @@ impl Place {\n     fn iterate_over_parents(&self) -> impl Iterator<Item = Place> + '_ {\n         (0..self.projection.len())\n             .map(|x| &self.projection[0..x])\n-            .map(|x| Place { local: self.local, projection: x.to_vec() })\n+            .map(|x| Place { local: self.local, projection: x.to_vec().into() })\n+    }\n+\n+    fn project(&self, projection: PlaceElem) -> Place {\n+        Place {\n+            local: self.local,\n+            projection: self.projection.iter().cloned().chain([projection]).collect(),\n+        }\n     }\n }\n \n impl From<LocalId> for Place {\n     fn from(local: LocalId) -> Self {\n-        Self { local, projection: vec![] }\n+        Self { local, projection: vec![].into() }\n     }\n }\n \n@@ -437,7 +444,7 @@ pub enum TerminatorKind {\n         /// These are owned by the callee, which is free to modify them.\n         /// This allows the memory occupied by \"by-value\" arguments to be\n         /// reused across function calls without duplicating the contents.\n-        args: Vec<Operand>,\n+        args: Box<[Operand]>,\n         /// Where the returned value will be written\n         destination: Place,\n         /// Where to go after this call returns. If none, the call necessarily diverges.\n@@ -894,7 +901,7 @@ pub enum Rvalue {\n     ///\n     /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n     /// generator lowering, `Generator` aggregate kinds are disallowed too.\n-    Aggregate(AggregateKind, Vec<Operand>),\n+    Aggregate(AggregateKind, Box<[Operand]>),\n \n     /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n     ///\n@@ -1011,7 +1018,7 @@ impl MirBody {\n                                 for_operand(o2, &mut f);\n                             }\n                             Rvalue::Aggregate(_, ops) => {\n-                                for op in ops {\n+                                for op in ops.iter_mut() {\n                                     for_operand(op, &mut f);\n                                 }\n                             }\n@@ -1058,6 +1065,27 @@ impl MirBody {\n             }\n         }\n     }\n+\n+    fn shrink_to_fit(&mut self) {\n+        let MirBody {\n+            basic_blocks,\n+            locals,\n+            start_block: _,\n+            owner: _,\n+            binding_locals,\n+            param_locals,\n+            closures,\n+        } = self;\n+        basic_blocks.shrink_to_fit();\n+        locals.shrink_to_fit();\n+        binding_locals.shrink_to_fit();\n+        param_locals.shrink_to_fit();\n+        closures.shrink_to_fit();\n+        for (_, b) in basic_blocks.iter_mut() {\n+            let BasicBlock { statements, terminator: _, is_cleanup: _ } = b;\n+            statements.shrink_to_fit();\n+        }\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]"}, {"sha": "66af6658e81ad4ee86f05f60eccbd310d370f4f2", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=23ce228d545aef4ad7933e69ff9d68961f407605", "patch": "@@ -93,7 +93,7 @@ fn moved_out_of_ref(db: &dyn HirDatabase, body: &MirBody) -> Vec<MovedOutOfRef>\n         Operand::Copy(p) | Operand::Move(p) => {\n             let mut ty: Ty = body.locals[p.local].ty.clone();\n             let mut is_dereference_of_ref = false;\n-            for proj in &p.projection {\n+            for proj in &*p.projection {\n                 if *proj == ProjectionElem::Deref && ty.as_reference().is_some() {\n                     is_dereference_of_ref = true;\n                 }\n@@ -143,7 +143,7 @@ fn moved_out_of_ref(db: &dyn HirDatabase, body: &MirBody) -> Vec<MovedOutOfRef>\n                         for_operand(o2, statement.span);\n                     }\n                     Rvalue::Aggregate(_, ops) => {\n-                        for op in ops {\n+                        for op in ops.iter() {\n                             for_operand(op, statement.span);\n                         }\n                     }"}, {"sha": "e4acd10aa9bea7f8fce58dbaaa2cd27f7843e743", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=23ce228d545aef4ad7933e69ff9d68961f407605", "patch": "@@ -562,7 +562,7 @@ impl Evaluator<'_> {\n         let mut ty: Ty =\n             self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n         let mut metadata: Option<IntervalOrOwned> = None; // locals are always sized\n-        for proj in &p.projection {\n+        for proj in &*p.projection {\n             let prev_ty = ty.clone();\n             ty = proj.projected_ty(\n                 ty,"}, {"sha": "f73b25d83f4e182d44556cfc5a024a6b808f4635", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=23ce228d545aef4ad7933e69ff9d68961f407605", "patch": "@@ -387,7 +387,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                                 current,\n                                 place,\n                                 ty,\n-                                vec![],\n+                                Box::new([]),\n                                 expr_id.into(),\n                             )?;\n                         }\n@@ -561,7 +561,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 };\n                 self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n                 self.lower_loop(current, place, label, expr_id.into(), |this, begin| {\n-                    let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false, expr_id.into())?\n+                    let Some(current) = this.lower_call(iter_next_fn_op, Box::new([Operand::Copy(ref_mut_iterator_place)]), option_item_place.clone(), begin, false, expr_id.into())?\n                     else {\n                         return Ok(());\n                     };\n@@ -758,8 +758,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                                         match x {\n                                             Some(x) => x,\n                                             None => {\n-                                                let mut p = sp.clone();\n-                                                p.projection.push(ProjectionElem::Field(FieldId {\n+                                                let p = sp.project(ProjectionElem::Field(FieldId {\n                                                     parent: variant_id,\n                                                     local_id: LocalFieldId::from_raw(RawIdx::from(i as u32)),\n                                                 }));\n@@ -782,10 +781,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         };\n                         let local_id =\n                             variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n-                        let mut place = place;\n-                        place\n-                            .projection\n-                            .push(PlaceElem::Field(FieldId { parent: union_id.into(), local_id }));\n+                        let place = place.project(PlaceElem::Field(FieldId { parent: union_id.into(), local_id }));\n                         self.lower_expr_to_place(*expr, place, current)\n                     }\n                 }\n@@ -826,8 +822,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 let Some((operand, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n                     return Ok(None);\n                 };\n-                let mut p = place;\n-                p.projection.push(ProjectionElem::Deref);\n+                let p = place.project(ProjectionElem::Deref);\n                 self.push_assignment(current, p, operand.into(), expr_id.into());\n                 Ok(Some(current))\n             },\n@@ -1031,7 +1026,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 self.push_assignment(\n                     current,\n                     place,\n-                    Rvalue::Aggregate(AggregateKind::Closure(ty), operands),\n+                    Rvalue::Aggregate(AggregateKind::Closure(ty), operands.into()),\n                     expr_id.into(),\n                 );\n                 Ok(Some(current))\n@@ -1128,11 +1123,11 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 let index = name\n                     .as_tuple_index()\n                     .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n-                place.projection.push(ProjectionElem::TupleOrClosureField(index))\n+                *place = place.project(ProjectionElem::TupleOrClosureField(index))\n             } else {\n                 let field =\n                     self.infer.field_resolution(expr_id).ok_or(MirLowerError::UnresolvedField)?;\n-                place.projection.push(ProjectionElem::Field(field));\n+                *place = place.project(ProjectionElem::Field(field));\n             }\n         } else {\n             not_supported!(\"\")\n@@ -1242,7 +1237,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         prev_block: BasicBlockId,\n         place: Place,\n         ty: Ty,\n-        fields: Vec<Operand>,\n+        fields: Box<[Operand]>,\n         span: MirSpan,\n     ) -> Result<BasicBlockId> {\n         let subst = match ty.kind(Interner) {\n@@ -1280,13 +1275,13 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         else {\n             return Ok(None);\n         };\n-        self.lower_call(func, args, place, current, is_uninhabited, span)\n+        self.lower_call(func, args.into(), place, current, is_uninhabited, span)\n     }\n \n     fn lower_call(\n         &mut self,\n         func: Operand,\n-        args: Vec<Operand>,\n+        args: Box<[Operand]>,\n         place: Place,\n         current: BasicBlockId,\n         is_uninhabited: bool,\n@@ -1744,12 +1739,13 @@ pub fn mir_body_for_closure_query(\n             match r {\n                 Some(x) => {\n                     p.local = closure_local;\n-                    let prev_projs =\n-                        mem::replace(&mut p.projection, vec![PlaceElem::TupleOrClosureField(x.1)]);\n+                    let mut next_projs = vec![PlaceElem::TupleOrClosureField(x.1)];\n+                    let prev_projs = mem::take(&mut p.projection);\n                     if x.0.kind != CaptureKind::ByValue {\n-                        p.projection.push(ProjectionElem::Deref);\n+                        next_projs.push(ProjectionElem::Deref);\n                     }\n-                    p.projection.extend(prev_projs.into_iter().skip(x.0.place.projections.len()));\n+                    next_projs.extend(prev_projs.iter().cloned().skip(x.0.place.projections.len()));\n+                    p.projection = next_projs.into();\n                 }\n                 None => err = Some(p.clone()),\n             }\n@@ -1764,6 +1760,7 @@ pub fn mir_body_for_closure_query(\n     if let Some(err) = err {\n         return Err(MirLowerError::UnresolvedUpvar(err));\n     }\n+    ctx.result.shrink_to_fit();\n     Ok(Arc::new(ctx.result))\n }\n \n@@ -1780,7 +1777,8 @@ pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<Mi\n     });\n     let body = db.body(def);\n     let infer = db.infer(def);\n-    let result = lower_to_mir(db, def, &body, &infer, body.body_expr)?;\n+    let mut result = lower_to_mir(db, def, &body, &infer, body.body_expr)?;\n+    result.shrink_to_fit();\n     Ok(Arc::new(result))\n }\n "}, {"sha": "d2c8d9a089e00060f3e85f8ca4682c2f445eee3f", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=23ce228d545aef4ad7933e69ff9d68961f407605", "patch": "@@ -65,7 +65,7 @@ impl MirLowerCtx<'_> {\n                     )? else {\n                         return Ok(None);\n                     };\n-                    x.0.projection.push(ProjectionElem::Deref);\n+                    x.0 = x.0.project(ProjectionElem::Deref);\n                     Ok(Some(x))\n                 }\n                 Adjust::Deref(Some(od)) => {\n@@ -139,15 +139,14 @@ impl MirLowerCtx<'_> {\n                         let ty = self.expr_ty_without_adjust(expr_id);\n                         let ref_ty =\n                             TyKind::Ref(Mutability::Not, static_lifetime(), ty).intern(Interner);\n-                        let mut temp: Place = self.temp(ref_ty, current, expr_id.into())?.into();\n+                        let temp: Place = self.temp(ref_ty, current, expr_id.into())?.into();\n                         self.push_assignment(\n                             current,\n                             temp.clone(),\n                             Operand::Static(s).into(),\n                             expr_id.into(),\n                         );\n-                        temp.projection.push(ProjectionElem::Deref);\n-                        Ok(Some((temp, current)))\n+                        Ok(Some((temp.project(ProjectionElem::Deref), current)))\n                     }\n                     _ => try_rvalue(self),\n                 }\n@@ -196,7 +195,7 @@ impl MirLowerCtx<'_> {\n                     let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                         return Ok(None);\n                     };\n-                    r.projection.push(ProjectionElem::Deref);\n+                    r = r.project(ProjectionElem::Deref);\n                     Ok(Some((r, current)))\n                 }\n                 _ => try_rvalue(self),\n@@ -253,7 +252,7 @@ impl MirLowerCtx<'_> {\n                 let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)? else {\n                     return Ok(None);\n                 };\n-                p_base.projection.push(ProjectionElem::Index(l_index));\n+                p_base = p_base.project(ProjectionElem::Index(l_index));\n                 Ok(Some((p_base, current)))\n             }\n             _ => try_rvalue(self),\n@@ -283,10 +282,10 @@ impl MirLowerCtx<'_> {\n             )\n             .intern(Interner),\n         );\n-        let Some(current) = self.lower_call(index_fn_op, vec![Operand::Copy(place), index_operand], result.clone(), current, false, span)? else {\n+        let Some(current) = self.lower_call(index_fn_op, Box::new([Operand::Copy(place), index_operand]), result.clone(), current, false, span)? else {\n             return Ok(None);\n         };\n-        result.projection.push(ProjectionElem::Deref);\n+        result = result.project(ProjectionElem::Deref);\n         Ok(Some((result, current)))\n     }\n \n@@ -330,10 +329,10 @@ impl MirLowerCtx<'_> {\n             .intern(Interner),\n         );\n         let mut result: Place = self.temp(target_ty_ref, current, span)?.into();\n-        let Some(current) = self.lower_call(deref_fn_op, vec![Operand::Copy(ref_place)], result.clone(), current, false, span)? else {\n+        let Some(current) = self.lower_call(deref_fn_op, Box::new([Operand::Copy(ref_place)]), result.clone(), current, false, span)? else {\n             return Ok(None);\n         };\n-        result.projection.push(ProjectionElem::Deref);\n+        result = result.project(ProjectionElem::Deref);\n         Ok(Some((result, current)))\n     }\n }"}, {"sha": "00864907ac8872cb565a4288e0e6d2a0049d2db8", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23ce228d545aef4ad7933e69ff9d68961f407605/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=23ce228d545aef4ad7933e69ff9d68961f407605", "patch": "@@ -110,10 +110,10 @@ impl MirLowerCtx<'_> {\n             Pat::Slice { prefix, slice, suffix } => {\n                 pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n                 for (i, &pat) in prefix.iter().enumerate() {\n-                    let mut next_place = cond_place.clone();\n-                    next_place\n-                        .projection\n-                        .push(ProjectionElem::ConstantIndex { offset: i as u64, from_end: false });\n+                    let next_place = cond_place.project(ProjectionElem::ConstantIndex {\n+                        offset: i as u64,\n+                        from_end: false,\n+                    });\n                     let cond_ty = self.infer[pat].clone();\n                     (current, current_else) = self.pattern_match(\n                         current,\n@@ -126,8 +126,7 @@ impl MirLowerCtx<'_> {\n                 }\n                 if let Some(slice) = slice {\n                     if let Pat::Bind { id, subpat: _ } = self.body[*slice] {\n-                        let mut next_place = cond_place.clone();\n-                        next_place.projection.push(ProjectionElem::Subslice {\n+                        let next_place = cond_place.project(ProjectionElem::Subslice {\n                             from: prefix.len() as u64,\n                             to: suffix.len() as u64,\n                         });\n@@ -142,10 +141,10 @@ impl MirLowerCtx<'_> {\n                     }\n                 }\n                 for (i, &pat) in suffix.iter().enumerate() {\n-                    let mut next_place = cond_place.clone();\n-                    next_place\n-                        .projection\n-                        .push(ProjectionElem::ConstantIndex { offset: i as u64, from_end: true });\n+                    let next_place = cond_place.project(ProjectionElem::ConstantIndex {\n+                        offset: i as u64,\n+                        from_end: true,\n+                    });\n                     let cond_ty = self.infer[pat].clone();\n                     (current, current_else) = self.pattern_match(\n                         current,\n@@ -269,11 +268,10 @@ impl MirLowerCtx<'_> {\n             Pat::Ref { pat, mutability: _ } => {\n                 if let Some((ty, _, _)) = cond_ty.as_reference() {\n                     cond_ty = ty.clone();\n-                    cond_place.projection.push(ProjectionElem::Deref);\n                     self.pattern_match(\n                         current,\n                         current_else,\n-                        cond_place,\n+                        cond_place.project(ProjectionElem::Deref),\n                         cond_ty,\n                         *pat,\n                         binding_mode,\n@@ -479,8 +477,7 @@ impl MirLowerCtx<'_> {\n         binding_mode: BindingAnnotation,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n         for (proj, arg, ty) in args {\n-            let mut cond_place = cond_place.clone();\n-            cond_place.projection.push(proj);\n+            let cond_place = cond_place.project(proj);\n             (current, current_else) =\n                 self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n         }\n@@ -513,5 +510,11 @@ fn pattern_matching_dereference(\n     cond_place: &mut Place,\n ) {\n     let cnt = pattern_matching_dereference_count(cond_ty, binding_mode);\n-    cond_place.projection.extend((0..cnt).map(|_| ProjectionElem::Deref));\n+    cond_place.projection = cond_place\n+        .projection\n+        .iter()\n+        .cloned()\n+        .chain((0..cnt).map(|_| ProjectionElem::Deref))\n+        .collect::<Vec<_>>()\n+        .into();\n }"}]}