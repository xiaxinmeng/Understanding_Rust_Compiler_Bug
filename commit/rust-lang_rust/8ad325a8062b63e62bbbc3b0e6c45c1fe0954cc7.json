{"sha": "8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZDMyNWE4MDYyYjYzZTYyYmJiYzNiMGU2YzQ1YzFmZTA5NTRjYzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-11T13:37:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-11T13:37:28Z"}, "message": "Merge #7051 #7219 #7245 #7246\n\n7051: Check dbg! macro in tidy_test r=matklad a=edwin0cheng\n\nSame as `check_todo` but for dbg! macro\r\n\r\nr? @matklad \n\n7219: Refactor rename name checking r=matklad a=Veykril\n\nImproves the user facing error messages a bit and prevents renaming to `_` when the name is referenced as this would change source to not compile anymore since `_` is only a pattern, not a proper identifier.\n\n7245: Encourage gifs r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n7246: Unfreeze cargo_metadata r=matklad a=kjeremy\n\nIt now pulls in a newer version of semver-parser.\r\n\r\nThis does add a dependency on `cargo-platform` in the interest of correctness.\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\nCo-authored-by: kjeremy <kjeremy@gmail.com>", "tree": {"sha": "c8348ebebe475f931d74ffb2c7512f060950dfc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8348ebebe475f931d74ffb2c7512f060950dfc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf/FSYCRBK7hj4Ov3rIwAAdHIIAAzGXva/TZH2wWV+PG0b0MgH\neOKbdyXwu2i/hIjnVFlBOfsDXQG9nIExCM/ckjz2QODD+jHq1RvkCS8GCbW6ksFl\nmd1MrwuxFo14NP5zioGASyR93dkupc7r0ylqsmk49od4tIEjGOCNHud2hFuem+GX\nx3KMgkkF//ytvvK+7YjGIU9TWKQuuvi8ePiVenYZXgrinbJoxhyX/tQOk4W2ID90\nVs6eQTR2reQ6juJQk69MO7rDi4M5QcY9H2UKteLAPeuYF4RjyalojxtJhEf5Vp3v\nac6cye+PdNKnVWiVHJveFyusl4AcRn45V4psKZLxFFFjbUZLUAhiejFZyIuKdZQ=\n=BG9B\n-----END PGP SIGNATURE-----\n", "payload": "tree c8348ebebe475f931d74ffb2c7512f060950dfc1\nparent b84c49b9af92af628019fbcb11898be117af4f97\nparent 8584d269262e73aa7c3ebe25b1d61483375de267\nparent f7af0b4b969aa1ba85744f082a30af808a684d7c\nparent 2d0464a6f3c572d7736670c22c71efe8aca93749\nparent 1da68e87af7b78257adaad27f266f4f50ac4588c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610372248 +0000\ncommitter GitHub <noreply@github.com> 1610372248 +0000\n\nMerge #7051 #7219 #7245 #7246\n\n7051: Check dbg! macro in tidy_test r=matklad a=edwin0cheng\n\nSame as `check_todo` but for dbg! macro\r\n\r\nr? @matklad \n\n7219: Refactor rename name checking r=matklad a=Veykril\n\nImproves the user facing error messages a bit and prevents renaming to `_` when the name is referenced as this would change source to not compile anymore since `_` is only a pattern, not a proper identifier.\n\n7245: Encourage gifs r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n7246: Unfreeze cargo_metadata r=matklad a=kjeremy\n\nIt now pulls in a newer version of semver-parser.\r\n\r\nThis does add a dependency on `cargo-platform` in the interest of correctness.\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\nCo-authored-by: kjeremy <kjeremy@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "html_url": "https://github.com/rust-lang/rust/commit/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b84c49b9af92af628019fbcb11898be117af4f97", "url": "https://api.github.com/repos/rust-lang/rust/commits/b84c49b9af92af628019fbcb11898be117af4f97", "html_url": "https://github.com/rust-lang/rust/commit/b84c49b9af92af628019fbcb11898be117af4f97"}, {"sha": "8584d269262e73aa7c3ebe25b1d61483375de267", "url": "https://api.github.com/repos/rust-lang/rust/commits/8584d269262e73aa7c3ebe25b1d61483375de267", "html_url": "https://github.com/rust-lang/rust/commit/8584d269262e73aa7c3ebe25b1d61483375de267"}, {"sha": "f7af0b4b969aa1ba85744f082a30af808a684d7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7af0b4b969aa1ba85744f082a30af808a684d7c", "html_url": "https://github.com/rust-lang/rust/commit/f7af0b4b969aa1ba85744f082a30af808a684d7c"}, {"sha": "2d0464a6f3c572d7736670c22c71efe8aca93749", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d0464a6f3c572d7736670c22c71efe8aca93749", "html_url": "https://github.com/rust-lang/rust/commit/2d0464a6f3c572d7736670c22c71efe8aca93749"}, {"sha": "1da68e87af7b78257adaad27f266f4f50ac4588c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1da68e87af7b78257adaad27f266f4f50ac4588c", "html_url": "https://github.com/rust-lang/rust/commit/1da68e87af7b78257adaad27f266f4f50ac4588c"}], "stats": {"total": 314, "additions": 215, "deletions": 99}, "files": [{"sha": "5563fdeb23a40772c47e665edda1c786d0f4b358", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -126,13 +126,24 @@ version = \"1.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n \n+[[package]]\n+name = \"cargo-platform\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0226944a63d1bf35a3b5f948dd7c59e263db83695c9e8bffc4037de02e30f1d7\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.12.0\"\n+version = \"0.12.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d5a5f7b42f606b7f23674f6f4d877628350682bc40687d3fae65679a58d55345\"\n+checksum = \"11a47b6286279a9998588ef7050d1ebc2500c69892a557c90fe5d071c64415dc\"\n dependencies = [\n+ \"cargo-platform\",\n  \"semver\",\n+ \"semver-parser\",\n  \"serde\",\n  \"serde_json\",\n ]"}, {"sha": "d04eef65a7963a3735cac6452177b8c8d36aee5b", "filename": "crates/completion/src/completions/dot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fdot.rs?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -373,20 +373,20 @@ fn foo(a: A) {\n     fn macro_expansion_resilient() {\n         check(\n             r#\"\n-macro_rules! dbg {\n+macro_rules! d {\n     () => {};\n     ($val:expr) => {\n         match $val { tmp => { tmp } }\n     };\n     // Trailing comma with single argument is ignored\n-    ($val:expr,) => { $crate::dbg!($val) };\n+    ($val:expr,) => { $crate::d!($val) };\n     ($($val:expr),+ $(,)?) => {\n-        ($($crate::dbg!($val)),+,)\n+        ($($crate::d!($val)),+,)\n     };\n }\n struct A { the_field: u32 }\n fn foo(a: A) {\n-    dbg!(a.$0)\n+    d!(a.$0)\n }\n \"#,\n             expect![[r#\""}, {"sha": "1d19c7886941a5062fe03932e07bc80893bbc7e3", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n crossbeam-channel = \"0.5.0\"\n log = \"0.4.8\"\n-cargo_metadata = \"=0.12.0\"\n+cargo_metadata = \"0.12.2\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n "}, {"sha": "317b6f0114ea838af8e575419add53be8e3d07c7", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -175,12 +175,7 @@ fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<Hov\n         Definition::SelfType(it) => it.target_ty(db).as_adt(),\n         _ => None,\n     }?;\n-    match adt {\n-        Adt::Struct(it) => it.try_to_nav(db),\n-        Adt::Union(it) => it.try_to_nav(db),\n-        Adt::Enum(it) => it.try_to_nav(db),\n-    }\n-    .map(to_action)\n+    adt.try_to_nav(db).map(to_action)\n }\n \n fn runnable_action("}, {"sha": "3edc43e0828c667793b92d8f32371700128765fb", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 161, "deletions": 79, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -14,16 +14,17 @@ use ide_db::{\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    lex_single_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n+    lex_single_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken, T,\n };\n use test_utils::mark;\n use text_edit::TextEdit;\n \n use crate::{\n-    references::find_all_refs, FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind,\n+    FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind, ReferenceSearchResult,\n     SourceChange, SourceFileEdit, TextRange, TextSize,\n };\n \n+type RenameResult<T> = Result<T, RenameError>;\n #[derive(Debug)]\n pub struct RenameError(pub(crate) String);\n \n@@ -35,24 +36,30 @@ impl fmt::Display for RenameError {\n \n impl Error for RenameError {}\n \n+macro_rules! format_err {\n+    ($fmt:expr) => {RenameError(format!($fmt))};\n+    ($fmt:expr, $($arg:tt)+) => {RenameError(format!($fmt, $($arg)+))}\n+}\n+\n+macro_rules! bail {\n+    ($($tokens:tt)*) => {return Err(format_err!($($tokens)*))}\n+}\n+\n pub(crate) fn prepare_rename(\n     db: &RootDatabase,\n     position: FilePosition,\n-) -> Result<RangeInfo<()>, RenameError> {\n+) -> RenameResult<RangeInfo<()>> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n     if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n         rename_mod(&sema, position, module, \"dummy\")\n     } else if let Some(self_token) =\n-        syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+        syntax.token_at_offset(position.offset).find(|t| t.kind() == T![self])\n     {\n         rename_self_to_param(&sema, position, self_token, \"dummy\")\n     } else {\n-        let range = match find_all_refs(&sema, position, None) {\n-            Some(RangeInfo { range, .. }) => range,\n-            None => return Err(RenameError(\"No references found at position\".to_string())),\n-        };\n+        let RangeInfo { range, .. } = find_all_refs(&sema, position)?;\n         Ok(RangeInfo::new(range, SourceChange::from(vec![])))\n     }\n     .map(|info| RangeInfo::new(info.range, ()))\n@@ -62,7 +69,7 @@ pub(crate) fn rename(\n     db: &RootDatabase,\n     position: FilePosition,\n     new_name: &str,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n+) -> RenameResult<RangeInfo<SourceChange>> {\n     let sema = Semantics::new(db);\n     rename_with_semantics(&sema, position, new_name)\n }\n@@ -71,42 +78,18 @@ pub(crate) fn rename_with_semantics(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n     new_name: &str,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n-    let is_lifetime_name = match lex_single_syntax_kind(new_name) {\n-        Some(res) => match res {\n-            (SyntaxKind::IDENT, _) => false,\n-            (SyntaxKind::UNDERSCORE, _) => false,\n-            (SyntaxKind::SELF_KW, _) => return rename_to_self(&sema, position),\n-            (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => true,\n-            (SyntaxKind::LIFETIME_IDENT, _) => {\n-                return Err(RenameError(format!(\n-                    \"Invalid name `{0}`: Cannot rename lifetime to {0}\",\n-                    new_name\n-                )))\n-            }\n-            (_, Some(syntax_error)) => {\n-                return Err(RenameError(format!(\"Invalid name `{}`: {}\", new_name, syntax_error)))\n-            }\n-            (_, None) => {\n-                return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name)))\n-            }\n-        },\n-        None => return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name))),\n-    };\n-\n+) -> RenameResult<RangeInfo<SourceChange>> {\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n-    // this is here to prevent lifetime renames from happening on modules and self\n-    if is_lifetime_name {\n-        rename_reference(&sema, position, new_name, is_lifetime_name)\n-    } else if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n+\n+    if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n         rename_mod(&sema, position, module, new_name)\n     } else if let Some(self_token) =\n-        syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+        syntax.token_at_offset(position.offset).find(|t| t.kind() == T![self])\n     {\n         rename_self_to_param(&sema, position, self_token, new_name)\n     } else {\n-        rename_reference(&sema, position, new_name, is_lifetime_name)\n+        rename_reference(&sema, position, new_name)\n     }\n }\n \n@@ -127,6 +110,33 @@ pub(crate) fn will_rename_file(\n     Some(change)\n }\n \n+#[derive(Debug, PartialEq)]\n+enum IdentifierKind {\n+    Ident,\n+    Lifetime,\n+    ToSelf,\n+    Underscore,\n+}\n+\n+fn check_identifier(new_name: &str) -> RenameResult<IdentifierKind> {\n+    match lex_single_syntax_kind(new_name) {\n+        Some(res) => match res {\n+            (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n+            (T![_], _) => Ok(IdentifierKind::Underscore),\n+            (T![self], _) => Ok(IdentifierKind::ToSelf),\n+            (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n+                Ok(IdentifierKind::Lifetime)\n+            }\n+            (SyntaxKind::LIFETIME_IDENT, _) => {\n+                bail!(\"Invalid name `{0}`: Cannot rename lifetime to {0}\", new_name)\n+            }\n+            (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n+            (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+        },\n+        None => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+    }\n+}\n+\n fn find_module_at_offset(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n@@ -155,6 +165,14 @@ fn find_module_at_offset(\n     Some(module)\n }\n \n+fn find_all_refs(\n+    sema: &Semantics<RootDatabase>,\n+    position: FilePosition,\n+) -> RenameResult<RangeInfo<ReferenceSearchResult>> {\n+    crate::references::find_all_refs(sema, position, None)\n+        .ok_or_else(|| format_err!(\"No references found at position\"))\n+}\n+\n fn source_edit_from_reference(\n     sema: &Semantics<RootDatabase>,\n     reference: Reference,\n@@ -223,7 +241,10 @@ fn rename_mod(\n     position: FilePosition,\n     module: Module,\n     new_name: &str,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n+) -> RenameResult<RangeInfo<SourceChange>> {\n+    if IdentifierKind::Ident != check_identifier(new_name)? {\n+        bail!(\"Invalid name `{0}`: cannot rename module to {0}\", new_name);\n+    }\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n \n@@ -254,8 +275,7 @@ fn rename_mod(\n         source_file_edits.push(edit);\n     }\n \n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)\n-        .ok_or_else(|| RenameError(\"No references found at position\".to_string()))?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n     let ref_edits = refs\n         .references\n         .into_iter()\n@@ -274,27 +294,26 @@ fn rename_to_self(\n \n     let (fn_def, fn_ast) = find_node_at_offset::<ast::Fn>(syn, position.offset)\n         .and_then(|fn_ast| sema.to_def(&fn_ast).zip(Some(fn_ast)))\n-        .ok_or_else(|| RenameError(\"No surrounding method declaration found\".to_string()))?;\n+        .ok_or_else(|| format_err!(\"No surrounding method declaration found\"))?;\n     let param_range = fn_ast\n         .param_list()\n         .and_then(|p| p.params().next())\n-        .ok_or_else(|| RenameError(\"Method has no parameters\".to_string()))?\n+        .ok_or_else(|| format_err!(\"Method has no parameters\"))?\n         .syntax()\n         .text_range();\n     if !param_range.contains(position.offset) {\n-        return Err(RenameError(\"Only the first parameter can be self\".to_string()));\n+        bail!(\"Only the first parameter can be self\");\n     }\n \n     let impl_block = find_node_at_offset::<ast::Impl>(syn, position.offset)\n         .and_then(|def| sema.to_def(&def))\n-        .ok_or_else(|| RenameError(\"No impl block found for function\".to_string()))?;\n+        .ok_or_else(|| format_err!(\"No impl block found for function\"))?;\n     if fn_def.self_param(sema.db).is_some() {\n-        return Err(RenameError(\"Method already has a self parameter\".to_string()));\n+        bail!(\"Method already has a self parameter\");\n     }\n \n     let params = fn_def.assoc_fn_params(sema.db);\n-    let first_param =\n-        params.first().ok_or_else(|| RenameError(\"Method has no parameters\".into()))?;\n+    let first_param = params.first().ok_or_else(|| format_err!(\"Method has no parameters\"))?;\n     let first_param_ty = first_param.ty();\n     let impl_ty = impl_block.target_ty(sema.db);\n     let (ty, self_param) = if impl_ty.remove_ref().is_some() {\n@@ -307,18 +326,17 @@ fn rename_to_self(\n     };\n \n     if ty != impl_ty {\n-        return Err(RenameError(\"Parameter type differs from impl block type\".to_string()));\n+        bail!(\"Parameter type differs from impl block type\");\n     }\n \n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)\n-        .ok_or_else(|| RenameError(\"No reference found at position\".to_string()))?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n \n     let (param_ref, usages): (Vec<Reference>, Vec<Reference>) = refs\n         .into_iter()\n         .partition(|reference| param_range.intersect(reference.file_range.range).is_some());\n \n     if param_ref.is_empty() {\n-        return Err(RenameError(\"Parameter to rename not found\".to_string()));\n+        bail!(\"Parameter to rename not found\");\n     }\n \n     let mut edits = usages\n@@ -367,12 +385,22 @@ fn rename_self_to_param(\n     self_token: SyntaxToken,\n     new_name: &str,\n ) -> Result<RangeInfo<SourceChange>, RenameError> {\n+    let ident_kind = check_identifier(new_name)?;\n+    match ident_kind {\n+        IdentifierKind::Lifetime => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+        IdentifierKind::ToSelf => {\n+            // no-op\n+            mark::hit!(rename_self_to_self);\n+            return Ok(RangeInfo::new(self_token.text_range(), SourceChange::default()));\n+        }\n+        _ => (),\n+    }\n     let source_file = sema.parse(position.file_id);\n     let syn = source_file.syntax();\n \n     let text = sema.db.file_text(position.file_id);\n     let fn_def = find_node_at_offset::<ast::Fn>(syn, position.offset)\n-        .ok_or_else(|| RenameError(\"No surrounding method declaration found\".to_string()))?;\n+        .ok_or_else(|| format_err!(\"No surrounding method declaration found\"))?;\n     let search_range = fn_def.syntax().text_range();\n \n     let mut edits: Vec<SourceFileEdit> = vec![];\n@@ -382,19 +410,21 @@ fn rename_self_to_param(\n         if !search_range.contains_inclusive(offset) {\n             continue;\n         }\n-        if let Some(ref usage) =\n-            syn.token_at_offset(offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n-        {\n+        if let Some(ref usage) = syn.token_at_offset(offset).find(|t| t.kind() == T![self]) {\n             let edit = if let Some(ref self_param) = ast::SelfParam::cast(usage.parent()) {\n                 text_edit_from_self_param(syn, self_param, new_name)\n-                    .ok_or_else(|| RenameError(\"No target type found\".to_string()))?\n+                    .ok_or_else(|| format_err!(\"No target type found\"))?\n             } else {\n                 TextEdit::replace(usage.text_range(), String::from(new_name))\n             };\n             edits.push(SourceFileEdit { file_id: position.file_id, edit });\n         }\n     }\n \n+    if edits.len() > 1 && ident_kind == IdentifierKind::Underscore {\n+        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+    }\n+\n     let range = ast::SelfParam::cast(self_token.parent())\n         .map_or(self_token.text_range(), |p| p.syntax().text_range());\n \n@@ -405,35 +435,41 @@ fn rename_reference(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n     new_name: &str,\n-    is_lifetime_name: bool,\n ) -> Result<RangeInfo<SourceChange>, RenameError> {\n-    let RangeInfo { range, info: refs } = match find_all_refs(sema, position, None) {\n-        Some(range_info) => range_info,\n-        None => return Err(RenameError(\"No references found at position\".to_string())),\n-    };\n-\n-    match (refs.declaration.kind == ReferenceKind::Lifetime, is_lifetime_name) {\n-        (true, false) => {\n-            return Err(RenameError(format!(\n-                \"Invalid name `{}`: not a lifetime identifier\",\n-                new_name\n-            )))\n+    let ident_kind = check_identifier(new_name)?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n+\n+    match (ident_kind, &refs.declaration.kind) {\n+        (IdentifierKind::ToSelf, ReferenceKind::Lifetime)\n+        | (IdentifierKind::Underscore, ReferenceKind::Lifetime)\n+        | (IdentifierKind::Ident, ReferenceKind::Lifetime) => {\n+            mark::hit!(rename_not_a_lifetime_ident_ref);\n+            bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n         }\n-        (false, true) => {\n-            return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name)))\n+        (IdentifierKind::Lifetime, ReferenceKind::Lifetime) => mark::hit!(rename_lifetime),\n+        (IdentifierKind::Lifetime, _) => {\n+            mark::hit!(rename_not_an_ident_ref);\n+            bail!(\"Invalid name `{}`: not an identifier\", new_name)\n         }\n-        _ => (),\n+        (IdentifierKind::ToSelf, ReferenceKind::SelfKw) => {\n+            unreachable!(\"rename_self_to_param should've been called instead\")\n+        }\n+        (IdentifierKind::ToSelf, _) => {\n+            mark::hit!(rename_to_self);\n+            return rename_to_self(sema, position);\n+        }\n+        (IdentifierKind::Underscore, _) if !refs.references.is_empty() => {\n+            mark::hit!(rename_underscore_multiple);\n+            bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\")\n+        }\n+        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n     }\n \n     let edit = refs\n         .into_iter()\n         .map(|reference| source_edit_from_reference(sema, reference, new_name))\n         .collect::<Vec<_>>();\n \n-    if edit.is_empty() {\n-        return Err(RenameError(\"No references found at position\".to_string()));\n-    }\n-\n     Ok(RangeInfo::new(range, SourceChange::from(edit)))\n }\n \n@@ -462,9 +498,11 @@ mod tests {\n                         text_edit_builder.replace(indel.delete, indel.insert);\n                     }\n                 }\n-                let mut result = analysis.file_text(file_id.unwrap()).unwrap().to_string();\n-                text_edit_builder.finish().apply(&mut result);\n-                assert_eq_text!(ra_fixture_after, &*result);\n+                if let Some(file_id) = file_id {\n+                    let mut result = analysis.file_text(file_id).unwrap().to_string();\n+                    text_edit_builder.finish().apply(&mut result);\n+                    assert_eq_text!(ra_fixture_after, &*result);\n+                }\n             }\n             Err(err) => {\n                 if ra_fixture_after.starts_with(\"error:\") {\n@@ -530,6 +568,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_invalid_identifier_lifetime() {\n+        mark::check!(rename_not_an_ident_ref);\n         check(\n             \"'foo\",\n             r#\"fn main() { let i$0 = 1; }\"#,\n@@ -539,15 +578,36 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_invalid_identifier_lifetime2() {\n+        mark::check!(rename_not_a_lifetime_ident_ref);\n         check(\n             \"foo\",\n             r#\"fn main<'a>(_: &'a$0 ()) {}\"#,\n             \"error: Invalid name `foo`: not a lifetime identifier\",\n         );\n     }\n \n+    #[test]\n+    fn test_rename_to_underscore_invalid() {\n+        mark::check!(rename_underscore_multiple);\n+        check(\n+            \"_\",\n+            r#\"fn main(foo$0: ()) {foo;}\"#,\n+            \"error: Cannot rename reference to `_` as it is being referenced multiple times\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_mod_invalid() {\n+        check(\n+            \"'foo\",\n+            r#\"mod foo$0 {}\"#,\n+            \"error: Invalid name `'foo`: cannot rename module to 'foo\",\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_for_local() {\n+        mark::check!(rename_ident);\n         check(\n             \"k\",\n             r#\"\n@@ -1178,6 +1238,7 @@ fn foo(f: foo::Foo) {\n \n     #[test]\n     fn test_parameter_to_self() {\n+        mark::check!(rename_to_self);\n         check(\n             \"self\",\n             r#\"\n@@ -1481,6 +1542,7 @@ fn foo(Foo { i: bar }: foo) -> i32 {\n \n     #[test]\n     fn test_rename_lifetimes() {\n+        mark::check!(rename_lifetime);\n         check(\n             \"'yeeee\",\n             r#\"\n@@ -1562,6 +1624,26 @@ fn foo<'a>() -> &'a () {\n         }\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_self_to_self() {\n+        mark::check!(rename_self_to_self);\n+        check(\n+            \"self\",\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self$0) {}\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self) {}\n+}\n \"#,\n         )\n     }"}, {"sha": "83f9ead171928ee1bf8ceb30853149e26091aec9", "filename": "crates/proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fproc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fproc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2FCargo.toml?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -20,7 +20,7 @@ proc_macro_api = { path = \"../proc_macro_api\", version = \"0.0.0\" }\n test_utils = { path = \"../test_utils\", version = \"0.0.0\" }\n \n [dev-dependencies]\n-cargo_metadata = \"=0.12.0\"\n+cargo_metadata = \"0.12.2\"\n \n # used as proc macro test targets\n serde_derive = \"1.0.106\""}, {"sha": "855fb83eaf3e17f34bfad512689cb0907e69fc81", "filename": "crates/project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fproject_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/crates%2Fproject_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2FCargo.toml?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n-cargo_metadata = \"=0.12.0\"\n+cargo_metadata = \"0.12.2\"\n serde = { version = \"1.0.106\", features = [\"derive\"] }\n serde_json = \"1.0.48\"\n anyhow = \"1.0.26\""}, {"sha": "9859f614820baea9a82cf8bee35b7d68009e89eb", "filename": "docs/dev/style.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -78,6 +78,8 @@ Use original span for FileId\n \n This makes it easier to prepare a changelog.\n \n+If the change adds a new user-visible functionality, consider recording a GIF with [peek](https://github.com/phw/peek) and pasting it into the PR description.\n+\n **Rationale:** clean history is potentially useful, but rarely used.\n But many users read changelogs.\n "}, {"sha": "a957e36afe8feb52fbe1347ce1b28820f2280549", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=8ad325a8062b63e62bbbc3b0e6c45c1fe0954cc7", "patch": "@@ -85,6 +85,7 @@ fn rust_files_are_tidy() {\n     for path in rust_files(&project_root().join(\"crates\")) {\n         let text = read_file(&path).unwrap();\n         check_todo(&path, &text);\n+        check_dbg(&path, &text);\n         check_trailing_ws(&path, &text);\n         deny_clippy(&path, &text);\n         tidy_docs.visit(&path, &text);\n@@ -94,10 +95,9 @@ fn rust_files_are_tidy() {\n \n #[test]\n fn check_merge_commits() {\n-    let stdout =\n-        dbg!(cmd!(\"git rev-list --merges --invert-grep --author 'bors\\\\[bot\\\\]' HEAD~19..\"))\n-            .read()\n-            .unwrap();\n+    let stdout = cmd!(\"git rev-list --merges --invert-grep --author 'bors\\\\[bot\\\\]' HEAD~19..\")\n+        .read()\n+        .unwrap();\n     if !stdout.is_empty() {\n         panic!(\n             \"\n@@ -224,7 +224,7 @@ Zlib OR Apache-2.0 OR MIT\n fn check_todo(path: &Path, text: &str) {\n     let need_todo = &[\n         // This file itself obviously needs to use todo (<- like this!).\n-        \"tests/cli.rs\",\n+        \"tests/tidy.rs\",\n         // Some of our assists generate `todo!()`.\n         \"handlers/add_turbo_fish.rs\",\n         \"handlers/generate_function.rs\",\n@@ -252,6 +252,32 @@ fn check_todo(path: &Path, text: &str) {\n     }\n }\n \n+fn check_dbg(path: &Path, text: &str) {\n+    let need_dbg = &[\n+        // This file itself obviously needs to use dbg.\n+        \"tests/tidy.rs\",\n+        // Assists to remove `dbg!()`\n+        \"handlers/remove_dbg.rs\",\n+        // We have .dbg postfix\n+        \"completion/src/completions/postfix.rs\",\n+        // The documentation in string literals may contain anything for its own purposes\n+        \"completion/src/lib.rs\",\n+        \"completion/src/generated_lint_completions.rs\",\n+        // test for doc test for remove_dbg\n+        \"src/tests/generated.rs\",\n+    ];\n+    if need_dbg.iter().any(|p| path.ends_with(p)) {\n+        return;\n+    }\n+    if text.contains(\"dbg!\") {\n+        panic!(\n+            \"\\ndbg! macros should not be committed to the master branch,\\n\\\n+             {}\\n\",\n+            path.display(),\n+        )\n+    }\n+}\n+\n fn check_trailing_ws(path: &Path, text: &str) {\n     if is_exclude_dir(path, &[\"test_data\"]) {\n         return;"}]}