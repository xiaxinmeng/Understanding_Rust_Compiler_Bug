{"sha": "1ef16874b5ef79e193526cd23eebd30d45826360", "node_id": "C_kwDOAAsO6NoAKDFlZjE2ODc0YjVlZjc5ZTE5MzUyNmNkMjNlZWJkMzBkNDU4MjYzNjA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-01-02T13:09:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-06T11:17:41Z"}, "message": "also do not add noalias on not-Unpin Box", "tree": {"sha": "997b7585d5e67dbba9fb0a406f8e95e7a4e168e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/997b7585d5e67dbba9fb0a406f8e95e7a4e168e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ef16874b5ef79e193526cd23eebd30d45826360", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef16874b5ef79e193526cd23eebd30d45826360", "html_url": "https://github.com/rust-lang/rust/commit/1ef16874b5ef79e193526cd23eebd30d45826360", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ef16874b5ef79e193526cd23eebd30d45826360/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "html_url": "https://github.com/rust-lang/rust/commit/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71"}], "stats": {"total": 296, "additions": 180, "deletions": 116}, "files": [{"sha": "0306cb5ce6abd7615d068c093cff045333e2e26b", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ef16874b5ef79e193526cd23eebd30d45826360/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef16874b5ef79e193526cd23eebd30d45826360/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=1ef16874b5ef79e193526cd23eebd30d45826360", "patch": "@@ -1443,8 +1443,8 @@ pub enum PointerKind {\n     SharedRef { frozen: bool },\n     /// Mutable reference. `unpin` indicates the absence of any pinned data.\n     MutableRef { unpin: bool },\n-    /// Box.\n-    Box,\n+    /// Box. `unpin` indicates the absence of any pinned data.\n+    Box { unpin: bool },\n }\n \n /// Note that this information is advisory only, and backends are free to ignore it."}, {"sha": "4c2855821384bcf4ed35bda7e3635eaacdcc1e7d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 95, "deletions": 91, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/1ef16874b5ef79e193526cd23eebd30d45826360/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef16874b5ef79e193526cd23eebd30d45826360/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=1ef16874b5ef79e193526cd23eebd30d45826360", "patch": "@@ -818,110 +818,114 @@ where\n         let tcx = cx.tcx();\n         let param_env = cx.param_env();\n \n-        let pointee_info =\n-            match *this.ty.kind() {\n-                ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                    tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: None,\n-                    })\n-                }\n-                ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                    tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| {\n-                        PointeeInfo { size: layout.size, align: layout.align.abi, safe: None }\n-                    })\n-                }\n-                ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                    // Use conservative pointer kind if not optimizing. This saves us the\n-                    // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n-                    // attributes in LLVM have compile-time cost even in unoptimized builds).\n-                    let optimize = tcx.sess.opts.optimize != OptLevel::No;\n-                    let kind = match mt {\n-                        hir::Mutability::Not => PointerKind::SharedRef {\n-                            frozen: optimize && ty.is_freeze(tcx, cx.param_env()),\n-                        },\n-                        hir::Mutability::Mut => PointerKind::MutableRef {\n-                            unpin: optimize && ty.is_unpin(tcx, cx.param_env()),\n-                        },\n-                    };\n+        let pointee_info = match *this.ty.kind() {\n+            ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                })\n+            }\n+            ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n+                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                })\n+            }\n+            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                // Use conservative pointer kind if not optimizing. This saves us the\n+                // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n+                // attributes in LLVM have compile-time cost even in unoptimized builds).\n+                let optimize = tcx.sess.opts.optimize != OptLevel::No;\n+                let kind = match mt {\n+                    hir::Mutability::Not => PointerKind::SharedRef {\n+                        frozen: optimize && ty.is_freeze(tcx, cx.param_env()),\n+                    },\n+                    hir::Mutability::Mut => PointerKind::MutableRef {\n+                        unpin: optimize && ty.is_unpin(tcx, cx.param_env()),\n+                    },\n+                };\n \n-                    tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: Some(kind),\n-                    })\n-                }\n+                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: Some(kind),\n+                })\n+            }\n \n-                _ => {\n-                    let mut data_variant = match this.variants {\n-                        // Within the discriminant field, only the niche itself is\n-                        // always initialized, so we only check for a pointer at its\n-                        // offset.\n-                        //\n-                        // If the niche is a pointer, it's either valid (according\n-                        // to its type), or null (which the niche field's scalar\n-                        // validity range encodes). This allows using\n-                        // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                        // this will continue to work as long as we don't start\n-                        // using more niches than just null (e.g., the first page of\n-                        // the address space, or unaligned pointers).\n-                        Variants::Multiple {\n-                            tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n-                            tag_field,\n-                            ..\n-                        } if this.fields.offset(tag_field) == offset => {\n-                            Some(this.for_variant(cx, untagged_variant))\n-                        }\n-                        _ => Some(this),\n-                    };\n+            _ => {\n+                let mut data_variant = match this.variants {\n+                    // Within the discriminant field, only the niche itself is\n+                    // always initialized, so we only check for a pointer at its\n+                    // offset.\n+                    //\n+                    // If the niche is a pointer, it's either valid (according\n+                    // to its type), or null (which the niche field's scalar\n+                    // validity range encodes). This allows using\n+                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                    // this will continue to work as long as we don't start\n+                    // using more niches than just null (e.g., the first page of\n+                    // the address space, or unaligned pointers).\n+                    Variants::Multiple {\n+                        tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n+                        tag_field,\n+                        ..\n+                    } if this.fields.offset(tag_field) == offset => {\n+                        Some(this.for_variant(cx, untagged_variant))\n+                    }\n+                    _ => Some(this),\n+                };\n \n-                    if let Some(variant) = data_variant {\n-                        // We're not interested in any unions.\n-                        if let FieldsShape::Union(_) = variant.fields {\n-                            data_variant = None;\n-                        }\n+                if let Some(variant) = data_variant {\n+                    // We're not interested in any unions.\n+                    if let FieldsShape::Union(_) = variant.fields {\n+                        data_variant = None;\n                     }\n+                }\n \n-                    let mut result = None;\n-\n-                    if let Some(variant) = data_variant {\n-                        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n-                        // (requires passing in the expected address space from the caller)\n-                        let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n-                        for i in 0..variant.fields.count() {\n-                            let field_start = variant.fields.offset(i);\n-                            if field_start <= offset {\n-                                let field = variant.field(cx, i);\n-                                result = field.to_result().ok().and_then(|field| {\n-                                    if ptr_end <= field_start + field.size {\n-                                        // We found the right field, look inside it.\n-                                        let field_info =\n-                                            field.pointee_info_at(cx, offset - field_start);\n-                                        field_info\n-                                    } else {\n-                                        None\n-                                    }\n-                                });\n-                                if result.is_some() {\n-                                    break;\n+                let mut result = None;\n+\n+                if let Some(variant) = data_variant {\n+                    // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                    // (requires passing in the expected address space from the caller)\n+                    let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n+                    for i in 0..variant.fields.count() {\n+                        let field_start = variant.fields.offset(i);\n+                        if field_start <= offset {\n+                            let field = variant.field(cx, i);\n+                            result = field.to_result().ok().and_then(|field| {\n+                                if ptr_end <= field_start + field.size {\n+                                    // We found the right field, look inside it.\n+                                    let field_info =\n+                                        field.pointee_info_at(cx, offset - field_start);\n+                                    field_info\n+                                } else {\n+                                    None\n                                 }\n+                            });\n+                            if result.is_some() {\n+                                break;\n                             }\n                         }\n                     }\n+                }\n \n-                    // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                    if let Some(ref mut pointee) = result {\n-                        if let ty::Adt(def, _) = this.ty.kind() {\n-                            if def.is_box() && offset.bytes() == 0 {\n-                                pointee.safe = Some(PointerKind::Box);\n-                            }\n+                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                if let Some(ref mut pointee) = result {\n+                    if let ty::Adt(def, _) = this.ty.kind() {\n+                        if def.is_box() && offset.bytes() == 0 {\n+                            let optimize = tcx.sess.opts.optimize != OptLevel::No;\n+                            pointee.safe = Some(PointerKind::Box {\n+                                unpin: optimize && this.ty.boxed_ty().is_unpin(tcx, cx.param_env()),\n+                            });\n                         }\n                     }\n-\n-                    result\n                 }\n-            };\n+\n+                result\n+            }\n+        };\n \n         debug!(\n             \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\","}, {"sha": "ad5527f5a778b89bb11ba49c9f95c23f3b307491", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ef16874b5ef79e193526cd23eebd30d45826360/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef16874b5ef79e193526cd23eebd30d45826360/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=1ef16874b5ef79e193526cd23eebd30d45826360", "patch": "@@ -261,7 +261,7 @@ fn adjust_for_rust_scalar<'tcx>(\n             // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>). If LLVM had a way\n             // to say \"dereferenceable on entry\" we could use it here.\n             attrs.pointee_size = match kind {\n-                PointerKind::Box\n+                PointerKind::Box { .. }\n                 | PointerKind::SharedRef { frozen: false }\n                 | PointerKind::MutableRef { unpin: false } => Size::ZERO,\n                 PointerKind::SharedRef { frozen: true }\n@@ -278,17 +278,16 @@ fn adjust_for_rust_scalar<'tcx>(\n             // versions at all anymore. We still support turning it off using -Zmutable-noalias.\n             let noalias_mut_ref = cx.tcx.sess.opts.unstable_opts.mutable_noalias;\n \n-            // `&mut` pointer parameters never alias other parameters,\n-            // or mutable global data\n-            //\n             // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n             // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on memory\n             // dependencies rather than pointer equality. However this only applies to arguments,\n             // not return values.\n+            //\n+            // `&mut T` and `Box<T>` where `T: Unpin` are unique and hence `noalias`.\n             let no_alias = match kind {\n                 PointerKind::SharedRef { frozen } => frozen,\n                 PointerKind::MutableRef { unpin } => unpin && noalias_mut_ref,\n-                PointerKind::Box => noalias_for_box,\n+                PointerKind::Box { unpin } => unpin && noalias_for_box,\n             };\n             // We can never add `noalias` in return position; that LLVM attribute has some very surprising semantics\n             // (see <https://github.com/rust-lang/unsafe-code-guidelines/issues/385#issuecomment-1368055745>)."}, {"sha": "106e93751d21904c363c07bf26413a75505c78a7", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1ef16874b5ef79e193526cd23eebd30d45826360/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef16874b5ef79e193526cd23eebd30d45826360/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=1ef16874b5ef79e193526cd23eebd30d45826360", "patch": "@@ -135,6 +135,32 @@ impl NewPermission {\n         }\n     }\n \n+    fn from_box_ty<'tcx>(\n+        ty: Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Self {\n+        // `ty` is not the `Box` but the field of the Box with this pointer (due to allocator handling).\n+        let pointee = ty.builtin_deref(true).unwrap().ty;\n+        if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n+            // A regular box. On `FnEntry` this is `noalias`, but not `dereferenceable` (hence only\n+            // a weak protector).\n+            NewPermission::Uniform {\n+                perm: Permission::Unique,\n+                access: Some(AccessKind::Write),\n+                protector: (kind == RetagKind::FnEntry)\n+                    .then_some(ProtectorKind::WeakProtector),\n+            }\n+        } else {\n+            // `!Unpin` boxes do not get `noalias` nor `dereferenceable`.\n+            NewPermission::Uniform {\n+                perm: Permission::SharedReadWrite,\n+                access: None,\n+                protector: None,\n+            }\n+        }\n+    }\n+\n     fn protector(&self) -> Option<ProtectorKind> {\n         match self {\n             NewPermission::Uniform { protector, .. } => *protector,\n@@ -914,12 +940,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n-                let new_perm = NewPermission::Uniform {\n-                    perm: Permission::Unique,\n-                    access: Some(AccessKind::Write),\n-                    protector: (self.kind == RetagKind::FnEntry)\n-                        .then_some(ProtectorKind::WeakProtector),\n-                };\n+                let new_perm = NewPermission::from_box_ty(place.layout.ty, self.kind, self.ecx);\n                 self.retag_ptr_inplace(place, new_perm, self.retag_cause)\n             }\n "}, {"sha": "6994def16a1da3f537c9fb78bdc4a8622c2d13d5", "filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1ef16874b5ef79e193526cd23eebd30d45826360/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef16874b5ef79e193526cd23eebd30d45826360/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs?ref=1ef16874b5ef79e193526cd23eebd30d45826360", "patch": "@@ -26,6 +26,19 @@ impl Future for Delay {\n     }\n }\n \n+fn mk_waker() -> Waker {\n+    use std::sync::Arc;\n+\n+    struct MyWaker;\n+    impl Wake for MyWaker {\n+        fn wake(self: Arc<Self>) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    Waker::from(Arc::new(MyWaker))\n+}\n+\n async fn do_stuff() {\n     (&mut Delay::new(1)).await;\n }\n@@ -73,16 +86,7 @@ impl Future for DoStuff {\n }\n \n fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n-    use std::sync::Arc;\n-\n-    struct MyWaker;\n-    impl Wake for MyWaker {\n-        fn wake(self: Arc<Self>) {\n-            unimplemented!()\n-        }\n-    }\n-\n-    let waker = Waker::from(Arc::new(MyWaker));\n+    let waker = mk_waker();\n     let mut context = Context::from_waker(&waker);\n \n     let mut pinned = pin!(fut);\n@@ -94,7 +98,37 @@ fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n     }\n }\n \n+fn self_referential_box() {\n+    let waker = mk_waker();\n+    let cx = &mut Context::from_waker(&waker);\n+\n+    async fn my_fut() -> i32 {\n+        let val = 10;\n+        let val_ref = &val;\n+\n+        let _ = Delay::new(1).await;\n+\n+        *val_ref\n+    }\n+\n+    fn box_poll<F: Future>(\n+        mut f: Pin<Box<F>>,\n+        cx: &mut Context<'_>,\n+    ) -> (Pin<Box<F>>, Poll<F::Output>) {\n+        let p = f.as_mut().poll(cx);\n+        (f, p)\n+    }\n+\n+    let my_fut = Box::pin(my_fut());\n+    let (my_fut, p1) = box_poll(my_fut, cx);\n+    assert!(p1.is_pending());\n+    let (my_fut, p2) = box_poll(my_fut, cx);\n+    assert!(p2.is_ready());\n+    drop(my_fut);\n+}\n+\n fn main() {\n     run_fut(do_stuff());\n     run_fut(DoStuff::new());\n+    self_referential_box();\n }"}, {"sha": "96dfde18683e34b2c3ab452a79920edd040a72a1", "filename": "tests/codegen/function-arguments.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ef16874b5ef79e193526cd23eebd30d45826360/tests%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef16874b5ef79e193526cd23eebd30d45826360/tests%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments.rs?ref=1ef16874b5ef79e193526cd23eebd30d45826360", "patch": "@@ -181,6 +181,12 @@ pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n }\n \n+// CHECK: noundef nonnull align 4 {{i32\\*|ptr}} @notunpin_box({{i32\\*|ptr}} noundef nonnull align 4 %x)\n+#[no_mangle]\n+pub fn notunpin_box(x: Box<NotUnpin>) -> Box<NotUnpin> {\n+  x\n+}\n+\n // CHECK: @struct_return({{%S\\*|ptr}} noalias nocapture noundef sret(%S) dereferenceable(32){{( %0)?}})\n #[no_mangle]\n pub fn struct_return() -> S {\n@@ -247,12 +253,12 @@ pub fn trait_raw(_: *const dyn Drop) {\n \n // CHECK: @trait_box({{\\{\\}\\*|ptr}} noalias noundef nonnull align 1{{( %0)?}}, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}){{( %1)?}})\n #[no_mangle]\n-pub fn trait_box(_: Box<dyn Drop>) {\n+pub fn trait_box(_: Box<dyn Drop + Unpin>) {\n }\n \n // CHECK: { {{i8\\*|ptr}}, {{i8\\*|ptr}} } @trait_option({{i8\\*|ptr}} noalias noundef align 1 %x.0, {{i8\\*|ptr}} %x.1)\n #[no_mangle]\n-pub fn trait_option(x: Option<Box<dyn Drop>>) -> Option<Box<dyn Drop>> {\n+pub fn trait_option(x: Option<Box<dyn Drop + Unpin>>) -> Option<Box<dyn Drop + Unpin>> {\n   x\n }\n "}]}