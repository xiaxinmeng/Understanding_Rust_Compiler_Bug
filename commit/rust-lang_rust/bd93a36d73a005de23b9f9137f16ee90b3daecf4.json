{"sha": "bd93a36d73a005de23b9f9137f16ee90b3daecf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOTNhMzZkNzNhMDA1ZGUyM2I5ZjkxMzdmMTZlZTkwYjNkYWVjZjQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-02-15T04:20:36Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-02-15T04:20:36Z"}, "message": "Made num <-> str conversion functions use NumStrConv trait\n\nRemoved hacky dependency on Round trait and generic infinity functions\nRemoved generic-runtime-failure-depending-on-type behavior", "tree": {"sha": "c16a12d521da770794a23c04a9cb32e3d2429f29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c16a12d521da770794a23c04a9cb32e3d2429f29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd93a36d73a005de23b9f9137f16ee90b3daecf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd93a36d73a005de23b9f9137f16ee90b3daecf4", "html_url": "https://github.com/rust-lang/rust/commit/bd93a36d73a005de23b9f9137f16ee90b3daecf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd93a36d73a005de23b9f9137f16ee90b3daecf4/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26e0aafb889fab89c1dee5d74131455826cfa6ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/26e0aafb889fab89c1dee5d74131455826cfa6ed", "html_url": "https://github.com/rust-lang/rust/commit/26e0aafb889fab89c1dee5d74131455826cfa6ed"}], "stats": {"total": 230, "additions": 111, "deletions": 119}, "files": [{"sha": "79623402c4d30c188e8c22c9fc121b2d30e582a9", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=bd93a36d73a005de23b9f9137f16ee90b3daecf4", "patch": "@@ -378,7 +378,7 @@ impl num::Round for f32 {\n #[inline(always)]\n pub pure fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -392,7 +392,7 @@ pub pure fn to_str(num: f32) -> ~str {\n #[inline(always)]\n pub pure fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 16u, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -413,7 +413,7 @@ pub pure fn to_str_hex(num: f32) -> ~str {\n #[inline(always)]\n pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n-        &num, rdx, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -430,7 +430,7 @@ pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n-    strconv::to_str_common(&num, rdx, true, true,\n+    strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n@@ -446,7 +446,7 @@ pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n #[inline(always)]\n pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigExact(dig));\n+        &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n@@ -462,7 +462,7 @@ pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n #[inline(always)]\n pub pure fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigMax(dig));\n+        &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n "}, {"sha": "51ee8eeba919d18cc25860b5751fcf8eb98214e2", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=bd93a36d73a005de23b9f9137f16ee90b3daecf4", "patch": "@@ -403,7 +403,7 @@ impl num::Round for f64 {\n #[inline(always)]\n pub pure fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -417,7 +417,7 @@ pub pure fn to_str(num: f64) -> ~str {\n #[inline(always)]\n pub pure fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 16u, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -438,7 +438,7 @@ pub pure fn to_str_hex(num: f64) -> ~str {\n #[inline(always)]\n pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n-        &num, rdx, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -455,7 +455,7 @@ pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n-    strconv::to_str_common(&num, rdx, true, true,\n+    strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n@@ -471,7 +471,7 @@ pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n #[inline(always)]\n pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigExact(dig));\n+        &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n@@ -487,7 +487,7 @@ pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n #[inline(always)]\n pub pure fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigMax(dig));\n+        &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n "}, {"sha": "31bd08b12418e6afb0af52e363c23196dfd8e51c", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=bd93a36d73a005de23b9f9137f16ee90b3daecf4", "patch": "@@ -109,7 +109,7 @@ pub mod consts {\n #[inline(always)]\n pub pure fn to_str(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -123,7 +123,7 @@ pub pure fn to_str(num: float) -> ~str {\n #[inline(always)]\n pub pure fn to_str_hex(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 16u, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -144,7 +144,7 @@ pub pure fn to_str_hex(num: float) -> ~str {\n #[inline(always)]\n pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n-        &num, radix, true, true, strconv::SignNeg, strconv::DigAll);\n+        &num, radix, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -161,7 +161,7 @@ pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n-    strconv::to_str_common(&num, radix, true, true,\n+    strconv::to_str_common(&num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n@@ -177,7 +177,7 @@ pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n #[inline(always)]\n pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigExact(digits));\n+        &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n     r\n }\n \n@@ -199,7 +199,7 @@ pub fn test_to_str_exact_do_decimal() {\n #[inline(always)]\n pub pure fn to_str_digits(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, true, strconv::SignNeg, strconv::DigMax(digits));\n+        &num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n     r\n }\n "}, {"sha": "c0624608a15f557dc0f6cf6e3b34bcd1bb948fad", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=bd93a36d73a005de23b9f9137f16ee90b3daecf4", "patch": "@@ -256,23 +256,23 @@ impl FromStrRadix for T {\n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n-    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false, false,\n+    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n pub pure fn to_str(num: T) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, 10u, false, false,\n+    let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, radix, false, false,\n+    let (buf, _) = strconv::to_str_common(&num, radix, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }"}, {"sha": "7d6b62542621bd501e9bb36036935a96966813ef", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 87, "deletions": 95, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=bd93a36d73a005de23b9f9137f16ee90b3daecf4", "patch": "@@ -16,9 +16,9 @@ use str;\n use kinds::Copy;\n use vec;\n use num::{NumCast, Zero, One, cast, pow_with_uint};\n-use num::{Round, RoundToZero,\n+/*use num::{Round, RoundToZero,\n           is_NaN, is_infinity, is_neg_infinity, is_neg_zero,\n-          infinity, neg_infinity, NaN};\n+          infinity, neg_infinity, NaN};*/\n use float;\n use f32;\n use f64;\n@@ -42,59 +42,61 @@ pub enum SignFormat {\n }\n \n pub trait NumStrConv {\n-    static fn has_NaN()      -> bool;\n-    static fn has_inf()      -> bool;\n-    static fn has_neg_inf()  -> bool;\n-    static fn has_neg_zero() -> bool;\n+    static pure fn has_NaN()      -> bool;\n+    static pure fn has_inf()      -> bool;\n+    static pure fn has_neg_inf()  -> bool;\n+    static pure fn has_neg_zero() -> bool;\n \n-    static fn NaN()      -> Option<Self>;\n-    static fn inf()      -> Option<Self>;\n-    static fn neg_inf()  -> Option<Self>;\n-    static fn neg_zero() -> Option<Self>;\n+    static pure fn NaN()      -> Option<Self>;\n+    static pure fn inf()      -> Option<Self>;\n+    static pure fn neg_inf()  -> Option<Self>;\n+    static pure fn neg_zero() -> Option<Self>;\n \n-    fn is_NaN(&self)      -> bool;\n-    fn is_inf(&self)      -> bool;\n-    fn is_neg_inf(&self)  -> bool;\n-    fn is_neg_zero(&self) -> bool;\n+    pure fn is_NaN(&self)      -> bool;\n+    pure fn is_inf(&self)      -> bool;\n+    pure fn is_neg_inf(&self)  -> bool;\n+    pure fn is_neg_zero(&self) -> bool;\n \n-    fn round_to_zero(&self) -> Self;\n-    fn split_at_dot(&self) -> (Self, Self);\n+    pure fn round_to_zero(&self)   -> Self;\n+    pure fn fractional_part(&self) -> Self;\n \n }\n \n macro_rules! impl_NumStrConv_Floating (\n     ($t:ty) => (\n         impl NumStrConv for $t {\n-            static fn has_NaN()      -> bool { true }\n-            static fn has_inf()      -> bool { true }\n-            static fn has_neg_inf()  -> bool { true }\n-            static fn has_neg_zero() -> bool { true }\n-\n-            static fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n-            static fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n-            static fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n-            static fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n-\n-            fn is_NaN(&self)      -> bool { *self != *self }\n-            fn is_inf(&self)      -> bool {\n+            static pure fn has_NaN()      -> bool { true }\n+            static pure fn has_inf()      -> bool { true }\n+            static pure fn has_neg_inf()  -> bool { true }\n+            static pure fn has_neg_zero() -> bool { true }\n+\n+            static pure fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n+            static pure fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n+            static pure fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n+            static pure fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n+\n+            pure fn is_NaN(&self)      -> bool { *self != *self }\n+\n+            pure fn is_inf(&self)      -> bool {\n                 *self == NumStrConv::inf().unwrap()\n             }\n-            fn is_neg_inf(&self)  -> bool {\n+\n+            pure fn is_neg_inf(&self)  -> bool {\n                 *self == NumStrConv::neg_inf().unwrap()\n             }\n-            fn is_neg_zero(&self) -> bool {\n+\n+            pure fn is_neg_zero(&self) -> bool {\n                 *self == 0.0 && (1.0 / *self).is_neg_inf()\n             }\n \n-            fn round_to_zero(&self) -> $t {\n+            pure fn round_to_zero(&self) -> $t {\n                 ( if *self < 0.0 { f64::ceil(*self as f64)  }\n                   else           { f64::floor(*self as f64) }\n                 ) as $t\n             }\n \n-            fn split_at_dot(&self) -> ($t, $t) {\n-                let r = self.round_to_zero();\n-                (r, *self - r)\n+            pure fn fractional_part(&self) -> $t {\n+                *self - self.round_to_zero()\n             }\n         }\n     )\n@@ -103,24 +105,23 @@ macro_rules! impl_NumStrConv_Floating (\n macro_rules! impl_NumStrConv_Integer (\n     ($t:ty) => (\n         impl NumStrConv for $t {\n-            static fn has_NaN()      -> bool { false }\n-            static fn has_inf()      -> bool { false }\n-            static fn has_neg_inf()  -> bool { false }\n-            static fn has_neg_zero() -> bool { false }\n-\n-            static fn NaN()      -> Option<$t> { None }\n-            static fn inf()      -> Option<$t> { None }\n-            static fn neg_inf()  -> Option<$t> { None }\n-            static fn neg_zero() -> Option<$t> { None }\n-\n-            fn is_NaN(&self)      -> bool { false }\n-            fn is_inf(&self)      -> bool { false }\n-            fn is_neg_inf(&self)  -> bool { false }\n-            fn is_neg_zero(&self) -> bool { false }\n-\n-            fn round_to_zero(&self) -> $t { *self }\n-\n-            fn split_at_dot(&self) -> ($t, $t) { (*self, 0) }\n+            static pure fn has_NaN()      -> bool { false }\n+            static pure fn has_inf()      -> bool { false }\n+            static pure fn has_neg_inf()  -> bool { false }\n+            static pure fn has_neg_zero() -> bool { false }\n+\n+            static pure fn NaN()      -> Option<$t> { None }\n+            static pure fn inf()      -> Option<$t> { None }\n+            static pure fn neg_inf()  -> Option<$t> { None }\n+            static pure fn neg_zero() -> Option<$t> { None }\n+\n+            pure fn is_NaN(&self)      -> bool { false }\n+            pure fn is_inf(&self)      -> bool { false }\n+            pure fn is_neg_inf(&self)  -> bool { false }\n+            pure fn is_neg_zero(&self) -> bool { false }\n+\n+            pure fn round_to_zero(&self)   -> $t { *self }\n+            pure fn fractional_part(&self) -> $t {     0 }\n         }\n     )\n )\n@@ -142,6 +143,8 @@ impl_NumStrConv_Integer!(u16)\n impl_NumStrConv_Integer!(u32)\n impl_NumStrConv_Integer!(u64)\n \n+// NOTE: inline the methods\n+\n /**\n  * Converts a number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all numeric string\n@@ -151,10 +154,6 @@ impl_NumStrConv_Integer!(u64)\n  * - `num`           - The number to convert. Accepts any number that\n  *                     implements the numeric traits.\n  * - `radix`         - Base to use. Accepts only the values 2-36.\n- * - `special`       - Whether to attempt to compare to special values like\n- *                     `inf` or `NaN`. Also needed to detect negative 0.\n- *                     Can fail if it doesn't match `num`s type\n- *                     (see safety note).\n  * - `negative_zero` - Whether to treat the special value `-0` as\n  *                     `-0` or as `+0`.\n  * - `sign`          - How to emit the sign. Options are:\n@@ -176,19 +175,10 @@ impl_NumStrConv_Integer!(u64)\n  *\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails on wrong value for `special` (see safety note).\n- *\n- * # Safety note\n- * The function detects the special values `inf`, `-inf` and `NaN` by\n- * dynamically comparing `num` to `1 / 0`, `-1 / 0` and `0 / 0`\n- * (each of type T) if `special` is `true`. This will fail on integer types\n- * with a 'divide by zero'. Likewise, it will fail if `num` **is** one of\n- * those special values, and `special` is `false`, because then the\n- * algorithm just does normal calculations on them.\n  */\n-pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n+pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+Div<T,T>+\n                                   Neg<T>+Modulo<T,T>+Mul<T,T>>(\n-        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n     if radix as int <  2 {\n         fail!(fmt!(\"to_str_bytes_common: radix %? to low, \\\n@@ -201,32 +191,33 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n-    if special {\n-        if is_NaN(num) {\n-            return (str::to_bytes(\"NaN\"), true);\n-        } else if is_infinity(num){\n-            return match sign {\n-                SignAll => (str::to_bytes(\"+inf\"), true),\n-                _       => (str::to_bytes(\"inf\"), true)\n-            }\n-        } else if is_neg_infinity(num) {\n-            return match sign {\n-                SignNone => (str::to_bytes(\"inf\"), true),\n-                _        => (str::to_bytes(\"-inf\"), true),\n-            }\n+    if NumStrConv::has_NaN::<T>() && num.is_NaN() {\n+        return (str::to_bytes(\"NaN\"), true);\n+    }\n+    if NumStrConv::has_inf::<T>() && num.is_inf(){\n+        return match sign {\n+            SignAll => (str::to_bytes(\"+inf\"), true),\n+            _       => (str::to_bytes(\"inf\"), true)\n+        }\n+    }\n+    if NumStrConv::has_neg_inf::<T>() && num.is_neg_inf() {\n+        return match sign {\n+            SignNone => (str::to_bytes(\"inf\"), true),\n+            _        => (str::to_bytes(\"-inf\"), true),\n         }\n     }\n \n-    let neg = *num < _0 || (negative_zero && *num == _0\n-                            && special && is_neg_zero(num));\n+    let neg = *num < _0 || (negative_zero\n+                            && NumStrConv::has_neg_zero::<T>()\n+                            && num.is_neg_zero());\n     let mut buf: ~[u8] = ~[];\n     let radix_gen: T   = cast(radix as int);\n \n     let mut deccum;\n \n     // First emit the non-fractional part, looping at least once to make\n     // sure at least a `0` gets emitted.\n-    deccum = num.round(RoundToZero);\n+    deccum = num.round_to_zero();\n     loop {\n         // Calculate the absolute value of each digit instead of only\n         // doing it once for the whole number because a\n@@ -243,7 +234,7 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n \n         // Decrease the deccumulator one digit at a time\n         deccum /= radix_gen;\n-        deccum = deccum.round(RoundToZero);\n+        deccum = deccum.round_to_zero();\n \n         unsafe { // FIXME: Pureness workaround (#4568)\n             buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n@@ -286,7 +277,7 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n     let start_fractional_digits = buf.len();\n \n     // Now emit the fractional part, if any\n-    deccum = num.fract();\n+    deccum = num.fractional_part();\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n         unsafe { // FIXME: Pureness workaround (#4568)\n             buf.push('.' as u8);\n@@ -309,7 +300,7 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n \n             // Calculate the absolute value of each digit.\n             // See note in first loop.\n-            let current_digit_signed = deccum.round(RoundToZero);\n+            let current_digit_signed = deccum.round_to_zero();\n             let current_digit = if current_digit_signed < _0 {\n                 -current_digit_signed\n             } else {\n@@ -322,7 +313,7 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n             }\n \n             // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n+            deccum = deccum.fractional_part();\n             dig += 1u;\n         }\n \n@@ -409,11 +400,11 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+Neg<T>\n+pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+Div<T,T>+Neg<T>\n                             +Modulo<T,T>+Mul<T,T>>(\n-        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n-    let (bytes, special) = to_str_bytes_common(num, radix, special,\n+    let (bytes, special) = to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits);\n     (str::from_bytes(bytes), special)\n }\n@@ -466,7 +457,7 @@ priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  *   formated like `FF_AE_FF_FF`.\n  */\n pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n-                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>>(\n+                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool\n         ) -> Option<T> {\n@@ -503,17 +494,18 @@ pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n         }\n     }\n \n+    // XXX: Bytevector constant from str\n     if special {\n         if buf == str::to_bytes(\"inf\") || buf == str::to_bytes(\"+inf\") {\n-            return Some(infinity());\n+            return NumStrConv::inf();\n         } else if buf == str::to_bytes(\"-inf\") {\n             if negative {\n-                return Some(neg_infinity());\n+                return NumStrConv::neg_inf();\n             } else {\n                 return None;\n             }\n         } else if buf == str::to_bytes(\"NaN\") {\n-            return Some(NaN());\n+            return NumStrConv::NaN();\n         }\n     }\n \n@@ -654,7 +646,7 @@ pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n  */\n #[inline(always)]\n pub pure fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n-                              Sub<T,T>+Neg<T>+Add<T,T>>(\n+                              Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool\n         ) -> Option<T> {"}, {"sha": "c5743b40a89e42f37737dccdb91e64fb1453331f", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd93a36d73a005de23b9f9137f16ee90b3daecf4/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=bd93a36d73a005de23b9f9137f16ee90b3daecf4", "patch": "@@ -220,23 +220,23 @@ impl FromStrRadix for T {\n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n-    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false, false,\n+    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n pub pure fn to_str(num: T) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, 10u, false, false,\n+    let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, radix, false, false,\n+    let (buf, _) = strconv::to_str_common(&num, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }"}]}