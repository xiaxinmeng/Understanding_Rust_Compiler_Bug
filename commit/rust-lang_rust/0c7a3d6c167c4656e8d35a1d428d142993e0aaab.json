{"sha": "0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjN2EzZDZjMTY3YzQ2NTZlOGQzNWExZDQyOGQxNDI5OTNlMGFhYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-16T11:27:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-16T11:27:35Z"}, "message": "auto merge of #18978 : jakub-/rust/roll-up, r=cmr", "tree": {"sha": "bf70393828be01b5042bdc76031d0a9ec7cb4900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf70393828be01b5042bdc76031d0a9ec7cb4900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "html_url": "https://github.com/rust-lang/rust/commit/0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb51567e1911452f3da4b924a91e5360f5efe67c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb51567e1911452f3da4b924a91e5360f5efe67c", "html_url": "https://github.com/rust-lang/rust/commit/cb51567e1911452f3da4b924a91e5360f5efe67c"}, {"sha": "892d4e28f4021ffa815649ec3a52f22f929b3708", "url": "https://api.github.com/repos/rust-lang/rust/commits/892d4e28f4021ffa815649ec3a52f22f929b3708", "html_url": "https://github.com/rust-lang/rust/commit/892d4e28f4021ffa815649ec3a52f22f929b3708"}], "stats": {"total": 1944, "additions": 1011, "deletions": 933}, "files": [{"sha": "b7d4596b0febf528302f049be36cc40cc49a1888", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::from_str::FromStr;\n use std::fmt;\n+use std::str::FromStr;\n use regex::Regex;\n \n #[deriving(Clone, PartialEq)]"}, {"sha": "d49ff0258ab02917a6599986adbd28448bb4bd9e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -22,7 +22,7 @@ extern crate regex;\n use std::os;\n use std::io;\n use std::io::fs;\n-use std::from_str::FromStr;\n+use std::str::FromStr;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};"}, {"sha": "60ef76528e849cee43367fd53a7211d200c4ad00", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -12,8 +12,6 @@ use common::Config;\n use common;\n use util;\n \n-use std::from_str::FromStr;\n-\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     pub error_patterns: Vec<String> ,\n@@ -353,8 +351,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = FromStr::from_str(components[0]).expect(error_string);\n-    let minor: int = FromStr::from_str(components[1]).expect(error_string);\n+    let major: int = from_str(components[0]).expect(error_string);\n+    let minor: int = from_str(components[1]).expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -364,6 +362,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = FromStr::from_str(version_string).expect(error_string);\n+    let major: int = from_str(version_string).expect(error_string);\n     return major;\n }"}, {"sha": "e57953db3a256fd2463ad6a04d3015dccd830c96", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -95,7 +95,7 @@ code should need to run is a stack.\n `match` being exhaustive has some useful properties. First, if every\n possibility is covered by the `match`, adding further variants to the `enum`\n in the future will prompt a compilation failure, rather than runtime panic.\n-Second, it makes cost explicit. In general, only safe way to have a\n+Second, it makes cost explicit. In general, the only safe way to have a\n non-exhaustive match would be to panic the task if nothing is matched, though\n it could fall through if the type of the `match` expression is `()`. This sort\n of hidden cost and special casing is against the language's philosophy. It's"}, {"sha": "2c6388a61805299dccc141afb412f0446f0be2d4", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -133,11 +133,11 @@ pass-by-reference. Basically, languages can make two choices (this is made\n up syntax, it's not Rust):\n \n ```{notrust,ignore}\n-fn foo(x) {\n+func foo(x) {\n     x = 5\n }\n \n-fn main() {\n+func main() {\n     i = 1\n     foo(i)\n     // what is the value of i here?\n@@ -153,11 +153,11 @@ So what do pointers have to do with this? Well, since pointers point to a\n location in memory...\n \n ```{notrust,ignore}\n-fn foo(&int x) {\n+func foo(&int x) {\n     *x = 5\n }\n \n-fn main() {\n+func main() {\n     i = 1\n     foo(&i)\n     // what is the value of i here?\n@@ -192,13 +192,13 @@ When you combine pointers and functions, it's easy to accidentally invalidate\n the memory the pointer is pointing to. For example:\n \n ```{notrust,ignore}\n-fn make_pointer(): &int {\n+func make_pointer(): &int {\n     x = 5;\n \n     return &x;\n }\n \n-fn main() {\n+func main() {\n     &int i = make_pointer();\n     *i = 5; // uh oh!\n }\n@@ -214,11 +214,11 @@ issue. Two pointers are said to alias when they point at the same location\n in memory. Like this:\n \n ```{notrust,ignore}\n-fn mutate(&int i, int j) {\n+func mutate(&int i, int j) {\n     *i = j;\n }\n \n-fn main() {\n+func main() {\n   x = 5;\n   y = &x;\n   z = &x; //y and z are aliased"}, {"sha": "071c9ff013c59d248237af77ed2201436b02cffb", "filename": "src/doc/guide-strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Fguide-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Fguide-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-strings.md?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -155,7 +155,7 @@ println!(\"{}\", s[0]);\n This does not compile. This is on purpose. In the world of UTF-8, direct\n indexing is basically never what you want to do. The reason is that each\n character can be a variable number of bytes. This means that you have to iterate\n-through the characters anyway, which is a O(n) operation. \n+through the characters anyway, which is an O(n) operation.\n \n There's 3 basic levels of unicode (and its encodings):\n "}, {"sha": "5d1401e27ba4aa4ce771739f4560dfc31dd68fd9", "filename": "src/doc/reference.md", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -2526,7 +2526,7 @@ The currently implemented features of the reference compiler are:\n \n * `plugin_registrar` - Indicates that a crate has [compiler plugins][plugin] that it\n                        wants to load. As with `phase`, the implementation is\n-                       in need of a overhaul, and it is not clear that plugins\n+                       in need of an overhaul, and it is not clear that plugins\n                        defined using this will continue to work.\n \n * `quote` - Allows use of the `quote_*!` family of macros, which are\n@@ -2583,7 +2583,7 @@ there isn't a parser error first). The directive in this case is no longer\n necessary, and it's likely that existing code will break if the feature isn't\n removed.\n \n-If a unknown feature is found in a directive, it results in a compiler error.\n+If an unknown feature is found in a directive, it results in a compiler error.\n An unknown feature is one which has never been recognized by the compiler.\n \n # Statements and expressions\n@@ -2685,7 +2685,7 @@ When an lvalue is evaluated in an _lvalue context_, it denotes a memory\n location; when evaluated in an _rvalue context_, it denotes the value held _in_\n that memory location.\n \n-When an rvalue is used in lvalue context, a temporary un-named lvalue is\n+When an rvalue is used in an lvalue context, a temporary un-named lvalue is\n created and used instead. A temporary's lifetime equals the largest lifetime\n of any reference that points to it.\n \n@@ -2833,7 +2833,7 @@ foo().x;\n ```\n \n A field access is an [lvalue](#lvalues,-rvalues-and-temporaries) referring to\n-the value of that field. When the type providing the field inherits mutabilty,\n+the value of that field. When the type providing the field inherits mutability,\n it can be [assigned](#assignment-expressions) to.\n \n Also, if the type of the expression to the left of the dot is a pointer, it is\n@@ -3108,11 +3108,10 @@ then the expression completes.\n Some examples of call expressions:\n \n ```\n-# use std::from_str::FromStr;\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi: Option<f32> = FromStr::from_str(\"3.14\");\n+let pi: Option<f32> = from_str(\"3.14\");\n ```\n \n ### Lambda expressions\n@@ -3321,7 +3320,7 @@ between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n exactly one argument, while the pattern `C(..)` is type-correct for any enum\n variant `C`, regardless of how many arguments `C` has.\n \n-Used inside a array pattern, `..` stands for any number of elements, when the\n+Used inside an array pattern, `..` stands for any number of elements, when the\n `advanced_slice_patterns` feature gate is turned on. This wildcard can be used\n at most once for a given array, which implies that it cannot be used to\n specifically match elements that are at an unknown distance from both ends of a\n@@ -3584,7 +3583,7 @@ is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to\n 0xD7FF or 0xE000 to 0x10FFFF range. A `[char]` array is effectively an UCS-4 /\n UTF-32 string.\n \n-A value of type `str` is a Unicode string, represented as a array of 8-bit\n+A value of type `str` is a Unicode string, represented as an array of 8-bit\n unsigned bytes holding a sequence of UTF-8 codepoints. Since `str` is of\n unknown size, it is not a _first class_ type, but can only be instantiated\n through a pointer type, such as `&str` or `String`."}, {"sha": "cb99da8092df03aabebb726c702001dc9ec1b0f6", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -75,7 +75,11 @@ def full_snapshot_name(date, rev, platform, hsh):\n \n \n def get_kernel(triple):\n-    os_name = triple.split('-')[2]\n+    t = triple.split('-')\n+    if len(t) == 2:\n+      os_name = t[1]\n+    else:\n+      os_name = t[2]\n     if os_name == \"windows\":\n         return \"winnt\"\n     if os_name == \"darwin\":"}, {"sha": "1b1b65bd560e16fb93b1fd73d6ece63a918f32b7", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -105,7 +105,7 @@ syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n syn keyword rustTrait Str StrVector StrSlice\n syn keyword rustTrait IntoMaybeOwned StrAllocating UnicodeStrSlice\n-syn keyword rustTrait ToString IntoStr\n+syn keyword rustTrait ToString IntoString\n syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8\n syn keyword rustTrait Tuple9 Tuple10 Tuple11 Tuple12"}, {"sha": "501f915461a27844cf162732f8a3848d7e9f1017", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -179,9 +179,9 @@ pub struct Rc<T> {\n     _noshare: marker::NoSync\n }\n \n-#[stable]\n impl<T> Rc<T> {\n     /// Constructs a new reference-counted pointer.\n+    #[stable]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -200,9 +200,7 @@ impl<T> Rc<T> {\n             }\n         }\n     }\n-}\n \n-impl<T> Rc<T> {\n     /// Downgrades the reference-counted pointer to a weak reference.\n     #[experimental = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {"}, {"sha": "a2f89dfecbc1370bd6239e6770466a98fb554af9", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -73,6 +73,7 @@ pub use core::str::{CharSplitsN, AnyLines, MatchIndices, StrSplits};\n pub use core::str::{Utf16CodeUnits, eq_slice, is_utf8, is_utf16, Utf16Items};\n pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n+pub use core::str::{FromStr, from_str};\n pub use core::str::{Str, StrPrelude};\n pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n "}, {"sha": "3c75198a368bffa4a72c02b9d19d3219d12785b4", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -25,7 +25,7 @@ use core::raw::Slice as RawSlice;\n use hash;\n use slice::CloneSliceAllocPrelude;\n use str;\n-use str::{CharRange, StrAllocating, MaybeOwned, Owned};\n+use str::{CharRange, FromStr, StrAllocating, MaybeOwned, Owned};\n use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -795,6 +795,33 @@ pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n \n+impl FromStr for String {\n+    #[inline]\n+    fn from_str(s: &str) -> Option<String> {\n+        Some(String::from_str(s))\n+    }\n+}\n+\n+/// Trait for converting a type to a string, consuming it in the process.\n+pub trait IntoString {\n+    /// Consume and convert to a string.\n+    fn into_string(self) -> String;\n+}\n+\n+/// A generic trait for converting a value to a string\n+pub trait ToString {\n+    /// Converts the value of `self` to an owned string\n+    fn to_string(&self) -> String;\n+}\n+\n+impl<T: fmt::Show> ToString for T {\n+    fn to_string(&self) -> String {\n+        let mut buf = Vec::<u8>::new();\n+        let _ = format_args!(|args| fmt::write(&mut buf, args), \"{}\", self);\n+        String::from_utf8(buf).unwrap()\n+    }\n+}\n+\n /// Unsafe operations\n #[unstable = \"waiting on raw module conventions\"]\n pub mod raw {\n@@ -860,7 +887,7 @@ mod tests {\n \n     use str;\n     use str::{Str, StrPrelude, Owned};\n-    use super::{as_string, String};\n+    use super::{as_string, String, ToString};\n     use vec::Vec;\n     use slice::CloneSliceAllocPrelude;\n \n@@ -1164,6 +1191,28 @@ mod tests {\n         assert_eq!(\"oob\", s[1..4]);\n     }\n \n+    #[test]\n+    fn test_simple_types() {\n+        assert_eq!(1i.to_string(), \"1\".to_string());\n+        assert_eq!((-1i).to_string(), \"-1\".to_string());\n+        assert_eq!(200u.to_string(), \"200\".to_string());\n+        assert_eq!(2u8.to_string(), \"2\".to_string());\n+        assert_eq!(true.to_string(), \"true\".to_string());\n+        assert_eq!(false.to_string(), \"false\".to_string());\n+        assert_eq!(().to_string(), \"()\".to_string());\n+        assert_eq!((\"hi\".to_string()).to_string(), \"hi\".to_string());\n+    }\n+\n+    #[test]\n+    fn test_vectors() {\n+        let x: Vec<int> = vec![];\n+        assert_eq!(x.to_string(), \"[]\".to_string());\n+        assert_eq!((vec![1i]).to_string(), \"[1]\".to_string());\n+        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\".to_string());\n+        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n+               \"[[], [1], [1, 1]]\".to_string());\n+    }\n+\n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "1005732a1e24ff0e4cfd1531cb0e6242b4111f96", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -504,9 +504,9 @@ impl<T: Ord> TreeSet<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::BTreeSet;\n+    /// use std::collections::TreeSet;\n     ///\n-    /// let mut set = BTreeSet::new();\n+    /// let mut set = TreeSet::new();\n     ///\n     /// assert_eq!(set.insert(2i), true);\n     /// assert_eq!(set.insert(2i), false);\n@@ -522,9 +522,9 @@ impl<T: Ord> TreeSet<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::BTreeSet;\n+    /// use std::collections::TreeSet;\n     ///\n-    /// let mut set = BTreeSet::new();\n+    /// let mut set = TreeSet::new();\n     ///\n     /// set.insert(2i);\n     /// assert_eq!(set.remove(&2), true);"}, {"sha": "fdee089380bbb6b340cd262439e6de03a7ef7c69", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -645,7 +645,6 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -1653,6 +1652,13 @@ impl<T> Vec<T> {\n     }\n }\n \n+impl<'a> fmt::FormatWriter for Vec<u8> {\n+    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+        self.push_all(buf);\n+        Ok(())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "5511266b4cd2276600c3b8fdf9232fa903c3f37a", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -88,6 +88,7 @@ use intrinsics::TypeId;\n #[stable]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n+    #[stable]\n     fn get_type_id(&self) -> TypeId;\n }\n \n@@ -117,7 +118,6 @@ pub trait AnyRefExt<'a> {\n #[stable]\n impl<'a> AnyRefExt<'a> for &'a Any {\n     #[inline]\n-    #[stable]\n     fn is<T: 'static>(self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n@@ -130,7 +130,6 @@ impl<'a> AnyRefExt<'a> for &'a Any {\n     }\n \n     #[inline]\n-    #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_ref<T: 'static>(self) -> Option<&'a T> {\n         if self.is::<T>() {\n             unsafe {\n@@ -159,7 +158,6 @@ pub trait AnyMutRefExt<'a> {\n #[stable]\n impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n     #[inline]\n-    #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_mut<T: 'static>(self) -> Option<&'a mut T> {\n         if self.is::<T>() {\n             unsafe {"}, {"sha": "d84a7875df1aaa48b0f5daddcd24b1d73e14602c", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -58,20 +58,25 @@ pub struct AtomicPtr<T> {\n #[stable]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations\n+    #[stable]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n     /// on the same value\n+    #[stable]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n     /// in another thread\n+    #[stable]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n     /// `Release` ordering\n+    #[stable]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n+    #[stable]\n     SeqCst\n }\n \n@@ -91,10 +96,10 @@ pub const INIT_ATOMIC_UINT: AtomicUint =\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n \n-#[stable]\n impl AtomicBool {\n     /// Create a new `AtomicBool`\n     #[inline]\n+    #[stable]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val), nocopy: marker::NoCopy }\n@@ -106,6 +111,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n@@ -116,6 +122,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -124,6 +131,7 @@ impl AtomicBool {\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -174,6 +182,7 @@ impl AtomicBool {\n     /// }\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n@@ -205,6 +214,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -236,6 +246,7 @@ impl AtomicBool {\n     /// assert_eq!(true, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -266,6 +277,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -296,17 +308,18 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n-#[stable]\n impl AtomicInt {\n     /// Create a new `AtomicInt`\n     #[inline]\n+    #[stable]\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v), nocopy: marker::NoCopy}\n     }\n@@ -317,6 +330,7 @@ impl AtomicInt {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n@@ -327,12 +341,14 @@ impl AtomicInt {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: int, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -343,6 +359,7 @@ impl AtomicInt {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -359,6 +376,7 @@ impl AtomicInt {\n     /// assert_eq!(10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -375,6 +393,7 @@ impl AtomicInt {\n     /// assert_eq!(-10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -390,6 +409,7 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n     /// assert_eq!(0b100001, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -405,6 +425,7 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n     /// assert_eq!(0b111111, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -420,15 +441,16 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n     /// assert_eq!(0b011110, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n-#[stable]\n impl AtomicUint {\n     /// Create a new `AtomicUint`\n     #[inline]\n+    #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v), nocopy: marker::NoCopy }\n     }\n@@ -439,6 +461,7 @@ impl AtomicUint {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n@@ -449,12 +472,14 @@ impl AtomicUint {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, val: uint, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -465,6 +490,7 @@ impl AtomicUint {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -481,6 +507,7 @@ impl AtomicUint {\n     /// assert_eq!(10, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -497,6 +524,7 @@ impl AtomicUint {\n     /// assert_eq!(0, foo.load(SeqCst));\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -512,6 +540,7 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n     /// assert_eq!(0b100001, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -527,6 +556,7 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n     /// assert_eq!(0b111111, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -542,15 +572,16 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n     /// assert_eq!(0b011110, foo.load(SeqCst));\n     #[inline]\n+    #[stable]\n     pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n-#[stable]\n impl<T> AtomicPtr<T> {\n     /// Create a new `AtomicPtr`\n     #[inline]\n+    #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as uint), nocopy: marker::NoCopy }\n     }\n@@ -561,6 +592,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(self.p.get() as *const *mut T, order) as *mut T\n@@ -573,12 +605,14 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n+    #[stable]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n+    #[stable]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n     }\n@@ -589,6 +623,7 @@ impl<T> AtomicPtr<T> {\n     /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n+    #[stable]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_compare_and_swap(self.p.get(), old as uint,\n@@ -609,6 +644,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -620,6 +656,7 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -632,6 +669,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n+#[stable]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -644,6 +682,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n+#[stable]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -655,6 +694,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -666,6 +706,7 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -677,6 +718,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[stable]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -689,6 +731,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n+#[stable]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -701,6 +744,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n+#[stable]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),"}, {"sha": "0b7389b20190caadb2769548e1e660cd6443b1db", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -157,6 +157,7 @@\n \n use clone::Clone;\n use cmp::PartialEq;\n+use default::Default;\n use kinds::{marker, Copy};\n use ops::{Deref, DerefMut, Drop};\n use option::{None, Option, Some};\n@@ -168,9 +169,9 @@ pub struct Cell<T> {\n     noshare: marker::NoSync,\n }\n \n-#[stable]\n impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n+    #[stable]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -180,12 +181,14 @@ impl<T:Copy> Cell<T> {\n \n     /// Returns a copy of the contained value.\n     #[inline]\n+    #[stable]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n     #[inline]\n+    #[stable]\n     pub fn set(&self, value: T) {\n         unsafe {\n             *self.value.get() = value;\n@@ -211,6 +214,13 @@ impl<T:Copy> Clone for Cell<T> {\n     }\n }\n \n+#[unstable]\n+impl<T:Default + Copy> Default for Cell<T> {\n+    fn default() -> Cell<T> {\n+        Cell::new(Default::default())\n+    }\n+}\n+\n #[unstable = \"waiting for `PartialEq` trait to become stable\"]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n@@ -337,6 +347,13 @@ impl<T: Clone> Clone for RefCell<T> {\n     }\n }\n \n+#[unstable]\n+impl<T:Default> Default for RefCell<T> {\n+    fn default() -> RefCell<T> {\n+        RefCell::new(Default::default())\n+    }\n+}\n+\n #[unstable = \"waiting for `PartialEq` to become stable\"]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {"}, {"sha": "e7b0f626bf8725d26118e84c2a0d6695911e222f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -16,8 +16,8 @@\n \n use intrinsics;\n use mem;\n-use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::Float;\n+use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::from_str_radix;\n use option::Option;\n \n pub const RADIX: uint = 2u;\n@@ -424,3 +424,10 @@ impl Float for f32 {\n         self * (value / 180.0f32)\n     }\n }\n+\n+#[inline]\n+#[allow(missing_docs)]\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f32> {\n+    from_str_radix(src, 16)\n+}"}, {"sha": "e82be19011073950dbde530693578feb588c2b6d", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -16,8 +16,8 @@\n \n use intrinsics;\n use mem;\n-use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::Float;\n+use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::from_str_radix;\n use option::Option;\n \n // FIXME(#5527): These constants should be deprecated once associated\n@@ -430,3 +430,10 @@ impl Float for f64 {\n         self * (value / 180.0)\n     }\n }\n+\n+#[inline]\n+#[allow(missing_docs)]\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f64> {\n+    from_str_radix(src, 16)\n+}"}, {"sha": "f5505ff8e762519a448ded962091fcf0ebca08d6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 288, "deletions": 1, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -14,18 +14,21 @@\n \n #![allow(missing_docs)]\n \n-use intrinsics;\n use {int, i8, i16, i32, i64};\n use {uint, u8, u16, u32, u64};\n use {f32, f64};\n+use char::Char;\n use clone::Clone;\n use cmp::{PartialEq, Eq};\n use cmp::{PartialOrd, Ord};\n+use intrinsics;\n+use iter::Iterator;\n use kinds::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n+use str::{FromStr, from_str, StrPrelude};\n \n /// Simultaneous division and remainder\n #[inline]\n@@ -1372,6 +1375,290 @@ pub trait Float\n     fn to_radians(self) -> Self;\n }\n \n+/// A generic trait for converting a string with a radix (base) to a value\n+#[experimental = \"might need to return Result\"]\n+pub trait FromStrRadix {\n+    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+}\n+\n+/// A utility function that just calls FromStrRadix::from_str_radix.\n+#[experimental = \"might need to return Result\"]\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n+    FromStrRadix::from_str_radix(str, radix)\n+}\n+\n+macro_rules! from_str_radix_float_impl {\n+    ($T:ty) => {\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStr for $T {\n+            /// Convert a string in base 10 to a float.\n+            /// Accepts an optional decimal exponent.\n+            ///\n+            /// This function accepts strings such as\n+            ///\n+            /// * '3.14'\n+            /// * '+3.14', equivalent to '3.14'\n+            /// * '-3.14'\n+            /// * '2.5E10', or equivalently, '2.5e10'\n+            /// * '2.5E-10'\n+            /// * '.' (understood as 0)\n+            /// * '5.'\n+            /// * '.5', or, equivalently,  '0.5'\n+            /// * '+inf', 'inf', '-inf', 'NaN'\n+            ///\n+            /// Leading and trailing whitespace represent an error.\n+            ///\n+            /// # Arguments\n+            ///\n+            /// * src - A string\n+            ///\n+            /// # Return value\n+            ///\n+            /// `None` if the string did not represent a valid number.  Otherwise,\n+            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+            #[inline]\n+            fn from_str(src: &str) -> Option<$T> {\n+                from_str_radix(src, 10)\n+            }\n+        }\n+\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStrRadix for $T {\n+            /// Convert a string in a given base to a float.\n+            ///\n+            /// Due to possible conflicts, this function does **not** accept\n+            /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+            /// does it recognize exponents of any kind.\n+            ///\n+            /// Leading and trailing whitespace represent an error.\n+            ///\n+            /// # Arguments\n+            ///\n+            /// * src - A string\n+            /// * radix - The base to use. Must lie in the range [2 .. 36]\n+            ///\n+            /// # Return value\n+            ///\n+            /// `None` if the string did not represent a valid number. Otherwise,\n+            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+               assert!(radix >= 2 && radix <= 36,\n+                       \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n+                       radix);\n+\n+                // Special values\n+                match src {\n+                    \"inf\"   => return Some(Float::infinity()),\n+                    \"-inf\"  => return Some(Float::neg_infinity()),\n+                    \"NaN\"   => return Some(Float::nan()),\n+                    _       => {},\n+                }\n+\n+                let (is_positive, src) =  match src.slice_shift_char() {\n+                    (None, _)        => return None,\n+                    (Some('-'), \"\")  => return None,\n+                    (Some('-'), src) => (false, src),\n+                    (Some(_), _)     => (true,  src),\n+                };\n+\n+                // The significand to accumulate\n+                let mut sig = if is_positive { 0.0 } else { -0.0 };\n+                // Necessary to detect overflow\n+                let mut prev_sig = sig;\n+                let mut cs = src.chars().enumerate();\n+                // Exponent prefix and exponent index offset\n+                let mut exp_info = None::<(char, uint)>;\n+\n+                // Parse the integer part of the significand\n+                for (i, c) in cs {\n+                    match c.to_digit(radix) {\n+                        Some(digit) => {\n+                            // shift significand one digit left\n+                            sig = sig * (radix as $T);\n+\n+                            // add/subtract current digit depending on sign\n+                            if is_positive {\n+                                sig = sig + ((digit as int) as $T);\n+                            } else {\n+                                sig = sig - ((digit as int) as $T);\n+                            }\n+\n+                            // Detect overflow by comparing to last value, except\n+                            // if we've not seen any non-zero digits.\n+                            if prev_sig != 0.0 {\n+                                if is_positive && sig <= prev_sig\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && sig >= prev_sig\n+                                    { return Some(Float::neg_infinity()); }\n+\n+                                // Detect overflow by reversing the shift-and-add process\n+                                if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n+                                    { return Some(Float::neg_infinity()); }\n+                            }\n+                            prev_sig = sig;\n+                        },\n+                        None => match c {\n+                            'e' | 'E' | 'p' | 'P' => {\n+                                exp_info = Some((c, i + 1));\n+                                break;  // start of exponent\n+                            },\n+                            '.' => {\n+                                break;  // start of fractional part\n+                            },\n+                            _ => {\n+                                return None;\n+                            },\n+                        },\n+                    }\n+                }\n+\n+                // If we are not yet at the exponent parse the fractional\n+                // part of the significand\n+                if exp_info.is_none() {\n+                    let mut power = 1.0;\n+                    for (i, c) in cs {\n+                        match c.to_digit(radix) {\n+                            Some(digit) => {\n+                                // Decrease power one order of magnitude\n+                                power = power / (radix as $T);\n+                                // add/subtract current digit depending on sign\n+                                sig = if is_positive {\n+                                    sig + (digit as $T) * power\n+                                } else {\n+                                    sig - (digit as $T) * power\n+                                };\n+                                // Detect overflow by comparing to last value\n+                                if is_positive && sig < prev_sig\n+                                    { return Some(Float::infinity()); }\n+                                if !is_positive && sig > prev_sig\n+                                    { return Some(Float::neg_infinity()); }\n+                                prev_sig = sig;\n+                            },\n+                            None => match c {\n+                                'e' | 'E' | 'p' | 'P' => {\n+                                    exp_info = Some((c, i + 1));\n+                                    break; // start of exponent\n+                                },\n+                                _ => {\n+                                    return None; // invalid number\n+                                },\n+                            },\n+                        }\n+                    }\n+                }\n+\n+                // Parse and calculate the exponent\n+                let exp = match exp_info {\n+                    Some((c, offset)) => {\n+                        let base = match c {\n+                            'E' | 'e' if radix == 10 => 10u as $T,\n+                            'P' | 'p' if radix == 16 => 2u as $T,\n+                            _ => return None,\n+                        };\n+\n+                        // Parse the exponent as decimal integer\n+                        let src = src[offset..];\n+                        let (is_positive, exp) = match src.slice_shift_char() {\n+                            (Some('-'), src) => (false, from_str::<uint>(src)),\n+                            (Some('+'), src) => (true,  from_str::<uint>(src)),\n+                            (Some(_), _)     => (true,  from_str::<uint>(src)),\n+                            (None, _)        => return None,\n+                        };\n+\n+                        match (is_positive, exp) {\n+                            (true,  Some(exp)) => base.powi(exp as i32),\n+                            (false, Some(exp)) => 1.0 / base.powi(exp as i32),\n+                            (_, None)          => return None,\n+                        }\n+                    },\n+                    None => 1.0, // no exponent\n+                };\n+\n+                Some(sig * exp)\n+            }\n+        }\n+    }\n+}\n+from_str_radix_float_impl!(f32)\n+from_str_radix_float_impl!(f64)\n+\n+macro_rules! from_str_radix_int_impl {\n+    ($T:ty) => {\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStr for $T {\n+            #[inline]\n+            fn from_str(src: &str) -> Option<$T> {\n+                from_str_radix(src, 10)\n+            }\n+        }\n+\n+        #[experimental = \"might need to return Result\"]\n+        impl FromStrRadix for $T {\n+            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+                assert!(radix >= 2 && radix <= 36,\n+                       \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+                       radix);\n+\n+                let is_signed_ty = (0 as $T) > Int::min_value();\n+\n+                match src.slice_shift_char() {\n+                    (Some('-'), src) if is_signed_ty => {\n+                        // The number is negative\n+                        let mut result = 0;\n+                        for c in src.chars() {\n+                            let x = match c.to_digit(radix) {\n+                                Some(x) => x,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_mul(radix as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_sub(x as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                        }\n+                        Some(result)\n+                    },\n+                    (Some(_), _) => {\n+                        // The number is signed\n+                        let mut result = 0;\n+                        for c in src.chars() {\n+                            let x = match c.to_digit(radix) {\n+                                Some(x) => x,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_mul(radix as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                            result = match result.checked_add(x as $T) {\n+                                Some(result) => result,\n+                                None => return None,\n+                            };\n+                        }\n+                        Some(result)\n+                    },\n+                    (None, _) => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+from_str_radix_int_impl!(int)\n+from_str_radix_int_impl!(i8)\n+from_str_radix_int_impl!(i16)\n+from_str_radix_int_impl!(i32)\n+from_str_radix_int_impl!(i64)\n+from_str_radix_int_impl!(uint)\n+from_str_radix_int_impl!(u8)\n+from_str_radix_int_impl!(u16)\n+from_str_radix_int_impl!(u32)\n+from_str_radix_int_impl!(u64)\n+\n // DEPRECATED\n \n macro_rules! trait_impl {"}, {"sha": "d41dbb11adb198cc0fe905bc56905cfe07e097f5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -716,7 +716,6 @@ impl<T: Default> Option<T> {\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n@@ -728,6 +727,7 @@ impl<T> AsSlice<T> for Option<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for Option<T> {\n     #[inline]\n     fn default() -> Option<T> { None }\n@@ -772,9 +772,10 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n impl<A> ExactSize<A> for Item<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable]\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a"}, {"sha": "101eb7ac74cdbdf4208742bacd194c87c95ea1c6", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -41,6 +41,7 @@ pub use ops::{Fn, FnMut, FnOnce};\n // Reexported functions\n pub use iter::{range, repeat};\n pub use mem::drop;\n+pub use str::from_str;\n \n // Reexported types and traits\n "}, {"sha": "5a6d0917af2c41b9970a3525aa4d1a287e636884", "filename": "src/libcore/result.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -878,9 +878,10 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n impl<A> ExactSize<A> for Item<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n-// Free functions\n+// FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable]\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -933,6 +934,10 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     }\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// FromIterator\n+/////////////////////////////////////////////////////////////////////////////\n+\n /// Perform a fold operation over the result values from an iterator.\n ///\n /// If an `Err` is encountered, it is immediately returned."}, {"sha": "ab4e50c58d9a45a87ad462a9c287178052c02a49", "filename": "src/libcore/str.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -31,6 +31,42 @@ use raw::Repr;\n use slice::{mod, SlicePrelude};\n use uint;\n \n+/// A trait to abstract the idea of creating a new instance of a type from a\n+/// string.\n+#[experimental = \"might need to return Result\"]\n+pub trait FromStr {\n+    /// Parses a string `s` to return an optional value of this type. If the\n+    /// string is ill-formatted, the None is returned.\n+    fn from_str(s: &str) -> Option<Self>;\n+}\n+\n+/// A utility function that just calls FromStr::from_str\n+pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n+    FromStr::from_str(s)\n+}\n+\n+impl FromStr for bool {\n+    /// Parse a `bool` from a string.\n+    ///\n+    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    /// ```\n+    #[inline]\n+    fn from_str(s: &str) -> Option<bool> {\n+        match s {\n+            \"true\"  => Some(true),\n+            \"false\" => Some(false),\n+            _       => None,\n+        }\n+    }\n+}\n+\n /*\n Section: Creating a string\n */"}, {"sha": "6444cf7ee0ebfea3243d51c23a4c6b32ca69b052", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::cell::*;\n+use core::default::Default;\n use std::mem::drop;\n \n #[test]\n@@ -146,3 +147,15 @@ fn as_unsafe_cell() {\n     unsafe { *r2.as_unsafe_cell().get() = 1u; }\n     assert_eq!(1u, *r2.borrow());\n }\n+\n+#[test]\n+fn cell_default() {\n+    let cell: Cell<u32> = Default::default();\n+    assert_eq!(0, cell.get());\n+}\n+\n+#[test]\n+fn refcell_default() {\n+    let cell: RefCell<u64> = Default::default();\n+    assert_eq!(0, *cell.borrow());\n+}"}, {"sha": "e25f10bd0dad531b0df7590bca75ff5ed9788776", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -15,7 +15,8 @@ macro_rules! int_module (($T:ty, $T_i:ident) => (\n mod tests {\n     use core::$T_i::*;\n     use core::int;\n-    use core::num::{Int, SignedInt};\n+    use core::num::{FromStrRadix, Int, SignedInt};\n+    use core::str::from_str;\n     use num;\n \n     #[test]\n@@ -156,6 +157,49 @@ mod tests {\n         assert!(5i.checked_div(0) == None);\n         assert!(int::MIN.checked_div(-1) == None);\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n+        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n+        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n+        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n+\n+        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n+        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n+        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n+        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n+\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n+    }\n }\n \n ))"}, {"sha": "0cd1ded21d6c6cdd269a12e5b3c6209ff0bae9a4", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -45,3 +45,73 @@ pub fn test_num<T>(ten: T, two: T) where\n     assert_eq!(ten.div(&two),  ten / two);\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use core::option::{Option, Some, None};\n+    use core::num::Float;\n+    use core::num::from_str_radix;\n+\n+    #[test]\n+    fn from_str_issue7588() {\n+        let u : Option<u8> = from_str_radix(\"1000\", 10);\n+        assert_eq!(u, None);\n+        let s : Option<i16> = from_str_radix(\"80000\", 10);\n+        assert_eq!(s, None);\n+        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10);\n+        assert_eq!(f, Some(Float::infinity()))\n+        let fe : Option<f32> = from_str_radix(\"1e40\", 10);\n+        assert_eq!(fe, Some(Float::infinity()))\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix_float() {\n+        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10);\n+        assert_eq!(x1, Some(-123.456));\n+        let x2 : Option<f32> = from_str_radix(\"123.456\", 10);\n+        assert_eq!(x2, Some(123.456));\n+        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10);\n+        assert_eq!(x3, Some(-0.0));\n+        let x4 : Option<f32> = from_str_radix(\"0.0\", 10);\n+        assert_eq!(x4, Some(0.0));\n+        let x4 : Option<f32> = from_str_radix(\"1.0\", 10);\n+        assert_eq!(x4, Some(1.0));\n+        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10);\n+        assert_eq!(x5, Some(-1.0));\n+    }\n+\n+    #[test]\n+    fn test_int_from_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n+        assert_eq!(from_str::<i8>(\"128\"), None);\n+\n+        i8_val += 1 as i8;\n+        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n+        assert_eq!(from_str::<i8>(\"-129\"), None);\n+\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n+        assert_eq!(from_str::<i16>(\"32768\"), None);\n+\n+        i16_val += 1 as i16;\n+        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n+        assert_eq!(from_str::<i16>(\"-32769\"), None);\n+\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n+        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n+\n+        i32_val += 1 as i32;\n+        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n+        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n+\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n+        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n+\n+        i64_val += 1 as i64;\n+        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n+        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n+    }\n+}"}, {"sha": "5f44fd807ccae726d3ecf852129b9f777565dbc6", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[test]\n+fn test_bool_from_str() {\n+    assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+}\n+\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in range(0, s.len()) {"}, {"sha": "c7540852970d8ca9a2ea42636fa1e2a324ddb9df", "filename": "src/libregex/re.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -10,7 +10,6 @@\n \n use std::collections::HashMap;\n use std::fmt;\n-use std::from_str::from_str;\n use std::str::{MaybeOwned, Owned, Slice};\n \n use compile::Program;"}, {"sha": "9768b3ce1aba6b9db50a43523c25d6291cfa69cc", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -268,8 +268,21 @@ macro_rules! cgoptions(\n \n     pub type CodegenSetter = fn(&mut CodegenOptions, v: Option<&str>) -> bool;\n     pub const CG_OPTIONS: &'static [(&'static str, CodegenSetter,\n-                                      &'static str)] =\n-        &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n+                                     Option<&'static str>, &'static str)] =\n+        &[ $( (stringify!($opt), cgsetters::$opt, cg_type_descs::$parse, $desc) ),* ];\n+\n+    #[allow(non_upper_case_globals)]\n+    mod cg_type_descs {\n+        pub const parse_bool: Option<&'static str> = None;\n+        pub const parse_opt_bool: Option<&'static str> = None;\n+        pub const parse_string: Option<&'static str> = Some(\"a string\");\n+        pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n+        pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n+        pub const parse_uint: Option<&'static str> = Some(\"a number\");\n+        pub const parse_passes: Option<&'static str> =\n+            Some(\"a space-separated list of passes, or `all`\");\n+    }\n \n     mod cgsetters {\n         use super::{CodegenOptions, Passes, SomePasses, AllPasses};\n@@ -334,8 +347,7 @@ macro_rules! cgoptions(\n         }\n \n         fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n-            use std::from_str::FromStr;\n-            match v.and_then(FromStr::from_str) {\n+            match v.and_then(from_str) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }\n@@ -421,19 +433,25 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n         let value = iter.next();\n         let option_to_lookup = key.replace(\"-\", \"_\");\n         let mut found = false;\n-        for &(candidate, setter, _) in CG_OPTIONS.iter() {\n+        for &(candidate, setter, opt_type_desc, _) in CG_OPTIONS.iter() {\n             if option_to_lookup.as_slice() != candidate { continue }\n             if !setter(&mut cg, value) {\n-                match value {\n-                    Some(..) => {\n+                match (value, opt_type_desc) {\n+                    (Some(..), None) => {\n                         early_error(format!(\"codegen option `{}` takes no \\\n                                              value\", key).as_slice())\n                     }\n-                    None => {\n+                    (None, Some(type_desc)) => {\n                         early_error(format!(\"codegen option `{0}` requires \\\n-                                             a value (-C {0}=<value>)\",\n-                                            key).as_slice())\n+                                             {1} (-C {0}=<value>)\",\n+                                            key, type_desc).as_slice())\n+                    }\n+                    (Some(value), Some(type_desc)) => {\n+                        early_error(format!(\"incorrect value `{}` for codegen \\\n+                                             option `{}` - {} was expected\",\n+                                             value, key, type_desc).as_slice())\n                     }\n+                    (None, None) => unreachable!()\n                 }\n             }\n             found = true;"}, {"sha": "546469c3c0e5d4735377a795ec8b92470383c798", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -299,14 +299,10 @@ fn describe_debug_flags() {\n \n fn describe_codegen_flags() {\n     println!(\"\\nAvailable codegen options:\\n\");\n-    let mut cg = config::basic_codegen_options();\n-    for &(name, parser, desc) in config::CG_OPTIONS.iter() {\n-        // we invoke the parser function on `None` to see if this option needs\n-        // an argument or not.\n-        let (width, extra) = if parser(&mut cg, None) {\n-            (25, \"\")\n-        } else {\n-            (21, \"=val\")\n+    for &(name, _, opt_type_desc, desc) in config::CG_OPTIONS.iter() {\n+        let (width, extra) = match opt_type_desc {\n+            Some(..) => (21, \"=val\"),\n+            None => (25, \"\")\n         };\n         println!(\"    -C {:>width$s}{} -- {}\", name.replace(\"_\", \"-\"),\n                  extra, desc, width=width);"}, {"sha": "7b6de088319f4fcc3bab7fcc7241e66b4ea30276", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -31,8 +31,8 @@ use syntax::print::{pp, pprust};\n use graphviz as dot;\n \n use std::io::{mod, MemReader};\n-use std::from_str::FromStr;\n use std::option;\n+use std::str::FromStr;\n use arena::TypedArena;\n \n #[deriving(PartialEq, Show)]"}, {"sha": "9530c86a94c111416a8ddd155f25892370fc0681", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -455,7 +455,12 @@ pub fn llvm_type_name(cx: &CrateContext,\n \n     let base = ty::item_path_str(cx.tcx(), did);\n     let strings: Vec<String> = tps.iter().map(|t| t.repr(cx.tcx())).collect();\n-    let tstr = format!(\"{}<{}>\", base, strings);\n+    let tstr = if strings.is_empty() {\n+        base\n+    } else {\n+        format!(\"{}<{}>\", base, strings)\n+    };\n+\n     if did.krate == 0 {\n         format!(\"{}.{}\", name, tstr)\n     } else {"}, {"sha": "b28da098a5783385d152cca1d46722e4b9b557b9", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -584,3 +584,9 @@ pre.rust { position: relative; }\n         height: 1.5em;\n     }\n }\n+\n+@media print {\n+    nav.sub, .content .out-of-band, .collapse-toggle {\n+        display: none;\n+    }\n+}"}, {"sha": "7ec59f0139d9823eb7e22c52ad1541819cff0f0d", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -19,7 +19,7 @@ use std::num::Zero;\n use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n use syntax::ast::Public;\n \n-use clean::{Crate, Item, ModuleItem, Module, StructItem, Struct, EnumItem, Enum};\n+use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem, Stability};\n \n@@ -146,13 +146,12 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n     // considered to have no children.\n     match item.inner {\n         // Require explicit `pub` to be visible\n-        StructItem(Struct { fields: ref subitems, .. }) |\n         ImplItem(Impl { items: ref subitems, trait_: None, .. }) => {\n             let subcounts = subitems.iter().filter(|i| visible(*i))\n                                            .map(summarize_item)\n                                            .map(|s| s.val0())\n                                            .fold(Counts::zero(), |acc, x| acc + x);\n-            (item_counts + subcounts, None)\n+            (subcounts, None)\n         }\n         // `pub` automatically\n         EnumItem(Enum { variants: ref subitems, .. }) => {"}, {"sha": "a074d6f43b97baf8444b3e346329b79cb7bf0e0d", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -200,7 +200,7 @@ use std::{char, f64, fmt, io, num, str};\n use std::io::MemWriter;\n use std::mem::{swap, transmute};\n use std::num::{Float, FPNaN, FPInfinite, Int};\n-use std::str::ScalarValue;\n+use std::str::{FromStr, ScalarValue};\n use std::string;\n use std::vec::Vec;\n use std::ops;\n@@ -1988,7 +1988,7 @@ macro_rules! read_primitive {\n                 String(s) => {\n                     // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                     // is going to have a string here, as per JSON spec.\n-                    match std::from_str::from_str(s.as_slice()) {\n+                    match std::str::from_str(s.as_slice()) {\n                         Some(f) => Ok(f),\n                         None => Err(ExpectedError(\"Number\".to_string(), s)),\n                     }\n@@ -2027,7 +2027,7 @@ impl ::Decoder<DecoderError> for Decoder {\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                match std::from_str::from_str(s.as_slice()) {\n+                match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 }\n@@ -2315,6 +2315,10 @@ impl ToJson for bool {\n     fn to_json(&self) -> Json { Boolean(*self) }\n }\n \n+impl ToJson for str {\n+    fn to_json(&self) -> Json { String(self.into_string()) }\n+}\n+\n impl ToJson for string::String {\n     fn to_json(&self) -> Json { String((*self).clone()) }\n }\n@@ -2395,7 +2399,7 @@ impl fmt::Show for Json {\n     }\n }\n \n-impl std::from_str::FromStr for Json {\n+impl FromStr for Json {\n     fn from_str(s: &str) -> Option<Json> {\n         from_str(s).ok()\n     }\n@@ -2480,7 +2484,7 @@ mod tests {\n     #[test]\n     fn test_from_str_trait() {\n         let s = \"null\";\n-        assert!(::std::from_str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n+        assert!(::std::str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n     }\n \n     #[test]\n@@ -3714,7 +3718,8 @@ mod tests {\n         assert_eq!(f64::NAN.to_json(), Null);\n         assert_eq!(true.to_json(), Boolean(true));\n         assert_eq!(false.to_json(), Boolean(false));\n-        assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n+        assert_eq!(\"abc\".to_json(), String(\"abc\".into_string()));\n+        assert_eq!(\"abc\".into_string().to_json(), String(\"abc\".into_string()));\n         assert_eq!((1u, 2u).to_json(), list2);\n         assert_eq!((1u, 2u, 3u).to_json(), list3);\n         assert_eq!([1u, 2].to_json(), list2);"}, {"sha": "923349b1bf74089ba378064d222e9e8e56cf0b02", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -21,8 +21,7 @@ use mem;\n use option::{Option, Some, None};\n use slice::{SlicePrelude, AsSlice};\n use str::{Str, StrPrelude};\n-use string::{mod, String};\n-use to_string::IntoStr;\n+use string::{mod, String, IntoString};\n use vec::Vec;\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n@@ -326,7 +325,7 @@ impl AsciiStr for [Ascii] {\n     }\n }\n \n-impl IntoStr for Vec<Ascii> {\n+impl IntoString for Vec<Ascii> {\n     #[inline]\n     fn into_string(self) -> String {\n         unsafe {"}, {"sha": "21b1e0560a5dba49ff6d0b715196d0f4d91ba957", "filename": "src/libstd/from_str.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cb51567e1911452f3da4b924a91e5360f5efe67c/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb51567e1911452f3da4b924a91e5360f5efe67c/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=cb51567e1911452f3da4b924a91e5360f5efe67c", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `FromStr` trait for types that can be created from strings\n-\n-#![experimental]\n-\n-use option::{Option, Some, None};\n-use string::String;\n-\n-/// A trait to abstract the idea of creating a new instance of a type from a\n-/// string.\n-#[experimental = \"might need to return Result\"]\n-pub trait FromStr {\n-    /// Parses a string `s` to return an optional value of this type. If the\n-    /// string is ill-formatted, the None is returned.\n-    fn from_str(s: &str) -> Option<Self>;\n-}\n-\n-/// A utility function that just calls FromStr::from_str\n-pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n-    FromStr::from_str(s)\n-}\n-\n-impl FromStr for bool {\n-    /// Parse a `bool` from a string.\n-    ///\n-    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    /// ```\n-    #[inline]\n-    fn from_str(s: &str) -> Option<bool> {\n-        match s {\n-            \"true\"  => Some(true),\n-            \"false\" => Some(false),\n-            _       => None,\n-        }\n-    }\n-}\n-\n-impl FromStr for String {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<String> {\n-        Some(String::from_str(s))\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-\n-    #[test]\n-    fn test_bool_from_str() {\n-        assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-        assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-        assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    }\n-}"}, {"sha": "7ba5e173182e165c8061357365200849c66183df", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -16,13 +16,12 @@\n #![allow(missing_docs)]\n \n use fmt;\n-use from_str::FromStr;\n use io::{mod, IoResult, IoError};\n use io::net;\n use iter::Iterator;\n use option::{Option, None, Some};\n use result::{Ok, Err};\n-use str::StrPrelude;\n+use str::{FromStr, StrPrelude};\n use slice::{CloneSlicePrelude, SlicePrelude};\n use vec::Vec;\n \n@@ -540,7 +539,7 @@ impl<'a> ToSocketAddr for &'a str {\n mod test {\n     use prelude::*;\n     use super::*;\n-    use from_str::FromStr;\n+    use str::FromStr;\n \n     #[test]\n     fn test_from_str_ipv4() {"}, {"sha": "24fc2998ee696f49766abf41327ed3bf9a9d6b7d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -661,23 +661,22 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n+            drop(TcpStream::connect(addr));\n+            tx.send(());\n         });\n \n         let mut stream = acceptor.accept();\n+        rx.recv();\n         let buf = [0];\n-        loop {\n-            match stream.write(buf) {\n-                Ok(..) => {}\n-                Err(e) => {\n-                    assert!(e.kind == ConnectionReset ||\n-                            e.kind == BrokenPipe ||\n-                            e.kind == ConnectionAborted,\n-                            \"unknown error: {}\", e);\n-                    break;\n-                }\n+        match stream.write(buf) {\n+            Ok(..) => {}\n+            Err(e) => {\n+                assert!(e.kind == ConnectionReset ||\n+                        e.kind == BrokenPipe ||\n+                        e.kind == ConnectionAborted,\n+                        \"unknown error: {}\", e);\n             }\n         }\n     }\n@@ -687,23 +686,22 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n+            drop(TcpStream::connect(addr));\n+            tx.send(());\n         });\n \n         let mut stream = acceptor.accept();\n+        rx.recv();\n         let buf = [0];\n-        loop {\n-            match stream.write(buf) {\n-                Ok(..) => {}\n-                Err(e) => {\n-                    assert!(e.kind == ConnectionReset ||\n-                            e.kind == BrokenPipe ||\n-                            e.kind == ConnectionAborted,\n-                            \"unknown error: {}\", e);\n-                    break;\n-                }\n+        match stream.write(buf) {\n+            Ok(..) => {}\n+            Err(e) => {\n+                assert!(e.kind == ConnectionReset ||\n+                        e.kind == BrokenPipe ||\n+                        e.kind == ConnectionAborted,\n+                        \"unknown error: {}\", e);\n             }\n         }\n     }"}, {"sha": "5b5bb6181516546dabbd0cd05dfeb1d6a81627e6", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -1190,7 +1190,7 @@ mod tests {\n             Path::new(\"/dev/null\")\n         };\n \n-        let mut fdes = match fs::open(&path, Truncate, Write) {\n+        let fdes = match fs::open(&path, Truncate, Write) {\n             Ok(f) => f,\n             Err(_) => panic!(\"failed to open file descriptor\"),\n         };"}, {"sha": "612613134d448e95d3517ea40f21be39351a1e2c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -54,7 +54,7 @@\n //!\n //! For converting to strings use the [`format!`](fmt/index.html)\n //! macro, and for converting from strings use the\n-//! [`FromStr`](from_str/index.html) trait.\n+//! [`FromStr`](str/trait.FromStr.html) trait.\n //!\n //! ## Platform abstractions\n //!\n@@ -219,9 +219,7 @@ pub mod time;\n /* Common traits */\n \n pub mod error;\n-pub mod from_str;\n pub mod num;\n-pub mod to_string;\n \n /* Common data structures */\n "}, {"sha": "207fa6499309c43ceac08ae53569aa1e7df7e9e4", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -17,12 +17,10 @@\n \n use prelude::*;\n \n-use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n-use num;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -339,68 +337,6 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     r\n }\n \n-#[inline]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f32> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f32 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as\n-    ///\n-    /// * '3.14'\n-    /// * '+3.14', equivalent to '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * '+inf', 'inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f32> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl num::FromStrRadix for f32 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Due to possible conflicts, this function does **not** accept\n-    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-    /// does it recognize exponents of any kind.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f32::*;"}, {"sha": "543d50596e8ce00402a5d287ecf2e062ad273c42", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -16,12 +16,10 @@\n \n use prelude::*;\n \n-use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n-use num;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -347,63 +345,6 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     r\n }\n \n-#[inline]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f64> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f64 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as:\n-    ///\n-    /// * '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `none` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f64> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl num::FromStrRadix for f64 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f64> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f64::*;"}, {"sha": "6455c10736a3fe8dc1beda48341339d60041d7aa", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i16\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i16::{BITS, BYTES, MIN, MAX};\n \n int_module!(i16)"}, {"sha": "39b179c8274eb01c07efc2c8e47cfaececfc636f", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i32\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i32::{BITS, BYTES, MIN, MAX};\n \n int_module!(i32)"}, {"sha": "a0c474c479ae409e6d1abf0d36bd9e2524e4e887", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i64\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i64::{BITS, BYTES, MIN, MAX};\n \n int_module!(i64)"}, {"sha": "e911ed1de9ac4e29a8eb2319bdb862375048461b", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i8\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i8::{BITS, BYTES, MIN, MAX};\n \n int_module!(i8)"}, {"sha": "36c021efe0a3978f29389520c2c2d29b3763b220", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"int\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::int::{BITS, BYTES, MIN, MAX};\n \n int_module!(int)"}, {"sha": "2f1162d28e558797a0c4be6239f39a808263e7c6", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -14,131 +14,4 @@\n \n macro_rules! int_module (($T:ty) => (\n \n-#[experimental = \"might need to return Result\"]\n-impl FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use num::FromStrRadix;\n-\n-    #[test]\n-    fn test_from_str() {\n-        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n-        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n-        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n-        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n-        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n-        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n-        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"\"), None);\n-        assert_eq!(from_str::<$T>(\" \"), None);\n-        assert_eq!(from_str::<$T>(\"x\"), None);\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n-    }\n-\n-    #[test]\n-    fn test_int_to_str_overflow() {\n-        let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_string(), \"127\".to_string());\n-\n-        i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n-\n-        let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n-\n-        i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n-\n-        let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n-\n-        i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n-\n-        i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_int_from_str_overflow() {\n-        let mut i8_val: i8 = 127_i8;\n-        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"128\"), None);\n-\n-        i8_val += 1 as i8;\n-        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"-129\"), None);\n-\n-        let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"32768\"), None);\n-\n-        i16_val += 1 as i16;\n-        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"-32769\"), None);\n-\n-        let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n-\n-        i32_val += 1 as i32;\n-        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n-\n-        i64_val += 1 as i64;\n-        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n-    }\n-}\n-\n ))"}, {"sha": "2ce6c0e6e71cd7647c6b1463d268d5e426757819", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -16,8 +16,6 @@\n #![experimental]\n #![allow(missing_docs)]\n \n-use option::Option;\n-\n #[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt::Show;\n #[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n@@ -31,6 +29,7 @@ pub use core::num::{checked_next_power_of_two};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n+pub use core::num::{FromStrRadix, from_str_radix};\n pub use core::num::{FPCategory, FPNaN, FPInfinite, FPZero, FPSubnormal};\n pub use core::num::{FPNormal, Float};\n \n@@ -115,18 +114,6 @@ pub trait FloatMath: Float {\n     fn atanh(self) -> Self;\n }\n \n-/// A generic trait for converting a string with a radix (base) to a value\n-#[experimental = \"might need to return Result\"]\n-pub trait FromStrRadix {\n-    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n-}\n-\n-/// A utility function that just calls FromStrRadix::from_str_radix.\n-#[experimental = \"might need to return Result\"]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n-    FromStrRadix::from_str_radix(str, radix)\n-}\n-\n // DEPRECATED\n \n #[deprecated = \"Use `FloatMath::abs_sub`\"]\n@@ -764,8 +751,9 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: One + Mul<T, T>>(base: T, exp: uint) -> T {\n-            range(0, exp).fold(one::<T>(), |acc, _| acc * base)\n+        fn naive_pow<T: Int>(base: T, exp: uint) -> T {\n+            let one: T = Int::one();\n+            range(0, exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow(\n             (($num:expr, $exp:expr) => $expected:expr) => {{"}, {"sha": "d1a89d72621a7a9f8ba27729a35d35260d7e271c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 21, "deletions": 232, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,12 +13,8 @@\n #![allow(missing_docs)]\n \n use char;\n-use char::Char;\n-use from_str::from_str;\n-use iter::Iterator;\n use num;\n use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n-use option::{None, Option, Some};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n use str::StrPrelude;\n use string::String;\n@@ -425,242 +421,35 @@ pub fn float_to_str_common<T: Float>(\n static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n-pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n-\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n-    let radix_t: T = num::cast(radix as int).unwrap();\n-\n-    // Special values\n-    match src {\n-        \"inf\"   => return Some(Float::infinity()),\n-        \"-inf\"  => return Some(Float::neg_infinity()),\n-        \"NaN\"   => return Some(Float::nan()),\n-        _       => {},\n-    }\n-\n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (None, _)        => return None,\n-        (Some('-'), \"\")  => return None,\n-        (Some('-'), src) => (false, src),\n-        (Some(_), _)     => (true,  src),\n-    };\n-\n-    // The significand to accumulate\n-    let mut sig = if is_positive { _0 } else { -_0 };\n-    // Necessary to detect overflow\n-    let mut prev_sig = sig;\n-    let mut cs = src.chars().enumerate();\n-    // Exponent prefix and exponent index offset\n-    let mut exp_info = None::<(char, uint)>;\n-\n-    // Parse the integer part of the significand\n-    for (i, c) in cs {\n-        match c.to_digit(radix) {\n-            Some(digit) => {\n-                // shift significand one digit left\n-                sig = sig * radix_t;\n-\n-                // add/subtract current digit depending on sign\n-                if is_positive {\n-                    sig = sig + num::cast(digit as int).unwrap();\n-                } else {\n-                    sig = sig - num::cast(digit as int).unwrap();\n-                }\n-\n-                // Detect overflow by comparing to last value, except\n-                // if we've not seen any non-zero digits.\n-                if prev_sig != _0 {\n-                    if is_positive && sig <= prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig >= prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-\n-                    // Detect overflow by reversing the shift-and-add process\n-                    let digit: T = num::cast(digit as int).unwrap();\n-                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n-                        { return Some(Float::neg_infinity()); }\n-                }\n-                prev_sig = sig;\n-            },\n-            None => match c {\n-                'e' | 'E' | 'p' | 'P' => {\n-                    exp_info = Some((c, i + 1));\n-                    break;  // start of exponent\n-                },\n-                '.' => {\n-                    break;  // start of fractional part\n-                },\n-                _ => {\n-                    return None;\n-                },\n-            },\n-        }\n-    }\n-\n-    // If we are not yet at the exponent parse the fractional\n-    // part of the significand\n-    if exp_info.is_none() {\n-        let mut power = _1;\n-        for (i, c) in cs {\n-            match c.to_digit(radix) {\n-                Some(digit) => {\n-                    let digit: T = num::cast(digit).unwrap();\n-                    // Decrease power one order of magnitude\n-                    power = power / radix_t;\n-                    // add/subtract current digit depending on sign\n-                    sig = if is_positive {\n-                        sig + digit * power\n-                    } else {\n-                        sig - digit * power\n-                    };\n-                    // Detect overflow by comparing to last value\n-                    if is_positive && sig < prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig > prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-                    prev_sig = sig;\n-                },\n-                None => match c {\n-                    'e' | 'E' | 'p' | 'P' => {\n-                        exp_info = Some((c, i + 1));\n-                        break; // start of exponent\n-                    },\n-                    _ => {\n-                        return None; // invalid number\n-                    },\n-                },\n-            }\n-        }\n-    }\n-\n-    // Parse and calculate the exponent\n-    let exp = match exp_info {\n-        Some((c, offset)) => {\n-            let base: T = match c {\n-                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n-                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n-                _ => return None,\n-            };\n-\n-            // Parse the exponent as decimal integer\n-            let src = src[offset..];\n-            let (is_positive, exp) = match src.slice_shift_char() {\n-                (Some('-'), src) => (false, from_str::<uint>(src)),\n-                (Some('+'), src) => (true,  from_str::<uint>(src)),\n-                (Some(_), _)     => (true,  from_str::<uint>(src)),\n-                (None, _)        => return None,\n-            };\n-\n-            match (is_positive, exp) {\n-                (true,  Some(exp)) => base.powi(exp as i32),\n-                (false, Some(exp)) => _1 / base.powi(exp as i32),\n-                (_, None)          => return None,\n-            }\n-        },\n-        None => _1, // no exponent\n-    };\n+#[cfg(test)]\n+mod tests {\n+    use string::ToString;\n \n-    Some(sig * exp)\n-}\n+    #[test]\n+    fn test_int_to_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert_eq!(i8_val.to_string(), \"127\".to_string());\n \n-pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n+        i8_val += 1 as i8;\n+        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n \n-    fn cast<T: Int>(x: uint) -> T {\n-        num::cast(x).unwrap()\n-    }\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n \n-    let _0: T = Int::zero();\n-    let _1: T = Int::one();\n-    let is_signed = _0 > Int::min_value();\n+        i16_val += 1 as i16;\n+        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n \n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (Some('-'), src) if is_signed => (false, src),\n-        (Some(_), _) => (true, src),\n-        (None, _) => return None,\n-    };\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n \n-    let mut xs = src.chars().map(|c| {\n-        c.to_digit(radix).map(cast)\n-    });\n-    let radix = cast(radix);\n-    let mut result = _0;\n-\n-    if is_positive {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_add(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    } else {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_sub(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    }\n+        i32_val += 1 as i32;\n+        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n \n-    Some(result)\n-}\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n \n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use num::Float;\n-\n-    #[test]\n-    fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n-        assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n-        assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n-        assert_eq!(f, Some(Float::infinity()))\n-        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n-        assert_eq!(fe, Some(Float::infinity()))\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix_float(\"-123.456\", 10);\n-        assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix_float(\"123.456\", 10);\n-        assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix_float(\"-0.0\", 10);\n-        assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"0.0\", 10);\n-        assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"1.0\", 10);\n-        assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix_float(\"-1.0\", 10);\n-        assert_eq!(x5, Some(-1.0));\n+        i64_val += 1 as i64;\n+        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n     }\n }\n "}, {"sha": "246224ddb2b4eff7c3b98987f10d8dc57485bca9", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u16\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u16)"}, {"sha": "143b45010c2548f3552e51acc91f4c398b3498b4", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u32\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u32)"}, {"sha": "92c5380f980ea0d991a37150c801ec05a9dd6f8e", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u64\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u64)"}, {"sha": "faa6d167065ce26a1de0bcf7e25b441293ba0906", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u8\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u8)"}, {"sha": "a425aab3aa10c5529380d530eab152cebc010fcb", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"uint\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n uint_module!(uint)"}, {"sha": "ef9e809ed2bcc3fbff2eee6c104ce5833ac0b2fb", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -15,22 +15,6 @@\n \n macro_rules! uint_module (($T:ty) => (\n \n-#[experimental = \"might need to return Result\"]\n-impl FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n // String conversion functions and impl num -> str\n \n /// Convert to a string as a byte slice in a given base."}, {"sha": "23e57a028de27efee45620e6b4a3ab6cda699a85", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -51,8 +51,7 @@ use result::{Err, Ok, Result};\n use slice::{AsSlice, SlicePrelude, PartialEqSlicePrelude};\n use slice::CloneSliceAllocPrelude;\n use str::{Str, StrPrelude, StrAllocating};\n-use string::String;\n-use to_string::ToString;\n+use string::{String, ToString};\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n "}, {"sha": "e2ff824a7c98fb5010d585f58b264711d572060b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -13,12 +13,11 @@\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use from_str::FromStr;\n use hash;\n use io::Writer;\n use iter::{DoubleEndedIterator, AdditiveIterator, Extend, Iterator, Map};\n use option::{Option, None, Some};\n-use str::Str;\n+use str::{FromStr, Str};\n use str;\n use slice::{CloneSliceAllocPrelude, Splits, AsSlice, VectorVector,\n             PartialEqSlicePrelude, SlicePrelude};"}, {"sha": "b8016e3e8f453b2fbcf41024e2b451fcfe54f74c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -16,14 +16,13 @@ use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use from_str::FromStr;\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extend, Iterator, Map};\n use mem;\n use option::{Option, Some, None};\n use slice::{AsSlice, SlicePrelude};\n-use str::{CharSplits, Str, StrAllocating, StrVector, StrPrelude};\n+use str::{CharSplits, FromStr, Str, StrAllocating, StrVector, StrPrelude};\n use string::String;\n use unicode::char::UnicodeChar;\n use vec::Vec;"}, {"sha": "a9e99940c4689d2e2944859d1ca37ebc8d722ddc", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -50,9 +50,9 @@\n #[doc(no_inline)] pub use ops::{Fn, FnMut, FnOnce};\n \n // Reexported functions\n-#[doc(no_inline)] pub use from_str::from_str;\n #[doc(no_inline)] pub use iter::{range, repeat};\n #[doc(no_inline)] pub use mem::drop;\n+#[doc(no_inline)] pub use str::from_str;\n \n // Reexported types and traits\n \n@@ -76,14 +76,13 @@\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n #[doc(no_inline)] pub use str::{Str, StrVector, StrPrelude};\n #[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrPrelude};\n-#[doc(no_inline)] pub use to_string::{ToString, IntoStr};\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n #[doc(no_inline)] pub use slice::{SlicePrelude, AsSlice, CloneSlicePrelude};\n #[doc(no_inline)] pub use slice::{VectorVector, PartialEqSlicePrelude, OrdSlicePrelude};\n #[doc(no_inline)] pub use slice::{CloneSliceAllocPrelude, OrdSliceAllocPrelude, SliceAllocPrelude};\n-#[doc(no_inline)] pub use string::String;\n+#[doc(no_inline)] pub use string::{IntoString, String, ToString};\n #[doc(no_inline)] pub use vec::Vec;\n \n // Reexported runtime types"}, {"sha": "8b457d1639dc43857199b21f9c90fa413e3a6a6a", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -12,13 +12,12 @@\n \n #![allow(non_camel_case_types)]\n \n-use from_str::from_str;\n use io::{IoResult, Writer};\n use iter::Iterator;\n use option::{Some, None};\n use os;\n use result::{Ok, Err};\n-use str::StrPrelude;\n+use str::{StrPrelude, from_str};\n use sync::atomic;\n use unicode::char::UnicodeChar;\n "}, {"sha": "92657d1b59bee8723bcdbb57fdc363d08912ec0d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use from_str::FromStr;\n-use from_str::from_str;\n use libc::uintptr_t;\n use option::{Some, None, Option};\n use os;\n-use str::Str;\n+use str::{FromStr, from_str, Str};\n use sync::atomic;\n \n /// Dynamically inquire about whether we're running under V."}, {"sha": "4ae5cd054f6208695d51cd004e17e1e37c67e992", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 167, "deletions": 63, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,91 +12,195 @@\n \n use core::prelude::*;\n \n-use task;\n use task::spawn;\n-use vec::Vec;\n-use comm::{channel, Sender};\n+use comm::{channel, Sender, Receiver};\n+use sync::{Arc, Mutex};\n \n-enum Msg<T> {\n-    Execute(proc(&T):Send),\n-    Quit\n+struct Sentinel<'a> {\n+    jobs: &'a Arc<Mutex<Receiver<proc(): Send>>>,\n+    active: bool\n }\n \n-/// A task pool used to execute functions in parallel.\n-pub struct TaskPool<T> {\n-    channels: Vec<Sender<Msg<T>>>,\n-    next_index: uint,\n+impl<'a> Sentinel<'a> {\n+    fn new(jobs: &Arc<Mutex<Receiver<proc(): Send>>>) -> Sentinel {\n+        Sentinel {\n+            jobs: jobs,\n+            active: true\n+        }\n+    }\n+\n+    // Cancel and destroy this sentinel.\n+    fn cancel(mut self) {\n+        self.active = false;\n+    }\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for TaskPool<T> {\n+impl<'a> Drop for Sentinel<'a> {\n     fn drop(&mut self) {\n-        for channel in self.channels.iter_mut() {\n-            channel.send(Quit);\n+        if self.active {\n+            spawn_in_pool(self.jobs.clone())\n         }\n     }\n }\n \n-impl<T> TaskPool<T> {\n-    /// Spawns a new task pool with `n_tasks` tasks. The provided\n-    /// `init_fn_factory` returns a function which, given the index of the\n-    /// task, should return local data to be kept around in that task.\n+/// A task pool used to execute functions in parallel.\n+///\n+/// Spawns `n` worker tasks and replenishes the pool if any worker tasks\n+/// panic.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// # use std::sync::TaskPool;\n+/// # use std::iter::AdditiveIterator;\n+///\n+/// let pool = TaskPool::new(4u);\n+///\n+/// let (tx, rx) = channel();\n+/// for _ in range(0, 8u) {\n+///     let tx = tx.clone();\n+///     pool.execute(proc() {\n+///         tx.send(1u);\n+///     });\n+/// }\n+///\n+/// assert_eq!(rx.iter().take(8u).sum(), 8u);\n+/// ```\n+pub struct TaskPool {\n+    // How the taskpool communicates with subtasks.\n+    //\n+    // This is the only such Sender, so when it is dropped all subtasks will\n+    // quit.\n+    jobs: Sender<proc(): Send>\n+}\n+\n+impl TaskPool {\n+    /// Spawns a new task pool with `tasks` tasks.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `n_tasks` is less than 1.\n-    pub fn new(n_tasks: uint,\n-               init_fn_factory: || -> proc(uint):Send -> T)\n-               -> TaskPool<T> {\n-        assert!(n_tasks >= 1);\n-\n-        let channels = Vec::from_fn(n_tasks, |i| {\n-            let (tx, rx) = channel::<Msg<T>>();\n-            let init_fn = init_fn_factory();\n-\n-            let task_body = proc() {\n-                let local_data = init_fn(i);\n-                loop {\n-                    match rx.recv() {\n-                        Execute(f) => f(&local_data),\n-                        Quit => break\n-                    }\n-                }\n-            };\n+    /// This function will panic if `tasks` is 0.\n+    pub fn new(tasks: uint) -> TaskPool {\n+        assert!(tasks >= 1);\n \n-            // Run on this scheduler.\n-            task::spawn(task_body);\n+        let (tx, rx) = channel::<proc(): Send>();\n+        let rx = Arc::new(Mutex::new(rx));\n \n-            tx\n-        });\n+        // Taskpool tasks.\n+        for _ in range(0, tasks) {\n+            spawn_in_pool(rx.clone());\n+        }\n \n-        return TaskPool {\n-            channels: channels,\n-            next_index: 0,\n-        };\n+        TaskPool { jobs: tx }\n     }\n \n-    /// Executes the function `f` on a task in the pool. The function\n-    /// receives a reference to the local data returned by the `init_fn`.\n-    pub fn execute(&mut self, f: proc(&T):Send) {\n-        self.channels[self.next_index].send(Execute(f));\n-        self.next_index += 1;\n-        if self.next_index == self.channels.len() { self.next_index = 0; }\n+    /// Executes the function `job` on a task in the pool.\n+    pub fn execute(&self, job: proc():Send) {\n+        self.jobs.send(job);\n     }\n }\n \n-#[test]\n-fn test_task_pool() {\n-    let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n-    let mut pool = TaskPool::new(4, f);\n-    for _ in range(0u, 8) {\n-        pool.execute(proc(i) println!(\"Hello from thread {}!\", *i));\n-    }\n+fn spawn_in_pool(jobs: Arc<Mutex<Receiver<proc(): Send>>>) {\n+    spawn(proc() {\n+        // Will spawn a new task on panic unless it is cancelled.\n+        let sentinel = Sentinel::new(&jobs);\n+\n+        loop {\n+            let message = {\n+                // Only lock jobs for the time it takes\n+                // to get a job, not run it.\n+                let lock = jobs.lock();\n+                lock.recv_opt()\n+            };\n+\n+            match message {\n+                Ok(job) => job(),\n+\n+                // The Taskpool was dropped.\n+                Err(..) => break\n+            }\n+        }\n+\n+        sentinel.cancel();\n+    })\n }\n \n-#[test]\n-#[should_fail]\n-fn test_zero_tasks_panic() {\n-    let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n-    TaskPool::new(0, f);\n+#[cfg(test)]\n+mod test {\n+    use core::prelude::*;\n+    use super::*;\n+    use comm::channel;\n+    use iter::range;\n+\n+    const TEST_TASKS: uint = 4u;\n+\n+    #[test]\n+    fn test_works() {\n+        use iter::AdditiveIterator;\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+\n+        let (tx, rx) = channel();\n+        for _ in range(0, TEST_TASKS) {\n+            let tx = tx.clone();\n+            pool.execute(proc() {\n+                tx.send(1u);\n+            });\n+        }\n+\n+        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_zero_tasks_panic() {\n+        TaskPool::new(0);\n+    }\n+\n+    #[test]\n+    fn test_recovery_from_subtask_panic() {\n+        use iter::AdditiveIterator;\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+\n+        // Panic all the existing tasks.\n+        for _ in range(0, TEST_TASKS) {\n+            pool.execute(proc() { panic!() });\n+        }\n+\n+        // Ensure new tasks were spawned to compensate.\n+        let (tx, rx) = channel();\n+        for _ in range(0, TEST_TASKS) {\n+            let tx = tx.clone();\n+            pool.execute(proc() {\n+                tx.send(1u);\n+            });\n+        }\n+\n+        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n+    }\n+\n+    #[test]\n+    fn test_should_not_panic_on_drop_if_subtasks_panic_after_drop() {\n+        use sync::{Arc, Barrier};\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+        let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n+\n+        // Panic all the existing tasks in a bit.\n+        for _ in range(0, TEST_TASKS) {\n+            let waiter = waiter.clone();\n+            pool.execute(proc() {\n+                waiter.wait();\n+                panic!();\n+            });\n+        }\n+\n+        drop(pool);\n+\n+        // Kick off the failure.\n+        waiter.wait();\n+    }\n }\n+"}, {"sha": "c7e31dae3d459c5d0dab78399d6fba4c29bac674", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -105,9 +105,8 @@ use rt::local::Local;\n use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n-use string::String;\n+use string::{String, ToString};\n use sync::Future;\n-use to_string::ToString;\n \n /// A means of spawning a task\n pub trait Spawner {"}, {"sha": "83340c9faac22d5b9d18bf5eff5291e32815a54a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -388,7 +388,7 @@ mod tests {\n     use super::{Duration, MIN, MAX};\n     use {i32, i64};\n     use option::{Some, None};\n-    use to_string::ToString;\n+    use string::ToString;\n \n     #[test]\n     fn test_duration() {"}, {"sha": "c19fd81b5705667185f8a8a9391fca11a9114dba", "filename": "src/libstd/to_string.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cb51567e1911452f3da4b924a91e5360f5efe67c/src%2Flibstd%2Fto_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb51567e1911452f3da4b924a91e5360f5efe67c/src%2Flibstd%2Fto_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_string.rs?ref=cb51567e1911452f3da4b924a91e5360f5efe67c", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `ToString` trait for converting to strings\n-\n-*/\n-\n-#![experimental]\n-\n-use fmt;\n-use string::String;\n-\n-/// A generic trait for converting a value to a string\n-pub trait ToString {\n-    /// Converts the value of `self` to an owned string\n-    fn to_string(&self) -> String;\n-}\n-\n-/// Trait for converting a type to a string, consuming it in the process.\n-pub trait IntoStr {\n-    /// Consume and convert to a string.\n-    fn into_string(self) -> String;\n-}\n-\n-impl<T: fmt::Show> ToString for T {\n-    fn to_string(&self) -> String {\n-        format!(\"{}\", *self)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    #[test]\n-    fn test_simple_types() {\n-        assert_eq!(1i.to_string(), \"1\".to_string());\n-        assert_eq!((-1i).to_string(), \"-1\".to_string());\n-        assert_eq!(200u.to_string(), \"200\".to_string());\n-        assert_eq!(2u8.to_string(), \"2\".to_string());\n-        assert_eq!(true.to_string(), \"true\".to_string());\n-        assert_eq!(false.to_string(), \"false\".to_string());\n-        assert_eq!(().to_string(), \"()\".to_string());\n-        assert_eq!((\"hi\".to_string()).to_string(), \"hi\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_vectors() {\n-        let x: Vec<int> = vec![];\n-        assert_eq!(x.to_string(), \"[]\".to_string());\n-        assert_eq!((vec![1i]).to_string(), \"[1]\".to_string());\n-        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\".to_string());\n-        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n-               \"[[], [1], [1, 1]]\".to_string());\n-    }\n-}"}, {"sha": "69eb260b8c4cc0626ca8518d1180cb9e0e7ddc81", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -22,19 +22,23 @@\n //! would generate two implementations like:\n //!\n //! ```ignore\n-//! impl<S:serialize::Encoder> Encodable<S> for Node {\n-//!     fn encode(&self, s: &S) {\n-//!         s.emit_struct(\"Node\", 1, || {\n-//!             s.emit_field(\"id\", 0, || s.emit_uint(self.id))\n+//! impl<S: Encoder<E>, E> Encodable<S, E> for Node {\n+//!     fn encode(&self, s: &mut S) -> Result<(), E> {\n+//!         s.emit_struct(\"Node\", 1, |this| {\n+//!             this.emit_struct_field(\"id\", 0, |this| {\n+//!                 Encodable::encode(&self.id, this)\n+//!                 /* this.emit_uint(self.id) can also be used */\n+//!             })\n //!         })\n //!     }\n //! }\n //!\n-//! impl<D:Decoder> Decodable for node_id {\n-//!     fn decode(d: &D) -> Node {\n-//!         d.read_struct(\"Node\", 1, || {\n-//!             Node {\n-//!                 id: d.read_field(\"x\".to_string(), 0, || decode(d))\n+//! impl<D: Decoder<E>, E> Decodable<D, E> for Node {\n+//!     fn decode(d: &mut D) -> Result<Node, E> {\n+//!         d.read_struct(\"Node\", 1, |this| {\n+//!             match this.read_struct_field(\"id\", 0, |this| Decodable::decode(this)) {\n+//!                 Ok(id) => Ok(Node { id: id }),\n+//!                 Err(e) => Err(e),\n //!             }\n //!         })\n //!     }\n@@ -46,37 +50,42 @@\n //!\n //! ```ignore\n //! #[deriving(Encodable, Decodable)]\n-//! struct spanned<T> { node: T, span: Span }\n+//! struct Spanned<T> { node: T, span: Span }\n //! ```\n //!\n //! would yield functions like:\n //!\n //! ```ignore\n-//!     impl<\n-//!         S: Encoder,\n-//!         T: Encodable<S>\n-//!     > spanned<T>: Encodable<S> {\n-//!         fn encode<S:Encoder>(s: &S) {\n-//!             s.emit_rec(|| {\n-//!                 s.emit_field(\"node\", 0, || self.node.encode(s));\n-//!                 s.emit_field(\"span\", 1, || self.span.encode(s));\n-//!             })\n-//!         }\n+//! impl<\n+//!     S: Encoder<E>,\n+//!     E,\n+//!     T: Encodable<S, E>\n+//! > Encodable<S, E> for Spanned<T> {\n+//!     fn encode(&self, s: &mut S) -> Result<(), E> {\n+//!         s.emit_struct(\"Spanned\", 2, |this| {\n+//!             this.emit_struct_field(\"node\", 0, |this| self.node.encode(this))\n+//!                 .ok().unwrap();\n+//!             this.emit_struct_field(\"span\", 1, |this| self.span.encode(this))\n+//!         })\n //!     }\n+//! }\n //!\n-//!     impl<\n-//!         D: Decoder,\n-//!         T: Decodable<D>\n-//!     > spanned<T>: Decodable<D> {\n-//!         fn decode(d: &D) -> spanned<T> {\n-//!             d.read_rec(|| {\n-//!                 {\n-//!                     node: d.read_field(\"node\".to_string(), 0, || decode(d)),\n-//!                     span: d.read_field(\"span\".to_string(), 1, || decode(d)),\n-//!                 }\n+//! impl<\n+//!     D: Decoder<E>,\n+//!     E,\n+//!     T: Decodable<D, E>\n+//! > Decodable<D, E> for Spanned<T> {\n+//!     fn decode(d: &mut D) -> Result<Spanned<T>, E> {\n+//!         d.read_struct(\"Spanned\", 2, |this| {\n+//!             Ok(Spanned {\n+//!                 node: this.read_struct_field(\"node\", 0, |this| Decodable::decode(this))\n+//!                     .ok().unwrap(),\n+//!                 span: this.read_struct_field(\"span\", 1, |this| Decodable::decode(this))\n+//!                     .ok().unwrap(),\n //!             })\n-//!         }\n+//!         })\n //!     }\n+//! }\n //! ```\n \n use ast::{MetaItem, Item, Expr, ExprRet, MutMutable, LitNil};"}, {"sha": "ff96f806faccb336cb8a16f86247c3f6c50d4a4e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -53,13 +53,13 @@ use std::cmp;\n use std::f64;\n use std::fmt::Show;\n use std::fmt;\n-use std::from_str::FromStr;\n use std::io::fs::PathExtensions;\n use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::num::{Float, FloatMath, Int};\n use std::os;\n+use std::str::FromStr;\n use std::string::String;\n use std::task::TaskBuilder;\n use std::time::Duration;"}, {"sha": "e439b27a19061d350405e9db2ece0d503640accb", "filename": "src/test/run-make/codegen-options-parsing/Makefile", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -0,0 +1,24 @@\n+-include ../tools.mk\n+\n+all:\n+\t#Option taking a number\n+\t$(RUSTC) -C codegen-units dummy.rs 2>&1 | \\\n+\t\tgrep 'codegen option `codegen-units` requires a number'\n+\t$(RUSTC) -C codegen-units= dummy.rs 2>&1 | \\\n+\t\tgrep 'incorrect value `` for codegen option `codegen-units` - a number was expected'\n+\t$(RUSTC) -C codegen-units=foo dummy.rs 2>&1 | \\\n+\t\tgrep 'incorrect value `foo` for codegen option `codegen-units` - a number was expected'\n+\t$(RUSTC) -C codegen-units=1 dummy.rs\n+\t#Option taking a string\n+\t$(RUSTC) -C extra-filename dummy.rs 2>&1 | \\\n+\t\tgrep 'codegen option `extra-filename` requires a string'\n+\t$(RUSTC) -C extra-filename= dummy.rs 2>&1\n+\t$(RUSTC) -C extra-filename=foo dummy.rs 2>&1\n+\t#Option taking no argument\n+\t$(RUSTC) -C lto= dummy.rs 2>&1 | \\\n+\t\tgrep 'codegen option `lto` takes no value'\n+\t$(RUSTC) -C lto=1 dummy.rs 2>&1 | \\\n+\t\tgrep 'codegen option `lto` takes no value'\n+\t$(RUSTC) -C lto=foo dummy.rs 2>&1 | \\\n+\t\tgrep 'codegen option `lto` takes no value'\n+\t$(RUSTC) -C lto dummy.rs"}, {"sha": "8ae3d072362ed6b5db81a00be3becce691926a7f", "filename": "src/test/run-make/codegen-options-parsing/dummy.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2Fdummy.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {}"}, {"sha": "a041bbfe8ad92ed706707edbba9d3e746750f01c", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -11,7 +11,7 @@\n // aux-build:cci_class_cast.rs\n extern crate cci_class_cast;\n \n-use std::to_string::ToString;\n+use std::string::ToString;\n use cci_class_cast::kitty::cat;\n \n fn print_out(thing: Box<ToString>, expected: String) {"}, {"sha": "0d88141984750fb8e5362a9e725c503e16670075", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c7a3d6c167c4656e8d35a1d428d142993e0aaab/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "patch": "@@ -11,7 +11,7 @@\n extern crate collections;\n \n use std::str::{SendStr, Owned, Slice};\n-use std::to_string::ToString;\n+use std::string::ToString;\n use self::collections::TreeMap;\n use std::option::Some;\n "}]}