{"sha": "42001edc998f3406ecc04afa48bf07ce91247b67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMDAxZWRjOTk4ZjM0MDZlY2MwNGFmYTQ4YmYwN2NlOTEyNDdiNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-11T12:04:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-11T12:04:41Z"}, "message": "Auto merge of #35403 - scottcarr:lvalue_refactor, r=nikomatsakis\n\nrefactor lvalue_ty to be method of lvalue\n\nCurrently `Mir` (and `MirContext`) implement a method `lvalue_ty` (and actually many more `foo_ty`).  But this should be a method of `Lvalue`.\n\nIf you have an `lvalue` and you want to get its type, the natural thing to write is:\n\n```\nlvalue.ty()\n```\n\nOf course it needs context, but still:\n\n```\nlvalue.ty(mir, tcx)\n```\n\nMakes more sense than\n\n```\nmir.lvalue_ty(lvalue, tcx)\n```\n\nI actually think we should go a step farther and have traits so we could get the type of some value generically, but that's up for debate.  The thing I'm running into a lot in the compiler is I have a value of type `Foo` and I know that there is some related type `Bar` which I can get through some combination of method calls, but it's often not as direct as I would imagine.  Unless you already know the code, its not clear why you would look in `Mir` for a method to get the type of an `Lvalue`.", "tree": {"sha": "7c29d830bfa0ccd66f2577ef52be3a46aacab5de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c29d830bfa0ccd66f2577ef52be3a46aacab5de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42001edc998f3406ecc04afa48bf07ce91247b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42001edc998f3406ecc04afa48bf07ce91247b67", "html_url": "https://github.com/rust-lang/rust/commit/42001edc998f3406ecc04afa48bf07ce91247b67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42001edc998f3406ecc04afa48bf07ce91247b67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "695b3d8279e17689b988e000203ba95ffeb4a91c", "url": "https://api.github.com/repos/rust-lang/rust/commits/695b3d8279e17689b988e000203ba95ffeb4a91c", "html_url": "https://github.com/rust-lang/rust/commit/695b3d8279e17689b988e000203ba95ffeb4a91c"}, {"sha": "f37bf6d367c8fb0a69f72ff49b24ad2da67ddbe5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f37bf6d367c8fb0a69f72ff49b24ad2da67ddbe5", "html_url": "https://github.com/rust-lang/rust/commit/f37bf6d367c8fb0a69f72ff49b24ad2da67ddbe5"}], "stats": {"total": 263, "additions": 129, "deletions": 134}, "files": [{"sha": "534bb2c0b2b2a1fde84d4067c3376f7f21f759f3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 73, "deletions": 77, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -113,75 +113,38 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n-    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      operand: &Operand<'tcx>)\n-                      -> Ty<'tcx>\n-    {\n-        match *operand {\n-            Operand::Consume(ref l) => self.lvalue_ty(tcx, l).to_ty(tcx),\n-            Operand::Constant(ref c) => c.ty,\n-        }\n-    }\n-\n-    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    op: BinOp,\n-                    lhs_ty: Ty<'tcx>,\n-                    rhs_ty: Ty<'tcx>)\n-                    -> Ty<'tcx>\n-    {\n-        // FIXME: handle SIMD correctly\n-        match op {\n-            BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div | BinOp::Rem |\n-            BinOp::BitXor | BinOp::BitAnd | BinOp::BitOr => {\n-                // these should be integers or floats of the same size.\n-                assert_eq!(lhs_ty, rhs_ty);\n-                lhs_ty\n-            }\n-            BinOp::Shl | BinOp::Shr => {\n-                lhs_ty // lhs_ty can be != rhs_ty\n-            }\n-            BinOp::Eq | BinOp::Lt | BinOp::Le |\n-            BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n-                tcx.types.bool\n-            }\n-        }\n-    }\n-\n-    pub fn lvalue_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     lvalue: &Lvalue<'tcx>)\n-                     -> LvalueTy<'tcx>\n-    {\n-        match *lvalue {\n-            Lvalue::Var(index) =>\n-                LvalueTy::Ty { ty: self.var_decls[index].ty },\n-            Lvalue::Temp(index) =>\n-                LvalueTy::Ty { ty: self.temp_decls[index].ty },\n-            Lvalue::Arg(index) =>\n-                LvalueTy::Ty { ty: self.arg_decls[index].ty },\n-            Lvalue::Static(def_id) =>\n+impl<'tcx> Lvalue<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> LvalueTy<'tcx> {\n+        match self {\n+            &Lvalue::Var(index) =>\n+                LvalueTy::Ty { ty: mir.var_decls[index].ty },\n+            &Lvalue::Temp(index) =>\n+                LvalueTy::Ty { ty: mir.temp_decls[index].ty },\n+            &Lvalue::Arg(index) =>\n+                LvalueTy::Ty { ty: mir.arg_decls[index].ty },\n+            &Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n-            Lvalue::ReturnPointer =>\n-                LvalueTy::Ty { ty: self.return_ty.unwrap() },\n-            Lvalue::Projection(ref proj) =>\n-                self.lvalue_ty(tcx, &proj.base).projection_ty(tcx, &proj.elem)\n+            &Lvalue::ReturnPointer =>\n+                LvalueTy::Ty { ty: mir.return_ty.unwrap() },\n+            &Lvalue::Projection(ref proj) =>\n+                proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n+}\n \n-    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     rvalue: &Rvalue<'tcx>)\n-                     -> Option<Ty<'tcx>>\n+impl<'tcx> Rvalue<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>>\n     {\n-        match *rvalue {\n-            Rvalue::Use(ref operand) => Some(self.operand_ty(tcx, operand)),\n-            Rvalue::Repeat(ref operand, ref count) => {\n-                let op_ty = self.operand_ty(tcx, operand);\n+        match self {\n+            &Rvalue::Use(ref operand) => Some(operand.ty(mir, tcx)),\n+            &Rvalue::Repeat(ref operand, ref count) => {\n+                let op_ty = operand.ty(mir, tcx);\n                 let count = count.value.as_u64(tcx.sess.target.uint_type);\n                 assert_eq!(count as usize as u64, count);\n                 Some(tcx.mk_array(op_ty, count as usize))\n             }\n-            Rvalue::Ref(reg, bk, ref lv) => {\n-                let lv_ty = self.lvalue_ty(tcx, lv).to_ty(tcx);\n+            &Rvalue::Ref(reg, bk, ref lv) => {\n+                let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 Some(tcx.mk_ref(\n                     tcx.mk_region(reg),\n                     ty::TypeAndMut {\n@@ -190,39 +153,39 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                     }\n                 ))\n             }\n-            Rvalue::Len(..) => Some(tcx.types.usize),\n-            Rvalue::Cast(_, _, ty) => Some(ty),\n-            Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.operand_ty(tcx, lhs);\n-                let rhs_ty = self.operand_ty(tcx, rhs);\n-                Some(self.binop_ty(tcx, op, lhs_ty, rhs_ty))\n+            &Rvalue::Len(..) => Some(tcx.types.usize),\n+            &Rvalue::Cast(_, _, ty) => Some(ty),\n+            &Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = lhs.ty(mir, tcx);\n+                let rhs_ty = rhs.ty(mir, tcx);\n+                Some(op.ty(tcx, lhs_ty, rhs_ty))\n             }\n-            Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.operand_ty(tcx, lhs);\n-                let rhs_ty = self.operand_ty(tcx, rhs);\n-                let ty = self.binop_ty(tcx, op, lhs_ty, rhs_ty);\n+            &Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = lhs.ty(mir, tcx);\n+                let rhs_ty = rhs.ty(mir, tcx);\n+                let ty = op.ty(tcx, lhs_ty, rhs_ty);\n                 let ty = tcx.mk_tup(vec![ty, tcx.types.bool]);\n                 Some(ty)\n             }\n-            Rvalue::UnaryOp(_, ref operand) => {\n-                Some(self.operand_ty(tcx, operand))\n+            &Rvalue::UnaryOp(_, ref operand) => {\n+                Some(operand.ty(mir, tcx))\n             }\n-            Rvalue::Box(t) => {\n+            &Rvalue::Box(t) => {\n                 Some(tcx.mk_box(t))\n             }\n-            Rvalue::Aggregate(ref ak, ref ops) => {\n+            &Rvalue::Aggregate(ref ak, ref ops) => {\n                 match *ak {\n                     AggregateKind::Vec => {\n                         if let Some(operand) = ops.get(0) {\n-                            let ty = self.operand_ty(tcx, operand);\n+                            let ty = operand.ty(mir, tcx);\n                             Some(tcx.mk_array(ty, ops.len()))\n                         } else {\n                             None\n                         }\n                     }\n                     AggregateKind::Tuple => {\n                         Some(tcx.mk_tup(\n-                            ops.iter().map(|op| self.operand_ty(tcx, op)).collect()\n+                            ops.iter().map(|op| op.ty(mir, tcx)).collect()\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs) => {\n@@ -233,7 +196,40 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                     }\n                 }\n             }\n-            Rvalue::InlineAsm { .. } => None\n+            &Rvalue::InlineAsm { .. } => None\n+        }\n+    }\n+}\n+\n+impl<'tcx> Operand<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        match self {\n+            &Operand::Consume(ref l) => l.ty(mir, tcx).to_ty(tcx),\n+            &Operand::Constant(ref c) => c.ty,\n+        }\n+    }\n+}\n+\n+impl<'tcx> BinOp {\n+      pub fn ty<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    lhs_ty: Ty<'tcx>,\n+                    rhs_ty: Ty<'tcx>)\n+                    -> Ty<'tcx> {\n+        // FIXME: handle SIMD correctly\n+        match self {\n+            &BinOp::Add | &BinOp::Sub | &BinOp::Mul | &BinOp::Div | &BinOp::Rem |\n+            &BinOp::BitXor | &BinOp::BitAnd | &BinOp::BitOr => {\n+                // these should be integers or floats of the same size.\n+                assert_eq!(lhs_ty, rhs_ty);\n+                lhs_ty\n+            }\n+            &BinOp::Shl | &BinOp::Shr => {\n+                lhs_ty // lhs_ty can be != rhs_ty\n+            }\n+            &BinOp::Eq | &BinOp::Lt | &BinOp::Le |\n+            &BinOp::Ne | &BinOp::Ge | &BinOp::Gt => {\n+                tcx.types.bool\n+            }\n         }\n     }\n }"}, {"sha": "f6e9484eda1a4ca54d363454e2531319a8f83e7c", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -185,7 +185,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     {\n         match self.move_data().move_paths[path].content {\n             MovePathContent::Lvalue(ref lvalue) => {\n-                let ty = self.mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+                let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n                 debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n                 self.tcx.type_needs_drop_given_env(ty, self.param_env())\n@@ -555,7 +555,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         let mut fields = fields;\n         fields.retain(|&(ref lvalue, _)| {\n-            let ty = self.mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+            let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n             self.tcx.type_needs_drop_given_env(ty, self.param_env())\n         });\n \n@@ -706,7 +706,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     /// This creates a \"drop ladder\" that drops the needed fields of the\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        let ty = self.mir.lvalue_ty(self.tcx, c.lvalue).to_ty(self.tcx);\n+        let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n         match ty.sty {\n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                 self.open_drop_for_adt(c, def, substs)\n@@ -892,7 +892,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // dataflow can create unneeded children in some cases\n         // - be sure to ignore them.\n \n-        let ty = self.mir.lvalue_ty(self.tcx, c.lvalue).to_ty(self.tcx);\n+        let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n         match ty.sty {\n             ty::TyStruct(def, _) | ty::TyEnum(def, _) => {"}, {"sha": "7c912e8bac6bbe9ede63801c133e23c07c19f91f", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -256,7 +256,7 @@ fn move_path_children_matching<'tcx, F>(move_paths: &MovePathData<'tcx>,\n fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                       mir: &Mir<'tcx>,\n                                                       lv: &repr::Lvalue<'tcx>) -> bool {\n-    let ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n+    let ty = lv.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n             debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} refd => false\",\n@@ -355,7 +355,7 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n \n         // don't move out of non-Copy things\n         if let MovePathContent::Lvalue(ref lvalue) = move_data.move_paths[path].content {\n-            let ty = mir.lvalue_ty(tcx, lvalue).to_ty(tcx);\n+            let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n             if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n                 continue;\n             }"}, {"sha": "fa3490cbcf3384f920426c867fc03584dbae7d31", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -347,13 +347,13 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                         continue;\n                     }\n                 }\n-                (statement.source_info.span, mir.lvalue_ty(tcx, dest).to_ty(tcx))\n+                (statement.source_info.span, dest.ty(mir, tcx).to_ty(tcx))\n             }\n             Candidate::ShuffleIndices(bb) => {\n                 let terminator = mir[bb].terminator();\n                 let ty = match terminator.kind {\n                     TerminatorKind::Call { ref args, .. } => {\n-                        mir.operand_ty(tcx, &args[2])\n+                        args[2].ty(mir, tcx)\n                     }\n                     _ => {\n                         span_bug!(terminator.source_info.span,"}, {"sha": "539ec81889f01940b28a139c4c5d0aab26f19a03", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -486,8 +486,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                 this.add(Qualif::STATIC);\n                             }\n \n-                            let base_ty = this.mir.lvalue_ty(this.tcx, &proj.base)\n-                                              .to_ty(this.tcx);\n+                            let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n                             if let ty::TyRawPtr(_) = base_ty.sty {\n                                 this.add(Qualif::NOT_CONST);\n                                 if this.mode != Mode::Fn {\n@@ -506,8 +505,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                           \"cannot refer to the interior of another \\\n                                            static, use a constant instead\");\n                             }\n-                            let ty = this.mir.lvalue_ty(this.tcx, lvalue)\n-                                         .to_ty(this.tcx);\n+                            let ty = lvalue.ty(this.mir, this.tcx).to_ty(this.tcx);\n                             this.qualif.restrict(ty, this.tcx, &this.param_env);\n                         }\n \n@@ -592,7 +590,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     self.add(Qualif::STATIC_REF);\n                 }\n \n-                let ty = self.mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+                let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n                 if kind == BorrowKind::Mut {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -652,7 +650,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = self.mir.operand_ty(self.tcx, operand);\n+                let operand_ty = operand.ty(self.mir, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -670,7 +668,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::TyRawPtr(_) = self.mir.operand_ty(self.tcx, lhs).sty {\n+                if let ty::TyRawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt);\n@@ -702,7 +700,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n \n                     if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n-                        let ty = self.mir.rvalue_ty(self.tcx, rvalue).unwrap();\n+                        let ty = rvalue.ty(self.mir, self.tcx).unwrap();\n                         self.add_type(ty);\n                         assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n                         // Even if the value inside may not need dropping,\n@@ -724,7 +722,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n             self.visit_operand(func);\n \n-            let fn_ty = self.mir.operand_ty(self.tcx, func);\n+            let fn_ty = func.ty(self.mir, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     (f.abi == Abi::PlatformIntrinsic &&\n@@ -804,7 +802,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 } else {\n                     // Be conservative about the returned value of a const fn.\n                     let tcx = self.tcx;\n-                    let ty = self.mir.lvalue_ty(tcx, dest).to_ty(tcx);\n+                    let ty = dest.ty(self.mir, tcx).to_ty(tcx);\n                     self.qualif = Qualif::empty();\n                     self.add_type(ty);\n "}, {"sha": "c8556d5e0d83fee6659cca8b11a5b5d63e13a9e4", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n         self.super_rvalue(rvalue);\n-        if let Some(ty) = self.mir.rvalue_ty(self.tcx(), rvalue) {\n+        if let Some(ty) = rvalue.ty(self.mir, self.tcx()) {\n             self.sanitize_type(rvalue, ty);\n         }\n     }\n@@ -178,7 +178,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             ProjectionElem::Index(ref i) => {\n                 self.visit_operand(i);\n-                let index_ty = self.mir.operand_ty(tcx, i);\n+                let index_ty = i.ty(self.mir, tcx);\n                 if index_ty != tcx.types.usize {\n                     LvalueTy::Ty {\n                         ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n@@ -353,8 +353,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match stmt.kind {\n             StatementKind::Assign(ref lv, ref rv) => {\n-                let lv_ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n-                let rv_ty = mir.rvalue_ty(tcx, rv);\n+                let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n+                let rv_ty = rv.ty(mir, tcx);\n                 if let Some(rv_ty) = rv_ty {\n                     if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n@@ -388,16 +388,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ref value,\n                 ..\n             } => {\n-                let lv_ty = mir.lvalue_ty(tcx, location).to_ty(tcx);\n-                let rv_ty = mir.operand_ty(tcx, value);\n+                let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n+                let rv_ty = value.ty(mir, tcx);\n                 if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n                     span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n             }\n \n             TerminatorKind::If { ref cond, .. } => {\n-                let cond_ty = mir.operand_ty(tcx, cond);\n+                let cond_ty = cond.ty(mir, tcx);\n                 match cond_ty.sty {\n                     ty::TyBool => {}\n                     _ => {\n@@ -406,7 +406,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n-                let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n+                let discr_ty = discr.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) = self.sub_types(self.last_span, discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n@@ -419,7 +419,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // FIXME: check the values\n             }\n             TerminatorKind::Switch { ref discr, adt_def, ref targets } => {\n-                let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n+                let discr_ty = discr.ty(mir, tcx).to_ty(tcx);\n                 match discr_ty.sty {\n                     ty::TyEnum(def, _)\n                         if def == adt_def && adt_def.variants.len() == targets.len()\n@@ -431,7 +431,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                let func_ty = mir.operand_ty(tcx, func);\n+                let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let func_ty = match func_ty.sty {\n                     ty::TyFnDef(_, _, func_ty) | ty::TyFnPtr(func_ty) => func_ty,\n@@ -451,16 +451,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Assert { ref cond, ref msg, .. } => {\n-                let cond_ty = mir.operand_ty(tcx, cond);\n+                let cond_ty = cond.ty(mir, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n                 if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n-                    if mir.operand_ty(tcx, len) != tcx.types.usize {\n+                    if len.ty(mir, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n-                    if mir.operand_ty(tcx, index) != tcx.types.usize {\n+                    if index.ty(mir, tcx) != tcx.types.usize {\n                         span_mirbug!(self, index, \"bounds-check index non-usize {:?}\", index)\n                     }\n                 }\n@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 span_mirbug!(self, term, \"call to diverging function {:?} with dest\", sig);\n             }\n             (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n-                let dest_ty = mir.lvalue_ty(tcx, dest).to_ty(tcx);\n+                let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) = self.sub_types(self.last_span, ty, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n@@ -505,7 +505,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n-            let op_arg_ty = mir.operand_ty(self.tcx(), op_arg);\n+            let op_arg_ty = op_arg.ty(mir, self.tcx());\n             if let Err(terr) = self.sub_types(self.last_span, op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n@@ -552,7 +552,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let arg_ty = match mir.operand_ty(self.tcx(), &args[0]).sty {\n+        let arg_ty = match args[0].ty(mir, self.tcx()).sty {\n             ty::TyRawPtr(mt) => mt.ty,\n             ty::TyBox(ty) => ty,\n             _ => {"}, {"sha": "58b49f6944fa7d69dbd2d2dff6e6f84ad4ba3170", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -478,7 +478,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let target_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &target_ty);\n-                let source_ty = self.mir.operand_ty(self.scx.tcx(), operand);\n+                let source_ty = operand.ty(self.mir, self.scx.tcx());\n                 let source_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &source_ty);\n@@ -525,8 +525,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting lvalue {:?}\", *lvalue);\n \n         if let mir_visit::LvalueContext::Drop = context {\n-            let ty = self.mir.lvalue_ty(self.scx.tcx(), lvalue)\n-                             .to_ty(self.scx.tcx());\n+            let ty = lvalue.ty(self.mir, self.scx.tcx())\n+                           .to_ty(self.scx.tcx());\n \n             let ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                       self.param_substs,\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 match constant.ty.sty {\n                     ty::TyFnDef(def_id, _, bare_fn_ty)\n                         if is_drop_in_place_intrinsic(tcx, def_id, bare_fn_ty) => {\n-                        let operand_ty = self.mir.operand_ty(tcx, &args[0]);\n+                        let operand_ty = args[0].ty(self.mir, tcx);\n                         if let ty::TyRawPtr(mt) = operand_ty.sty {\n                             let operand_ty = monomorphize::apply_param_substs(tcx,\n                                                                               self.param_substs,"}, {"sha": "d6dbefec0346752254731824e160fbe80a4e9db5", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -143,7 +143,8 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n         // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n             if self.mir.local_index(&proj.base).is_some() {\n-                let ty = self.mir.lvalue_ty(self.bcx.tcx(), &proj.base);\n+                let ty = proj.base.ty(self.mir, self.bcx.tcx());\n+\n                 let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));\n                 if common::type_is_imm_pair(self.bcx.ccx(), ty) {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n@@ -170,7 +171,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                     self.mark_as_lvalue(index);\n                 }\n                 LvalueContext::Drop => {\n-                    let ty = self.mir.lvalue_ty(self.bcx.tcx(), lvalue);\n+                    let ty = lvalue.ty(self.mir, self.bcx.tcx());\n                     let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));\n \n                     // Only need the lvalue if we're actually dropping it."}, {"sha": "b1fd3e88d75f00c8d579f8e0feb9fa45773b7adf", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -230,7 +230,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let ty = mir.lvalue_ty(bcx.tcx(), location).to_ty(bcx.tcx());\n+                let ty = location.ty(&mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = bcx.monomorphize(&ty);\n \n                 // Double check for necessity to drop\n@@ -433,7 +433,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 let extra_args = &args[sig.inputs.len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n-                    let op_ty = self.mir.operand_ty(bcx.tcx(), op_arg);\n+                    let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n                     bcx.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n                 let fn_ty = callee.direct_fn_type(bcx.ccx(), &extra_args);\n@@ -828,7 +828,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             return ReturnDest::Nothing;\n         }\n         let dest = if let Some(index) = self.mir.local_index(dest) {\n-            let ret_ty = self.lvalue_ty(dest);\n+            let ret_ty = self.monomorphized_lvalue_ty(dest);\n             match self.locals[index] {\n                 LocalRef::Lvalue(dest) => dest,\n                 LocalRef::Operand(None) => {"}, {"sha": "35ded7042969f33023d8e3d97b5def3eb79c0ea6", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let span = statement.source_info.span;\n                 match statement.kind {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n-                        let ty = self.mir.lvalue_ty(tcx, dest);\n+                        let ty = dest.ty(self.mir, tcx);\n                         let ty = self.monomorphize(&ty).to_ty(tcx);\n                         match self.const_rvalue(rvalue, ty, span) {\n                             Ok(value) => self.store(dest, value, span),\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n \n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                    let fn_ty = self.mir.operand_ty(tcx, func);\n+                    let fn_ty = func.ty(self.mir, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n                     let instance = match fn_ty.sty {\n                         ty::TyFnDef(def_id, substs, _) => {\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 ConstLvalue {\n                     base: Base::Static(consts::get_static(self.ccx, def_id).val),\n                     llextra: ptr::null_mut(),\n-                    ty: self.mir.lvalue_ty(tcx, lvalue).to_ty(tcx)\n+                    ty: lvalue.ty(self.mir, tcx).to_ty(tcx)\n                 }\n             }\n             mir::Lvalue::Projection(ref projection) => {\n@@ -723,7 +723,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let lhs = self.const_operand(lhs, span)?;\n                 let rhs = self.const_operand(rhs, span)?;\n                 let ty = lhs.ty;\n-                let binop_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let binop_ty = op.ty(tcx, lhs.ty, rhs.ty);\n                 let (lhs, rhs) = (lhs.llval, rhs.llval);\n                 Const::new(const_scalar_binop(op, lhs, rhs, ty), binop_ty)\n             }\n@@ -732,7 +732,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let lhs = self.const_operand(lhs, span)?;\n                 let rhs = self.const_operand(rhs, span)?;\n                 let ty = lhs.ty;\n-                let val_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let val_ty = op.ty(tcx, lhs.ty, rhs.ty);\n                 let binop_ty = tcx.mk_tup(vec![val_ty, tcx.types.bool]);\n                 let (lhs, rhs) = (lhs.llval, rhs.llval);\n                 assert!(!ty.is_fp());"}, {"sha": "94db2e3c23cef29a965a16c4bb7feec768e9f3b7", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -108,7 +108,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::Arg(_) |\n             mir::Lvalue::ReturnPointer => bug!(), // handled above\n             mir::Lvalue::Static(def_id) => {\n-                let const_ty = self.lvalue_ty(lvalue);\n+                let const_ty = self.monomorphized_lvalue_ty(lvalue);\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id).val,\n                                      LvalueTy::from_ty(const_ty))\n             },\n@@ -200,7 +200,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             ty::TyArray(..) => {\n                                 // must cast the lvalue pointer type to the new\n                                 // array type (*[%_; new_len]).\n-                                let base_ty = self.lvalue_ty(lvalue);\n+                                let base_ty = self.monomorphized_lvalue_ty(lvalue);\n                                 let llbasety = type_of::type_of(bcx.ccx(), base_ty).ptr_to();\n                                 let llbase = bcx.pointercast(llbase, llbasety);\n                                 (llbase, ptr::null_mut())\n@@ -240,7 +240,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             match self.locals[index] {\n                 LocalRef::Lvalue(lvalue) => f(self, lvalue),\n                 LocalRef::Operand(None) => {\n-                    let lvalue_ty = self.lvalue_ty(lvalue);\n+                    let lvalue_ty = self.monomorphized_lvalue_ty(lvalue);\n                     let lvalue = LvalueRef::alloca(bcx,\n                                                    lvalue_ty,\n                                                    \"lvalue_temp\");\n@@ -252,7 +252,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 LocalRef::Operand(Some(_)) => {\n                     // See comments in LocalRef::new_operand as to why\n                     // we always have Some in a ZST LocalRef::Operand.\n-                    let ty = self.lvalue_ty(lvalue);\n+                    let ty = self.monomorphized_lvalue_ty(lvalue);\n                     if common::type_is_zero_size(bcx.ccx(), ty) {\n                         // Pass an undef pointer as no stores can actually occur.\n                         let llptr = C_undef(type_of(bcx.ccx(), ty).ptr_to());\n@@ -289,9 +289,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    pub fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         let tcx = self.fcx.ccx.tcx();\n-        let lvalue_ty = self.mir.lvalue_ty(tcx, lvalue);\n+        let lvalue_ty = lvalue.ty(&self.mir, tcx);\n         self.fcx.monomorphize(&lvalue_ty.to_ty(tcx))\n     }\n }"}, {"sha": "9f7c2ee219eb5abafed3bc90684a3ffc6a159fbb", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -400,7 +400,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    ty: self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty),\n+                    ty: op.ty(bcx.tcx(), lhs.ty, rhs.ty),\n                 };\n                 (bcx, operand)\n             }\n@@ -410,7 +410,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let result = self.trans_scalar_checked_binop(&bcx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.ty);\n-                let val_ty = self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty);\n+                let val_ty = op.ty(bcx.tcx(), lhs.ty, rhs.ty);\n                 let operand_ty = bcx.tcx().mk_tup(vec![val_ty, bcx.tcx().types.bool]);\n                 let operand = OperandRef {\n                     val: result,"}, {"sha": "44d264c7e98f27cacd710ef00caed9622cba1c3b", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42001edc998f3406ecc04afa48bf07ce91247b67/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=42001edc998f3406ecc04afa48bf07ce91247b67", "patch": "@@ -39,7 +39,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             bcx\n                         }\n                         LocalRef::Operand(Some(_)) => {\n-                            let ty = self.lvalue_ty(lvalue);\n+                            let ty = self.monomorphized_lvalue_ty(lvalue);\n \n                             if !common::type_is_zero_size(bcx.ccx(), ty) {\n                                 span_bug!(statement.source_info.span,"}]}