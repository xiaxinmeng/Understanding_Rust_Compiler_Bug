{"sha": "a8f6e614f86be429b5862f30e023063f619aeed2", "node_id": "C_kwDOAAsO6NoAKGE4ZjZlNjE0Zjg2YmU0MjliNTg2MmYzMGUwMjMwNjNmNjE5YWVlZDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-27T09:19:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-27T09:19:42Z"}, "message": "Auto merge of #89652 - rcvalle:rust-cfi, r=nagisa\n\nAdd LLVM CFI support to the Rust compiler\n\nThis PR adds LLVM Control Flow Integrity (CFI) support to the Rust compiler. It initially provides forward-edge control flow protection for Rust-compiled code only by aggregating function pointers in groups identified by their number of arguments.\n\nForward-edge control flow protection for C or C++ and Rust -compiled code \"mixed binaries\" (i.e., for when C or C++ and Rust -compiled code share the same virtual address space) will be provided in later work as part of this project by defining and using compatible type identifiers (see Type metadata in the design document in the tracking issue #89653).\n\nLLVM CFI can be enabled with -Zsanitizer=cfi and requires LTO (i.e., -Clto).\n\nThank you, `@eddyb` and `@pcc,` for all the help!", "tree": {"sha": "329266e75828737d5cd8f66a7b27bb02379f9308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/329266e75828737d5cd8f66a7b27bb02379f9308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8f6e614f86be429b5862f30e023063f619aeed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f6e614f86be429b5862f30e023063f619aeed2", "html_url": "https://github.com/rust-lang/rust/commit/a8f6e614f86be429b5862f30e023063f619aeed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8f6e614f86be429b5862f30e023063f619aeed2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47aeac648ed56095688c1c20972c9b72bd0da7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/47aeac648ed56095688c1c20972c9b72bd0da7ce", "html_url": "https://github.com/rust-lang/rust/commit/47aeac648ed56095688c1c20972c9b72bd0da7ce"}, {"sha": "c5708caf6a858b76b5519f81d2061ef85d9976b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5708caf6a858b76b5519f81d2061ef85d9976b6", "html_url": "https://github.com/rust-lang/rust/commit/c5708caf6a858b76b5519f81d2061ef85d9976b6"}], "stats": {"total": 512, "additions": 473, "deletions": 39}, "files": [{"sha": "fff2aa6df7c725ab53bcd2a2c9ba5008c15b72e2", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -915,6 +915,16 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n+    fn type_metadata(&mut self, _function: RValue<'gcc>, _typeid: String) {\n+        // Unsupported.\n+    }\n+\n+    fn typeid_metadata(&mut self, _typeid: String) -> RValue<'gcc> {\n+        // Unsupported.\n+        self.context.new_rvalue_from_int(self.int_type, 0)\n+    }\n+\n+\n     fn store(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, align: Align) -> RValue<'gcc> {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }"}, {"sha": "64bd586662d385a863a45b0bd555d340cda24721", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -367,6 +367,11 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n+    fn type_test(&mut self, _pointer: Self::Value, _typeid: Self::Value) -> Self::Value {\n+        // Unsupported.\n+        self.context.new_rvalue_from_int(self.int_type, 0)\n+    }\n+\n     fn va_start(&mut self, _va_list: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }"}, {"sha": "0707faf610cf3e4edc312bf9f3b8d0cac413adcf", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -604,6 +604,32 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    fn type_metadata(&mut self, function: &'ll Value, typeid: String) {\n+        let typeid_metadata = self.typeid_metadata(typeid);\n+        let v = [self.const_usize(0), typeid_metadata];\n+        unsafe {\n+            llvm::LLVMGlobalSetMetadata(\n+                function,\n+                llvm::MD_type as c_uint,\n+                llvm::LLVMValueAsMetadata(llvm::LLVMMDNodeInContext(\n+                    self.cx.llcx,\n+                    v.as_ptr(),\n+                    v.len() as c_uint,\n+                )),\n+            )\n+        }\n+    }\n+\n+    fn typeid_metadata(&mut self, typeid: String) -> Self::Value {\n+        unsafe {\n+            llvm::LLVMMDStringInContext(\n+                self.cx.llcx,\n+                typeid.as_ptr() as *const c_char,\n+                typeid.as_bytes().len() as c_uint,\n+            )\n+        }\n+    }\n+\n     fn store(&mut self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }"}, {"sha": "cda766039c16728f9b4c70433bed31a191266fc0", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -221,6 +221,15 @@ pub unsafe fn create_module(\n         llvm::LLVMRustAddModuleFlag(llmod, avoid_plt, 1);\n     }\n \n+    if sess.is_sanitizer_cfi_enabled() {\n+        // FIXME(rcvalle): Add support for non canonical jump tables.\n+        let canonical_jump_tables = \"CFI Canonical Jump Tables\\0\".as_ptr().cast();\n+        // FIXME(rcvalle): Add it with Override behavior flag--LLVMRustAddModuleFlag adds it with\n+        // Warning behavior flag. Add support for specifying the behavior flag to\n+        // LLVMRustAddModuleFlag.\n+        llvm::LLVMRustAddModuleFlag(llmod, canonical_jump_tables, 1);\n+    }\n+\n     // Control Flow Guard is currently only supported by the MSVC linker on Windows.\n     if sess.target.is_like_msvc {\n         match sess.opts.cg.control_flow_guard {\n@@ -779,6 +788,8 @@ impl CodegenCx<'b, 'tcx> {\n             ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n         }\n \n+        ifn!(\"llvm.type.test\", fn(i8p, self.type_metadata()) -> i1);\n+\n         if self.sess().opts.debuginfo != DebugInfo::None {\n             ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n             ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);"}, {"sha": "e63fb22829a3f5b9789f3ab4f95a54ec1e97a404", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -401,6 +401,14 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    fn type_test(&mut self, pointer: Self::Value, typeid: Self::Value) -> Self::Value {\n+        // Test the called operand using llvm.type.test intrinsic. The LowerTypeTests link-time\n+        // optimization pass replaces calls to this intrinsic with code to test type membership.\n+        let i8p_ty = self.type_i8p();\n+        let bitcast = self.bitcast(pointer, i8p_ty);\n+        self.call_intrinsic(\"llvm.type.test\", &[bitcast, typeid])\n+    }\n+\n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n         self.call_intrinsic(\"llvm.va_start\", &[va_list])\n     }"}, {"sha": "21d2388fc3054f458dcf12a200d2c169324627fb", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -416,6 +416,7 @@ pub enum MetadataType {\n     MD_nontemporal = 9,\n     MD_mem_parallel_loop_access = 10,\n     MD_nonnull = 11,\n+    MD_type = 19,\n }\n \n /// LLVMRustAsmDialect\n@@ -1002,6 +1003,8 @@ extern \"C\" {\n     pub fn LLVMSetValueName2(Val: &Value, Name: *const c_char, NameLen: size_t);\n     pub fn LLVMReplaceAllUsesWith(OldVal: &'a Value, NewVal: &'a Value);\n     pub fn LLVMSetMetadata(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n+    pub fn LLVMGlobalSetMetadata(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n+    pub fn LLVMValueAsMetadata(Node: &'a Value) -> &Metadata;\n \n     // Operations on constants of any type\n     pub fn LLVMConstNull(Ty: &Type) -> &Value;"}, {"sha": "297dcde99b3d4e950fcd728db3addc55ff864ddb", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n+use rustc_symbol_mangling::typeid_for_fnabi;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n@@ -818,12 +819,43 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             self.codegen_argument(&mut bx, location, &mut llargs, last_arg);\n         }\n \n-        let fn_ptr = match (llfn, instance) {\n-            (Some(llfn), _) => llfn,\n-            (None, Some(instance)) => bx.get_fn_addr(instance),\n+        let (is_indirect_call, fn_ptr) = match (llfn, instance) {\n+            (Some(llfn), _) => (true, llfn),\n+            (None, Some(instance)) => (false, bx.get_fn_addr(instance)),\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n \n+        // For backends that support CFI using type membership (i.e., testing whether a given\n+        // pointer is associated with a type identifier).\n+        if bx.tcx().sess.is_sanitizer_cfi_enabled() && is_indirect_call {\n+            // Emit type metadata and checks.\n+            // FIXME(rcvalle): Add support for generalized identifiers.\n+            // FIXME(rcvalle): Create distinct unnamed MDNodes for internal identifiers.\n+            let typeid = typeid_for_fnabi(bx.tcx(), fn_abi);\n+            let typeid_metadata = bx.typeid_metadata(typeid.clone());\n+\n+            // Test whether the function pointer is associated with the type identifier.\n+            let cond = bx.type_test(fn_ptr, typeid_metadata);\n+            let mut bx_pass = bx.build_sibling_block(\"type_test.pass\");\n+            let mut bx_fail = bx.build_sibling_block(\"type_test.fail\");\n+            bx.cond_br(cond, bx_pass.llbb(), bx_fail.llbb());\n+\n+            helper.do_call(\n+                self,\n+                &mut bx_pass,\n+                fn_abi,\n+                fn_ptr,\n+                &llargs,\n+                destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n+                cleanup,\n+            );\n+\n+            bx_fail.abort();\n+            bx_fail.unreachable();\n+\n+            return;\n+        }\n+\n         helper.do_call(\n             self,\n             &mut bx,"}, {"sha": "1cd400eecfbd2b0253d9af93a443174cfe6fc086", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n+use rustc_symbol_mangling::typeid_for_fnabi;\n use rustc_target::abi::call::{FnAbi, PassMode};\n \n use std::iter;\n@@ -244,6 +245,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     for (bb, _) in traversal::reverse_postorder(&mir) {\n         fx.codegen_block(bb);\n     }\n+\n+    // For backends that support CFI using type membership (i.e., testing whether a given  pointer\n+    // is associated with a type identifier).\n+    if cx.tcx().sess.is_sanitizer_cfi_enabled() {\n+        let typeid = typeid_for_fnabi(cx.tcx(), fn_abi);\n+        bx.type_metadata(llfn, typeid.clone());\n+    }\n }\n \n /// Produces, for each argument, a `Value` pointing at the"}, {"sha": "158e658301eed725410dba017970a4b1d7e18fae", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -158,6 +158,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn range_metadata(&mut self, load: Self::Value, range: WrappingRange);\n     fn nonnull_metadata(&mut self, load: Self::Value);\n+    fn type_metadata(&mut self, function: Self::Function, typeid: String);\n+    fn typeid_metadata(&mut self, typeid: String) -> Self::Value;\n \n     fn store(&mut self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value;\n     fn store_with_flags("}, {"sha": "78bf22ef9f2e2066c5ee3d9202c857d80e04b719", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -24,6 +24,8 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     ///\n     /// Currently has any effect only when LLVM versions prior to 12.0 are used as the backend.\n     fn sideeffect(&mut self);\n+    /// Trait method used to test whether a given pointer is associated with a type identifier.\n+    fn type_test(&mut self, pointer: Self::Value, typeid: Self::Value) -> Self::Value;\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "e894e46a301424615848d78db424d789691e16f2", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -351,8 +351,7 @@ mod desc {\n     pub const parse_panic_strategy: &str = \"either `unwind` or `abort`\";\n     pub const parse_opt_panic_strategy: &str = parse_panic_strategy;\n     pub const parse_relro_level: &str = \"one of: `full`, `partial`, or `off`\";\n-    pub const parse_sanitizers: &str =\n-        \"comma separated list of sanitizers: `address`, `hwaddress`, `leak`, `memory` or `thread`\";\n+    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `leak`, `memory` or `thread`\";\n     pub const parse_sanitizer_memory_track_origins: &str = \"0, 1, or 2\";\n     pub const parse_cfguard: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n@@ -605,6 +604,7 @@ mod parse {\n             for s in v.split(',') {\n                 *slot |= match s {\n                     \"address\" => SanitizerSet::ADDRESS,\n+                    \"cfi\" => SanitizerSet::CFI,\n                     \"leak\" => SanitizerSet::LEAK,\n                     \"memory\" => SanitizerSet::MEMORY,\n                     \"thread\" => SanitizerSet::THREAD,"}, {"sha": "0f6a3ddccbaf0fbc62628cdb6d16b234c038b2be", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -672,6 +672,9 @@ impl Session {\n     pub fn is_nightly_build(&self) -> bool {\n         self.opts.unstable_features.is_nightly_build()\n     }\n+    pub fn is_sanitizer_cfi_enabled(&self) -> bool {\n+        self.opts.debugging_opts.sanitizer.contains(SanitizerSet::CFI)\n+    }\n     pub fn overflow_checks(&self) -> bool {\n         self.opts\n             .cg\n@@ -1398,6 +1401,16 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n                                 disable it using `-C target-feature=-crt-static`\",\n         );\n     }\n+\n+    // LLVM CFI requires LTO.\n+    if sess.is_sanitizer_cfi_enabled() {\n+        if sess.opts.cg.lto == config::LtoCli::Unspecified\n+            || sess.opts.cg.lto == config::LtoCli::No\n+            || sess.opts.cg.lto == config::LtoCli::Thin\n+        {\n+            sess.err(\"`-Zsanitizer=cfi` requires `-Clto`\");\n+        }\n+    }\n }\n \n /// Holds data on the current incremental compilation session, if there is one."}, {"sha": "c4bb82d467ffc056856a4ce5843fca055176d9d5", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -407,6 +407,7 @@ symbols! {\n         cfg_target_thread_local,\n         cfg_target_vendor,\n         cfg_version,\n+        cfi,\n         char,\n         client,\n         clippy,"}, {"sha": "179e47f9957a897c76c47e8d069f5da339d62f10", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -104,8 +104,9 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Instance, TyCtxt};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::config::SymbolManglingVersion;\n+use rustc_target::abi::call::FnAbi;\n \n use tracing::debug;\n \n@@ -151,6 +152,11 @@ fn symbol_name_provider(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::Symb\n     ty::SymbolName::new(tcx, &symbol_name)\n }\n \n+/// This function computes the typeid for the given function ABI.\n+pub fn typeid_for_fnabi(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> String {\n+    v0::mangle_typeid_for_fnabi(tcx, fn_abi)\n+}\n+\n /// Computes the symbol name for the given instance. This function will call\n /// `compute_instantiating_crate` if it needs to factor the instantiating crate\n /// into the symbol name."}, {"sha": "0363ddb0e6eee17b2e9d79ce3ad334a20459a6bf", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, FloatTy, Instance, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::Integer;\n use rustc_target::spec::abi::Abi;\n \n@@ -55,6 +56,41 @@ pub(super) fn mangle(\n     std::mem::take(&mut cx.out)\n }\n \n+pub(super) fn mangle_typeid_for_fnabi(\n+    _tcx: TyCtxt<'tcx>,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+) -> String {\n+    // LLVM uses type metadata to allow IR modules to aggregate pointers by their types.[1] This\n+    // type metadata is used by LLVM Control Flow Integrity to test whether a given pointer is\n+    // associated with a type identifier (i.e., test type membership).\n+    //\n+    // Clang uses the Itanium C++ ABI's[2] virtual tables and RTTI typeinfo structure name[3] as\n+    // type metadata identifiers for function pointers. The typeinfo name encoding is a\n+    // two-character code (i.e., \u201cTS\u201d) prefixed to the type encoding for the function.\n+    //\n+    // For cross-language LLVM CFI support, a compatible encoding must be used by either\n+    //\n+    //  a. Using a superset of types that encompasses types used by Clang (i.e., Itanium C++ ABI's\n+    //     type encodings[4]), or at least types used at the FFI boundary.\n+    //  b. Reducing the types to the least common denominator between types used by Clang (or at\n+    //     least types used at the FFI boundary) and Rust compilers (if even possible).\n+    //  c. Creating a new ABI for cross-language CFI and using it for Clang and Rust compilers (and\n+    //     possibly other compilers).\n+    //\n+    // Option (b) may weaken the protection for Rust-compiled only code, so it should be provided\n+    // as an alternative to a Rust-specific encoding for when mixing Rust and C and C++ -compiled\n+    // code. Option (c) would require changes to Clang to use the new ABI.\n+    //\n+    // [1] https://llvm.org/docs/TypeMetadata.html\n+    // [2] https://itanium-cxx-abi.github.io/cxx-abi/abi.html\n+    // [3] https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-special-vtables\n+    // [4] https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-type\n+    //\n+    // FIXME(rcvalle): See comment above.\n+    let arg_count = fn_abi.args.len() + fn_abi.ret.is_indirect() as usize;\n+    format!(\"typeid{}\", arg_count)\n+}\n+\n struct BinderLevel {\n     /// The range of distances from the root of what's\n     /// being printed, to the lifetimes in a binder."}, {"sha": "2c71fb8afeedeb54cb3339e22169e71a7c3c7f1d", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -6,7 +6,7 @@ pub fn target() -> Target {\n     base.max_atomic_width = Some(128);\n \n     // FIXME: The leak sanitizer currently fails the tests, see #88132.\n-    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::THREAD;\n+    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::CFI | SanitizerSet::THREAD;\n \n     base.pre_link_args.insert(LinkerFlavor::Gcc, vec![\"-arch\".to_string(), \"arm64\".to_string()]);\n     base.link_env_remove.extend(super::apple_base::macos_link_env_remove());"}, {"sha": "05e0c65dd5c38654b001db52bb786972476cca21", "filename": "compiler/rustc_target/src/spec/aarch64_fuchsia.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -8,7 +8,7 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n             max_atomic_width: Some(128),\n-            supported_sanitizers: SanitizerSet::ADDRESS,\n+            supported_sanitizers: SanitizerSet::ADDRESS | SanitizerSet::CFI,\n             ..super::fuchsia_base::opts()\n         },\n     }"}, {"sha": "1e9abbbe1e7878c5553f39983046d01b758acf86", "filename": "compiler/rustc_target/src/spec/aarch64_linux_android.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_linux_android.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -14,7 +14,7 @@ pub fn target() -> Target {\n             // As documented in https://developer.android.com/ndk/guides/cpu-features.html\n             // the neon (ASIMD) and FP must exist on all android aarch64 targets.\n             features: \"+neon,+fp-armv8\".to_string(),\n-            supported_sanitizers: SanitizerSet::HWADDRESS,\n+            supported_sanitizers: SanitizerSet::CFI | SanitizerSet::HWADDRESS,\n             ..super::android_base::opts()\n         },\n     }"}, {"sha": "03ee7ba4875c956a8d2b67628f87d8b6f848d8ce", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_freebsd.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -9,6 +9,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             max_atomic_width: Some(128),\n             supported_sanitizers: SanitizerSet::ADDRESS\n+                | SanitizerSet::CFI\n                 | SanitizerSet::MEMORY\n                 | SanitizerSet::THREAD,\n             ..super::freebsd_base::opts()"}, {"sha": "c8d46adbfd92ba17b8358aad26430538dffa1005", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -10,6 +10,7 @@ pub fn target() -> Target {\n             mcount: \"\\u{1}_mcount\".to_string(),\n             max_atomic_width: Some(128),\n             supported_sanitizers: SanitizerSet::ADDRESS\n+                | SanitizerSet::CFI\n                 | SanitizerSet::LEAK\n                 | SanitizerSet::MEMORY\n                 | SanitizerSet::THREAD"}, {"sha": "484593dcf4d785073feb7427d64f22c47b900714", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -602,6 +602,7 @@ bitflags::bitflags! {\n         const MEMORY  = 1 << 2;\n         const THREAD  = 1 << 3;\n         const HWADDRESS = 1 << 4;\n+        const CFI     = 1 << 5;\n     }\n }\n \n@@ -612,6 +613,7 @@ impl SanitizerSet {\n     fn as_str(self) -> Option<&'static str> {\n         Some(match self {\n             SanitizerSet::ADDRESS => \"address\",\n+            SanitizerSet::CFI => \"cfi\",\n             SanitizerSet::LEAK => \"leak\",\n             SanitizerSet::MEMORY => \"memory\",\n             SanitizerSet::THREAD => \"thread\",\n@@ -644,6 +646,7 @@ impl IntoIterator for SanitizerSet {\n     fn into_iter(self) -> Self::IntoIter {\n         [\n             SanitizerSet::ADDRESS,\n+            SanitizerSet::CFI,\n             SanitizerSet::LEAK,\n             SanitizerSet::MEMORY,\n             SanitizerSet::THREAD,\n@@ -1804,6 +1807,7 @@ impl Target {\n                         for s in a {\n                             base.$key_name |= match s.as_string() {\n                                 Some(\"address\") => SanitizerSet::ADDRESS,\n+                                Some(\"cfi\") => SanitizerSet::CFI,\n                                 Some(\"leak\") => SanitizerSet::LEAK,\n                                 Some(\"memory\") => SanitizerSet::MEMORY,\n                                 Some(\"thread\") => SanitizerSet::THREAD,"}, {"sha": "22fdaabfcb89b68821fde9b65c7a137c2b1439ba", "filename": "compiler/rustc_target/src/spec/x86_64_apple_darwin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -13,7 +13,8 @@ pub fn target() -> Target {\n     base.link_env_remove.extend(super::apple_base::macos_link_env_remove());\n     // don't use probe-stack=inline-asm until rust#83139 and rust#84667 are resolved\n     base.stack_probes = StackProbeType::Call;\n-    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::LEAK | SanitizerSet::THREAD;\n+    base.supported_sanitizers =\n+        SanitizerSet::ADDRESS | SanitizerSet::CFI | SanitizerSet::LEAK | SanitizerSet::THREAD;\n \n     // Clang automatically chooses a more specific target based on\n     // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work"}, {"sha": "c253c0c30b3d34c442baa2995e63e4c645b3e7fb", "filename": "compiler/rustc_target/src/spec/x86_64_fuchsia.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_fuchsia.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -6,7 +6,7 @@ pub fn target() -> Target {\n     base.max_atomic_width = Some(64);\n     // don't use probe-stack=inline-asm until rust#83139 and rust#84667 are resolved\n     base.stack_probes = StackProbeType::Call;\n-    base.supported_sanitizers = SanitizerSet::ADDRESS;\n+    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::CFI;\n \n     Target {\n         llvm_target: \"x86_64-fuchsia\".to_string(),"}, {"sha": "6aa0728668277f52e723f14a42ce3a67218c2e87", "filename": "compiler/rustc_target/src/spec/x86_64_pc_solaris.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_solaris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_solaris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_solaris.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -8,7 +8,7 @@ pub fn target() -> Target {\n     base.max_atomic_width = Some(64);\n     // don't use probe-stack=inline-asm until rust#83139 and rust#84667 are resolved\n     base.stack_probes = StackProbeType::Call;\n-    base.supported_sanitizers = SanitizerSet::ADDRESS;\n+    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::CFI;\n \n     Target {\n         llvm_target: \"x86_64-pc-solaris\".to_string(),"}, {"sha": "24cc7ae788b458dbfa268841cfba06f7fc202502", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_freebsd.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -7,7 +7,8 @@ pub fn target() -> Target {\n     base.pre_link_args.entry(LinkerFlavor::Gcc).or_default().push(\"-m64\".to_string());\n     // don't use probe-stack=inline-asm until rust#83139 and rust#84667 are resolved\n     base.stack_probes = StackProbeType::Call;\n-    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::MEMORY | SanitizerSet::THREAD;\n+    base.supported_sanitizers =\n+        SanitizerSet::ADDRESS | SanitizerSet::CFI | SanitizerSet::MEMORY | SanitizerSet::THREAD;\n \n     Target {\n         llvm_target: \"x86_64-unknown-freebsd\".to_string(),"}, {"sha": "79ccf63acfada71a1d2d268bf0a963b97f3368b6", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_illumos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_illumos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_illumos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_illumos.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -5,7 +5,7 @@ pub fn target() -> Target {\n     base.pre_link_args.insert(LinkerFlavor::Gcc, vec![\"-m64\".to_string(), \"-std=c99\".to_string()]);\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n-    base.supported_sanitizers = SanitizerSet::ADDRESS;\n+    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::CFI;\n \n     Target {\n         // LLVM does not currently have a separate illumos target,"}, {"sha": "c2484f2d8f66d88b8bfd23f3d88497b255a4eb24", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -7,8 +7,11 @@ pub fn target() -> Target {\n     base.pre_link_args.entry(LinkerFlavor::Gcc).or_default().push(\"-m64\".to_string());\n     // don't use probe-stack=inline-asm until rust#83139 and rust#84667 are resolved\n     base.stack_probes = StackProbeType::Call;\n-    base.supported_sanitizers =\n-        SanitizerSet::ADDRESS | SanitizerSet::LEAK | SanitizerSet::MEMORY | SanitizerSet::THREAD;\n+    base.supported_sanitizers = SanitizerSet::ADDRESS\n+        | SanitizerSet::CFI\n+        | SanitizerSet::LEAK\n+        | SanitizerSet::MEMORY\n+        | SanitizerSet::THREAD;\n \n     Target {\n         llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),"}, {"sha": "a5e79803335b7ae027f2c678740288ee72a39f7c", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_musl.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -8,8 +8,11 @@ pub fn target() -> Target {\n     // don't use probe-stack=inline-asm until rust#83139 and rust#84667 are resolved\n     base.stack_probes = StackProbeType::Call;\n     base.static_position_independent_executables = true;\n-    base.supported_sanitizers =\n-        SanitizerSet::ADDRESS | SanitizerSet::LEAK | SanitizerSet::MEMORY | SanitizerSet::THREAD;\n+    base.supported_sanitizers = SanitizerSet::ADDRESS\n+        | SanitizerSet::CFI\n+        | SanitizerSet::LEAK\n+        | SanitizerSet::MEMORY\n+        | SanitizerSet::THREAD;\n \n     Target {\n         llvm_target: \"x86_64-unknown-linux-musl\".to_string(),"}, {"sha": "bdb2be4f863e2bed0d37e2f1c60247568ec9baf5", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_netbsd.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_netbsd.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -7,8 +7,11 @@ pub fn target() -> Target {\n     base.pre_link_args.entry(LinkerFlavor::Gcc).or_default().push(\"-m64\".to_string());\n     // don't use probe-stack=inline-asm until rust#83139 and rust#84667 are resolved\n     base.stack_probes = StackProbeType::Call;\n-    base.supported_sanitizers =\n-        SanitizerSet::ADDRESS | SanitizerSet::LEAK | SanitizerSet::MEMORY | SanitizerSet::THREAD;\n+    base.supported_sanitizers = SanitizerSet::ADDRESS\n+        | SanitizerSet::CFI\n+        | SanitizerSet::LEAK\n+        | SanitizerSet::MEMORY\n+        | SanitizerSet::THREAD;\n \n     Target {\n         llvm_target: \"x86_64-unknown-netbsd\".to_string(),"}, {"sha": "18e8ed394e81409615a9de263fd05626cb46cac5", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -2879,6 +2879,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 for item in list.iter() {\n                     if item.has_name(sym::address) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n+                    } else if item.has_name(sym::cfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n                     } else if item.has_name(sym::memory) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n                     } else if item.has_name(sym::thread) {"}, {"sha": "fa38dd54d60c89bc7730daa6c20b1c501df0d6df", "filename": "src/doc/rustc/src/exploit-mitigations.md", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -123,9 +123,9 @@ equivalent.\n   <tr>\n    <td>Forward-edge control flow protection\n    </td>\n-   <td>No\n+   <td>Yes\n    </td>\n-   <td>\n+   <td>Nightly\n    </td>\n   </tr>\n   <tr>\n@@ -465,24 +465,27 @@ implementations such as [LLVM ControlFlowIntegrity\n commercially available [grsecurity/PaX Reuse Attack Protector\n (RAP)](https://grsecurity.net/rap_faq).\n \n-The Rust compiler does not support forward-edge control flow protection on\n-Linux<sup id=\"fnref:6\" role=\"doc-noteref\"><a href=\"#fn:6\"\n-class=\"footnote\">6</a></sup>. There is work currently ongoing to add support\n-for the [sanitizers](https://github.com/google/sanitizers)[40], which may or\n-may not include support for LLVM CFI.\n+The Rust compiler supports forward-edge control flow protection on nightly\n+builds[40]-[41] <sup id=\"fnref:6\" role=\"doc-noteref\"><a href=\"#fn:6\"\n+class=\"footnote\">6</a></sup>.\n \n ```text\n-$ readelf -s target/release/hello-rust | grep __cfi_init\n+$ readelf -s -W target/debug/rust-cfi | grep \"\\.cfi\"\n+    12: 0000000000005170    46 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi7add_one.cfi\n+    15: 00000000000051a0    16 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi7add_two.cfi\n+    17: 0000000000005270   396 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi4main.cfi\n+...\n ```\n-Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary.\n+Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary[41].\n \n-The presence of the `__cfi_init` symbol (and references to `__cfi_check`)\n-indicates that LLVM CFI (i.e., forward-edge control flow protection) is\n-enabled for a given binary. Conversely, the absence of the `__cfi_init`\n-symbol (and references to `__cfi_check`) indicates that LLVM CFI is not\n-enabled for a given binary (see Fig. 15).\n+The presence of symbols suffixed with \".cfi\" or the `__cfi_init` symbol (and\n+references to `__cfi_check`) indicates that LLVM CFI (i.e., forward-edge control\n+flow protection) is enabled for a given binary. Conversely, the absence of\n+symbols suffixed with \".cfi\" or the `__cfi_init` symbol (and references to\n+`__cfi_check`) indicates that LLVM CFI is not enabled for a given binary (see\n+Fig. 15).\n \n-<small id=\"fn:6\">6\\. It supports Control Flow Guard (CFG) on Windows (see\n+<small id=\"fn:6\">6\\. It also supports Control Flow Guard (CFG) on Windows (see\n <https://github.com/rust-lang/rust/issues/68793>). <a href=\"#fnref:6\"\n class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n \n@@ -689,5 +692,8 @@ defaults (unrelated to `READ_IMPLIES_EXEC`).\n 39. A. Crichton. \u201cRemove the alloc\\_jemalloc crate #55238.\u201d GitHub.\n     <https://github.com/rust-lang/rust/pull/55238>.\n \n-40. J. Aparicio. 2017. \u201cTracking issue for sanitizer support #39699.\u201d\n-    <https://github.com/rust-lang/rust/issues/39699>.\n+40. R. de C Valle. \u201cTracking Issue for LLVM Control Flow Integrity (CFI) Support\n+    for Rust #89653.\u201d GitHub. <https://github.com/rust-lang/rust/issues/89653>.\n+\n+41. \u201cControlFlowIntegrity.\u201d The Rust Unstable Book.\n+    <https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#controlflowintegrity>."}, {"sha": "b3dbc9a9956795273b3ec854ef72873681057206", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 179, "deletions": 2, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -1,19 +1,24 @@\n # `sanitizer`\n \n-The tracking issue for this feature is: [#39699](https://github.com/rust-lang/rust/issues/39699).\n+The tracking issues for this feature are:\n+\n+* [#39699](https://github.com/rust-lang/rust/issues/39699).\n+* [#89653](https://github.com/rust-lang/rust/issues/89653).\n \n ------------------------\n \n This feature allows for use of one of following sanitizers:\n \n * [AddressSanitizer][clang-asan] a fast memory error detector.\n+* [ControlFlowIntegrity][clang-cfi] LLVM Control Flow Integrity (CFI) provides\n+  forward-edge control flow protection.\n * [HWAddressSanitizer][clang-hwasan] a memory error detector similar to\n   AddressSanitizer, but based on partial hardware assistance.\n * [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n * [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n-To enable a sanitizer compile with `-Zsanitizer=address`,\n+To enable a sanitizer compile with `-Zsanitizer=address`,`-Zsanitizer=cfi`,\n `-Zsanitizer=hwaddress`, `-Zsanitizer=leak`, `-Zsanitizer=memory` or\n `-Zsanitizer=thread`.\n \n@@ -177,6 +182,176 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n ==39249==ABORTING\n ```\n \n+# ControlFlowIntegrity\n+\n+The LLVM Control Flow Integrity (CFI) support in the Rust compiler initially\n+provides forward-edge control flow protection for Rust-compiled code only by\n+aggregating function pointers in groups identified by their number of arguments.\n+\n+Forward-edge control flow protection for C or C++ and Rust -compiled code \"mixed\n+binaries\" (i.e., for when C or C++ and Rust -compiled code share the same\n+virtual address space) will be provided in later work by defining and using\n+compatible type identifiers (see Type metadata in the design document in the\n+tracking issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n+\n+LLVM CFI can be enabled with -Zsanitizer=cfi and requires LTO (i.e., -Clto).\n+\n+## Example\n+\n+```text\n+#![feature(asm, naked_functions)]\n+\n+use std::mem;\n+\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+#[naked]\n+pub extern \"C\" fn add_two(x: i32) {\n+    // x + 2 preceeded by a landing pad/nop block\n+    unsafe {\n+        asm!(\n+            \"\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             lea rax, [rdi+2]\n+             ret\n+        \",\n+            options(noreturn)\n+        );\n+    }\n+}\n+\n+fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    f(arg) + f(arg)\n+}\n+\n+fn main() {\n+    let answer = do_twice(add_one, 5);\n+\n+    println!(\"The answer is: {}\", answer);\n+\n+    println!(\"With CFI enabled, you should not see the next answer\");\n+    let f: fn(i32) -> i32 = unsafe {\n+        // Offsets 0-8 make it land in the landing pad/nop block, and offsets 1-8 are\n+        // invalid branch/call destinations (i.e., within the body of the function).\n+        mem::transmute::<*const u8, fn(i32) -> i32>((add_two as *const u8).offset(5))\n+    };\n+    let next_answer = do_twice(f, 5);\n+\n+    println!(\"The next answer is: {}\", next_answer);\n+}\n+```\n+Fig. 1.\u2003Modified example from the [Advanced Functions and\n+Closures][rust-book-ch19-05] chapter of the [The Rust Programming\n+Language][rust-book] book.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+The next answer is: 14\n+$\n+```\n+Fig. 2.\u2003Build and execution of the modified example with LLVM CFI disabled.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc -Clto -Zsanitizer=cfi rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+Illegal instruction\n+$\n+```\n+Fig. 3.\u2003Build and execution of the modified example with LLVM CFI enabled.\n+\n+When LLVM CFI is enabled, if there are any attempts to change/hijack control\n+flow using an indirect branch/call to an invalid destination, the execution is\n+terminated (see Fig. 3).\n+\n+```rust\n+use std::mem;\n+\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+fn add_two(x: i32, _y: i32) -> i32 {\n+    x + 2\n+}\n+\n+fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    f(arg) + f(arg)\n+}\n+\n+fn main() {\n+    let answer = do_twice(add_one, 5);\n+\n+    println!(\"The answer is: {}\", answer);\n+\n+    println!(\"With CFI enabled, you should not see the next answer\");\n+    let f: fn(i32) -> i32 =\n+        unsafe { mem::transmute::<*const u8, fn(i32) -> i32>(add_two as *const u8) };\n+    let next_answer = do_twice(f, 5);\n+\n+    println!(\"The next answer is: {}\", next_answer);\n+}\n+```\n+Fig. 4.\u2003Another modified example from the [Advanced Functions and\n+Closures][rust-book-ch19-05] chapter of the [The Rust Programming\n+Language][rust-book] book.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+The next answer is: 14\n+$\n+```\n+Fig. 5.\u2003Build and execution of the modified example with LLVM CFI disabled.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc -Clto -Zsanitizer=cfi rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+Illegal instruction\n+$\n+```\n+Fig. 6.\u2003Build and execution of the modified example with LLVM CFI enabled.\n+\n+When LLVM CFI is enabled, if there are any attempts to change/hijack control\n+flow using an indirect branch/call to a function with different number of\n+arguments than intended/passed in the call/branch site, the execution is also\n+terminated (see Fig. 6).\n+\n+Forward-edge control flow protection not only by aggregating function pointers\n+in groups identified by their number of arguments, but also their argument\n+types, will also be provided in later work by defining and using compatible type\n+identifiers (see Type metadata in the design document in the tracking\n+issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n+\n+[rust-book-ch19-05]: https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html\n+[rust-book]: https://doc.rust-lang.org/book/title-page.html\n+\n # HWAddressSanitizer\n \n HWAddressSanitizer is a newer variant of AddressSanitizer that consumes much\n@@ -404,12 +579,14 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n \n * [Sanitizers project page](https://github.com/google/sanitizers/wiki/)\n * [AddressSanitizer in Clang][clang-asan]\n+* [ControlFlowIntegrity in Clang][clang-cfi]\n * [HWAddressSanitizer in Clang][clang-hwasan]\n * [LeakSanitizer in Clang][clang-lsan]\n * [MemorySanitizer in Clang][clang-msan]\n * [ThreadSanitizer in Clang][clang-tsan]\n \n [clang-asan]: https://clang.llvm.org/docs/AddressSanitizer.html\n+[clang-cfi]: https://clang.llvm.org/docs/ControlFlowIntegrity.html\n [clang-hwasan]: https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html\n [clang-lsan]: https://clang.llvm.org/docs/LeakSanitizer.html\n [clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html"}, {"sha": "68f81808861a8633e1f1e6d6981bde444b3ab982", "filename": "src/test/codegen/sanitizer_cfi_add_canonical_jump_tables_flag.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_add_canonical_jump_tables_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_add_canonical_jump_tables_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_add_canonical_jump_tables_flag.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -0,0 +1,14 @@\n+// Verifies that \"CFI Canonical Jump Tables\" module flag is added.\n+//\n+// ignore-windows\n+// needs-sanitizer-cfi\n+// only-aarch64\n+// only-x86_64\n+// compile-flags: -Clto -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo() {\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 2, !\"CFI Canonical Jump Tables\", i32 1}"}, {"sha": "9ed0422ceff15907fcb019be034ec76aadb877be", "filename": "src/test/codegen/sanitizer_cfi_emit_type_checks.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_checks.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -0,0 +1,24 @@\n+// Verifies that pointer type membership tests for indirect calls are emitted.\n+//\n+// ignore-windows\n+// needs-sanitizer-cfi\n+// only-aarch64\n+// only-x86_64\n+// compile-flags: -Clto -Cno-prepopulate-passes -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       start:\n+    // CHECK-NEXT:  %0 = bitcast i32 (i32)* %f to i8*\n+    // CHECK-NEXT:  %1 = call i1 @llvm.type.test(i8* %0, metadata !\"{{[[:print:]]+}}\")\n+    // CHECK-NEXT:  br i1 %1, label %type_test.pass, label %type_test.fail\n+    // CHECK:       type_test.pass:\n+    // CHECK-NEXT:  %2 = call i32 %f(i32 %arg)\n+    // CHECK-NEXT:  br label %bb1\n+    // CHECK:       type_test.fail:\n+    // CHECK-NEXT:  call void @llvm.trap()\n+    // CHECK-NEXT:  unreachable\n+    f(arg)\n+}"}, {"sha": "96fced47e786d977f63bfe170e3886b0cfecef9d", "filename": "src/test/codegen/sanitizer_cfi_emit_type_metadata.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f6e614f86be429b5862f30e023063f619aeed2/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer_cfi_emit_type_metadata.rs?ref=a8f6e614f86be429b5862f30e023063f619aeed2", "patch": "@@ -0,0 +1,31 @@\n+// Verifies that type metadata for functions are emitted.\n+//\n+// ignore-windows\n+// needs-sanitizer-cfi\n+// only-aarch64\n+// only-x86_64\n+// compile-flags: -Clto -Cno-prepopulate-passes -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"typeid1\")\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"typeid2\")\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"typeid3\")\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i64 0, !\"typeid2\"}\n+// CHECK: !{{[0-9]+}} = !{i64 0, !\"typeid3\"}\n+// CHECK: !{{[0-9]+}} = !{i64 0, !\"typeid4\"}"}]}