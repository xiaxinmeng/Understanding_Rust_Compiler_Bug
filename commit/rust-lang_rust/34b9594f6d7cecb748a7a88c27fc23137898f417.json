{"sha": "34b9594f6d7cecb748a7a88c27fc23137898f417", "node_id": "C_kwDOAAsO6NoAKDM0Yjk1OTRmNmQ3Y2VjYjc0OGE3YTg4YzI3ZmMyMzEzNzg5OGY0MTc", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-26T05:50:30Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-26T20:31:53Z"}, "message": "Detect when method call on LHS might be shadowed\n\nAddress #39232.", "tree": {"sha": "35c9e98b5db7ac4d11e4686519e7bc525d13bfb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c9e98b5db7ac4d11e4686519e7bc525d13bfb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b9594f6d7cecb748a7a88c27fc23137898f417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b9594f6d7cecb748a7a88c27fc23137898f417", "html_url": "https://github.com/rust-lang/rust/commit/34b9594f6d7cecb748a7a88c27fc23137898f417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b9594f6d7cecb748a7a88c27fc23137898f417/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caa64e5b5e7605a1c1428b2a402021bef83f3e1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/caa64e5b5e7605a1c1428b2a402021bef83f3e1e", "html_url": "https://github.com/rust-lang/rust/commit/caa64e5b5e7605a1c1428b2a402021bef83f3e1e"}], "stats": {"total": 167, "additions": 167, "deletions": 0}, "files": [{"sha": "f7f492863abc7e2df271f719b89df5020b3e2b0f", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/34b9594f6d7cecb748a7a88c27fc23137898f417/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b9594f6d7cecb748a7a88c27fc23137898f417/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=34b9594f6d7cecb748a7a88c27fc23137898f417", "patch": "@@ -1,5 +1,6 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -36,6 +37,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        self.annotate_alternative_method_deref(err, expr, error);\n+\n         // Use `||` to give these suggestions a precedence\n         let _ = self.suggest_missing_parentheses(err, expr)\n             || self.suggest_remove_last_method_call(err, expr, expected)\n@@ -316,6 +319,95 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn annotate_alternative_method_deref(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        error: Option<TypeError<'tcx>>,\n+    ) {\n+        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let Some(TypeError::Sorts(ExpectedFound { expected, .. })) = error else {return;};\n+        let Some(hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Assign(lhs, rhs, _), ..\n+                })) = self.tcx.hir().find(parent) else {return; };\n+        if rhs.hir_id != expr.hir_id || expected.is_closure() {\n+            return;\n+        }\n+        let hir::ExprKind::Unary(hir::UnOp::Deref, deref) = lhs.kind else { return; };\n+        let hir::ExprKind::MethodCall(path, base, args, _) = deref.kind else { return; };\n+        let self_ty = self.typeck_results.borrow().expr_ty_adjusted_opt(base).unwrap();\n+        let pick = self\n+            .probe_for_name(\n+                probe::Mode::MethodCall,\n+                path.ident,\n+                probe::IsSuggestion(true),\n+                self_ty,\n+                deref.hir_id,\n+                probe::ProbeScope::TraitsInScope,\n+            )\n+            .unwrap();\n+        let methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::AllTraits,\n+        );\n+        let suggestions: Vec<_> = methods\n+            .into_iter()\n+            .filter(|m| m.def_id != pick.item.def_id)\n+            .map(|m| {\n+                let substs = ty::InternalSubsts::for_item(self.tcx, m.def_id, |param, _| {\n+                    self.var_for_def(deref.span, param)\n+                });\n+                vec![\n+                    (\n+                        deref.span.until(base.span),\n+                        format!(\n+                            \"{}({}\",\n+                            with_no_trimmed_paths!(\n+                                self.tcx.def_path_str_with_substs(m.def_id, substs,)\n+                            ),\n+                            match self.tcx.fn_sig(m.def_id).input(0).skip_binder().kind() {\n+                                ty::Ref(_, _, hir::Mutability::Mut) => \"&mut \",\n+                                ty::Ref(_, _, _) => \"&\",\n+                                _ => \"\",\n+                            },\n+                        ),\n+                    ),\n+                    match &args[..] {\n+                        [] => (base.span.shrink_to_hi().with_hi(deref.span.hi()), \")\".to_string()),\n+                        [first, ..] => (base.span.until(first.span), String::new()),\n+                    },\n+                ]\n+            })\n+            .collect();\n+        if suggestions.is_empty() {\n+            return;\n+        }\n+        let mut path_span: MultiSpan = path.ident.span.into();\n+        path_span.push_span_label(\n+            path.ident.span,\n+            format!(\n+                \"refers to `{}`\",\n+                with_no_trimmed_paths!(self.tcx.def_path_str(pick.item.def_id)),\n+            ),\n+        );\n+        err.span_note(\n+            path_span,\n+            &format!(\n+            \"there are multiple methods with the same name, `{}` refers to `{}` in the method call\",\n+            path.ident,\n+            with_no_trimmed_paths!(self.tcx.def_path_str(pick.item.def_id)),\n+        ));\n+        err.multipart_suggestions(\n+            \"you might have meant to invoke a different method, you can use the fully-qualified path\",\n+        suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// If the expected type is an enum (Issue #55250) with any variants whose\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants("}, {"sha": "a7574d4e1afd44c1dd75256d51db1f06eaea06af", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/34b9594f6d7cecb748a7a88c27fc23137898f417/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b9594f6d7cecb748a7a88c27fc23137898f417/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=34b9594f6d7cecb748a7a88c27fc23137898f417", "patch": "@@ -322,6 +322,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n+    pub fn probe_for_name_many(\n+        &self,\n+        mode: Mode,\n+        item_name: Ident,\n+        is_suggestion: IsSuggestion,\n+        self_ty: Ty<'tcx>,\n+        scope_expr_id: hir::HirId,\n+        scope: ProbeScope,\n+    ) -> Vec<ty::AssocItem> {\n+        self.probe_op(\n+            item_name.span,\n+            mode,\n+            Some(item_name),\n+            None,\n+            is_suggestion,\n+            self_ty,\n+            scope_expr_id,\n+            scope,\n+            |probe_cx| {\n+                Ok(probe_cx\n+                    .inherent_candidates\n+                    .iter()\n+                    .chain(&probe_cx.extension_candidates)\n+                    // .filter(|candidate| candidate_filter(&candidate.item))\n+                    .map(|candidate| candidate.item)\n+                    .collect())\n+            },\n+        )\n+        .unwrap()\n+    }\n+\n     fn probe_op<OP, R>(\n         &'a self,\n         span: Span,"}, {"sha": "740ac77ee0c675d7fc7257dce53f4932e5947986", "filename": "src/test/ui/suggestions/shadowed-lplace-method.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34b9594f6d7cecb748a7a88c27fc23137898f417/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/34b9594f6d7cecb748a7a88c27fc23137898f417/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed?ref=34b9594f6d7cecb748a7a88c27fc23137898f417", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![allow(unused_imports)]\n+use std::borrow::BorrowMut;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+fn main() {\n+    let rc = Rc::new(RefCell::new(true));\n+    *std::cell::RefCell::<_>::borrow_mut(&rc) = false; //~ ERROR E0308\n+}"}, {"sha": "6bf12879e6f28dcc5c5c354b7917b78f9a083854", "filename": "src/test/ui/suggestions/shadowed-lplace-method.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34b9594f6d7cecb748a7a88c27fc23137898f417/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b9594f6d7cecb748a7a88c27fc23137898f417/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs?ref=34b9594f6d7cecb748a7a88c27fc23137898f417", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![allow(unused_imports)]\n+use std::borrow::BorrowMut;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+fn main() {\n+    let rc = Rc::new(RefCell::new(true));\n+    *rc.borrow_mut() = false; //~ ERROR E0308\n+}"}, {"sha": "080600128a3da6633a61d5972e701d39fdcfc2e6", "filename": "src/test/ui/suggestions/shadowed-lplace-method.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/34b9594f6d7cecb748a7a88c27fc23137898f417/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34b9594f6d7cecb748a7a88c27fc23137898f417/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr?ref=34b9594f6d7cecb748a7a88c27fc23137898f417", "patch": "@@ -0,0 +1,23 @@\n+error[E0308]: mismatched types\n+  --> $DIR/shadowed-lplace-method.rs:9:24\n+   |\n+LL |     *rc.borrow_mut() = false;\n+   |     ----------------   ^^^^^ expected struct `Rc`, found `bool`\n+   |     |\n+   |     expected due to the type of this binding\n+   |\n+   = note: expected struct `Rc<RefCell<bool>>`\n+                found type `bool`\n+note: there are multiple methods with the same name, `borrow_mut` refers to `std::borrow::BorrowMut::borrow_mut` in the method call\n+  --> $DIR/shadowed-lplace-method.rs:9:9\n+   |\n+LL |     *rc.borrow_mut() = false;\n+   |         ^^^^^^^^^^ refers to `std::borrow::BorrowMut::borrow_mut`\n+help: you might have meant to invoke a different method, you can use the fully-qualified path\n+   |\n+LL |     *std::cell::RefCell::<_>::borrow_mut(&rc) = false;\n+   |      +++++++++++++++++++++++++++++++++++++  ~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}