{"sha": "915686d069a36de0a31bc8e4a11d432fed7d4bda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNTY4NmQwNjlhMzZkZTBhMzFiYzhlNGExMWQ0MzJmZWQ3ZDRiZGE=", "commit": {"author": {"name": "Dario Gonzalez", "email": "dario.gonzalez@fortanix.com", "date": "2019-12-04T18:36:43Z"}, "committer": {"name": "Dario Gonzalez", "email": "dario.gonzalez@fortanix.com", "date": "2019-12-26T16:22:59Z"}, "message": "Implement padding for IpAddr without heap alloc", "tree": {"sha": "a40b146f732bd930a3c50d8268718087bfb6bb75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a40b146f732bd930a3c50d8268718087bfb6bb75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/915686d069a36de0a31bc8e4a11d432fed7d4bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/915686d069a36de0a31bc8e4a11d432fed7d4bda", "html_url": "https://github.com/rust-lang/rust/commit/915686d069a36de0a31bc8e4a11d432fed7d4bda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/915686d069a36de0a31bc8e4a11d432fed7d4bda/comments", "author": {"login": "Goirad", "id": 20523291, "node_id": "MDQ6VXNlcjIwNTIzMjkx", "avatar_url": "https://avatars.githubusercontent.com/u/20523291?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Goirad", "html_url": "https://github.com/Goirad", "followers_url": "https://api.github.com/users/Goirad/followers", "following_url": "https://api.github.com/users/Goirad/following{/other_user}", "gists_url": "https://api.github.com/users/Goirad/gists{/gist_id}", "starred_url": "https://api.github.com/users/Goirad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Goirad/subscriptions", "organizations_url": "https://api.github.com/users/Goirad/orgs", "repos_url": "https://api.github.com/users/Goirad/repos", "events_url": "https://api.github.com/users/Goirad/events{/privacy}", "received_events_url": "https://api.github.com/users/Goirad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Goirad", "id": 20523291, "node_id": "MDQ6VXNlcjIwNTIzMjkx", "avatar_url": "https://avatars.githubusercontent.com/u/20523291?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Goirad", "html_url": "https://github.com/Goirad", "followers_url": "https://api.github.com/users/Goirad/followers", "following_url": "https://api.github.com/users/Goirad/following{/other_user}", "gists_url": "https://api.github.com/users/Goirad/gists{/gist_id}", "starred_url": "https://api.github.com/users/Goirad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Goirad/subscriptions", "organizations_url": "https://api.github.com/users/Goirad/orgs", "repos_url": "https://api.github.com/users/Goirad/repos", "events_url": "https://api.github.com/users/Goirad/events{/privacy}", "received_events_url": "https://api.github.com/users/Goirad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acb6690e1d58fc5f262ada5b5030fe73e601f1e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/acb6690e1d58fc5f262ada5b5030fe73e601f1e8", "html_url": "https://github.com/rust-lang/rust/commit/acb6690e1d58fc5f262ada5b5030fe73e601f1e8"}], "stats": {"total": 93, "additions": 80, "deletions": 13}, "files": [{"sha": "15d2361acd916e83f923a6c6c954fd73f7968aef", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 80, "deletions": 13, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/915686d069a36de0a31bc8e4a11d432fed7d4bda/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915686d069a36de0a31bc8e4a11d432fed7d4bda/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=915686d069a36de0a31bc8e4a11d432fed7d4bda", "patch": "@@ -9,6 +9,7 @@\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::hash;\n+use crate::io::Write;\n use crate::sys::net::netc as c;\n use crate::sys_common::{AsInner, FromInner};\n \n@@ -833,8 +834,16 @@ impl From<Ipv6Addr> for IpAddr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv4Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        const IPV4_BUF_LEN: usize = 15; // Long enough for the longest possible IPv4 address\n+        let mut buf = [0u8; IPV4_BUF_LEN];\n+        let mut buf_slice = &mut buf[..];\n         let octets = self.octets();\n-        write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n+        // Note: The call to write should never fail, hence the unwrap\n+        write!(buf_slice, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n+        let len = IPV4_BUF_LEN - buf_slice.len();\n+        // This unsafe is OK because we know what is being written to the buffer\n+        let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n+        fmt.pad(buf)\n     }\n }\n \n@@ -1495,18 +1504,40 @@ impl Ipv6Addr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Note: The calls to write should never fail, hence the unwraps in the function\n+        // Long enough for the longest possible IPv6: 39\n+        const IPV6_BUF_LEN: usize = 39;\n+        let mut buf = [0u8; IPV6_BUF_LEN];\n+        let mut buf_slice = &mut buf[..];\n+\n         match self.segments() {\n             // We need special cases for :: and ::1, otherwise they're formatted\n             // as ::0.0.0.[01]\n-            [0, 0, 0, 0, 0, 0, 0, 0] => write!(fmt, \"::\"),\n-            [0, 0, 0, 0, 0, 0, 0, 1] => write!(fmt, \"::1\"),\n+            [0, 0, 0, 0, 0, 0, 0, 0] => write!(buf_slice, \"::\").unwrap(),\n+            [0, 0, 0, 0, 0, 0, 0, 1] => write!(buf_slice, \"::1\").unwrap(),\n             // Ipv4 Compatible address\n             [0, 0, 0, 0, 0, 0, g, h] => {\n-                write!(fmt, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8, (h >> 8) as u8, h as u8)\n+                write!(\n+                    buf_slice,\n+                    \"::{}.{}.{}.{}\",\n+                    (g >> 8) as u8,\n+                    g as u8,\n+                    (h >> 8) as u8,\n+                    h as u8\n+                )\n+                .unwrap();\n             }\n             // Ipv4-Mapped address\n             [0, 0, 0, 0, 0, 0xffff, g, h] => {\n-                write!(fmt, \"::ffff:{}.{}.{}.{}\", (g >> 8) as u8, g as u8, (h >> 8) as u8, h as u8)\n+                write!(\n+                    buf_slice,\n+                    \"::ffff:{}.{}.{}.{}\",\n+                    (g >> 8) as u8,\n+                    g as u8,\n+                    (h >> 8) as u8,\n+                    h as u8\n+                )\n+                .unwrap();\n             }\n             _ => {\n                 fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) {\n@@ -1539,25 +1570,33 @@ impl fmt::Display for Ipv6Addr {\n                 let (zeros_at, zeros_len) = find_zero_slice(&self.segments());\n \n                 if zeros_len > 1 {\n-                    fn fmt_subslice(segments: &[u16], fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    fn fmt_subslice(segments: &[u16], buf: &mut &mut [u8]) {\n                         if !segments.is_empty() {\n-                            write!(fmt, \"{:x}\", segments[0])?;\n+                            write!(*buf, \"{:x}\", segments[0]).unwrap();\n                             for &seg in &segments[1..] {\n-                                write!(fmt, \":{:x}\", seg)?;\n+                                write!(*buf, \":{:x}\", seg).unwrap();\n                             }\n                         }\n-                        Ok(())\n                     }\n \n-                    fmt_subslice(&self.segments()[..zeros_at], fmt)?;\n-                    fmt.write_str(\"::\")?;\n-                    fmt_subslice(&self.segments()[zeros_at + zeros_len..], fmt)\n+                    fmt_subslice(&self.segments()[..zeros_at], &mut buf_slice);\n+                    write!(buf_slice, \"::\").unwrap();\n+                    fmt_subslice(&self.segments()[zeros_at + zeros_len..], &mut buf_slice);\n                 } else {\n                     let &[a, b, c, d, e, f, g, h] = &self.segments();\n-                    write!(fmt, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\", a, b, c, d, e, f, g, h)\n+                    write!(\n+                        buf_slice,\n+                        \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n+                        a, b, c, d, e, f, g, h\n+                    )\n+                    .unwrap();\n                 }\n             }\n         }\n+        let len = IPV6_BUF_LEN - buf_slice.len();\n+        // This is safe because we know exactly what can be in this buffer\n+        let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n+        fmt.pad(buf)\n     }\n }\n \n@@ -1896,6 +1935,18 @@ mod tests {\n         assert_eq!(None, none);\n     }\n \n+    #[test]\n+    fn ipv4_addr_to_string() {\n+        // Short address\n+        assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n+        // Long address\n+        assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n+\n+        // Test padding\n+        assert_eq!(&format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n+        assert_eq!(&format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n+    }\n+\n     #[test]\n     fn ipv6_addr_to_string() {\n         // ipv4-mapped address\n@@ -1909,6 +1960,22 @@ mod tests {\n         // v6 address with no zero segments\n         assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n \n+        // longest possible IPv6 length\n+        assert_eq!(\n+            Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888)\n+                .to_string(),\n+            \"1111:2222:3333:4444:5555:6666:7777:8888\"\n+        );\n+        // padding\n+        assert_eq!(\n+            &format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)),\n+            \"1:2:3:4:5:6:7:8     \"\n+        );\n+        assert_eq!(\n+            &format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)),\n+            \"     1:2:3:4:5:6:7:8\"\n+        );\n+\n         // reduce a single run of zeros\n         assert_eq!(\n             \"ae::ffff:102:304\","}]}