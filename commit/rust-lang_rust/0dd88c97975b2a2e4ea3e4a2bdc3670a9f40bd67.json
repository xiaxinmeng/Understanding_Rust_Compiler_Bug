{"sha": "0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZDg4Yzk3OTc1YjJhMmU0ZWEzZTRhMmJkYzM2NzBhOWY0MGJkNjc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-21T14:05:30Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-21T14:05:30Z"}, "message": "Rollup merge of #53329 - frewsxcv:frewsxcv-ptr-add-sub, r=RalfJung\n\nReplace usages of ptr::offset with ptr::{add,sub}.\n\nRust provides these helper methods \u2013 so let's use them!", "tree": {"sha": "0ad62b121fcafe2d11ee95819caf64e975d4ad00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ad62b121fcafe2d11ee95819caf64e975d4ad00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlt8HCsACgkQ/vbIBR0O\nATza+hAAxCfxVhCMCj8bSkjFjwJd3OoNRrKULGYboka6RqCdigXpf83zbuLJPpeY\nGuCpm2Zoj/z7TEvR5sR4QfARJKXdUyCjKf0FaQodYf1FPrmU4OsG0X32y6wrhBG5\nQw5P0w7pvIz1OHCgkt9gJ9SZJnnfhLRZAlrOA11wVa41xkdlxHjL7+qXbI7QqAkF\nYoG6vUTKNRP2D3wiUKy59rnxTCxmMSdkN5LxpV80JVkbGXLcTG7OnVPH9//dlinw\nb73Eq5GK5fKrBZwlJdRBUTbQY+lRVYiBosirtIyTj1ezOT56QQdx6hHHAEWumx0l\nKKCRu6yKgiHQ4A+rp6pK7kjLBuXn9cNljFqKAJfvAnN5qBw4FZjGcA/NxAFVMRIs\n7sPa48yLwUnUnbdm/AAYfIf4IpbIrbOdFV9nWYVrCNh/8tQ2TY7oei4c+5SGRynZ\nOcJ5cXDKTleA1bFlhaAro2h5I+PGCEVHPSZMi87iHAI3TbZvO5r+raLO75fMdxAY\n3wpD55FX6bsLS64ZiKj0KUYFMLj6+AzA69cBHI/cbOf2cH+JmYdmVRBHOlfDDS3T\npnZ3H0CJ/sIOIIh7/NdCr0vWovkl76SryLu5F8lb+clma5RwOatzIpuR+s8U/eDX\npOSpiz7DhMt5KBQx6ljZviI7J5jvGs8dbA2Wsum1Uq9QLrJjaNc=\n=lJK2\n-----END PGP SIGNATURE-----", "payload": "tree 0ad62b121fcafe2d11ee95819caf64e975d4ad00\nparent 9bbab65ebefbeb512445a759603b03f858e5e9b9\nparent 993fb934640b7e514f3c629c33a2698a83ed8c3e\nauthor kennytm <kennytm@gmail.com> 1534860330 +0800\ncommitter kennytm <kennytm@gmail.com> 1534860330 +0800\n\nRollup merge of #53329 - frewsxcv:frewsxcv-ptr-add-sub, r=RalfJung\n\nReplace usages of ptr::offset with ptr::{add,sub}.\n\nRust provides these helper methods \u2013 so let's use them!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "html_url": "https://github.com/rust-lang/rust/commit/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bbab65ebefbeb512445a759603b03f858e5e9b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bbab65ebefbeb512445a759603b03f858e5e9b9", "html_url": "https://github.com/rust-lang/rust/commit/9bbab65ebefbeb512445a759603b03f858e5e9b9"}, {"sha": "993fb934640b7e514f3c629c33a2698a83ed8c3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/993fb934640b7e514f3c629c33a2698a83ed8c3e", "html_url": "https://github.com/rust-lang/rust/commit/993fb934640b7e514f3c629c33a2698a83ed8c3e"}], "stats": {"total": 296, "additions": 148, "deletions": 148}, "files": [{"sha": "3bd0c243b39acfd3e6eca39abf5b51c08f52b0ff", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -245,7 +245,7 @@ mod tests {\n                 .unwrap_or_else(|_| handle_alloc_error(layout));\n \n             let mut i = ptr.cast::<u8>().as_ptr();\n-            let end = i.offset(layout.size() as isize);\n+            let end = i.add(layout.size());\n             while i < end {\n                 assert_eq!(*i, 0);\n                 i = i.offset(1);"}, {"sha": "32292e61f94d2f597568e600f8648dfba842bd16", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -706,7 +706,7 @@ impl<T: Clone> Clone for Box<[T]> {\n         impl<T> Drop for BoxBuilder<T> {\n             fn drop(&mut self) {\n                 let mut data = self.data.ptr();\n-                let max = unsafe { data.offset(self.len as isize) };\n+                let max = unsafe { data.add(self.len) };\n \n                 while data != max {\n                     unsafe {"}, {"sha": "0315545262b6bc0a295953f22b4328070223356b", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -1151,12 +1151,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n             let new_len = self.node.len() - self.idx - 1;\n \n             ptr::copy_nonoverlapping(\n-                self.node.keys().as_ptr().offset(self.idx as isize + 1),\n+                self.node.keys().as_ptr().add(self.idx + 1),\n                 new_node.keys.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.vals().as_ptr().offset(self.idx as isize + 1),\n+                self.node.vals().as_ptr().add(self.idx + 1),\n                 new_node.vals.as_mut_ptr(),\n                 new_len\n             );\n@@ -1209,17 +1209,17 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let new_len = self.node.len() - self.idx - 1;\n \n             ptr::copy_nonoverlapping(\n-                self.node.keys().as_ptr().offset(self.idx as isize + 1),\n+                self.node.keys().as_ptr().add(self.idx + 1),\n                 new_node.data.keys.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.vals().as_ptr().offset(self.idx as isize + 1),\n+                self.node.vals().as_ptr().add(self.idx + 1),\n                 new_node.data.vals.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.as_internal().edges.as_ptr().offset(self.idx as isize + 1),\n+                self.node.as_internal().edges.as_ptr().add(self.idx + 1),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1\n             );\n@@ -1283,14 +1283,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                        slice_remove(self.node.keys_mut(), self.idx));\n             ptr::copy_nonoverlapping(\n                 right_node.keys().as_ptr(),\n-                left_node.keys_mut().as_mut_ptr().offset(left_len as isize + 1),\n+                left_node.keys_mut().as_mut_ptr().add(left_len + 1),\n                 right_len\n             );\n             ptr::write(left_node.vals_mut().get_unchecked_mut(left_len),\n                        slice_remove(self.node.vals_mut(), self.idx));\n             ptr::copy_nonoverlapping(\n                 right_node.vals().as_ptr(),\n-                left_node.vals_mut().as_mut_ptr().offset(left_len as isize + 1),\n+                left_node.vals_mut().as_mut_ptr().add(left_len + 1),\n                 right_len\n             );\n \n@@ -1309,7 +1309,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                              .as_internal_mut()\n                              .edges\n                              .as_mut_ptr()\n-                             .offset(left_len as isize + 1),\n+                             .add(left_len + 1),\n                     right_len + 1\n                 );\n \n@@ -1394,10 +1394,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n                 // Make room for stolen elements in the right child.\n                 ptr::copy(right_kv.0,\n-                          right_kv.0.offset(count as isize),\n+                          right_kv.0.add(count),\n                           right_len);\n                 ptr::copy(right_kv.1,\n-                          right_kv.1.offset(count as isize),\n+                          right_kv.1.add(count),\n                           right_len);\n \n                 // Move elements from the left child to the right one.\n@@ -1418,7 +1418,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                     // Make room for stolen edges.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n                     ptr::copy(right_edges,\n-                              right_edges.offset(count as isize),\n+                              right_edges.add(count),\n                               right_len + 1);\n                     right.correct_childrens_parent_links(count, count + right_len + 1);\n \n@@ -1463,10 +1463,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 move_kv(right_kv, count - 1, parent_kv, 0, 1);\n \n                 // Fix right indexing\n-                ptr::copy(right_kv.0.offset(count as isize),\n+                ptr::copy(right_kv.0.add(count),\n                           right_kv.0,\n                           new_right_len);\n-                ptr::copy(right_kv.1.offset(count as isize),\n+                ptr::copy(right_kv.1.add(count),\n                           right_kv.1,\n                           new_right_len);\n             }\n@@ -1480,7 +1480,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n                     // Fix right indexing.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n-                    ptr::copy(right_edges.offset(count as isize),\n+                    ptr::copy(right_edges.add(count),\n                               right_edges,\n                               new_right_len + 1);\n                     right.correct_childrens_parent_links(0, new_right_len + 1);\n@@ -1497,11 +1497,11 @@ unsafe fn move_kv<K, V>(\n     dest: (*mut K, *mut V), dest_offset: usize,\n     count: usize)\n {\n-    ptr::copy_nonoverlapping(source.0.offset(source_offset as isize),\n-                             dest.0.offset(dest_offset as isize),\n+    ptr::copy_nonoverlapping(source.0.add(source_offset),\n+                             dest.0.add(dest_offset),\n                              count);\n-    ptr::copy_nonoverlapping(source.1.offset(source_offset as isize),\n-                             dest.1.offset(dest_offset as isize),\n+    ptr::copy_nonoverlapping(source.1.add(source_offset),\n+                             dest.1.add(dest_offset),\n                              count);\n }\n \n@@ -1513,8 +1513,8 @@ unsafe fn move_edges<K, V>(\n {\n     let source_ptr = source.as_internal_mut().edges.as_mut_ptr();\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n-    ptr::copy_nonoverlapping(source_ptr.offset(source_offset as isize),\n-                             dest_ptr.offset(dest_offset as isize),\n+    ptr::copy_nonoverlapping(source_ptr.add(source_offset),\n+                             dest_ptr.add(dest_offset),\n                              count);\n     dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n }\n@@ -1604,8 +1604,8 @@ pub mod marker {\n \n unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n     ptr::copy(\n-        slice.as_ptr().offset(idx as isize),\n-        slice.as_mut_ptr().offset(idx as isize + 1),\n+        slice.as_ptr().add(idx),\n+        slice.as_mut_ptr().add(idx + 1),\n         slice.len() - idx\n     );\n     ptr::write(slice.get_unchecked_mut(idx), val);\n@@ -1614,8 +1614,8 @@ unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n     let ret = ptr::read(slice.get_unchecked(idx));\n     ptr::copy(\n-        slice.as_ptr().offset(idx as isize + 1),\n-        slice.as_mut_ptr().offset(idx as isize),\n+        slice.as_ptr().add(idx + 1),\n+        slice.as_mut_ptr().add(idx),\n         slice.len() - idx - 1\n     );\n     ret"}, {"sha": "55c8a78f8d046e502979d8370bcb1d21207ef1c8", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -126,13 +126,13 @@ impl<T> VecDeque<T> {\n     /// Moves an element out of the buffer\n     #[inline]\n     unsafe fn buffer_read(&mut self, off: usize) -> T {\n-        ptr::read(self.ptr().offset(off as isize))\n+        ptr::read(self.ptr().add(off))\n     }\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n     unsafe fn buffer_write(&mut self, off: usize, value: T) {\n-        ptr::write(self.ptr().offset(off as isize), value);\n+        ptr::write(self.ptr().add(off), value);\n     }\n \n     /// Returns `true` if and only if the buffer is at full capacity.\n@@ -177,8 +177,8 @@ impl<T> VecDeque<T> {\n                       src,\n                       len,\n                       self.cap());\n-        ptr::copy(self.ptr().offset(src as isize),\n-                  self.ptr().offset(dst as isize),\n+        ptr::copy(self.ptr().add(src),\n+                  self.ptr().add(dst),\n                   len);\n     }\n \n@@ -197,8 +197,8 @@ impl<T> VecDeque<T> {\n                       src,\n                       len,\n                       self.cap());\n-        ptr::copy_nonoverlapping(self.ptr().offset(src as isize),\n-                                 self.ptr().offset(dst as isize),\n+        ptr::copy_nonoverlapping(self.ptr().add(src),\n+                                 self.ptr().add(dst),\n                                  len);\n     }\n \n@@ -436,7 +436,7 @@ impl<T> VecDeque<T> {\n     pub fn get(&self, index: usize) -> Option<&T> {\n         if index < self.len() {\n             let idx = self.wrap_add(self.tail, index);\n-            unsafe { Some(&*self.ptr().offset(idx as isize)) }\n+            unsafe { Some(&*self.ptr().add(idx)) }\n         } else {\n             None\n         }\n@@ -465,7 +465,7 @@ impl<T> VecDeque<T> {\n     pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n         if index < self.len() {\n             let idx = self.wrap_add(self.tail, index);\n-            unsafe { Some(&mut *self.ptr().offset(idx as isize)) }\n+            unsafe { Some(&mut *self.ptr().add(idx)) }\n         } else {\n             None\n         }\n@@ -501,8 +501,8 @@ impl<T> VecDeque<T> {\n         let ri = self.wrap_add(self.tail, i);\n         let rj = self.wrap_add(self.tail, j);\n         unsafe {\n-            ptr::swap(self.ptr().offset(ri as isize),\n-                      self.ptr().offset(rj as isize))\n+            ptr::swap(self.ptr().add(ri),\n+                      self.ptr().add(rj))\n         }\n     }\n \n@@ -1805,20 +1805,20 @@ impl<T> VecDeque<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping(first_half.as_ptr().offset(at as isize),\n+                ptr::copy_nonoverlapping(first_half.as_ptr().add(at),\n                                          other.ptr(),\n                                          amount_in_first);\n \n                 // just take all of the second half.\n                 ptr::copy_nonoverlapping(second_half.as_ptr(),\n-                                         other.ptr().offset(amount_in_first as isize),\n+                                         other.ptr().add(amount_in_first),\n                                          second_len);\n             } else {\n                 // `at` lies in the second half, need to factor in the elements we skipped\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping(second_half.as_ptr().offset(offset as isize),\n+                ptr::copy_nonoverlapping(second_half.as_ptr().add(offset),\n                                          other.ptr(),\n                                          amount_in_second);\n             }\n@@ -2709,24 +2709,24 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n \n             // Need to move the ring to the front of the buffer, as vec will expect this.\n             if other.is_contiguous() {\n-                ptr::copy(buf.offset(tail as isize), buf, len);\n+                ptr::copy(buf.add(tail), buf, len);\n             } else {\n                 if (tail - head) >= cmp::min(cap - tail, head) {\n                     // There is enough free space in the centre for the shortest block so we can\n                     // do this in at most three copy moves.\n                     if (cap - tail) > head {\n                         // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.offset(tail as isize),\n-                                  buf.offset((tail - head) as isize),\n+                        ptr::copy(buf.add(tail),\n+                                  buf.add(tail - head),\n                                   cap - tail);\n                         // copy left in the end\n-                        ptr::copy(buf, buf.offset((cap - head) as isize), head);\n+                        ptr::copy(buf, buf.add(cap - head), head);\n                         // shift the new thing to the start\n-                        ptr::copy(buf.offset((tail - head) as isize), buf, len);\n+                        ptr::copy(buf.add(tail - head), buf, len);\n                     } else {\n                         // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.offset((cap - tail) as isize), head);\n-                        ptr::copy(buf.offset(tail as isize), buf, cap - tail);\n+                        ptr::copy(buf, buf.add(cap - tail), head);\n+                        ptr::copy(buf.add(tail), buf, cap - tail);\n                     }\n                 } else {\n                     // Need to use N swaps to move the ring\n@@ -2751,7 +2751,7 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n                         for i in left_edge..right_edge {\n                             right_offset = (i - left_edge) % (cap - right_edge);\n                             let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.offset(i as isize), buf.offset(src));\n+                            ptr::swap(buf.add(i), buf.offset(src));\n                         }\n                         let n_ops = right_edge - left_edge;\n                         left_edge += n_ops;"}, {"sha": "837770feecef596d7380dd009f6802a904877f32", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -282,7 +282,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///         // double would have aborted or panicked if the len exceeded\n     ///         // `isize::MAX` so this is safe to do unchecked now.\n     ///         unsafe {\n-    ///             ptr::write(self.buf.ptr().offset(self.len as isize), elem);\n+    ///             ptr::write(self.buf.ptr().add(self.len), elem);\n     ///         }\n     ///         self.len += 1;\n     ///     }\n@@ -487,7 +487,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///         // `isize::MAX` so this is safe to do unchecked now.\n     ///         for x in elems {\n     ///             unsafe {\n-    ///                 ptr::write(self.buf.ptr().offset(self.len as isize), x.clone());\n+    ///                 ptr::write(self.buf.ptr().add(self.len), x.clone());\n     ///             }\n     ///             self.len += 1;\n     ///         }"}, {"sha": "b8f1d51db464f55276d541ec314ca0c28032b199", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -771,7 +771,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             };\n \n             for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.offset(i as isize), item.clone());\n+                ptr::write(elems.add(i), item.clone());\n                 guard.n_elems += 1;\n             }\n "}, {"sha": "9d442b3e00ca074ea7b6d1584272923bc8b922ef", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -715,8 +715,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n-    let v_mid = v.offset(mid as isize);\n-    let v_end = v.offset(len as isize);\n+    let v_mid = v.add(mid);\n+    let v_end = v.add(len);\n \n     // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n     // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n@@ -742,7 +742,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n         ptr::copy_nonoverlapping(v, buf, mid);\n         hole = MergeHole {\n             start: buf,\n-            end: buf.offset(mid as isize),\n+            end: buf.add(mid),\n             dest: v,\n         };\n \n@@ -766,7 +766,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n         ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n         hole = MergeHole {\n             start: buf,\n-            end: buf.offset((len - mid) as isize),\n+            end: buf.add(len - mid),\n             dest: v_mid,\n         };\n "}, {"sha": "eabda7123dec0c396dfe5773806285e87ab1feff", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -1190,8 +1190,8 @@ impl String {\n         let next = idx + ch.len_utf8();\n         let len = self.len();\n         unsafe {\n-            ptr::copy(self.vec.as_ptr().offset(next as isize),\n-                      self.vec.as_mut_ptr().offset(idx as isize),\n+            ptr::copy(self.vec.as_ptr().add(next),\n+                      self.vec.as_mut_ptr().add(idx),\n                       len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n@@ -1232,8 +1232,8 @@ impl String {\n                 del_bytes += ch_len;\n             } else if del_bytes > 0 {\n                 unsafe {\n-                    ptr::copy(self.vec.as_ptr().offset(idx as isize),\n-                              self.vec.as_mut_ptr().offset((idx - del_bytes) as isize),\n+                    ptr::copy(self.vec.as_ptr().add(idx),\n+                              self.vec.as_mut_ptr().add(idx - del_bytes),\n                               ch_len);\n                 }\n             }\n@@ -1289,11 +1289,11 @@ impl String {\n         let amt = bytes.len();\n         self.vec.reserve(amt);\n \n-        ptr::copy(self.vec.as_ptr().offset(idx as isize),\n-                  self.vec.as_mut_ptr().offset((idx + amt) as isize),\n+        ptr::copy(self.vec.as_ptr().add(idx),\n+                  self.vec.as_mut_ptr().add(idx + amt),\n                   len - idx);\n         ptr::copy(bytes.as_ptr(),\n-                  self.vec.as_mut_ptr().offset(idx as isize),\n+                  self.vec.as_mut_ptr().add(idx),\n                   amt);\n         self.vec.set_len(len + amt);\n     }"}, {"sha": "2cd7898f4c78134678cfee3e4750ecc3f10a6d89", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -672,7 +672,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n             };\n \n             for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.offset(i as isize), item.clone());\n+                ptr::write(elems.add(i), item.clone());\n                 guard.n_elems += 1;\n             }\n "}, {"sha": "e9c1a3df518913cb709004445ee46e740dda94ac", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -692,7 +692,7 @@ impl<T> Vec<T> {\n     pub fn truncate(&mut self, len: usize) {\n         let current_len = self.len;\n         unsafe {\n-            let mut ptr = self.as_mut_ptr().offset(self.len as isize);\n+            let mut ptr = self.as_mut_ptr().add(self.len);\n             // Set the final length at the end, keeping in mind that\n             // dropping an element might panic. Works around a missed\n             // optimization, as seen in the following issue:\n@@ -856,7 +856,7 @@ impl<T> Vec<T> {\n             // infallible\n             // The spot to put the new value\n             {\n-                let p = self.as_mut_ptr().offset(index as isize);\n+                let p = self.as_mut_ptr().add(index);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n                 ptr::copy(p, p.offset(1), len - index);\n@@ -891,7 +891,7 @@ impl<T> Vec<T> {\n             let ret;\n             {\n                 // the place we are taking from.\n-                let ptr = self.as_mut_ptr().offset(index as isize);\n+                let ptr = self.as_mut_ptr().add(index);\n                 // copy it out, unsafely having a copy of the value on\n                 // the stack and in the vector at the same time.\n                 ret = ptr::read(ptr);\n@@ -1034,8 +1034,8 @@ impl<T> Vec<T> {\n             let mut w: usize = 1;\n \n             while r < ln {\n-                let p_r = p.offset(r as isize);\n-                let p_wm1 = p.offset((w - 1) as isize);\n+                let p_r = p.add(r);\n+                let p_wm1 = p.add(w - 1);\n                 if !same_bucket(&mut *p_r, &mut *p_wm1) {\n                     if r != w {\n                         let p_w = p_wm1.offset(1);\n@@ -1072,7 +1072,7 @@ impl<T> Vec<T> {\n             self.reserve(1);\n         }\n         unsafe {\n-            let end = self.as_mut_ptr().offset(self.len as isize);\n+            let end = self.as_mut_ptr().add(self.len);\n             ptr::write(end, value);\n             self.len += 1;\n         }\n@@ -1196,7 +1196,7 @@ impl<T> Vec<T> {\n             self.set_len(start);\n             // Use the borrow in the IterMut to indicate borrowing behavior of the\n             // whole Drain iterator (like &mut T).\n-            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().offset(start as isize),\n+            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(start),\n                                                         end - start);\n             Drain {\n                 tail_start: end,\n@@ -1290,7 +1290,7 @@ impl<T> Vec<T> {\n             self.set_len(at);\n             other.set_len(other_len);\n \n-            ptr::copy_nonoverlapping(self.as_ptr().offset(at as isize),\n+            ptr::copy_nonoverlapping(self.as_ptr().add(at),\n                                      other.as_mut_ptr(),\n                                      other.len());\n         }\n@@ -1473,7 +1473,7 @@ impl<T> Vec<T> {\n         self.reserve(n);\n \n         unsafe {\n-            let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n+            let mut ptr = self.as_mut_ptr().add(self.len());\n             // Use SetLenOnDrop to work around bug where compiler\n             // may not realize the store through `ptr` through self.set_len()\n             // don't alias.\n@@ -1799,7 +1799,7 @@ impl<T> IntoIterator for Vec<T> {\n             let end = if mem::size_of::<T>() == 0 {\n                 arith_offset(begin as *const i8, self.len() as isize) as *const T\n             } else {\n-                begin.offset(self.len() as isize) as *const T\n+                begin.add(self.len()) as *const T\n             };\n             let cap = self.buf.cap();\n             mem::forget(self);\n@@ -1898,7 +1898,7 @@ impl<T, I> SpecExtend<T, I> for Vec<T>\n         if let Some(additional) = high {\n             self.reserve(additional);\n             unsafe {\n-                let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n+                let mut ptr = self.as_mut_ptr().add(self.len());\n                 let mut local_len = SetLenOnDrop::new(&mut self.len);\n                 for element in iterator {\n                     ptr::write(ptr, element);\n@@ -2561,8 +2561,8 @@ impl<'a, T> Drop for Drain<'a, T> {\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n                 if tail != start {\n-                    let src = source_vec.as_ptr().offset(tail as isize);\n-                    let dst = source_vec.as_mut_ptr().offset(start as isize);\n+                    let src = source_vec.as_ptr().add(tail);\n+                    let dst = source_vec.as_mut_ptr().add(start);\n                     ptr::copy(src, dst, self.tail_len);\n                 }\n                 source_vec.set_len(start + self.tail_len);\n@@ -2672,7 +2672,7 @@ impl<'a, T> Drain<'a, T> {\n         let range_start = vec.len;\n         let range_end = self.tail_start;\n         let range_slice = slice::from_raw_parts_mut(\n-            vec.as_mut_ptr().offset(range_start as isize),\n+            vec.as_mut_ptr().add(range_start),\n             range_end - range_start);\n \n         for place in range_slice {\n@@ -2693,8 +2693,8 @@ impl<'a, T> Drain<'a, T> {\n         vec.buf.reserve(used_capacity, extra_capacity);\n \n         let new_tail_start = self.tail_start + extra_capacity;\n-        let src = vec.as_ptr().offset(self.tail_start as isize);\n-        let dst = vec.as_mut_ptr().offset(new_tail_start as isize);\n+        let src = vec.as_ptr().add(self.tail_start);\n+        let dst = vec.as_mut_ptr().add(new_tail_start);\n         ptr::copy(src, dst, self.tail_len);\n         self.tail_start = new_tail_start;\n     }"}, {"sha": "753b6a5e29248bac365e4d5d3eaeafd7e11fb5e4", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -249,7 +249,7 @@ mod platform {\n     }\n \n     unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n-        let aligned = ptr.offset((align - (ptr as usize & (align - 1))) as isize);\n+        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n         *get_header(aligned) = Header(ptr);\n         aligned\n     }"}, {"sha": "6ad703180c224eecd7e6777c5beb18c17ea8fe5f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -106,7 +106,7 @@ impl<T> TypedArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 !0 as *mut T\n             } else {\n-                self.start().offset(self.storage.cap() as isize)\n+                self.start().add(self.storage.cap())\n             }\n         }\n     }\n@@ -179,7 +179,7 @@ impl<T> TypedArena<T> {\n         unsafe {\n             let start_ptr = self.ptr.get();\n             let arena_slice = slice::from_raw_parts_mut(start_ptr, slice.len());\n-            self.ptr.set(start_ptr.offset(arena_slice.len() as isize));\n+            self.ptr.set(start_ptr.add(arena_slice.len()));\n             arena_slice.copy_from_slice(slice);\n             arena_slice\n         }"}, {"sha": "7756a6f71dbd60a2cf68731a750b4d676646ae60", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -918,7 +918,7 @@ extern \"rust-intrinsic\" {\n     ///         // treat it as \"dead\", and therefore, you only have two real\n     ///         // mutable slices.\n     ///         (slice::from_raw_parts_mut(ptr, mid),\n-    ///          slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+    ///          slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n     ///     }\n     /// }\n     /// ```"}, {"sha": "b1dc84bb84cb8f1c8fee985546aae535b09fbc0f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -511,7 +511,7 @@ macro_rules! impls{\n ///     let ptr = vec.as_ptr();\n ///     Slice {\n ///         start: ptr,\n-///         end: unsafe { ptr.offset(vec.len() as isize) },\n+///         end: unsafe { ptr.add(vec.len()) },\n ///         phantom: PhantomData,\n ///     }\n /// }"}, {"sha": "ebdddde7de3717f656b7831f7f7e0040df808d5d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -226,8 +226,8 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         // Declaring `t` here avoids aligning the stack when this loop is unused\n         let mut t: Block = mem::uninitialized();\n         let t = &mut t as *mut _ as *mut u8;\n-        let x = x.offset(i as isize);\n-        let y = y.offset(i as isize);\n+        let x = x.add(i);\n+        let y = y.add(i);\n \n         // Swap a block of bytes of x & y, using t as a temporary buffer\n         // This should be optimized into efficient SIMD operations where available\n@@ -243,8 +243,8 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         let rem = len - i;\n \n         let t = &mut t as *mut _ as *mut u8;\n-        let x = x.offset(i as isize);\n-        let y = y.offset(i as isize);\n+        let x = x.add(i);\n+        let y = y.add(i);\n \n         copy_nonoverlapping(x, t, rem);\n         copy_nonoverlapping(y, x, rem);\n@@ -613,7 +613,7 @@ impl<T: ?Sized> *const T {\n     /// The compiler and standard library generally tries to ensure allocations\n     /// never reach a size where an offset is a concern. For instance, `Vec`\n     /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().offset(vec.len() as isize)` is always safe.\n+    /// `vec.as_ptr().add(vec.len())` is always safe.\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n@@ -1231,7 +1231,7 @@ impl<T: ?Sized> *const T {\n     /// let ptr = &x[n] as *const u8;\n     /// let offset = ptr.align_offset(align_of::<u16>());\n     /// if offset < x.len() - n - 1 {\n-    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n+    ///     let u16_ptr = ptr.add(offset) as *const u16;\n     ///     assert_ne!(*u16_ptr, 500);\n     /// } else {\n     ///     // while the pointer can be aligned via `offset`, it would point\n@@ -1334,7 +1334,7 @@ impl<T: ?Sized> *mut T {\n     /// The compiler and standard library generally tries to ensure allocations\n     /// never reach a size where an offset is a concern. For instance, `Vec`\n     /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().offset(vec.len() as isize)` is always safe.\n+    /// `vec.as_ptr().add(vec.len())` is always safe.\n     ///\n     /// Most platforms fundamentally can't even construct such an allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n@@ -2261,7 +2261,7 @@ impl<T: ?Sized> *mut T {\n     /// let ptr = &x[n] as *const u8;\n     /// let offset = ptr.align_offset(align_of::<u16>());\n     /// if offset < x.len() - n - 1 {\n-    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n+    ///     let u16_ptr = ptr.add(offset) as *const u16;\n     ///     assert_ne!(*u16_ptr, 500);\n     /// } else {\n     ///     // while the pointer can be aligned via `offset`, it would point"}, {"sha": "cf95333af9cbb1622a69244f25d4dba61b269b01", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -72,8 +72,8 @@ pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n     if len >= 2 * usize_bytes {\n         while offset <= len - 2 * usize_bytes {\n             unsafe {\n-                let u = *(ptr.offset(offset as isize) as *const usize);\n-                let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n+                let u = *(ptr.add(offset) as *const usize);\n+                let v = *(ptr.add(offset + usize_bytes) as *const usize);\n \n                 // break if there is a matching byte\n                 let zu = contains_zero_byte(u ^ repeated_x);"}, {"sha": "3366c4a3e661c4a825bb0af9b03969ba907ab58c", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -383,7 +383,7 @@ impl<T> [T] {\n     ///\n     /// unsafe {\n     ///     for i in 0..x.len() {\n-    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n+    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     ///     }\n     /// }\n     /// ```\n@@ -410,7 +410,7 @@ impl<T> [T] {\n     ///\n     /// unsafe {\n     ///     for i in 0..x.len() {\n-    ///         *x_ptr.offset(i as isize) += 2;\n+    ///         *x_ptr.add(i) += 2;\n     ///     }\n     /// }\n     /// assert_eq!(x, &[3, 4, 6]);\n@@ -546,9 +546,9 @@ impl<T> [T] {\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as *const u8).wrapping_offset(self.len() as isize) as *const T\n+                (ptr as *const u8).wrapping_add(self.len()) as *const T\n             } else {\n-                ptr.offset(self.len() as isize)\n+                ptr.add(self.len())\n             };\n \n             Iter {\n@@ -578,9 +578,9 @@ impl<T> [T] {\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as *mut u8).wrapping_offset(self.len() as isize) as *mut T\n+                (ptr as *mut u8).wrapping_add(self.len()) as *mut T\n             } else {\n-                ptr.offset(self.len() as isize)\n+                ptr.add(self.len())\n             };\n \n             IterMut {\n@@ -842,7 +842,7 @@ impl<T> [T] {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, mid),\n-             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+             from_raw_parts_mut(ptr.add(mid), len - mid))\n         }\n     }\n \n@@ -1444,7 +1444,7 @@ impl<T> [T] {\n \n         unsafe {\n             let p = self.as_mut_ptr();\n-            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n+            rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n \n@@ -1485,7 +1485,7 @@ impl<T> [T] {\n \n         unsafe {\n             let p = self.as_mut_ptr();\n-            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n+            rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n \n@@ -1789,7 +1789,7 @@ impl<T> [T] {\n             let (us_len, ts_len) = rest.align_to_offsets::<U>();\n             (left,\n              from_raw_parts(rest.as_ptr() as *const U, us_len),\n-             from_raw_parts(rest.as_ptr().offset((rest.len() - ts_len) as isize), ts_len))\n+             from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len))\n         }\n     }\n \n@@ -1843,7 +1843,7 @@ impl<T> [T] {\n             let mut_ptr = rest.as_mut_ptr();\n             (left,\n              from_raw_parts_mut(mut_ptr as *mut U, us_len),\n-             from_raw_parts_mut(mut_ptr.offset((rest.len() - ts_len) as isize), ts_len))\n+             from_raw_parts_mut(mut_ptr.add(rest.len() - ts_len), ts_len))\n         }\n     }\n }\n@@ -2037,12 +2037,12 @@ impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n-        &*slice.as_ptr().offset(self as isize)\n+        &*slice.as_ptr().add(self)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n-        &mut *slice.as_mut_ptr().offset(self as isize)\n+        &mut *slice.as_mut_ptr().add(self)\n     }\n \n     #[inline]\n@@ -2086,12 +2086,12 @@ impl<T> SliceIndex<[T]> for  ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        from_raw_parts(slice.as_ptr().offset(self.start as isize), self.end - self.start)\n+        from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        from_raw_parts_mut(slice.as_mut_ptr().offset(self.start as isize), self.end - self.start)\n+        from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n     }\n \n     #[inline]\n@@ -2467,7 +2467,7 @@ macro_rules! iterator {\n                 }\n                 // We are in bounds. `offset` does the right thing even for ZSTs.\n                 unsafe {\n-                    let elem = Some(& $( $mut_ )* *self.ptr.offset(n as isize));\n+                    let elem = Some(& $( $mut_ )* *self.ptr.add(n));\n                     self.post_inc_start((n as isize).wrapping_add(1));\n                     elem\n                 }\n@@ -3347,7 +3347,7 @@ impl<'a, T> FusedIterator for Windows<'a, T> {}\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        from_raw_parts(self.v.as_ptr().offset(i as isize), self.size)\n+        from_raw_parts(self.v.as_ptr().add(i), self.size)\n     }\n     fn may_have_side_effect() -> bool { false }\n }\n@@ -3474,7 +3474,7 @@ unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts(self.v.as_ptr().offset(start as isize), end - start)\n+        from_raw_parts(self.v.as_ptr().add(start), end - start)\n     }\n     fn may_have_side_effect() -> bool { false }\n }\n@@ -3593,7 +3593,7 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts_mut(self.v.as_mut_ptr().offset(start as isize), end - start)\n+        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n     }\n     fn may_have_side_effect() -> bool { false }\n }\n@@ -3716,7 +3716,7 @@ impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts(self.v.as_ptr().offset(start as isize), self.chunk_size)\n+        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n     }\n     fn may_have_side_effect() -> bool { false }\n }\n@@ -3831,7 +3831,7 @@ impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts_mut(self.v.as_mut_ptr().offset(start as isize), self.chunk_size)\n+        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n     }\n     fn may_have_side_effect() -> bool { false }\n }\n@@ -4116,15 +4116,15 @@ impl_marker_for!(BytewiseEquality,\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n-        &*self.ptr.offset(i as isize)\n+        &*self.ptr.add(i)\n     }\n     fn may_have_side_effect() -> bool { false }\n }\n \n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n-        &mut *self.ptr.offset(i as isize)\n+        &mut *self.ptr.add(i)\n     }\n     fn may_have_side_effect() -> bool { false }\n }"}, {"sha": "0d182b8497452e2bf7db6d6417b4b6e2092d3b34", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -77,8 +77,8 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n         }\n \n         ptr::swap_nonoverlapping(\n-            mid.offset(-(left as isize)),\n-            mid.offset((right-delta) as isize),\n+            mid.sub(left),\n+            mid.add(right - delta),\n             delta);\n \n         if left <= right {\n@@ -91,15 +91,15 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n     let rawarray = RawArray::new();\n     let buf = rawarray.ptr();\n \n-    let dim = mid.offset(-(left as isize)).offset(right as isize);\n+    let dim = mid.sub(left).add(right);\n     if left <= right {\n-        ptr::copy_nonoverlapping(mid.offset(-(left as isize)), buf, left);\n-        ptr::copy(mid, mid.offset(-(left as isize)), right);\n+        ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n+        ptr::copy(mid, mid.sub(left), right);\n         ptr::copy_nonoverlapping(buf, dim, left);\n     }\n     else {\n         ptr::copy_nonoverlapping(mid, buf, right);\n-        ptr::copy(mid.offset(-(left as isize)), dim, left);\n-        ptr::copy_nonoverlapping(buf, mid.offset(-(left as isize)), right);\n+        ptr::copy(mid.sub(left), dim, left);\n+        ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n     }\n }"}, {"sha": "e4c1fd03f9eb384b1197e5a6d3b82ed14f85d349", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -221,15 +221,15 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n     // 3. `end` - End pointer into the `offsets` array.\n     // 4. `offsets - Indices of out-of-order elements within the block.\n \n-    // The current block on the left side (from `l` to `l.offset(block_l)`).\n+    // The current block on the left side (from `l` to `l.add(block_l)`).\n     let mut l = v.as_mut_ptr();\n     let mut block_l = BLOCK;\n     let mut start_l = ptr::null_mut();\n     let mut end_l = ptr::null_mut();\n     let mut offsets_l: [u8; BLOCK] = unsafe { mem::uninitialized() };\n \n-    // The current block on the right side (from `r.offset(-block_r)` to `r`).\n-    let mut r = unsafe { l.offset(v.len() as isize) };\n+    // The current block on the right side (from `r.sub(block_r)` to `r`).\n+    let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();\n     let mut end_r = ptr::null_mut();"}, {"sha": "64bdf4d9f486ad84d1d6d6dbdd72ad1ddaa3fe9f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -1518,12 +1518,12 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             let ptr = v.as_ptr();\n             let align = unsafe {\n                 // the offset is safe, because `index` is guaranteed inbounds\n-                ptr.offset(index as isize).align_offset(usize_bytes)\n+                ptr.add(index).align_offset(usize_bytes)\n             };\n             if align == 0 {\n                 while index < blocks_end {\n                     unsafe {\n-                        let block = ptr.offset(index as isize) as *const usize;\n+                        let block = ptr.add(index) as *const usize;\n                         // break if there is a nonascii byte\n                         let zu = contains_nonascii(*block);\n                         let zv = contains_nonascii(*block.offset(1));\n@@ -1878,13 +1878,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let ptr = slice.as_ptr().add(self.start);\n             let len = self.end - self.start;\n             super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let ptr = slice.as_ptr().add(self.start);\n             let len = self.end - self.start;\n             super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, len))\n         }\n@@ -1973,13 +1973,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let ptr = slice.as_ptr().add(self.start);\n             let len = slice.len() - self.start;\n             super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let ptr = slice.as_ptr().add(self.start);\n             let len = slice.len() - self.start;\n             super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, len))\n         }\n@@ -2573,7 +2573,7 @@ impl str {\n             unsafe {\n                 (from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, mid)),\n                  from_utf8_unchecked_mut(slice::from_raw_parts_mut(\n-                    ptr.offset(mid as isize),\n+                    ptr.add(mid),\n                     len - mid\n                  )))\n             }"}, {"sha": "7e0c32fe03d8a57a43f5d7b17e8264e646fdbc88", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -38,7 +38,7 @@ impl DwarfReader {\n     // telling the backend to generate \"misalignment-safe\" code.\n     pub unsafe fn read<T: Copy>(&mut self) -> T {\n         let Unaligned(result) = *(self.ptr as *const Unaligned<T>);\n-        self.ptr = self.ptr.offset(mem::size_of::<T>() as isize);\n+        self.ptr = self.ptr.add(mem::size_of::<T>());\n         result\n     }\n "}, {"sha": "45fb56570618093f556f85134daa61a450e0da69", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -139,7 +139,7 @@ impl<A: Array> ArrayVec<A> {\n             // whole Drain iterator (like &mut T).\n             let range_slice = {\n                 let arr = &mut self.values as &mut [ManuallyDrop<<A as Array>::Element>];\n-                slice::from_raw_parts_mut(arr.as_mut_ptr().offset(start as isize),\n+                slice::from_raw_parts_mut(arr.as_mut_ptr().add(start),\n                                           end - start)\n             };\n             Drain {\n@@ -262,8 +262,8 @@ impl<'a, A: Array> Drop for Drain<'a, A> {\n                 {\n                     let arr =\n                         &mut source_array_vec.values as &mut [ManuallyDrop<<A as Array>::Element>];\n-                    let src = arr.as_ptr().offset(tail as isize);\n-                    let dst = arr.as_mut_ptr().offset(start as isize);\n+                    let src = arr.as_ptr().add(tail);\n+                    let dst = arr.as_mut_ptr().add(start);\n                     ptr::copy(src, dst, self.tail_len);\n                 };\n                 source_array_vec.set_len(start + self.tail_len);"}, {"sha": "689aad25b431d78566f635b96821e5bb4959bdf8", "filename": "src/librustc_data_structures/small_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -125,7 +125,7 @@ impl<A: Array> SmallVec<A> {\n             // infallible\n             // The spot to put the new value\n             {\n-                let p = self.as_mut_ptr().offset(index as isize);\n+                let p = self.as_mut_ptr().add(index);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n                 ptr::copy(p, p.offset(1), len - index);"}, {"sha": "768357ec8dc417e7ea1fedfa4e522dbc2a480009", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -234,10 +234,10 @@ fn can_alias_safehash_as_hash() {\n // make a RawBucket point to invalid memory using safe code.\n impl<K, V> RawBucket<K, V> {\n     unsafe fn hash(&self) -> *mut HashUint {\n-        self.hash_start.offset(self.idx as isize)\n+        self.hash_start.add(self.idx)\n     }\n     unsafe fn pair(&self) -> *mut (K, V) {\n-        self.pair_start.offset(self.idx as isize) as *mut (K, V)\n+        self.pair_start.add(self.idx) as *mut (K, V)\n     }\n     unsafe fn hash_pair(&self) -> (*mut HashUint, *mut (K, V)) {\n         (self.hash(), self.pair())"}, {"sha": "4b19519a57a876cc94ed430e640e89544833aa46", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -359,6 +359,6 @@ unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n     if v.capacity() == v.len() {\n         v.reserve(1);\n     }\n-    slice::from_raw_parts_mut(v.as_mut_ptr().offset(v.len() as isize),\n+    slice::from_raw_parts_mut(v.as_mut_ptr().add(v.len()),\n                               v.capacity() - v.len())\n }"}, {"sha": "8725abe741679a50da912a28021ba9be6800986d", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -772,7 +772,7 @@ pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {\n pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 {\n     // memory layout of an &[u8] and &Wtf8 are the same\n     Wtf8::from_bytes_unchecked(slice::from_raw_parts(\n-        s.bytes.as_ptr().offset(begin as isize),\n+        s.bytes.as_ptr().add(begin),\n         end - begin\n     ))\n }"}, {"sha": "220482f57eb01052b9f991574cdbdb8bfd9e72b7", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -27,7 +27,7 @@ impl<'a> MyWriter for &'a mut [u8] {\n         let write_len = buf.len();\n         unsafe {\n             *self = slice::from_raw_parts_mut(\n-                self.as_mut_ptr().offset(write_len as isize),\n+                self.as_mut_ptr().add(write_len),\n                 self.len() - write_len\n             );\n         }"}, {"sha": "c4cae1e1d611d6bfa2f132241cf26db3b928bc34", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -37,8 +37,8 @@ unsafe fn test_triangle() -> bool {\n         for i in 0..COUNT / 2 {\n             let (p0, p1, size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             for j in 0..size {\n-                assert_eq!(*p0.offset(j as isize), i as u8);\n-                assert_eq!(*p1.offset(j as isize), i as u8);\n+                assert_eq!(*p0.add(j), i as u8);\n+                assert_eq!(*p1.add(j), i as u8);\n             }\n         }\n     }\n@@ -100,8 +100,8 @@ unsafe fn test_triangle() -> bool {\n     for i in 0..COUNT / 2 {\n         let (p0, p1, size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n         for j in 0..size {\n-            *p0.offset(j as isize) = i as u8;\n-            *p1.offset(j as isize) = i as u8;\n+            *p0.add(j) = i as u8;\n+            *p1.add(j) = i as u8;\n         }\n     }\n "}, {"sha": "d349519478ae403891a6308cdda9d7fa95e67fb6", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=0dd88c97975b2a2e4ea3e4a2bdc3670a9f40bd67", "patch": "@@ -36,7 +36,7 @@ fn start(argc: isize, argv: *const *const u8) -> isize {\n \n     let args = unsafe {\n         (0..argc as usize).map(|i| {\n-            let ptr = *argv.offset(i as isize) as *const _;\n+            let ptr = *argv.add(i) as *const _;\n             CStr::from_ptr(ptr).to_bytes().to_vec()\n         }).collect::<Vec<_>>()\n     };"}]}