{"sha": "92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYjllNWVmM2MwM2Q1MTcxM2ZmNWZhMzJjZDU4YmRmOTc3MDFiNWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-30T19:37:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-30T19:37:29Z"}, "message": "Merge #9068\n\n9068: Move more `CompletinoContext` fields to `ImmediateLocation` r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "8e9cd674d600cfff5d9523c7a017456742ba444c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e9cd674d600cfff5d9523c7a017456742ba444c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgs+l5CRBK7hj4Ov3rIwAAKh8IAAQcVqDvyCn9khpowlMbwfAg\nZSnmu1xxJTqqbzlVPqn9ngHhK3w4UPpBeDgHn1L3LP7DcKEyq2rKcZtjpD3qDNrt\nyfvccGxhNqs/t28/eCbTUC0E+BoNVUJWNLjPQUwr2/+kIRlgbIx4U0snD91kuFmO\n2jxod8dsGA+2vKI1YFeqCO4Oq/cdKpudWUzDq+fxQnZlfm9Gjf+/ZKPvynpYpb0k\ner4UCBl8wdpLjjllOEfiMcv8XAS9S3OvSpgnA1W3UsMCRir0ElKh8uIJfhJ5kaAg\nuz4KdIMkMZQDHeCl2IeEdNEHkI/j8YjOc0CifdxUfJgxjIAAs2nFWO5207VCvWY=\n=5XC8\n-----END PGP SIGNATURE-----\n", "payload": "tree 8e9cd674d600cfff5d9523c7a017456742ba444c\nparent 088b67079675af3d559dd3572520e3dc62d982ee\nparent 5660408f0a5b62bcc31258678e65078378109c94\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622403449 +0000\ncommitter GitHub <noreply@github.com> 1622403449 +0000\n\nMerge #9068\n\n9068: Move more `CompletinoContext` fields to `ImmediateLocation` r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "html_url": "https://github.com/rust-lang/rust/commit/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "088b67079675af3d559dd3572520e3dc62d982ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/088b67079675af3d559dd3572520e3dc62d982ee", "html_url": "https://github.com/rust-lang/rust/commit/088b67079675af3d559dd3572520e3dc62d982ee"}, {"sha": "5660408f0a5b62bcc31258678e65078378109c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/5660408f0a5b62bcc31258678e65078378109c94", "html_url": "https://github.com/rust-lang/rust/commit/5660408f0a5b62bcc31258678e65078378109c94"}], "stats": {"total": 309, "additions": 163, "deletions": 146}, "files": [{"sha": "cb90e8a3e1175e73e60bccda7bb777c97fae20ec", "filename": "crates/ide_completion/src/completions/fn_param.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "patch": "@@ -128,4 +128,19 @@ fn outer(text: String) {\n             \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn completes_non_ident_pat_param() {\n+        check(\n+            r#\"\n+struct Bar { bar: u32 }\n+\n+fn foo(Bar { bar }: Bar) {}\n+fn foo2($0) {}\n+\"#,\n+            expect![[r#\"\n+                bn Bar { bar }: Bar\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "0d035c61151ab11330617ff8e9c298b4926323de", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "patch": "@@ -4,7 +4,10 @@ use std::iter;\n \n use syntax::{SyntaxKind, T};\n \n-use crate::{CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions};\n+use crate::{\n+    patterns::ImmediateLocation, CompletionContext, CompletionItem, CompletionItemKind,\n+    CompletionKind, Completions,\n+};\n \n pub(crate) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     // complete keyword \"crate\" in use stmt\n@@ -44,7 +47,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         cov_mark::hit!(no_keyword_completion_in_comments);\n         return;\n     }\n-    if ctx.record_lit_syntax.is_some() {\n+    if matches!(ctx.completion_location, Some(ImmediateLocation::RecordExpr(_))) {\n         cov_mark::hit!(no_keyword_completion_in_record_lit);\n         return;\n     }\n@@ -55,7 +58,6 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     let expects_item = ctx.expects_item();\n \n     if ctx.has_impl_or_trait_prev_sibling() {\n-        // FIXME this also incorrectly shows up after a complete trait/impl\n         add_keyword(\"where\", \"where \");\n         return;\n     }\n@@ -77,11 +79,8 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(\"pub\", \"pub \");\n     }\n \n-    if expects_item || expects_assoc_item || has_block_expr_parent || ctx.is_match_arm {\n-        add_keyword(\"unsafe\", \"unsafe \");\n-    }\n-\n     if expects_item || expects_assoc_item || has_block_expr_parent {\n+        add_keyword(\"unsafe\", \"unsafe \");\n         add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n         add_keyword(\"const\", \"const $0\");\n         add_keyword(\"type\", \"type $0\");\n@@ -103,6 +102,9 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     if ctx.expects_expression() {\n+        if !has_block_expr_parent {\n+            add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n+        }\n         add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n         add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n         add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n@@ -574,6 +576,7 @@ pub mod future {\n         check(\n             r#\"fn main() { let _ = $0 }\"#,\n             expect![[r#\"\n+                kw unsafe\n                 kw match\n                 kw while\n                 kw while let\n@@ -634,6 +637,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n+                kw unsafe\n                 kw match\n                 kw while\n                 kw while let"}, {"sha": "6a5746fb94f69e8d72287cbfe381d01f2de28604", "filename": "crates/ide_completion/src/completions/mod_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "patch": "@@ -9,14 +9,14 @@ use ide_db::{\n };\n use rustc_hash::FxHashSet;\n \n-use crate::CompletionItem;\n+use crate::{patterns::ImmediateLocation, CompletionItem};\n \n use crate::{context::CompletionContext, item::CompletionKind, Completions};\n \n /// Complete mod declaration, i.e. `mod $0 ;`\n pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let mod_under_caret = match &ctx.mod_declaration_under_caret {\n-        Some(mod_under_caret) if mod_under_caret.item_list().is_none() => mod_under_caret,\n+    let mod_under_caret = match &ctx.completion_location {\n+        Some(ImmediateLocation::ModDeclaration(mod_under_caret)) => mod_under_caret,\n         _ => return None,\n     };\n "}, {"sha": "227c08d0107c897ecea7b777c60d5d69bcd64175", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "patch": "@@ -2,21 +2,21 @@\n use ide_db::{helpers::FamousDefs, SymbolKind};\n use syntax::ast::Expr;\n \n-use crate::{item::CompletionKind, CompletionContext, CompletionItem, Completions};\n+use crate::{\n+    item::CompletionKind, patterns::ImmediateLocation, CompletionContext, CompletionItem,\n+    Completions,\n+};\n \n pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let missing_fields = match (ctx.record_pat_syntax.as_ref(), ctx.record_lit_syntax.as_ref()) {\n-        (None, None) => return None,\n-        (Some(_), Some(_)) => unreachable!(\"A record cannot be both a literal and a pattern\"),\n-        (Some(record_pat), _) => ctx.sema.record_pattern_missing_fields(record_pat),\n-        (_, Some(record_lit)) => {\n-            let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_lit.clone()));\n+    let missing_fields = match &ctx.completion_location {\n+        Some(ImmediateLocation::RecordExpr(record_expr)) => {\n+            let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n             let default_trait = FamousDefs(&ctx.sema, ctx.krate).core_default_Default();\n             let impl_default_trait = default_trait\n                 .zip(ty)\n                 .map_or(false, |(default_trait, ty)| ty.impls_trait(ctx.db, default_trait, &[]));\n \n-            let missing_fields = ctx.sema.record_literal_missing_fields(record_lit);\n+            let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n             if impl_default_trait && !missing_fields.is_empty() {\n                 let completion_text = \"..Default::default()\";\n                 let mut item = CompletionItem::new(\n@@ -32,6 +32,10 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n \n             missing_fields\n         }\n+        Some(ImmediateLocation::RecordPat(record_pat)) => {\n+            ctx.sema.record_pattern_missing_fields(record_pat)\n+        }\n+        _ => return None,\n     };\n \n     for (field, ty) in missing_fields {"}, {"sha": "7c46c815d2baf2d17338487c2a7586722f06e2ac", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 35, "deletions": 64, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "patch": "@@ -18,7 +18,7 @@ use text_edit::Indel;\n use crate::{\n     patterns::{\n         determine_location, determine_prev_sibling, for_is_prev2, inside_impl_trait_block,\n-        is_in_loop_body, is_match_arm, previous_token, ImmediateLocation, ImmediatePrevSibling,\n+        is_in_loop_body, previous_token, ImmediateLocation, ImmediatePrevSibling,\n     },\n     CompletionConfig,\n };\n@@ -54,11 +54,6 @@ pub(crate) struct CompletionContext<'a> {\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n \n-    /// RecordExpr the token is a field of\n-    pub(super) record_lit_syntax: Option<ast::RecordExpr>,\n-    /// RecordPat the token is a field of\n-    pub(super) record_pat_syntax: Option<ast::RecordPat>,\n-\n     // potentially set if we are completing a lifetime\n     pub(super) lifetime_syntax: Option<ast::Lifetime>,\n     pub(super) lifetime_param_syntax: Option<ast::LifetimeParam>,\n@@ -71,6 +66,7 @@ pub(crate) struct CompletionContext<'a> {\n \n     pub(super) completion_location: Option<ImmediateLocation>,\n     pub(super) prev_sibling: Option<ImmediatePrevSibling>,\n+    pub(super) attribute_under_caret: Option<ast::Attr>,\n \n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n@@ -95,14 +91,10 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_macro_call: bool,\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n-    pub(super) attribute_under_caret: Option<ast::Attr>,\n-    pub(super) mod_declaration_under_caret: Option<ast::Module>,\n     pub(super) locals: Vec<(String, Local)>,\n \n-    // keyword patterns\n     pub(super) previous_token: Option<SyntaxToken>,\n     pub(super) in_loop_body: bool,\n-    pub(super) is_match_arm: bool,\n     pub(super) incomplete_let: bool,\n \n     no_completion_required: bool,\n@@ -157,8 +149,6 @@ impl<'a> CompletionContext<'a> {\n             lifetime_param_syntax: None,\n             function_def: None,\n             use_item_syntax: None,\n-            record_lit_syntax: None,\n-            record_pat_syntax: None,\n             impl_def: None,\n             active_parameter: ActiveParameter::at(db, position),\n             is_label_ref: false,\n@@ -176,15 +166,13 @@ impl<'a> CompletionContext<'a> {\n             is_macro_call: false,\n             is_path_type: false,\n             has_type_args: false,\n-            attribute_under_caret: None,\n-            mod_declaration_under_caret: None,\n             previous_token: None,\n             in_loop_body: false,\n             completion_location: None,\n             prev_sibling: None,\n-            is_match_arm: false,\n             no_completion_required: false,\n             incomplete_let: false,\n+            attribute_under_caret: None,\n             locals,\n         };\n \n@@ -227,7 +215,6 @@ impl<'a> CompletionContext<'a> {\n                 break;\n             }\n         }\n-        ctx.fill_keyword_patterns(&speculative_file, offset);\n         ctx.fill(&original_file, speculative_file, offset);\n         Some(ctx)\n     }\n@@ -311,31 +298,13 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn is_path_disallowed(&self) -> bool {\n-        self.record_lit_syntax.is_some()\n-            || self.record_pat_syntax.is_some()\n-            || self.attribute_under_caret.is_some()\n-            || self.mod_declaration_under_caret.is_some()\n-    }\n-\n-    fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n-        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n-        let syntax_element = NodeOrToken::Token(fake_ident_token);\n-        self.previous_token = previous_token(syntax_element.clone());\n-        self.in_loop_body = is_in_loop_body(syntax_element.clone());\n-        self.is_match_arm = is_match_arm(syntax_element.clone());\n-\n-        self.mod_declaration_under_caret =\n-            find_node_at_offset::<ast::Module>(&file_with_fake_ident, offset)\n-                .filter(|module| module.item_list().is_none());\n-        self.incomplete_let =\n-            syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n-                it.syntax().text_range().end() == syntax_element.text_range().end()\n-            });\n-\n-        let inside_impl_trait_block = inside_impl_trait_block(syntax_element.clone());\n-        let fn_is_prev = self.previous_token_is(T![fn]);\n-        let for_is_prev2 = for_is_prev2(syntax_element.clone());\n-        self.no_completion_required = (fn_is_prev && !inside_impl_trait_block) || for_is_prev2;\n+        matches!(\n+            self.completion_location,\n+            Some(ImmediateLocation::Attribute(_))\n+                | Some(ImmediateLocation::ModDeclaration(_))\n+                | Some(ImmediateLocation::RecordPat(_))\n+                | Some(ImmediateLocation::RecordExpr(_))\n+        ) || self.attribute_under_caret.is_some()\n     }\n \n     fn fill_impl_def(&mut self) {\n@@ -453,25 +422,43 @@ impl<'a> CompletionContext<'a> {\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n     ) {\n+        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n+        let syntax_element = NodeOrToken::Token(fake_ident_token);\n+        self.previous_token = previous_token(syntax_element.clone());\n+        self.attribute_under_caret = syntax_element.ancestors().find_map(ast::Attr::cast);\n+        self.no_completion_required = {\n+            let inside_impl_trait_block = inside_impl_trait_block(syntax_element.clone());\n+            let fn_is_prev = self.previous_token_is(T![fn]);\n+            let for_is_prev2 = for_is_prev2(syntax_element.clone());\n+            (fn_is_prev && !inside_impl_trait_block) || for_is_prev2\n+        };\n+        self.in_loop_body = is_in_loop_body(syntax_element.clone());\n+\n+        self.incomplete_let =\n+            syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n+                it.syntax().text_range().end() == syntax_element.text_range().end()\n+            });\n+\n         let (expected_type, expected_name) = self.expected_type_and_name();\n         self.expected_type = expected_type;\n         self.expected_name = expected_name;\n-        self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n+\n         let name_like = match find_node_at_offset(&&file_with_fake_ident, offset) {\n             Some(it) => it,\n             None => return,\n         };\n-        self.completion_location = determine_location(&name_like);\n+        self.completion_location =\n+            determine_location(&self.sema, original_file, offset, &name_like);\n         self.prev_sibling = determine_prev_sibling(&name_like);\n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n                 self.classify_lifetime(original_file, lifetime, offset);\n             }\n             ast::NameLike::NameRef(name_ref) => {\n-                self.classify_name_ref(original_file, name_ref, offset);\n+                self.classify_name_ref(original_file, name_ref);\n             }\n             ast::NameLike::Name(name) => {\n-                self.classify_name(original_file, name, offset);\n+                self.classify_name(name);\n             }\n         }\n     }\n@@ -505,7 +492,7 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    fn classify_name(&mut self, original_file: &SyntaxNode, name: ast::Name, offset: TextSize) {\n+    fn classify_name(&mut self, name: ast::Name) {\n         if let Some(bind_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n             self.is_pat_or_const = Some(PatternRefutability::Refutable);\n             // if any of these is here our bind pat can't be a const pat anymore\n@@ -543,28 +530,12 @@ impl<'a> CompletionContext<'a> {\n \n             self.fill_impl_def();\n         }\n+\n         self.is_param |= is_node::<ast::Param>(name.syntax());\n-        if ast::RecordPatField::for_field_name(&name).is_some() {\n-            self.record_pat_syntax =\n-                self.sema.find_node_at_offset_with_macros(&original_file, offset);\n-        }\n     }\n \n-    fn classify_name_ref(\n-        &mut self,\n-        original_file: &SyntaxNode,\n-        name_ref: ast::NameRef,\n-        offset: TextSize,\n-    ) {\n+    fn classify_name_ref(&mut self, original_file: &SyntaxNode, name_ref: ast::NameRef) {\n         self.fill_impl_def();\n-        if ast::RecordExprField::for_field_name(&name_ref).is_some() {\n-            self.record_lit_syntax =\n-                self.sema.find_node_at_offset_with_macros(original_file, offset);\n-        }\n-        if ast::RecordPatField::for_field_name_ref(&name_ref).is_some() {\n-            self.record_pat_syntax =\n-                self.sema.find_node_at_offset_with_macros(&original_file, offset);\n-        }\n \n         self.name_ref_syntax =\n             find_node_at_offset(original_file, name_ref.syntax().text_range().start());"}, {"sha": "26516046bcf32ee8aa583f796ad5faf079409d0c", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 87, "deletions": 64, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=92b9e5ef3c03d51713ff5fa32cd58bdf97701b5e", "patch": "@@ -1,15 +1,18 @@\n //! Patterns telling us certain facts about current syntax element, they are used in completion context\n \n+use hir::Semantics;\n+use ide_db::RootDatabase;\n use syntax::{\n     algo::non_trivia_sibling,\n     ast::{self, LoopBodyOwner},\n-    match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n+    match_ast, AstNode, Direction, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, T,\n+    SyntaxNode, SyntaxToken, TextSize, T,\n };\n \n #[cfg(test)]\n use crate::test_utils::{check_pattern_is_applicable, check_pattern_is_not_applicable};\n+\n /// Direct parent container of the cursor position\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediatePrevSibling {\n@@ -19,7 +22,7 @@ pub(crate) enum ImmediatePrevSibling {\n }\n \n /// Direct parent container of the cursor position\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediateLocation {\n     Use,\n     Impl,\n@@ -29,10 +32,24 @@ pub(crate) enum ImmediateLocation {\n     IdentPat,\n     BlockExpr,\n     ItemList,\n+    // Fake file ast node\n+    Attribute(ast::Attr),\n+    // Fake file ast node\n+    ModDeclaration(ast::Module),\n+    // Original file ast node\n+    /// The record expr of the field name we are completing\n+    RecordExpr(ast::RecordExpr),\n+    // Original file ast node\n+    /// The record pat of the field name we are completing\n+    RecordPat(ast::RecordPat),\n }\n \n pub(crate) fn determine_prev_sibling(name_like: &ast::NameLike) -> Option<ImmediatePrevSibling> {\n-    let node = maximize_name_ref(name_like)?;\n+    let node = match name_like {\n+        ast::NameLike::NameRef(name_ref) => maximize_name_ref(name_ref),\n+        ast::NameLike::Name(n) => n.syntax().clone(),\n+        ast::NameLike::Lifetime(lt) => lt.syntax().clone(),\n+    };\n     let node = match node.parent().and_then(ast::MacroCall::cast) {\n         // When a path is being typed after the name of a trait/type of an impl it is being\n         // parsed as a macro, so when the trait/impl has a block following it an we are between the\n@@ -77,8 +94,37 @@ pub(crate) fn determine_prev_sibling(name_like: &ast::NameLike) -> Option<Immedi\n     Some(res)\n }\n \n-pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateLocation> {\n-    let node = maximize_name_ref(name_like)?;\n+pub(crate) fn determine_location(\n+    sema: &Semantics<RootDatabase>,\n+    original_file: &SyntaxNode,\n+    offset: TextSize,\n+    name_like: &ast::NameLike,\n+) -> Option<ImmediateLocation> {\n+    let node = match name_like {\n+        ast::NameLike::NameRef(name_ref) => {\n+            if ast::RecordExprField::for_field_name(&name_ref).is_some() {\n+                return sema\n+                    .find_node_at_offset_with_macros(original_file, offset)\n+                    .map(ImmediateLocation::RecordExpr);\n+            }\n+            if ast::RecordPatField::for_field_name_ref(&name_ref).is_some() {\n+                return sema\n+                    .find_node_at_offset_with_macros(original_file, offset)\n+                    .map(ImmediateLocation::RecordPat);\n+            }\n+            maximize_name_ref(name_ref)\n+        }\n+        ast::NameLike::Name(name) => {\n+            if ast::RecordPatField::for_field_name(&name).is_some() {\n+                return sema\n+                    .find_node_at_offset_with_macros(original_file, offset)\n+                    .map(ImmediateLocation::RecordPat);\n+            }\n+            name.syntax().clone()\n+        }\n+        ast::NameLike::Lifetime(lt) => lt.syntax().clone(),\n+    };\n+\n     let parent = match node.parent() {\n         Some(parent) => match ast::MacroCall::cast(parent.clone()) {\n             // When a path is being typed in an (Assoc)ItemList the parser will always emit a macro_call.\n@@ -103,6 +149,7 @@ pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateL\n             }\n         }\n     };\n+\n     let res = match_ast! {\n         match parent {\n             ast::IdentPat(_it) => ImmediateLocation::IdentPat,\n@@ -117,36 +164,34 @@ pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateL\n                 Some(TRAIT) => ImmediateLocation::Trait,\n                 _ => return None,\n             },\n+            ast::Module(it) => if it.item_list().is_none() {\n+                    ImmediateLocation::ModDeclaration(it)\n+                } else {\n+                    return None\n+            },\n+            ast::Attr(it) => ImmediateLocation::Attribute(it),\n             _ => return None,\n         }\n     };\n     Some(res)\n }\n \n-fn maximize_name_ref(name_like: &ast::NameLike) -> Option<SyntaxNode> {\n-    // First walk the element we are completing up to its highest node that has the same text range\n-    // as the element so that we can check in what context it immediately lies. We only do this for\n-    // NameRef -> Path as that's the only thing that makes sense to being \"expanded\" semantically.\n-    // We only wanna do this if the NameRef is the last segment of the path.\n-    let node = match name_like {\n-        ast::NameLike::NameRef(name_ref) => {\n-            if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n-                let p = segment.parent_path();\n-                if p.parent_path().is_none() {\n-                    p.syntax()\n-                        .ancestors()\n-                        .take_while(|it| it.text_range() == p.syntax().text_range())\n-                        .last()?\n-                } else {\n-                    return None;\n-                }\n-            } else {\n-                return None;\n+fn maximize_name_ref(name_ref: &ast::NameRef) -> SyntaxNode {\n+    // Maximize a nameref to its enclosing path if its the last segment of said path\n+    if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n+        let p = segment.parent_path();\n+        if p.parent_path().is_none() {\n+            if let Some(it) = p\n+                .syntax()\n+                .ancestors()\n+                .take_while(|it| it.text_range() == p.syntax().text_range())\n+                .last()\n+            {\n+                return it;\n             }\n         }\n-        it @ ast::NameLike::Name(_) | it @ ast::NameLike::Lifetime(_) => it.syntax().clone(),\n-    };\n-    Some(node)\n+    }\n+    name_ref.syntax().clone()\n }\n \n pub(crate) fn inside_impl_trait_block(element: SyntaxElement) -> bool {\n@@ -167,18 +212,6 @@ fn test_inside_impl_trait_block() {\n     check_pattern_is_not_applicable(r\"impl A { fn f$0 }\", inside_impl_trait_block);\n }\n \n-pub(crate) fn is_match_arm(element: SyntaxElement) -> bool {\n-    not_same_range_ancestor(element.clone()).filter(|it| it.kind() == MATCH_ARM).is_some()\n-        && previous_sibling_or_ancestor_sibling(element)\n-            .and_then(|it| it.into_token())\n-            .filter(|it| it.kind() == FAT_ARROW)\n-            .is_some()\n-}\n-#[test]\n-fn test_is_match_arm() {\n-    check_pattern_is_applicable(r\"fn my_fn() { match () { () => m$0 } }\", is_match_arm);\n-}\n-\n pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n     element.into_token().and_then(|it| previous_non_trivia_token(it))\n }\n@@ -216,10 +249,6 @@ pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n         .is_some()\n }\n \n-pub(crate) fn not_same_range_ancestor(element: SyntaxElement) -> Option<SyntaxNode> {\n-    element.ancestors().skip_while(|it| it.text_range() == element.text_range()).next()\n-}\n-\n fn previous_non_trivia_token(token: SyntaxToken) -> Option<SyntaxToken> {\n     let mut token = token.prev_token();\n     while let Some(inner) = token.clone() {\n@@ -232,31 +261,25 @@ fn previous_non_trivia_token(token: SyntaxToken) -> Option<SyntaxToken> {\n     None\n }\n \n-fn previous_sibling_or_ancestor_sibling(element: SyntaxElement) -> Option<SyntaxElement> {\n-    let token_sibling = non_trivia_sibling(element.clone(), Direction::Prev);\n-    if let Some(sibling) = token_sibling {\n-        Some(sibling)\n-    } else {\n-        // if not trying to find first ancestor which has such a sibling\n-        let range = element.text_range();\n-        let top_node = element.ancestors().take_while(|it| it.text_range() == range).last()?;\n-        let prev_sibling_node = top_node.ancestors().find(|it| {\n-            non_trivia_sibling(NodeOrToken::Node(it.to_owned()), Direction::Prev).is_some()\n-        })?;\n-        non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n+    use syntax::algo::find_node_at_offset;\n+\n+    use crate::test_utils::position;\n+\n     use super::*;\n \n     fn check_location(code: &str, loc: impl Into<Option<ImmediateLocation>>) {\n-        check_pattern_is_applicable(code, |e| {\n-            let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n-            assert_eq!(determine_location(name), loc.into());\n-            true\n-        });\n+        let (db, pos) = position(code);\n+\n+        let sema = Semantics::new(&db);\n+        let original_file = sema.parse(pos.file_id);\n+\n+        let name_like = find_node_at_offset(original_file.syntax(), pos.offset).unwrap();\n+        assert_eq!(\n+            determine_location(&sema, original_file.syntax(), pos.offset, &name_like),\n+            loc.into()\n+        );\n     }\n \n     fn check_prev_sibling(code: &str, sibling: impl Into<Option<ImmediatePrevSibling>>) {"}]}