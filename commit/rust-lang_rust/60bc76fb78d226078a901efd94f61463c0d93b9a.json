{"sha": "60bc76fb78d226078a901efd94f61463c0d93b9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYmM3NmZiNzhkMjI2MDc4YTkwMWVmZDk0ZjYxNDYzYzBkOTNiOWE=", "commit": {"author": {"name": "JeremyLetang", "email": "letang.jeremy@gmail.com", "date": "2014-02-10T21:50:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-13T20:54:17Z"}, "message": "remove duplicate function from std::ptr (is_null, is_not_null, offset, mut_offset)", "tree": {"sha": "8c8777c148f24c82d45728e9817cd9a8b4de223d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c8777c148f24c82d45728e9817cd9a8b4de223d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60bc76fb78d226078a901efd94f61463c0d93b9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60bc76fb78d226078a901efd94f61463c0d93b9a", "html_url": "https://github.com/rust-lang/rust/commit/60bc76fb78d226078a901efd94f61463c0d93b9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60bc76fb78d226078a901efd94f61463c0d93b9a/comments", "author": {"login": "jeremyletang", "id": 4346460, "node_id": "MDQ6VXNlcjQzNDY0NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/4346460?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeremyletang", "html_url": "https://github.com/jeremyletang", "followers_url": "https://api.github.com/users/jeremyletang/followers", "following_url": "https://api.github.com/users/jeremyletang/following{/other_user}", "gists_url": "https://api.github.com/users/jeremyletang/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeremyletang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeremyletang/subscriptions", "organizations_url": "https://api.github.com/users/jeremyletang/orgs", "repos_url": "https://api.github.com/users/jeremyletang/repos", "events_url": "https://api.github.com/users/jeremyletang/events{/privacy}", "received_events_url": "https://api.github.com/users/jeremyletang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c5295c0bf6e69a772120ec6a56e0fdb3021ded4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c5295c0bf6e69a772120ec6a56e0fdb3021ded4", "html_url": "https://github.com/rust-lang/rust/commit/1c5295c0bf6e69a772120ec6a56e0fdb3021ded4"}], "stats": {"total": 167, "additions": 70, "deletions": 97}, "files": [{"sha": "053a8612694ab399aff710291f4f3af61e05d1f7", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -195,7 +195,7 @@ impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n             let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n-            assert!(!ptr::is_null(ptr));\n+            assert!(!ptr.is_null());\n             // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n             // move_val_init moves a value into this memory without\n             // attempting to drop the original value."}, {"sha": "b41af9eb05430f19cbcc72c8fae978b5d069a01c", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -34,7 +34,6 @@ use std::cast;\n use std::cell::{Cell, RefCell};\n use std::mem;\n use std::num;\n-use std::ptr;\n use std::kinds::marker;\n use std::rc::Rc;\n use std::rt::global_heap;\n@@ -144,7 +143,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *uint = transmute(ptr::offset(buf, idx as int));\n+        let tydesc_data: *uint = transmute(buf.offset(idx as int));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n@@ -155,7 +154,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n-            ((*tydesc).drop_glue)(ptr::offset(buf, start as int) as *i8);\n+            ((*tydesc).drop_glue)(buf.offset(start as int) as *i8);\n         }\n \n         // Find where the next tydesc lives\n@@ -261,7 +260,7 @@ impl Arena {\n             //       start, n_bytes, align, head.fill);\n \n             let buf = self.head.as_ptr();\n-            return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n+            return (buf.offset(tydesc_start as int), buf.offset(start as int));\n         }\n     }\n "}, {"sha": "fec5b105c4b1893f4c9f406210511f606b85f983", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -119,7 +119,7 @@ impl <T> CVec<T> {\n     pub fn get<'a>(&'a self, ofs: uint) -> &'a T {\n         assert!(ofs < self.len);\n         unsafe {\n-            &*ptr::mut_offset(self.base, ofs as int)\n+            &*self.base.offset(ofs as int)\n         }\n     }\n \n@@ -131,7 +131,7 @@ impl <T> CVec<T> {\n     pub fn get_mut<'a>(&'a mut self, ofs: uint) -> &'a mut T {\n         assert!(ofs < self.len);\n         unsafe {\n-            &mut *ptr::mut_offset(self.base, ofs as int)\n+            &mut *self.base.offset(ofs as int)\n         }\n     }\n "}, {"sha": "70b93a9813535842c5791b7e16697395b18a3102", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -30,7 +30,6 @@ use std::io;\n use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n-use std::ptr;\n use std::str;\n use std::vec;\n use flate;\n@@ -340,7 +339,7 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n                 });\n                 if !version_ok { return None; }\n \n-                let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n+                let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {"}, {"sha": "b8d16f9bb8006d761ea7ba62801496141d676ccd", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -21,7 +21,6 @@ use std::cast;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_char};\n use syntax::codemap::Span;\n-use std::ptr::is_not_null;\n \n pub struct Builder<'a> {\n     llbuilder: BuilderRef,\n@@ -492,7 +491,7 @@ impl<'a> Builder<'a> {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n-        assert!(is_not_null(self.llbuilder));\n+        assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store\");\n         unsafe {\n             llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n@@ -503,7 +502,7 @@ impl<'a> Builder<'a> {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n-        assert!(is_not_null(self.llbuilder));\n+        assert!(self.llbuilder.is_not_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);"}, {"sha": "b71dbe05ad2b665a6b8f74057a4c08290df6cb6e", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -426,7 +426,7 @@ mod test {\n         unsafe {\n             let base = transmute::<*u8, *mut u8>(buf.base);\n             (*base) = 1;\n-            (*ptr::mut_offset(base, 1)) = 2;\n+            (*base.offset(1)) = 2;\n         }\n \n         assert!(slice[0] == 1);"}, {"sha": "3d57a32a830b2c867162c9ca85c6ae8dadb96bf9", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -131,7 +131,6 @@ pub mod reader {\n     }\n \n     pub fn vuint_at(data: &[u8], start: uint) -> Res {\n-        use std::ptr::offset;\n         use std::mem::from_be32;\n \n         if data.len() - start < 4 {\n@@ -163,7 +162,7 @@ pub mod reader {\n \n         unsafe {\n             let (ptr, _): (*u8, uint) = transmute(data);\n-            let ptr = offset(ptr, start as int);\n+            let ptr = ptr.offset(start as int);\n             let ptr: *i32 = transmute(ptr);\n             let val = from_be32(*ptr) as u32;\n "}, {"sha": "fe332a60efa4468ec3f37ef8e1df608323114be9", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -310,7 +310,7 @@ impl<'a> ToCStr for &'a [u8] {\n         let buf = malloc_raw(self_len + 1);\n \n         ptr::copy_memory(buf, self.as_ptr(), self_len);\n-        *ptr::mut_offset(buf, self_len as int) = 0;\n+        *buf.offset(self_len as int) = 0;\n \n         CString::new(buf as *libc::c_char, true)\n     }\n@@ -368,7 +368,7 @@ impl<'a> Iterator<libc::c_char> for CChars<'a> {\n         if ch == 0 {\n             None\n         } else {\n-            self.ptr = unsafe { ptr::offset(self.ptr, 1) };\n+            self.ptr = unsafe { self.ptr.offset(1) };\n             Some(ch)\n         }\n     }\n@@ -429,18 +429,18 @@ mod tests {\n     fn test_str_to_c_str() {\n         \"\".to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n+                assert_eq!(*buf.offset(0), 0);\n             }\n         });\n \n         \"hello\".to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n+                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+                assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(5), 0);\n             }\n         })\n     }\n@@ -450,28 +450,28 @@ mod tests {\n         let b: &[u8] = [];\n         b.to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n+                assert_eq!(*buf.offset(0), 0);\n             }\n         });\n \n         let _ = bytes!(\"hello\").to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n+                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+                assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+                assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(5), 0);\n             }\n         });\n \n         let _ = bytes!(\"foo\", 0xff).to_c_str().with_ref(|buf| {\n             unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'f' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 0xff as i8);\n-                assert_eq!(*ptr::offset(buf, 4), 0);\n+                assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n+                assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(2), 'o' as libc::c_char);\n+                assert_eq!(*buf.offset(3), 0xff as i8);\n+                assert_eq!(*buf.offset(4), 0);\n             }\n         });\n     }\n@@ -634,16 +634,15 @@ mod bench {\n     use extra::test::BenchHarness;\n     use libc;\n     use prelude::*;\n-    use ptr;\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {\n         let s_buf = s.as_ptr();\n         for i in range(0, s.len()) {\n             unsafe {\n                 assert_eq!(\n-                    *ptr::offset(s_buf, i as int) as libc::c_char,\n-                    *ptr::offset(c_str, i as int));\n+                    *s_buf.offset(i as int) as libc::c_char,\n+                    *c_str.offset(i as int));\n             }\n         }\n     }"}, {"sha": "da4697d0e48804491a51e8801058a6044bac11b7", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -18,6 +18,7 @@ use iter::Iterator;\n use option::Option;\n use io::Reader;\n use vec::{OwnedVector, ImmutableVector};\n+use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `None`.\n@@ -104,7 +105,7 @@ pub fn u64_from_be_bytes(data: &[u8],\n                          start: uint,\n                          size: uint)\n                       -> u64 {\n-    use ptr::{copy_nonoverlapping_memory, offset, mut_offset};\n+    use ptr::{copy_nonoverlapping_memory};\n     use mem::from_be64;\n     use vec::MutableVector;\n \n@@ -116,9 +117,9 @@ pub fn u64_from_be_bytes(data: &[u8],\n \n     let mut buf = [0u8, ..8];\n     unsafe {\n-        let ptr = offset(data.as_ptr(), start as int);\n+        let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n-        copy_nonoverlapping_memory(mut_offset(out, (8 - size) as int), ptr, size);\n+        copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n         from_be64(*(out as *i64)) as u64\n     }\n }"}, {"sha": "2ba6f7d4fd64d93fa45c48cb8753269b5d9151e9", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 34, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -21,23 +21,6 @@ use unstable::intrinsics;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n \n-/// Calculate the offset from a pointer.\n-/// The `count` argument is in units of T; e.g. a `count` of 3\n-/// represents a pointer offset of `3 * sizeof::<T>()` bytes.\n-#[inline]\n-pub unsafe fn offset<T>(ptr: *T, count: int) -> *T {\n-    intrinsics::offset(ptr, count)\n-}\n-\n-/// Calculate the offset from a mut pointer. The count *must* be in bounds or\n-/// otherwise the loads of this address are undefined.\n-/// The `count` argument is in units of T; e.g. a `count` of 3\n-/// represents a pointer offset of `3 * sizeof::<T>()` bytes.\n-#[inline]\n-pub unsafe fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n-    intrinsics::offset(ptr as *T, count) as *mut T\n-}\n-\n /// Return the offset of the first null pointer in `buf`.\n #[inline]\n pub unsafe fn buf_len<T>(buf: **T) -> uint {\n@@ -63,7 +46,7 @@ impl<T> Clone for *mut T {\n pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n     let mut i = 0;\n     loop {\n-        if f(&(*offset(buf, i as int))) { return i; }\n+        if f(&(*buf.offset(i as int))) { return i; }\n         else { i += 1; }\n     }\n }\n@@ -76,14 +59,6 @@ pub fn null<T>() -> *T { 0 as *T }\n #[inline]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n-/// Returns true if the pointer is equal to the null pointer.\n-#[inline]\n-pub fn is_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_null() }\n-\n-/// Returns true if the pointer is not equal to the null pointer.\n-#[inline]\n-pub fn is_not_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_not_null() }\n-\n /**\n  * Copies data from one location to another.\n  *\n@@ -206,7 +181,7 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     }\n     //let start_ptr = *arr;\n     for e in range(0, len) {\n-        let n = offset(arr, e as int);\n+        let n = arr.offset(e as int);\n         cb(*n);\n     }\n     debug!(\"array_each_with_len: after iterate\");\n@@ -278,7 +253,7 @@ impl<T> RawPtr<T> for *T {\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.\n     #[inline]\n-    unsafe fn offset(self, count: int) -> *T { offset(self, count) }\n+    unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }\n }\n \n /// Extension methods for mutable pointers\n@@ -323,7 +298,7 @@ impl<T> RawPtr<T> for *mut T {\n     /// This method should be preferred over `offset` when the guarantee can be\n     /// satisfied, to enable better optimization.\n     #[inline]\n-    unsafe fn offset(self, count: int) -> *mut T { mut_offset(self, count) }\n+    unsafe fn offset(self, count: int) -> *mut T { intrinsics::offset(self as *T, count) as *mut T }\n }\n \n // Equality for pointers\n@@ -478,14 +453,14 @@ pub mod ptr_tests {\n             let v0 = ~[32000u16, 32001u16, 32002u16];\n             let mut v1 = ~[0u16, 0u16, 0u16];\n \n-            copy_memory(mut_offset(v1.as_mut_ptr(), 1),\n-                        offset(v0.as_ptr(), 1), 1);\n+            copy_memory(v1.as_mut_ptr().offset(1),\n+                        v0.as_ptr().offset(1), 1);\n             assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n             copy_memory(v1.as_mut_ptr(),\n-                        offset(v0.as_ptr(), 2), 1);\n+                        v0.as_ptr().offset(2), 1);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 0u16));\n-            copy_memory(mut_offset(v1.as_mut_ptr(), 2),\n+            copy_memory(v1.as_mut_ptr().offset(2),\n                         v0.as_ptr(), 1u);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 32000u16));\n@@ -525,7 +500,7 @@ pub mod ptr_tests {\n         assert!(p.is_null());\n         assert!(!p.is_not_null());\n \n-        let q = unsafe { offset(p, 1) };\n+        let q = unsafe { p.offset(1) };\n         assert!(!q.is_null());\n         assert!(q.is_not_null());\n "}, {"sha": "58c00177b90165578dd5f0bf23000352ee355125", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -23,6 +23,7 @@ use io;\n use iter::Iterator;\n use option::{Some, None, Option};\n use ptr;\n+use ptr::RawPtr;\n use reflect;\n use reflect::{MovePtr, align};\n use result::{Ok, Err};\n@@ -221,7 +222,7 @@ impl<'a> ReprVisitor<'a> {\n                 if_ok!(self, self.writer.write(\", \".as_bytes()));\n             }\n             self.visit_ptr_inner(p as *u8, inner);\n-            p = align(unsafe { ptr::offset(p, sz as int) as uint }, al) as *u8;\n+            p = align(unsafe { p.offset(sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n         if_ok!(self, self.writer.write([']' as u8]));"}, {"sha": "0d263d94ccf0f26992fff841b83c63de0c51d0d2", "filename": "src/libstd/str.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -1242,7 +1242,7 @@ pub mod raw {\n         let mut i = 0;\n         while *curr != 0 {\n             i += 1;\n-            curr = ptr::offset(buf, i);\n+            curr = buf.offset(i);\n         }\n         from_buf_len(buf as *u8, i as uint)\n     }\n@@ -1272,7 +1272,7 @@ pub mod raw {\n         let mut len = 0u;\n         while *curr != 0u8 {\n             len += 1u;\n-            curr = ptr::offset(s, len as int);\n+            curr = s.offset(len as int);\n         }\n         let v = Slice { data: s, len: len };\n         assert!(is_utf8(::cast::transmute(v)));\n@@ -2921,7 +2921,6 @@ impl Default for ~str {\n mod tests {\n     use iter::AdditiveIterator;\n     use prelude::*;\n-    use ptr;\n     use str::*;\n \n     #[test]\n@@ -3549,11 +3548,11 @@ mod tests {\n     fn test_as_ptr() {\n         let buf = \"hello\".as_ptr();\n         unsafe {\n-            assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n-            assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n-            assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n-            assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n-            assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n+            assert_eq!(*buf.offset(0), 'h' as u8);\n+            assert_eq!(*buf.offset(1), 'e' as u8);\n+            assert_eq!(*buf.offset(2), 'l' as u8);\n+            assert_eq!(*buf.offset(3), 'l' as u8);\n+            assert_eq!(*buf.offset(4), 'o' as u8);\n         }\n     }\n "}, {"sha": "c67b19933d37fe352d09177988ae2f892747534a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -139,7 +139,7 @@ pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n             &mut i, (),\n             |i, ()| while *i < n_elts {\n                 mem::move_val_init(\n-                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    &mut(*p.offset(*i as int)),\n                     op(*i));\n                 *i += 1u;\n             },\n@@ -167,7 +167,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n             &mut i, (),\n             |i, ()| while *i < n_elts {\n                 mem::move_val_init(\n-                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    &mut(*p.offset(*i as int)),\n                     t.clone());\n                 *i += 1u;\n             },\n@@ -1497,7 +1497,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             let fill = (**repr).fill;\n             (**repr).fill += mem::nonzero_size_of::<T>();\n             let p = to_unsafe_ptr(&((**repr).data));\n-            let p = ptr::offset(p, fill as int) as *mut T;\n+            let p = p.offset(fill as int) as *mut T;\n             mem::move_val_init(&mut(*p), t);\n         }\n     }\n@@ -1511,7 +1511,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         unsafe { // Note: infallible.\n             let self_p = self.as_mut_ptr();\n             let rhs_p = rhs.as_ptr();\n-            ptr::copy_memory(ptr::mut_offset(self_p, self_len as int), rhs_p, rhs_len);\n+            ptr::copy_memory(self_p.offset(self_len as int), rhs_p, rhs_len);\n             self.set_len(new_len);\n             rhs.set_len(0);\n         }\n@@ -1798,11 +1798,11 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             let mut w = 1;\n \n             while r < ln {\n-                let p_r = ptr::mut_offset(p, r as int);\n-                let p_wm1 = ptr::mut_offset(p, (w - 1) as int);\n+                let p_r = p.offset(r as int);\n+                let p_wm1 = p.offset((w - 1) as int);\n                 if *p_r != *p_wm1 {\n                     if r != w {\n-                        let p_w = ptr::mut_offset(p_wm1, 1);\n+                        let p_w = p_wm1.offset(1);\n                         mem::swap(&mut *p_r, &mut *p_w);\n                     }\n                     w += 1;\n@@ -2385,7 +2385,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        cast::transmute(ptr::mut_offset(self.repr().data as *mut T, index as int))\n+        cast::transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n     #[inline]\n@@ -2486,6 +2486,7 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n pub mod raw {\n     use cast;\n     use ptr;\n+    use ptr::RawPtr;\n     use vec::{with_capacity, MutableVector, OwnedVector};\n     use unstable::raw::Slice;\n \n@@ -2544,7 +2545,7 @@ pub mod raw {\n     pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n         if slice.len == 0 { fail!(\"shift on empty slice\"); }\n         let head: *T = slice.data;\n-        slice.data = ptr::offset(slice.data, 1);\n+        slice.data = slice.data.offset(1);\n         slice.len -= 1;\n         head\n     }\n@@ -2556,7 +2557,7 @@ pub mod raw {\n      */\n     pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n         if slice.len == 0 { fail!(\"pop on empty slice\"); }\n-        let tail: *T = ptr::offset(slice.data, (slice.len - 1) as int);\n+        let tail: *T = slice.data.offset((slice.len - 1) as int);\n         slice.len -= 1;\n         tail\n     }"}, {"sha": "25ba45021b3fa0364bb9571ec92aa5f87e556727", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bc76fb78d226078a901efd94f61463c0d93b9a/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=60bc76fb78d226078a901efd94f61463c0d93b9a", "patch": "@@ -22,7 +22,8 @@ use cast::{forget, transmute};\n use rt::global_heap::{malloc_raw, realloc_raw};\n use vec::{ImmutableVector, Items, MutableVector};\n use unstable::raw::Slice;\n-use ptr::{offset, read_ptr};\n+use ptr::read_ptr;\n+use ptr::RawPtr;\n use libc::{free, c_void};\n \n pub struct Vec<T> {\n@@ -135,7 +136,7 @@ impl<T> Vec<T> {\n         }\n \n         unsafe {\n-            let end = offset(self.ptr as *T, self.len as int) as *mut T;\n+            let end = (self.ptr as *T).offset(self.len as int) as *mut T;\n             move_val_init(&mut *end, value);\n             self.len += 1;\n         }"}]}