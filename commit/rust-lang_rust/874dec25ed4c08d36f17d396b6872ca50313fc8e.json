{"sha": "874dec25ed4c08d36f17d396b6872ca50313fc8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NGRlYzI1ZWQ0YzA4ZDM2ZjE3ZDM5NmI2ODcyY2E1MDMxM2ZjOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T21:01:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T21:01:17Z"}, "message": "Auto merge of #52115 - Dylan-DPC:feature/nll-liveness-regions, r=nikomatsakis\n\nonly compute liveness for variables whose types include regions\n\nCloses #52034\n\nr? @nikomatsakis", "tree": {"sha": "cae7979747cbbea6d7a39ec36bb75e58b7b0789f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cae7979747cbbea6d7a39ec36bb75e58b7b0789f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/874dec25ed4c08d36f17d396b6872ca50313fc8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/874dec25ed4c08d36f17d396b6872ca50313fc8e", "html_url": "https://github.com/rust-lang/rust/commit/874dec25ed4c08d36f17d396b6872ca50313fc8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/874dec25ed4c08d36f17d396b6872ca50313fc8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9416587a4b4270b5a6c88a46e264d7271007773", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9416587a4b4270b5a6c88a46e264d7271007773", "html_url": "https://github.com/rust-lang/rust/commit/d9416587a4b4270b5a6c88a46e264d7271007773"}, {"sha": "0770ff0500e25be2931217d7d6e095b0b0ec975d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0770ff0500e25be2931217d7d6e095b0b0ec975d", "html_url": "https://github.com/rust-lang/rust/commit/0770ff0500e25be2931217d7d6e095b0b0ec975d"}], "stats": {"total": 659, "additions": 302, "deletions": 357}, "files": [{"sha": "cbd9c9a4e1a85368906de6d91bd210585a731c7b", "filename": "src/librustc_mir/borrow_check/nll/liveness_map.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs?ref=874dec25ed4c08d36f17d396b6872ca50313fc8e", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! For the NLL computation, we need to compute liveness, but only for those\n+//! local variables whose types contain regions. The others are not of interest\n+//! to us. This file defines a new index type (LocalWithRegion) that indexes into\n+//! a list of \"variables whose type contain regions\". It also defines a map from\n+//! Local to LocalWithRegion and vice versa -- this map can be given to the\n+//! liveness code so that it only operates over variables with regions in their\n+//! types, instead of all variables.\n+\n+use rustc::ty::TypeFoldable;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::mir::{Mir, Local};\n+use util::liveness::LiveVariableMap;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+/// Map between Local and LocalWithRegion indices: this map is supplied to the\n+/// liveness code so that it will only analyze those variables whose types\n+/// contain regions.\n+crate struct NllLivenessMap {\n+    /// For each local variable, contains either None (if the type has no regions)\n+    /// or Some(i) with a suitable index.\n+    pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n+    /// For each LocalWithRegion, maps back to the original Local index.\n+    pub to_local: IndexVec<LocalWithRegion, Local>,\n+\n+}\n+\n+impl LiveVariableMap for NllLivenessMap {\n+\n+    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n+        self.from_local[local]\n+    }\n+\n+    type LiveVar = LocalWithRegion;\n+\n+    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n+        self.to_local[local]\n+    }\n+\n+    fn num_variables(&self) -> usize {\n+        self.to_local.len()\n+    }\n+}\n+\n+impl NllLivenessMap {\n+    /// Iterates over the variables in Mir and assigns each Local whose type contains\n+    /// regions a LocalWithRegion index. Returns a map for converting back and forth.\n+    pub fn compute(mir: &Mir) -> Self {\n+        let mut to_local = IndexVec::default();\n+        let from_local: IndexVec<Local,Option<_>> = mir\n+            .local_decls\n+            .iter_enumerated()\n+            .map(|(local, local_decl)| {\n+                if local_decl.ty.has_free_regions() {\n+                    Some(to_local.push(local))\n+                }\n+                    else {\n+                        None\n+                    }\n+            }).collect();\n+\n+        Self { from_local, to_local }\n+    }\n+}\n+\n+/// Index given to each local variable whose type contains a region.\n+newtype_index!(LocalWithRegion);"}, {"sha": "76f8fa206be5d76109c63b363e65193b556b8bb1", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=874dec25ed4c08d36f17d396b6872ca50313fc8e", "patch": "@@ -13,6 +13,7 @@ use borrow_check::location::{LocationIndex, LocationTable};\n use borrow_check::nll::facts::AllFactsExt;\n use borrow_check::nll::type_check::MirTypeckRegionConstraints;\n use borrow_check::nll::region_infer::values::RegionValueElements;\n+use borrow_check::nll::liveness_map::{NllLivenessMap, LocalWithRegion};\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -30,7 +31,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n use transform::MirSource;\n-use util::liveness::{LivenessResults, LocalSet};\n+use util::liveness::{LivenessResults, LiveVarSet};\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n@@ -45,6 +46,7 @@ crate mod region_infer;\n mod renumber;\n crate mod type_check;\n mod universal_regions;\n+crate mod liveness_map;\n \n mod constraints;\n \n@@ -103,7 +105,8 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let elements = &Rc::new(RegionValueElements::new(mir, universal_regions.len()));\n \n     // Run the MIR type-checker.\n-    let liveness = &LivenessResults::compute(mir);\n+    let liveness_map = NllLivenessMap::compute(&mir);\n+    let liveness = LivenessResults::compute(mir, &liveness_map);\n     let constraint_sets = type_check::type_check(\n         infcx,\n         param_env,\n@@ -193,7 +196,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // write unit-tests, as well as helping with debugging.\n     dump_mir_results(\n         infcx,\n-        liveness,\n+        &liveness,\n         MirSource::item(def_id),\n         &mir,\n         &regioncx,\n@@ -209,7 +212,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    liveness: &LivenessResults,\n+    liveness: &LivenessResults<LocalWithRegion>,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -219,14 +222,16 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n+    let map = &NllLivenessMap::compute(mir);\n+\n     let regular_liveness_per_location: FxHashMap<_, _> = mir\n         .basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n             let mut results = vec![];\n             liveness\n                 .regular\n-                .simulate_block(&mir, bb, |location, local_set| {\n+                .simulate_block(&mir, bb, map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results\n@@ -240,7 +245,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n             let mut results = vec![];\n             liveness\n                 .drop\n-                .simulate_block(&mir, bb, |location, local_set| {\n+                .simulate_block(&mir, bb, map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results\n@@ -405,7 +410,10 @@ impl ToRegionVid for RegionVid {\n     }\n }\n \n-fn live_variable_set(regular: &LocalSet, drops: &LocalSet) -> String {\n+fn live_variable_set(\n+    regular: &LiveVarSet<LocalWithRegion>,\n+    drops: &LiveVarSet<LocalWithRegion>\n+) -> String {\n     // sort and deduplicate:\n     let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();\n "}, {"sha": "2b9307db59af9feb3821760f2c52f059845d3d39", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=874dec25ed4c08d36f17d396b6872ca50313fc8e", "patch": "@@ -8,20 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::{NllLivenessMap, LocalWithRegion};\n use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::mir::Local;\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n-use util::liveness::LivenessResults;\n+use util::liveness::{LivenessResults, LiveVariableMap };\n \n use super::TypeChecker;\n \n@@ -36,7 +36,7 @@ use super::TypeChecker;\n pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    liveness: &LivenessResults,\n+    liveness: &LivenessResults<LocalWithRegion>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n@@ -47,6 +47,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n         flow_inits,\n         move_data,\n         drop_data: FxHashMap(),\n+        map: &NllLivenessMap::compute(mir),\n     };\n \n     for bb in mir.basic_blocks().indices() {\n@@ -63,10 +64,11 @@ where\n {\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n-    liveness: &'gen LivenessResults,\n+    liveness: &'gen LivenessResults<LocalWithRegion>,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+    map: &'gen NllLivenessMap,\n }\n \n struct DropData<'tcx> {\n@@ -84,17 +86,18 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         self.liveness\n             .regular\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n-                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    let local = self.map.from_live_var(live_local);\n+                    let live_local_ty = self.mir.local_decls[local].ty;\n                     Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n                 }\n             });\n \n-        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n+        let mut all_live_locals: Vec<(Location, Vec<LocalWithRegion>)> = vec![];\n         self.liveness\n             .drop\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n                 all_live_locals.push((location, live_locals.iter().collect()));\n             });\n         debug!(\n@@ -121,15 +124,17 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                     });\n                 }\n \n-                let mpi = self.move_data.rev_lookup.find_local(live_local);\n+                let local = self.map.from_live_var(live_local);\n+                let mpi = self.move_data.rev_lookup.find_local(local);\n                 if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n                     debug!(\n                         \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n                         self.move_data.move_paths[mpi],\n                         self.move_data.move_paths[initialized_child]\n                     );\n \n-                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    let local = self.map.from_live_var(live_local);\n+                    let live_local_ty = self.mir.local_decls[local].ty;\n                     self.add_drop_live_constraint(live_local, live_local_ty, location);\n                 }\n             }\n@@ -190,7 +195,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// particular this takes `#[may_dangle]` into account.\n     fn add_drop_live_constraint(\n         &mut self,\n-        dropped_local: Local,\n+        dropped_local: LocalWithRegion,\n         dropped_ty: Ty<'tcx>,\n         location: Location,\n     ) {"}, {"sha": "e23f9b20a10f8f43ab964c3a0a2374c5c0bde6f2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=874dec25ed4c08d36f17d396b6872ca50313fc8e", "patch": "@@ -19,6 +19,7 @@ use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::region_infer::values::{RegionValues, RegionValueElements};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::LocalWithRegion;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n@@ -109,7 +110,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     universal_regions: &UniversalRegions<'tcx>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n-    liveness: &LivenessResults,\n+    liveness: &LivenessResults<LocalWithRegion>,\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,"}, {"sha": "a43f17e40dfb632d4a53234d906c46e871f5cffc", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=874dec25ed4c08d36f17d396b6872ca50313fc8e", "patch": "@@ -66,7 +66,7 @@ use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n-use util::liveness::{self, LivenessMode};\n+use util::liveness::{self, IdentityMap, LivenessMode};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use std::collections::HashMap;\n@@ -130,7 +130,7 @@ struct SuspensionPoint {\n     state: u32,\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n-    storage_liveness: liveness::LocalSet,\n+    storage_liveness: liveness::LiveVarSet<Local>,\n }\n \n struct TransformVisitor<'a, 'tcx: 'a> {\n@@ -145,7 +145,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     remap: HashMap<Local, (Ty<'tcx>, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n-    storage_liveness: HashMap<BasicBlock, liveness::LocalSet>,\n+    storage_liveness: HashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n \n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint>,\n@@ -317,7 +317,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n     new_ret_local\n }\n \n-struct StorageIgnored(liveness::LocalSet);\n+struct StorageIgnored(liveness::LiveVarSet<Local>);\n \n impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     fn visit_statement(&mut self,\n@@ -332,7 +332,7 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     }\n }\n \n-struct BorrowedLocals(liveness::LocalSet);\n+struct BorrowedLocals(liveness::LiveVarSet<Local>);\n \n fn mark_as_borrowed<'tcx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n     match *place {\n@@ -361,12 +361,12 @@ impl<'tcx> Visitor<'tcx> for BorrowedLocals {\n     }\n }\n \n-fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                mir: &Mir<'tcx>,\n                                                source: MirSource,\n                                                movable: bool) ->\n-                                               (liveness::LocalSet,\n-                                                HashMap<BasicBlock, liveness::LocalSet>) {\n+                                               (liveness::LiveVarSet<Local>,\n+                                                HashMap<BasicBlock, liveness::LiveVarSet<Local>>) {\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n \n@@ -396,12 +396,23 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n-    let mut liveness = liveness::liveness_of_locals(mir, LivenessMode {\n-        include_regular_use: true,\n-        include_drops: true,\n-    });\n-    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &liveness);\n+    let mut set = liveness::LiveVarSet::new_empty(mir.local_decls.len());\n+    let mut liveness = liveness::liveness_of_locals(\n+        mir,\n+        LivenessMode {\n+            include_regular_use: true,\n+            include_drops: true,\n+        },\n+        &IdentityMap::new(mir),\n+    );\n+    liveness::dump_mir(\n+        tcx,\n+        \"generator_liveness\",\n+        source,\n+        mir,\n+        &IdentityMap::new(mir),\n+        &liveness,\n+    );\n \n     let mut storage_liveness_map = HashMap::new();\n \n@@ -468,7 +479,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             mir: &mut Mir<'tcx>)\n     -> (HashMap<Local, (Ty<'tcx>, usize)>,\n         GeneratorLayout<'tcx>,\n-        HashMap<BasicBlock, liveness::LocalSet>)\n+        HashMap<BasicBlock, liveness::LiveVarSet<Local>>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,"}, {"sha": "6c5b38a806e57b1a9ec8426297741fb0b34cbd3f", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 166, "deletions": 79, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874dec25ed4c08d36f17d396b6872ca50313fc8e/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=874dec25ed4c08d36f17d396b6872ca50313fc8e", "patch": "@@ -33,32 +33,75 @@\n //! generator yield points, all pre-existing references are invalidated, so this\n //! doesn't matter).\n \n-use rustc::mir::*;\n+use rustc::mir::visit::MirVisitable;\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc::mir::Local;\n+use rustc::mir::*;\n+use rustc::ty::{item_path, TyCtxt};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n-use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n-use rustc::ty::item_path;\n-use rustc::mir::visit::MirVisitable;\n-use std::path::{Path, PathBuf};\n use std::fs;\n-use rustc::ty::TyCtxt;\n use std::io::{self, Write};\n+use std::path::{Path, PathBuf};\n use transform::MirSource;\n+use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n \n-pub type LocalSet = IdxSetBuf<Local>;\n+pub type LiveVarSet<V> = IdxSetBuf<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks. You can use `simulate_block` to obtain the\n /// intra-block results.\n-pub struct LivenessResult {\n+///\n+/// The `V` type defines the set of variables that we computed\n+/// liveness for. This is often `Local`, in which case we computed\n+/// liveness for all variables -- but it can also be some other type,\n+/// which indicates a subset of the variables within the graph.\n+pub struct LivenessResult<V: Idx> {\n     /// Liveness mode in use when these results were computed.\n     pub mode: LivenessMode,\n \n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LocalSet>,\n+    pub outs: IndexVec<BasicBlock, LiveVarSet<V>>,\n+}\n+\n+/// Defines the mapping to/from the MIR local variables (`Local`) to\n+/// the \"live variable indices\" we are using in a particular\n+/// computation.\n+pub trait LiveVariableMap {\n+    type LiveVar;\n+\n+    fn from_local(&self, local: Local) -> Option<Self::LiveVar>;\n+    fn from_live_var(&self, local: Self::LiveVar) -> Local;\n+    fn num_variables(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+pub struct IdentityMap<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx> IdentityMap<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>) -> Self {\n+        Self { mir }\n+    }\n+}\n+\n+impl<'a, 'tcx> LiveVariableMap for IdentityMap<'a, 'tcx> {\n+    type LiveVar = Local;\n+\n+    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n+        Some(local)\n+    }\n+\n+    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n+        local\n+    }\n+\n+    fn num_variables(&self) -> usize {\n+        self.mir.local_decls.len()\n+    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -80,25 +123,29 @@ pub struct LivenessMode {\n }\n \n /// A combination of liveness results, used in NLL.\n-pub struct LivenessResults {\n+pub struct LivenessResults<V: Idx> {\n     /// Liveness results where a regular use makes a variable X live,\n     /// but not a drop.\n-    pub regular: LivenessResult,\n+    pub regular: LivenessResult<V>,\n \n     /// Liveness results where a drop makes a variable X live,\n     /// but not a regular use.\n-    pub drop: LivenessResult,\n+    pub drop: LivenessResult<V>,\n }\n \n-impl LivenessResults {\n-    pub fn compute<'tcx>(mir: &Mir<'tcx>) -> LivenessResults {\n+impl<V: Idx> LivenessResults<V> {\n+    pub fn compute<'tcx>(\n+        mir: &Mir<'tcx>,\n+        map: &impl LiveVariableMap<LiveVar = V>,\n+    ) -> LivenessResults<V> {\n         LivenessResults {\n             regular: liveness_of_locals(\n                 &mir,\n                 LivenessMode {\n                     include_regular_use: true,\n                     include_drops: false,\n                 },\n+                map,\n             ),\n \n             drop: liveness_of_locals(\n@@ -107,6 +154,7 @@ impl LivenessResults {\n                     include_regular_use: false,\n                     include_drops: true,\n                 },\n+                map,\n             ),\n         }\n     }\n@@ -115,19 +163,26 @@ impl LivenessResults {\n /// Compute which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n-pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult {\n-    let locals = mir.local_decls.len();\n-    let def_use: IndexVec<_, _> = mir.basic_blocks()\n+pub fn liveness_of_locals<'tcx, V: Idx>(\n+    mir: &Mir<'tcx>,\n+    mode: LivenessMode,\n+    map: &impl LiveVariableMap<LiveVar = V>,\n+) -> LivenessResult<V> {\n+    let num_live_vars = map.num_variables();\n+\n+    let def_use: IndexVec<_, DefsUses<V>> = mir\n+        .basic_blocks()\n         .iter()\n-        .map(|b| block(mode, b, locals))\n+        .map(|b| block(mode, map, b, num_live_vars))\n         .collect();\n \n-    let mut outs: IndexVec<_, _> = mir.basic_blocks()\n+    let mut outs: IndexVec<_, LiveVarSet<V>> = mir\n+        .basic_blocks()\n         .indices()\n-        .map(|_| LocalSet::new_empty(locals))\n+        .map(|_| LiveVarSet::new_empty(num_live_vars))\n         .collect();\n \n-    let mut bits = LocalSet::new_empty(locals);\n+    let mut bits = LiveVarSet::new_empty(num_live_vars);\n \n     // queue of things that need to be re-processed, and a set containing\n     // the things currently in the queue\n@@ -156,14 +211,19 @@ pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> Liveness\n     LivenessResult { mode, outs }\n }\n \n-impl LivenessResult {\n+impl<V: Idx> LivenessResult<V> {\n     /// Walks backwards through the statements/terminator in the given\n     /// basic block `block`.  At each point within `block`, invokes\n     /// the callback `op` with the current location and the set of\n     /// variables that are live on entry to that location.\n-    pub fn simulate_block<'tcx, OP>(&self, mir: &Mir<'tcx>, block: BasicBlock, mut callback: OP)\n-    where\n-        OP: FnMut(Location, &LocalSet),\n+    pub fn simulate_block<'tcx, OP>(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        block: BasicBlock,\n+        map: &impl LiveVariableMap<LiveVar = V>,\n+        mut callback: OP,\n+    ) where\n+        OP: FnMut(Location, &LiveVarSet<V>),\n     {\n         let data = &mir[block];\n \n@@ -179,18 +239,23 @@ impl LivenessResult {\n             block,\n             statement_index,\n         };\n-        let locals = mir.local_decls.len();\n+        let num_live_vars = map.num_variables();\n         let mut visitor = DefsUsesVisitor {\n             mode: self.mode,\n+            map,\n             defs_uses: DefsUses {\n-                defs: LocalSet::new_empty(locals),\n-                uses: LocalSet::new_empty(locals),\n+                defs: LiveVarSet::new_empty(num_live_vars),\n+                uses: LiveVarSet::new_empty(num_live_vars),\n             },\n         };\n         // Visit the various parts of the basic block in reverse. If we go\n         // forward, the logic in `add_def` and `add_use` would be wrong.\n-        visitor.update_bits_and_do_callback(terminator_location, &data.terminator, &mut bits,\n-                                            &mut callback);\n+        visitor.update_bits_and_do_callback(\n+            terminator_location,\n+            &data.terminator,\n+            &mut bits,\n+            &mut callback,\n+        );\n \n         // Compute liveness before each statement (in rev order) and invoke callback.\n         for statement in data.statements.iter().rev() {\n@@ -200,8 +265,12 @@ impl LivenessResult {\n                 statement_index,\n             };\n             visitor.defs_uses.clear();\n-            visitor.update_bits_and_do_callback(statement_location, statement, &mut bits,\n-                                                &mut callback);\n+            visitor.update_bits_and_do_callback(\n+                statement_location,\n+                statement,\n+                &mut bits,\n+                &mut callback,\n+            );\n         }\n     }\n }\n@@ -225,11 +294,9 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Opti\n         // We let Call define the result in both the success and\n         // unwind cases. This is not really correct, however it\n         // does not seem to be observable due to the way that we\n-        // generate MIR. See the test case\n-        // `mir-opt/nll/liveness-call-subtlety.rs`. To do things\n-        // properly, we would apply the def in call only to the\n-        // input from the success path and not the unwind\n-        // path. -nmatsakis\n+        // generate MIR. To do things properly, we would apply\n+        // the def in call only to the input from the success\n+        // path and not the unwind path. -nmatsakis\n         PlaceContext::Call |\n \n         // Storage live and storage dead aren't proper defines, but we can ignore\n@@ -281,28 +348,33 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Opti\n     }\n }\n \n-struct DefsUsesVisitor {\n+struct DefsUsesVisitor<'lv, V, M>\n+where\n+    V: Idx,\n+    M: LiveVariableMap<LiveVar = V> + 'lv,\n+{\n     mode: LivenessMode,\n-    defs_uses: DefsUses,\n+    map: &'lv M,\n+    defs_uses: DefsUses<V>,\n }\n \n #[derive(Eq, PartialEq, Clone)]\n-struct DefsUses {\n-    defs: LocalSet,\n-    uses: LocalSet,\n+struct DefsUses<V: Idx> {\n+    defs: LiveVarSet<V>,\n+    uses: LiveVarSet<V>,\n }\n \n-impl DefsUses {\n+impl<V: Idx> DefsUses<V> {\n     fn clear(&mut self) {\n         self.uses.clear();\n         self.defs.clear();\n     }\n \n-    fn apply(&self, bits: &mut LocalSet) -> bool {\n+    fn apply(&self, bits: &mut LiveVarSet<V>) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n \n-    fn add_def(&mut self, index: Local) {\n+    fn add_def(&mut self, index: V) {\n         // If it was used already in the block, remove that use\n         // now that we found a definition.\n         //\n@@ -316,7 +388,7 @@ impl DefsUses {\n         self.defs.add(&index);\n     }\n \n-    fn add_use(&mut self, index: Local) {\n+    fn add_use(&mut self, index: V) {\n         // Inverse of above.\n         //\n         // Example:\n@@ -332,44 +404,57 @@ impl DefsUses {\n     }\n }\n \n-impl DefsUsesVisitor {\n+impl<'lv, V, M> DefsUsesVisitor<'lv, V, M>\n+where\n+    V: Idx,\n+    M: LiveVariableMap<LiveVar = V>,\n+{\n     /// Update `bits` with the effects of `value` and call `callback`. We\n     /// should always visit in reverse order. This method assumes that we have\n     /// not visited anything before; if you have, clear `bits` first.\n-    fn update_bits_and_do_callback<'tcx, OP>(&mut self, location: Location,\n-                                             value: &impl MirVisitable<'tcx>, bits: &mut LocalSet,\n-                                             callback: &mut OP)\n-    where\n-        OP: FnMut(Location, &LocalSet),\n+    fn update_bits_and_do_callback<'tcx, OP>(\n+        &mut self,\n+        location: Location,\n+        value: &impl MirVisitable<'tcx>,\n+        bits: &mut LiveVarSet<V>,\n+        callback: &mut OP,\n+    ) where\n+        OP: FnMut(Location, &LiveVarSet<V>),\n     {\n         value.apply(location, self);\n         self.defs_uses.apply(bits);\n         callback(location, bits);\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n+impl<'tcx, 'lv, V, M> Visitor<'tcx> for DefsUsesVisitor<'lv, V, M>\n+where\n+    V: Idx,\n+    M: LiveVariableMap<LiveVar = V>,\n+{\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        match categorize(context, self.mode) {\n-            Some(DefUse::Def) => {\n-                self.defs_uses.add_def(local);\n+        if let Some(v_index) = self.map.from_local(local) {\n+            match categorize(context, self.mode) {\n+                Some(DefUse::Def) => self.defs_uses.add_def(v_index),\n+                Some(DefUse::Use) => self.defs_uses.add_use(v_index),\n+                None => (),\n             }\n-\n-            Some(DefUse::Use) => {\n-                self.defs_uses.add_use(local);\n-            }\n-\n-            None => {}\n         }\n     }\n }\n \n-fn block<'tcx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses {\n+fn block<'tcx, V: Idx>(\n+    mode: LivenessMode,\n+    map: &impl LiveVariableMap<LiveVar = V>,\n+    b: &BasicBlockData<'tcx>,\n+    locals: usize,\n+) -> DefsUses<V> {\n     let mut visitor = DefsUsesVisitor {\n         mode,\n+        map,\n         defs_uses: DefsUses {\n-            defs: LocalSet::new_empty(locals),\n-            uses: LocalSet::new_empty(locals),\n+            defs: LiveVarSet::new_empty(locals),\n+            uses: LiveVarSet::new_empty(locals),\n         },\n     };\n \n@@ -388,12 +473,13 @@ fn block<'tcx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> D\n     visitor.defs_uses\n }\n \n-pub fn dump_mir<'a, 'tcx>(\n+pub fn dump_mir<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult,\n+    map: &impl LiveVariableMap<LiveVar = V>,\n+    result: &LivenessResult<V>,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -402,16 +488,17 @@ pub fn dump_mir<'a, 'tcx>(\n         // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n+    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, map, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx>(\n+fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult,\n+    map: &dyn LiveVariableMap<LiveVar = V>,\n+    result: &LivenessResult<V>,\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n@@ -423,25 +510,25 @@ fn dump_matched_mir_node<'a, 'tcx>(\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, &mut file, result)?;\n+        write_mir_fn(tcx, source, mir, map, &mut file, result)?;\n         Ok(())\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(\n+pub fn write_mir_fn<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource,\n     mir: &Mir<'tcx>,\n+    map: &dyn LiveVariableMap<LiveVar = V>,\n     w: &mut dyn Write,\n-    result: &LivenessResult,\n+    result: &LivenessResult<V>,\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n-            let live: Vec<String> = mir.local_decls\n-                .indices()\n-                .filter(|i| result[block].contains(i))\n-                .map(|i| format!(\"{:?}\", i))\n+        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet<V>>| {\n+            let live: Vec<String> = result[block].iter()\n+                .map(|v| map.from_live_var(v))\n+                .map(|local| format!(\"{:?}\", local))\n                 .collect();\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n         };"}, {"sha": "5fdea4208df996ec156ca19e8416cd7f1c581c95", "filename": "src/test/mir-opt/nll/liveness-call-subtlety.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags:-Zborrowck=mir\n-\n-fn can_panic() -> Box<usize> {\n-    Box::new(44)\n-}\n-\n-fn main() {\n-    let mut x = Box::new(22);\n-    x = can_panic();\n-}\n-\n-// Check that:\n-// - `_1` is the variable corresponding to `x`\n-// and\n-// - `_1` is live when `can_panic` is called (because it may be dropped)\n-//\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-//    bb0: {\n-//            | Live variables on entry to bb0[0]: []\n-//        StorageLive(_1);\n-//            | Live variables on entry to bb0[1]: []\n-//        _1 = const <std::boxed::Box<T>>::new(const 22usize) -> [return: bb2, unwind: bb1];\n-//            | Live variables on exit from bb0: [_1 (drop)]\n-//    }\n-// END rustc.main.nll.0.mir\n-// START rustc.main.nll.0.mir\n-//    bb2: {\n-//            | Live variables on entry to bb2[0]: [_1 (drop)]\n-//        StorageLive(_2);\n-//            | Live variables on entry to bb2[1]: [_1 (drop)]\n-//        _2 = const can_panic() -> [return: bb3, unwind: bb4];\n-//            | Live variables on exit from bb2: [_1 (drop), _2]\n-//    }\n-// END rustc.main.nll.0.mir"}, {"sha": "001499b657de955af53762ee984fca5058825084", "filename": "src/test/mir-opt/nll/liveness-drop-intra-block.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags:-Zborrowck=mir\n-\n-#![allow(warnings)]\n-\n-fn use_x(_: usize) -> bool { true }\n-\n-fn main() {\n-    let mut x = 22;\n-    loop {\n-        // Key point: `x` not live on entry to this basic block.\n-        x = 55;\n-        if use_x(x) { break; }\n-    }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-//    bb3: {\n-//            | Live variables on entry to bb3[0]: []\n-//        _1 = const 55usize;\n-//            | Live variables on entry to bb3[1]: [_1]\n-//        StorageLive(_3);\n-//            | Live variables on entry to bb3[2]: [_1]\n-//        StorageLive(_4);\n-//            | Live variables on entry to bb3[3]: [_1]\n-//        _4 = _1;\n-//            | Live variables on entry to bb3[4]: [_4]\n-//        _3 = const use_x(move _4) -> [return: bb4, unwind: bb1];\n-//            | Live variables on exit from bb3: [_3]\n-//    }\n-// END rustc.main.nll.0.mir"}, {"sha": "fbe20d76ea721e4406c681aa9bfcce3926138ed7", "filename": "src/test/mir-opt/nll/liveness-interblock.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags:-Zborrowck=mir\n-\n-fn cond() -> bool { false }\n-\n-fn make_live(_: usize) { }\n-\n-fn make_dead() { }\n-\n-fn main() {\n-    let x = 5;\n-\n-    if cond() {\n-        make_live(x);\n-    } else {\n-        // x should be dead on entry to this block\n-        make_dead();\n-    }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-//     bb3: {\n-//             | Live variables on entry to bb3[0]: [_1]\n-//         StorageLive(_4);\n-//             | Live variables on entry to bb3[1]: [_1]\n-//         _4 = _1;\n-//             | Live variables on entry to bb3[2]: [_4]\n-//         _3 = const make_live(move _4) -> [return: bb5, unwind: bb1];\n-//             | Live variables on exit from bb3: []\n-//     }\n-// END rustc.main.nll.0.mir\n-// START rustc.main.nll.0.mir\n-//     bb4: {\n-//             | Live variables on entry to bb4[0]: []\n-//         _5 = const make_dead() -> [return: bb6, unwind: bb1];\n-//             | Live variables on exit from bb4: []\n-//     }\n-// END rustc.main.nll.0.mir"}, {"sha": "187d9e6ca899304256d060345f37b9510c85d781", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Basic test for liveness constraints: the region (`R1`) that appears\n-// in the type of `p` includes the points after `&v[0]` up to (but not\n-// including) the call to `use_x`. The `else` branch is not included.\n-\n-// compile-flags:-Zborrowck=mir -Zverbose\n-//                              ^^^^^^^^^ force compiler to dump more region information\n-\n-#![allow(warnings)]\n-\n-fn use_x(_: usize) -> bool { true }\n-\n-fn main() {\n-    let mut v = [1, 2, 3];\n-    let p = &v[0];\n-    if true {\n-        use_x(*p);\n-    } else {\n-        use_x(22);\n-    }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-// | '_#2r    | {bb2[0..=1], bb3[0..=1]}\n-// | '_#3r    | {bb2[1], bb3[0..=1]}\n-// ...\n-//             let _2: &'_#3r usize;\n-// END rustc.main.nll.0.mir\n-// START rustc.main.nll.0.mir\n-//    bb2: {\n-//            | Live variables on entry to bb2[0]: [_1, _3]\n-//        _2 = &'_#2r _1[_3];\n-//            | Live variables on entry to bb2[1]: [_2]\n-//        switchInt(const true) -> [false: bb4, otherwise: bb3];\n-//            | Live variables on exit from bb2: [_2]\n-//    }\n-// END rustc.main.nll.0.mir\n-// START rustc.main.nll.0.mir\n-//    bb3: {\n-//            | Live variables on entry to bb3[0]: [_2]\n-//        StorageLive(_7);\n-//            | Live variables on entry to bb3[1]: [_2]\n-//        _7 = (*_2);\n-//            | Live variables on entry to bb3[2]: [_7]\n-//        _6 = const use_x(move _7) -> [return: bb5, unwind: bb1];\n-//            | Live variables on exit from bb3: []\n-//    }\n-// END rustc.main.nll.0.mir"}, {"sha": "62064fa94f2fe9ceaa0968ff28e743d76c9ce3e3", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test for the subregion constraints. In this case, the region R3 on\n-// `p` includes two disjoint regions of the control-flow graph. The\n-// borrows in `&v[0]` and `&v[1]` each (in theory) have to outlive R3,\n-// but only at a particular point, and hence they wind up including\n-// distinct regions.\n-//\n-// FIXME(#43234) -- Well, this used to be true, but we modified NLL\n-// for the time being to not take location into account.\n-\n-// compile-flags:-Zborrowck=mir -Zverbose\n-//                              ^^^^^^^^^ force compiler to dump more region information\n-\n-#![allow(warnings)]\n-\n-fn use_x(_: usize) -> bool { true }\n-\n-fn main() {\n-    let mut v = [1, 2, 3];\n-    let mut p = &v[0];\n-    if true {\n-        use_x(*p);\n-    } else {\n-        use_x(22);\n-    }\n-\n-    p = &v[1];\n-    use_x(*p);\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-// | '_#2r    | {bb2[0..=1], bb3[0..=1], bb8[2..=4]}\n-// ...\n-// | '_#4r    | {bb2[1], bb3[0..=1], bb8[1..=4]}\n-// | '_#5r    | {bb2[1], bb3[0..=1], bb8[2..=4]}\n-// ...\n-// let mut _2: &'_#5r usize;\n-// ...\n-// _2 = &'_#2r _1[_3];\n-// ...\n-// _2 = &'_#4r (*_10);\n-// END rustc.main.nll.0.mir"}]}