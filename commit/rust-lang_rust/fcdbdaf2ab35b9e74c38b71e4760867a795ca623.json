{"sha": "fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZGJkYWYyYWIzNWI5ZTc0YzM4YjcxZTQ3NjA4NjdhNzk1Y2E2MjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-26T23:33:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:44Z"}, "message": "Convert the rest of rustc::lib::llvm to istrs. Issue #855", "tree": {"sha": "0ea55d88e591b3491c1b851add288decbf14f17f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ea55d88e591b3491c1b851add288decbf14f17f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "html_url": "https://github.com/rust-lang/rust/commit/fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "html_url": "https://github.com/rust-lang/rust/commit/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056"}], "stats": {"total": 99, "additions": 50, "deletions": 49}, "files": [{"sha": "0e4f957b5ba5e6c0e1d923021e351e5632e56993", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "patch": "@@ -91,7 +91,7 @@ mod write {\n         if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }\n         link_intrinsics(sess, llmod);\n         let pm = mk_pass_manager();\n-        let td = mk_target_data(istr::to_estr(x86::get_data_layout()));\n+        let td = mk_target_data(x86::get_data_layout());\n         llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n         // TODO: run the linter here also, once there are llvm-c bindings for\n         // it."}, {"sha": "9bc7dc932f53286068c06a9be7bda59edc466b30", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "patch": "@@ -899,26 +899,26 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n \n /* Memory-managed object interface to type handles. */\n \n-obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n+obj type_names(type_names: std::map::hashmap<TypeRef, istr>,\n                named_types: std::map::hashmap<istr, TypeRef>) {\n \n-    fn associate(s: str, t: TypeRef) {\n-        assert (!named_types.contains_key(istr::from_estr(s)));\n+    fn associate(s: &istr, t: TypeRef) {\n+        assert (!named_types.contains_key(s));\n         assert (!type_names.contains_key(t));\n         type_names.insert(t, s);\n-        named_types.insert(istr::from_estr(s), t);\n+        named_types.insert(s, t);\n     }\n \n     fn type_has_name(t: TypeRef) -> bool { ret type_names.contains_key(t); }\n \n-    fn get_name(t: TypeRef) -> str { ret type_names.get(t); }\n+    fn get_name(t: TypeRef) -> istr { ret type_names.get(t); }\n \n-    fn name_has_type(s: str) -> bool {\n-        ret named_types.contains_key(istr::from_estr(s));\n+    fn name_has_type(s: &istr) -> bool {\n+        ret named_types.contains_key(s);\n     }\n \n-    fn get_type(s: str) -> TypeRef {\n-        ret named_types.get(istr::from_estr(s));\n+    fn get_type(s: &istr) -> TypeRef {\n+        ret named_types.get(s);\n     }\n }\n \n@@ -931,29 +931,30 @@ fn mk_type_names() -> type_names {\n \n     let hasher: std::map::hashfn<TypeRef> = hash;\n     let eqer: std::map::eqfn<TypeRef> = eq;\n-    let tn = std::map::mk_hashmap::<TypeRef, str>(hasher, eqer);\n+    let tn = std::map::mk_hashmap::<TypeRef, istr>(hasher, eqer);\n \n     ret type_names(tn, nt);\n }\n \n-fn type_to_str(names: type_names, ty: TypeRef) -> str {\n+fn type_to_str(names: type_names, ty: TypeRef) -> istr {\n     ret type_to_str_inner(names, [], ty);\n }\n \n fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n-   str {\n+   istr {\n \n     if names.type_has_name(ty) { ret names.get_name(ty); }\n \n     let outer = outer0 + [ty];\n \n     let kind: int = llvm::LLVMGetTypeKind(ty);\n \n-    fn tys_str(names: type_names, outer: &[TypeRef], tys: &[TypeRef]) -> str {\n-        let s: str = \"\";\n+    fn tys_str(names: type_names, outer: &[TypeRef],\n+               tys: &[TypeRef]) -> istr {\n+        let s: istr = ~\"\";\n         let first: bool = true;\n         for t: TypeRef in tys {\n-            if first { first = false; } else { s += \", \"; }\n+            if first { first = false; } else { s += ~\", \"; }\n             s += type_to_str_inner(names, outer, t);\n         }\n         ret s;\n@@ -968,53 +969,53 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       // horrible, horrible. Complete as needed.\n \n       0 {\n-        ret \"Void\";\n+        ret ~\"Void\";\n       }\n-      1 { ret \"Float\"; }\n-      2 { ret \"Double\"; }\n-      3 { ret \"X86_FP80\"; }\n-      4 { ret \"FP128\"; }\n-      5 { ret \"PPC_FP128\"; }\n-      6 { ret \"Label\"; }\n+      1 { ret ~\"Float\"; }\n+      2 { ret ~\"Double\"; }\n+      3 { ret ~\"X86_FP80\"; }\n+      4 { ret ~\"FP128\"; }\n+      5 { ret ~\"PPC_FP128\"; }\n+      6 { ret ~\"Label\"; }\n \n \n \n       7 {\n-        ret \"i\" + istr::to_estr(std::int::str(\n-            llvm::LLVMGetIntTypeWidth(ty) as int));\n+        ret ~\"i\" + std::int::str(\n+            llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n \n \n \n       8 {\n-        let s = \"fn(\";\n+        let s = ~\"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args: uint = llvm::LLVMCountParamTypes(ty);\n         let args: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_args);\n         llvm::LLVMGetParamTypes(ty, vec::to_ptr(args));\n         s += tys_str(names, outer, args);\n-        s += \") -> \";\n+        s += ~\") -> \";\n         s += type_to_str_inner(names, outer, out_ty);\n         ret s;\n       }\n \n \n \n       9 {\n-        let s: str = \"{\";\n+        let s: istr = ~\"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n         let elts: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_elts);\n         llvm::LLVMGetStructElementTypes(ty, vec::to_ptr(elts));\n         s += tys_str(names, outer, elts);\n-        s += \"}\";\n+        s += ~\"}\";\n         ret s;\n       }\n \n \n \n       10 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n-        ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n+        ret ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\"]\";\n       }\n \n \n@@ -1025,20 +1026,20 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n             i += 1u;\n             if tout as int == ty as int {\n                 let n: uint = vec::len::<TypeRef>(outer0) - i;\n-                ret \"*\\\\\" + istr::to_estr(std::int::str(n as int));\n+                ret ~\"*\\\\\" + std::int::str(n as int);\n             }\n         }\n-        ret \"*\" +\n+        ret ~\"*\" +\n                 type_to_str_inner(names, outer, llvm::LLVMGetElementType(ty));\n       }\n \n \n \n       12 {\n-        ret \"Opaque\";\n+        ret ~\"Opaque\";\n       }\n-      13 { ret \"Vector\"; }\n-      14 { ret \"Metadata\"; }\n+      13 { ret ~\"Vector\"; }\n+      14 { ret ~\"Metadata\"; }\n       _ { log_err #fmt[\"unknown TypeKind %d\", kind as int]; fail; }\n     }\n }\n@@ -1068,8 +1069,8 @@ resource target_data_res(TD: TargetDataRef) {\n \n type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n-fn mk_target_data(string_rep: str) -> target_data {\n-    let lltd = istr::as_buf(istr::from_estr(string_rep), { |buf|\n+fn mk_target_data(string_rep: &istr) -> target_data {\n+    let lltd = istr::as_buf(string_rep, { |buf|\n         llvm::LLVMCreateTargetData(buf)\n     });\n     ret {lltd: lltd, dtor: @target_data_res(lltd)};"}, {"sha": "200fd042416d76b5368dc2de26d8b2ebb8fe421d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "patch": "@@ -6306,7 +6306,7 @@ fn make_common_glue(sess: &session::session, output: &str) {\n     let _: () = istr::as_buf(x86::get_target_triple(), { |buf|\n         llvm::LLVMSetTarget(llmod, buf)\n     });\n-    mk_target_data(istr::to_estr(x86::get_data_layout()));\n+    mk_target_data(x86::get_data_layout());\n     declare_intrinsics(llmod);\n     let _: () = istr::as_buf(x86::get_module_asm(), { |buf|\n         llvm::LLVMSetModuleInlineAsm(llmod, buf)\n@@ -6411,14 +6411,14 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n     let _: () = istr::as_buf(x86::get_target_triple(), { |buf|\n         llvm::LLVMSetTarget(llmod, buf)\n     });\n-    let td = mk_target_data(istr::to_estr(x86::get_data_layout()));\n+    let td = mk_target_data(x86::get_data_layout());\n     let tn = mk_type_names();\n     let intrinsics = declare_intrinsics(llmod);\n     let task_type = T_task();\n     let taskptr_type = T_ptr(task_type);\n-    tn.associate(\"taskptr\", taskptr_type);\n+    tn.associate(~\"taskptr\", taskptr_type);\n     let tydesc_type = T_tydesc(taskptr_type);\n-    tn.associate(\"tydesc\", tydesc_type);\n+    tn.associate(~\"tydesc\", tydesc_type);\n     let glues = make_glues(llmod, taskptr_type);\n     let hasher = ty::hash_ty;\n     let eqer = ty::eq_ty;"}, {"sha": "f193f1e5623a02edda71aa42b23f28b10a8f43d2", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbdaf2ab35b9e74c38b71e4760867a795ca623/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=fcdbdaf2ab35b9e74c38b71e4760867a795ca623", "patch": "@@ -439,7 +439,7 @@ fn rslt(bcx: @block_ctxt, val: ValueRef) -> result {\n }\n \n fn ty_str(tn: type_names, t: TypeRef) -> str {\n-    ret lib::llvm::type_to_str(tn, t);\n+    ret istr::to_estr(lib::llvm::type_to_str(tn, t));\n }\n \n fn val_ty(v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n@@ -609,23 +609,23 @@ fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n }\n \n fn T_glue_fn(cx: &crate_ctxt) -> TypeRef {\n-    let s = \"glue_fn\";\n+    let s = ~\"glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_cmp_glue_fn(cx: &crate_ctxt) -> TypeRef {\n-    let s = \"cmp_glue_fn\";\n+    let s = ~\"cmp_glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_copy_glue_fn(cx: &crate_ctxt) -> TypeRef {\n-    let s = \"copy_glue_fn\";\n+    let s = ~\"copy_glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_copy_glue);\n     cx.tn.associate(s, t);\n@@ -736,7 +736,7 @@ fn T_taskptr(cx: &crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n \n // This type must never be used directly; it must always be cast away.\n fn T_typaram(tn: &type_names) -> TypeRef {\n-    let s = \"typaram\";\n+    let s = ~\"typaram\";\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_i8();\n     tn.associate(s, t);\n@@ -755,23 +755,23 @@ fn T_closure_ptr(cx: &crate_ctxt, llbindings_ty: TypeRef, n_ty_params: uint)\n }\n \n fn T_opaque_closure_ptr(cx: &crate_ctxt) -> TypeRef {\n-    let s = \"*closure\";\n+    let s = ~\"*closure\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_closure_ptr(cx, T_nil(), 0u);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_tag(tn: &type_names, size: uint) -> TypeRef {\n-    let s = \"tag_\" + istr::to_estr(uint::to_str(size, 10u));\n+    let s = ~\"tag_\" + uint::to_str(size, 10u);\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_struct([T_int(), T_array(T_i8(), size)]);\n     tn.associate(s, t);\n     ret t;\n }\n \n fn T_opaque_tag(tn: &type_names) -> TypeRef {\n-    let s = \"opaque_tag\";\n+    let s = ~\"opaque_tag\";\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_struct([T_int(), T_i8()]);\n     tn.associate(s, t);"}]}