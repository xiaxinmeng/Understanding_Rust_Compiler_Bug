{"sha": "b11733534d95aebe0b4f949f8e4c8f21c312f108", "node_id": "C_kwDOAAsO6NoAKGIxMTczMzUzNGQ5NWFlYmUwYjRmOTQ5ZjhlNGM4ZjIxYzMxMmYxMDg", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-12-01T17:17:50Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-01-21T13:48:10Z"}, "message": "Remove a span from hir::ExprKind::MethodCall", "tree": {"sha": "12ff6db964e10b1c2e6e8f0d19a23d06c0de77c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12ff6db964e10b1c2e6e8f0d19a23d06c0de77c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b11733534d95aebe0b4f949f8e4c8f21c312f108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b11733534d95aebe0b4f949f8e4c8f21c312f108", "html_url": "https://github.com/rust-lang/rust/commit/b11733534d95aebe0b4f949f8e4c8f21c312f108", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b11733534d95aebe0b4f949f8e4c8f21c312f108/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84e918971d643c6a33067d5125214ab800ce5307", "url": "https://api.github.com/repos/rust-lang/rust/commits/84e918971d643c6a33067d5125214ab800ce5307", "html_url": "https://github.com/rust-lang/rust/commit/84e918971d643c6a33067d5125214ab800ce5307"}], "stats": {"total": 431, "additions": 211, "deletions": 220}, "files": [{"sha": "f04dc85b28a9838351920b9499cdee3f19d2a050", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -56,12 +56,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ImplTraitContext::disallowed(),\n                     ));\n                     let args = self.lower_exprs(args);\n-                    hir::ExprKind::MethodCall(\n-                        hir_seg,\n-                        self.lower_span(seg.ident.span),\n-                        args,\n-                        self.lower_span(span),\n-                    )\n+                    hir::ExprKind::MethodCall(hir_seg, args, self.lower_span(span))\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                     let binop = self.lower_binop(binop);"}, {"sha": "4e6fac5eb287c4548ad223e19c06fb10ad9ded5d", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1669,21 +1669,21 @@ pub enum ExprKind<'hir> {\n     Call(&'hir Expr<'hir>, &'hir [Expr<'hir>]),\n     /// A method call (e.g., `x.foo::<'static, Bar, Baz>(a, b, c, d)`).\n     ///\n-    /// The `PathSegment`/`Span` represent the method name and its generic arguments\n+    /// The `PathSegment` represents the method name and its generic arguments\n     /// (within the angle brackets).\n-    /// The first element of the vector of `Expr`s is the expression that evaluates\n+    /// The first element of the `&[Expr]` is the expression that evaluates\n     /// to the object on which the method is being called on (the receiver),\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n+    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d], span)`.\n     /// The final `Span` represents the span of the function and arguments\n     /// (e.g. `foo::<Bar, Baz>(a, b, c, d)` in `x.foo::<Bar, Baz>(a, b, c, d)`\n     ///\n     /// To resolve the called method to a `DefId`, call [`type_dependent_def_id`] with\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../ty/struct.TypeckResults.html#method.type_dependent_def_id\n-    MethodCall(&'hir PathSegment<'hir>, Span, &'hir [Expr<'hir>], Span),\n+    MethodCall(&'hir PathSegment<'hir>, &'hir [Expr<'hir>], Span),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -3257,7 +3257,7 @@ impl<'hir> Node<'hir> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Block<'static>, 48);\n-    rustc_data_structures::static_assert_size!(super::Expr<'static>, 64);\n+    rustc_data_structures::static_assert_size!(super::Expr<'static>, 56);\n     rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 80);"}, {"sha": "1d10e79d3007b08eeee1b15f14a854ded24ee924", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1149,7 +1149,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, _, arguments, _) => {\n+        ExprKind::MethodCall(ref segment, arguments, _) => {\n             visitor.visit_path_segment(expression.span, segment);\n             walk_list!(visitor, visit_expr, arguments);\n         }"}, {"sha": "9e54122f8dd5cba9509ef4b936aeca88272278f2", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1427,7 +1427,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::Call(ref func, ref args) => {\n                 self.print_expr_call(&func, args);\n             }\n-            hir::ExprKind::MethodCall(ref segment, _, ref args, _) => {\n+            hir::ExprKind::MethodCall(ref segment, ref args, _) => {\n                 self.print_expr_method_call(segment, args);\n             }\n             hir::ExprKind::Binary(op, ref lhs, ref rhs) => {"}, {"sha": "4c93ec7ab18f1cdaaa3e95c2523e8f1edbc1d2c0", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -121,8 +121,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        if let ExprKind::MethodCall(_, call_span, exprs, _) = expr.kind {\n-            if call_span == self.target_span\n+        if let ExprKind::MethodCall(segment, exprs, _) = expr.kind {\n+            if segment.ident.span == self.target_span\n                 && Some(self.target)\n                     == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n                         typeck_results\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // 3 |     let _ = x.sum() as f64;\n             //   |               ^^^ cannot infer type for `S`\n             span\n-        } else if let Some(ExprKind::MethodCall(_, call_span, _, _)) =\n+        } else if let Some(ExprKind::MethodCall(segment, ..)) =\n             local_visitor.found_method_call.map(|e| &e.kind)\n         {\n             // Point at the call instead of the whole expression:\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             //   |                         ^^^^^^^ cannot infer type\n             //   |\n             //   = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n-            if span.contains(*call_span) { *call_span } else { span }\n+            if span.contains(segment.ident.span) { segment.ident.span } else { span }\n         } else {\n             span\n         };\n@@ -709,7 +709,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             };\n             err.span_label(pattern.span, msg);\n         } else if let Some(e) = local_visitor.found_method_call {\n-            if let ExprKind::MethodCall(segment, _, exprs, _) = &e.kind {\n+            if let ExprKind::MethodCall(segment, exprs, _) = &e.kind {\n                 // Suggest impl candidates:\n                 //\n                 // error[E0283]: type annotations needed"}, {"sha": "a14d6020361312067c94f33b1971511dbee3a0c3", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n         }\n \n         // We only care about method call expressions.\n-        if let hir::ExprKind::MethodCall(call, span, args, _) = &expr.kind {\n+        if let hir::ExprKind::MethodCall(call, args, _) = &expr.kind {\n             if call.ident.name != sym::into_iter {\n                 return;\n             }\n@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                 // to an array or to a slice.\n                 _ => bug!(\"array type coerced to something other than array or slice\"),\n             };\n-            cx.struct_span_lint(ARRAY_INTO_ITER, *span, |lint| {\n+            cx.struct_span_lint(ARRAY_INTO_ITER, call.ident.span, |lint| {\n                 let mut diag = lint.build(&format!(\n                     \"this method call resolves to `<&{} as IntoIterator>::into_iter` \\\n                     (due to backwards compatibility), \\"}, {"sha": "65385d4c7a12fd6b532d3ab0cf45105232de7016", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -2494,7 +2494,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         _ => {}\n                     }\n                 }\n-            } else if let hir::ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n+            } else if let hir::ExprKind::MethodCall(_, ref args, _) = expr.kind {\n                 // Find problematic calls to `MaybeUninit::assume_init`.\n                 let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n                 if cx.tcx.is_diagnostic_item(sym::assume_init, def_id) {"}, {"sha": "ae9368347543ad4270cdc1cb9a54c9575f9d7d3a", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -44,7 +44,7 @@ fn in_macro(span: Span) -> bool {\n fn first_method_call<'tcx>(\n     expr: &'tcx Expr<'tcx>,\n ) -> Option<(&'tcx PathSegment<'tcx>, &'tcx [Expr<'tcx>])> {\n-    if let ExprKind::MethodCall(path, _, args, _) = &expr.kind {\n+    if let ExprKind::MethodCall(path, args, _) = &expr.kind {\n         if args.iter().any(|e| e.span.from_expansion()) { None } else { Some((path, *args)) }\n     } else {\n         None"}, {"sha": "39b5b7afdaef1dbf4c4e2fc019559afbe9dd00f3", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -40,7 +40,7 @@ declare_lint_pass!(NoopMethodCall => [NOOP_METHOD_CALL]);\n impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // We only care about method calls.\n-        let ExprKind::MethodCall(call, _, elements, _) = &expr.kind else {\n+        let ExprKind::MethodCall(call, elements, _) = &expr.kind else {\n             return\n         };\n         // We only care about method calls corresponding to the `Clone`, `Deref` and `Borrow`"}, {"sha": "bceb5e536e7110af987f910c868c2d652a7fa2dc", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1464,7 +1464,7 @@ impl InvalidAtomicOrdering {\n             sym::AtomicI128,\n         ];\n         if_chain! {\n-            if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n+            if let ExprKind::MethodCall(ref method_path, args, _) = &expr.kind;\n             if recognized_names.contains(&method_path.ident.name);\n             if let Some(m_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if let Some(impl_did) = cx.tcx.impl_of_method(m_def_id);"}, {"sha": "374e6ef87a7402f9ed1679b65ad4427d0dd9b995", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -163,9 +163,9 @@ impl<'tcx> Cx<'tcx> {\n \n         let kind = match expr.kind {\n             // Here comes the interesting stuff:\n-            hir::ExprKind::MethodCall(_, method_span, ref args, fn_span) => {\n+            hir::ExprKind::MethodCall(segment, ref args, fn_span) => {\n                 // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n-                let expr = self.method_callee(expr, method_span, None);\n+                let expr = self.method_callee(expr, segment.ident.span, None);\n                 // When we apply adjustments to the receiver, use the span of\n                 // the overall method call for better diagnostics. args[0]\n                 // is guaranteed to exist, since a method call always has a receiver."}, {"sha": "d59c12fc2fa604a2f1400c2a268cdac448f175fb", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1203,9 +1203,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                     return;\n                 }\n             }\n-            hir::ExprKind::MethodCall(_, span, _, _) => {\n+            hir::ExprKind::MethodCall(segment, ..) => {\n                 // Method calls have to be checked specially.\n-                self.span = span;\n+                self.span = segment.ident.span;\n                 if let Some(def_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     if self.visit(self.tcx.type_of(def_id)).is_break() {\n                         return;"}, {"sha": "8b4ab77dffb5fdf8754eb7b31b3d4e3da8d4c4f3", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1363,9 +1363,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *rest)\n             }\n-            hir::ExprKind::MethodCall(ref seg, _, args, _) => {\n-                self.process_method_call(ex, seg, args)\n-            }\n+            hir::ExprKind::MethodCall(ref seg, args, _) => self.process_method_call(ex, seg, args),\n             hir::ExprKind::Field(ref sub_ex, _) => {\n                 self.visit_expr(&sub_ex);\n "}, {"sha": "e94c600bb4955541dad28c196d949440ffe87e09", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -2322,7 +2322,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if let Some(Node::Expr(hir::Expr {\n                     kind:\n                         hir::ExprKind::Call(hir::Expr { span, .. }, _)\n-                        | hir::ExprKind::MethodCall(_, span, ..),\n+                        | hir::ExprKind::MethodCall(\n+                            hir::PathSegment { ident: Ident { span, .. }, .. },\n+                            ..,\n+                        ),\n                     ..\n                 })) = hir.find(call_hir_id)\n                 {"}, {"sha": "2409346298da98c4c0c85dfe15c138cb27ea2bfc", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -464,14 +464,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr_parent = self.tcx.hir().get_parent_node(*expr_hir_id);\n         let hir = self.tcx.hir().find(expr_parent);\n         let closure_params_len = closure_fn_decl.inputs.len();\n-        let (method_path, method_span, method_expr) = match (hir, closure_params_len) {\n+        let (method_path, method_expr) = match (hir, closure_params_len) {\n             (\n                 Some(Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::MethodCall(path, span, expr, _),\n+                    kind: hir::ExprKind::MethodCall(segment, expr, _),\n                     ..\n                 })),\n                 1,\n-            ) => (path, span, expr),\n+            ) => (segment, expr),\n             _ => return None,\n         };\n \n@@ -483,10 +483,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self_ty.starts_with(\"std::option::Option\")\n             || self_ty.starts_with(\"std::result::Result\"))\n             && (name == sym::map || name == sym::and_then);\n-        match (is_as_ref_able, self.sess().source_map().span_to_snippet(*method_span)) {\n+        match (is_as_ref_able, self.sess().source_map().span_to_snippet(method_path.ident.span)) {\n             (true, Ok(src)) => {\n                 let suggestion = format!(\"as_ref().{}\", src);\n-                Some((*method_span, \"consider using `as_ref` instead\", suggestion))\n+                Some((method_path.ident.span, \"consider using `as_ref` instead\", suggestion))\n             }\n             _ => None,\n         }\n@@ -643,8 +643,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n-                    if let hir::ExprKind::MethodCall(ref segment, sp, ref args, _) = expr.kind {\n-                        let clone_trait = self.tcx.require_lang_item(LangItem::Clone, Some(sp));\n+                    if let hir::ExprKind::MethodCall(ref segment, ref args, _) = expr.kind {\n+                        let clone_trait =\n+                            self.tcx.require_lang_item(LangItem::Clone, Some(segment.ident.span));\n                         if let ([arg], Some(true), sym::clone) = (\n                             &args[..],\n                             self.typeck_results.borrow().type_dependent_def_id(expr.hir_id).map("}, {"sha": "23cc4b0ffc8140683ee11205c65c0f7a94ea70aa", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -230,8 +230,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // we skip issuing a warning because it is autogenerated code.\n             ExprKind::Call(..) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {}\n             ExprKind::Call(callee, _) => self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n-            ExprKind::MethodCall(_, ref span, _, _) => {\n-                self.warn_if_unreachable(expr.hir_id, *span, \"call\")\n+            ExprKind::MethodCall(segment, ..) => {\n+                self.warn_if_unreachable(expr.hir_id, segment.ident.span, \"call\")\n             }\n             _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n         }\n@@ -306,8 +306,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ExprKind::Block(body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(callee, args) => self.check_call(expr, &callee, args, expected),\n-            ExprKind::MethodCall(segment, span, args, _) => {\n-                self.check_method_call(expr, segment, span, args, expected)\n+            ExprKind::MethodCall(segment, args, _) => {\n+                self.check_method_call(expr, segment, args, expected)\n             }\n             ExprKind::Cast(e, t) => self.check_expr_cast(e, t, expr),\n             ExprKind::Type(e, t) => {\n@@ -1097,14 +1097,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         segment: &hir::PathSegment<'_>,\n-        span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let rcvr = &args[0];\n         let rcvr_t = self.check_expr(&rcvr);\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n+        let span = segment.ident.span;\n \n         let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr, args) {\n             Ok(method) => {"}, {"sha": "0f9803b969fb74521feef9aefcbfe1b950845721", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -964,7 +964,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if found != self.tcx.types.unit {\n             return;\n         }\n-        if let ExprKind::MethodCall(path_segment, _, [rcvr, ..], _) = expr.kind {\n+        if let ExprKind::MethodCall(path_segment, [rcvr, ..], _) = expr.kind {\n             if self\n                 .typeck_results\n                 .borrow()"}, {"sha": "e42d94a6f403be5f637dcb20ddaf9d2dbb1c80ca", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -148,8 +148,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::Call(hir::Expr { span, .. }, args) => {\n                     (*span, *span, &args[..], None)\n                 }\n-                hir::ExprKind::MethodCall(path_segment, span, args, _) => (\n-                    *span,\n+                hir::ExprKind::MethodCall(path_segment, args, _) => (\n+                    path_segment.ident.span,\n                     // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n                     path_segment\n                         .args\n@@ -161,7 +161,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 .source_map()\n                                 .next_point(tcx.sess.source_map().next_point(arg.span()))\n                         })\n-                        .unwrap_or(*span),\n+                        .unwrap_or(path_segment.ident.span),\n                     &args[1..], // Skip the receiver.\n                     None,       // methods are never ctors\n                 ),"}, {"sha": "d7d52ab823cee0f54d689dfd61c8c7e70a1f599a", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -345,7 +345,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n \n                 self.handle_uninhabited_return(expr);\n             }\n-            ExprKind::MethodCall(_, _, exprs, _) => {\n+            ExprKind::MethodCall(_, exprs, _) => {\n                 for expr in exprs {\n                     self.visit_expr(expr);\n                 }"}, {"sha": "586f34cd2c8140d8f07a91a6b731273675ffe1c9", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -130,7 +130,7 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx rustc_hir::Expr<'tcx>) {\n-        if let ExprKind::MethodCall(segment, method_span, _, _) = expr.kind {\n+        if let ExprKind::MethodCall(segment, ..) = expr.kind {\n             if let Some(hir_id) = segment.hir_id {\n                 let hir = self.tcx.hir();\n                 let body_id = hir.enclosing_body_owner(hir_id);\n@@ -141,7 +141,7 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n                 });\n                 if let Some(def_id) = typeck_results.type_dependent_def_id(expr.hir_id) {\n                     self.matches.insert(\n-                        method_span,\n+                        segment.ident.span,\n                         match hir.span_if_local(def_id) {\n                             Some(span) => LinkFromSrc::Local(clean::Span::new(span)),\n                             None => LinkFromSrc::External(def_id),"}, {"sha": "47fc666da9ab0349eea284a6bbabe50f540b15b1", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -150,7 +150,7 @@ where\n                     return;\n                 }\n             }\n-            hir::ExprKind::MethodCall(_, _, _, span) => {\n+            hir::ExprKind::MethodCall(_, _, span) => {\n                 let types = tcx.typeck(ex.hir_id.owner);\n                 let def_id = if let Some(def_id) = types.type_dependent_def_id(ex.hir_id) {\n                     def_id"}, {"sha": "c4956bacf43617a3de0ed2a747e6d377af022430", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n             // do not lint if the closure is called using an iterator (see #1141)\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, _, [self_arg, ..], _) = &parent.kind;\n+                if let ExprKind::MethodCall(_, [self_arg, ..], _) = &parent.kind;\n                 let caller = self.cx.typeck_results().expr_ty(self_arg);\n                 if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n                 if implements_trait(self.cx, caller, iter_id, &[]);"}, {"sha": "f7449c8dc72ed584a839c418bf2dd25de2c31d37", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -259,7 +259,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                 ))\n             })\n         },\n-        ExprKind::MethodCall(path, _, args, _) if args.len() == 1 => {\n+        ExprKind::MethodCall(path, args, _) if args.len() == 1 => {\n             let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym::Option)\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym::Result)"}, {"sha": "02d97bf43df83d50587d50b9669ee205230766a4", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -41,9 +41,9 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'tcx> LateLintPass<'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(count, _, [count_recv], _) = expr.kind;\n+            if let ExprKind::MethodCall(count, [count_recv], _) = expr.kind;\n             if count.ident.name == sym::count;\n-            if let ExprKind::MethodCall(filter, _, [filter_recv, filter_arg], _) = count_recv.kind;\n+            if let ExprKind::MethodCall(filter, [filter_recv, filter_arg], _) = count_recv.kind;\n             if filter.ident.name == sym!(filter);\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_arg.kind;\n             let body = cx.tcx.hir().body(body_id);\n@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n             if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n             if !is_local_used(cx, needle, arg_id);\n             then {\n-                let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n+                let haystack = if let ExprKind::MethodCall(path, args, _) =\n                         filter_recv.kind {\n                     let p = path.ident.name;\n                     if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {"}, {"sha": "e71f110820c0b83111e7ce23824e9f3fd98c4430", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -37,7 +37,7 @@ declare_lint_pass!(CaseSensitiveFileExtensionComparisons => [CASE_SENSITIVE_FILE\n \n fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Span> {\n     if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident, .. }, _, [obj, extension, ..], span) = expr.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident, .. }, [obj, extension, ..], span) = expr.kind;\n         if ident.as_str() == \"ends_with\";\n         if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = extension.kind;\n         if (2..=6).contains(&ext_literal.as_str().len());"}, {"sha": "ea74d5acbda0528ade62cc8b1d0aca92cf2fc7f4", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -43,7 +43,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             },\n             _ => nbits,\n         },\n-        ExprKind::MethodCall(method, _, [left, right], _) => {\n+        ExprKind::MethodCall(method, [left, right], _) => {\n             if signed {\n                 return nbits;\n             }\n@@ -54,7 +54,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             };\n             apply_reductions(cx, nbits, left, signed).min(max_bits.unwrap_or(u64::max_value()))\n         },\n-        ExprKind::MethodCall(method, _, [_, lo, hi], _) => {\n+        ExprKind::MethodCall(method, [_, lo, hi], _) => {\n             if method.ident.as_str() == \"clamp\" {\n                 //FIXME: make this a diagnostic item\n                 if let (Some(lo_bits), Some(hi_bits)) = (get_constant_bits(cx, lo), get_constant_bits(cx, hi)) {\n@@ -63,7 +63,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             }\n             nbits\n         },\n-        ExprKind::MethodCall(method, _, [_value], _) => {\n+        ExprKind::MethodCall(method, [_value], _) => {\n             if method.ident.name.as_str() == \"signum\" {\n                 0 // do not lint if cast comes from a `signum` function\n             } else {"}, {"sha": "079b7ff0675b4b34ad1b8d96e7a5e7810a2bf811", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -19,7 +19,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             cx.typeck_results().expr_ty(expr),\n         );\n         lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-    } else if let ExprKind::MethodCall(method_path, _, [self_arg, ..], _) = &expr.kind {\n+    } else if let ExprKind::MethodCall(method_path, [self_arg, ..], _) = &expr.kind {\n         if_chain! {\n             if method_path.ident.name == sym!(cast);\n             if let Some(generic_args) = method_path.args;"}, {"sha": "75f70b77ed4e7d34a07a52467ab4c7f61e563053", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -41,14 +41,14 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for the result of methods that always return non-negative values.\n-            if let ExprKind::MethodCall(path, _, _, _) = cast_op.kind {\n+            if let ExprKind::MethodCall(path, _, _) = cast_op.kind {\n                 let mut method_name = path.ident.name.as_str();\n                 let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n                 if_chain! {\n                     if method_name == \"unwrap\";\n                     if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n-                    if let ExprKind::MethodCall(inner_path, _, _, _) = &arglist[0][0].kind;\n+                    if let ExprKind::MethodCall(inner_path, _, _) = &arglist[0][0].kind;\n                     then {\n                         method_name = inner_path.ident.name.as_str();\n                     }"}, {"sha": "fb201d2c012b19f9927a8f371ad91cabaa886c96", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 }\n             },\n \n-            ExprKind::MethodCall(_, _, args, _) => {\n+            ExprKind::MethodCall(_, args, _) => {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n                     for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {"}, {"sha": "feb5f100de5d5871904bfb47cb469d7b93b2fb82", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -361,7 +361,7 @@ fn try_parse_ref_op<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) -> Option<(RefOp, &'tcx Expr<'tcx>)> {\n     let (def_id, arg) = match expr.kind {\n-        ExprKind::MethodCall(_, _, [arg], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n+        ExprKind::MethodCall(_, [arg], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(path),\n@@ -408,7 +408,7 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n     match parent.kind {\n         // Leave deref calls in the middle of a method chain.\n         // e.g. x.deref().foo()\n-        ExprKind::MethodCall(_, _, [self_arg, ..], _) if self_arg.hir_id == child_id => false,\n+        ExprKind::MethodCall(_, [self_arg, ..], _) if self_arg.hir_id == child_id => false,\n \n         // Leave deref calls resulting in a called function\n         // e.g. (x.deref())()"}, {"sha": "24e32c09f44b3252d158653ef366eb8bb66a8e28", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, left, right) = expr.kind;\n-            if let ExprKind::MethodCall(method_path, _ , args, _) = left.kind;\n+            if let ExprKind::MethodCall(method_path, args, _) = left.kind;\n             if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {"}, {"sha": "1ae2e20c1e060e78aa206ee20a25f31c05f59c65", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -244,7 +244,6 @@ fn try_parse_contains<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Optio\n     });\n     match expr.kind {\n         ExprKind::MethodCall(\n-            _,\n             _,\n             [\n                 map,\n@@ -281,7 +280,7 @@ struct InsertExpr<'tcx> {\n     value: &'tcx Expr<'tcx>,\n }\n fn try_parse_insert<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n-    if let ExprKind::MethodCall(_, _, [map, key, value], _) = expr.kind {\n+    if let ExprKind::MethodCall(_, [map, key, value], _) = expr.kind {\n         let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n         if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n             Some(InsertExpr { map, key, value })"}, {"sha": "263bff4873caf4cb45af2f3efdd8bb95dd31bbf1", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(path, _, args, _) = body.value.kind;\n+            if let ExprKind::MethodCall(path, args, _) = body.value.kind;\n             if check_inputs(cx, body.params, args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n             let substs = cx.typeck_results().node_substs(body.value.hir_id);"}, {"sha": "f326fd83d18e70a16c17de0a8ca5681f5562ee58", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -35,10 +35,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, _, [write_call], _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, [write_call], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, _, [write_recv, write_arg], _) = write_call.kind;\n+            if let ExprKind::MethodCall(write_fun, [write_recv, write_arg], _) = write_call.kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {"}, {"sha": "79ce53f7a5f23f2cd3f3f0f64f36541b28bb453b", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -303,7 +303,7 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n-                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, _, args, _) = grandparent.kind {\n+                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = grandparent.kind {\n                         if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n                             return;\n                         }\n@@ -364,13 +364,11 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: lmethod_name, .. },\n-                _lspan,\n                 [largs_0, largs_1, ..],\n                 _\n             ) = &add_lhs.kind;\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: rmethod_name, .. },\n-                _rspan,\n                 [rargs_0, rargs_1, ..],\n                 _\n             ) = &add_rhs.kind;\n@@ -409,7 +407,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &lhs.kind;\n+        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &lhs.kind;\n         if cx.typeck_results().expr_ty(self_arg).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n@@ -453,7 +451,7 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     ) = &expr.kind\n     {\n         if let Some(parent) = get_parent_expr(cx, expr) {\n-            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, _, args, _) = parent.kind {\n+            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = parent.kind {\n                 if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n                     return;\n                 }\n@@ -589,8 +587,8 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, args_a, _) = expr_a.kind;\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, args_b, _) = expr_b.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, args_b, _) = expr_b.kind;\n         then {\n             return method_name_a.as_str() == method_name_b.as_str() &&\n                 args_a.len() == args_b.len() &&\n@@ -615,8 +613,8 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             rhs,\n         ) = &expr.kind;\n         if are_same_base_logs(cx, lhs, rhs);\n-        if let ExprKind::MethodCall(_, _, [largs_self, ..], _) = &lhs.kind;\n-        if let ExprKind::MethodCall(_, _, [rargs_self, ..], _) = &rhs.kind;\n+        if let ExprKind::MethodCall(_, [largs_self, ..], _) = &lhs.kind;\n+        if let ExprKind::MethodCall(_, [rargs_self, ..], _) = &rhs.kind;\n         then {\n             span_lint_and_sugg(\n                 cx,\n@@ -714,7 +712,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n             return;\n         }\n \n-        if let ExprKind::MethodCall(path, _, args, _) = &expr.kind {\n+        if let ExprKind::MethodCall(path, args, _) = &expr.kind {\n             let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n \n             if recv_ty.is_floating_point() {"}, {"sha": "17b0749a4a990f91594d704f325ec5e25f16fcde", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -149,7 +149,7 @@ fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symb\n fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Expr<'_>) {\n     if_chain! {\n         if !value.span.from_expansion();\n-        if let ExprKind::MethodCall(_, _, [receiver], _) = value.kind;\n+        if let ExprKind::MethodCall(_, [receiver], _) = value.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(value.hir_id);\n         if is_diag_trait_item(cx, method_def_id, sym::ToString);\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);"}, {"sha": "3e3718b9445f7a0e645f2e1a96084953c061e774", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.kind {\n-            Call(_, args) | MethodCall(_, _, args, _) => {\n+            Call(_, args) | MethodCall(_, args, _) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n                     if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())"}, {"sha": "830e3b32cfa2fac80d26726df67d353a835ea145", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, _, args, _) => {\n+            hir::ExprKind::MethodCall(_, args, _) => {\n                 let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n "}, {"sha": "df29d9308e7124da07b112998729023abbba7e17", "filename": "src/tools/clippy/clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Is a method call\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, args, _) = expr.kind;\n \n             // Method name is \"get\"\n             if path.ident.name == sym!(get);\n@@ -73,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n             ) = &get_index_arg.kind;\n \n             // LHS of subtraction is \"x.len()\"\n-            if let ExprKind::MethodCall(arg_lhs_path, _, lhs_args, _) = &lhs.kind;\n+            if let ExprKind::MethodCall(arg_lhs_path, lhs_args, _) = &lhs.kind;\n             if arg_lhs_path.ident.name == sym::len;\n             if let Some(arg_lhs_struct) = lhs_args.get(0);\n "}, {"sha": "e9501700784931c25ac97277fafa0b825ceac596", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -127,7 +127,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n \n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(path, _span, [self_arg, ..], _) = &expr.kind;\n+        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n         if path.ident.as_str() == \"lock\";\n         let ty = cx.typeck_results().expr_ty(self_arg);\n         if is_type_diagnostic_item(cx, ty, sym::Mutex);"}, {"sha": "3008e86ef8b296da25d2a4e5adc78c614ceed059", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -145,7 +145,7 @@ const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n \n fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, _, args, _) => {\n+        ExprKind::MethodCall(method, args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n@@ -221,7 +221,7 @@ const INFINITE_COLLECTORS: &[Symbol] = &[\n \n fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, _, args, _) => {\n+        ExprKind::MethodCall(method, args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);"}, {"sha": "530b0a90ebd8a8245fb129d1317dd06f64cd71fd", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -370,7 +370,7 @@ fn check_for_is_empty(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, _, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(method_path, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {"}, {"sha": "ef0221639aa940414ea29f146b3c53f9511d8067", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -119,7 +119,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n \n     let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n         if_chain! {\n-            if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n+            if let ExprKind::MethodCall(method, len_args, _) = end.kind;\n             if method.ident.name == sym::len;\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n@@ -343,7 +343,7 @@ fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Opti\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(method, args, _) = expr.kind;\n         if method.ident.name == sym::clone;\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);"}, {"sha": "5bc32acf56eccd1a22a64fb19011b5946b68e045", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -658,7 +658,7 @@ fn check_for_loop<'tcx>(\n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n \n-    if let ExprKind::MethodCall(method, _, [self_arg], _) = arg.kind {\n+    if let ExprKind::MethodCall(method, [self_arg], _) = arg.kind {\n         let method_name = method.ident.as_str();\n         // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n         match method_name {"}, {"sha": "f57dcc2f5c453ead3d76b1d2f31e23678bb36dad", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -24,8 +24,8 @@ pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n }\n fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n-        if let ExprKind::MethodCall(chain_method, method0_span, _, _) = args[0].kind;\n+        if let ExprKind::MethodCall(method, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(chain_method, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n         then {\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n@@ -62,7 +62,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n             span_lint_and_sugg(\n                 cx,\n                 NEEDLESS_COLLECT,\n-                method0_span.with_hi(expr.span.hi()),\n+                chain_method.ident.span.with_hi(expr.span.hi()),\n                 NEEDLESS_COLLECT_MSG,\n                 \"replace with\",\n                 sugg,\n@@ -79,7 +79,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let PatKind::Binding(_, id, ..) = local.pat.kind;\n                 if let Some(init_expr) = local.init;\n-                if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n+                if let ExprKind::MethodCall(method_name, &[ref iter_source], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n                 let ty = cx.typeck_results().expr_ty(init_expr);\n                 if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n@@ -101,7 +101,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     }\n \n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n-                    let mut span = MultiSpan::from_span(collect_span);\n+                    let mut span = MultiSpan::from_span(method_name.ident.span);\n                     span.push_span_label(iter_call.span, \"the iterator could be used here instead\".into());\n                     span_lint_hir_and_then(\n                         cx,\n@@ -193,7 +193,7 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+        if let ExprKind::MethodCall(method_name, [recv, args @ ..], _) = &expr.kind {\n             if method_name.ident.name == sym!(collect) && is_trait_method(self.cx, expr, sym::Iterator) {\n                 self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(recv));\n                 self.visit_expr(recv);"}, {"sha": "9d335073e4fb2c524999ad6ec75ceba81b76b6dd", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -186,7 +186,7 @@ pub(super) fn check<'tcx>(\n \n fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, _, len_args, _) = expr.kind;\n+        if let ExprKind::MethodCall(method, len_args, _) = expr.kind;\n         if len_args.len() == 1;\n         if method.ident.name == sym::len;\n         if let ExprKind::Path(QPath::Resolved(_, path)) = len_args[0].kind;\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(meth, _, [args_0, args_1, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(meth, [args_0, args_1, ..], _) = &expr.kind;\n             if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(args_1, args_0, expr);\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprKind::MethodCall(_, _, args, _) => {\n+            ExprKind::MethodCall(_, args, _) => {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args) {\n                     self.prefer_mutable = false;"}, {"sha": "a0b2302662e64b8b6bf6a476fc4439338c6bd95d", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -121,7 +121,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Repeat(e, _)\n         | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n         ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n-        ExprKind::Array(es) | ExprKind::MethodCall(_, _, es, _) | ExprKind::Tup(es) => {\n+        ExprKind::Array(es) | ExprKind::MethodCall(_, es, _) | ExprKind::Tup(es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n         ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), main_loop_id),"}, {"sha": "e048d744fc3ba89714466632729338dd06670d59", "filename": "src/tools/clippy/clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -180,7 +180,7 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n     if_chain! {\n             // Extract method being called\n             if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n-            if let ExprKind::MethodCall(path, _, args, _) = &semi_stmt.kind;\n+            if let ExprKind::MethodCall(path, args, _) = &semi_stmt.kind;\n             // Figure out the parameters for the method call\n             if let Some(self_expr) = args.get(0);\n             if let Some(pushed_item) = args.get(1);"}, {"sha": "15f419e4410ca86ccdf83c2843c58b63625122bb", "filename": "src/tools/clippy/clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check<'tcx>(\n ) {\n     let arg_expr = match arg.kind {\n         ExprKind::AddrOf(BorrowKind::Ref, _, ref_arg) => ref_arg,\n-        ExprKind::MethodCall(method, _, args, _) if args.len() == 1 && method.ident.name == rustc_span::sym::iter => {\n+        ExprKind::MethodCall(method, args, _) if args.len() == 1 && method.ident.name == rustc_span::sym::iter => {\n             &args[0]\n         },\n         _ => return,"}, {"sha": "20a8294a0d1acf0132adf4222149a3baec66ddf4", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -21,7 +21,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Res::Def(_, pat_did) = pat_path.res;\n         if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n         // check for call to `Iterator::next`\n-        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = let_expr.kind;\n+        if let ExprKind::MethodCall(method_name, [iter_expr], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n         if is_trait_method(cx, let_expr, sym::Iterator);\n         if let Some(iter_expr_struct) = try_parse_iter_expr(cx, iter_expr);"}, {"sha": "bf4ab29d90876aa66c393904942f6ff87983dde1", "filename": "src/tools/clippy/clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualOkOr {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(method_segment, _, args, _) = scrutinee.kind;\n+            if let ExprKind::MethodCall(method_segment, args, _) = scrutinee.kind;\n             if method_segment.ident.name == sym!(map_or);\n             if args.len() == 3;\n             let method_receiver = &args[0];"}, {"sha": "c814e013c631cd2a02119078f3f70a94a972a0b1", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n \n         if_chain! {\n             if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n-            if let ExprKind::MethodCall(_, _, [target_arg, pattern], _) = cond.kind;\n+            if let ExprKind::MethodCall(_, [target_arg, pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n             then {\n@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n // Returns `Some(arg)` if `expr` matches `arg.len()` and `None` otherwise.\n fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(_, _, [arg], _) = expr.kind;\n+        if let ExprKind::MethodCall(_, [arg], _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, method_def_id, &paths::STR_LEN);\n         then {"}, {"sha": "22a2552b283a5940c4c54c6e4dff90c1468fb293", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n         }\n \n         if_chain! {\n-            if let hir::ExprKind::MethodCall(method, _, args, _) = e.kind;\n+            if let hir::ExprKind::MethodCall(method, args, _) = e.kind;\n             if args.len() == 2;\n             if method.ident.name == sym::map;\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     }\n                                 }\n                             },\n-                            hir::ExprKind::MethodCall(method, _, [obj], _) => if_chain! {\n+                            hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n                                 if ident_eq(name, obj) && method.ident.name == sym::clone;\n                                 if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n                                 if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);"}, {"sha": "e3a42de0b7c10c183299aaa5b18de8efc6b1c6ab", "filename": "src/tools/clippy/clippy_lints/src/map_err_ignore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n         }\n \n         // check if this is a method call (e.g. x.foo())\n-        if let ExprKind::MethodCall(method, _t_span, args, _) = e.kind {\n+        if let ExprKind::MethodCall(method, args, _) = e.kind {\n             // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n             // Enum::Variant[2]))\n             if method.ident.as_str() == \"map_err\" && args.len() == 2 {"}, {"sha": "0f6ac47843241d9cc3718d8548eea50ecb746b9b", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -129,7 +129,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n     }\n \n     match expr.kind {\n-        hir::ExprKind::Call(_, _) | hir::ExprKind::MethodCall(_, _, _, _) => {\n+        hir::ExprKind::Call(_, _) | hir::ExprKind::MethodCall(..) => {\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },"}, {"sha": "77a4917ec58f0a80afd66d1d8e4e8841a94ad96b", "filename": "src/tools/clippy/clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n             };\n \n         if_chain! {\n-            if let ExprKind::MethodCall(_, ok_span, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let ExprKind::MethodCall(ok_path, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n             if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::Result);\n@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n \n                 let mut applicability = Applicability::MachineApplicable;\n                 let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n-                let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_span), \"\", &mut applicability);\n+                let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_path.ident.span), \"\", &mut applicability);\n                 let sugg = format!(\n                     \"{} let Ok({}) = {}\",\n                     ifwhile,"}, {"sha": "85aec93670b95642ef3f2f51883fc185984ad2b1", "filename": "src/tools/clippy/clippy_lints/src/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -87,8 +87,7 @@ struct MatchExprVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for MatchExprVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n         match ex.kind {\n-            ExprKind::MethodCall(segment, _, [receiver], _) if self.case_altered(segment.ident.as_str(), receiver) => {\n-            },\n+            ExprKind::MethodCall(segment, [receiver], _) if self.case_altered(segment.ident.as_str(), receiver) => {},\n             _ => walk_expr(self, ex),\n         }\n     }"}, {"sha": "411a797b6cb53cf2adeec0bffc7cb5dd28238f6b", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1909,7 +1909,7 @@ mod redundant_pattern_match {\n                     },\n                     // Method calls can take self by reference.\n                     // e.g. In `String::new().len()` the string is a temporary value.\n-                    ExprKind::MethodCall(_, _, [self_arg, args @ ..], _) => {\n+                    ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n                         if !matches!(self_arg.kind, ExprKind::Path(_)) {\n                             let self_by_ref = self\n                                 .cx\n@@ -2020,7 +2020,7 @@ mod redundant_pattern_match {\n         // check that `while_let_on_iterator` lint does not trigger\n         if_chain! {\n             if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _, _) = let_expr.kind;\n+            if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n             if method_path.ident.name == sym::next;\n             if is_trait_method(cx, let_expr, sym::Iterator);\n             then {"}, {"sha": "ce958b8ac9f5991a82de380f4ce71575ac60381c", "filename": "src/tools/clippy/clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -121,9 +121,9 @@ pub(crate) trait BindInsteadOfMap {\n         });\n         let (span, msg) = if_chain! {\n             if can_sugg;\n-            if let hir::ExprKind::MethodCall(_, span, ..) = expr.kind;\n+            if let hir::ExprKind::MethodCall(segment, ..) = expr.kind;\n             if let Some(msg) = Self::lint_msg(cx);\n-            then { (span, msg) } else { return false; }\n+            then { (segment.ident.span, msg) } else { return false; }\n         };\n         span_lint_and_then(cx, BIND_INSTEAD_OF_MAP, expr.span, &msg, |diag| {\n             multispan_sugg_with_applicability("}, {"sha": "0b38a07204e86cec08a825a3d00b5e7b3dc09c46", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -81,12 +81,12 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                 // &*x is a nop, &x.clone() is not\n                 ExprKind::AddrOf(..) => return,\n                 // (*x).func() is useless, x.clone().func() can work in case func borrows self\n-                ExprKind::MethodCall(_, _, [self_arg, ..], _)\n+                ExprKind::MethodCall(_, [self_arg, ..], _)\n                     if expr.hir_id == self_arg.hir_id && ty != cx.typeck_results().expr_ty_adjusted(expr) =>\n                 {\n                     return;\n                 },\n-                ExprKind::MethodCall(_, _, [self_arg, ..], _) if expr.hir_id == self_arg.hir_id => true,\n+                ExprKind::MethodCall(_, [self_arg, ..], _) if expr.hir_id == self_arg.hir_id => true,\n                 ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n                 | ExprKind::Field(..)\n                 | ExprKind::Index(..) => true,"}, {"sha": "e7d2d550a3032e58af49db5ddf99cc970ab2d4fb", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -28,7 +28,7 @@ pub(super) fn check<'tcx>(\n         loop {\n             arg_root = match &arg_root.kind {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n-                hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n+                hir::ExprKind::MethodCall(method_name, call_args, _) => {\n                     if call_args.len() == 1\n                         && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n                         && {"}, {"sha": "a15fe609402251db53e17ba0ba32c8c3fee7d45b", "filename": "src/tools/clippy/clippy_lints/src/methods/extend_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n     if_chain! {\n         if is_type_diagnostic_item(cx, ty, sym::Vec);\n         //check source object\n-        if let ExprKind::MethodCall(src_method, _, [drain_vec, drain_arg], _) = &arg.kind;\n+        if let ExprKind::MethodCall(src_method, [drain_vec, drain_arg], _) = &arg.kind;\n         if src_method.ident.as_str() == \"drain\";\n         let src_ty = cx.typeck_results().expr_ty(drain_vec);\n         //check if actual src type is mutable for code suggestion"}, {"sha": "ba1af9f3d62be9a38934c24790f9bbb7b4bdc98c", "filename": "src/tools/clippy/clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -28,7 +28,7 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n             let closure_expr = peel_blocks(&body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n-                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, _, args, _) => {\n+                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, args, _) => {\n                     if_chain! {\n                     if ident.name == method_name;\n                     if let hir::ExprKind::Path(path) = &args[0].kind;\n@@ -118,7 +118,7 @@ pub(super) fn check<'tcx>(\n             };\n             // closure ends with is_some() or is_ok()\n             if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-            if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n+            if let ExprKind::MethodCall(path, [filter_arg], _) = filter_body.value.kind;\n             if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n             if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did) {\n                 Some(false)\n@@ -135,7 +135,7 @@ pub(super) fn check<'tcx>(\n             if let [map_param] = map_body.params;\n             if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n             // closure ends with expect() or unwrap()\n-            if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n+            if let ExprKind::MethodCall(seg, [map_arg, ..], _) = map_body.value.kind;\n             if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n \n             let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {"}, {"sha": "137c9628eb45c930c230abc341f0f7efe2e8d1fa", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -2039,10 +2039,10 @@ impl_lint_pass!(Methods => [\n \n /// Extracts a method call name, args, and `Span` of the method name.\n fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx str, &'tcx [hir::Expr<'tcx>], Span)> {\n-    if let ExprKind::MethodCall(path, span, args, _) = recv.kind {\n+    if let ExprKind::MethodCall(path, args, _) = recv.kind {\n         if !args.iter().any(|e| e.span.from_expansion()) {\n             let name = path.ident.name.as_str();\n-            return Some((name, args, span));\n+            return Some((name, args, path.ident.span));\n         }\n     }\n     None\n@@ -2060,14 +2060,15 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             hir::ExprKind::Call(func, args) => {\n                 from_iter_instead_of_collect::check(cx, expr, args, func);\n             },\n-            hir::ExprKind::MethodCall(method_call, ref method_span, args, _) => {\n-                or_fun_call::check(cx, expr, *method_span, method_call.ident.as_str(), args);\n-                expect_fun_call::check(cx, expr, *method_span, method_call.ident.as_str(), args);\n+            hir::ExprKind::MethodCall(method_call, args, _) => {\n+                let method_span = method_call.ident.span;\n+                or_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n+                expect_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n                 clone_on_copy::check(cx, expr, method_call.ident.name, args);\n                 clone_on_ref_ptr::check(cx, expr, method_call.ident.name, args);\n                 inefficient_to_string::check(cx, expr, method_call.ident.name, args);\n                 single_char_add_str::check(cx, expr, args);\n-                into_iter_on_ref::check(cx, expr, *method_span, method_call.ident.name, args);\n+                into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n                 unnecessary_to_owned::check(cx, expr, method_call.ident.name, args);\n             },"}, {"sha": "ba2d2914315f9d0be879665f1d55d0b81e41f6ef", "filename": "src/tools/clippy/clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -56,7 +56,7 @@ pub(super) fn check<'tcx>(\n             let closure_expr = peel_blocks(&closure_body.value);\n \n             match &closure_expr.kind {\n-                hir::ExprKind::MethodCall(_, _, args, _) => {\n+                hir::ExprKind::MethodCall(_, args, _) => {\n                     if_chain! {\n                         if args.len() == 1;\n                         if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);"}, {"sha": "b2f624ed480e4cc903fcbebc08722105a9449037", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -132,7 +132,7 @@ fn parse_iter_usage<'tcx>(\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, _, [_, args @ ..], _) = e.kind {\n+            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n                 (name, args)\n             } else {\n                 return None;\n@@ -173,7 +173,7 @@ fn parse_iter_usage<'tcx>(\n                         } else {\n                             if_chain! {\n                                 if let Some((_, Node::Expr(next_expr))) = iter.next();\n-                                if let ExprKind::MethodCall(next_name, _, [_], _) = next_expr.kind;\n+                                if let ExprKind::MethodCall(next_name, [_], _) = next_expr.kind;\n                                 if next_name.ident.name == sym::next;\n                                 if next_expr.span.ctxt() == ctxt;\n                                 if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n@@ -217,7 +217,7 @@ fn parse_iter_usage<'tcx>(\n                 }\n             },\n             _ if e.span.ctxt() != ctxt => (None, span),\n-            ExprKind::MethodCall(name, _, [_], _)\n+            ExprKind::MethodCall(name, [_], _)\n                 if name.ident.name == sym::unwrap\n                     && cx\n                         .typeck_results()\n@@ -289,7 +289,7 @@ fn check_iter<'tcx>(\n ) -> bool {\n     match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, _, [_, args @ ..], _) = e.kind {\n+            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n                 (name, args)\n             } else {\n                 return false;"}, {"sha": "65e94c5f44a9f0ae35a0023251bb3cfbf12f88f4", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -45,7 +45,7 @@ pub fn check_for_loop_iter(\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             let snippet = if_chain! {\n-                if let ExprKind::MethodCall(maybe_iter_method_name, _, [collection], _) = receiver.kind;\n+                if let ExprKind::MethodCall(maybe_iter_method_name, [collection], _) = receiver.kind;\n                 if maybe_iter_method_name.ident.name == sym::iter;\n \n                 if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n@@ -155,7 +155,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n                         self.addr_of_exprs.push(parent);\n                         return;\n                     },\n-                    ExprKind::MethodCall(_, _, args, _) => {\n+                    ExprKind::MethodCall(_, args, _) => {\n                         if_chain! {\n                             if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n                             if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);"}, {"sha": "b67bfb6597b0489d243987669f3fab4600390e0c", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -313,7 +313,7 @@ fn get_callee_substs_and_args<'tcx>(\n         }\n     }\n     if_chain! {\n-        if let ExprKind::MethodCall(_, _, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(_, args, _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         then {\n             let substs = cx.typeck_results().node_substs(expr.hir_id);"}, {"sha": "ca5d33ee8b07fc8043560f042fff75932830a528", "filename": "src/tools/clippy/clippy_lints/src/methods/useless_asref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -23,8 +23,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str,\n             // allow the `as_ref` or `as_mut` if it is followed by another method call\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(cx, expr);\n-                if let hir::ExprKind::MethodCall(_, ref span, _, _) = parent.kind;\n-                if span != &expr.span;\n+                if let hir::ExprKind::MethodCall(segment, ..) = parent.kind;\n+                if segment.ident.span != expr.span;\n                 then {\n                     return;\n                 }"}, {"sha": "c4cf994aacaa9f8aba2d595ed50a4aa2e5b3dbca", "filename": "src/tools/clippy/clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -24,7 +24,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind {\n+    if let hir::ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind {\n         if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(self_arg)) {\n             Some(self_arg)\n         } else {"}, {"sha": "cf9770f5c1fd320af91b3d297424fd33bb20388b", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -86,7 +86,7 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                 None\n             }\n         },\n-        ExprKind::MethodCall(path, _, args, _) => {\n+        ExprKind::MethodCall(path, args, _) => {\n             if_chain! {\n                 if let [obj, _] = args;\n                 if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);"}, {"sha": "3918bdbdf4387cc7e5bc926df8d5519bfdd684b8", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -523,7 +523,7 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, _, [ref self_arg, ..], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)"}, {"sha": "7871be41d62946b94dbf2cb3c43a731f6be555b4", "filename": "src/tools/clippy/clippy_lints/src/mut_mutex_lock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -49,7 +49,7 @@ declare_lint_pass!(MutMutexLock => [MUT_MUTEX_LOCK]);\n impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, method_span, [self_arg, ..], _) = &ex.kind;\n+            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &ex.kind;\n             if path.ident.name == sym!(lock);\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n                 span_lint_and_sugg(\n                     cx,\n                     MUT_MUTEX_LOCK,\n-                    *method_span,\n+                    path.ident.span,\n                     \"calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\",\n                     \"change this to\",\n                     \"get_mut\".to_owned(),"}, {"sha": "5c3e505c06c47821976f3377b1606a4d71c5d83e", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                     );\n                 }\n             },\n-            ExprKind::MethodCall(path, _, arguments, _) => {\n+            ExprKind::MethodCall(path, arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);"}, {"sha": "6cf513b214e6dd14559216f4e49aefb4cd0c2992", "filename": "src/tools/clippy/clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -56,12 +56,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n \n         if_chain! {\n             // Check the method name is `for_each`.\n-            if let ExprKind::MethodCall(method_name, _, [for_each_recv, for_each_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(method_name, [for_each_recv, for_each_arg], _) = expr.kind;\n             if method_name.ident.name == Symbol::intern(\"for_each\");\n             // Check `for_each` is an associated function of `Iterator`.\n             if is_trait_method(cx, expr, sym::Iterator);\n             // Checks the receiver of `for_each` is also a method call.\n-            if let ExprKind::MethodCall(_, _, [iter_recv], _) = for_each_recv.kind;\n+            if let ExprKind::MethodCall(_, [iter_recv], _) = for_each_recv.kind;\n             // Skip the lint if the call chain is too long. e.g. `v.field.iter().for_each()` or\n             // `v.foo().iter().for_each()` must be skipped.\n             if matches!("}, {"sha": "21d8263390af3c813d2ae842d8bfa5f167fa0698", "filename": "src/tools/clippy/clippy_lints/src/needless_option_as_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for OptionNeedlessDeref {\n \n         if_chain! {\n             if is_type_diagnostic_item(cx,outer_ty,sym::Option);\n-            if let ExprKind::MethodCall(path, _, [sub_expr], _) = expr.kind;\n+            if let ExprKind::MethodCall(path, [sub_expr], _) = expr.kind;\n             let symbol = path.ident.as_str();\n             if symbol == \"as_deref\" || symbol == \"as_deref_mut\";\n             if TyS::same_type( outer_ty, typeck.expr_ty(sub_expr) );"}, {"sha": "ed022b9d5291cbf3ad6cdf3df582a6ced7b25440", "filename": "src/tools/clippy/clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -43,7 +43,7 @@ declare_lint_pass!(NonOctalUnixPermissions => [NON_OCTAL_UNIX_PERMISSIONS]);\n impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         match &expr.kind {\n-            ExprKind::MethodCall(path, _, [func, param], _) => {\n+            ExprKind::MethodCall(path, [func, param], _) => {\n                 let obj_ty = cx.typeck_results().expr_ty(func).peel_refs();\n \n                 if_chain! {"}, {"sha": "5a0b5042018ba6c68fecc751faa8fac11087f341", "filename": "src/tools/clippy/clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -32,7 +32,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &e.kind {\n+        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &e.kind {\n             let obj_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -60,7 +60,7 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(path, _, arguments, _) = argument.kind {\n+    if let ExprKind::MethodCall(path, arguments, _) = argument.kind {\n         let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions"}, {"sha": "c9f807f2aa3aadfe756369ac9e889dc8cafaf182", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -68,7 +68,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n \n /// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n-    if let ExprKind::MethodCall(path, _, &[ref receiver], _) = &expr.kind {\n+    if let ExprKind::MethodCall(path, &[ref receiver], _) = &expr.kind {\n         path.ident.name.as_str() == \"ok\"\n             && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(receiver), sym::Result)\n     } else {"}, {"sha": "3f940ce61c03e2c935d9870745384caa79aaa208", "filename": "src/tools/clippy/clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -46,7 +46,7 @@ declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::PathBuf);"}, {"sha": "b907f38afbb92f96dfb27efe3659872e239bac34", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -93,7 +93,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(path_segment, _, [arg_0, arg_1, ..], _) = &expr.kind {\n+    if let ExprKind::MethodCall(path_segment, [arg_0, arg_1, ..], _) = &expr.kind {\n         if is_expr_ty_raw_ptr(cx, arg_0) {\n             if path_segment.ident.name == sym::offset {\n                 return Some((arg_0, arg_1, Method::Offset));"}, {"sha": "6f634ded5fef700ffcc8a08ce79fe92be7156f34", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -58,7 +58,7 @@ impl QuestionMark {\n     fn check_is_none_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n-            if let ExprKind::MethodCall(segment, _, args, _) = &cond.kind;\n+            if let ExprKind::MethodCall(segment, args, _) = &cond.kind;\n             if let Some(subject) = args.get(0);\n             if (Self::option_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_none)) ||\n                 (Self::result_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_err));"}, {"sha": "52d47e6d97861b96f6f3c9f1f30e99cb9962d2a9", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -190,7 +190,7 @@ impl_lint_pass!(Ranges => [\n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n-            ExprKind::MethodCall(path, _, args, _) => {\n+            ExprKind::MethodCall(path, args, _) => {\n                 check_range_zip_with_len(cx, path, args, expr.span);\n             },\n             ExprKind::Binary(ref op, l, r) => {\n@@ -331,13 +331,13 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if path.ident.as_str() == \"zip\";\n         if let [iter, zip_arg] = args;\n         // `.iter()` call\n-        if let ExprKind::MethodCall(iter_path, _, iter_args, _) = iter.kind;\n+        if let ExprKind::MethodCall(iter_path, iter_args, _) = iter.kind;\n         if iter_path.ident.name == sym::iter;\n         // range expression in `.zip()` call: `0..x.len()`\n         if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n-        if let ExprKind::MethodCall(len_path, _, len_args, _) = end.kind;\n+        if let ExprKind::MethodCall(len_path, len_args, _) = end.kind;\n         if len_path.ident.name == sym::len && len_args.len() == 1;\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;"}, {"sha": "898c70ace66f35776c42c3b6a866022af81c7751", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -46,7 +46,7 @@ declare_lint_pass!(RepeatOnce => [REPEAT_ONCE]);\n impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, [receiver, count], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, [receiver, count], _) = &expr.kind;\n             if path.ident.name == sym!(repeat);\n             if constant_context(cx, cx.typeck_results()).expr(count) == Some(Constant::Int(1));\n             if !receiver.span.from_expansion();"}, {"sha": "c7c57ab426d9d8f82072f4010345deac8d98787d", "filename": "src/tools/clippy/clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -108,7 +108,7 @@ fn get_pointee_ty_and_count_expr<'tcx>(\n     };\n     if_chain! {\n         // Find calls to copy_{from,to}{,_nonoverlapping} and write_bytes methods\n-        if let ExprKind::MethodCall(method_path, _, [ptr_self, .., count], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_path, [ptr_self, .., count], _) = expr.kind;\n         let method_ident = method_path.ident.as_str();\n         if METHODS.iter().any(|m| *m == &*method_ident);\n "}, {"sha": "b4ad5dcbe3e9a265feaace30158ae5a227a7e2d3", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, _, [self_arg, extend_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(path, [self_arg, extend_arg], _) = expr.kind;\n             if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(extend);\n             if self.is_repeat_take(extend_arg);\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, _, [self_arg, len_arg, fill_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(path, [self_arg, len_arg, fill_arg], _) = expr.kind;\n             if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(resize);\n \n@@ -232,7 +232,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(take_path, _, take_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(take_path, take_args, _) = expr.kind;\n             if take_path.ident.name == sym!(take);\n \n             // Check that take is applied to `repeat(0)`"}, {"sha": "bcd28b429784a488520f6107255ab106f23b7ecf", "filename": "src/tools/clippy/clippy_lints/src/stable_sort_primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -87,7 +87,7 @@ struct LintDetection {\n \n fn detect_stable_sort_primitive(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintDetection> {\n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(method_name, args, _) = &expr.kind;\n         if let Some(slice) = &args.get(0);\n         if let Some(method) = SortingKind::from_stable_name(method_name.ident.name.as_str());\n         if let Some(slice_type) = is_slice_of_primitives(cx, slice);"}, {"sha": "3573f632a3671e6adde5cd641030f8beb9d85e6e", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -282,7 +282,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, args, _) = &e.kind;\n+            if let ExprKind::MethodCall(path, args, _) = &e.kind;\n             if path.ident.name == sym!(as_bytes);\n             if let ExprKind::Lit(lit) = &args[0].kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n@@ -324,9 +324,9 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, [recv], _) = &e.kind;\n+            if let ExprKind::MethodCall(path, [recv], _) = &e.kind;\n             if path.ident.name == sym!(into_bytes);\n-            if let ExprKind::MethodCall(path, _, [recv], _) = &recv.kind;\n+            if let ExprKind::MethodCall(path, [recv], _) = &recv.kind;\n             if matches!(path.ident.name.as_str(), \"to_owned\" | \"to_string\");\n             if let ExprKind::Lit(lit) = &recv.kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n@@ -384,7 +384,7 @@ declare_lint_pass!(StrToString => [STR_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StrToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n             if path.ident.name == sym!(to_string);\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, ty, ..) = ty.kind();\n@@ -434,7 +434,7 @@ declare_lint_pass!(StringToString => [STRING_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StringToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n             if path.ident.name == sym!(to_string);\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if is_type_diagnostic_item(cx, ty, sym::String);"}, {"sha": "7bc9cf742e6549e7dbbcffa91b499da3766d61bb", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n             if let ExprKind::Path(path) = &func.kind;\n             if let Some(did) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if match_libc_symbol(cx, did, \"strlen\");\n-            if let ExprKind::MethodCall(path, _, [self_arg], _) = recv.kind;\n+            if let ExprKind::MethodCall(path, [self_arg], _) = recv.kind;\n             if !recv.span.from_expansion();\n             if path.ident.name == sym::as_ptr;\n             then {"}, {"sha": "aa6c01b3a7cd935a3a9835ab79088a8c2cdaf6bc", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -39,12 +39,12 @@ declare_lint_pass!(ToDigitIsSome => [TO_DIGIT_IS_SOME]);\n impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(is_some_path, _, is_some_args, _) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(is_some_path, is_some_args, _) = &expr.kind;\n             if is_some_path.ident.name.as_str() == \"is_some\";\n             if let [to_digit_expr] = &**is_some_args;\n             then {\n                 let match_result = match &to_digit_expr.kind {\n-                    hir::ExprKind::MethodCall(to_digits_path, _, to_digit_args, _) => {\n+                    hir::ExprKind::MethodCall(to_digits_path, to_digit_args, _) => {\n                         if_chain! {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";"}, {"sha": "03060d78fc5af39d325068a721a991b9e96a7e83", "filename": "src/tools/clippy/clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -93,7 +93,7 @@ impl LateLintPass<'_> for ToStringInDisplay {\n         if_chain! {\n             if self.in_display_impl;\n             if let Some(self_hir_id) = self.self_hir_id;\n-            if let ExprKind::MethodCall(path, _, [ref self_arg, ..], _) = expr.kind;\n+            if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n             if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if is_diag_trait_item(cx, expr_def_id, sym::ToString);"}, {"sha": "6d909c34690d4f54148210eb0c1aea0b59551837", "filename": "src/tools/clippy/clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -177,7 +177,7 @@ fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt\n                     });\n                 }\n             },\n-            ExprKind::MethodCall(path, _, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n+            ExprKind::MethodCall(path, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n                 return Some(TargetVec {\n                     location: VecLocation::Expr(self_expr),\n                     init_kind: None,\n@@ -211,7 +211,7 @@ fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Opt\n         }\n     });\n     match expr.kind {\n-        ExprKind::MethodCall(path, _, [self_expr, _], _) => {\n+        ExprKind::MethodCall(path, [self_expr, _], _) => {\n             let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n             if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n                 Some((self_expr, expr.span))"}, {"sha": "88ca0cb20a12c59dc66bf903e31dd9962932f8c5", "filename": "src/tools/clippy/clippy_lints/src/unit_hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -49,7 +49,7 @@ declare_lint_pass!(UnitHash => [UNIT_HASH]);\n impl<'tcx> LateLintPass<'tcx> for UnitHash {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(name_ident, _, args, _) = &expr.kind;\n+            if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind;\n             if name_ident.ident.name == sym::hash;\n             if let [recv, state_param] = args;\n             if cx.typeck_results().expr_ty(recv).is_unit();"}, {"sha": "141f260487264026182e39eb2b24ea227cf33364", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -142,7 +142,7 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n \n impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::MethodCall(_, _, args, _) = expr.kind {\n+        if let ExprKind::MethodCall(_, args, _) = expr.kind {\n             let arg_indices = get_args_to_check(cx, expr);\n             for (i, trait_name) in arg_indices {\n                 if i < args.len() {"}, {"sha": "97d92f10e1cb2b039e13b6b646be14c4370e1343", "filename": "src/tools/clippy/clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n \n     match expr.kind {\n-        ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n+        ExprKind::Call(_, args) | ExprKind::MethodCall(_, args, _) => {\n             let args_to_recover = args\n                 .iter()\n                 .filter(|arg| {"}, {"sha": "e6c260ed96a98837d231692a893898d69f66cd71", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -93,10 +93,7 @@ fn mirrored_exprs(\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n-        (\n-            ExprKind::MethodCall(left_segment, _, left_args, _),\n-            ExprKind::MethodCall(right_segment, _, right_args, _),\n-        ) => {\n+        (ExprKind::MethodCall(left_segment, left_args, _), ExprKind::MethodCall(right_segment, right_args, _)) => {\n             left_segment.ident == right_segment.ident\n                 && iter::zip(*left_args, *right_args)\n                     .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n@@ -165,7 +162,7 @@ fn mirrored_exprs(\n \n fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n     if_chain! {\n-        if let ExprKind::MethodCall(name_ident, _, args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind;\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n@@ -175,7 +172,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, _, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs("}, {"sha": "323cf83ffcffae0410f5ba0ec668055a70679ebe", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n                     check_map_error(cx, res, expr);\n                 }\n             },\n-            hir::ExprKind::MethodCall(path, _, [ref arg_0, ..], _) => match path.ident.as_str() {\n+            hir::ExprKind::MethodCall(path, [ref arg_0, ..], _) => match path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_map_error(cx, arg_0, expr);\n                 },\n@@ -94,7 +94,7 @@ fn try_remove_await<'a>(expr: &'a hir::Expr<'a>) -> Option<&hir::Expr<'a>> {\n \n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n-    while let hir::ExprKind::MethodCall(path, _, args, _) = call.kind {\n+    while let hir::ExprKind::MethodCall(path, args, _) = call.kind {\n         if matches!(path.ident.as_str(), \"or\" | \"or_else\" | \"ok\") {\n             call = &args[0];\n         } else {\n@@ -110,7 +110,7 @@ fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<\n }\n \n fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>, is_await: bool) {\n-    if let hir::ExprKind::MethodCall(path, _, _, _) = call.kind {\n+    if let hir::ExprKind::MethodCall(path, _, _) = call.kind {\n         let symbol = path.ident.as_str();\n         let read_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)"}, {"sha": "e984048701341099acc25ba8b70b5981f2bb14ae", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -154,7 +154,7 @@ fn collect_unwrap_info<'tcx>(\n         return collect_unwrap_info(cx, if_expr, expr, branch, !invert, false);\n     } else {\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n+            if let ExprKind::MethodCall(method_name, args, _) = &expr.kind;\n             if let Some(local_id) = path_to_local(&args[0]);\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             let name = method_name.ident.as_str();\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(method_name, _, [self_arg, ..], _) = expr.kind;\n+                if let ExprKind::MethodCall(method_name, [self_arg, ..], _) = expr.kind;\n                 if let Some(id) = path_to_local(self_arg);\n                 if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);"}, {"sha": "d23c85c033b2f7e63ce1809f30443d055e6eb605", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -402,9 +402,9 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 self.expr(func);\n                 self.slice(args, |e| self.expr(e));\n             },\n-            ExprKind::MethodCall(method_name, _, args, _) => {\n+            ExprKind::MethodCall(method_name, args, _) => {\n                 bind!(self, method_name, args);\n-                kind!(\"MethodCall({method_name}, _, {args}, _)\");\n+                kind!(\"MethodCall({method_name}, {args}, _)\");\n                 self.ident(field!(method_name.ident));\n                 self.slice(args, |e| self.expr(e));\n             },"}, {"sha": "b58325ac73ee964770ce951ffb6a25400932c234", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -149,7 +149,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             }\n             print_expr(cx, init, indent + 1);\n         },\n-        hir::ExprKind::MethodCall(path, _, args, _) => {\n+        hir::ExprKind::MethodCall(path, args, _) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {"}, {"sha": "ec1b5a499d472a401b6677fbf163f40614812e33", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -583,7 +583,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n             let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n@@ -665,7 +665,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if let ExprKind::Closure(_, _, body_id, _, _) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(*body_id);\n             let only_expr = peel_blocks_with_stmt(&body.value);\n-            if let ExprKind::MethodCall(ps, _, span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::MethodCall(ps, span_call_args, _) = &only_expr.kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n                 let mut sle = SpanlessEq::new(cx).deny_side_effects();\n@@ -1097,7 +1097,7 @@ impl InterningDefinedSymbol {\n         };\n         if_chain! {\n             // is a method call\n-            if let ExprKind::MethodCall(_, _, [item], _) = call.kind;\n+            if let ExprKind::MethodCall(_, [item], _) = call.kind;\n             if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n             let ty = cx.typeck_results().expr_ty(item);\n             // ...on either an Ident or a Symbol"}, {"sha": "5ee3146eaab125b6f77616da9e4b3a02571212ce", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -896,7 +896,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for IsMultiSpanScanner<'a, 'hir> {\n                     self.add_single_span_suggestion();\n                 }\n             },\n-            ExprKind::MethodCall(path, _path_span, arg, _arg_span) => {\n+            ExprKind::MethodCall(path, arg, _arg_span) => {\n                 let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&arg[0]));\n                 if match_type(self.cx, self_ty, &paths::DIAGNOSTIC_BUILDER) {\n                     let called_method = path.ident.name.as_str().to_string();"}, {"sha": "fbf2b3e081b823220e0c1fbc792de34b1daaeba1", "filename": "src/tools/clippy/clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n         if let Some(searcher) = self.searcher.take() {\n             if_chain! {\n                 if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind;\n-                if let ExprKind::MethodCall(path, _, [self_arg, _], _) = expr.kind;\n+                if let ExprKind::MethodCall(path, [self_arg, _], _) = expr.kind;\n                 if path_to_local_id(self_arg, searcher.local_id);\n                 if path.ident.name.as_str() == \"push\";\n                 then {"}, {"sha": "4d86abd0fa123660a564d309bbc08c4d7a37c706", "filename": "src/tools/clippy/clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -31,7 +31,7 @@ declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(path_segment, _, args, _) = expr.kind;\n+            if let hir::ExprKind::MethodCall(path_segment, args, _) = expr.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;"}, {"sha": "8e2ddd225fdb3bd239c2e73288e6a5a794be0bca", "filename": "src/tools/clippy/clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for VerboseFileReads {\n \n fn is_file_read_to_end<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_end\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n         let ty = cx.typeck_results().expr_ty(&exprs[0]);\n@@ -75,7 +75,7 @@ fn is_file_read_to_end<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) ->\n \n fn is_file_read_to_string<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_string\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n         let ty = cx.typeck_results().expr_ty(&exprs[0]);"}, {"sha": "eb9efec3f1612a8f7af66888ba3b3534e726f400", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -141,7 +141,7 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                     self.eagerness |= NoChange;\n                     return;\n                 },\n-                ExprKind::MethodCall(name, _, args, _) => {\n+                ExprKind::MethodCall(name, args, _) => {\n                     self.eagerness |= self\n                         .cx\n                         .typeck_results()"}, {"sha": "ed573ad9056195c650c77e9fadfdab68856a4bbb", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -258,7 +258,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                             && self.eq_expr(l.body, r.body)\n                     })\n             },\n-            (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n+            (&ExprKind::MethodCall(l_path, l_args, _), &ExprKind::MethodCall(r_path, r_args, _)) => {\n                 self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(le, ll), &ExprKind::Repeat(re, rl)) => {\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(path, ref _tys, args, ref _fn_span) => {\n+            ExprKind::MethodCall(path, args, ref _fn_span) => {\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },"}, {"sha": "8386aaeaf44493826917dca33f3502fe8232c959", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -1059,13 +1059,13 @@ pub fn method_calls<'tcx>(\n \n     let mut current = expr;\n     for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, span, args, _) = &current.kind {\n+        if let ExprKind::MethodCall(path, args, _) = &current.kind {\n             if args.iter().any(|e| e.span.from_expansion()) {\n                 break;\n             }\n             method_names.push(path.ident.name);\n             arg_lists.push(&**args);\n-            spans.push(*span);\n+            spans.push(path.ident.span);\n             current = &args[0];\n         } else {\n             break;\n@@ -1086,7 +1086,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(path, _, args, _) = current.kind {\n+        if let ExprKind::MethodCall(path, args, _) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n                 if args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n@@ -1780,7 +1780,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 None\n             }\n         },\n-        ExprKind::MethodCall(_, _, _, _) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n+        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n         _ => None,\n     };\n "}, {"sha": "649b7b9940af3b067ab74f34a67a2cdb35cb762e", "filename": "src/tools/clippy/clippy_utils/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -36,7 +36,7 @@ fn extract_clone_suggestions<'tcx>(\n         if abort {\n             return false;\n         }\n-        if let ExprKind::MethodCall(seg, _, [recv], _) = expr.kind {\n+        if let ExprKind::MethodCall(seg, [recv], _) = expr.kind {\n             if path_to_local_id(recv, id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     abort = true;"}, {"sha": "48525f9a5725e3c6f070572023e4efb5bd105517", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -863,7 +863,7 @@ impl<'tcx> DerefDelegate<'_, 'tcx> {\n     /// indicates whether the function from `parent_expr` takes its args by double reference\n     fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n         let (call_args, inputs) = match parent_expr.kind {\n-            ExprKind::MethodCall(_, _, call_args, _) => {\n+            ExprKind::MethodCall(_, call_args, _) => {\n                 if let Some(method_did) = self.cx.typeck_results().type_dependent_def_id(parent_expr.hir_id) {\n                     (call_args, self.cx.tcx.fn_sig(method_did).skip_binder().inputs())\n                 } else {\n@@ -915,15 +915,15 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                     match &parent_expr.kind {\n                         // given expression is the self argument and will be handled completely by the compiler\n                         // i.e.: `|x| x.is_something()`\n-                        ExprKind::MethodCall(_, _, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n+                        ExprKind::MethodCall(_, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n                             self.suggestion_start\n                                 .push_str(&format!(\"{}{}\", start_snip, ident_str_with_proj));\n                             self.next_pos = span.hi();\n                             return;\n                         },\n                         // item is used in a call\n                         // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n-                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [_, call_args @ ..], _) => {\n+                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, [_, call_args @ ..], _) => {\n                             let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n                             let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n "}, {"sha": "6c8a3dc418b1517f4156a7c58a0146f4b9ca2a0a", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             // Check our expr is calling a method\n-            if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..], _) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..]) = &expr.kind;\n             // Check the name of this method is `some_method`\n             if path.ident.name == sym!(some_method);\n             // Optionally, check the type of the self argument."}, {"sha": "5e78b7c9de7e3990b3e415899ccb1ae096185cd4", "filename": "src/tools/clippy/tests/ui/author/struct.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b11733534d95aebe0b4f949f8e4c8f21c312f108/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fstruct.stdout?ref=b11733534d95aebe0b4f949f8e4c8f21c312f108", "patch": "@@ -53,7 +53,7 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n+    if let ExprKind::MethodCall(method_name, args, _) = expr.kind;\n     if method_name.ident.as_str() == \"test\";\n     if args.len() == 1;\n     if let ExprKind::Path(ref qpath) = args[0].kind;"}]}