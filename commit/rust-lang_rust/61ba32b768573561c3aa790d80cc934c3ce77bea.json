{"sha": "61ba32b768573561c3aa790d80cc934c3ce77bea", "node_id": "C_kwDOAAsO6NoAKDYxYmEzMmI3Njg1NzM1NjFjM2FhNzkwZDgwY2M5MzRjM2NlNzdiZWE", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-04-30T17:27:01Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-04-30T17:27:27Z"}, "message": "Update intravisit docs", "tree": {"sha": "f7565bf7fbb09eb298891def7532dd49e545d33d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7565bf7fbb09eb298891def7532dd49e545d33d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61ba32b768573561c3aa790d80cc934c3ce77bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61ba32b768573561c3aa790d80cc934c3ce77bea", "html_url": "https://github.com/rust-lang/rust/commit/61ba32b768573561c3aa790d80cc934c3ce77bea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61ba32b768573561c3aa790d80cc934c3ce77bea/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d201c812d40932509b2b5307c0b20c1ce78d21da", "url": "https://api.github.com/repos/rust-lang/rust/commits/d201c812d40932509b2b5307c0b20c1ce78d21da", "html_url": "https://github.com/rust-lang/rust/commit/d201c812d40932509b2b5307c0b20c1ce78d21da"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "977c0eb3cd2bcf11075dc2668488ab009855fdcd", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/61ba32b768573561c3aa790d80cc934c3ce77bea/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ba32b768573561c3aa790d80cc934c3ce77bea/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=61ba32b768573561c3aa790d80cc934c3ce77bea", "patch": "@@ -163,10 +163,15 @@ impl<'hir> Map<'hir> for ! {\n pub mod nested_filter {\n     use super::Map;\n \n-    /// Specifies what nested things a visitor wants to visit. The most\n-    /// common choice is `OnlyBodies`, which will cause the visitor to\n-    /// visit fn bodies for fns that it encounters, but skip over nested\n-    /// item-like things.\n+    /// Specifies what nested things a visitor wants to visit. By \"nested\n+    /// things\", we are referring to bits of HIR that are not directly embedded\n+    /// within one another but rather indirectly, through a table in the crate.\n+    /// This is done to control dependencies during incremental compilation: the\n+    /// non-inline bits of HIR can be tracked and hashed separately.\n+    ///\n+    /// The most common choice is `OnlyBodies`, which will cause the visitor to\n+    /// visit fn bodies for fns that it encounters, and closure bodies, but\n+    /// skip over nested item-like things.\n     ///\n     /// See the comments on `ItemLikeVisitor` for more details on the overall\n     /// visit strategy.\n@@ -217,42 +222,38 @@ use nested_filter::NestedFilter;\n pub trait Visitor<'v>: Sized {\n     // this type should not be overridden, it exists for convenient usage as `Self::Map`\n     type Map: Map<'v> = <Self::NestedFilter as NestedFilter<'v>>::Map;\n-    type NestedFilter: NestedFilter<'v> = nested_filter::None;\n \n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n \n-    /// The default versions of the `visit_nested_XXX` routines invoke\n-    /// this method to get a map to use. By selecting an enum variant,\n-    /// you control which kinds of nested HIR are visited; see\n-    /// `NestedVisitorMap` for details. By \"nested HIR\", we are\n-    /// referring to bits of HIR that are not directly embedded within\n-    /// one another but rather indirectly, through a table in the\n-    /// crate. This is done to control dependencies during incremental\n-    /// compilation: the non-inline bits of HIR can be tracked and\n-    /// hashed separately.\n+    /// Override this type to control which nested HIR are visited; see\n+    /// [`NestedFilter`] for details. If you override this type, you\n+    /// must also override [`nested_visit_map`](Self::nested_visit_map).\n     ///\n     /// **If for some reason you want the nested behavior, but don't\n-    /// have a `Map` at your disposal:** then you should override the\n-    /// `visit_nested_XXX` methods, and override this method to\n-    /// `panic!()`. This way, if a new `visit_nested_XXX` variant is\n-    /// added in the future, we will see the panic in your code and\n-    /// fix it appropriately.\n+    /// have a `Map` at your disposal:** then override the\n+    /// `visit_nested_XXX` methods. If a new `visit_nested_XXX` variant is\n+    /// added in the future, it will cause a panic which can be detected\n+    /// and fixed appropriately.\n+    type NestedFilter: NestedFilter<'v> = nested_filter::None;\n+\n+    /// If `type NestedFilter` is set to visit nested items, this method\n+    /// must also be overridden to provide a map to retrieve nested items.\n     fn nested_visit_map(&mut self) -> Self::Map {\n         panic!(\n             \"nested_visit_map must be implemented or consider using \\\n             `type NestedFilter = nested_filter::None` (the default)\"\n         );\n     }\n \n-    /// Invoked when a nested item is encountered. By default does\n-    /// nothing unless you override `nested_visit_map` to return other than\n-    /// `None`, in which case it will walk the item. **You probably\n-    /// don't want to override this method** -- instead, override\n-    /// `nested_visit_map` or use the \"shallow\" or \"deep\" visit\n-    /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n-    /// reason to override this method is if you want a nested pattern\n-    /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n+    /// Invoked when a nested item is encountered. By default, when\n+    /// `Self::NestedFilter` is `nested_filter::None`, this method does\n+    /// nothing. **You probably don't want to override this method** --\n+    /// instead, override [`Self::NestedFilter`] or use the \"shallow\" or\n+    /// \"deep\" visit patterns described on\n+    /// `itemlikevisit::ItemLikeVisitor`. The only reason to override\n+    /// this method is if you want a nested pattern but cannot supply a\n+    /// [`Map`]; see `nested_visit_map` for advice.\n     fn visit_nested_item(&mut self, id: ItemId) {\n         if Self::NestedFilter::INTER {\n             let item = self.nested_visit_map().item(id);\n@@ -291,9 +292,8 @@ pub trait Visitor<'v>: Sized {\n     }\n \n     /// Invoked to visit the body of a function, method or closure. Like\n-    /// visit_nested_item, does nothing by default unless you override\n-    /// `nested_visit_map` to return other than `None`, in which case it will walk\n-    /// the body.\n+    /// `visit_nested_item`, does nothing by default unless you override\n+    /// `Self::NestedFilter`.\n     fn visit_nested_body(&mut self, id: BodyId) {\n         if Self::NestedFilter::INTRA {\n             let body = self.nested_visit_map().body(id);"}, {"sha": "b2c6ca1354f107204af0e517e424135d8da00b8c", "filename": "compiler/rustc_hir/src/itemlikevisit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61ba32b768573561c3aa790d80cc934c3ce77bea/compiler%2Frustc_hir%2Fsrc%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ba32b768573561c3aa790d80cc934c3ce77bea/compiler%2Frustc_hir%2Fsrc%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fitemlikevisit.rs?ref=61ba32b768573561c3aa790d80cc934c3ce77bea", "patch": "@@ -17,8 +17,8 @@ use super::{ForeignItem, ImplItem, Item, TraitItem};\n ///    an item, but don't care about how item-like things are nested\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n-///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n-///      to return `NestedVisitorMap::OnlyBodies` and use\n+///    - How: Implement `intravisit::Visitor` and override the `NestedFilter` type to\n+///      `nested_filter::OnlyBodies` (and implement `nested_visit_map`), and use\n ///      `tcx.hir().visit_all_item_likes(&mut visitor.as_deep_visitor())`. Within your\n ///      `intravisit::Visitor` impl, implement methods like `visit_expr()` (don't forget to invoke\n ///      `intravisit::walk_expr()` to keep walking the subparts).\n@@ -29,9 +29,9 @@ use super::{ForeignItem, ImplItem, Item, TraitItem};\n ///    item-like things.\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n-///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n-///      to return `NestedVisitorMap::All`. Walk your crate with `intravisit::walk_crate()`\n-///      invoked on `tcx.hir().krate()`.\n+///    - How: Implement `intravisit::Visitor` and override the `NestedFilter` type to\n+///      `nested_filter::All` (and implement `nested_visit_map`). Walk your crate with\n+///      `tcx.hir().walk_toplevel_module(visitor)` invoked on `tcx.hir().krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking."}]}