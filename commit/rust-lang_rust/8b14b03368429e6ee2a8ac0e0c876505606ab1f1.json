{"sha": "8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMTRiMDMzNjg0MjllNmVlMmE4YWMwZTBjODc2NTA1NjA2YWIxZjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-14T09:29:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-14T09:29:14Z"}, "message": "Merge pull request #473 from solson/rustup\n\nrustup: Update for rustc validation fixes", "tree": {"sha": "6628cfaa293a5c7ec9415af56da108927694ee44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6628cfaa293a5c7ec9415af56da108927694ee44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbwwxqCRBK7hj4Ov3rIwAAdHIIAIXUjrmXZt67JpVyjoAhBg0w\nLuXosN2LJQf2E8L/zJWHO2Bqp5tpmc/CjgBBUMzx1WwsC25Xf7GFlaCdy07SiGeW\nZ3lGSBwlWitAvRj0D9tDuEntq4/N8BpG1We4aXWOm0yukJ2zR/dFypVPNAFMje5S\nLhMAdEhhHoK/AYfe337mAPknF15tSwUywOkoGvb1A1x0v1DZPyM3Fi2uNpzcttlf\nVFaFqgmBD0pR20QORG98J6jdmhvRt9NggCi5q60vNyLY07XSv0WOu6E8OYAlyH3u\n3bXtOMvyFU0xOVlXJPVgyjCAHSeZW6YujKjCzZk4fHiU6g4bz45shMhItXqS2Hw=\n=b4ec\n-----END PGP SIGNATURE-----\n", "payload": "tree 6628cfaa293a5c7ec9415af56da108927694ee44\nparent 7fb2fa70a7af47a5feb41c70096ec996e3365562\nparent 9a1dd865c1d91d6ad8561ba16209998388d98309\nauthor Ralf Jung <post@ralfj.de> 1539509354 +0200\ncommitter GitHub <noreply@github.com> 1539509354 +0200\n\nMerge pull request #473 from solson/rustup\n\nrustup: Update for rustc validation fixes"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "html_url": "https://github.com/rust-lang/rust/commit/8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fb2fa70a7af47a5feb41c70096ec996e3365562", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb2fa70a7af47a5feb41c70096ec996e3365562", "html_url": "https://github.com/rust-lang/rust/commit/7fb2fa70a7af47a5feb41c70096ec996e3365562"}, {"sha": "9a1dd865c1d91d6ad8561ba16209998388d98309", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1dd865c1d91d6ad8561ba16209998388d98309", "html_url": "https://github.com/rust-lang/rust/commit/9a1dd865c1d91d6ad8561ba16209998388d98309"}], "stats": {"total": 250, "additions": 167, "deletions": 83}, "files": [{"sha": "abbc6c90452ac77da289008069272ad989b1d6bd", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1 +1 @@\n-nightly-2018-10-11\n+nightly-2018-10-14"}, {"sha": "73a8d19c309b2a6929df619cd17036a39265fac9", "filename": "rustc_tests/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/rustc_tests%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/rustc_tests%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2Fsrc%2Fmain.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -95,7 +95,7 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n                     if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n                         let did = self.0.hir.body_owner_def_id(body_id);\n                         println!(\"running test: {}\", self.0.def_path_debug_str(did));\n-                        miri::eval_main(self.0, did, None);\n+                        miri::eval_main(self.0, did, None, /*validate*/true);\n                         self.1.session.abort_if_errors();\n                     }\n                 }\n@@ -106,7 +106,7 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n         state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(tcx, state));\n     } else if let Some((entry_node_id, _, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        miri::eval_main(tcx, entry_def_id, None);\n+        miri::eval_main(tcx, entry_def_id, None, /*validate*/true);\n \n         state.session.abort_if_errors();\n     } else {"}, {"sha": "d7207da0b3c08cbb90143fa0cf5766851b78c253", "filename": "src/bin/miri.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -25,10 +25,14 @@ use std::path::PathBuf;\n \n struct MiriCompilerCalls {\n     default: Box<RustcDefaultCalls>,\n-    /// Whether to begin interpretation at the start_fn lang item or not\n+\n+    /// Whether to begin interpretation at the start_fn lang item or not.\n     ///\n-    /// If false, the interpretation begins at the `main` function\n+    /// If false, the interpretation begins at the `main` function.\n     start_fn: bool,\n+\n+    /// Whether to enforce the validity invariant.\n+    validate: bool,\n }\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n@@ -87,7 +91,9 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         let mut control = this.default.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n         let start_fn = this.start_fn;\n-        control.after_analysis.callback = Box::new(move |state| after_analysis(state, start_fn));\n+        let validate = this.validate;\n+        control.after_analysis.callback =\n+            Box::new(move |state| after_analysis(state, start_fn, validate));\n         control.after_analysis.stop = Compilation::Stop;\n         control\n     }\n@@ -101,38 +107,43 @@ fn after_hir_lowering(state: &mut CompileState) {\n     state.session.plugin_attributes.borrow_mut().push(attr);\n }\n \n-fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>, use_start_fn: bool) {\n+fn after_analysis<'a, 'tcx>(\n+    state: &mut CompileState<'a, 'tcx>,\n+    use_start_fn: bool,\n+    validate: bool,\n+) {\n     state.session.abort_if_errors();\n \n     let tcx = state.tcx.unwrap();\n \n     if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a>(\n-            TyCtxt<'a, 'tcx, 'tcx>,\n-            &'a CompileState<'a, 'tcx>\n-        );\n+        struct Visitor<'a, 'tcx: 'a> {\n+            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            state: &'a CompileState<'a, 'tcx>,\n+            validate: bool,\n+        };\n         impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'hir hir::Item) {\n                 if let hir::ItemKind::Fn(.., body_id) = i.node {\n                     if i.attrs.iter().any(|attr| {\n                         attr.name() == \"test\"\n                     })\n                     {\n-                        let did = self.0.hir.body_owner_def_id(body_id);\n+                        let did = self.tcx.hir.body_owner_def_id(body_id);\n                         println!(\n                             \"running test: {}\",\n-                            self.0.def_path_debug_str(did),\n+                            self.tcx.def_path_debug_str(did),\n                         );\n-                        miri::eval_main(self.0, did, None);\n-                        self.1.session.abort_if_errors();\n+                        miri::eval_main(self.tcx, did, None, self.validate);\n+                        self.state.session.abort_if_errors();\n                     }\n                 }\n             }\n             fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n             fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n         }\n         state.hir_crate.unwrap().visit_all_item_likes(\n-            &mut Visitor(tcx, state),\n+            &mut Visitor { tcx, state, validate }\n         );\n     } else if let Some((entry_node_id, _, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n@@ -142,7 +153,7 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>, use_start_fn: bo\n         } else {\n             None\n         };\n-        miri::eval_main(tcx, entry_def_id, start_wrapper);\n+        miri::eval_main(tcx, entry_def_id, start_wrapper, validate);\n \n         state.session.abort_if_errors();\n     } else {\n@@ -221,12 +232,18 @@ fn main() {\n     }\n \n     let mut start_fn = false;\n+    let mut validate = true;\n     args.retain(|arg| {\n-        if arg == \"-Zmiri-start-fn\" {\n-            start_fn = true;\n-            false\n-        } else {\n-            true\n+        match arg.as_str() {\n+            \"-Zmiri-start-fn\" => {\n+                start_fn = true;\n+                false\n+            },\n+            \"-Zmiri-disable-validation\" => {\n+                validate = false;\n+                false\n+            },\n+            _ => true\n         }\n     });\n \n@@ -235,6 +252,7 @@ fn main() {\n         rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n             default: Box::new(RustcDefaultCalls),\n             start_fn,\n+            validate,\n         }), None, None)\n     });\n     std::process::exit(result as i32);"}, {"sha": "812df49b0b8fa73a9869a635db94b3a2f79a63ed", "filename": "src/fn_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -252,12 +252,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n                 // and of course eval_main.\n                 let mir = self.load_mir(f_instance.def)?;\n-                let closure_dest = Place::null(&self);\n+                let ret_place = MPlaceTy::dangling(self.layout_of(self.tcx.mk_unit())?, &self).into();\n                 self.push_stack_frame(\n                     f_instance,\n                     mir.span,\n                     mir,\n-                    closure_dest,\n+                    Some(ret_place),\n                     StackPopCleanup::Goto(Some(ret)), // directly return to caller\n                 )?;\n                 let mut args = self.frame().mir.args_iter();"}, {"sha": "19c4f04f4826e53dcd16ad6ec2d8cb5cca3200f5", "filename": "src/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -238,7 +238,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"init\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,\n                 // but we also do not want to create a new allocation with 0s and then copy that over.\n-                if !dest.layout.is_zst() { // notzhing to do for ZST\n+                // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n+                // However, this only affects direct calls of the intrinsic; calls to the stable\n+                // functions wrapping them do get their validation.\n+                if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n                             let x = Scalar::from_int(0, s.value.size(&self));\n@@ -338,7 +341,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"size_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let (size, _) = self.size_and_align_of_mplace(mplace)?;\n+                let (size, _) = self.size_and_align_of_mplace(mplace)?\n+                    .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(size.bytes() as u128, ptr_size),\n@@ -349,7 +353,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let (_, align) = self.size_and_align_of_mplace(mplace)?;\n+                let (_, align) = self.size_and_align_of_mplace(mplace)?\n+                    .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(align.abi(), ptr_size),\n@@ -397,6 +402,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"uninit\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,\n                 // but we also do not want to create a new allocation with 0s and then copy that over.\n+                // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n+                // However, this only affects direct calls of the intrinsic; calls to the stable\n+                // functions wrapping them do get their validation.\n                 if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {"}, {"sha": "0bebe40d529af6f3a17a947ea2a09194fad3c8a2", "filename": "src/lib.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -50,11 +50,12 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n     start_wrapper: Option<DefId>,\n+    validate: bool,\n ) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>> {\n     let mut ecx = EvalContext::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Default::default(),\n+        Evaluator::new(validate),\n         Default::default(),\n     );\n \n@@ -67,7 +68,6 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n                 .to_owned(),\n         ));\n     }\n-    let ptr_size = ecx.memory.pointer_size();\n \n     if let Some(start_id) = start_wrapper {\n         let main_ret_ty = ecx.tcx.fn_sig(main_id).output();\n@@ -89,16 +89,15 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         }\n \n         // Return value (in static memory so that it does not count as leak)\n-        let size = ecx.tcx.data_layout.pointer_size;\n-        let align = ecx.tcx.data_layout.pointer_align;\n-        let ret_ptr = ecx.memory_mut().allocate(size, align, MiriMemoryKind::MutStatic.into())?;\n+        let ret = ecx.layout_of(start_mir.return_ty())?;\n+        let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into())?;\n \n         // Push our stack frame\n         ecx.push_stack_frame(\n             start_instance,\n             start_mir.span,\n             start_mir,\n-            Place::from_ptr(ret_ptr, align),\n+            Some(ret_ptr.into()),\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n@@ -126,11 +125,12 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n         assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n     } else {\n+        let ret_place = MPlaceTy::dangling(ecx.layout_of(tcx.mk_unit())?, &ecx).into();\n         ecx.push_stack_frame(\n             main_instance,\n             main_mir.span,\n             main_mir,\n-            Place::from_scalar_ptr(Scalar::from_int(1, ptr_size).into(), ty::layout::Align::from_bytes(1, 1).unwrap()),\n+            Some(ret_place),\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n@@ -146,8 +146,9 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n     start_wrapper: Option<DefId>,\n+    validate: bool,\n ) {\n-    let mut ecx = create_ecx(tcx, main_id, start_wrapper).expect(\"Couldn't create ecx\");\n+    let mut ecx = create_ecx(tcx, main_id, start_wrapper, validate).expect(\"Couldn't create ecx\");\n \n     let res: EvalResult = (|| {\n         ecx.run()?;\n@@ -222,14 +223,27 @@ impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n }\n \n \n-#[derive(Clone, Default, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n     pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n \n     /// TLS state\n     pub(crate) tls: TlsData<'tcx>,\n+\n+    /// Whether to enforce the validity invariant\n+    pub(crate) validate: bool,\n+}\n+\n+impl<'tcx> Evaluator<'tcx> {\n+    fn new(validate: bool) -> Self {\n+        Evaluator {\n+            env_vars: HashMap::default(),\n+            tls: TlsData::default(),\n+            validate,\n+        }\n+    }\n }\n \n impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n@@ -240,7 +254,29 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<()>)>;\n \n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n-    const ENFORCE_VALIDITY: bool = false; // this is still WIP\n+\n+    fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {\n+        if !ecx.machine.validate {\n+            return false;\n+        }\n+\n+        // Some functions are whitelisted until we figure out how to fix them.\n+        // We walk up the stack a few frames to also cover their callees.\n+        const WHITELIST: &[&str] = &[\n+            // Uses mem::uninitialized\n+            \"std::ptr::read\",\n+            \"std::sys::windows::mutex::Mutex::\",\n+        ];\n+        for frame in ecx.stack().iter()\n+            .rev().take(3)\n+        {\n+            let name = frame.instance.to_string();\n+            if WHITELIST.iter().any(|white| name.starts_with(white)) {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn find_fn(\n@@ -286,7 +322,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             malloc,\n             malloc_mir.span,\n             malloc_mir,\n-            *dest,\n+            Some(dest),\n             // Don't do anything when we are done.  The statement() function will increment\n             // the old stack frame's stmt counter to the next statement, which means that when\n             // exchange_malloc returns, we go on evaluating exactly where we want to be."}, {"sha": "c04f7a9c350204cc8882eb1a0c1fe3d7d8e31ef5", "filename": "src/tls.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,9 +1,12 @@\n use std::collections::BTreeMap;\n \n+use rustc_target::abi::LayoutOf;\n use rustc::{ty, ty::layout::HasDataLayout, mir};\n \n-use super::{EvalResult, EvalErrorKind, Scalar, Evaluator,\n-            Place, StackPopCleanup, EvalContext};\n+use super::{\n+    EvalResult, EvalErrorKind, StackPopCleanup, EvalContext, Evaluator,\n+    MPlaceTy, Scalar,\n+};\n \n pub type TlsKey = u128;\n \n@@ -139,12 +142,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             // TODO: Potentially, this has to support all the other possible instances?\n             // See eval_fn_call in interpret/terminator/mod.rs\n             let mir = self.load_mir(instance.def)?;\n-            let ret = Place::null(&self);\n+            let ret_place = MPlaceTy::dangling(self.layout_of(self.tcx.mk_unit())?, &self).into();\n             self.push_stack_frame(\n                 instance,\n                 mir.span,\n                 mir,\n-                ret,\n+                Some(ret_place),\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n             let arg_local = self.frame().mir.args_iter().next().ok_or_else("}, {"sha": "cbf370e0236300addd9a3df43b951f29c9e12cbd", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n fn main() {\n     let b = Box::new(42);"}, {"sha": "2a08d9f1f9f85080fabd5bec569f188b1bb9d3ad", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n fn main() {\n     let g = unsafe {"}, {"sha": "2f8fea38d8f9f984463bfa085767417327c7f400", "filename": "tests/compile-fail/execute_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n #![feature(box_syntax)]\n "}, {"sha": "e6d1da1e0736a9dc2b6d5e049a5303c38cf6c54b", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n use std::mem;\n "}, {"sha": "af4ad67a4f0999db940cabdb65cff97b6433b0b3", "filename": "tests/compile-fail/invalid_bool.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_bool.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,9 +1,3 @@\n-//ignore-test FIXME: do some basic validation of invariants for all values in flight\n-//This does currently not get caught becuase it compiles to SwitchInt, which\n-//has no knowledge about data invariants.\n-\n fn main() {\n-    let b = unsafe { std::mem::transmute::<u8, bool>(2) };\n-    if b { unreachable!() } else { unreachable!() } //~ ERROR constant evaluation error\n-    //~^ NOTE invalid boolean value read\n+    let _b = unsafe { std::mem::transmute::<u8, bool>(2) }; //~ ERROR encountered 2, but expected something in the range 0..=1\n }"}, {"sha": "2348c62559b00523cbe626d9d055e023f88690ce", "filename": "tests/compile-fail/invalid_bool2.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_bool2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_bool2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_bool2.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,3 +1,6 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n fn main() {\n     let b = unsafe { std::mem::transmute::<u8, bool>(2) };\n     let _x = b == true; //~ ERROR invalid boolean value read"}, {"sha": "3ff0ed60f664c53e3a247a6c8e03470deb450a06", "filename": "tests/compile-fail/invalid_char.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_char.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    assert!(std::char::from_u32(-1_i32 as u32).is_none());\n+    let _ = match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR encountered 4294967295, but expected something in the range 0..=1114111\n+        'a' => {true},\n+        'b' => {false},\n+        _ => {true},\n+    };\n+}"}, {"sha": "5de2d073f3231f752d099ae670a6214b808d34a8", "filename": "tests/compile-fail/invalid_char2.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_char2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_char2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_char2.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,3 +1,6 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n fn main() {\n     assert!(std::char::from_u32(-1_i32 as u32).is_none());\n     let c = unsafe { std::mem::transmute::<i32, char>(-1) };", "previous_filename": "tests/compile-fail/match_char2.rs"}, {"sha": "543a797d44f20de0fa0492bbd4fcc35f21fdcdd8", "filename": "tests/compile-fail/invalid_enum_discriminant.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,17 +1,8 @@\n-// Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n-\n #[repr(C)]\n pub enum Foo {\n     A, B, C, D\n }\n \n fn main() {\n-    let f = unsafe { std::mem::transmute::<i32, Foo>(42) };\n-    match f {\n-        Foo::A => {}, //~ ERROR invalid enum discriminant\n-        Foo::B => {},\n-        Foo::C => {},\n-        Foo::D => {},\n-    }\n+    let _f = unsafe { std::mem::transmute::<i32, Foo>(42) }; //~ ERROR encountered invalid enum discriminant 42\n }"}, {"sha": "ea94081693e1bea559248e79dd8b8b3526a4cad8", "filename": "tests/compile-fail/invalid_enum_discriminant2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_enum_discriminant2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Finvalid_enum_discriminant2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_enum_discriminant2.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n // error-pattern: invalid enum discriminant\n "}, {"sha": "e7fee1e3e36112f76d3d847daa6a885d1418cb05", "filename": "tests/compile-fail/match_char.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7fb2fa70a7af47a5feb41c70096ec996e3365562/tests%2Fcompile-fail%2Fmatch_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb2fa70a7af47a5feb41c70096ec996e3365562/tests%2Fcompile-fail%2Fmatch_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_char.rs?ref=7fb2fa70a7af47a5feb41c70096ec996e3365562", "patch": "@@ -1,13 +0,0 @@\n-//ignore-test FIXME: do some basic validation of invariants for all values in flight\n-//This does currently not get caught becuase it compiles to SwitchInt, which\n-//has no knowledge about data invariants.\n-\n-fn main() {\n-    assert!(std::char::from_u32(-1_i32 as u32).is_none());\n-    let _ = match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR constant evaluation error\n-        //~^ NOTE tried to interpret an invalid 32-bit value as a char: 4294967295\n-        'a' => {true},\n-        'b' => {false},\n-        _ => {true},\n-    };\n-}"}, {"sha": "9821723deb3bc828eb4686d1a24be57649dee8a4", "filename": "tests/compile-fail/never_say_never.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fnever_say_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fnever_say_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_say_never.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n #![feature(never_type)]\n #![allow(unreachable_code)]"}, {"sha": "c5c53d4231c7c516f18c4c50db30d18e3e766d9a", "filename": "tests/compile-fail/never_transmute_humans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_humans.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n #![feature(never_type)]\n #![allow(unreachable_code)]"}, {"sha": "11fc0f068de0d80104f54df2c5c5739ae61bc386", "filename": "tests/compile-fail/never_transmute_void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_void.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n #![feature(never_type)]\n #![allow(unreachable_code)]"}, {"sha": "d18f314c8aaa168c3d75628a17613783fd1bba15", "filename": "tests/compile-fail/reference_to_packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Freference_to_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Freference_to_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freference_to_packed.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n #![allow(dead_code, unused_variables)]\n "}, {"sha": "69917dce8591073b314170c02ce61281d742bcd5", "filename": "tests/compile-fail/storage_dead_dangling.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fstorage_dead_dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fstorage_dead_dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstorage_dead_dangling.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,3 +1,6 @@\n+// This should fail even without validation\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n static mut LEAK: usize = 0;\n \n fn fill(v: &mut i32) {"}, {"sha": "82f2d10ee4bb5e94439135fc8dcda014c390b904", "filename": "tests/compile-fail/validation_cast_fn_ptr1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fvalidation_cast_fn_ptr1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fvalidation_cast_fn_ptr1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_cast_fn_ptr1.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    // Cast a function pointer such that on a call, the argument gets transmuted\n+    // from raw ptr to reference.  This is ABI-compatible, so it's not the call that\n+    // should fail, but validation should.\n+    fn f(_x: &i32) { }\n+\n+    let g: fn(*const i32) = unsafe { std::mem::transmute(f as fn(&i32)) };\n+\n+    g(0usize as *const i32) //~ ERROR encountered 0, but expected something greater or equal to 1\n+}"}, {"sha": "2f3b91a53e622a2b7c91db07fc6827b831595686", "filename": "tests/compile-fail/validation_cast_fn_ptr2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fvalidation_cast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Fcompile-fail%2Fvalidation_cast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_cast_fn_ptr2.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    // Cast a function pointer such that when returning, the return value gets transmuted\n+    // from raw ptr to reference.  This is ABI-compatible, so it's not the call that\n+    // should fail, but validation should.\n+    fn f() -> *const i32 { 0usize as *const i32 }\n+\n+    let g: fn() -> &'static i32 = unsafe { std::mem::transmute(f as fn() -> *const i32) };\n+\n+    let _x = g(); //~ ERROR encountered 0, but expected something greater or equal to 1\n+}"}, {"sha": "dc0fa0987aebb65a577263747c00507924d42775", "filename": "tests/run-pass/btreemap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Frun-pass%2Fbtreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Frun-pass%2Fbtreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbtreemap.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,5 +1,5 @@\n-// mir validation can't cope with `mem::uninitialized()`, so this test fails with validation & full-MIR.\n-// compile-flags: -Zmir-emit-validate=0\n+// FIXME: Validation disabled due to https://github.com/rust-lang/rust/issues/54957\n+// compile-flags: -Zmiri-disable-validation\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub enum Foo {\n@@ -14,4 +14,6 @@ pub fn main() {\n     b.insert(Foo::A(\"/=\"));\n     b.insert(Foo::A(\"#\"));\n     b.insert(Foo::A(\"0o\"));\n+    assert!(b.remove(&Foo::A(\"/=\")));\n+    assert!(!b.remove(&Foo::A(\"/=\")));\n }"}, {"sha": "4d89066035cebb97cba9ea33ad75a811faac25c5", "filename": "tests/run-pass/rc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Frun-pass%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Frun-pass%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frc.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Validation disabled due to https://github.com/rust-lang/rust/issues/54908\n+// compile-flags: -Zmiri-disable-validation\n+\n use std::cell::RefCell;\n use std::rc::Rc;\n "}, {"sha": "627c821a9f307bd088fdffb249f51ff28dd64cd7", "filename": "tests/run-pass/ref-invalid-ptr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Frun-pass%2Fref-invalid-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b14b03368429e6ee2a8ac0e0c876505606ab1f1/tests%2Frun-pass%2Fref-invalid-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fref-invalid-ptr.rs?ref=8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "patch": "@@ -1,7 +1,12 @@\n+// FIXME validation disabled because it checks these references too eagerly\n+// compile-flags: -Zmiri-disable-validation\n+\n fn main() {\n     let x = 2usize as *const u32;\n+    // this is not aligned, but we immediately cast it to a raw ptr so that must be okay\n     let _y = unsafe { &*x as *const u32 };\n \n     let x = 0usize as *const u32;\n+    // this is NULL, but we immediately cast it to a raw ptr so that must be okay\n     let _y = unsafe { &*x as *const u32 };\n }"}]}