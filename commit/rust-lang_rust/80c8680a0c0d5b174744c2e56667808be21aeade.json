{"sha": "80c8680a0c0d5b174744c2e56667808be21aeade", "node_id": "C_kwDOAAsO6NoAKDgwYzg2ODBhMGMwZDViMTc0NzQ0YzJlNTY2Njc4MDhiZTIxYWVhZGU", "commit": {"author": {"name": "Konrad Borowski", "email": "konrad@borowski.pw", "date": "2022-09-21T14:03:49Z"}, "committer": {"name": "Konrad Borowski", "email": "konrad@borowski.pw", "date": "2022-09-21T14:06:20Z"}, "message": "Use fetch_update in sync::Weak::upgrade", "tree": {"sha": "d0f09bfdd1ecb27cd5bd227c989f731022a5407c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0f09bfdd1ecb27cd5bd227c989f731022a5407c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80c8680a0c0d5b174744c2e56667808be21aeade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80c8680a0c0d5b174744c2e56667808be21aeade", "html_url": "https://github.com/rust-lang/rust/commit/80c8680a0c0d5b174744c2e56667808be21aeade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80c8680a0c0d5b174744c2e56667808be21aeade/comments", "author": {"login": "xfix", "id": 1297598, "node_id": "MDQ6VXNlcjEyOTc1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1297598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xfix", "html_url": "https://github.com/xfix", "followers_url": "https://api.github.com/users/xfix/followers", "following_url": "https://api.github.com/users/xfix/following{/other_user}", "gists_url": "https://api.github.com/users/xfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/xfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xfix/subscriptions", "organizations_url": "https://api.github.com/users/xfix/orgs", "repos_url": "https://api.github.com/users/xfix/repos", "events_url": "https://api.github.com/users/xfix/events{/privacy}", "received_events_url": "https://api.github.com/users/xfix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xfix", "id": 1297598, "node_id": "MDQ6VXNlcjEyOTc1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1297598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xfix", "html_url": "https://github.com/xfix", "followers_url": "https://api.github.com/users/xfix/followers", "following_url": "https://api.github.com/users/xfix/following{/other_user}", "gists_url": "https://api.github.com/users/xfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/xfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xfix/subscriptions", "organizations_url": "https://api.github.com/users/xfix/orgs", "repos_url": "https://api.github.com/users/xfix/repos", "events_url": "https://api.github.com/users/xfix/events{/privacy}", "received_events_url": "https://api.github.com/users/xfix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba4a389b3961a2fd72e01bd6cb0b0e065edaf3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba4a389b3961a2fd72e01bd6cb0b0e065edaf3d", "html_url": "https://github.com/rust-lang/rust/commit/cba4a389b3961a2fd72e01bd6cb0b0e065edaf3d"}], "stats": {"total": 39, "additions": 16, "deletions": 23}, "files": [{"sha": "fc000cce8f817ec6919dbf6ebc8c47b6ec7956ac", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/80c8680a0c0d5b174744c2e56667808be21aeade/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c8680a0c0d5b174744c2e56667808be21aeade/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=80c8680a0c0d5b174744c2e56667808be21aeade", "patch": "@@ -1980,33 +1980,26 @@ impl<T: ?Sized> Weak<T> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add as this function should never take the reference count\n         // from zero to one.\n-        let inner = self.inner()?;\n-\n-        // Relaxed load because any write of 0 that we can observe\n-        // leaves the field in a permanently zero state (so a\n-        // \"stale\" read of 0 is fine), and any other value is\n-        // confirmed via the CAS below.\n-        let mut n = inner.strong.load(Relaxed);\n-\n-        loop {\n-            if n == 0 {\n-                return None;\n-            }\n-\n-            // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n-            if n > MAX_REFCOUNT {\n-                abort();\n-            }\n-\n+        self.inner()?\n+            .strong\n             // Relaxed is fine for the failure case because we don't have any expectations about the new state.\n             // Acquire is necessary for the success case to synchronise with `Arc::new_cyclic`, when the inner\n             // value can be initialized after `Weak` references have already been created. In that case, we\n             // expect to observe the fully initialized value.\n-            match inner.strong.compare_exchange_weak(n, n + 1, Acquire, Relaxed) {\n-                Ok(_) => return Some(unsafe { Arc::from_inner(self.ptr) }), // null checked above\n-                Err(old) => n = old,\n-            }\n-        }\n+            .fetch_update(Acquire, Relaxed, |n| {\n+                // Any write of 0 we can observe leaves the field in permanently zero state.\n+                if n == 0 {\n+                    return None;\n+                }\n+                // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n+                if n > MAX_REFCOUNT {\n+                    abort();\n+                }\n+                Some(n + 1)\n+            })\n+            .ok()\n+            // null checked above\n+            .map(|_| unsafe { Arc::from_inner(self.ptr) })\n     }\n \n     /// Gets the number of strong (`Arc`) pointers pointing to this allocation."}]}