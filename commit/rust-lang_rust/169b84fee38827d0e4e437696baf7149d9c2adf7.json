{"sha": "169b84fee38827d0e4e437696baf7149d9c2adf7", "node_id": "C_kwDOAAsO6NoAKDE2OWI4NGZlZTM4ODI3ZDBlNGU0Mzc2OTZiYWY3MTQ5ZDljMmFkZjc", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-10T02:09:09Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-10T02:09:09Z"}, "message": "Replace where-bounded Clean impl with function\n\nThis was the only Clean impl I found with `where` bounds.\n\nThis impl was doubly-confusing: it was implemented on a tuple and it\nwas polymorphic. Combined, this caused a \"spooky action at a distance\"\neffect to make the code very confusing.", "tree": {"sha": "3bcf891e81705525e0f3395f08c05f86726b4cb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bcf891e81705525e0f3395f08c05f86726b4cb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/169b84fee38827d0e4e437696baf7149d9c2adf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/169b84fee38827d0e4e437696baf7149d9c2adf7", "html_url": "https://github.com/rust-lang/rust/commit/169b84fee38827d0e4e437696baf7149d9c2adf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/169b84fee38827d0e4e437696baf7149d9c2adf7/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c57704f3eb4319cc93513c232e9c434a73af46d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c57704f3eb4319cc93513c232e9c434a73af46d2", "html_url": "https://github.com/rust-lang/rust/commit/c57704f3eb4319cc93513c232e9c434a73af46d2"}], "stats": {"total": 30, "additions": 17, "deletions": 13}, "files": [{"sha": "2fbccfda8e67497d0286b727a92ea008a2c46b84", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/169b84fee38827d0e4e437696baf7149d9c2adf7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169b84fee38827d0e4e437696baf7149d9c2adf7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=169b84fee38827d0e4e437696baf7149d9c2adf7", "patch": "@@ -761,8 +761,9 @@ fn clean_fn_or_proc_macro(\n \n impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n-        let (generics, decl) =\n-            enter_impl_trait(cx, |cx| (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n+        let (generics, decl) = enter_impl_trait(cx, |cx| {\n+            (self.1.clean(cx), clean_fn_decl_with_args(cx, &*self.0.decl, self.2))\n+        });\n         Function { decl, generics, header: self.0.header }\n     }\n }\n@@ -804,16 +805,18 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n     }\n }\n \n-impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl<'a>, A)\n+fn clean_fn_decl_with_args<'a, A: Copy>(\n+    cx: &mut DocContext<'_>,\n+    decl: &'a hir::FnDecl<'a>,\n+    args: A,\n+) -> FnDecl\n where\n     (&'a [hir::Ty<'a>], A): Clean<Arguments>,\n {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n-        FnDecl {\n-            inputs: (self.0.inputs, self.1).clean(cx),\n-            output: self.0.output.clean(cx),\n-            c_variadic: self.0.c_variadic,\n-        }\n+    FnDecl {\n+        inputs: (decl.inputs, args).clean(cx),\n+        output: decl.output.clean(cx),\n+        c_variadic: decl.c_variadic,\n     }\n }\n \n@@ -894,7 +897,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n                     let (generics, decl) = enter_impl_trait(cx, |cx| {\n-                        (self.generics.clean(cx), (sig.decl, names).clean(cx))\n+                        (self.generics.clean(cx), clean_fn_decl_with_args(cx, sig.decl, names))\n                     });\n                     let mut t = Function { header: sig.header, decl, generics };\n                     if t.header.constness == hir::Constness::Const\n@@ -1728,7 +1731,7 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             let generic_params = self.generic_params.iter().map(|x| x.clean(cx)).collect();\n-            let decl = (self.decl, self.param_names).clean(cx);\n+            let decl = clean_fn_decl_with_args(cx, self.decl, self.param_names);\n             (generic_params, decl)\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n@@ -2025,8 +2028,9 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n             let kind = match item.kind {\n                 hir::ForeignItemKind::Fn(decl, names, ref generics) => {\n                     let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n-                    let (generics, decl) =\n-                        enter_impl_trait(cx, |cx| (generics.clean(cx), (decl, names).clean(cx)));\n+                    let (generics, decl) = enter_impl_trait(cx, |cx| {\n+                        (generics.clean(cx), clean_fn_decl_with_args(cx, decl, names))\n+                    });\n                     ForeignFunctionItem(Function {\n                         decl,\n                         generics,"}]}