{"sha": "1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "node_id": "C_kwDOAAsO6NoAKDFmMTQ3YTJlZDc2NzFjYWNkOGFiNDIzZDg5NzlhMWNjZmE0NDQzYWI", "commit": {"author": {"name": "Julian Wollersberger", "email": "julian.wollersberger@gmx.at", "date": "2021-11-30T15:06:58Z"}, "committer": {"name": "Julian Wollersberger", "email": "julian.wollersberger@gmx.at", "date": "2021-12-01T18:14:10Z"}, "message": "Replace `nth_char(0)` with `next()` in `cursor.first()`\nand optimize the iterator returned by `tokenize().\n\nThis improves lexer performance by 35%", "tree": {"sha": "7ceb843b858469295039282f0417caac325bb010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ceb843b858469295039282f0417caac325bb010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "html_url": "https://github.com/rust-lang/rust/commit/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab/comments", "author": null, "committer": null, "parents": [{"sha": "72d66064e77281536588189a916af28a1819b313", "url": "https://api.github.com/repos/rust-lang/rust/commits/72d66064e77281536588189a916af28a1819b313", "html_url": "https://github.com/rust-lang/rust/commit/72d66064e77281536588189a916af28a1819b313"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "0ba6c56dbb50147b7e54ad80dccdeb7b00649c39", "filename": "compiler/rustc_lexer/src/cursor.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab/compiler%2Frustc_lexer%2Fsrc%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab/compiler%2Frustc_lexer%2Fsrc%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Fcursor.rs?ref=1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "patch": "@@ -2,10 +2,11 @@ use std::str::Chars;\n \n /// Peekable iterator over a char sequence.\n ///\n-/// Next characters can be peeked via `nth_char` method,\n+/// Next characters can be peeked via `first` method,\n /// and position can be shifted forward via `bump` method.\n pub(crate) struct Cursor<'a> {\n     initial_len: usize,\n+    /// Iterator over chars. Slightly faster than a &str.\n     chars: Chars<'a>,\n     #[cfg(debug_assertions)]\n     prev: char,\n@@ -37,22 +38,21 @@ impl<'a> Cursor<'a> {\n         }\n     }\n \n-    /// Returns nth character relative to the current cursor position.\n+    /// Peeks the next symbol from the input stream without consuming it.\n     /// If requested position doesn't exist, `EOF_CHAR` is returned.\n     /// However, getting `EOF_CHAR` doesn't always mean actual end of file,\n     /// it should be checked with `is_eof` method.\n-    fn nth_char(&self, n: usize) -> char {\n-        self.chars().nth(n).unwrap_or(EOF_CHAR)\n-    }\n-\n-    /// Peeks the next symbol from the input stream without consuming it.\n     pub(crate) fn first(&self) -> char {\n-        self.nth_char(0)\n+        // `.next()` optimizes better than `.nth(0)`\n+        self.chars.clone().next().unwrap_or(EOF_CHAR)\n     }\n \n     /// Peeks the second symbol from the input stream without consuming it.\n     pub(crate) fn second(&self) -> char {\n-        self.nth_char(1)\n+        // `.next()` optimizes better than `.nth(1)`\n+        let mut iter = self.chars.clone();\n+        iter.next();\n+        iter.next().unwrap_or(EOF_CHAR)\n     }\n \n     /// Checks if there is nothing more to consume.\n@@ -65,9 +65,9 @@ impl<'a> Cursor<'a> {\n         self.initial_len - self.chars.as_str().len()\n     }\n \n-    /// Returns a `Chars` iterator over the remaining characters.\n-    fn chars(&self) -> Chars<'a> {\n-        self.chars.clone()\n+    /// Resets the number of bytes consumed to 0.\n+    pub(crate) fn reset_len_consumed(&mut self) {\n+        self.initial_len = self.chars.as_str().len();\n     }\n \n     /// Moves to the next character.\n@@ -81,4 +81,13 @@ impl<'a> Cursor<'a> {\n \n         Some(c)\n     }\n+\n+    /// Eats symbols while predicate returns true or until the end of file is reached.\n+    pub(crate) fn eat_while(&mut self, mut predicate: impl FnMut(char) -> bool) {\n+        // It was tried making optimized version of this for eg. line comments, but\n+        // LLVM can inline all of this and compile it down to fast iteration over bytes.\n+        while predicate(self.first()) && !self.is_eof() {\n+            self.bump();\n+        }\n+    }\n }"}, {"sha": "08cd2d29c410fc6a15d0c543a14cea8ce500a6a4", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "patch": "@@ -225,14 +225,15 @@ pub fn first_token(input: &str) -> Token {\n }\n \n /// Creates an iterator that produces tokens from the input string.\n-pub fn tokenize(mut input: &str) -> impl Iterator<Item = Token> + '_ {\n+pub fn tokenize(input: &str) -> impl Iterator<Item = Token> + '_ {\n+    let mut cursor = Cursor::new(input);\n     std::iter::from_fn(move || {\n-        if input.is_empty() {\n-            return None;\n+        if cursor.is_eof() {\n+            None\n+        } else {\n+            cursor.reset_len_consumed();\n+            Some(cursor.advance_token())\n         }\n-        let token = first_token(input);\n-        input = &input[token.len..];\n-        Some(token)\n     })\n }\n \n@@ -808,11 +809,4 @@ impl Cursor<'_> {\n \n         self.eat_while(is_id_continue);\n     }\n-\n-    /// Eats symbols while predicate returns true or until the end of file is reached.\n-    fn eat_while(&mut self, mut predicate: impl FnMut(char) -> bool) {\n-        while predicate(self.first()) && !self.is_eof() {\n-            self.bump();\n-        }\n-    }\n }"}]}