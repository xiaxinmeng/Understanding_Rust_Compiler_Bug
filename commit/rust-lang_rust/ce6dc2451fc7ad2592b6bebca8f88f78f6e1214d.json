{"sha": "ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNmRjMjQ1MWZjN2FkMjU5MmI2YmViY2E4Zjg4Zjc4ZjZlMTIxNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-16T10:25:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-16T10:25:43Z"}, "message": "auto merge of #6520 : thestinger/rust/rc, r=pcwalton\n\nThis is still enough to prevent cycles (explanation given in the docstring).", "tree": {"sha": "8e723dfd461af774421fa93d775661d0ce031721", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e723dfd461af774421fa93d775661d0ce031721"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d", "html_url": "https://github.com/rust-lang/rust/commit/ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "800e3c76a70624d4cb8d0d81f87f4ac034cfb9d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/800e3c76a70624d4cb8d0d81f87f4ac034cfb9d3", "html_url": "https://github.com/rust-lang/rust/commit/800e3c76a70624d4cb8d0d81f87f4ac034cfb9d3"}, {"sha": "4702667a62be3286828e2c43094cbfbcfd26ad2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4702667a62be3286828e2c43094cbfbcfd26ad2a", "html_url": "https://github.com/rust-lang/rust/commit/4702667a62be3286828e2c43094cbfbcfd26ad2a"}], "stats": {"total": 108, "additions": 66, "deletions": 42}, "files": [{"sha": "46f50eafec160a57658ac5893a4520fe72f32fdc", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 66, "deletions": 42, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=ce6dc2451fc7ad2592b6bebca8f88f78f6e1214d", "patch": "@@ -11,7 +11,11 @@\n /** Task-local reference counted smart pointers\n \n Task-local reference counted smart pointers are an alternative to managed boxes with deterministic\n-destruction. They are restricted to containing `Owned` types in order to prevent cycles.\n+destruction. They are restricted to containing types that are either `Owned` or `Const` (or both) to\n+prevent cycles.\n+\n+Neither `Rc<T>` or `RcMut<T>` is ever `Owned` and `RcMut<T>` is never `Const`. If `T` is `Const`, a\n+cycle cannot be created with `Rc<T>` because there is no way to modify it after creation.\n \n */\n \n@@ -30,16 +34,26 @@ pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>,\n }\n \n-pub impl<T: Owned> Rc<T> {\n-    fn new(value: T) -> Rc<T> {\n-        unsafe {\n-            let ptr = malloc(sys::size_of::<RcBox<T>>() as size_t) as *mut RcBox<T>;\n-            assert!(!ptr::is_null(ptr));\n-            intrinsics::move_val_init(&mut *ptr, RcBox{value: value, count: 1});\n-            Rc{ptr: ptr}\n-        }\n+priv impl<T> Rc<T> {\n+    unsafe fn new(value: T) -> Rc<T> {\n+        let ptr = malloc(sys::size_of::<RcBox<T>>() as size_t) as *mut RcBox<T>;\n+        assert!(!ptr::is_null(ptr));\n+        intrinsics::move_val_init(&mut *ptr, RcBox{value: value, count: 1});\n+        Rc{ptr: ptr}\n     }\n+}\n+\n+// FIXME: #6516: should be a static method\n+pub fn rc_from_owned<T: Owned>(value: T) -> Rc<T> {\n+    unsafe { Rc::new(value) }\n+}\n+\n+// FIXME: #6516: should be a static method\n+pub fn rc_from_const<T: Const>(value: T) -> Rc<T> {\n+    unsafe { Rc::new(value) }\n+}\n \n+pub impl<T> Rc<T> {\n     #[inline(always)]\n     fn borrow<'r>(&'r self) -> &'r T {\n         unsafe { cast::copy_lifetime(self, &(*self.ptr).value) }\n@@ -48,7 +62,7 @@ pub impl<T: Owned> Rc<T> {\n \n #[unsafe_destructor]\n #[cfg(not(stage0))]\n-impl<T: Owned> Drop for Rc<T> {\n+impl<T> Drop for Rc<T> {\n     fn finalize(&self) {\n         unsafe {\n             (*self.ptr).count -= 1;\n@@ -62,7 +76,7 @@ impl<T: Owned> Drop for Rc<T> {\n \n #[unsafe_destructor]\n #[cfg(stage0)]\n-impl<T: Owned> Drop for Rc<T> {\n+impl<T> Drop for Rc<T> {\n     fn finalize(&self) {\n         unsafe {\n             (*self.ptr).count -= 1;\n@@ -75,7 +89,7 @@ impl<T: Owned> Drop for Rc<T> {\n }\n \n \n-impl<T: Owned> Clone for Rc<T> {\n+impl<T> Clone for Rc<T> {\n     /// Return a shallow copy of the reference counted pointer.\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n@@ -86,11 +100,11 @@ impl<T: Owned> Clone for Rc<T> {\n     }\n }\n \n-impl<T: Owned + DeepClone> DeepClone for Rc<T> {\n+impl<T: DeepClone> DeepClone for Rc<T> {\n     /// Return a deep copy of the reference counted pointer.\n     #[inline]\n     fn deep_clone(&self) -> Rc<T> {\n-        Rc::new(self.borrow().deep_clone())\n+        unsafe { Rc::new(self.borrow().deep_clone()) }\n     }\n }\n \n@@ -101,7 +115,7 @@ mod test_rc {\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::new(Cell(5));\n+        let x = rc_from_owned(Cell(5));\n         let y = x.clone();\n         do x.borrow().with_mut_ref |inner| {\n             *inner = 20;\n@@ -111,7 +125,7 @@ mod test_rc {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Rc::new(Cell(5));\n+        let x = rc_from_owned(Cell(5));\n         let y = x.deep_clone();\n         do x.borrow().with_mut_ref |inner| {\n             *inner = 20;\n@@ -121,21 +135,21 @@ mod test_rc {\n \n     #[test]\n     fn test_simple() {\n-        let x = Rc::new(5);\n+        let x = rc_from_const(5);\n         assert_eq!(*x.borrow(), 5);\n     }\n \n     #[test]\n     fn test_simple_clone() {\n-        let x = Rc::new(5);\n+        let x = rc_from_const(5);\n         let y = x.clone();\n         assert_eq!(*x.borrow(), 5);\n         assert_eq!(*y.borrow(), 5);\n     }\n \n     #[test]\n     fn test_destructor() {\n-        let x = Rc::new(~5);\n+        let x = rc_from_owned(~5);\n         assert_eq!(**x.borrow(), 5);\n     }\n }\n@@ -167,16 +181,26 @@ pub struct RcMut<T> {\n     priv ptr: *mut RcMutBox<T>,\n }\n \n-pub impl<T: Owned> RcMut<T> {\n-    fn new(value: T) -> RcMut<T> {\n-        unsafe {\n-            let ptr = malloc(sys::size_of::<RcMutBox<T>>() as size_t) as *mut RcMutBox<T>;\n-            assert!(!ptr::is_null(ptr));\n-            intrinsics::move_val_init(&mut *ptr, RcMutBox{value: value, count: 1, borrow: Nothing});\n-            RcMut{ptr: ptr}\n-        }\n+priv impl<T> RcMut<T> {\n+    unsafe fn new(value: T) -> RcMut<T> {\n+        let ptr = malloc(sys::size_of::<RcMutBox<T>>() as size_t) as *mut RcMutBox<T>;\n+        assert!(!ptr::is_null(ptr));\n+        intrinsics::move_val_init(&mut *ptr, RcMutBox{value: value, count: 1, borrow: Nothing});\n+        RcMut{ptr: ptr}\n     }\n+}\n+\n+// FIXME: #6516: should be a static method\n+pub fn rc_mut_from_owned<T: Owned>(value: T) -> RcMut<T> {\n+    unsafe { RcMut::new(value) }\n+}\n+\n+// FIXME: #6516: should be a static method\n+pub fn rc_mut_from_const<T: Const>(value: T) -> RcMut<T> {\n+    unsafe { RcMut::new(value) }\n+}\n \n+pub impl<T> RcMut<T> {\n     /// Fails if there is already a mutable borrow of the box\n     #[inline]\n     fn with_borrow<U>(&self, f: &fn(&T) -> U) -> U {\n@@ -205,7 +229,7 @@ pub impl<T: Owned> RcMut<T> {\n \n #[unsafe_destructor]\n #[cfg(not(stage0))]\n-impl<T: Owned> Drop for RcMut<T> {\n+impl<T> Drop for RcMut<T> {\n     fn finalize(&self) {\n         unsafe {\n             (*self.ptr).count -= 1;\n@@ -219,7 +243,7 @@ impl<T: Owned> Drop for RcMut<T> {\n \n #[unsafe_destructor]\n #[cfg(stage0)]\n-impl<T: Owned> Drop for RcMut<T> {\n+impl<T> Drop for RcMut<T> {\n     fn finalize(&self) {\n         unsafe {\n             (*self.ptr).count -= 1;\n@@ -231,7 +255,7 @@ impl<T: Owned> Drop for RcMut<T> {\n     }\n }\n \n-impl<T: Owned> Clone for RcMut<T> {\n+impl<T> Clone for RcMut<T> {\n     /// Return a shallow copy of the reference counted pointer.\n     #[inline]\n     fn clone(&self) -> RcMut<T> {\n@@ -242,13 +266,13 @@ impl<T: Owned> Clone for RcMut<T> {\n     }\n }\n \n-impl<T: Owned + DeepClone> DeepClone for RcMut<T> {\n+impl<T: DeepClone> DeepClone for RcMut<T> {\n     /// Return a deep copy of the reference counted pointer.\n     #[inline]\n     fn deep_clone(&self) -> RcMut<T> {\n         do self.with_borrow |x| {\n             // FIXME: #6497: should avoid freeze (slow)\n-            RcMut::new(x.deep_clone())\n+            unsafe { RcMut::new(x.deep_clone()) }\n         }\n     }\n }\n@@ -259,7 +283,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn test_clone() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_owned(5);\n         let y = x.clone();\n         do x.with_mut_borrow |value| {\n             *value = 20;\n@@ -271,7 +295,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_const(5);\n         let y = x.deep_clone();\n         do x.with_mut_borrow |value| {\n             *value = 20;\n@@ -283,7 +307,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn borrow_many() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_owned(5);\n         let y = x.clone();\n \n         do x.with_borrow |a| {\n@@ -299,7 +323,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn modify() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_const(5);\n         let y = x.clone();\n \n         do y.with_mut_borrow |a| {\n@@ -314,22 +338,22 @@ mod test_rc_mut {\n \n     #[test]\n     fn release_immutable() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_owned(5);\n         do x.with_borrow |_| {}\n         do x.with_mut_borrow |_| {}\n     }\n \n     #[test]\n     fn release_mutable() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_const(5);\n         do x.with_mut_borrow |_| {}\n         do x.with_borrow |_| {}\n     }\n \n     #[test]\n     #[should_fail]\n     fn frozen() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_owned(5);\n         let y = x.clone();\n \n         do x.with_borrow |_| {\n@@ -341,7 +365,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn mutable_dupe() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_const(5);\n         let y = x.clone();\n \n         do x.with_mut_borrow |_| {\n@@ -353,7 +377,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn mutable_freeze() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_owned(5);\n         let y = x.clone();\n \n         do x.with_mut_borrow |_| {\n@@ -365,7 +389,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn restore_freeze() {\n-        let x = RcMut::new(5);\n+        let x = rc_mut_from_const(5);\n         let y = x.clone();\n \n         do x.with_borrow |_| {"}]}