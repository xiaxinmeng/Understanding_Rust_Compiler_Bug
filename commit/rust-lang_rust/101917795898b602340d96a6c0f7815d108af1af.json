{"sha": "101917795898b602340d96a6c0f7815d108af1af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMTkxNzc5NTg5OGI2MDIzNDBkOTZhNmMwZjc4MTVkMTA4YWYxYWY=", "commit": {"author": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2013-09-19T14:11:23Z"}, "committer": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2013-09-19T14:58:11Z"}, "message": "lexer: show correct span on lexical errors\n\nPreviously, the lexer calling `rdr.fatal(...)` would report the span of\nthe last complete token, instead of a span within the erroneous token\n(besides one span fixed in 1ac90bb).\n\nThis commit adds a wrapper around `rdr.fatal(...)` that sets the span\nexplicilty, so that all fatal errors in `libsyntax/parse/lexer.rs` now\nreport the offending code more precisely. A number of tests try to\nverify that, though the `compile-fail` testing setup can only check that\nthe spans are on the right lines, and the \"unterminated string/block\ncomment\" errors can't have the line marked at all, so that's incomplete.\n\nCloses #9149.", "tree": {"sha": "efac5b3a02dfeea43cc24cdc3db2f10dc0502899", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efac5b3a02dfeea43cc24cdc3db2f10dc0502899"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/101917795898b602340d96a6c0f7815d108af1af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/101917795898b602340d96a6c0f7815d108af1af", "html_url": "https://github.com/rust-lang/rust/commit/101917795898b602340d96a6c0f7815d108af1af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/101917795898b602340d96a6c0f7815d108af1af/comments", "author": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2b0b11aebfe3167bf41f7c6c31cf7b1e396efe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b0b11aebfe3167bf41f7c6c31cf7b1e396efe7", "html_url": "https://github.com/rust-lang/rust/commit/d2b0b11aebfe3167bf41f7c6c31cf7b1e396efe7"}], "stats": {"total": 234, "additions": 215, "deletions": 19}, "files": [{"sha": "3d686167ce1dc2a880bb639e69e5b380cdc96555", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -149,6 +149,16 @@ impl reader for TtReader {\n     fn dup(@mut self) -> @mut reader { dup_tt_reader(self) as @mut reader }\n }\n \n+// report a lexical error spanning [`from_pos`, `to_pos`)\n+fn fatal_span(rdr: @mut StringReader,\n+              from_pos: BytePos,\n+              to_pos: BytePos,\n+              m: ~str)\n+           -> ! {\n+    rdr.peek_span = codemap::mk_sp(from_pos, to_pos);\n+    rdr.fatal(m);\n+}\n+\n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n // EFFECT: update the interner, maybe.\n fn string_advance_token(r: @mut StringReader) {\n@@ -327,7 +337,8 @@ fn consume_block_comment(rdr: @mut StringReader)\n             bump(rdr);\n         }\n         if is_eof(rdr) {\n-            rdr.fatal(~\"unterminated block doc-comment\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"unterminated block doc-comment\");\n         } else {\n             bump(rdr);\n             bump(rdr);\n@@ -344,8 +355,12 @@ fn consume_block_comment(rdr: @mut StringReader)\n             }\n         }\n     } else {\n+        let start_bpos = rdr.last_pos - BytePos(2u);\n         loop {\n-            if is_eof(rdr) { rdr.fatal(~\"unterminated block comment\"); }\n+            if is_eof(rdr) {\n+                fatal_span(rdr, start_bpos, rdr.last_pos,\n+                           ~\"unterminated block comment\");\n+            }\n             if rdr.curr == '*' && nextch(rdr) == '/' {\n                 bump(rdr);\n                 bump(rdr);\n@@ -362,6 +377,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n }\n \n fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n+    let start_bpos = rdr.last_pos;\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n@@ -375,7 +391,10 @@ fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n         let exponent = scan_digits(rdr, 10u);\n         if exponent.len() > 0u {\n             return Some(rslt + exponent);\n-        } else { rdr.fatal(~\"scan_exponent: bad fp literal\"); }\n+        } else {\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"scan_exponent: bad fp literal\");\n+        }\n     } else { return None::<~str>; }\n }\n \n@@ -399,6 +418,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     let mut base = 10u;\n     let mut c = c;\n     let mut n = nextch(rdr);\n+    let start_bpos = rdr.last_pos;\n     if c == '0' && n == 'x' {\n         bump(rdr);\n         bump(rdr);\n@@ -442,11 +462,13 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n                       else { either::Right(ast::ty_u64) };\n         }\n         if num_str.len() == 0u {\n-            rdr.fatal(~\"no valid digits found for number\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => rdr.fatal(~\"int literal is too large\")\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                               ~\"int literal is too large\")\n         };\n \n         match tp {\n@@ -464,8 +486,10 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         match base {\n-          16u => rdr.fatal(~\"hexadecimal float literal is not supported\"),\n-          2u => rdr.fatal(~\"binary float literal is not supported\"),\n+          16u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                            ~\"hexadecimal float literal is not supported\"),\n+          2u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                           ~\"binary float literal is not supported\"),\n           _ => ()\n         }\n     }\n@@ -507,11 +531,13 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n         if num_str.len() == 0u {\n-            rdr.fatal(~\"no valid digits found for number\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => rdr.fatal(~\"int literal is too large\")\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                               ~\"int literal is too large\")\n         };\n \n         debug!(\"lexing %s as an unsuffixed integer literal\",\n@@ -523,19 +549,23 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0;\n     let mut i = n_hex_digits;\n+    let start_bpos = rdr.last_pos;\n     while i != 0u {\n         let n = rdr.curr;\n-        bump(rdr);\n         if !is_hex_digit(n) {\n-            rdr.fatal(fmt!(\"illegal numeric character escape: %d\", n as int));\n+            fatal_span(rdr, rdr.last_pos, rdr.pos,\n+                       fmt!(\"illegal numeric character escape: %d\",\n+                            n as int));\n         }\n+        bump(rdr);\n         accum_int *= 16;\n         accum_int += hex_digit_val(n);\n         i -= 1u;\n     }\n     match char::from_u32(accum_int as u32) {\n         Some(x) => x,\n-        None => rdr.fatal(fmt!(\"illegal numeric character escape\"))\n+        None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                           fmt!(\"illegal numeric character escape\"))\n     }\n }\n \n@@ -691,6 +721,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         if c2 == '\\\\' {\n             // '\\X' for some X must be a character constant:\n             let escaped = rdr.curr;\n+            let escaped_pos = rdr.last_pos;\n             bump(rdr);\n             match escaped {\n               'n' => { c2 = '\\n'; }\n@@ -704,12 +735,18 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n               'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 => {\n-                rdr.fatal(fmt!(\"unknown character escape: %d\", c2 as int));\n+                fatal_span(rdr, escaped_pos, rdr.last_pos,\n+                          fmt!(\"unknown character escape: %d\", c2 as int));\n               }\n             }\n         }\n         if rdr.curr != '\\'' {\n-            rdr.fatal(~\"unterminated character constant\");\n+            fatal_span(rdr,\n+                       // Byte offsetting here is okay because the character\n+                       // before position `start` is an ascii single quote.\n+                       start - BytePos(1u),\n+                       rdr.last_pos,\n+                       ~\"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n         return token::LIT_CHAR(c2 as u32);\n@@ -721,7 +758,9 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         while rdr.curr != '\"' {\n             if is_eof(rdr) {\n                 do with_str_from(rdr, n) |s| {\n-                    rdr.fatal(fmt!(\"unterminated double quote string: %s\", s));\n+                    fatal_span(rdr, n, rdr.last_pos,\n+                               fmt!(\"unterminated double quote string: %s\",\n+                                    s));\n                 }\n             }\n \n@@ -730,6 +769,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             match ch {\n               '\\\\' => {\n                 let escaped = rdr.curr;\n+                let escaped_pos = rdr.last_pos;\n                 bump(rdr);\n                 match escaped {\n                   'n' => accum_str.push_char('\\n'),\n@@ -750,7 +790,8 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                     accum_str.push_char(scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n-                    rdr.fatal(fmt!(\"unknown string escape: %d\", c2 as int));\n+                    fatal_span(rdr, escaped_pos, rdr.last_pos,\n+                               fmt!(\"unknown string escape: %d\", c2 as int));\n                   }\n                 }\n               }\n@@ -786,11 +827,10 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '^' => { return binop(rdr, token::CARET); }\n       '%' => { return binop(rdr, token::PERCENT); }\n       c => {\n-          // So the error span points to the unrecognized character\n-          rdr.peek_span = codemap::mk_sp(rdr.last_pos, rdr.pos);\n           let mut cs = ~\"\";\n           char::escape_default(c, |c| cs.push_char(c));\n-          rdr.fatal(fmt!(\"unknown start of token: %s\", cs));\n+          fatal_span(rdr, rdr.last_pos, rdr.pos,\n+                     fmt!(\"unknown start of token: %s\", cs));\n       }\n     }\n }"}, {"sha": "5a5e9d7d8f23876a792d72ed5ca623b8ea52014d", "filename": "src/test/compile-fail/lex-bad-fp-lit.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-bad-fp-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-bad-fp-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-bad-fp-lit.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static f: float =\n+    1e+ //~ ERROR: scan_exponent: bad fp literal\n+;"}, {"sha": "457c6126c44a5959f0433e955fe573ed7efaaecf", "filename": "src/test/compile-fail/lex-hex-float-lit.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-hex-float-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-hex-float-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-hex-float-lit.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static f: float =\n+    0x539.0 //~ ERROR: hexadecimal float literal is not supported\n+;"}, {"sha": "fe46cec776dfa77a86a0bf8fc06d0bec2a2014b5", "filename": "src/test/compile-fail/lex-illegal-num-char-escape-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\\Uffffffff' //~ ERROR: illegal numeric character escape\n+;"}, {"sha": "2760371b8e2aa69dfbd16f191fd99bec0d74c53d", "filename": "src/test/compile-fail/lex-illegal-num-char-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\\u539_' //~ ERROR: illegal numeric character escape\n+;"}, {"sha": "39d1cba64b08bce68eff5c8dfb0f41fbb03ae688", "filename": "src/test/compile-fail/lex-int-lit-too-large-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large-2.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    99999999999999999999999999999999u32 //~ ERROR: int literal is too large\n+;"}, {"sha": "6343be651fa5961d3ece0c02ad1067a008786a3a", "filename": "src/test/compile-fail/lex-int-lit-too-large.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    99999999999999999999999999999999 //~ ERROR: int literal is too large\n+;"}, {"sha": "549dbf5bc8c6c0f1ff8bdd830010c642272f124d", "filename": "src/test/compile-fail/lex-no-valid-digits-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits-2.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    0xu32 //~ ERROR: no valid digits\n+;"}, {"sha": "6a5b8e93f010a5f6b1ab21a7b3b2f40360c8c613", "filename": "src/test/compile-fail/lex-no-valid-digits.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    0x //~ ERROR: no valid digits\n+;"}, {"sha": "f2445c2b60ebaf7c100605e7e833fcb75bedfb25", "filename": "src/test/compile-fail/lex-unknown-char-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unknown-char-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unknown-char-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unknown-char-escape.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\\\u25cf' //~ ERROR: unknown character escape\n+;"}, {"sha": "1bb682303451bd30c36864458cabb741ed275b55", "filename": "src/test/compile-fail/lex-unknown-start-tok.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unknown-start-tok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unknown-start-tok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unknown-start-tok.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    \u25cf //~ ERROR: unknown start of token\n+}"}, {"sha": "f7809b02b0be34a3405f3ba51784ce77ae2cd668", "filename": "src/test/compile-fail/lex-unknown-str-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static s: &'static str =\n+    \"\\\u25cf\" //~ ERROR: unknown string escape\n+;"}, {"sha": "551360ff9e095b425b94f748100f3f6092b65f23", "filename": "src/test/compile-fail/lex-unterminated-char-const.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unterminated-char-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101917795898b602340d96a6c0f7815d108af1af/src%2Ftest%2Fcompile-fail%2Flex-unterminated-char-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unterminated-char-const.rs?ref=101917795898b602340d96a6c0f7815d108af1af", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\u25cf  //~ ERROR: unterminated character constant\n+;"}]}