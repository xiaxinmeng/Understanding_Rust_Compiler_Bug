{"sha": "24efc3a934abcc9f497929a0c799d105cae934aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZWZjM2E5MzRhYmNjOWY0OTc5MjlhMGM3OTlkMTA1Y2FlOTM0YWE=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-25T13:35:22Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-25T13:35:22Z"}, "message": "Ignore empty lines inside arguments of macro with brace", "tree": {"sha": "649674351e08a9c0bdaa184917f94a737e33caf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/649674351e08a9c0bdaa184917f94a737e33caf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24efc3a934abcc9f497929a0c799d105cae934aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24efc3a934abcc9f497929a0c799d105cae934aa", "html_url": "https://github.com/rust-lang/rust/commit/24efc3a934abcc9f497929a0c799d105cae934aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24efc3a934abcc9f497929a0c799d105cae934aa/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6554e7c20653b6e77fbbdc54ec27c40959dd0446", "url": "https://api.github.com/repos/rust-lang/rust/commits/6554e7c20653b6e77fbbdc54ec27c40959dd0446", "html_url": "https://github.com/rust-lang/rust/commit/6554e7c20653b6e77fbbdc54ec27c40959dd0446"}], "stats": {"total": 76, "additions": 63, "deletions": 13}, "files": [{"sha": "a841268ce07351365ae445cd6077145975437591", "filename": "src/macros.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/24efc3a934abcc9f497929a0c799d105cae934aa/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24efc3a934abcc9f497929a0c799d105cae934aa/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=24efc3a934abcc9f497929a0c799d105cae934aa", "patch": "@@ -309,31 +309,51 @@ fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> MacroStyle {\n /// }\n /// ```\n fn indent_macro_snippet(macro_str: &str, indent: Indent) -> Option<String> {\n-    let min_prefix_space_width =\n-        try_opt!(macro_str.lines().skip(1).map(get_prefix_space_width).min());\n-\n     let mut lines = macro_str.lines();\n-    let first_line = try_opt!(lines.next());\n+    let first_line = try_opt!(lines.next().map(|s| s.trim_right()));\n+    let mut trimmed_lines = Vec::with_capacity(16);\n+\n+    let min_prefix_space_width = try_opt!(\n+        lines\n+            .filter_map(|line| {\n+                let prefix_space_width = if is_empty_line(line) {\n+                    None\n+                } else {\n+                    get_prefix_space_width(line)\n+                };\n+                trimmed_lines.push((line.trim(), prefix_space_width));\n+                prefix_space_width\n+            })\n+            .min()\n+    );\n \n     Some(\n         String::from(first_line) + \"\\n\" +\n-            &lines\n-                .map(|line| {\n-                    let new_indent_width = indent.width() +\n-                        get_prefix_space_width(line)\n-                            .checked_sub(min_prefix_space_width)\n-                            .unwrap_or(0);\n-                    repeat_white_space(new_indent_width) + line.trim()\n+            &trimmed_lines\n+                .iter()\n+                .map(|&(line, prefix_space_width)| match prefix_space_width {\n+                    Some(original_indent_width) => {\n+                        let new_indent_width = indent.width() +\n+                            original_indent_width\n+                                .checked_sub(min_prefix_space_width)\n+                                .unwrap_or(0);\n+                        repeat_white_space(new_indent_width) + line.trim()\n+                    }\n+                    None => String::new(),\n                 })\n                 .collect::<Vec<_>>()\n                 .join(\"\\n\"),\n     )\n }\n \n-fn get_prefix_space_width(s: &str) -> usize {\n-    s.chars().position(|c| c != ' ').unwrap_or(0)\n+fn get_prefix_space_width(s: &str) -> Option<usize> {\n+    s.chars().position(|c| c != ' ')\n }\n \n fn repeat_white_space(ws_count: usize) -> String {\n     repeat(\" \").take(ws_count).collect::<String>()\n }\n+\n+fn is_empty_line(s: &str) -> bool {\n+    s.is_empty() || s.chars().all(char::is_whitespace)\n+}"}, {"sha": "aa2861ecd173fe3ab7e0e006c8d035781ea75fb2", "filename": "tests/source/macros.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24efc3a934abcc9f497929a0c799d105cae934aa/tests%2Fsource%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24efc3a934abcc9f497929a0c799d105cae934aa/tests%2Fsource%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacros.rs?ref=24efc3a934abcc9f497929a0c799d105cae934aa", "patch": "@@ -134,6 +134,21 @@ fn issue_1885() {\n     }).collect::<Vec<_>>();\n }\n \n+fn issue_1917() {\n+    mod x {\n+        quickcheck! {\n+            fn test(a: String, s: String, b: String) -> TestResult {\n+                if a.find(&s).is_none() {\n+\n+                    TestResult::from_bool(true)\n+                } else {\n+                    TestResult::discard()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Put the following tests with macro invocations whose arguments cannot be parsed as expressioins\n // at the end of the file for now.\n "}, {"sha": "cbe15f9f7f7b4a576d7b7f63fcff73bb5fe96bf6", "filename": "tests/target/macros.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24efc3a934abcc9f497929a0c799d105cae934aa/tests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24efc3a934abcc9f497929a0c799d105cae934aa/tests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacros.rs?ref=24efc3a934abcc9f497929a0c799d105cae934aa", "patch": "@@ -178,6 +178,21 @@ fn issue_1885() {\n         .collect::<Vec<_>>();\n }\n \n+fn issue_1917() {\n+    mod x {\n+        quickcheck! {\n+            fn test(a: String, s: String, b: String) -> TestResult {\n+                if a.find(&s).is_none() {\n+\n+                    TestResult::from_bool(true)\n+                } else {\n+                    TestResult::discard()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Put the following tests with macro invocations whose arguments cannot be parsed as expressioins\n // at the end of the file for now.\n "}]}