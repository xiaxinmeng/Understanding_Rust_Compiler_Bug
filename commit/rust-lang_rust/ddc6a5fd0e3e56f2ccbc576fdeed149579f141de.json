{"sha": "ddc6a5fd0e3e56f2ccbc576fdeed149579f141de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYzZhNWZkMGUzZTU2ZjJjY2JjNTc2ZmRlZWQxNDk1NzlmMTQxZGU=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T16:10:17Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T16:10:17Z"}, "message": "Split options parsing into several functions", "tree": {"sha": "e12a83fca9664444d8952e13dcb64b6a84712e9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e12a83fca9664444d8952e13dcb64b6a84712e9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de", "html_url": "https://github.com/rust-lang/rust/commit/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12397e9dd5a97460d76c884d449ca1c2d26da8ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/12397e9dd5a97460d76c884d449ca1c2d26da8ed", "html_url": "https://github.com/rust-lang/rust/commit/12397e9dd5a97460d76c884d449ca1c2d26da8ed"}], "stats": {"total": 302, "additions": 179, "deletions": 123}, "files": [{"sha": "0c47bc8ae94a741f9676bb7f800942ac3e719d78", "filename": "src/libtest/cli.rs", "status": "modified", "additions": 179, "deletions": 123, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de/src%2Flibtest%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de/src%2Flibtest%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fcli.rs?ref=ddc6a5fd0e3e56f2ccbc576fdeed149579f141de", "patch": "@@ -40,7 +40,7 @@ impl TestOpts {\n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, String>;\n /// Result of parsing the option part.\n-type OptPartRes<T> = Result<Option<T>, String>;\n+type OptPartRes<T> = Result<T, String>;\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n@@ -186,36 +186,111 @@ Test Attributes:\n     );\n }\n \n-// FIXME: Copied from libsyntax until linkage errors are resolved. Issue #47566\n-fn is_nightly() -> bool {\n-    // Whether this is a feature-staged build, i.e., on the beta or stable channel\n-    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n-    // Whether we should enable unstable features for bootstrapping\n-    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+/// Parses command line arguments into test options.\n+/// Returns `None` if help was requested (since we only show help message and don't run tests),\n+/// returns `Some(Err(..))` if provided arguments are incorrect,\n+/// otherwise creates a `TestOpts` object and returns it.\n+pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n+    // Parse matches.\n+    let opts = optgroups();\n+    let args = args.get(1..).unwrap_or(args);\n+    let matches = match opts.parse(args) {\n+        Ok(m) => m,\n+        Err(f) => return Some(Err(f.to_string())),\n+    };\n \n-    bootstrap || !disable_unstable_features\n+    // Check if help was requested.\n+    if matches.opt_present(\"h\") {\n+        // Show help and do nothing more.\n+        usage(&args[0], &opts);\n+        return None;\n+    }\n+\n+    // Actually parse the opts.\n+    let opts_result = parse_opts_impl(matches);\n+\n+    Some(opts_result)\n }\n \n // Gets the option value and checks if unstable features are enabled.\n macro_rules! unstable_optflag {\n     ($matches:ident, $allow_unstable:ident, $option_name:literal) => {{\n         let opt = $matches.opt_present($option_name);\n         if !$allow_unstable && opt {\n-            return Some(Err(format!(\n+            return Err(format!(\n                 \"The \\\"{}\\\" flag is only accepted on the nightly compiler\",\n                 $option_name\n-            )));\n+            ));\n         }\n \n         opt\n     }};\n }\n \n+// Implementation of `parse_opts` that doesn't care about help message\n+// and returns a `Result`.\n+fn parse_opts_impl(matches: getopts::Matches) -> OptRes {\n+    let allow_unstable = get_allow_unstable(&matches)?;\n+\n+    // Unstable flags\n+    let exclude_should_panic = unstable_optflag!(matches, allow_unstable, \"exclude-should-panic\");\n+    let include_ignored = unstable_optflag!(matches, allow_unstable, \"include-ignored\");\n+    let time_options = get_time_options(&matches, allow_unstable)?;\n+\n+    let quiet = matches.opt_present(\"quiet\");\n+    let exact = matches.opt_present(\"exact\");\n+    let list = matches.opt_present(\"list\");\n+    let skip = matches.opt_strs(\"skip\");\n+\n+    let bench_benchmarks = matches.opt_present(\"bench\");\n+    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n+\n+    let logfile = get_log_file(&matches)?;\n+    let run_ignored = get_run_ignored(&matches, include_ignored)?;\n+    let filter = get_filter(&matches)?;\n+    let nocapture = get_nocapture(&matches)?;\n+    let test_threads = get_test_threads(&matches)?;\n+    let color = get_color_config(&matches)?;\n+    let format = get_format(&matches, quiet, allow_unstable)?;\n+\n+    let options = Options::new().display_output(matches.opt_present(\"show-output\"));\n+\n+    let test_opts = TestOpts {\n+        list,\n+        filter,\n+        filter_exact: exact,\n+        exclude_should_panic,\n+        run_ignored,\n+        run_tests,\n+        bench_benchmarks,\n+        logfile,\n+        nocapture,\n+        color,\n+        format,\n+        test_threads,\n+        skip,\n+        time_options,\n+        options,\n+    };\n+\n+    Ok(test_opts)\n+}\n+\n+// FIXME: Copied from libsyntax until linkage errors are resolved. Issue #47566\n+fn is_nightly() -> bool {\n+    // Whether this is a feature-staged build, i.e., on the beta or stable channel\n+    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+    // Whether we should enable unstable features for bootstrapping\n+    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+\n+    bootstrap || !disable_unstable_features\n+}\n+\n // Gets the CLI options assotiated with `report-time` feature.\n fn get_time_options(\n     matches: &getopts::Matches,\n     allow_unstable: bool)\n--> Option<OptPartRes<TestTimeOptions>> {\n+-> OptPartRes<Option<TestTimeOptions>> {\n     let report_time = unstable_optflag!(matches, allow_unstable, \"report-time\");\n     let colored_opt_str = matches.opt_str(\"report-time\");\n     let mut report_time_colored = report_time && colored_opt_str == Some(\"colored\".into());\n@@ -232,71 +307,73 @@ fn get_time_options(\n         None\n     };\n \n-    Some(Ok(options))\n+    Ok(options)\n }\n \n-// Parses command line arguments into test options\n-pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n-    let mut allow_unstable = false;\n-    let opts = optgroups();\n-    let args = args.get(1..).unwrap_or(args);\n-    let matches = match opts.parse(args) {\n-        Ok(m) => m,\n-        Err(f) => return Some(Err(f.to_string())),\n+fn get_test_threads(matches: &getopts::Matches) -> OptPartRes<Option<usize>> {\n+    let test_threads = match matches.opt_str(\"test-threads\") {\n+        Some(n_str) => match n_str.parse::<usize>() {\n+            Ok(0) => return Err(\"argument for --test-threads must not be 0\".to_string()),\n+            Ok(n) => Some(n),\n+            Err(e) => {\n+                return Err(format!(\n+                    \"argument for --test-threads must be a number > 0 \\\n+                     (error: {})\",\n+                    e\n+                ));\n+            }\n+        },\n+        None => None,\n     };\n \n-    if let Some(opt) = matches.opt_str(\"Z\") {\n-        if !is_nightly() {\n-            return Some(Err(\n-                \"the option `Z` is only accepted on the nightly compiler\".into(),\n-            ));\n-        }\n+    Ok(test_threads)\n+}\n \n-        match &*opt {\n-            \"unstable-options\" => {\n-                allow_unstable = true;\n-            }\n-            _ => {\n-                return Some(Err(\"Unrecognized option to `Z`\".into()));\n+fn get_format(matches: &getopts::Matches, quiet: bool, allow_unstable: bool) -> OptPartRes<OutputFormat> {\n+    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n+        None if quiet => OutputFormat::Terse,\n+        Some(\"pretty\") | None => OutputFormat::Pretty,\n+        Some(\"terse\") => OutputFormat::Terse,\n+        Some(\"json\") => {\n+            if !allow_unstable {\n+                return Err(\n+                    \"The \\\"json\\\" format is only accepted on the nightly compiler\".into(),\n+                );\n             }\n+            OutputFormat::Json\n         }\n-    };\n \n-    if matches.opt_present(\"h\") {\n-        usage(&args[0], &opts);\n-        return None;\n-    }\n-\n-    let filter = if !matches.free.is_empty() {\n-        Some(matches.free[0].clone())\n-    } else {\n-        None\n+        Some(v) => {\n+            return Err(format!(\n+                \"argument for --format must be pretty, terse, or json (was \\\n+                 {})\",\n+                v\n+            ));\n+        }\n     };\n \n-    let exclude_should_panic = unstable_optflag!(matches, allow_unstable, \"exclude-should-panic\");\n+    Ok(format)\n+}\n \n-    let include_ignored = unstable_optflag!(matches, allow_unstable, \"include-ignored\");\n+fn get_color_config(matches: &getopts::Matches) -> OptPartRes<ColorConfig> {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n+        Some(\"auto\") | None => ColorConfig::AutoColor,\n+        Some(\"always\") => ColorConfig::AlwaysColor,\n+        Some(\"never\") => ColorConfig::NeverColor,\n \n-    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n-        (true, true) => {\n-            return Some(Err(\n-                \"the options --include-ignored and --ignored are mutually exclusive\".into(),\n+        Some(v) => {\n+            return Err(format!(\n+                \"argument for --color must be auto, always, or never (was \\\n+                 {})\",\n+                v\n             ));\n         }\n-        (true, false) => RunIgnored::Yes,\n-        (false, true) => RunIgnored::Only,\n-        (false, false) => RunIgnored::No,\n     };\n-    let quiet = matches.opt_present(\"quiet\");\n-    let exact = matches.opt_present(\"exact\");\n-    let list = matches.opt_present(\"list\");\n \n-    let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| PathBuf::from(&s));\n-\n-    let bench_benchmarks = matches.opt_present(\"bench\");\n-    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n+    Ok(color)\n+}\n \n+fn get_nocapture(matches: &getopts::Matches) -> OptPartRes<bool> {\n     let mut nocapture = matches.opt_present(\"nocapture\");\n     if !nocapture {\n         nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n@@ -305,80 +382,59 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         };\n     }\n \n-    let time_options = match get_time_options(&matches, allow_unstable) {\n-        Some(Ok(val)) => val,\n-        Some(Err(e)) => return Some(Err(e)),\n-        None => panic!(\"Unexpected output from `get_time_options`\"),\n-    };\n+    Ok(nocapture)\n+}\n \n-    let test_threads = match matches.opt_str(\"test-threads\") {\n-        Some(n_str) => match n_str.parse::<usize>() {\n-            Ok(0) => return Some(Err(\"argument for --test-threads must not be 0\".to_string())),\n-            Ok(n) => Some(n),\n-            Err(e) => {\n-                return Some(Err(format!(\n-                    \"argument for --test-threads must be a number > 0 \\\n-                     (error: {})\",\n-                    e\n-                )));\n-            }\n-        },\n-        None => None,\n+fn get_run_ignored(matches: &getopts::Matches, include_ignored: bool) -> OptPartRes<RunIgnored> {\n+    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n+        (true, true) => {\n+            return Err(\n+                \"the options --include-ignored and --ignored are mutually exclusive\".into(),\n+            );\n+        }\n+        (true, false) => RunIgnored::Yes,\n+        (false, true) => RunIgnored::Only,\n+        (false, false) => RunIgnored::No,\n     };\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n-        Some(\"auto\") | None => ColorConfig::AutoColor,\n-        Some(\"always\") => ColorConfig::AlwaysColor,\n-        Some(\"never\") => ColorConfig::NeverColor,\n+    Ok(run_ignored)\n+}\n \n-        Some(v) => {\n-            return Some(Err(format!(\n-                \"argument for --color must be auto, always, or never (was \\\n-                 {})\",\n-                v\n-            )));\n-        }\n+fn get_filter(matches: &getopts::Matches) -> OptPartRes<Option<String>> {\n+    let filter = if !matches.free.is_empty() {\n+        Some(matches.free[0].clone())\n+    } else {\n+        None\n     };\n \n-    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n-        None if quiet => OutputFormat::Terse,\n-        Some(\"pretty\") | None => OutputFormat::Pretty,\n-        Some(\"terse\") => OutputFormat::Terse,\n-        Some(\"json\") => {\n-            if !allow_unstable {\n-                return Some(Err(\n-                    \"The \\\"json\\\" format is only accepted on the nightly compiler\".into(),\n-                ));\n-            }\n-            OutputFormat::Json\n+    Ok(filter)\n+}\n+\n+fn get_allow_unstable(matches: &getopts::Matches) -> OptPartRes<bool> {\n+    let mut allow_unstable = false;\n+\n+    if let Some(opt) = matches.opt_str(\"Z\") {\n+        if !is_nightly() {\n+            return Err(\n+                \"the option `Z` is only accepted on the nightly compiler\".into(),\n+            );\n         }\n \n-        Some(v) => {\n-            return Some(Err(format!(\n-                \"argument for --format must be pretty, terse, or json (was \\\n-                 {})\",\n-                v\n-            )));\n+        match &*opt {\n+            \"unstable-options\" => {\n+                allow_unstable = true;\n+            }\n+            _ => {\n+                return Err(\"Unrecognized option to `Z`\".into());\n+            }\n         }\n     };\n \n-    let test_opts = TestOpts {\n-        list,\n-        filter,\n-        filter_exact: exact,\n-        exclude_should_panic,\n-        run_ignored,\n-        run_tests,\n-        bench_benchmarks,\n-        logfile,\n-        nocapture,\n-        color,\n-        format,\n-        test_threads,\n-        skip: matches.opt_strs(\"skip\"),\n-        time_options,\n-        options: Options::new().display_output(matches.opt_present(\"show-output\")),\n-    };\n+    Ok(allow_unstable)\n+}\n+\n+fn get_log_file(matches: &getopts::Matches) -> OptPartRes<Option<PathBuf>> {\n+    let logfile = matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s));\n \n-    Some(Ok(test_opts))\n+    Ok(logfile)\n }"}]}