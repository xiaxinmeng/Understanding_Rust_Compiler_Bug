{"sha": "a72790d879a6266b4dc75ab3014c00735cf67610", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3Mjc5MGQ4NzlhNjI2NmI0ZGM3NWFiMzAxNGMwMDczNWNmNjc2MTA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-02-26T14:45:13Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-05-03T12:03:16Z"}, "message": "When using NLL, implicitly borrow match bindings for any guard,\nderef'ing such borrows within that guard.\n\nReview feedback: Add comment noting a point where we may or may not\nneed to add a cast when we finish the work on rust-lang/rust#27282.\n\nReview feedback: Pass a newtype'd `ArmHasGuard` rather than a raw boolean.\n\nReview feedback: toggle \"ref binding in guards\" semantics via specific\nmethod. (This should ease a follow-up PR that just unconditionally\nadopts the new semantics.)", "tree": {"sha": "8223aa135c778fa828739d95b0b52806531aef3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8223aa135c778fa828739d95b0b52806531aef3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a72790d879a6266b4dc75ab3014c00735cf67610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a72790d879a6266b4dc75ab3014c00735cf67610", "html_url": "https://github.com/rust-lang/rust/commit/a72790d879a6266b4dc75ab3014c00735cf67610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a72790d879a6266b4dc75ab3014c00735cf67610/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b00db7c75b85d521a17372750512111657baaea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b00db7c75b85d521a17372750512111657baaea2", "html_url": "https://github.com/rust-lang/rust/commit/b00db7c75b85d521a17372750512111657baaea2"}], "stats": {"total": 411, "additions": 373, "deletions": 38}, "files": [{"sha": "3d154e43a9ae12972cd81f0111e328887102effe", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a72790d879a6266b4dc75ab3014c00735cf67610", "patch": "@@ -1467,6 +1467,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.borrowck_mode().use_mir()\n     }\n \n+    /// If true, pattern variables for use in guards on match arms\n+    /// will be bound as references to the data, and occurrences of\n+    /// those variables in the guard expression will implicitly\n+    /// dereference those bindings. (See rust-lang/rust#27282.)\n+    pub fn all_pat_vars_are_implicit_refs_within_guards(self) -> bool {\n+        self.borrowck_mode().use_mir()\n+    }\n+\n     /// If true, we should enable two-phase borrows checks. This is\n     /// done with either `-Ztwo-phase-borrows` or with\n     /// `#![feature(nll)]`."}, {"sha": "fae06db31629bbad32f58ce16e51d1e3afae41b3", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=a72790d879a6266b4dc75ab3014c00735cf67610", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::ForGuard::OutsideGuard;\n+use build::matches::ArmHasGuard;\n use hair::*;\n use rustc::mir::*;\n use rustc::hir;\n@@ -113,7 +115,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Declare the bindings, which may create a visibility scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n-                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern);\n+                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n+                                                      ArmHasGuard(false));\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n@@ -135,8 +138,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         }\n \n                         this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n-                            this.storage_live_binding(block, node, span);\n-                            this.schedule_drop_for_binding(node, span);\n+                            this.storage_live_binding(block, node, span, OutsideGuard);\n+                            this.schedule_drop_for_binding(node, span, OutsideGuard);\n                         })\n                     }\n "}, {"sha": "365b9babd0869cfb070ae9bb63e65fa0aaf7ca06", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=a72790d879a6266b4dc75ab3014c00735cf67610", "patch": "@@ -11,6 +11,7 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::ForGuard::{OutsideGuard, WithinGuard};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n@@ -86,8 +87,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Place::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n-                let index = this.var_indices[&id];\n-                block.and(Place::Local(index))\n+                let place = if this.is_bound_var_in_guard(id) {\n+                    let index = this.var_local_id(id, WithinGuard);\n+                    if this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards() {\n+                        Place::Local(index).deref()\n+                    } else {\n+                        Place::Local(index)\n+                    }\n+                } else {\n+                    let index = this.var_local_id(id, OutsideGuard);\n+                    Place::Local(index)\n+                };\n+                block.and(place)\n             }\n             ExprKind::StaticRef { id } => {\n                 block.and(Place::Static(Box::new(Static { def_id: id, ty: expr.ty })))"}, {"sha": "6946ac4c7b2771af2a6b7affc10f8870b3adc997", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 267, "deletions": 30, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a72790d879a6266b4dc75ab3014c00735cf67610", "patch": "@@ -14,6 +14,8 @@\n //! details.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n+use build::ForGuard::{self, OutsideGuard, WithinGuard};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::ty::{self, Ty};\n@@ -28,6 +30,11 @@ mod simplify;\n mod test;\n mod util;\n \n+/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// a match arm has a guard expression attached to it.\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct ArmHasGuard(pub bool);\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn match_expr(&mut self,\n                       destination: &Place<'tcx>,\n@@ -66,7 +73,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let body = self.hir.mirror(arm.body.clone());\n             let scope = self.declare_bindings(None, body.span,\n                                               LintLevel::Inherited,\n-                                              &arm.patterns[0]);\n+                                              &arm.patterns[0],\n+                                              ArmHasGuard(arm.guard.is_some()));\n             (body, scope.unwrap_or(self.visibility_scope))\n         }).collect();\n \n@@ -149,7 +157,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                           var: NodeId, span: Span) {\n         if self.hir.tcx().sess.opts.debugging_opts.disable_nll_user_type_assert { return; }\n \n-        let local_id = self.var_indices[&var];\n+        let local_id = self.var_local_id(var, OutsideGuard);\n         let source_info = self.source_info(span);\n \n         debug!(\"user_assert_ty: local_id={:?}\", hir_id.local_id);\n@@ -173,14 +181,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n                                    subpattern: None, .. } => {\n-                let place = self.storage_live_binding(block, var, irrefutable_pat.span);\n+                let place = self.storage_live_binding(block, var, irrefutable_pat.span,\n+                                                      OutsideGuard);\n \n                 if let Some(ty) = ty {\n                     self.user_assert_ty(block, ty, var, irrefutable_pat.span);\n                 }\n \n                 unpack!(block = self.into(&place, block, initializer));\n-                self.schedule_drop_for_binding(var, irrefutable_pat.span);\n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n             _ => {\n@@ -220,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate(block, candidate.bindings);\n+        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n \n         block.unit()\n     }\n@@ -232,7 +241,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             mut var_scope: Option<VisibilityScope>,\n                             scope_span: Span,\n                             lint_level: LintLevel,\n-                            pattern: &Pattern<'tcx>)\n+                            pattern: &Pattern<'tcx>,\n+                            has_guard: ArmHasGuard)\n                             -> Option<VisibilityScope> {\n         assert!(!(var_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a var and a lint scope at the same time\");\n@@ -254,15 +264,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 span,\n                 scope: var_scope.unwrap()\n             };\n-            this.declare_binding(source_info, syntactic_scope, mutability, name, var, ty);\n+            this.declare_binding(source_info, syntactic_scope, mutability, name, var,\n+                                 ty, has_guard);\n         });\n         var_scope\n     }\n \n-    pub fn storage_live_binding(&mut self, block: BasicBlock, var: NodeId, span: Span)\n+    pub fn storage_live_binding(&mut self,\n+                                block: BasicBlock,\n+                                var: NodeId,\n+                                span: Span,\n+                                for_guard: ForGuard)\n                             -> Place<'tcx>\n     {\n-        let local_id = self.var_indices[&var];\n+        let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement {\n             source_info,\n@@ -271,8 +286,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         Place::Local(local_id)\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n-        let local_id = self.var_indices[&var];\n+    pub fn schedule_drop_for_binding(&mut self,\n+                                     var: NodeId,\n+                                     span: Span,\n+                                     for_guard: ForGuard) {\n+        let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n@@ -770,21 +788,139 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                        vec![candidate.next_candidate_pre_binding_block],\n                                });\n \n-        self.bind_matched_candidate(block, candidate.bindings);\n \n+        // rust-lang/rust#27282: The `autoref` business deserves some\n+        // explanation here.\n+        //\n+        // The intent of the `autoref` flag is that when it is true,\n+        // then any pattern bindings of type T will map to a `&T`\n+        // within the context of the guard expression, but will\n+        // continue to map to a `T` in the context of the arm body. To\n+        // avoid surfacing this distinction in the user source code\n+        // (which would be a severe change to the language and require\n+        // far more revision to the compiler), when `autoref` is true,\n+        // then any occurrence of the identifier in the guard\n+        // expression will automatically get a deref op applied to it.\n+        //\n+        // So an input like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { foo if inspect(foo)\n+        //     => feed(foo), ...  }\n+        // ```\n+        //\n+        // will be treated as if it were really something like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { Foo { .. } if { let tmp1 = &place; inspect(*tmp1) }\n+        //     => { let tmp2 = place; feed(tmp2) }, ... }\n+        //\n+        // And an input like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { ref mut foo if inspect(foo)\n+        //     => feed(foo), ...  }\n+        // ```\n+        //\n+        // will be treated as if it were really something like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { Foo { .. } if { let tmp1 = & &mut place; inspect(*tmp1) }\n+        //     => { let tmp2 = &mut place; feed(tmp2) }, ... }\n+        // ```\n+        //\n+        // In short, any pattern binding will always look like *some*\n+        // kind of `&T` within the guard at least in terms of how the\n+        // MIR-borrowck views it, and this will ensure that guard\n+        // expressions cannot mutate their the match inputs via such\n+        // bindings. (It also ensures that guard expressions can at\n+        // most *copy* values from such bindings; non-Copy things\n+        // cannot be moved via pattern bindings in guard expressions.)\n+        //\n+        // ----\n+        //\n+        // Implementation notes (under assumption `autoref` is true).\n+        //\n+        // To encode the distinction above, we must inject the\n+        // temporaries `tmp1` and `tmp2`.\n+        //\n+        // There are two cases of interest: binding by-value, and binding by-ref.\n+        //\n+        // 1. Binding by-value: Things are simple.\n+        //\n+        //    * Establishing `tmp1` creates a reference into the\n+        //      matched place. This code is emitted by\n+        //      bind_matched_candidate_for_guard.\n+        //\n+        //    * `tmp2` is only initialized \"lazily\", after we have\n+        //      checked the guard. Thus, the code that can trigger\n+        //      moves out of the candidate can only fire after the\n+        //      guard evaluated to true. This initialization code is\n+        //      emitted by bind_matched_candidate_for_arm.\n+        //\n+        // 2. Binding by-reference: Things are tricky.\n+        //\n+        //    * Here, the guard expression wants a `&&` or `&&mut`\n+        //      into the original input. This means we need to borrow\n+        //      a reference that we do not immediately have at hand\n+        //      (because all we have is the places associated with the\n+        //      match input itself; it is up to us to create a place\n+        //      holding a `&` or `&mut` that we can then borrow).\n+        //\n+        //    * Therefore, when the binding is by-reference, we\n+        //      *eagerly* introduce the binding for the arm body\n+        //      (`tmp2`) and then borrow it (`tmp1`).\n+        //\n+        //    * This is documented with \"NOTE tricky business\" below.\n+        //\n+        // FIXME The distinction in how `tmp2` is initialized is\n+        // currently encoded in a pretty awkward fashion; namely, by\n+        // passing a boolean to bind_matched_candidate_for_arm_body\n+        // indicating whether all of the by-ref bindings were already\n+        // initialized.\n+        //\n+        // * Also: pnkfelix thinks \"laziness\" is natural; but since\n+        //   MIR-borrowck did not complain with earlier (universally\n+        //   eager) MIR codegen, laziness might not be *necessary*.\n+\n+        let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n+            if autoref {\n+                self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n+                let guard_frame = GuardFrame {\n+                    locals: candidate.bindings.iter()\n+                        .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n+                        .collect(),\n+                };\n+                debug!(\"Entering guard translation context: {:?}\", guard_frame);\n+                self.guard_context.push(guard_frame);\n+            } else {\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+            }\n+\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = self.hir.mirror(guard);\n             let source_info = self.source_info(guard.span);\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n+            if autoref {\n+                let guard_frame = self.guard_context.pop().unwrap();\n+                debug!(\"Exiting guard translation context with locals: {:?}\", guard_frame);\n+            }\n \n             let false_edge_block = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n                                TerminatorKind::if_(self.hir.tcx(), cond, arm_block,\n                                    false_edge_block));\n \n             let otherwise = self.cfg.start_new_block();\n+            if autoref {\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, true);\n+            }\n             self.cfg.terminate(false_edge_block, source_info,\n                                TerminatorKind::FalseEdges {\n                                    real_target: otherwise,\n@@ -793,47 +929,137 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                });\n             Some(otherwise)\n         } else {\n+            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n             self.cfg.terminate(block, candidate_source_info,\n                                TerminatorKind::Goto { target: arm_block });\n             None\n         }\n     }\n \n-    fn bind_matched_candidate(&mut self,\n-                              block: BasicBlock,\n-                              bindings: Vec<Binding<'tcx>>) {\n-        debug!(\"bind_matched_candidate(block={:?}, bindings={:?})\",\n+    fn bind_matched_candidate_for_guard(&mut self,\n+                                        block: BasicBlock,\n+                                        bindings: &[Binding<'tcx>]) {\n+        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\",\n                block, bindings);\n \n+        // Assign each of the bindings. Since we are binding for a\n+        // guard expression, this will never trigger moves out of the\n+        // candidate.\n+        let re_empty = self.hir.tcx().types.re_empty;\n+        for binding in bindings {\n+            let source_info = self.source_info(binding.span);\n+            let local_for_guard = self.storage_live_binding(\n+                block, binding.var_id, binding.span, WithinGuard);\n+            // Question: Why schedule drops if bindings are all\n+            // shared-&'s?  Answer: Because schedule_drop_for_binding\n+            // also emits StorageDead's for those locals.\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, WithinGuard);\n+            match binding.binding_mode {\n+                BindingMode::ByValue => {\n+                    let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n+                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                }\n+                BindingMode::ByRef(region, borrow_kind) => {\n+                    // NOTE tricky business: For `ref id` and `ref mut\n+                    // id` patterns, we want `id` within the guard to\n+                    // correspond to a temp of type `& &T` or `& &mut\n+                    // T`, while within the arm body it will\n+                    // correspond to a temp of type `&T` or `&mut T`,\n+                    // as usual.\n+                    //\n+                    // But to inject the level of indirection, we need\n+                    // something to point to.\n+                    //\n+                    // So:\n+                    //\n+                    // 1. First set up the local for the arm body\n+                    //   (even though we have not yet evaluated the\n+                    //   guard itself),\n+                    //\n+                    // 2. Then setup the local for the guard, which is\n+                    //    just a reference to the local from step 1.\n+                    //\n+                    // Note that since we are setting up the local for\n+                    // the arm body a bit eagerly here (and likewise\n+                    // scheduling its drop code), we should *not* do\n+                    // it redundantly later on.\n+                    //\n+                    // While we could have kept track of this with a\n+                    // flag or collection of such bindings, the\n+                    // treatment of all of these cases is uniform, so\n+                    // we should be safe just avoiding the code\n+                    // without maintaining such state.)\n+                    let local_for_arm_body = self.storage_live_binding(\n+                        block, binding.var_id, binding.span, OutsideGuard);\n+                    self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n+\n+                    // rust-lang/rust#27282: this potentially mutable\n+                    // borrow may require a cast in the future to\n+                    // avoid conflicting with an implicit borrow of\n+                    // the whole match input; or maybe it just\n+                    // requires an extension of our two-phase borrows\n+                    // system. See discussion on rust-lang/rust#49870.\n+                    let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n+                    self.cfg.push_assign(block, source_info, &local_for_arm_body, rvalue);\n+                    let rvalue = Rvalue::Ref(region, BorrowKind::Shared, local_for_arm_body);\n+                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn bind_matched_candidate_for_arm_body(&mut self,\n+                                           block: BasicBlock,\n+                                           bindings: &[Binding<'tcx>],\n+                                           already_initialized_state_for_refs: bool) {\n+        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}, \\\n+                already_initialized_state_for_refs={:?})\",\n+               block, bindings, already_initialized_state_for_refs);\n+\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n+            if let BindingMode::ByRef(..) = binding.binding_mode {\n+                // See \"NOTE tricky business\" above\n+                if already_initialized_state_for_refs { continue; }\n+            }\n+\n             let source_info = self.source_info(binding.span);\n-            let local = self.storage_live_binding(block, binding.var_id, binding.span);\n-            self.schedule_drop_for_binding(binding.var_id, binding.span);\n+            let local = self.storage_live_binding(block, binding.var_id, binding.span,\n+                                                  OutsideGuard);\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             let rvalue = match binding.binding_mode {\n-                BindingMode::ByValue =>\n-                    Rvalue::Use(self.consume_by_copy_or_move(binding.source)),\n-                BindingMode::ByRef(region, borrow_kind) =>\n-                    Rvalue::Ref(region, borrow_kind, binding.source),\n+                BindingMode::ByValue => {\n+                    Rvalue::Use(self.consume_by_copy_or_move(binding.source.clone()))\n+                }\n+                BindingMode::ByRef(region, borrow_kind) => {\n+                    Rvalue::Ref(region, borrow_kind, binding.source.clone())\n+                }\n             };\n             self.cfg.push_assign(block, source_info, &local, rvalue);\n         }\n     }\n \n+    /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where\n+    /// the bound `var` has type `T` in the arm body) in a pattern\n+    /// maps to *two* locals. The first local is a binding for\n+    /// occurrences of `var` in the guard, which will all have type\n+    /// `&T`. The second local is a binding for occurrences of `var`\n+    /// in the arm body, which will have type `T`.\n     fn declare_binding(&mut self,\n                        source_info: SourceInfo,\n                        syntactic_scope: VisibilityScope,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n-                       var_ty: Ty<'tcx>)\n-                       -> Local\n+                       var_ty: Ty<'tcx>,\n+                       has_guard: ArmHasGuard)\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?}, \\\n                 syntactic_scope={:?})\",\n                var_id, name, var_ty, source_info, syntactic_scope);\n \n-        let var = self.local_decls.push(LocalDecl::<'tcx> {\n+        let tcx = self.hir.tcx();\n+        let for_arm_body = self.local_decls.push(LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n@@ -842,10 +1068,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             internal: false,\n             is_user_variable: true,\n         });\n-        self.var_indices.insert(var_id, var);\n-\n-        debug!(\"declare_binding: var={:?}\", var);\n-\n-        var\n+        let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n+            let for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n+                mutability,\n+                ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n+                name: Some(name),\n+                source_info,\n+                syntactic_scope,\n+                internal: false,\n+                is_user_variable: true,\n+            });\n+            LocalsForNode::Two { for_guard, for_arm_body }\n+        } else {\n+            LocalsForNode::One(for_arm_body)\n+        };\n+        debug!(\"declare_binding: vars={:?}\", locals);\n+        self.var_indices.insert(var_id, locals);\n     }\n }"}, {"sha": "dd2a336af41d0a7d346e6793ccf064848f589369", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a72790d879a6266b4dc75ab3014c00735cf67610/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a72790d879a6266b4dc75ab3014c00735cf67610", "patch": "@@ -291,8 +291,14 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     visibility_scope_info: IndexVec<VisibilityScope, VisibilityScopeInfo>,\n     visibility_scope: VisibilityScope,\n \n+    /// the guard-context: each time we build the guard expression for\n+    /// a match arm, we push onto this stack, and then pop when we\n+    /// finish building it.\n+    guard_context: Vec<GuardFrame>,\n+\n     /// Maps node ids of variable bindings to the `Local`s created for them.\n-    var_indices: NodeMap<Local>,\n+    /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n+    var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     unit_temp: Option<Place<'tcx>>,\n \n@@ -305,6 +311,74 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     cached_unreachable_block: Option<BasicBlock>,\n }\n \n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    fn is_bound_var_in_guard(&self, id: ast::NodeId) -> bool {\n+        self.guard_context.iter().any(|frame| frame.locals.iter().any(|local| local.id == id))\n+    }\n+\n+    fn var_local_id(&self, id: ast::NodeId, for_guard: ForGuard) -> Local {\n+        self.var_indices[&id].local_id(for_guard)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum LocalsForNode {\n+    One(Local),\n+    Two { for_guard: Local, for_arm_body: Local },\n+}\n+\n+#[derive(Debug)]\n+struct GuardFrameLocal {\n+    id: ast::NodeId,\n+}\n+\n+impl GuardFrameLocal {\n+    fn new(id: ast::NodeId, _binding_mode: BindingMode) -> Self {\n+        GuardFrameLocal {\n+            id: id,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct GuardFrame {\n+    /// These are the id's of names that are bound by patterns of the\n+    /// arm of *this* guard.\n+    ///\n+    /// (Frames higher up the stack will have the id's bound in arms\n+    /// further out, such as in a case like:\n+    ///\n+    /// match E1 {\n+    ///      P1(id1) if (... (match E2 { P2(id2) if ... => B2 })) => B1,\n+    /// }\n+    ///\n+    /// here, when building for FIXME\n+    locals: Vec<GuardFrameLocal>,\n+}\n+\n+/// ForGuard is isomorphic to a boolean flag. It indicates whether we are\n+/// talking about the temp for a local binding for a use within a guard expression,\n+/// or a temp for use outside of a guard expressions.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum ForGuard {\n+    WithinGuard,\n+    OutsideGuard,\n+}\n+\n+impl LocalsForNode {\n+    fn local_id(&self, for_guard: ForGuard) -> Local {\n+        match (self, for_guard) {\n+            (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n+            (&LocalsForNode::Two { for_guard: local_id, .. }, ForGuard::WithinGuard) |\n+            (&LocalsForNode::Two { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n+                local_id,\n+\n+            (&LocalsForNode::One(_), ForGuard::WithinGuard) =>\n+                bug!(\"anything with one local should never be within a guard.\"),\n+        }\n+    }\n+}\n+\n struct CFG<'tcx> {\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n }\n@@ -548,6 +622,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             visibility_scope_info: IndexVec::new(),\n+            guard_context: vec![],\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n@@ -636,11 +711,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Don't introduce extra copies for simple bindings\n                     PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n                         self.local_decls[local].mutability = mutability;\n-                        self.var_indices.insert(var, local);\n+                        self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &pattern);\n+                                                      LintLevel::Inherited, &pattern,\n+                                                      matches::ArmHasGuard(false));\n                         unpack!(block = self.place_into_pattern(block, pattern, &place));\n                     }\n                 }"}]}