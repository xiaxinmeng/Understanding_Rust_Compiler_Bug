{"sha": "97495da163c017da34ce2bc8ba31388524216ba1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NDk1ZGExNjNjMDE3ZGEzNGNlMmJjOGJhMzEzODg1MjQyMTZiYTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-26T17:44:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-27T00:49:35Z"}, "message": "rollup merge of #19224: frewsxcv/unprefix-json-types\n\nAddressing the issues brought up in [this thread](https://github.com/rust-lang/rust/pull/19114#discussion_r20614461)\n\nThis pull request:\n\n* Unpublicizes reexports\n* Renames type aliases:\n * `json::JsonArray` \u261e `json::Array`\n * `json::JsonObject` \u261e `json::Object`", "tree": {"sha": "507d0f396d2ace88b654c6296c17d03cd4a161a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/507d0f396d2ace88b654c6296c17d03cd4a161a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97495da163c017da34ce2bc8ba31388524216ba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97495da163c017da34ce2bc8ba31388524216ba1", "html_url": "https://github.com/rust-lang/rust/commit/97495da163c017da34ce2bc8ba31388524216ba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97495da163c017da34ce2bc8ba31388524216ba1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fac5a07679cac21a580badc84b755b8df0f975cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fac5a07679cac21a580badc84b755b8df0f975cf", "html_url": "https://github.com/rust-lang/rust/commit/fac5a07679cac21a580badc84b755b8df0f975cf"}, {"sha": "ce238d752b1e04d4aea21c0fadf420a270ed6ff9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce238d752b1e04d4aea21c0fadf420a270ed6ff9", "html_url": "https://github.com/rust-lang/rust/commit/ce238d752b1e04d4aea21c0fadf420a270ed6ff9"}], "stats": {"total": 184, "additions": 92, "deletions": 92}, "files": [{"sha": "473552ab0ff98dc25ec84339e1b538b3dcd1c9b0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/97495da163c017da34ce2bc8ba31388524216ba1/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97495da163c017da34ce2bc8ba31388524216ba1/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=97495da163c017da34ce2bc8ba31388524216ba1", "patch": "@@ -194,12 +194,11 @@ fn main() {\n \n */\n \n-pub use self::JsonEvent::*;\n-pub use self::StackElement::*;\n-pub use self::Json::*;\n-pub use self::ErrorCode::*;\n-pub use self::ParserError::*;\n-pub use self::DecoderError::*;\n+use self::JsonEvent::*;\n+use self::StackElement::*;\n+use self::ErrorCode::*;\n+use self::ParserError::*;\n+use self::DecoderError::*;\n use self::ParserState::*;\n use self::InternalStackElement::*;\n \n@@ -223,13 +222,13 @@ pub enum Json {\n     F64(f64),\n     String(string::String),\n     Boolean(bool),\n-    Array(JsonArray),\n-    Object(JsonObject),\n+    Array(self::Array),\n+    Object(self::Object),\n     Null,\n }\n \n-pub type JsonArray = Vec<Json>;\n-pub type JsonObject = TreeMap<string::String, Json>;\n+pub type Array = Vec<Json>;\n+pub type Object = TreeMap<string::String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, PartialEq)]\n@@ -274,7 +273,7 @@ pub enum DecoderError {\n \n /// Returns a readable error string for a given error code.\n pub fn error_str(error: ErrorCode) -> &'static str {\n-    return match error {\n+    match error {\n         InvalidSyntax => \"invalid syntax\",\n         InvalidNumber => \"invalid number\",\n         EOFWhileParsingObject => \"EOF While parsing object\",\n@@ -863,14 +862,14 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n     fn encode(&self, e: &mut E) -> Result<(), S> {\n         match *self {\n-            I64(v) => v.encode(e),\n-            U64(v) => v.encode(e),\n-            F64(v) => v.encode(e),\n-            String(ref v) => v.encode(e),\n-            Boolean(v) => v.encode(e),\n-            Array(ref v) => v.encode(e),\n-            Object(ref v) => v.encode(e),\n-            Null => e.emit_nil(),\n+            Json::I64(v) => v.encode(e),\n+            Json::U64(v) => v.encode(e),\n+            Json::F64(v) => v.encode(e),\n+            Json::String(ref v) => v.encode(e),\n+            Json::Boolean(v) => v.encode(e),\n+            Json::Array(ref v) => v.encode(e),\n+            Json::Object(ref v) => v.encode(e),\n+            Json::Null => e.emit_nil(),\n         }\n     }\n }\n@@ -900,7 +899,7 @@ impl Json {\n     /// Otherwise, returns None.\n     pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n-            &Object(ref map) => map.get(key),\n+            &Json::Object(ref map) => map.get(key),\n             _ => None\n         }\n     }\n@@ -924,7 +923,7 @@ impl Json {\n     /// or the Json value is not an Object, returns None.\n     pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n-            &Object(ref map) => {\n+            &Json::Object(ref map) => {\n                 match map.get(key) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n@@ -949,9 +948,9 @@ impl Json {\n \n     /// If the Json value is an Object, returns the associated TreeMap.\n     /// Returns None otherwise.\n-    pub fn as_object<'a>(&'a self) -> Option<&'a JsonObject> {\n+    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n         match self {\n-            &Object(ref map) => Some(map),\n+            &Json::Object(ref map) => Some(map),\n             _ => None\n         }\n     }\n@@ -963,9 +962,9 @@ impl Json {\n \n     /// If the Json value is an Array, returns the associated vector.\n     /// Returns None otherwise.\n-    pub fn as_array<'a>(&'a self) -> Option<&'a JsonArray> {\n+    pub fn as_array<'a>(&'a self) -> Option<&'a Array> {\n         match self {\n-            &Array(ref array) => Some(&*array),\n+            &Json::Array(ref array) => Some(&*array),\n             _ => None\n         }\n     }\n@@ -979,39 +978,39 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            String(ref s) => Some(s.as_slice()),\n+            Json::String(ref s) => Some(s.as_slice()),\n             _ => None\n         }\n     }\n \n     /// Returns true if the Json value is a Number. Returns false otherwise.\n     pub fn is_number(&self) -> bool {\n         match *self {\n-            I64(_) | U64(_) | F64(_) => true,\n+            Json::I64(_) | Json::U64(_) | Json::F64(_) => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if the Json value is a i64. Returns false otherwise.\n     pub fn is_i64(&self) -> bool {\n         match *self {\n-            I64(_) => true,\n+            Json::I64(_) => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if the Json value is a u64. Returns false otherwise.\n     pub fn is_u64(&self) -> bool {\n         match *self {\n-            U64(_) => true,\n+            Json::U64(_) => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if the Json value is a f64. Returns false otherwise.\n     pub fn is_f64(&self) -> bool {\n         match *self {\n-            F64(_) => true,\n+            Json::F64(_) => true,\n             _ => false,\n         }\n     }\n@@ -1020,8 +1019,8 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_i64(&self) -> Option<i64> {\n         match *self {\n-            I64(n) => Some(n),\n-            U64(n) => num::cast(n),\n+            Json::I64(n) => Some(n),\n+            Json::U64(n) => num::cast(n),\n             _ => None\n         }\n     }\n@@ -1030,8 +1029,8 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_u64(&self) -> Option<u64> {\n         match *self {\n-            I64(n) => num::cast(n),\n-            U64(n) => Some(n),\n+            Json::I64(n) => num::cast(n),\n+            Json::U64(n) => Some(n),\n             _ => None\n         }\n     }\n@@ -1040,9 +1039,9 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_f64(&self) -> Option<f64> {\n         match *self {\n-            I64(n) => num::cast(n),\n-            U64(n) => num::cast(n),\n-            F64(n) => Some(n),\n+            Json::I64(n) => num::cast(n),\n+            Json::U64(n) => num::cast(n),\n+            Json::F64(n) => Some(n),\n             _ => None\n         }\n     }\n@@ -1056,7 +1055,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_boolean(&self) -> Option<bool> {\n         match self {\n-            &Boolean(b) => Some(b),\n+            &Json::Boolean(b) => Some(b),\n             _ => None\n         }\n     }\n@@ -1070,7 +1069,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_null(&self) -> Option<()> {\n         match self {\n-            &Null => Some(()),\n+            &Json::Null => Some(()),\n             _ => None\n         }\n     }\n@@ -1085,7 +1084,7 @@ impl<'a> ops::Index<&'a str, Json>  for Json {\n impl ops::Index<uint, Json> for Json {\n     fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n         match self {\n-            &Array(ref v) => v.index(idx),\n+            &Json::Array(ref v) => v.index(idx),\n             _ => panic!(\"can only index Json with uint if it is an array\")\n         }\n     }\n@@ -1844,16 +1843,16 @@ impl<T: Iterator<char>> Builder<T> {\n     }\n \n     fn build_value(&mut self) -> Result<Json, BuilderError> {\n-        match self.token {\n-            Some(NullValue) => Ok(Null),\n-            Some(I64Value(n)) => Ok(I64(n)),\n-            Some(U64Value(n)) => Ok(U64(n)),\n-            Some(F64Value(n)) => Ok(F64(n)),\n-            Some(BooleanValue(b)) => Ok(Boolean(b)),\n+        return match self.token {\n+            Some(NullValue) => Ok(Json::Null),\n+            Some(I64Value(n)) => Ok(Json::I64(n)),\n+            Some(U64Value(n)) => Ok(Json::U64(n)),\n+            Some(F64Value(n)) => Ok(Json::F64(n)),\n+            Some(BooleanValue(b)) => Ok(Json::Boolean(b)),\n             Some(StringValue(ref mut s)) => {\n                 let mut temp = string::String::new();\n                 swap(s, &mut temp);\n-                Ok(String(temp))\n+                Ok(Json::String(temp))\n             }\n             Some(Error(e)) => Err(e),\n             Some(ArrayStart) => self.build_array(),\n@@ -1870,7 +1869,7 @@ impl<T: Iterator<char>> Builder<T> {\n \n         loop {\n             if self.token == Some(ArrayEnd) {\n-                return Ok(Array(values.into_iter().collect()));\n+                return Ok(Json::Array(values.into_iter().collect()));\n             }\n             match self.build_value() {\n                 Ok(v) => values.push(v),\n@@ -1887,7 +1886,7 @@ impl<T: Iterator<char>> Builder<T> {\n \n         loop {\n             match self.token {\n-                Some(ObjectEnd) => { return Ok(Object(values)); }\n+                Some(ObjectEnd) => { return Ok(Json::Object(values)); }\n                 Some(Error(e)) => { return Err(e); }\n                 None => { break; }\n                 _ => {}\n@@ -1947,14 +1946,14 @@ impl Decoder {\n macro_rules! expect(\n     ($e:expr, Null) => ({\n         match $e {\n-            Null => Ok(()),\n+            Json::Null => Ok(()),\n             other => Err(ExpectedError(\"Null\".to_string(),\n                                        format!(\"{}\", other)))\n         }\n     });\n     ($e:expr, $t:ident) => ({\n         match $e {\n-            $t(v) => Ok(v),\n+            Json::$t(v) => Ok(v),\n             other => {\n                 Err(ExpectedError(stringify!($t).to_string(),\n                                   format!(\"{}\", other)))\n@@ -1967,25 +1966,25 @@ macro_rules! read_primitive {\n     ($name:ident, $ty:ty) => {\n         fn $name(&mut self) -> DecodeResult<$ty> {\n             match self.pop() {\n-                I64(f) => {\n+                Json::I64(f) => {\n                     match num::cast(f) {\n                         Some(f) => Ok(f),\n                         None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n                     }\n                 }\n-                U64(f) => {\n+                Json::U64(f) => {\n                     match num::cast(f) {\n                         Some(f) => Ok(f),\n                         None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n                     }\n                 }\n-                F64(f) => {\n+                Json::F64(f) => {\n                     match num::cast(f) {\n                         Some(f) => Ok(f),\n                         None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n                     }\n                 }\n-                String(s) => {\n+                Json::String(s) => {\n                     // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                     // is going to have a string here, as per JSON spec.\n                     match std::str::from_str(s.as_slice()) {\n@@ -2021,18 +2020,18 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_f64(&mut self) -> DecodeResult<f64> {\n         debug!(\"read_f64\");\n         match self.pop() {\n-            I64(f) => Ok(f as f64),\n-            U64(f) => Ok(f as f64),\n-            F64(f) => Ok(f),\n-            String(s) => {\n+            Json::I64(f) => Ok(f as f64),\n+            Json::U64(f) => Ok(f as f64),\n+            Json::F64(f) => Ok(f),\n+            Json::String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 }\n             },\n-            Null => Ok(f64::NAN),\n+            Json::Null => Ok(f64::NAN),\n             value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n         }\n     }\n@@ -2073,10 +2072,10 @@ impl ::Decoder<DecoderError> for Decoder {\n                             -> DecodeResult<T> {\n         debug!(\"read_enum_variant(names={})\", names);\n         let name = match self.pop() {\n-            String(s) => s,\n-            Object(mut o) => {\n+            Json::String(s) => s,\n+            Json::Object(mut o) => {\n                 let n = match o.remove(&\"variant\".to_string()) {\n-                    Some(String(s)) => s,\n+                    Some(Json::String(s)) => s,\n                     Some(val) => {\n                         return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n                     }\n@@ -2085,7 +2084,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                     }\n                 };\n                 match o.remove(&\"fields\".to_string()) {\n-                    Some(Array(l)) => {\n+                    Some(Json::Array(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n                         }\n@@ -2158,7 +2157,7 @@ impl ::Decoder<DecoderError> for Decoder {\n             None => {\n                 // Add a Null and try to parse it as an Option<_>\n                 // to get None as a default value.\n-                self.stack.push(Null);\n+                self.stack.push(Json::Null);\n                 match f(self) {\n                     Ok(x) => x,\n                     Err(_) => return Err(MissingFieldError(name.to_string())),\n@@ -2169,7 +2168,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 try!(f(self))\n             }\n         };\n-        self.stack.push(Object(obj));\n+        self.stack.push(Json::Object(obj));\n         Ok(value)\n     }\n \n@@ -2214,7 +2213,7 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_option()\");\n         match self.pop() {\n-            Null => f(self, false),\n+            Json::Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n@@ -2242,7 +2241,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         let len = obj.len();\n         for (key, value) in obj.into_iter() {\n             self.stack.push(value);\n-            self.stack.push(String(key));\n+            self.stack.push(Json::String(key));\n         }\n         f(self, len)\n     }\n@@ -2273,7 +2272,7 @@ pub trait ToJson for Sized? {\n macro_rules! to_json_impl_i64(\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n-            fn to_json(&self) -> Json { I64(*self as i64) }\n+            fn to_json(&self) -> Json { Json::I64(*self as i64) }\n         })+\n     )\n )\n@@ -2283,7 +2282,7 @@ to_json_impl_i64!(int, i8, i16, i32, i64)\n macro_rules! to_json_impl_u64(\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n-            fn to_json(&self) -> Json { U64(*self as u64) }\n+            fn to_json(&self) -> Json { Json::U64(*self as u64) }\n         })+\n     )\n )\n@@ -2301,26 +2300,26 @@ impl ToJson for f32 {\n impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n-            FPNaN | FPInfinite => Null,\n-            _                  => F64(*self)\n+            FPNaN | FPInfinite => Json::Null,\n+            _                  => Json::F64(*self)\n         }\n     }\n }\n \n impl ToJson for () {\n-    fn to_json(&self) -> Json { Null }\n+    fn to_json(&self) -> Json { Json::Null }\n }\n \n impl ToJson for bool {\n-    fn to_json(&self) -> Json { Boolean(*self) }\n+    fn to_json(&self) -> Json { Json::Boolean(*self) }\n }\n \n impl ToJson for str {\n-    fn to_json(&self) -> Json { String(self.into_string()) }\n+    fn to_json(&self) -> Json { Json::String(self.into_string()) }\n }\n \n impl ToJson for string::String {\n-    fn to_json(&self) -> Json { String((*self).clone()) }\n+    fn to_json(&self) -> Json { Json::String((*self).clone()) }\n }\n \n macro_rules! tuple_impl {\n@@ -2335,7 +2334,7 @@ macro_rules! tuple_impl {\n             #[allow(non_snake_case)]\n             fn to_json(&self) -> Json {\n                 match *self {\n-                    ($(ref $tyvar),*,) => Array(vec![$($tyvar.to_json()),*])\n+                    ($(ref $tyvar),*,) => Json::Array(vec![$($tyvar.to_json()),*])\n                 }\n             }\n         }\n@@ -2356,11 +2355,11 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n impl<A: ToJson> ToJson for [A] {\n-    fn to_json(&self) -> Json { Array(self.iter().map(|elt| elt.to_json()).collect()) }\n+    fn to_json(&self) -> Json { Json::Array(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n impl<A: ToJson> ToJson for Vec<A> {\n-    fn to_json(&self) -> Json { Array(self.iter().map(|elt| elt.to_json()).collect()) }\n+    fn to_json(&self) -> Json { Json::Array(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n@@ -2369,7 +2368,7 @@ impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n-        Object(d)\n+        Json::Object(d)\n     }\n }\n \n@@ -2379,14 +2378,14 @@ impl<A: ToJson> ToJson for HashMap<string::String, A> {\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n-        Object(d)\n+        Json::Object(d)\n     }\n }\n \n impl<A:ToJson> ToJson for Option<A> {\n     fn to_json(&self) -> Json {\n         match *self {\n-            None => Null,\n+            None => Json::Null,\n             Some(ref value) => value.to_json()\n         }\n     }\n@@ -2412,15 +2411,16 @@ mod tests {\n     use self::DecodeEnum::*;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{Array, Encoder, Decoder, Error, Boolean, I64, U64, F64, String, Null,\n-                PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n-                MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n-                JsonEvent, Parser, StackElement,\n-                ObjectStart, ObjectEnd, ArrayStart, ArrayEnd, BooleanValue, U64Value,\n-                F64Value, StringValue, NullValue, SyntaxError, Key, Index, Stack,\n-                InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingArray,\n-                EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n-                TrailingCharacters, TrailingComma};\n+    use super::Json::*;\n+    use super::ErrorCode::*;\n+    use super::ParserError::*;\n+    use super::DecoderError::*;\n+    use super::JsonEvent::*;\n+    use super::ParserState::*;\n+    use super::StackElement::*;\n+    use super::InternalStackElement::*;\n+    use super::{PrettyEncoder, Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n+                StackElement, Stack, Encoder, Decoder};\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n     use std::num::Float;"}, {"sha": "ba73b7cee2ebc77588708d750e3c4970bc4518e6", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97495da163c017da34ce2bc8ba31388524216ba1/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97495da163c017da34ce2bc8ba31388524216ba1/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=97495da163c017da34ce2bc8ba31388524216ba1", "patch": "@@ -21,7 +21,7 @@ enum object {\n     int_value(i64),\n }\n \n-fn lookup(table: json::JsonObject, key: String, default: String) -> String\n+fn lookup(table: json::Object, key: String, default: String) -> String\n {\n     match table.find(&key.to_string()) {\n         option::Some(&json::String(ref s)) => {"}]}