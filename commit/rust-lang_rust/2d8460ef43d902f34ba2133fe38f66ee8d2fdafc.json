{"sha": "2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "node_id": "C_kwDOAAsO6NoAKDJkODQ2MGVmNDNkOTAyZjM0YmEyMTMzZmUzOGY2NmVlOGQyZmRhZmM", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-07-15T17:17:10Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-09-05T11:06:23Z"}, "message": "Add matrix based test for documenting the let / let else temporary drop order\n\nThe drop order of let and let else is supposed to be the same,\nand in order to ensure this, the test checks that this holds for\nthe given list of cases.\n\nThe test also ensures that we drop the temporaries of the\ncondition before executing the else block.\n\nWe made the test matrix based so it can check all the possible\ncombinations and find out possible edge cases.", "tree": {"sha": "34e1a0d47e87656d89d3dbe5e4cdfb8a22558fee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34e1a0d47e87656d89d3dbe5e4cdfb8a22558fee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "html_url": "https://github.com/rust-lang/rust/commit/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "289279de116707f28cf9c18e4bbb8c6ec84ad75b", "url": "https://api.github.com/repos/rust-lang/rust/commits/289279de116707f28cf9c18e4bbb8c6ec84ad75b", "html_url": "https://github.com/rust-lang/rust/commit/289279de116707f28cf9c18e4bbb8c6ec84ad75b"}], "stats": {"total": 321, "additions": 321, "deletions": 0}, "files": [{"sha": "0054f3d4182ec12a32ebf6d19f0ea43ea454754f", "filename": "src/test/ui/let-else/let-else-drop-order.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs?ref=2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "patch": "@@ -0,0 +1,270 @@\n+// run-pass\n+// edition:2021\n+// check-run-results\n+//\n+// Drop order tests for let else\n+//\n+// Mostly this ensures two things:\n+// 1. That let and let else temporary drop order is the same.\n+//    This is a specific design request: https://github.com/rust-lang/rust/pull/93628#issuecomment-1047140316\n+// 2. That the else block truly only runs after the\n+//    temporaries have dropped.\n+//\n+// We also print some nice tables for an overview by humans.\n+// Changes in those tables are considered breakages, but the\n+// important properties 1 and 2 are also enforced by the code.\n+// This is important as it's easy to update the stdout file\n+// with a --bless and miss the impact of that change.\n+\n+#![feature(let_else)]\n+#![allow(irrefutable_let_patterns)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+#[derive(Clone)]\n+struct DropAccountant(Rc<RefCell<Vec<Vec<String>>>>);\n+\n+impl DropAccountant {\n+    fn new() -> Self {\n+        Self(Default::default())\n+    }\n+    fn build_droppy(&self, v: u32) -> Droppy<u32> {\n+        Droppy(self.clone(), v)\n+    }\n+    fn build_droppy_enum_none(&self, _v: u32) -> ((), DroppyEnum<u32>) {\n+        ((), DroppyEnum::None(self.clone()))\n+    }\n+    fn new_list(&self, s: impl ToString) {\n+        self.0.borrow_mut().push(vec![s.to_string()]);\n+    }\n+    fn push(&self, s: impl ToString) {\n+        let s = s.to_string();\n+        let mut accounts = self.0.borrow_mut();\n+        accounts.last_mut().unwrap().push(s);\n+    }\n+    fn print_table(&self) {\n+        println!();\n+\n+        let accounts = self.0.borrow();\n+        let before_last = &accounts[accounts.len() - 2];\n+        let last = &accounts[accounts.len() - 1];\n+        let before_last = get_comma_list(before_last);\n+        let last = get_comma_list(last);\n+        const LINES: &[&str] = &[\n+            \"vanilla\",\n+            \"&\",\n+            \"&mut\",\n+            \"move\",\n+            \"fn(this)\",\n+            \"tuple\",\n+            \"array\",\n+            \"ref &\",\n+            \"ref mut &mut\",\n+        ];\n+        let max_len = LINES.iter().map(|v| v.len()).max().unwrap();\n+        let max_len_before = before_last.iter().map(|v| v.len()).max().unwrap();\n+        let max_len_last = last.iter().map(|v| v.len()).max().unwrap();\n+\n+        println!(\n+            \"| {: <max_len$} | {: <max_len_before$} | {: <max_len_last$} |\",\n+            \"construct\", before_last[0], last[0]\n+        );\n+        println!(\"| {:-<max_len$} | {:-<max_len_before$} | {:-<max_len_last$} |\", \"\", \"\", \"\");\n+\n+        for ((l, l_before), l_last) in\n+            LINES.iter().zip(before_last[1..].iter()).zip(last[1..].iter())\n+        {\n+            println!(\n+                \"| {: <max_len$} | {: <max_len_before$} | {: <max_len_last$} |\",\n+                l, l_before, l_last,\n+            );\n+        }\n+    }\n+    #[track_caller]\n+    fn assert_all_equal_to(&self, st: &str) {\n+        let accounts = self.0.borrow();\n+        let last = &accounts[accounts.len() - 1];\n+        let last = get_comma_list(last);\n+        for line in last[1..].iter() {\n+            assert_eq!(line.trim(), st.trim());\n+        }\n+    }\n+    #[track_caller]\n+    fn assert_equality_last_two_lists(&self) {\n+        let accounts = self.0.borrow();\n+        let last = &accounts[accounts.len() - 1];\n+        let before_last = &accounts[accounts.len() - 2];\n+        for (l, b) in last[1..].iter().zip(before_last[1..].iter()) {\n+            if !(l == b || l == \"n/a\" || b == \"n/a\") {\n+                panic!(\"not equal: '{last:?}' != '{before_last:?}'\");\n+            }\n+        }\n+    }\n+}\n+\n+fn get_comma_list(sl: &[String]) -> Vec<String> {\n+    std::iter::once(sl[0].clone())\n+        .chain(sl[1..].chunks(2).map(|c| c.join(\",\")))\n+        .collect::<Vec<String>>()\n+}\n+\n+struct Droppy<T>(DropAccountant, T);\n+\n+impl<T> Drop for Droppy<T> {\n+    fn drop(&mut self) {\n+        self.0.push(\"drop\");\n+    }\n+}\n+\n+#[allow(dead_code)]\n+enum DroppyEnum<T> {\n+    Some(DropAccountant, T),\n+    None(DropAccountant),\n+}\n+\n+impl<T> Drop for DroppyEnum<T> {\n+    fn drop(&mut self) {\n+        match self {\n+            DroppyEnum::Some(acc, _inner) => acc,\n+            DroppyEnum::None(acc) => acc,\n+        }\n+        .push(\"drop\");\n+    }\n+}\n+\n+macro_rules! nestings_with {\n+    ($construct:ident, $binding:pat, $exp:expr) => {\n+        // vanilla:\n+        $construct!($binding, $exp.1);\n+\n+        // &:\n+        $construct!(&$binding, &$exp.1);\n+\n+        // &mut:\n+        $construct!(&mut $binding, &mut ($exp.1));\n+\n+        {\n+            // move:\n+            let w = $exp;\n+            $construct!(\n+                $binding,\n+                {\n+                    let w = w;\n+                    w\n+                }\n+                .1\n+            );\n+        }\n+\n+        // fn(this):\n+        $construct!($binding, std::convert::identity($exp).1);\n+    };\n+}\n+\n+macro_rules! nestings {\n+    ($construct:ident, $binding:pat, $exp:expr) => {\n+        nestings_with!($construct, $binding, $exp);\n+\n+        // tuple:\n+        $construct!(($binding, 77), ($exp.1, 77));\n+\n+        // array:\n+        $construct!([$binding], [$exp.1]);\n+    };\n+}\n+\n+macro_rules! let_else {\n+    ($acc:expr, $v:expr, $binding:pat, $build:ident) => {\n+        let acc = $acc;\n+        let v = $v;\n+\n+        macro_rules! let_else_construct {\n+            ($arg:pat, $exp:expr) => {\n+                loop {\n+                    let $arg = $exp else {\n+                        acc.push(\"else\");\n+                        break;\n+                    };\n+                    acc.push(\"body\");\n+                    break;\n+                }\n+            };\n+        }\n+        nestings!(let_else_construct, $binding, acc.$build(v));\n+        // ref &:\n+        let_else_construct!($binding, &acc.$build(v).1);\n+\n+        // ref mut &mut:\n+        let_else_construct!($binding, &mut acc.$build(v).1);\n+    };\n+}\n+\n+macro_rules! let_ {\n+    ($acc:expr, $binding:tt) => {\n+        let acc = $acc;\n+\n+        macro_rules! let_construct {\n+            ($arg:pat, $exp:expr) => {{\n+                let $arg = $exp;\n+                acc.push(\"body\");\n+            }};\n+        }\n+        let v = 0;\n+        {\n+            nestings_with!(let_construct, $binding, acc.build_droppy(v));\n+        }\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+\n+        // ref &:\n+        let_construct!($binding, &acc.build_droppy(v).1);\n+\n+        // ref mut &mut:\n+        let_construct!($binding, &mut acc.build_droppy(v).1);\n+    };\n+}\n+\n+fn main() {\n+    let acc = DropAccountant::new();\n+\n+    println!(\" --- matching cases ---\");\n+\n+    // Ensure that let and let else have the same behaviour\n+    acc.new_list(\"let _\");\n+    let_!(&acc, _);\n+    acc.new_list(\"let else _\");\n+    let_else!(&acc, 0, _, build_droppy);\n+    acc.assert_equality_last_two_lists();\n+    acc.print_table();\n+\n+    // Ensure that let and let else have the same behaviour\n+    acc.new_list(\"let _v\");\n+    let_!(&acc, _v);\n+    acc.new_list(\"let else _v\");\n+    let_else!(&acc, 0, _v, build_droppy);\n+    acc.assert_equality_last_two_lists();\n+    acc.print_table();\n+\n+    println!();\n+\n+    println!(\" --- mismatching cases ---\");\n+\n+    acc.new_list(\"let else _ mismatch\");\n+    let_else!(&acc, 1, DroppyEnum::Some(_, _), build_droppy_enum_none);\n+    acc.new_list(\"let else _v mismatch\");\n+    let_else!(&acc, 1, DroppyEnum::Some(_, _v), build_droppy_enum_none);\n+    acc.print_table();\n+    // This ensures that we always drop before visiting the else case\n+    acc.assert_all_equal_to(\"drop,else\");\n+\n+    acc.new_list(\"let else 0 mismatch\");\n+    let_else!(&acc, 1, 0, build_droppy);\n+    acc.new_list(\"let else 0 mismatch\");\n+    let_else!(&acc, 1, 0, build_droppy);\n+    acc.print_table();\n+    // This ensures that we always drop before visiting the else case\n+    acc.assert_all_equal_to(\"drop,else\");\n+}"}, {"sha": "01cf2f73e17c9e466508fa538169d64c510dd6c5", "filename": "src/test/ui/let-else/let-else-drop-order.run.stdout", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout?ref=2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "patch": "@@ -0,0 +1,51 @@\n+ --- matching cases ---\n+\n+| construct    | let _     | let else _ |\n+| ------------ | --------- | ---------- |\n+| vanilla      | drop,body | drop,body  |\n+| &            | body,drop | body,drop  |\n+| &mut         | body,drop | body,drop  |\n+| move         | drop,body | drop,body  |\n+| fn(this)     | drop,body | drop,body  |\n+| tuple        | n/a,n/a   | drop,body  |\n+| array        | n/a,n/a   | drop,body  |\n+| ref &        | body,drop | body,drop  |\n+| ref mut &mut | body,drop | body,drop  |\n+\n+| construct    | let _v    | let else _v |\n+| ------------ | --------- | ----------- |\n+| vanilla      | drop,body | drop,body   |\n+| &            | body,drop | body,drop   |\n+| &mut         | body,drop | body,drop   |\n+| move         | drop,body | drop,body   |\n+| fn(this)     | drop,body | drop,body   |\n+| tuple        | n/a,n/a   | drop,body   |\n+| array        | n/a,n/a   | drop,body   |\n+| ref &        | body,drop | body,drop   |\n+| ref mut &mut | body,drop | body,drop   |\n+\n+ --- mismatching cases ---\n+\n+| construct    | let else _ mismatch | let else _v mismatch |\n+| ------------ | ------------------- | -------------------- |\n+| vanilla      | drop,else           | drop,else            |\n+| &            | drop,else           | drop,else            |\n+| &mut         | drop,else           | drop,else            |\n+| move         | drop,else           | drop,else            |\n+| fn(this)     | drop,else           | drop,else            |\n+| tuple        | drop,else           | drop,else            |\n+| array        | drop,else           | drop,else            |\n+| ref &        | drop,else           | drop,else            |\n+| ref mut &mut | drop,else           | drop,else            |\n+\n+| construct    | let else 0 mismatch | let else 0 mismatch |\n+| ------------ | ------------------- | ------------------- |\n+| vanilla      | drop,else           | drop,else           |\n+| &            | drop,else           | drop,else           |\n+| &mut         | drop,else           | drop,else           |\n+| move         | drop,else           | drop,else           |\n+| fn(this)     | drop,else           | drop,else           |\n+| tuple        | drop,else           | drop,else           |\n+| array        | drop,else           | drop,else           |\n+| ref &        | drop,else           | drop,else           |\n+| ref mut &mut | drop,else           | drop,else           |"}]}