{"sha": "f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZTA5ZDZmMWZhYTZlNGQ3ZDRkMTkxMjNkMTYzM2ZjZTM3MGUxNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T06:07:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T06:07:41Z"}, "message": "auto merge of #7420 : mozilla/rust/rollup, r=thestinger", "tree": {"sha": "660935f34a057fbf3178197e5cec40e8de89d309", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/660935f34a057fbf3178197e5cec40e8de89d309"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "html_url": "https://github.com/rust-lang/rust/commit/f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eda5e40b79f7aaa51765f59c21a76fe033c937b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda5e40b79f7aaa51765f59c21a76fe033c937b1", "html_url": "https://github.com/rust-lang/rust/commit/eda5e40b79f7aaa51765f59c21a76fe033c937b1"}, {"sha": "ab428b648001030a0ea71c61dd89a531109c0cdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab428b648001030a0ea71c61dd89a531109c0cdd", "html_url": "https://github.com/rust-lang/rust/commit/ab428b648001030a0ea71c61dd89a531109c0cdd"}], "stats": {"total": 799, "additions": 474, "deletions": 325}, "files": [{"sha": "c84426161796d231876dd1f7bb27f15dbd6d8257", "filename": ".gitmodules", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -1,6 +1,8 @@\n [submodule \"src/llvm\"]\n \tpath = src/llvm\n \turl = https://github.com/brson/llvm.git\n+\tbranch = master\n [submodule \"src/libuv\"]\n \tpath = src/libuv\n \turl = https://github.com/brson/libuv.git\n+\tbranch = master"}, {"sha": "dbee53f8e30583944587570ce0245a696f05a74b", "filename": "RELEASES.txt", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -4,6 +4,8 @@ Version 0.7 (July 2013)\n    * ??? changes, numerous bugfixes\n \n    * Syntax changes\n+      * `impl`s no longer accept a visibility qualifier. Put them on methods\n+        instead.\n       * `use mod` is no longer valid.\n       * `fail!` and `assert!` accept `~str`, `&'static str` or `fmt!`-style\n         argument list.\n@@ -25,6 +27,10 @@ Version 0.7 (July 2013)\n         no padding between fields.\n       * The `for` loop protocol now requires `for`-iterators to return `bool`\n         so they compose better.\n+      * Trait default methods work more often.\n+      * Type parameters bound by `Copy` must now be copied explicitly with\n+        the `copy` keyword.\n+      * It is now illegal to move out of a dereferenced unsafe pointer.\n       * `Option<~T>` is now represented as a nullable pointer.\n       * `@mut` does dynamic borrow checks correctly.\n       * Macros TODO\n@@ -43,26 +49,30 @@ Version 0.7 (July 2013)\n    * Libraries\n       * The `core` crate was renamed to `std`.\n       * The `std` crate was renamed to `extra`.\n-      * `std::mut` removed.\n-      * std: The prelude no longer reexports any modules, only types and traits.\n-      * std: Prelude additions: `print`, `println`, `FromStr`, `ApproxEq`, `Equiv`,\n-        `Iterator`, `IteratorUtil`, many numeric traits, many tuple traits.\n       * std: `iterator` module for external iterator objects.\n+      * Many old-style (internal, higher-order function) iterators replaced by\n+        implementations of `Iterator`.\n       * std: Many old internal vector and string iterators,\n         incl. `any`, `all`. removed.\n-      * std: new numeric traits: `Fractional`, `Real`, `RealExt`, `Integer`, `Ratio`,\n+      * std: The `finalize` method of `Drop` renamed to `drop`.\n+      * std: The prelude no longer reexports any modules, only types and traits.\n+      * std: Prelude additions: `print`, `println`, `FromStr`, `ApproxEq`, `Equiv`,\n+        `Iterator`, `IteratorUtil`, many numeric traits, many tuple traits.\n+      * std: New numeric traits: `Fractional`, `Real`, `RealExt`, `Integer`, `Ratio`,\n         `Algebraic`, `Trigonometric`, `Exponential`, `Primitive`.\n       * std: Tuple traits and accessors defined for up to 12-tuples, e.g.\n         `(0, 1, 2).n2()` or `(0, 1, 2).n2_ref()`.\n-      * std: many types implement `Clone`.\n+      * std: Many types implement `Clone`.\n       * std: `path` type renamed to `Path`.\n+      * std: `mut` module and `Mut` type removed.\n       * std: Many standalone functions removed in favor of methods and iterators\n         in `vec`, `str`. In the future methods will also work as functions.\n-      * std: `reinterpret_cast` removed. Used `transmute`.\n+      * std: `reinterpret_cast` removed. Use `transmute`.\n       * std: ascii string handling in `std::ascii`.\n       * std: `Rand` is implemented for ~/@.\n       * std: `run` module for spawning processes overhauled.\n       * std: Various atomic types added to `unstable::atomic`.\n+      * std: Various types implement `Zero`.\n       * std: `LinearMap` and `LinearSet` renamed to `HashMap` and `HashSet`.\n       * std: Borrowed pointer functions moved from `ptr` to `borrow`.\n       * std: Added `os::mkdir_recursive`.\n@@ -96,7 +106,6 @@ Version 0.7 (July 2013)\n       * More and improved library documentation.\n       * Various improvements on ARM and Android.\n       * Various improvements to MIPS backend.\n-      * jemalloc is the Rust allocator.\n \n Version 0.6 (April 2013)\n ------------------------"}, {"sha": "36031d31149a9fd47591379dc6b7252449104166", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -60,7 +60,7 @@ def scrub(b):\n for t in stage2_tests:\n     p = os.path.join(\"test\", \"run-pass\", t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n-    d.write(\"    out.write_str(~\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n+    d.write(\"    out.write_str(\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n     d.write(\"    t_%d::main();\\n\" % i)\n     i += 1\n d.write(\"}\\n\")"}, {"sha": "e6a7dd64837305170421ba60af03c5b0747ab0b6", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 109, "deletions": 3, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n //! A double-ended queue implemented as a circular buffer\n-\n use core::prelude::*;\n \n use core::uint;\n use core::util::replace;\n use core::vec;\n+use core::cast::transmute;\n \n static initial_capacity: uint = 32u; // 2^5\n \n@@ -153,7 +153,86 @@ impl<T> Deque<T> {\n     pub fn reserve_at_least(&mut self, n: uint) {\n         vec::reserve_at_least(&mut self.elts, n);\n     }\n+\n+    /// Front-to-back iterator.\n+    pub fn iter<'a>(&'a self) -> DequeIterator<'a, T> {\n+    DequeIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+\n+    /// Front-to-back iterator which returns mutable values.\n+    pub fn mut_iter<'a>(&'a mut self) -> DequeMutIterator<'a, T> {\n+    DequeMutIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+\n+    /// Back-to-front iterator.\n+    pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n+    DequeRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+\n+    /// Back-to-front iterator which returns mutable values.\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n+    DequeMutRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+}\n+\n+macro_rules! iterator {\n+    (impl $name:ident -> $elem:ty, $step:expr) => {\n+        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                if self.used >= self.nelts {\n+                    return None;\n+                }\n+                let ret = unsafe {\n+                    match self.vec[self.idx % self.vec.len()] {\n+                        Some(ref e) => Some(transmute(e)),\n+                        None => None\n+                    }\n+                };\n+                self.idx += $step;\n+                self.used += 1;\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+/// Deque iterator\n+pub struct DequeIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self [Option<T>]\n }\n+iterator!{impl DequeIterator -> &'self T, 1}\n+\n+/// Deque reverse iterator\n+pub struct DequeRevIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self [Option<T>]\n+}\n+iterator!{impl DequeRevIterator -> &'self T, -1}\n+\n+/// Deque mutable iterator\n+pub struct DequeMutIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self mut [Option<T>]\n+\n+}\n+iterator!{impl DequeMutIterator -> &'self mut T, 1}\n+\n+/// Deque mutable reverse iterator\n+pub struct DequeMutRevIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self mut [Option<T>]\n+}\n+iterator!{impl DequeMutRevIterator -> &'self mut T, -1}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n@@ -178,6 +257,7 @@ mod tests {\n     use core::cmp::Eq;\n     use core::kinds::Copy;\n     use core::vec::capacity;\n+    use core;\n \n     #[test]\n     fn test_simple() {\n@@ -318,8 +398,7 @@ mod tests {\n \n     #[test]\n     fn test_param_taggy() {\n-        test_parameterized::<Taggy>(One(1), Two(1, 2), Three(1, 2, 3),\n-                                    Two(17, 42));\n+        test_parameterized::<Taggy>(One(1), Two(1, 2), Three(1, 2, 3), Two(17, 42));\n     }\n \n     #[test]\n@@ -382,4 +461,31 @@ mod tests {\n         assert_eq!(capacity(&mut d.elts), 64);\n     }\n \n+    #[test]\n+    fn test_iter() {\n+        let mut d = Deque::new();\n+        for core::int::range(0,5) |i| {\n+            d.add_back(i);\n+        }\n+        assert_eq!(d.iter().collect::<~[&int]>(), ~[&0,&1,&2,&3,&4]);\n+\n+        for core::int::range(6,9) |i| {\n+            d.add_front(i);\n+        }\n+        assert_eq!(d.iter().collect::<~[&int]>(), ~[&8,&7,&6,&0,&1,&2,&3,&4]);\n+    }\n+\n+    #[test]\n+    fn test_rev_iter() {\n+        let mut d = Deque::new();\n+        for core::int::range(0,5) |i| {\n+            d.add_back(i);\n+        }\n+        assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0]);\n+\n+        for core::int::range(6,9) |i| {\n+            d.add_front(i);\n+        }\n+        assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n+    }\n }"}, {"sha": "af891edf9e5fde3848197ddcd19e0fffe37b032c", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -37,10 +37,11 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n }\n \n impl<T:Ord> PriorityQueue<T> {\n-    /// Visit all values in the underlying vector.\n-    ///\n-    /// The values are **not** visited in order.\n-    pub fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.iter().advance(f) }\n+    /// An iterator visiting all values in underlying vector, in\n+    /// arbitrary order.\n+    pub fn iter<'a>(&'a self) -> PriorityQueueIterator<'a, T> {\n+        PriorityQueueIterator { iter: self.data.iter() }\n+    }\n \n     /// Returns the greatest item in the queue - fails if empty\n     pub fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n@@ -178,11 +179,33 @@ impl<T:Ord> PriorityQueue<T> {\n     }\n }\n \n+/// PriorityQueue iterator\n+pub struct PriorityQueueIterator <'self, T> {\n+    priv iter: vec::VecIterator<'self, T>,\n+}\n+\n+impl<'self, T> Iterator<&'self T> for PriorityQueueIterator<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'self T)> { self.iter.next() }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use sort::merge_sort;\n     use priority_queue::PriorityQueue;\n \n+    #[test]\n+    fn test_iterator() {\n+        let data = ~[5, 9, 3];\n+        let iterout = ~[9, 5, 3];\n+        let pq = PriorityQueue::from_vec(data);\n+        let mut i = 0;\n+        for pq.iter().advance |el| {\n+            assert_eq!(*el, iterout[i]);\n+            i += 1;\n+        }\n+    }\n+\n     #[test]\n     fn test_top_and_pop() {\n         let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];"}, {"sha": "3d35d1332b2f0dac6905aafbb1b2fa0e141057f8", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -832,7 +832,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.each |key, val| {\n+            for self.iter().advance |(key, val)| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -866,7 +866,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            for self.iter().advance |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }"}, {"sha": "9a4469cb5265a85298ddf0cd655f330fcf3fb1be", "filename": "src/libextra/term.rs", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -24,35 +24,38 @@ use core::io;\n \n // FIXME (#2807): Windows support.\n \n-pub static color_black: u8 = 0u8;\n-pub static color_red: u8 = 1u8;\n-pub static color_green: u8 = 2u8;\n-pub static color_yellow: u8 = 3u8;\n-pub static color_blue: u8 = 4u8;\n-pub static color_magenta: u8 = 5u8;\n-pub static color_cyan: u8 = 6u8;\n-pub static color_light_gray: u8 = 7u8;\n-pub static color_light_grey: u8 = 7u8;\n-pub static color_dark_gray: u8 = 8u8;\n-pub static color_dark_grey: u8 = 8u8;\n-pub static color_bright_red: u8 = 9u8;\n-pub static color_bright_green: u8 = 10u8;\n-pub static color_bright_yellow: u8 = 11u8;\n-pub static color_bright_blue: u8 = 12u8;\n-pub static color_bright_magenta: u8 = 13u8;\n-pub static color_bright_cyan: u8 = 14u8;\n-pub static color_bright_white: u8 = 15u8;\n+pub mod color {\n+    pub type Color = u16;\n+\n+    pub static black:   Color = 0u16;\n+    pub static red:     Color = 1u16;\n+    pub static green:   Color = 2u16;\n+    pub static yellow:  Color = 3u16;\n+    pub static blue:    Color = 4u16;\n+    pub static magenta: Color = 5u16;\n+    pub static cyan:    Color = 6u16;\n+    pub static white:   Color = 7u16;\n+\n+    pub static bright_black:   Color = 8u16;\n+    pub static bright_red:     Color = 9u16;\n+    pub static bright_green:   Color = 10u16;\n+    pub static bright_yellow:  Color = 11u16;\n+    pub static bright_blue:    Color = 12u16;\n+    pub static bright_magenta: Color = 13u16;\n+    pub static bright_cyan:    Color = 14u16;\n+    pub static bright_white:   Color = 15u16;\n+}\n \n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n-    color_supported: bool,\n+    num_colors: u16,\n     priv out: @io::Writer,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n pub struct Terminal {\n-    color_supported: bool,\n+    num_colors: u16,\n     priv out: @io::Writer,\n }\n \n@@ -66,66 +69,81 @@ impl Terminal {\n \n         let entry = open(term.unwrap());\n         if entry.is_err() {\n-            return Err(entry.get_err());\n+            return Err(entry.unwrap_err());\n         }\n \n-        let ti = parse(entry.get(), false);\n+        let ti = parse(entry.unwrap(), false);\n         if ti.is_err() {\n-            return Err(entry.get_err());\n+            return Err(ti.unwrap_err());\n         }\n \n-        let mut inf = ti.get();\n-        let cs = *inf.numbers.find_or_insert(~\"colors\", 0) >= 16\n-            && inf.strings.find(&~\"setaf\").is_some()\n-            && inf.strings.find_equiv(&(\"setab\")).is_some();\n+        let inf = ti.unwrap();\n+        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n+                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n+                     inf.numbers.find_equiv(&(\"colors\")).map_consume_default(0, |&n| n)\n+                 } else { 0 };\n \n-        return Ok(Terminal {out: out, ti: inf, color_supported: cs});\n+        return Ok(Terminal {out: out, ti: inf, num_colors: nc});\n     }\n-    pub fn fg(&self, color: u8) {\n-        if self.color_supported {\n+    /// Sets the foreground color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    pub fn fg(&self, color: color::Color) {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.get());\n+                self.out.write(s.unwrap());\n             } else {\n-                warn!(s.get_err());\n+                warn!(s.unwrap_err());\n             }\n         }\n     }\n-    pub fn bg(&self, color: u8) {\n-        if self.color_supported {\n+    /// Sets the background color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    pub fn bg(&self, color: color::Color) {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.get());\n+                self.out.write(s.unwrap());\n             } else {\n-                warn!(s.get_err());\n+                warn!(s.unwrap_err());\n             }\n         }\n     }\n     pub fn reset(&self) {\n-        if self.color_supported {\n-            let mut vars = Variables::new();\n-            let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], &mut vars);\n-            if s.is_ok() {\n-                self.out.write(s.get());\n-            } else {\n-                warn!(s.get_err());\n-            }\n+        let mut vars = Variables::new();\n+        let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], &mut vars);\n+        if s.is_ok() {\n+            self.out.write(s.unwrap());\n+        } else {\n+            warn!(s.unwrap_err());\n         }\n     }\n+\n+    priv fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+        if color >= self.num_colors && color >= 8 && color < 16 {\n+            color-8\n+        } else { color }\n+    }\n }\n \n #[cfg(target_os = \"win32\")]\n impl Terminal {\n     pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n-        return Ok(Terminal {out: out, color_supported: false});\n+        return Ok(Terminal {out: out, num_colors: 0});\n     }\n \n-    pub fn fg(&self, _color: u8) {\n+    pub fn fg(&self, _color: color::Color) {\n     }\n \n-    pub fn bg(&self, _color: u8) {\n+    pub fn bg(&self, _color: color::Color) {\n     }\n \n     pub fn reset(&self) {"}, {"sha": "72e70943ce1cce47662bbb2f29d6ac18165b410c", "filename": "src/libextra/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -326,33 +326,33 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n \n     fn write_ok(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ok\", term::color_green, use_color);\n+        write_pretty(out, \"ok\", term::color::green, use_color);\n     }\n \n     fn write_failed(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"FAILED\", term::color_red, use_color);\n+        write_pretty(out, \"FAILED\", term::color::red, use_color);\n     }\n \n     fn write_ignored(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ignored\", term::color_yellow, use_color);\n+        write_pretty(out, \"ignored\", term::color::yellow, use_color);\n     }\n \n     fn write_bench(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"bench\", term::color_cyan, use_color);\n+        write_pretty(out, \"bench\", term::color::cyan, use_color);\n     }\n \n     fn write_pretty(out: @io::Writer,\n                     word: &str,\n-                    color: u8,\n+                    color: term::color::Color,\n                     use_color: bool) {\n         let t = term::Terminal::new(out);\n         match t {\n             Ok(term)  => {\n-                if use_color && term.color_supported {\n+                if use_color {\n                     term.fg(color);\n                 }\n                 out.write_str(word);\n-                if use_color && term.color_supported {\n+                if use_color {\n                     term.reset();\n                 }\n             },"}, {"sha": "33ec4ae94ba52ddc3c902dbb4d34ca1c3f3bf9d3", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -164,19 +164,14 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Visit all key-value pairs in order\n-    pub fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n-        each(&self.root, f)\n-    }\n-\n     /// Visit all keys in order\n     pub fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n-        self.each(|k, _| f(k))\n+        self.iter().advance(|(k, _)| f(k))\n     }\n \n     /// Visit all values in order\n     pub fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n-        self.each(|_, v| f(v))\n+        self.iter().advance(|(_, v)| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n@@ -484,10 +479,6 @@ impl<T: TotalOrd> TreeSet<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n \n-    /// Visit all values in order\n-    #[inline]\n-    pub fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n-\n     /// Visit all values in reverse order\n     #[inline]\n     pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n@@ -779,7 +770,7 @@ mod test_treemap {\n             let &(k, v) = x;\n             assert!(map.find(&k).unwrap() == &v)\n         }\n-        for map.each |map_k, map_v| {\n+        for map.iter().advance |(map_k, map_v)| {\n             let mut found = false;\n             for ctrl.iter().advance |x| {\n                 let &(ctrl_k, ctrl_v) = x;\n@@ -885,7 +876,7 @@ mod test_treemap {\n     }\n \n     #[test]\n-    fn test_each() {\n+    fn test_iterator() {\n         let mut m = TreeMap::new();\n \n         assert!(m.insert(3, 6));\n@@ -895,7 +886,7 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        for m.each |k, v| {\n+        for m.iter().advance |(k, v)| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n@@ -1090,7 +1081,7 @@ mod test_set {\n     }\n \n     #[test]\n-    fn test_each() {\n+    fn test_iterator() {\n         let mut m = TreeSet::new();\n \n         assert!(m.insert(3));\n@@ -1100,7 +1091,7 @@ mod test_set {\n         assert!(m.insert(1));\n \n         let mut n = 0;\n-        for m.each |x| {\n+        for m.iter().advance |x| {\n             println(fmt!(\"%?\", x));\n             assert_eq!(*x, n);\n             n += 1"}, {"sha": "9e0d6fb8e3a6ea3fc9a4f09f5f646375ec42f3f5", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -89,70 +89,68 @@ fn find_library_crate_aux(\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix: ~str = prefix + crate_name + \"-\";\n-    let suffix: ~str = /*bad*/copy suffix;\n+    let prefix = prefix + crate_name + \"-\";\n \n     let mut matches = ~[];\n-    filesearch::search(filesearch, |path| {\n+    filesearch::search(filesearch, |path| -> Option<()> {\n         debug!(\"inspecting file %s\", path.to_str());\n-        let f: ~str = path.filename().get();\n-        if !(f.starts_with(prefix) && f.ends_with(suffix)) {\n-            debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n-                   prefix, suffix);\n-            option::None::<()>\n-        } else {\n-            debug!(\"%s is a candidate\", path.to_str());\n-            match get_metadata_section(cx.os, path) {\n-              option::Some(cvec) => {\n-                if !crate_matches(cvec, cx.metas, cx.hash) {\n-                    debug!(\"skipping %s, metadata doesn't match\",\n-                           path.to_str());\n-                    option::None::<()>\n-                } else {\n-                    debug!(\"found %s with matching metadata\", path.to_str());\n-                    matches.push((path.to_str(), cvec));\n-                    option::None::<()>\n+        match path.filename() {\n+            Some(ref f) if f.starts_with(prefix) && f.ends_with(suffix) => {\n+                debug!(\"%s is a candidate\", path.to_str());\n+                match get_metadata_section(cx.os, path) {\n+                    Some(cvec) =>\n+                        if !crate_matches(cvec, cx.metas, cx.hash) {\n+                            debug!(\"skipping %s, metadata doesn't match\",\n+                                   path.to_str());\n+                            None\n+                        } else {\n+                            debug!(\"found %s with matching metadata\", path.to_str());\n+                            matches.push((path.to_str(), cvec));\n+                            None\n+                        },\n+                    _ => {\n+                        debug!(\"could not load metadata for %s\", path.to_str());\n+                        None\n+                    }\n                 }\n-              }\n-              _ => {\n-                debug!(\"could not load metadata for %s\", path.to_str());\n-                option::None::<()>\n-              }\n             }\n-        }\n-    });\n+            _ => {\n+                debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n+                       prefix, suffix);\n+                None\n+            }\n+        }});\n \n-    if matches.is_empty() {\n-        None\n-    } else if matches.len() == 1u {\n-        Some(/*bad*/copy matches[0])\n-    } else {\n-        cx.diag.span_err(\n-            cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n-        cx.diag.handler().note(\"candidates:\");\n-        for matches.iter().advance |&(ident, data)| {\n-            cx.diag.handler().note(fmt!(\"path: %s\", ident));\n-            let attrs = decoder::get_crate_attributes(data);\n-            note_linkage_attrs(cx.intr, cx.diag, attrs);\n+    match matches.len() {\n+        0 => None,\n+        1 => Some(matches[0]),\n+        _ => {\n+            cx.diag.span_err(\n+                    cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n+                cx.diag.handler().note(\"candidates:\");\n+                for matches.iter().advance |&(ident, data)| {\n+                    cx.diag.handler().note(fmt!(\"path: %s\", ident));\n+                    let attrs = decoder::get_crate_attributes(data);\n+                    note_linkage_attrs(cx.intr, cx.diag, attrs);\n+                }\n+                cx.diag.handler().abort_if_errors();\n+                None\n+            }\n         }\n-        cx.diag.handler().abort_if_errors();\n-        None\n-    }\n }\n \n pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @str {\n-    let name_items = attr::find_meta_items_by_name(metas, \"name\");\n-    match name_items.last_opt() {\n-        Some(i) => {\n-            match attr::get_meta_item_value_str(*i) {\n-                Some(n) => n,\n-                // FIXME (#2406): Probably want a warning here since the user\n-                // is using the wrong type of meta item.\n-                _ => fail!()\n-            }\n+    for metas.iter().advance |m| {\n+        match m.node {\n+            ast::meta_name_value(s, ref l) if s == @\"name\" =>\n+                match l.node {\n+                    ast::lit_str(s) => return s,\n+                    _ => ()\n+                },\n+            _ => ()\n         }\n-        None => fail!(\"expected to find the crate name\")\n     }\n+    fail!(\"expected to find the crate name\")\n }\n \n pub fn note_linkage_attrs(intr: @ident_interner,"}, {"sha": "b4e6245f629d78db44ca67c9da8db17a9ee3130d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -55,7 +55,6 @@ use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::reachable;\n-use middle::trans::shape::*;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::type_of::*;\n@@ -2869,6 +2868,26 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n     }\n }\n \n+fn mk_global(ccx: &CrateContext,\n+             name: &str,\n+             llval: ValueRef,\n+             internal: bool)\n+          -> ValueRef {\n+    unsafe {\n+        let llglobal = do str::as_c_str(name) |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n+        };\n+        llvm::LLVMSetInitializer(llglobal, llval);\n+        llvm::LLVMSetGlobalConstant(llglobal, True);\n+\n+        if internal {\n+            lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n+        }\n+\n+        return llglobal;\n+    }\n+}\n+\n // Writes the current ABI version into the crate.\n pub fn write_abi_version(ccx: &mut CrateContext) {\n     mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version), false);"}, {"sha": "227e22131636baf8e4cc41d312d840b2029f48d2", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -210,7 +210,7 @@ pub fn store_environment(bcx: block,\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n-    // compute the shape of the closure\n+    // compute the type of the closure\n     let cdata_ty = mk_closure_tys(tcx, bound_values);\n \n     // allocate closure in the heap"}, {"sha": "272d7b234aa57f1efe6d6fbf3747e0dd60afe2a3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -658,7 +658,7 @@ impl block_ {\n pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_ptr(\n         tcx,\n-        ty::mt {ty: ty::mk_nil(), mutbl: ast::m_imm}\n+        ty::mt {ty: ty::mk_i8(), mutbl: ast::m_imm}\n     );\n     return ty::mk_tup(tcx, ~[ty::mk_uint(), ty::mk_type(tcx),\n                          ptr, ptr,\n@@ -826,20 +826,6 @@ pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_shape(ccx: &CrateContext, bytes: ~[u8]) -> ValueRef {\n-    unsafe {\n-        let llshape = C_bytes_plus_null(bytes);\n-        let name = fmt!(\"shape%u\", token::gensym(\"shape\"));\n-        let llglobal = do name.as_c_str |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape).to_ref(), buf)\n-        };\n-        llvm::LLVMSetInitializer(llglobal, llshape);\n-        llvm::LLVMSetGlobalConstant(llglobal, True);\n-        lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n-        return llvm::LLVMConstPointerCast(llglobal, Type::i8p().to_ref());\n-    }\n-}\n-\n pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n     unsafe {\n         llvm::LLVMGetParam(fndecl, param as c_uint)"}, {"sha": "a0ae579c86554d26b399038c54920e5a801991ca", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -22,7 +22,6 @@ use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::debuginfo;\n use middle::trans::reachable;\n-use middle::trans::shape;\n use middle::trans::type_use;\n use middle::ty;\n \n@@ -40,8 +39,6 @@ use middle::trans::common::{mono_id,new_namegen};\n \n use middle::trans::base::{decl_crate_map};\n \n-use middle::trans::shape::{mk_ctxt};\n-\n pub struct CrateContext {\n      sess: session::Session,\n      llmod: ModuleRef,\n@@ -110,7 +107,6 @@ pub struct CrateContext {\n      float_type: Type,\n      opaque_vec_type: Type,\n      builder: BuilderRef_res,\n-     shape_cx: shape::Ctxt,\n      crate_map: ValueRef,\n      // Set when at least one function uses GC. Needed so that\n      // decl_gc_metadata knows whether to link to the module metadata, which\n@@ -223,7 +219,6 @@ impl CrateContext {\n                   float_type: float_type,\n                   opaque_vec_type: opaque_vec_type,\n                   builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                  shape_cx: mk_ctxt(llmod),\n                   crate_map: crate_map,\n                   uses_gc: false,\n                   dbg_cx: dbg_cx,"}, {"sha": "c2a25d80998a50b2c04003b68027dbff94ae9ea7", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -35,7 +35,6 @@ pub mod cabi_arm;\n pub mod cabi_mips;\n pub mod foreign;\n pub mod reflect;\n-pub mod shape;\n pub mod debuginfo;\n pub mod type_use;\n pub mod reachable;"}, {"sha": "4118291dca0d6875529a60d03a164682138bd793", "filename": "src/librustc/middle/trans/shape.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/eda5e40b79f7aaa51765f59c21a76fe033c937b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda5e40b79f7aaa51765f59c21a76fe033c937b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=eda5e40b79f7aaa51765f59c21a76fe033c937b1", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A \"shape\" is a compact encoding of a type that is used by interpreted glue.\n-// This substitutes for the runtime tags used by e.g. MLs.\n-\n-\n-use lib::llvm::llvm;\n-use lib::llvm::{True, ModuleRef, ValueRef};\n-use middle::trans::common::*;\n-\n-use middle::trans::type_::Type;\n-\n-use core::str;\n-\n-pub struct Ctxt {\n-    next_tag_id: u16,\n-    pad: u16,\n-    pad2: u32\n-}\n-\n-pub fn mk_global(ccx: &CrateContext,\n-                 name: &str,\n-                 llval: ValueRef,\n-                 internal: bool)\n-              -> ValueRef {\n-    unsafe {\n-        let llglobal = do str::as_c_str(name) |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n-        };\n-        llvm::LLVMSetInitializer(llglobal, llval);\n-        llvm::LLVMSetGlobalConstant(llglobal, True);\n-\n-        if internal {\n-            ::lib::llvm::SetLinkage(llglobal,\n-                                    ::lib::llvm::InternalLinkage);\n-        }\n-\n-        return llglobal;\n-    }\n-}\n-\n-pub fn mk_ctxt(llmod: ModuleRef) -> Ctxt {\n-    unsafe {\n-        let llshapetablesty = Type::named_struct(\"shapes\");\n-        do \"shapes\".as_c_str |buf| {\n-            llvm::LLVMAddGlobal(llmod, llshapetablesty.to_ref(), buf)\n-        };\n-\n-        Ctxt {\n-            next_tag_id: 0u16,\n-            pad: 0u16,\n-            pad2: 0u32\n-        }\n-    }\n-}"}, {"sha": "869b3472422bc207f008f4df69909499e5ae7d4a", "filename": "src/librusti/program.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -107,7 +107,7 @@ impl Program {\n         match *to_print {\n             Some(ref s) => {\n                 code.push_str(*s);\n-                code.push_char('\\n');\n+                code.push_str(\";\\n\");\n             }\n             None => {}\n         }"}, {"sha": "54a404d971eec45e47ea74d22af99dcb4145d9a4", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -648,6 +648,11 @@ mod tests {\n             fn f() {}\n             f()\n         \");\n+\n+        debug!(\"simultaneous definitions + expressions are allowed\");\n+        run_program(\"\n+            let a = 3; a as u8\n+        \");\n     }\n \n     #[test]"}, {"sha": "bde7aaeab8e4a8139106990e7bef7cc7e4bbc351", "filename": "src/librustpkg/messages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -13,18 +13,18 @@ use core::io;\n use core::result::*;\n \n pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color_green, io::stdout())\n+    pretty_message(msg, \"note: \", term::color::green, io::stdout())\n }\n \n pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color_yellow, io::stdout())\n+    pretty_message(msg, \"warning: \", term::color::yellow, io::stdout())\n }\n \n pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color_red, io::stdout())\n+    pretty_message(msg, \"error: \", term::color::red, io::stdout())\n }\n \n-fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: u8, out: @io::Writer) {\n+fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: term::color::Color, out: @io::Writer) {\n     let term = term::Terminal::new(out);\n     match term {\n         Ok(ref t) => {"}, {"sha": "56e6bacf93e30eef6f0a5c05963e5fd9468e36bf", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 101, "deletions": 40, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -15,6 +15,7 @@\n use cast::transmute;\n use cast;\n use container::{Container, Mutable};\n+use cmp;\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n@@ -1299,44 +1300,6 @@ pub fn reverse<T>(v: &mut [T]) {\n     }\n }\n \n-/**\n- * Reverse part of a vector in place.\n- *\n- * Reverse the elements in the vector between `start` and `end - 1`.\n- *\n- * If either start or end do not represent valid positions in the vector, the\n- * vector is returned unchanged.\n- *\n- * # Arguments\n- *\n- * * `v` - The mutable vector to be modified\n- *\n- * * `start` - Index of the first element of the slice\n- *\n- * * `end` - Index one past the final element to be reversed.\n- *\n- * # Example\n- *\n- * Assume a mutable vector `v` contains `[1,2,3,4,5]`. After the call:\n- *\n- * ~~~ {.rust}\n- * reverse_part(v, 1, 4);\n- * ~~~\n- *\n- * `v` now contains `[1,4,3,2,5]`.\n- */\n-pub fn reverse_part<T>(v: &mut [T], start: uint, end : uint) {\n-    let sz = v.len();\n-    if start >= sz || end > sz { return; }\n-    let mut i = start;\n-    let mut j = end - 1;\n-    while i < j {\n-        vec::swap(v, i, j);\n-        i += 1;\n-        j -= 1;\n-    }\n-}\n-\n /// Returns a vector with the order of elements reversed\n pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n@@ -1393,7 +1356,7 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n         // swap indices[k] and indices[l]; sort indices[k+1..]\n         // (they're just reversed)\n         vec::swap(indices, k, l);\n-        reverse_part(indices, k+1, length);\n+        reverse(indices.mut_slice(k+1, length));\n         // fixup permutation based on indices\n         for uint::range(k, length) |i| {\n             permutation[i] = copy values[indices[i]];\n@@ -2059,6 +2022,21 @@ pub trait MutableVector<'self, T> {\n     fn mut_iter(self) -> VecMutIterator<'self, T>;\n     fn mut_rev_iter(self) -> VecMutRevIterator<'self, T>;\n \n+    /**\n+     * Consumes `src` and moves as many elements as it can into `self`\n+     * from the range [start,end).\n+     *\n+     * Returns the number of elements copied (the shorter of self.len()\n+     * and end - start).\n+     *\n+     * # Arguments\n+     *\n+     * * src - A mutable vector of `T`\n+     * * start - The index into `src` to start copying from\n+     * * end - The index into `str` to stop copying from\n+     */\n+    fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;\n+\n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n     unsafe fn unsafe_set(&self, index: uint, val: T);\n }\n@@ -2087,6 +2065,14 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n+    #[inline]\n+    fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {\n+        for self.mut_iter().zip(src.mut_slice(start, end).mut_iter()).advance |(a, b)| {\n+            util::swap(a, b);\n+        }\n+        cmp::min(self.len(), end-start)\n+    }\n+\n     #[inline]\n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T {\n         let pair_ptr: &(*mut T, uint) = transmute(self);\n@@ -2100,6 +2086,23 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n }\n \n+/// Trait for ~[T] where T is Cloneable\n+pub trait MutableCloneableVector<T> {\n+    /// Copies as many elements from `src` as it can into `self`\n+    /// (the shorter of self.len() and src.len()). Returns the number of elements copied.\n+    fn copy_from(self, &[T]) -> uint;\n+}\n+\n+impl<'self, T:Clone> MutableCloneableVector<T> for &'self mut [T] {\n+    #[inline]\n+    fn copy_from(self, src: &[T]) -> uint {\n+        for self.mut_iter().zip(src.iter()).advance |(a, b)| {\n+            *a = b.clone();\n+        }\n+        cmp::min(self.len(), src.len())\n+    }\n+}\n+\n /**\n * Constructs a vector from an unsafe pointer to a buffer\n *\n@@ -2288,6 +2291,22 @@ pub mod bytes {\n     use uint;\n     use vec::raw;\n     use vec;\n+    use ptr;\n+\n+    /// A trait for operations on mutable operations on `[u8]`\n+    pub trait MutableByteVector {\n+        /// Sets all bytes of the receiver to the given value.\n+        pub fn set_memory(self, value: u8);\n+    }\n+\n+    impl<'self> MutableByteVector for &'self mut [u8] {\n+        #[inline]\n+        fn set_memory(self, value: u8) {\n+            do vec::as_mut_buf(self) |p, len| {\n+                unsafe { ptr::set_memory(p, value, len) };\n+            }\n+        }\n+    }\n \n     /// Bytewise string comparison\n     pub fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n@@ -3879,10 +3898,42 @@ mod tests {\n         assert_eq!(xs, [5, 5, 5, 5, 5])\n     }\n \n+    #[test]\n+    fn test_move_from() {\n+        let mut a = [1,2,3,4,5];\n+        let b = ~[6,7,8];\n+        assert_eq!(a.move_from(b, 0, 3), 3);\n+        assert_eq!(a, [6,7,8,4,5]);\n+        let mut a = [7,2,8,1];\n+        let b = ~[3,1,4,1,5,9];\n+        assert_eq!(a.move_from(b, 0, 6), 4);\n+        assert_eq!(a, [3,1,4,1]);\n+        let mut a = [1,2,3,4];\n+        let b = ~[5,6,7,8,9,0];\n+        assert_eq!(a.move_from(b, 2, 3), 1);\n+        assert_eq!(a, [7,2,3,4]);\n+        let mut a = [1,2,3,4,5];\n+        let b = ~[5,6,7,8,9,0];\n+        assert_eq!(a.mut_slice(2,4).move_from(b,1,6), 2);\n+        assert_eq!(a, [1,2,6,7,5]);\n+    }\n+\n+    #[test]\n+    fn test_copy_from() {\n+        let mut a = [1,2,3,4,5];\n+        let b = [6,7,8];\n+        assert_eq!(a.copy_from(b), 3);\n+        assert_eq!(a, [6,7,8,4,5]);\n+        let mut c = [7,2,8,1];\n+        let d = [3,1,4,1,5,9];\n+        assert_eq!(c.copy_from(d), 4);\n+        assert_eq!(c, [3,1,4,1]);\n+    }\n+\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1,2,3,4,5];\n-        reverse_part(values,1,4);\n+        reverse(values.mut_slice(1, 4));\n         assert_eq!(values, [1,4,3,2,5]);\n     }\n \n@@ -3941,4 +3992,14 @@ mod tests {\n         t!(@[int]);\n         t!(~[int]);\n     }\n+\n+    #[test]\n+    fn test_bytes_set_memory() {\n+        use vec::bytes::MutableByteVector;\n+        let mut values = [1u8,2,3,4,5];\n+        values.mut_slice(0,5).set_memory(0xAB);\n+        assert_eq!(values, [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n+        values.mut_slice(2,4).set_memory(0xFF);\n+        assert_eq!(values, [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n+    }\n }"}, {"sha": "89867922b25bd4d250c77ae6fb769ea0471b81c4", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -178,16 +178,16 @@ fn diagnosticstr(lvl: level) -> ~str {\n     }\n }\n \n-fn diagnosticcolor(lvl: level) -> u8 {\n+fn diagnosticcolor(lvl: level) -> term::color::Color {\n     match lvl {\n-        fatal => term::color_bright_red,\n-        error => term::color_bright_red,\n-        warning => term::color_bright_yellow,\n-        note => term::color_bright_green\n+        fatal => term::color::bright_red,\n+        error => term::color::bright_red,\n+        warning => term::color::bright_yellow,\n+        note => term::color::bright_green\n     }\n }\n \n-fn print_maybe_colored(msg: &str, color: u8) {\n+fn print_maybe_colored(msg: &str, color: term::color::Color) {\n     let stderr = io::stderr();\n \n     let t = term::Terminal::new(stderr);\n@@ -231,7 +231,7 @@ pub fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n         let ss = cm.span_to_str(sp);\n         let lines = cm.span_to_lines(sp);\n         print_diagnostic(ss, lvl, msg);\n-        highlight_lines(cm, sp, lines);\n+        highlight_lines(cm, sp, lvl, lines);\n         print_macro_backtrace(cm, sp);\n       }\n       None => {\n@@ -241,7 +241,7 @@ pub fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n }\n \n fn highlight_lines(cm: @codemap::CodeMap,\n-                   sp: span,\n+                   sp: span, lvl: level,\n                    lines: @codemap::FileLines) {\n     let fm = lines.file;\n \n@@ -293,18 +293,18 @@ fn highlight_lines(cm: @codemap::CodeMap,\n             let curChar = (orig[pos] as char);\n             s += match curChar { // Whenever a tab occurs on the previous\n                 '\\t' => \"\\t\",    // line, we insert one on the error-point-\n-                _ => \" \"         // -squigly-line as well (instead of a\n-            };                   // space). This way the squigly-line will\n+                _ => \" \"         // -squiggly-line as well (instead of a\n+            };                   // space). This way the squiggly-line will\n         }                        // usually appear in the correct position.\n         io::stderr().write_str(s);\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n-            let num_squiglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n-            for num_squiglies.times() { s += \"~\"; }\n+            let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n+            for num_squigglies.times() { s += \"~\"; }\n         }\n-        print_maybe_colored(s + \"\\n\", term::color_bright_green);\n+        print_maybe_colored(s + \"\\n\", diagnosticcolor(lvl));\n     }\n }\n "}, {"sha": "7a30f5152d01de5ef8ec72483375abe419e6f88c", "filename": "src/test/run-pass/match-borrowed_str.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-borrowed_str.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -1,55 +1,60 @@\n-// FIXME #7306\n-// xfail-fast\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n \n-use std::io;\n-\n-fn f1(ref_string: &str) {\n+fn f1(ref_string: &str) -> ~str {\n     match ref_string {\n-        \"a\" => io::println(\"found a\"),\n-        \"b\" => io::println(\"found b\"),\n-        _ => io::println(\"not found\")\n+        \"a\" => ~\"found a\",\n+        \"b\" => ~\"found b\",\n+        _ => ~\"not found\"\n     }\n }\n \n-fn f2(ref_string: &str) {\n+fn f2(ref_string: &str) -> ~str {\n     match ref_string {\n-        \"a\" => io::println(\"found a\"),\n-        \"b\" => io::println(\"found b\"),\n-        s => io::println(fmt!(\"not found (%s)\", s))\n+        \"a\" => ~\"found a\",\n+        \"b\" => ~\"found b\",\n+        s => fmt!(\"not found (%s)\", s)\n     }\n }\n \n-fn g1(ref_1: &str, ref_2: &str) {\n+fn g1(ref_1: &str, ref_2: &str) -> ~str {\n     match (ref_1, ref_2) {\n-        (\"a\", \"b\") => io::println(\"found a,b\"),\n-        (\"b\", \"c\") => io::println(\"found b,c\"),\n-        _ => io::println(\"not found\")\n+        (\"a\", \"b\") => ~\"found a,b\",\n+        (\"b\", \"c\") => ~\"found b,c\",\n+        _ => ~\"not found\"\n     }\n }\n \n-fn g2(ref_1: &str, ref_2: &str) {\n+fn g2(ref_1: &str, ref_2: &str) -> ~str {\n     match (ref_1, ref_2) {\n-        (\"a\", \"b\") => io::println(\"found a,b\"),\n-        (\"b\", \"c\") => io::println(\"found b,c\"),\n-        (s1, s2) => io::println(fmt!(\"not found (%s, %s)\", s1, s2))\n+        (\"a\", \"b\") => ~\"found a,b\",\n+        (\"b\", \"c\") => ~\"found b,c\",\n+        (s1, s2) => fmt!(\"not found (%s, %s)\", s1, s2)\n     }\n }\n \n pub fn main() {\n-    f1(@\"a\");\n-    f1(~\"b\");\n-    f1(&\"c\");\n-    f1(\"d\");\n-    f2(@\"a\");\n-    f2(~\"b\");\n-    f2(&\"c\");\n-    f2(\"d\");\n-    g1(@\"a\", @\"b\");\n-    g1(~\"b\", ~\"c\");\n-    g1(&\"c\", &\"d\");\n-    g1(\"d\", \"e\");\n-    g2(@\"a\", @\"b\");\n-    g2(~\"b\", ~\"c\");\n-    g2(&\"c\", &\"d\");\n-    g2(\"d\", \"e\");\n+    assert_eq!(f1(@\"a\"), ~\"found a\");\n+    assert_eq!(f1(~\"b\"), ~\"found b\");\n+    assert_eq!(f1(&\"c\"), ~\"not found\");\n+    assert_eq!(f1(\"d\"), ~\"not found\");\n+    assert_eq!(f2(@\"a\"), ~\"found a\");\n+    assert_eq!(f2(~\"b\"), ~\"found b\");\n+    assert_eq!(f2(&\"c\"), ~\"not found (c)\");\n+    assert_eq!(f2(\"d\"), ~\"not found (d)\");\n+    assert_eq!(g1(@\"a\", @\"b\"), ~\"found a,b\");\n+    assert_eq!(g1(~\"b\", ~\"c\"), ~\"found b,c\");\n+    assert_eq!(g1(&\"c\", &\"d\"), ~\"not found\");\n+    assert_eq!(g1(\"d\", \"e\"), ~\"not found\");\n+    assert_eq!(g2(@\"a\", @\"b\"), ~\"found a,b\");\n+    assert_eq!(g2(~\"b\", ~\"c\"), ~\"found b,c\");\n+    assert_eq!(g2(&\"c\", &\"d\"), ~\"not found (c, d)\");\n+    assert_eq!(g2(\"d\", \"e\"), ~\"not found (d, e)\");\n }"}, {"sha": "34afc12f02e4f9967c640f51808889ed541645c7", "filename": "src/test/run-pass/shape_intrinsic_tag_then_rec.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e09d6f1faa6e4d7d4d19123d1633fce370e145/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs?ref=f1e09d6f1faa6e4d7d4d19123d1633fce370e145", "patch": "@@ -1,5 +1,3 @@\n-// xfail-fast\n-\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -14,9 +12,6 @@\n // on x86_64: when there is a enum embedded in an\n // interior record which is then itself interior to\n // something else, shape calculations were off.\n-extern mod extra;\n-use extra::list;\n-use extra::list::list;\n \n enum opt_span {\n "}]}