{"sha": "9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "node_id": "C_kwDOAAsO6NoAKDk4NTA1ODRhNGU1ZTRiN2U1Y2ViZDlkOTBjMjdkOGI4ODU5MWYyNjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-13T00:23:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-13T00:23:51Z"}, "message": "Auto merge of #103413 - RalfJung:phantom-dropck, r=lcnr\n\nPhantomData: fix documentation wrt interaction with dropck\n\nAs far as I could find out, the `PhantomData`-dropck interaction *only* affects code using `may_dangle`. The documentation in the standard library has not been updated for 8 years and thus stems from a time when Rust still used \"parametric dropck\", before [RFC 1238](https://rust-lang.github.io/rfcs/1238-nonparametric-dropck.html). Back then what the docs said was correct, but with `may_dangle` dropck it stopped being entirely accurate and these days, with NLL, it is actively misleading.\n\nFixes https://github.com/rust-lang/rust/issues/102810\nFixes https://github.com/rust-lang/rust/issues/70841\nCc `@nikomatsakis` I hope what I am saying here is right.^^", "tree": {"sha": "2f1d08489c9e1743b075f64744ede1c83fd1cec2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f1d08489c9e1743b075f64744ede1c83fd1cec2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "html_url": "https://github.com/rust-lang/rust/commit/9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9850584a4e5e4b7e5cebd9d90c27d8b88591f264/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d59fa3d23f021a18289416caf79fdf050bbc3b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d59fa3d23f021a18289416caf79fdf050bbc3b0", "html_url": "https://github.com/rust-lang/rust/commit/7d59fa3d23f021a18289416caf79fdf050bbc3b0"}, {"sha": "b93fd8355acbe8a4ffd53ad32c3d7f4798c15b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/b93fd8355acbe8a4ffd53ad32c3d7f4798c15b98", "html_url": "https://github.com/rust-lang/rust/commit/b93fd8355acbe8a4ffd53ad32c3d7f4798c15b98"}], "stats": {"total": 105, "additions": 95, "deletions": 10}, "files": [{"sha": "01606086fca681e51b45e9eb74f8f2c5fa906466", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9850584a4e5e4b7e5cebd9d90c27d8b88591f264/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9850584a4e5e4b7e5cebd9d90c27d8b88591f264/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "patch": "@@ -766,24 +766,19 @@ impl<T: ?Sized> !Sync for *mut T {}\n ///\n /// ## Ownership and the drop check\n ///\n-/// Adding a field of type `PhantomData<T>` indicates that your\n-/// type owns data of type `T`. This in turn implies that when your\n-/// type is dropped, it may drop one or more instances of the type\n-/// `T`. This has bearing on the Rust compiler's [drop check]\n-/// analysis.\n+/// The exact interaction of `PhantomData` with drop check **may change in the future**.\n ///\n-/// If your struct does not in fact *own* the data of type `T`, it is\n-/// better to use a reference type, like `PhantomData<&'a T>`\n-/// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n-/// as not to indicate ownership.\n+/// Currently, adding a field of type `PhantomData<T>` indicates that your type *owns* data of type\n+/// `T` in very rare circumstances. This in turn has effects on the Rust compiler's [drop check]\n+/// analysis. For the exact rules, see the [drop check] documentation.\n ///\n /// ## Layout\n ///\n /// For all `T`, the following are guaranteed:\n /// * `size_of::<PhantomData<T>>() == 0`\n /// * `align_of::<PhantomData<T>>() == 1`\n ///\n-/// [drop check]: ../../nomicon/dropck.html\n+/// [drop check]: Drop#drop-check\n #[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T: ?Sized>;"}, {"sha": "9ebf426be95135ad22711a64e1f7ed231f4329a3", "filename": "library/core/src/ops/drop.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9850584a4e5e4b7e5cebd9d90c27d8b88591f264/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9850584a4e5e4b7e5cebd9d90c27d8b88591f264/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs?ref=9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "patch": "@@ -132,6 +132,74 @@\n /// are `Copy` get implicitly duplicated by the compiler, making it very\n /// hard to predict when, and how often destructors will be executed. As such,\n /// these types cannot have destructors.\n+///\n+/// ## Drop check\n+///\n+/// Dropping interacts with the borrow checker in subtle ways: when a type `T` is being implicitly\n+/// dropped as some variable of this type goes out of scope, the borrow checker needs to ensure that\n+/// calling `T`'s destructor at this moment is safe. In particular, it also needs to be safe to\n+/// recursively drop all the fields of `T`. For example, it is crucial that code like the following\n+/// is being rejected:\n+///\n+/// ```compile_fail,E0597\n+/// use std::cell::Cell;\n+///\n+/// struct S<'a>(Cell<Option<&'a S<'a>>>, Box<i32>);\n+/// impl Drop for S<'_> {\n+///     fn drop(&mut self) {\n+///         if let Some(r) = self.0.get() {\n+///             // Print the contents of the `Box` in `r`.\n+///             println!(\"{}\", r.1);\n+///         }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     // Set up two `S` that point to each other.\n+///     let s1 = S(Cell::new(None), Box::new(42));\n+///     let s2 = S(Cell::new(Some(&s1)), Box::new(42));\n+///     s1.0.set(Some(&s2));\n+///     // Now they both get dropped. But whichever is the 2nd one\n+///     // to be dropped will access the `Box` in the first one,\n+///     // which is a use-after-free!\n+/// }\n+/// ```\n+///\n+/// The Nomicon discusses the need for [drop check in more detail][drop check].\n+///\n+/// To reject such code, the \"drop check\" analysis determines which types and lifetimes need to\n+/// still be live when `T` gets dropped. The exact details of this analysis are not yet\n+/// stably guaranteed and **subject to change**. Currently, the analysis works as follows:\n+/// - If `T` has no drop glue, then trivially nothing is required to be live. This is the case if\n+///   neither `T` nor any of its (recursive) fields have a destructor (`impl Drop`). [`PhantomData`]\n+///   and [`ManuallyDrop`] are considered to never have a destructor, no matter their field type.\n+/// - If `T` has drop glue, then, for all types `U` that are *owned* by any field of `T`,\n+///   recursively add the types and lifetimes that need to be live when `U` gets dropped. The set of\n+///   owned types is determined by recursively traversing `T`:\n+///   - Recursively descend through `PhantomData`, `Box`, tuples, and arrays (including arrays of\n+///     length 0).\n+///   - Stop at reference and raw pointer types as well as function pointers and function items;\n+///     they do not own anything.\n+///   - Stop at non-composite types (type parameters that remain generic in the current context and\n+///     base types such as integers and `bool`); these types are owned.\n+///   - When hitting an ADT with `impl Drop`, stop there; this type is owned.\n+///   - When hitting an ADT without `impl Drop`, recursively descend to its fields. (For an `enum`,\n+///     consider all fields of all variants.)\n+/// - Furthermore, if `T` implements `Drop`, then all generic (lifetime and type) parameters of `T`\n+///   must be live.\n+///\n+/// In the above example, the last clause implies that `'a` must be live when `S<'a>` is dropped,\n+/// and hence the example is rejected. If we remove the `impl Drop`, the liveness requirement\n+/// disappears and the example is accepted.\n+///\n+/// There exists an unstable way for a type to opt-out of the last clause; this is called \"drop\n+/// check eyepatch\" or `may_dangle`. For more details on this nightly-only feature, see the\n+/// [discussion in the Nomicon][nomicon].\n+///\n+/// [`ManuallyDrop`]: crate::mem::ManuallyDrop\n+/// [`PhantomData`]: crate::marker::PhantomData\n+/// [drop check]: ../../nomicon/dropck.html\n+/// [nomicon]: ../../nomicon/phantom-data.html#an-exception-the-special-case-of-the-standard-library-and-its-unstable-may_dangle\n #[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[const_trait]"}, {"sha": "ff100cd941fd6158279ff447a1f103cea3882e44", "filename": "tests/ui/drop/dropck-eyepatch-manuallydrop.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9850584a4e5e4b7e5cebd9d90c27d8b88591f264/tests%2Fui%2Fdrop%2Fdropck-eyepatch-manuallydrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9850584a4e5e4b7e5cebd9d90c27d8b88591f264/tests%2Fui%2Fdrop%2Fdropck-eyepatch-manuallydrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop%2Fdropck-eyepatch-manuallydrop.rs?ref=9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+//! This test checks that dropck knows that ManuallyDrop does not drop its field.\n+#![feature(dropck_eyepatch)]\n+\n+use std::mem::ManuallyDrop;\n+\n+struct S<T>(ManuallyDrop<T>);\n+\n+unsafe impl<#[may_dangle] T> Drop for S<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+struct NonTrivialDrop<'a>(&'a str);\n+impl<'a> Drop for NonTrivialDrop<'a> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    let s = String::from(\"string\");\n+    let _t = S(ManuallyDrop::new(NonTrivialDrop(&s)));\n+    drop(s);\n+}"}]}