{"sha": "ef38afc83db66dce317a3820121fb0233a0f4923", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMzhhZmM4M2RiNjZkY2UzMTdhMzgyMDEyMWZiMDIzM2EwZjQ5MjM=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-23T14:08:36Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-30T08:43:41Z"}, "message": "Add a test for various const let features", "tree": {"sha": "b32eeaedda85ba19e7393889ba700567b0baf033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b32eeaedda85ba19e7393889ba700567b0baf033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef38afc83db66dce317a3820121fb0233a0f4923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef38afc83db66dce317a3820121fb0233a0f4923", "html_url": "https://github.com/rust-lang/rust/commit/ef38afc83db66dce317a3820121fb0233a0f4923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef38afc83db66dce317a3820121fb0233a0f4923/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52b67b1766014ea73bac605ca643b1ddd69f1bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/52b67b1766014ea73bac605ca643b1ddd69f1bca", "html_url": "https://github.com/rust-lang/rust/commit/52b67b1766014ea73bac605ca643b1ddd69f1bca"}], "stats": {"total": 468, "additions": 468, "deletions": 0}, "files": [{"sha": "434aeaac5fd5b8563a046698ebb3a6a5aece3a8f", "filename": "src/test/ui/consts/const_let_eq.rs", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/ef38afc83db66dce317a3820121fb0233a0f4923/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef38afc83db66dce317a3820121fb0233a0f4923/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq.rs?ref=ef38afc83db66dce317a3820121fb0233a0f4923", "patch": "@@ -0,0 +1,468 @@\n+// run-pass\n+\n+struct Foo<T>(T);\n+struct Bar<T> { x: T }\n+struct W(u32);\n+struct A { a: u32 }\n+\n+const fn basics((a,): (u32,)) -> u32 {\n+    // Deferred assignment:\n+    let b: u32;\n+    b = a + 1;\n+\n+    // Immediate assignment:\n+    let c: u32 = b + 1;\n+\n+    // Mutables:\n+    let mut d: u32 = c + 1;\n+    d = d + 1;\n+    // +4 so far.\n+\n+    // No effect statements work:\n+    ; ;\n+    1;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [0];\n+    arr[0] = 1;\n+    d = d + arr[0];\n+    // +5\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(0);\n+    let mut bar: Bar<u32> = Bar { x: 0 };\n+    foo.0 = 1;\n+    bar.x = 1;\n+    d = d + foo.0 + bar.x;\n+    // +7\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(0)];\n+    arr[0].0 = 1;\n+    d = d + arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 0 }];\n+    arr[0].x = 1;\n+    d = d + arr[0].x;\n+    // +9\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([0]);\n+    (arr.0)[0] = 1;\n+    d = d + (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [0] };\n+    arr.x[0] = 1;\n+    d = d + arr.x[0];\n+    // +11\n+\n+    d\n+}\n+\n+const fn add_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a + 1;\n+    d += 1;\n+    // +2 so far.\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [0];\n+    arr[0] += 1;\n+    d += arr[0];\n+    // +3\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(0);\n+    let mut bar: Bar<u32> = Bar { x: 0 };\n+    foo.0 += 1;\n+    bar.x += 1;\n+    d += foo.0 + bar.x;\n+    // +5\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(0)];\n+    arr[0].0 += 1;\n+    d += arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 0 }];\n+    arr[0].x += 1;\n+    d += arr[0].x;\n+    // +7\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([0]);\n+    (arr.0)[0] += 1;\n+    d += (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [0] };\n+    arr.x[0] += 1;\n+    d += arr.x[0];\n+    // +9\n+\n+    d\n+}\n+\n+const fn mul_assign(A { a }: A) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a + 1;\n+    d *= 2;\n+    // 2^1 * (a + 1)\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [1];\n+    arr[0] *= 2;\n+    d *= arr[0];\n+    // 2^2 * (a + 1)\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(1);\n+    let mut bar: Bar<u32> = Bar { x: 1 };\n+    foo.0 *= 2;\n+    bar.x *= 2;\n+    d *= foo.0 + bar.x;\n+    // 2^4 * (a + 1)\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(1)];\n+    arr[0].0 *= 2;\n+    d *= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 1 }];\n+    arr[0].x *= 2;\n+    d *= arr[0].x;\n+    // 2^6 * (a + 1)\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([1]);\n+    (arr.0)[0] *= 2;\n+    d *= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [1] };\n+    arr.x[0] *= 2;\n+    d *= arr.x[0];\n+    // 2^8 * (a + 1)\n+\n+    d\n+}\n+\n+const fn div_assign(a: [u32; 1]) -> u32 {\n+    let a = a[0];\n+    // Mutables:\n+    let mut d: u32 = 1024 * a;\n+    d /= 2;\n+    // 512\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [4];\n+    arr[0] /= 2;\n+    d /= arr[0];\n+    // 256\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(4);\n+    let mut bar: Bar<u32> = Bar { x: 4 };\n+    foo.0 /= 2;\n+    bar.x /= 2;\n+    d /= foo.0;\n+    d /= bar.x;\n+    // 64\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(4)];\n+    arr[0].0 /= 2;\n+    d /= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 4 }];\n+    arr[0].x /= 2;\n+    d /= arr[0].x;\n+    // 16\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([4]);\n+    (arr.0)[0] /= 2;\n+    d /= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [4] };\n+    arr.x[0] /= 2;\n+    d /= arr.x[0];\n+    // 4\n+\n+    d\n+}\n+\n+const fn rem_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d %= 10;\n+    d += 10;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [3];\n+    arr[0] %= 2;\n+    d %= 9 + arr[0];\n+    d += 10;\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(5);\n+    let mut bar: Bar<u32> = Bar { x: 7 };\n+    foo.0 %= 2;\n+    bar.x %= 2;\n+    d %= 8 + foo.0 + bar.x;\n+    d += 10;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(4)];\n+    arr[0].0 %= 3;\n+    d %= 9 + arr[0].0;\n+    d += 10;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 7 }];\n+    arr[0].x %= 3;\n+    d %= 9 + arr[0].x;\n+    d += 10;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([6]);\n+    (arr.0)[0] %= 5;\n+    d %= 9 + (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [11] };\n+    arr.x[0] %= 5;\n+    d %= 9 + arr.x[0];\n+\n+    d\n+}\n+\n+const fn sub_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d -= 1;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [2];\n+    arr[0] -= 1;\n+    d -= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(2);\n+    let mut bar: Bar<u32> = Bar { x: 2 };\n+    foo.0 -= 1;\n+    bar.x -= 1;\n+    d -= foo.0 + bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(2)];\n+    arr[0].0 -= 1;\n+    d -= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 2 }];\n+    arr[0].x -= 1;\n+    d -= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([2]);\n+    (arr.0)[0] -= 1;\n+    d -= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [2] };\n+    arr.x[0] -= 1;\n+    d -= arr.x[0];\n+\n+    d\n+}\n+\n+const fn shl_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d <<= 1; // 10\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [1];\n+    arr[0] <<= 1;\n+    d <<= arr[0]; // 10 << 2\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(1);\n+    let mut bar: Bar<u32> = Bar { x: 1 };\n+    foo.0 <<= 1;\n+    bar.x <<= 1;\n+    d <<= foo.0 + bar.x; // 1000 << 4\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(1)];\n+    arr[0].0 <<= 1;\n+    d <<= arr[0].0; // 1000_0000 << 2\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 1 }];\n+    arr[0].x <<= 1;\n+    d <<= arr[0].x; // 1000_0000_00 << 2\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([1]);\n+    (arr.0)[0] <<= 1;\n+    d <<= (arr.0)[0]; // 1000_0000_0000 << 2\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [1] };\n+    arr.x[0] <<= 1;\n+    d <<= arr.x[0]; // 1000_0000_0000_00 << 2\n+\n+    d\n+}\n+\n+const fn shr_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d >>= 1; // /= 2\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [2];\n+    arr[0] >>= 1;\n+    d >>= arr[0]; // /= 4\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(2);\n+    let mut bar: Bar<u32> = Bar { x: 2 };\n+    foo.0 >>= 1;\n+    bar.x >>= 1;\n+    d >>= foo.0 + bar.x; // /= 16\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(2)];\n+    arr[0].0 >>= 1;\n+    d >>= arr[0].0; // /= 32\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 2 }];\n+    arr[0].x >>= 1;\n+    d >>= arr[0].x; // /= 64\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([2]);\n+    (arr.0)[0] >>= 1;\n+    d >>= (arr.0)[0]; // /= 128\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [2] };\n+    arr.x[0] >>= 1;\n+    d >>= arr.x[0]; // /= 256\n+\n+    d\n+}\n+\n+const fn bit_and_assign(W(a): W) -> u32 {\n+    let f = 0b1111_1111_1111_1111;\n+\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d &= 0b1111_1111_1111_1110;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [f];\n+    arr[0] &= 0b1111_1111_1111_1101;\n+    d &= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(f);\n+    let mut bar: Bar<u32> = Bar { x: f };\n+    foo.0 &= 0b1111_1111_1111_0111;\n+    bar.x &= 0b1111_1111_1101_1111;\n+    d &= foo.0 & bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(f)];\n+    arr[0].0 &= 0b1111_1110_1111_1111;\n+    d &= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: f }];\n+    arr[0].x &= 0b1111_1101_1111_1111;\n+    d &= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([f]);\n+    (arr.0)[0] &= 0b1011_1111_1111_1111;\n+    d &= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [f] };\n+    arr.x[0] &= 0b0111_1111_1111_1111;\n+    d &= arr.x[0];\n+\n+    d\n+}\n+\n+const fn bit_or_assign(W(a): W) -> u32 {\n+    let f = 0b0000_0000_0000_0000;\n+\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d |= 0b0000_0000_0000_0001;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [f];\n+    arr[0] |= 0b0000_0000_0000_1001;\n+    d |= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(f);\n+    let mut bar: Bar<u32> = Bar { x: f };\n+    foo.0 |= 0b0000_0000_0001_0000;\n+    bar.x |= 0b0000_0000_0100_0000;\n+    d |= foo.0 | bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(f)];\n+    arr[0].0 |= 0b0000_0001_0000_0000;\n+    d |= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: f }];\n+    arr[0].x |= 0b0000_0010_0000_0000;\n+    d |= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([f]);\n+    (arr.0)[0] |= 0b1000_0000_0000_0000;\n+    d |= (arr.0)[0]; // /= 128\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [f] };\n+    arr.x[0] |= 0b1100_0000_0000_0000;\n+    d |= arr.x[0]; // /= 256\n+\n+    d\n+}\n+\n+const fn bit_xor_assign(W(a): W) -> u32 {\n+    let f = 0b0000_0000_0000_0000;\n+\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d ^= 0b0000_0000_0000_0001;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [f];\n+    arr[0] ^= 0b0000_0000_0000_0010;\n+    d ^= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(f);\n+    let mut bar: Bar<u32> = Bar { x: f };\n+    foo.0 ^= 0b0000_0000_0001_0000;\n+    bar.x ^= 0b0000_0000_1000_0000;\n+    d ^= foo.0 ^ bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(f)];\n+    arr[0].0 ^= 0b0000_0001_0000_0000;\n+    d ^= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: f }];\n+    arr[0].x ^= 0b0000_0010_0000_0000;\n+    d ^= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([f]);\n+    (arr.0)[0] ^= 0b0100_0000_0000_0000;\n+    d ^= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [f] };\n+    arr.x[0] ^= 0b1000_0000_0000_0000;\n+    d ^= arr.x[0];\n+\n+    d\n+}\n+\n+macro_rules! test {\n+    ($c:ident, $e:expr, $r:expr) => {\n+        const $c: u32 = $e;\n+        assert_eq!($c, $r);\n+        assert_eq!($e, $r);\n+    }\n+}\n+\n+fn main() {\n+    test!(BASICS, basics((2,)), 13);\n+    test!(ADD, add_assign(W(1)), 10);\n+    test!(MUL, mul_assign(A { a: 0 }), 256);\n+    test!(DIV, div_assign([1]), 4);\n+    test!(REM, rem_assign(W(5)), 5);\n+    test!(SUB, sub_assign(W(8)), 0);\n+    test!(SHL, shl_assign(W(1)), 0b1000_0000_0000_0000);\n+    test!(SHR, shr_assign(W(256)), 1);\n+    test!(AND, bit_and_assign(W(0b1011_1111_1111_1111_1111)), 0b0011_1100_1101_0100);\n+    test!(OR, bit_or_assign(W(0b1011_0000_0000_0000)), 0b1111_0011_0101_1001);\n+    test!(XOR, bit_xor_assign(W(0b0000_0000_0000_0000)), 0b1100_0011_1001_0011);\n+}\n\\ No newline at end of file"}]}