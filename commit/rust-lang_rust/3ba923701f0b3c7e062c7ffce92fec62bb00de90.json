{"sha": "3ba923701f0b3c7e062c7ffce92fec62bb00de90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYTkyMzcwMWYwYjNjN2UwNjJjN2ZmY2U5MmZlYzYyYmIwMGRlOTA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-14T04:34:50Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-14T04:34:50Z"}, "message": "Update for changes in rustc nightly.", "tree": {"sha": "4f0da8f911bf94f3350735eb8f085f0f35651fc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f0da8f911bf94f3350735eb8f085f0f35651fc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba923701f0b3c7e062c7ffce92fec62bb00de90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba923701f0b3c7e062c7ffce92fec62bb00de90", "html_url": "https://github.com/rust-lang/rust/commit/3ba923701f0b3c7e062c7ffce92fec62bb00de90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba923701f0b3c7e062c7ffce92fec62bb00de90/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82dfa7278ba529f22e24c7d1dfad8b50f40f9819", "url": "https://api.github.com/repos/rust-lang/rust/commits/82dfa7278ba529f22e24c7d1dfad8b50f40f9819", "html_url": "https://github.com/rust-lang/rust/commit/82dfa7278ba529f22e24c7d1dfad8b50f40f9819"}], "stats": {"total": 85, "additions": 48, "deletions": 37}, "files": [{"sha": "f30e681cb4dd873406daec2f47bdef47f4ba288e", "filename": "src/interpreter.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3ba923701f0b3c7e062c7ffce92fec62bb00de90/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba923701f0b3c7e062c7ffce92fec62bb00de90/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=3ba923701f0b3c7e062c7ffce92fec62bb00de90", "patch": "@@ -1,4 +1,3 @@\n-use rustc::infer;\n use rustc::middle::const_val;\n use rustc::hir::def_id::DefId;\n use rustc::mir::mir_map::MirMap;\n@@ -25,7 +24,7 @@ const TRACE_EXECUTION: bool = true;\n \n struct GlobalEvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// A mapping from NodeIds to Mir, from rustc. Only contains MIR for crate-local items.\n     mir_map: &'a MirMap<'tcx>,\n@@ -124,7 +123,7 @@ enum TerminatorTarget {\n }\n \n impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         GlobalEvalContext {\n             tcx: tcx,\n             mir_map: mir_map,\n@@ -367,7 +366,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                     let last_ty = self.operand_ty(last_arg);\n                                     let last_layout = self.type_layout(last_ty);\n                                     match (&last_ty.sty, last_layout) {\n-                                        (&ty::TyTuple(ref fields),\n+                                        (&ty::TyTuple(fields),\n                                          &Layout::Univariant { ref variant, .. }) => {\n                                             let offsets = iter::once(0)\n                                                 .chain(variant.offset_after_field.iter()\n@@ -1063,7 +1062,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n     fn monomorphize(&self, ty: ty::Ty<'tcx>) -> ty::Ty<'tcx> {\n         let substituted = ty.subst(self.tcx, self.substs());\n-        infer::normalize_associated_type(self.tcx, &substituted)\n+        self.tcx.normalize_associated_type(&substituted)\n     }\n \n     fn type_needs_drop(&self, ty: ty::Ty<'tcx>) -> bool {\n@@ -1080,7 +1079,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn type_is_sized(&self, ty: ty::Ty<'tcx>) -> bool {\n-        ty.is_sized(&self.tcx.empty_parameter_environment(), DUMMY_SP)\n+        ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n     fn type_size(&self, ty: ty::Ty<'tcx>) -> usize {\n@@ -1091,10 +1090,10 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty);\n \n-        let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables, ProjectionMode::Any);\n-\n-        // TODO(solson): Report this error properly.\n-        ty.layout(&infcx).unwrap()\n+        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            // TODO(solson): Report this error properly.\n+            ty.layout(&infcx).unwrap()\n+        })\n     }\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<PrimVal> {\n@@ -1173,30 +1172,31 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl.\n-        let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables, ProjectionMode::Any);\n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-        let obligation = traits::Obligation::new(\n-            traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n-            trait_ref.to_poly_trait_predicate(),\n-        );\n-        let selection = selcx.select(&obligation).unwrap().unwrap();\n-\n-        // Currently, we use a fulfillment context to completely resolve all nested obligations.\n-        // This is because they can inform the inference of the impl's type parameters.\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let vtable = selection.map(|predicate| {\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-        });\n-        infer::drain_fulfillment_cx_or_panic(\n-            DUMMY_SP, &infcx, &mut fulfill_cx, &vtable\n-        )\n+        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+            let obligation = traits::Obligation::new(\n+                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                trait_ref.to_poly_trait_predicate(),\n+            );\n+            let selection = selcx.select(&obligation).unwrap().unwrap();\n+\n+            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n+            // This is because they can inform the inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n+        })\n     }\n \n     /// Trait method, which has to be resolved to an impl method.\n-    pub fn trait_method(&self, def_id: DefId, substs: &'tcx Substs<'tcx>)\n-        -> (DefId, &'tcx Substs<'tcx>)\n-    {\n+    pub fn trait_method(\n+        &self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> (DefId, &'tcx Substs<'tcx>) {\n         let method_item = self.tcx.impl_or_trait_item(def_id);\n         let trait_id = method_item.container().id();\n         let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n@@ -1279,8 +1279,8 @@ pub struct ImplMethod<'tcx> {\n }\n \n /// Locates the applicable definition of a method, given its name.\n-pub fn get_impl_method<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+pub fn get_impl_method<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     impl_def_id: DefId,\n     substs: &'tcx Substs<'tcx>,\n     name: ast::Name,\n@@ -1289,23 +1289,34 @@ pub fn get_impl_method<'tcx>(\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n+            let substs = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+                let substs = traits::translate_substs(&infcx, impl_def_id,\n+                                                      substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n             ImplMethod {\n                 method: node_item.item,\n-                substs: traits::translate_substs(&infcx, impl_def_id, substs, node_item.node),\n+                substs: substs,\n                 is_provided: node_item.node.is_from_trait(),\n             }\n         }\n         None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id);\n+            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n         }\n     }\n }\n \n-pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n+pub fn interpret_start_points<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir_map: &MirMap<'tcx>,\n+) {\n     for (&id, mir) in &mir_map.map {\n         for attr in tcx.map.attrs(id) {\n             use syntax::attr::AttrMetaMethods;"}]}