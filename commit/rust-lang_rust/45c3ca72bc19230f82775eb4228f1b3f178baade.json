{"sha": "45c3ca72bc19230f82775eb4228f1b3f178baade", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YzNjYTcyYmMxOTIzMGY4Mjc3NWViNDIyOGYxYjNmMTc4YmFhZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-04T18:55:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-04T18:55:52Z"}, "message": "auto merge of #8855 : michaelwoerister/rust/captured_vars, r=jdm\n\nThis pull request includes\r\n* support for variables captured in closures*,\r\n* a fix for issue #8512: arguments of non-immediate type (structs, tuples, etc) passed by value can now be accessed correctly in GDB. (I managed to fix this by using `llvm::DIBuilder::createComplexVariable()`. ~~However, I am not sure if this relies on unstable implementation details of LLVM's debug info handling. I'll try to clarify this on the LLVM mailing list~~).\r\n* simplification of the `debuginfo` module's public interface: the caller of functions like `create_local_var_metadata()` doesn't have to know and catch all cases when it mustn't call the function,\r\n* a cleanup refactoring with unified handling for locals, [self] arguments, captured variables, and match bindings,\r\n* and proper span information for self arguments.\r\n\r\n\\* However, see comment at https://github.com/michaelwoerister/rust/blob/1d916ace136a27e354d73d65f488603c65f65bd2/src/test/debug-info/var-captured-in-nested-closure.rs#L62 . This is the same problem as with the fix for issue #8512 above: We are probably using `llvm.dbg.declare` in an unsupported way that works today but might not work after the next LLVM update.\r\n\r\nCheers,\r\nMichael\r\n\r\nFixes #8512\r\nFixes #1341", "tree": {"sha": "a2641a829e3ef6e0791425bcfa98199aafb8946c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2641a829e3ef6e0791425bcfa98199aafb8946c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45c3ca72bc19230f82775eb4228f1b3f178baade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45c3ca72bc19230f82775eb4228f1b3f178baade", "html_url": "https://github.com/rust-lang/rust/commit/45c3ca72bc19230f82775eb4228f1b3f178baade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45c3ca72bc19230f82775eb4228f1b3f178baade/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1f90556f20fb5508c4e859da7abf667a00967b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f90556f20fb5508c4e859da7abf667a00967b4", "html_url": "https://github.com/rust-lang/rust/commit/d1f90556f20fb5508c4e859da7abf667a00967b4"}, {"sha": "5b94ae93f3d00f5afe3f1d957aad76173ed7e705", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b94ae93f3d00f5afe3f1d957aad76173ed7e705", "html_url": "https://github.com/rust-lang/rust/commit/5b94ae93f3d00f5afe3f1d957aad76173ed7e705"}], "stats": {"total": 1128, "additions": 896, "deletions": 232}, "files": [{"sha": "9e81ee5e64ccf96b4b2877c13682a0b474c16bf0", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -2084,6 +2084,31 @@ pub mod llvm {\n                                                         ColumnNo: c_uint)\n                                                         -> ValueRef;\n \n+        #[fast_ffi]\n+        pub fn LLVMDIBuilderCreateOpDeref(IntType: TypeRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub fn LLVMDIBuilderCreateOpPlus(IntType: TypeRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub fn LLVMDIBuilderCreateComplexVariable(Builder: DIBuilderRef,\n+            Tag: c_uint,\n+            Scope: ValueRef,\n+            Name: *c_char,\n+            File: ValueRef,\n+            LineNo: c_uint,\n+            Ty: ValueRef,\n+            AddrOps: *ValueRef,\n+            AddrOpsCount: c_uint,\n+            ArgNo: c_uint)\n+            -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n+\n         pub fn LLVMInitializeX86TargetInfo();\n         pub fn LLVMInitializeX86Target();\n         pub fn LLVMInitializeX86TargetMC();"}, {"sha": "cb672947774a5b9e6216507053fd524b0e56d17a", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -143,7 +143,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::codemap::Span;\n \n-#[deriving(Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum CaptureMode {\n     CapCopy, // Copy the value into the closure.\n     CapMove, // Move the value into the closure."}, {"sha": "39e3e97b48947a7ecb306dc2f3e75bffece05e92", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -2000,19 +2000,20 @@ pub fn store_arg(mut bcx: @mut Block,\n     let arg_ty = node_id_type(bcx, pat.id);\n     add_clean(bcx, llval, arg_ty);\n \n-    match simple_identifier(pat) {\n-        Some(_) => {\n-            // Optimized path for `x: T` case. This just adopts\n-            // `llval` wholesale as the pointer for `x`, avoiding the\n-            // general logic which may copy out of `llval`.\n-            bcx.fcx.llargs.insert(pat.id, llval);\n-        }\n-\n-        None => {\n-            // General path. Copy out the values that are used in the\n-            // pattern.\n-            bcx = bind_irrefutable_pat(bcx, pat, llval, BindArgument);\n-        }\n+    // Debug information (the llvm.dbg.declare intrinsic to be precise) always expects to get an\n+    // alloca, which only is the case on the general path, so lets disable the optimized path when\n+    // debug info is enabled.\n+    let fast_path = !bcx.ccx().sess.opts.extra_debuginfo && simple_identifier(pat).is_some();\n+\n+    if fast_path {\n+        // Optimized path for `x: T` case. This just adopts\n+        // `llval` wholesale as the pointer for `x`, avoiding the\n+        // general logic which may copy out of `llval`.\n+        bcx.fcx.llargs.insert(pat.id, llval);\n+    } else {\n+        // General path. Copy out the values that are used in the\n+        // pattern.\n+        bcx = bind_irrefutable_pat(bcx, pat, llval, BindArgument);\n     }\n \n     return bcx;"}, {"sha": "92aedbdef84bafd771b90f2689f655c3a921a0fe", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -131,20 +131,6 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _x: () }\n }\n \n-fn fcx_has_nonzero_span(fcx: &FunctionContext) -> bool {\n-    match fcx.span {\n-        None => false,\n-        Some(span) => *span.lo != 0 || *span.hi != 0\n-    }\n-}\n-\n-fn span_is_empty(opt_span: &Option<Span>) -> bool {\n-    match *opt_span {\n-        None => true,\n-        Some(span) => *span.lo == 0 && *span.hi == 0\n-    }\n-}\n-\n struct StatRecorder<'self> {\n     ccx: @mut CrateContext,\n     name: &'self str,\n@@ -1132,8 +1118,7 @@ pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n             match d.node {\n                 ast::DeclLocal(ref local) => {\n                     bcx = init_local(bcx, *local);\n-                    if cx.sess().opts.extra_debuginfo\n-                        && fcx_has_nonzero_span(bcx.fcx) {\n+                    if cx.sess().opts.extra_debuginfo {\n                         debuginfo::create_local_var_metadata(bcx, *local);\n                     }\n                 }\n@@ -1633,12 +1618,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n         }\n     };\n     let uses_outptr = type_of::return_uses_outptr(ccx.tcx, substd_output_type);\n-\n-    let debug_context = if id != -1 && ccx.sess.opts.debuginfo && !span_is_empty(&sp) {\n-        Some(debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl))\n-    } else {\n-        None\n-    };\n+    let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n     let fcx = @mut FunctionContext {\n           llfn: llfndecl,\n@@ -1784,7 +1764,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n             fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n             add_clean(bcx, self_val, slf.t);\n \n-            if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n+            if fcx.ccx.sess.opts.extra_debuginfo {\n                 debuginfo::create_self_argument_metadata(bcx, slf.t, self_val);\n             }\n         }\n@@ -1811,7 +1791,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n         };\n         bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n \n-        if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n+        if fcx.ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_argument_metadata(bcx, &args[arg_n]);\n         }\n     }"}, {"sha": "690d7343489e299909091845e09a8cf9cfb47c47", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -17,6 +17,7 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, INIT};\n+use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::type_of::*;\n@@ -307,7 +308,17 @@ pub fn load_environment(fcx: @mut FunctionContext,\n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv);\n \n-    // Populate the upvars from the environment.\n+    // Store the pointer to closure data in an alloca for debug info because that's what the\n+    // llvm.dbg.declare intrinsic expects\n+    let env_pointer_alloca = if fcx.ccx.sess.opts.extra_debuginfo {\n+        let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), cdata_ty), \"__debuginfo_env_ptr\");\n+        Store(bcx, llcdata, alloc);\n+        Some(alloc)\n+    } else {\n+        None\n+    };\n+\n+    // Populate the upvars from the environment\n     let mut i = 0u;\n     for cap_var in cap_vars.iter() {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n@@ -317,6 +328,18 @@ pub fn load_environment(fcx: @mut FunctionContext,\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n         fcx.llupvars.insert(def_id.node, upvarptr);\n+\n+        for &env_pointer_alloca in env_pointer_alloca.iter() {\n+            debuginfo::create_captured_var_metadata(\n+                bcx,\n+                def_id.node,\n+                cdata_ty,\n+                env_pointer_alloca,\n+                i,\n+                sigil,\n+                cap_var.span);\n+        }\n+\n         i += 1u;\n     }\n }"}, {"sha": "d64f221cb9ecd9e7b00b7db57bad679bb7b185f8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -228,7 +228,7 @@ pub struct FunctionContext {\n     ccx: @mut CrateContext,\n \n     // Used and maintained by the debuginfo module.\n-    debug_context: Option<~debuginfo::FunctionDebugContext>\n+    debug_context: debuginfo::FunctionDebugContext,\n }\n \n impl FunctionContext {"}, {"sha": "59159f61f485f1db385bc3eacd45347f53ae31af", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -111,7 +111,7 @@ pub struct CrateContext {\n      // decl_gc_metadata knows whether to link to the module metadata, which\n      // is not emitted by LLVM's GC pass when no functions use GC.\n      uses_gc: bool,\n-     dbg_cx: Option<debuginfo::DebugContext>,\n+     dbg_cx: Option<debuginfo::CrateDebugContext>,\n      do_not_commit_warning_issued: bool\n }\n \n@@ -161,7 +161,7 @@ impl CrateContext {\n \n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n-                Some(debuginfo::DebugContext::new(llmod, name.to_owned()))\n+                Some(debuginfo::CrateDebugContext::new(llmod, name.to_owned()))\n             } else {\n                 None\n             };"}, {"sha": "646f71ec28ad23aa82079a1b062ef74c7a061d4f", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 372, "deletions": 173, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -27,7 +27,7 @@ where possible. This will hopefully ease the adaption of this module to future L\n \n The public API of the module is a set of functions that will insert the correct metadata into the\n LLVM IR when called with the right parameters. The module is thus driven from an outside client with\n-functions like `debuginfo::local_var_metadata(bcx: block, local: &ast::local)`.\n+functions like `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n \n Internally the module will try to reuse already created metadata by utilizing a cache. The way to\n get a shared metadata node when needed is thus to just call the corresponding function in this\n@@ -37,9 +37,8 @@ module:\n \n The function will take care of probing the cache for an existing node for that exact file path.\n \n-All private state used by the module is stored within a DebugContext struct, which in turn is\n-contained in the CrateContext.\n-\n+All private state used by the module is stored within either the CrateDebugContext struct (owned by\n+the CrateContext) or the FunctionDebugContext (owned by the FunctionContext).\n \n This file consists of three conceptual sections:\n 1. The public interface of the module\n@@ -72,7 +71,7 @@ use syntax::codemap::Span;\n use syntax::{ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token::special_idents;\n \n-static DW_LANG_RUST: int = 0x9000;\n+static DW_LANG_RUST: c_uint = 0x9000;\n \n static DW_TAG_auto_variable: c_uint = 0x100;\n static DW_TAG_arg_variable: c_uint = 0x101;\n@@ -92,7 +91,7 @@ static DW_ATE_unsigned_char: c_uint = 0x08;\n //=-------------------------------------------------------------------------------------------------\n \n /// A context object for maintaining all state needed by the debuginfo module.\n-pub struct DebugContext {\n+pub struct CrateDebugContext {\n     priv crate_file: ~str,\n     priv llcontext: ContextRef,\n     priv builder: DIBuilderRef,\n@@ -101,13 +100,13 @@ pub struct DebugContext {\n     priv created_types: HashMap<uint, DIType>,\n }\n \n-impl DebugContext {\n-    pub fn new(llmod: ModuleRef, crate: ~str) -> DebugContext {\n-        debug!(\"DebugContext::new\");\n+impl CrateDebugContext {\n+    pub fn new(llmod: ModuleRef, crate: ~str) -> CrateDebugContext {\n+        debug!(\"CrateDebugContext::new\");\n         let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n-        return DebugContext {\n+        return CrateDebugContext {\n             crate_file: crate,\n             llcontext: llcontext,\n             builder: builder,\n@@ -118,11 +117,64 @@ impl DebugContext {\n     }\n }\n \n-pub struct FunctionDebugContext {\n-    priv scope_map: HashMap<ast::NodeId, DIScope>,\n-    priv fn_metadata: DISubprogram,\n-    priv argument_counter: uint,\n-    priv source_locations_enabled: bool,\n+pub enum FunctionDebugContext {\n+    priv FunctionDebugContext(~FunctionDebugContextData),\n+    priv DebugInfoDisabled,\n+    priv FunctionWithoutDebugInfo,\n+}\n+\n+impl FunctionDebugContext {\n+    fn get_ref<'a>(&'a self, cx: &CrateContext, span: Span) -> &'a FunctionDebugContextData {\n+        match *self {\n+            FunctionDebugContext(~ref data) => data,\n+            DebugInfoDisabled => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        although debug info is disabled!\");\n+            }\n+            FunctionWithoutDebugInfo => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        for function that should be ignored by debug info!\");\n+            }\n+        }\n+    }\n+\n+    fn get_mut_ref<'a>(&'a mut self,\n+                       cx: &CrateContext,\n+                       span: Span)\n+                    -> &'a mut FunctionDebugContextData {\n+        match *self {\n+            FunctionDebugContext(~ref mut data) => data,\n+            DebugInfoDisabled => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        although debug info is disabled!\");\n+            }\n+            FunctionWithoutDebugInfo => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        for function that should be ignored by debug info!\");\n+            }\n+        }\n+    }\n+}\n+\n+struct FunctionDebugContextData {\n+    scope_map: HashMap<ast::NodeId, DIScope>,\n+    fn_metadata: DISubprogram,\n+    argument_counter: uint,\n+    source_locations_enabled: bool,\n+}\n+\n+enum VariableAccess<'self> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: ValueRef },\n+    // The llptr given is an alloca containing the start of some pointer chain leading to the\n+    // variable's content.\n+    IndirectVariable { alloca: ValueRef, address_operations: &'self [ValueRef] }\n+}\n+\n+enum VariableKind {\n+    ArgumentVariable(uint /*index*/),\n+    LocalVariable,\n+    CapturedVariable,\n }\n \n /// Create any deferred debug metadata nodes\n@@ -138,7 +190,12 @@ pub fn finalize(cx: @mut CrateContext) {\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n+pub fn create_local_var_metadata(bcx: @mut Block,\n+                                 local: &ast::Local) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n     let cx = bcx.ccx();\n     let def_map = cx.tcx.def_map;\n \n@@ -147,8 +204,90 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n         let var_ident = ast_util::path_to_ident(path_ref);\n         let var_type = node_id_type(bcx, node_id);\n \n-        declare_local(bcx, var_ident, node_id, var_type, span);\n+        let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+            }\n+        };\n+\n+        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+        declare_local(bcx,\n+                      var_ident,\n+                      var_type,\n+                      scope_metadata,\n+                      DirectVariable { alloca: llptr },\n+                      LocalVariable,\n+                      span);\n+    }\n+}\n+\n+/// Creates debug information for a variable captured in a closure.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_captured_var_metadata(bcx: @mut Block,\n+                                    node_id: ast::NodeId,\n+                                    env_data_type: ty::t,\n+                                    env_pointer: ValueRef,\n+                                    env_index: uint,\n+                                    closure_sigil: ast::Sigil,\n+                                    span: Span) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n     }\n+\n+    let cx = bcx.ccx();\n+\n+    let ast_item = cx.tcx.items.find_copy(&node_id);\n+    let variable_ident = match ast_item {\n+        None => {\n+            cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n+        }\n+        Some(ast_map::node_local(ident)) => ident,\n+        Some(ast_map::node_arg(@ast::Pat { node: ast::PatIdent(_, ref path, _), _ })) => {\n+            ast_util::path_to_ident(path)\n+        }\n+        _ => {\n+            cx.sess.span_bug(span, fmt!(\"debuginfo::create_captured_var_metadata() - \\\n+                Captured var-id refers to unexpected ast_map variant: %?\", ast_item));\n+        }\n+    };\n+\n+    let variable_type = node_id_type(bcx, node_id);\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n+\n+    let llvm_env_data_type = type_of::type_of(cx, env_data_type);\n+    let byte_offset_of_var_in_env = machine::llelement_offset(cx, llvm_env_data_type, env_index);\n+\n+    let address_operations = unsafe {\n+        [llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref()),\n+         llvm::LLVMDIBuilderCreateOpPlus(Type::i64().to_ref()),\n+         C_i64(byte_offset_of_var_in_env as i64),\n+         llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref())]\n+    };\n+\n+    let address_op_count = match closure_sigil {\n+        ast::BorrowedSigil => {\n+            address_operations.len()\n+        }\n+        ast::ManagedSigil | ast::OwnedSigil => {\n+            address_operations.len() - 1\n+        }\n+    };\n+\n+    let variable_access = IndirectVariable {\n+        alloca: env_pointer,\n+        address_operations: address_operations.slice_to(address_op_count)\n+    };\n+\n+    declare_local(bcx,\n+                  variable_ident,\n+                  variable_type,\n+                  scope_metadata,\n+                  variable_access,\n+                  CapturedVariable,\n+                  span);\n }\n \n /// Creates debug information for a local variable introduced in the head of a match-statement arm.\n@@ -159,115 +298,102 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n                                      node_id: ast::NodeId,\n                                      variable_type: ty::t,\n                                      span: Span) {\n-    declare_local(bcx, variable_ident, node_id, variable_type, span);\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n+    let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n+        Some(v) => v,\n+        None => {\n+            bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+        }\n+    };\n+\n+    let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+    declare_local(bcx,\n+                  variable_ident,\n+                  variable_type,\n+                  scope_metadata,\n+                  DirectVariable { alloca: llptr },\n+                  LocalVariable,\n+                  span);\n }\n \n /// Creates debug information for the self argument of a method.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_self_argument_metadata(bcx: @mut Block,\n-                                     variable_type: ty::t,\n+                                     type_of_self: ty::t,\n                                      llptr: ValueRef) {\n-    assert_fcx_has_span(bcx.fcx);\n-    let span = bcx.fcx.span.unwrap();\n-\n-    let cx = bcx.ccx();\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n \n-    let filename = span_start(cx, span).file.name;\n-    let file_metadata = file_metadata(cx, filename);\n+    // Extract the span of the self argument from the method's AST\n+    let fnitem = bcx.ccx().tcx.items.get_copy(&bcx.fcx.id);\n+    let span = match fnitem {\n+        ast_map::node_method(@ast::method { explicit_self: explicit_self, _ }, _, _) => {\n+            explicit_self.span\n+        }\n+        ast_map::node_trait_method(\n+            @ast::provided(\n+                @ast::method {\n+                    explicit_self: explicit_self,\n+                    _\n+                }),\n+            _,\n+            _) => {\n+            explicit_self.span\n+        }\n+        _ => bcx.ccx().sess.bug(\n+                fmt!(\"create_self_argument_metadata: unexpected sort of node: %?\", fnitem))\n+    };\n \n-    let loc = span_start(cx, span);\n-    let type_metadata = type_metadata(cx, variable_type, span);\n-    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(bcx.ccx(), span).fn_metadata;\n \n     let argument_index = {\n-        let counter = &mut bcx.fcx.debug_context.get_mut_ref().argument_counter;\n+        let counter = &mut bcx.fcx.debug_context.get_mut_ref(bcx.ccx(), span).argument_counter;\n         let argument_index = *counter;\n         *counter += 1;\n-        argument_index as c_uint\n+        argument_index\n     };\n \n-    let var_metadata = do cx.sess.str_of(special_idents::self_).to_c_str().with_ref |name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateLocalVariable(\n-                DIB(cx),\n-                DW_TAG_arg_variable,\n-                scope,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                type_metadata,\n-                false,\n-                0,\n-                argument_index)\n-        }\n-    };\n+    let address_operations = &[unsafe { llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref()) }];\n \n-    set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n-    unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-            DIB(cx),\n-            llptr,\n-            var_metadata,\n-            bcx.llbb);\n+    let variable_access = if unsafe { llvm::LLVMIsAAllocaInst(llptr) } != ptr::null() {\n+        DirectVariable { alloca: llptr }\n+    } else {\n+        // This is not stable and may break with future LLVM versions. llptr should really always\n+        // be an alloca. Anything else is not supported and just works by chance.\n+        IndirectVariable { alloca: llptr, address_operations: address_operations }\n+    };\n \n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n-    }\n-    set_debug_location(cx, UnknownLocation);\n+    declare_local(bcx,\n+                  special_idents::self_,\n+                  type_of_self,\n+                  scope_metadata,\n+                  variable_access,\n+                  ArgumentVariable(argument_index),\n+                  span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: @mut Block,\n                                 arg: &ast::arg) {\n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n-\n-    let pattern = arg.pat;\n-    let filename = span_start(cx, pattern.span).file.name;\n-\n-    if fcx.id == -1 ||\n-       fcx.span.is_none() ||\n-       \"<intrinsic>\" == filename {\n+    if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let def_map = cx.tcx.def_map;\n-    let file_metadata = file_metadata(cx, filename);\n-    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;//create_function_metadata(fcx);\n-\n-    do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n+    let fcx = bcx.fcx;\n+    let cx = fcx.ccx;\n \n-        let ty = node_id_type(bcx, node_id);\n-        let type_metadata = type_metadata(cx, ty, codemap::dummy_sp());\n-        let loc = span_start(cx, span);\n-        let ident = ast_util::path_to_ident(path_ref);\n-        let name: &str = cx.sess.str_of(ident);\n-        debug!(\"create_argument_metadata: %s\", name);\n+    let def_map = cx.tcx.def_map;\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n-        let argument_index = {\n-            let counter = &mut fcx.debug_context.get_mut_ref().argument_counter;\n-            let argument_index = *counter;\n-            *counter += 1;\n-            argument_index as c_uint\n-        };\n-\n-        let arg_metadata = do name.with_c_str |name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(\n-                    DIB(cx),\n-                    DW_TAG_arg_variable,\n-                    scope,\n-                    name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    false,\n-                    0,\n-                    argument_index)\n-            }\n-        };\n+    do pat_util::pat_bindings(def_map, arg.pat) |_, node_id, span, path_ref| {\n \n         let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n             Some(v) => v,\n@@ -276,17 +402,28 @@ pub fn create_argument_metadata(bcx: @mut Block,\n             }\n         };\n \n-        set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n-        unsafe {\n-            let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                DIB(cx),\n-                llptr,\n-                arg_metadata,\n-                bcx.llbb);\n-\n-            llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+        if unsafe { llvm::LLVMIsAAllocaInst(llptr) } == ptr::null() {\n+            cx.sess.span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                    Referenced variable location is not an alloca!\");\n         }\n-        set_debug_location(cx, UnknownLocation);\n+\n+        let argument_type = node_id_type(bcx, node_id);\n+        let argument_ident = ast_util::path_to_ident(path_ref);\n+\n+        let argument_index = {\n+            let counter = &mut fcx.debug_context.get_mut_ref(cx, span).argument_counter;\n+            let argument_index = *counter;\n+            *counter += 1;\n+            argument_index\n+        };\n+\n+        declare_local(bcx,\n+                      argument_ident,\n+                      argument_type,\n+                      scope_metadata,\n+                      DirectVariable { alloca: llptr },\n+                      ArgumentVariable(argument_index),\n+                      span);\n     }\n }\n \n@@ -297,15 +434,15 @@ pub fn create_argument_metadata(bcx: @mut Block,\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    let cx: &mut CrateContext = fcx.ccx;\n-\n-    if !cx.sess.opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n+    if fn_should_be_ignored(fcx) {\n         return;\n     }\n \n+    let cx = fcx.ccx;\n+\n     debug!(\"set_source_location: %s\", cx.sess.codemap.span_to_str(span));\n \n-    if fcx.debug_context.get_ref().source_locations_enabled {\n+    if fcx.debug_context.get_ref(cx, span).source_locations_enabled {\n         let loc = span_start(cx, span);\n         let scope = scope_metadata(fcx, node_id, span);\n \n@@ -315,17 +452,35 @@ pub fn set_source_location(fcx: &FunctionContext,\n     }\n }\n \n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude, they are disabled\n+/// when beginning to translate a new function. This functions switches source location emitting on\n+/// and must therefore be called before the first real statement/expression of the function is\n+/// translated.\n pub fn start_emitting_source_locations(fcx: &mut FunctionContext) {\n-    for debug_context in fcx.debug_context.mut_iter() {\n-        debug_context.source_locations_enabled = true;\n+    match fcx.debug_context {\n+        FunctionDebugContext(~ref mut data) => data.source_locations_enabled = true,\n+        _ => { /* safe to ignore */ }\n     }\n }\n \n+/// Creates the function-specific debug context.\n+///\n+/// Returns the FunctionDebugContext for the function which holds state needed for debug info\n+/// creation. The function may also return another variant of the FunctionDebugContext enum which\n+/// indicates why no debuginfo should be created for the function.\n pub fn create_function_debug_context(cx: &mut CrateContext,\n                                      fn_ast_id: ast::NodeId,\n                                      param_substs: Option<@param_substs>,\n-                                     llfn: ValueRef) -> ~FunctionDebugContext {\n-    assert!(fn_ast_id != -1);\n+                                     llfn: ValueRef) -> FunctionDebugContext {\n+    if !cx.sess.opts.debuginfo {\n+        return DebugInfoDisabled;\n+    }\n+\n+    if fn_ast_id == -1 {\n+        return FunctionWithoutDebugInfo;\n+    }\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n@@ -395,9 +550,18 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             _) => {\n             (ident, fn_decl, generics, None, span)\n         }\n+        ast_map::node_variant(*)     |\n+        ast_map::node_struct_ctor(*) => {\n+            return FunctionWithoutDebugInfo;\n+        }\n         _ => cx.sess.bug(fmt!(\"create_function_debug_context: unexpected sort of node: %?\", fnitem))\n     };\n \n+    // This can be the case for functions inlined from another crate\n+    if span == codemap::dummy_sp() {\n+        return FunctionWithoutDebugInfo;\n+    }\n+\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n@@ -438,7 +602,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     };\n \n     // Initialize fn debug context (including scope map)\n-    let mut fn_debug_context = ~FunctionDebugContext {\n+    let mut fn_debug_context = ~FunctionDebugContextData {\n         scope_map: HashMap::new(),\n         fn_metadata: fn_metadata,\n         argument_counter: 1,\n@@ -448,7 +612,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n-    return fn_debug_context;\n+    return FunctionDebugContext(fn_debug_context);\n \n     fn get_function_signature(cx: &mut CrateContext,\n                               fn_ast_id: ast::NodeId,\n@@ -631,18 +795,26 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     do \"\".with_c_str |flags| {\n     do \"\".with_c_str |split_name| {\n         unsafe {\n-            llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n-                DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n+            llvm::LLVMDIBuilderCreateCompileUnit(\n+                dcx.builder,\n+                DW_LANG_RUST,\n+                crate_name,\n+                work_dir,\n+                producer,\n                 cx.sess.opts.optimize != session::No,\n-                flags, 0, split_name);\n+                flags,\n+                0,\n+                split_name);\n         }\n     }}}}};\n }\n \n fn declare_local(bcx: @mut Block,\n                  variable_ident: ast::Ident,\n-                 node_id: ast::NodeId,\n                  variable_type: ty::t,\n+                 scope_metadata: DIScope,\n+                 variable_access: VariableAccess,\n+                 variable_kind: VariableKind,\n                  span: Span) {\n     let cx: &mut CrateContext = bcx.ccx();\n \n@@ -652,41 +824,68 @@ fn declare_local(bcx: @mut Block,\n     let name: &str = cx.sess.str_of(variable_ident);\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let scope = scope_metadata(bcx.fcx, node_id, span);\n \n-    let var_metadata = do name.with_c_str |name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateLocalVariable(\n-                DIB(cx),\n-                DW_TAG_auto_variable,\n-                scope,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                type_metadata,\n-                false,\n-                0,\n-                0)\n-        }\n-    };\n+    let argument_index = match variable_kind {\n+        ArgumentVariable(index) => index,\n+        LocalVariable    |\n+        CapturedVariable => 0\n+    } as c_uint;\n \n-    let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n-        Some(v) => v,\n-        None => {\n-            bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+    let (var_alloca, var_metadata) = do name.with_c_str |name| {\n+        match variable_access {\n+            DirectVariable { alloca } => (\n+                alloca,\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateLocalVariable(\n+                        DIB(cx),\n+                        DW_TAG_auto_variable,\n+                        scope_metadata,\n+                        name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        cx.sess.opts.optimize != session::No,\n+                        0,\n+                        argument_index)\n+                }\n+            ),\n+            IndirectVariable { alloca, address_operations } => (\n+                alloca,\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateComplexVariable(\n+                        DIB(cx),\n+                        DW_TAG_auto_variable,\n+                        scope_metadata,\n+                        name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        vec::raw::to_ptr(address_operations),\n+                        address_operations.len() as c_uint,\n+                        argument_index)\n+                }\n+            )\n         }\n     };\n \n-    set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n+    set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, *loc.col));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n-            llptr,\n+            var_alloca,\n             var_metadata,\n             bcx.llbb);\n \n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n     }\n+\n+    match variable_kind {\n+        ArgumentVariable(_) | CapturedVariable => {\n+            assert!(!bcx.fcx.debug_context.get_ref(cx, span).source_locations_enabled);\n+            set_debug_location(cx, UnknownLocation);\n+        }\n+        _ => { /* fallthrough */ }\n+    }\n }\n \n fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n@@ -720,13 +919,9 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n /// Finds the scope metadata node for the given AST node.\n fn scope_metadata(fcx: &FunctionContext,\n                   node_id: ast::NodeId,\n-                  span: Span) -> DIScope {\n-    if fcx.debug_context.is_none() {\n-        fcx.ccx.sess.span_bug(span, \"debuginfo: FunctionDebugContext should be initialized \\\n-                                     but is not!\");\n-    }\n-\n-    let scope_map = &fcx.debug_context.get_ref().scope_map;\n+                  span: Span)\n+               -> DIScope {\n+    let scope_map = &fcx.debug_context.get_ref(fcx.ccx, span).scope_map;\n \n     match scope_map.find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n@@ -1260,30 +1455,31 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n     }\n }\n \n-fn bare_fn_metadata(cx: &mut CrateContext,\n-                    _fn_ty: ty::t,\n-                    inputs: ~[ty::t],\n-                    output: ty::t,\n-                    span: Span)\n-                 -> DICompositeType {\n-\n-    debug!(\"bare_fn_metadata: %?\", ty::get(_fn_ty));\n-\n+fn subroutine_type_metadata(cx: &mut CrateContext,\n+                            signature: &ty::FnSig,\n+                            span: Span)\n+                         -> DICompositeType {\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let nil_pointer_type_metadata = type_metadata(cx, ty::mk_nil_ptr(cx.tcx), span);\n-    let output_metadata = type_metadata(cx, output, span);\n-    let output_ptr_metadata = pointer_type_metadata(cx, output, output_metadata);\n+    let mut signature_metadata: ~[DIType] = vec::with_capacity(signature.inputs.len() + 1);\n+\n+    // return type\n+    signature_metadata.push(match ty::get(signature.output).sty {\n+        ty::ty_nil => ptr::null(),\n+        _ => type_metadata(cx, signature.output, span)\n+    });\n \n-    let inputs_vals = do inputs.map |arg| { type_metadata(cx, *arg, span) };\n-    let members = ~[output_ptr_metadata, nil_pointer_type_metadata] + inputs_vals;\n+    // regular arguments\n+    for &argument_type in signature.inputs.iter() {\n+        signature_metadata.push(type_metadata(cx, argument_type, span));\n+    }\n \n     return unsafe {\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n             file_metadata,\n-            create_DIArray(DIB(cx), members))\n+            create_DIArray(DIB(cx), signature_metadata))\n     };\n }\n \n@@ -1407,13 +1603,10 @@ fn type_metadata(cx: &mut CrateContext,\n             pointer_type_metadata(cx, t, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n-            let inputs = barefnty.sig.inputs.map(|a| *a);\n-            let output = barefnty.sig.output;\n-            bare_fn_metadata(cx, t, inputs, output, span)\n+            subroutine_type_metadata(cx, &barefnty.sig, span)\n         },\n-        ty::ty_closure(ref _closurety) => {\n-            cx.sess.span_note(span, \"debuginfo for closure NYI\");\n-            unimplemented_type_metadata(cx, t)\n+        ty::ty_closure(ref closurety) => {\n+            subroutine_type_metadata(cx, &closurety.sig, span)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n             cx.sess.span_note(span, \"debuginfo for trait NYI\");\n@@ -1458,7 +1651,6 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n         return;\n     }\n \n-\n     let metadata_node;\n \n     match debug_location {\n@@ -1507,7 +1699,7 @@ fn bytes_to_bits(bytes: uint) -> c_ulonglong {\n }\n \n #[inline]\n-fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n+fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut CrateDebugContext {\n     cx.dbg_cx.get_mut_ref()\n }\n \n@@ -1524,6 +1716,13 @@ fn assert_fcx_has_span(fcx: &FunctionContext) {\n     }\n }\n \n+fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n+    match fcx.debug_context {\n+        FunctionDebugContext(_) => false,\n+        _ => true\n+    }\n+}\n+\n // This procedure builds the *scope map* for a given function, which maps any given ast::NodeId in\n // the function's AST to the correct DIScope metadata instance.\n //"}, {"sha": "be67998ac5d51e0c2143d7ae500f13ecc1088044", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -73,7 +73,7 @@ pub enum ast_node {\n     node_variant(variant, @item, @path),\n     node_expr(@Expr),\n     node_stmt(@Stmt),\n-    node_arg,\n+    node_arg(@Pat),\n     node_local(Ident),\n     node_block(Block),\n     node_struct_ctor(@struct_def, @item, @path),\n@@ -171,7 +171,7 @@ impl Ctx {\n               sp: codemap::Span,\n               id: NodeId) {\n         for a in decl.inputs.iter() {\n-            self.map.insert(a.id, node_arg);\n+            self.map.insert(a.id, node_arg(a.pat));\n         }\n         visit::walk_fn(self, fk, decl, body, sp, id, ());\n     }\n@@ -487,8 +487,8 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n         fmt!(\"stmt %s (id=%?)\",\n              pprust::stmt_to_str(stmt, itr), id)\n       }\n-      Some(&node_arg) => {\n-        fmt!(\"arg (id=%?)\", id)\n+      Some(&node_arg(pat)) => {\n+        fmt!(\"arg %s (id=%?)\", pprust::pat_to_str(pat, itr), id)\n       }\n       Some(&node_local(ident)) => {\n         fmt!(\"local (id=%?, name=%s)\", id, itr.get(ident.name))"}, {"sha": "376adf24e25fde94c6ea49870355104084b7a944", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -724,3 +724,39 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateTemplateTypeParameter(\n       LineNo,\n       ColumnNo));\n }\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateOpDeref(LLVMTypeRef IntTy)\n+{\n+    return LLVMConstInt(IntTy, DIBuilder::OpDeref, true);\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateOpPlus(LLVMTypeRef IntTy)\n+{\n+    return LLVMConstInt(IntTy, DIBuilder::OpPlus, true);\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateComplexVariable(\n+    DIBuilderRef Builder,\n+    unsigned Tag,\n+    LLVMValueRef Scope,\n+    const char *Name,\n+    LLVMValueRef File,\n+    unsigned LineNo,\n+    LLVMValueRef Ty,\n+    LLVMValueRef* AddrOps,\n+    unsigned AddrOpsCount,\n+    unsigned ArgNo)\n+{\n+    llvm::ArrayRef<llvm::Value*> addr_ops((llvm::Value**)AddrOps, AddrOpsCount);\n+\n+    return wrap(Builder->createComplexVariable(\n+        Tag,\n+        unwrapDI<DIDescriptor>(Scope),\n+        Name,\n+        unwrapDI<DIFile>(File),\n+        LineNo,\n+        unwrapDI<DIType>(Ty),\n+        addr_ops,\n+        ArgNo\n+    ));\n+}"}, {"sha": "79cfe8b28519a4dc43193b586da67156ae4cdc54", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -608,6 +608,9 @@ LLVMDIBuilderCreateEnumerator\n LLVMDIBuilderCreateEnumerationType\n LLVMDIBuilderCreateUnionType\n LLVMDIBuilderCreateTemplateTypeParameter\n+LLVMDIBuilderCreateOpDeref\n+LLVMDIBuilderCreateOpPlus\n+LLVMDIBuilderCreateComplexVariable\n LLVMSetUnnamedAddr\n LLVMRustAddPass\n LLVMRustAddAnalysisPasses"}, {"sha": "da9c79a00ed470692dabcb3e9ad5bcd30d6cedf7", "filename": "src/test/debug-info/by-value-non-immediate-argument.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fby-value-non-immediate-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fby-value-non-immediate-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fby-value-non-immediate-argument.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print s\n+// check:$1 = {a = 1, b = 2.5}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = {a = 3, b = 4.5}\n+// debugger:print y\n+// check:$3 = 5\n+// debugger:print z\n+// check:$4 = 6.5\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$5 = {7, 8, 9.5, 10.5}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$6 = {11.5, 12.5, 13, 14}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = {{Case1, x = 0, y = 8970181431921507452}, {Case1, 0, 2088533116, 2088533116}}\n+// debugger:continue\n+\n+#[deriving(Clone)]\n+struct Struct {\n+    a: int,\n+    b: float\n+}\n+\n+#[deriving(Clone)]\n+struct StructStruct {\n+    a: Struct,\n+    b: Struct\n+}\n+\n+fn fun(s: Struct) {\n+    zzz();\n+}\n+\n+fn fun_fun(StructStruct { a: x, b: Struct { a: y, b: z } }: StructStruct) {\n+    zzz();\n+}\n+\n+fn tup(a: (int, uint, float, float)) {\n+    zzz();\n+}\n+\n+struct Newtype(float, float, int, uint);\n+\n+fn new_type(a: Newtype) {\n+    zzz();\n+}\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Enum {\n+    Case1 { x: i64, y: i64 },\n+    Case2 (i64, i32, i32),\n+}\n+\n+fn by_val_enum(x: Enum) {\n+    zzz();\n+}\n+\n+fn main() {\n+    fun(Struct { a: 1, b: 2.5 });\n+    fun_fun(StructStruct { a: Struct { a: 3, b: 4.5 }, b: Struct { a: 5, b: 6.5 } });\n+    tup((7, 8, 9.5, 10.5));\n+    new_type(Newtype(11.5, 12.5, 13, 14));\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    by_val_enum(Case1 { x: 0, y: 8970181431921507452 });\n+}\n+\n+fn zzz() {()}"}, {"sha": "6e381c74a339e963e5d296458cad27a5016a04c3", "filename": "src/test/debug-info/by-value-self-argument-in-trait-impl.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fby-value-self-argument-in-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fby-value-self-argument-in-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fby-value-self-argument-in-trait-impl.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print self\n+// check:$1 = 1111\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print self\n+// check:$2 = {x = 2222, y = 3333}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print self\n+// check:$3 = {4444.5, 5555, 6666, 7777.5}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print self->val\n+// check:$4 = 8888\n+// debugger:continue\n+\n+trait Trait {\n+    fn method(self) -> Self;\n+}\n+\n+impl Trait for int {\n+    fn method(self) -> int {\n+        zzz();\n+        self\n+    }\n+}\n+\n+struct Struct {\n+    x: uint,\n+    y: uint,\n+}\n+\n+impl Trait for Struct {\n+    fn method(self) -> Struct {\n+        zzz();\n+        self\n+    }\n+}\n+\n+impl Trait for (float, int, int, float) {\n+    fn method(self) -> (float, int, int, float) {\n+        zzz();\n+        self\n+    }\n+}\n+\n+impl Trait for @int {\n+    fn method(self) -> @int {\n+        zzz();\n+        self\n+    }\n+}\n+\n+fn main() {\n+    let _ = (1111 as int).method();\n+    let _ = Struct { x: 2222, y: 3333 }.method();\n+    let _ = (4444.5, 5555, 6666, 7777.5).method();\n+    let _ = (@8888).method();\n+}\n+\n+fn zzz() {()}"}, {"sha": "002bfbd2242ae9089f41c316e999873eab4a89cf", "filename": "src/test/debug-info/var-captured-in-managed-closure.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print constant\n+// check:$1 = 1\n+// debugger:print a_struct\n+// check:$2 = {a = -2, b = 3.5, c = 4}\n+// debugger:print *owned\n+// check:$3 = 5\n+// debugger:print managed->val\n+// check:$4 = 6\n+\n+#[allow(unused_variable)];\n+\n+struct Struct {\n+    a: int,\n+    b: float,\n+    c: uint\n+}\n+\n+fn main() {\n+    let constant = 1;\n+\n+    let a_struct = Struct {\n+        a: -2,\n+        b: 3.5,\n+        c: 4\n+    };\n+\n+    let owned = ~5;\n+    let managed = @6;\n+\n+    let closure: @fn() = || {\n+        zzz();\n+        do_something(&constant, &a_struct.a, owned, managed);\n+    };\n+\n+    closure();\n+}\n+\n+fn do_something(_: &int, _:&int, _:&int, _:&int) {\n+}\n+\n+fn zzz() {()}"}, {"sha": "cd20209ddfd0263594940b83715225ae69ad98eb", "filename": "src/test/debug-info/var-captured-in-nested-closure.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print variable\n+// check:$1 = 1\n+// debugger:print constant\n+// check:$2 = 2\n+// debugger:print a_struct\n+// check:$3 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *struct_ref\n+// check:$4 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *owned\n+// check:$5 = 6\n+// debugger:print managed->val\n+// check:$6 = 7\n+// debugger:print closure_local\n+// check:$7 = 8\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print variable\n+// check:$8 = 1\n+// debugger:print constant\n+// check:$9 = 2\n+// debugger:print a_struct\n+// check:$10 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *struct_ref\n+// check:$11 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *owned\n+// check:$12 = 6\n+// debugger:print managed->val\n+// check:$13 = 7\n+// debugger:print closure_local\n+// check:$14 = 8\n+// debugger:continue\n+\n+#[allow(unused_variable)];\n+\n+struct Struct {\n+    a: int,\n+    b: float,\n+    c: uint\n+}\n+\n+fn main() {\n+    let mut variable = 1;\n+    let constant = 2;\n+\n+    let a_struct = Struct {\n+        a: -3,\n+        b: 4.5,\n+        c: 5\n+    };\n+\n+    let struct_ref = &a_struct;\n+    let owned = ~6;\n+    let managed = @7;\n+\n+    let closure = || {\n+        let closure_local = 8;\n+\n+        let nested_closure = || {\n+            zzz();\n+            variable = constant + a_struct.a + struct_ref.a + *owned + *managed + closure_local;\n+        };\n+\n+        zzz();\n+\n+        nested_closure();\n+    };\n+\n+    closure();\n+}\n+\n+fn zzz() {()}"}, {"sha": "01839ea783533b8765d29eb9df358f888c6881ca", "filename": "src/test/debug-info/var-captured-in-sendable-closure.rs", "status": "renamed", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -8,30 +8,47 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Does not work yet, see issue #8512\n-// xfail-test\n-\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n-\n // debugger:finish\n-// debugger:print s\n-// check:$1 = {a = 1, b = 2.5}\n-// debugger:continue\n \n-#[deriving(Clone)]\n+// debugger:print constant\n+// check:$1 = 1\n+// debugger:print a_struct\n+// check:$2 = {a = -2, b = 3.5, c = 4}\n+// debugger:print *owned\n+// check:$3 = 5\n+\n+#[allow(unused_variable)];\n+\n struct Struct {\n     a: int,\n-    b: float\n+    b: float,\n+    c: uint\n }\n \n-fn fun(s: Struct) {\n-    zzz();\n+fn main() {\n+    let constant = 1;\n+\n+    let a_struct = Struct {\n+        a: -2,\n+        b: 3.5,\n+        c: 4\n+    };\n+\n+    let owned = ~5;\n+\n+    let closure: ~fn() = || {\n+        zzz();\n+        do_something(&constant, &a_struct.a, owned);\n+    };\n+\n+    closure();\n }\n \n-fn main() {\n-    fun(Struct { a: 1, b: 2.5 });\n+fn do_something(_: &int, _:&int, _:&int) {\n+\n }\n \n fn zzz() {()}", "previous_filename": "src/test/debug-info/by-value-struct-argument.rs"}, {"sha": "3ce7d6fd89bddbc40cc584019443839c5c1e7afb", "filename": "src/test/debug-info/var-captured-in-stack-closure.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c3ca72bc19230f82775eb4228f1b3f178baade/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs?ref=45c3ca72bc19230f82775eb4228f1b3f178baade", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print variable\n+// check:$1 = 1\n+// debugger:print constant\n+// check:$2 = 2\n+// debugger:print a_struct\n+// check:$3 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *struct_ref\n+// check:$4 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *owned\n+// check:$5 = 6\n+// debugger:print managed->val\n+// check:$6 = 7\n+\n+#[allow(unused_variable)];\n+\n+struct Struct {\n+    a: int,\n+    b: float,\n+    c: uint\n+}\n+\n+fn main() {\n+    let mut variable = 1;\n+    let constant = 2;\n+\n+    let a_struct = Struct {\n+        a: -3,\n+        b: 4.5,\n+        c: 5\n+    };\n+\n+    let struct_ref = &a_struct;\n+    let owned = ~6;\n+    let managed = @7;\n+\n+    let closure = || {\n+        zzz();\n+        variable = constant + a_struct.a + struct_ref.a + *owned + *managed;\n+    };\n+\n+    closure();\n+}\n+\n+fn zzz() {()}"}]}