{"sha": "bc019dfb39bab6979009bb89ecc2d3af460b3c37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMDE5ZGZiMzliYWI2OTc5MDA5YmI4OWVjYzJkM2FmNDYwYjNjMzc=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2016-11-24T00:09:51Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2016-12-02T00:22:04Z"}, "message": "Emit 'dllimport' attribute for dylib foreign items on Windows.", "tree": {"sha": "d00f24808d658366cbfcb0e978e8565c3fe9e767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d00f24808d658366cbfcb0e978e8565c3fe9e767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc019dfb39bab6979009bb89ecc2d3af460b3c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc019dfb39bab6979009bb89ecc2d3af460b3c37", "html_url": "https://github.com/rust-lang/rust/commit/bc019dfb39bab6979009bb89ecc2d3af460b3c37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc019dfb39bab6979009bb89ecc2d3af460b3c37/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "908dba0c9477b7dd022a236cb1514ddfca9369f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/908dba0c9477b7dd022a236cb1514ddfca9369f2", "html_url": "https://github.com/rust-lang/rust/commit/908dba0c9477b7dd022a236cb1514ddfca9369f2"}], "stats": {"total": 266, "additions": 220, "deletions": 46}, "files": [{"sha": "9275c01c8b16f2ab627937d3a475d6f5f453db8e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -131,6 +131,7 @@ pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Symbol,\n     pub cfg: Option<ast::MetaItem>,\n+    pub foreign_items: Vec<DefIndex>,\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -305,7 +306,8 @@ pub trait CrateStore<'tcx> {\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n-    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n+    fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n+    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -462,7 +464,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n-    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n+    fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n+    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -526,9 +529,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum> { vec![] }\n-    fn used_libraries(&self) -> Vec<NativeLibrary> {\n-        vec![]\n-    }\n+    fn used_libraries(&self) -> Vec<NativeLibrary> { vec![] }\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions"}, {"sha": "436b1b3159f8aae7837ec8f0af276ead6040de4d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -52,7 +52,7 @@ pub struct CrateLoader<'a> {\n     pub sess: &'a Session,\n     cstore: &'a CStore,\n     next_crate_num: CrateNum,\n-    foreign_item_map: FxHashMap<String, Vec<ast::NodeId>>,\n+    foreign_item_map: FxHashMap<String, Vec<DefIndex>>,\n     local_crate_name: Symbol,\n }\n \n@@ -310,6 +310,7 @@ impl<'a> CrateLoader<'a> {\n                 rlib: rlib,\n                 rmeta: rmeta,\n             },\n+            dllimport_foreign_items: RefCell::new(None),\n         });\n \n         self.cstore.set_crate_data(cnum, cmeta.clone());\n@@ -640,18 +641,36 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn register_statically_included_foreign_items(&mut self) {\n+    fn get_foreign_items_of_kind(&self, kind: cstore::NativeLibraryKind) -> Vec<DefIndex> {\n+        let mut items = vec![];\n         let libs = self.cstore.get_used_libraries();\n+        for lib in libs.borrow().iter() {\n+            if lib.kind == kind {\n+                items.extend(&lib.foreign_items);\n+            }\n+        }\n         for (foreign_lib, list) in self.foreign_item_map.iter() {\n-            let is_static = libs.borrow().iter().any(|lib| {\n-                lib.name == &**foreign_lib && lib.kind == cstore::NativeStatic\n+            let kind_matches = libs.borrow().iter().any(|lib| {\n+                lib.name == &**foreign_lib && lib.kind == kind\n             });\n-            if is_static {\n-                for id in list {\n-                    self.cstore.add_statically_included_foreign_item(*id);\n-                }\n+            if kind_matches {\n+                items.extend(list)\n             }\n         }\n+        items\n+    }\n+\n+    fn register_statically_included_foreign_items(&mut self) {\n+        for id in self.get_foreign_items_of_kind(cstore::NativeStatic) {\n+            self.cstore.add_statically_included_foreign_item(id);\n+        }\n+    }\n+\n+    fn register_dllimport_foreign_items(&mut self) {\n+        let mut dllimports = self.cstore.dllimport_foreign_items.borrow_mut();\n+        for id in self.get_foreign_items_of_kind(cstore::NativeUnknown) {\n+            dllimports.insert(id);\n+        }\n     }\n \n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n@@ -861,7 +880,8 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n+    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod,\n+                           definitions: &Definitions) {\n         if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n             return;\n         }\n@@ -912,10 +932,14 @@ impl<'a> CrateLoader<'a> {\n             let cfg = cfg.map(|list| {\n                 list[0].meta_item().unwrap().clone()\n             });\n+            let foreign_items = fm.items.iter()\n+                .map(|it| definitions.opt_def_index(it.id).unwrap())\n+                .collect();\n             let lib = NativeLibrary {\n                 name: n,\n                 kind: kind,\n                 cfg: cfg,\n+                foreign_items: foreign_items,\n             };\n             register_native_lib(self.sess, self.cstore, Some(m.span), lib);\n         }\n@@ -928,7 +952,7 @@ impl<'a> CrateLoader<'a> {\n             };\n             let list = self.foreign_item_map.entry(lib_name.to_string())\n                                                     .or_insert(Vec::new());\n-            list.extend(fm.items.iter().map(|it| it.id));\n+            list.extend(fm.items.iter().map(|it| definitions.opt_def_index(it.id).unwrap()));\n         }\n     }\n }\n@@ -947,30 +971,34 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n                 name: Symbol::intern(name),\n                 kind: kind,\n                 cfg: None,\n+                foreign_items: Vec::new(),\n             };\n             register_native_lib(self.sess, self.cstore, None, lib);\n         }\n         self.register_statically_included_foreign_items();\n+        self.register_dllimport_foreign_items();\n     }\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n-            ast::ItemKind::ExternCrate(_) => {}\n-            ast::ItemKind::ForeignMod(ref fm) => return self.process_foreign_mod(item, fm),\n-            _ => return,\n-        }\n-\n-        let info = self.extract_crate_info(item).unwrap();\n-        let (cnum, ..) = self.resolve_crate(\n-            &None, info.ident, info.name, None, item.span, PathKind::Crate, info.dep_kind,\n-        );\n+            ast::ItemKind::ForeignMod(ref fm) => {\n+                self.process_foreign_mod(item, fm, definitions)\n+            },\n+            ast::ItemKind::ExternCrate(_) => {\n+                let info = self.extract_crate_info(item).unwrap();\n+                let (cnum, ..) = self.resolve_crate(\n+                    &None, info.ident, info.name, None, item.span, PathKind::Crate, info.dep_kind,\n+                );\n \n-        let def_id = definitions.opt_local_def_id(item.id).unwrap();\n-        let len = definitions.def_path(def_id.index).data.len();\n+                let def_id = definitions.opt_local_def_id(item.id).unwrap();\n+                let len = definitions.def_path(def_id.index).data.len();\n \n-        let extern_crate =\n-            ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n-        self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n-        self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+                let extern_crate =\n+                    ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n+                self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n+                self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+            }\n+            _ => {}\n+        }\n     }\n }"}, {"sha": "279ef5bfb727614fbab91821a4afbb611d814518", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -15,13 +15,13 @@ use locator;\n use schema;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n@@ -31,7 +31,7 @@ use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos;\n \n-pub use rustc::middle::cstore::{NativeLibrary, LinkagePreference};\n+pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n pub use rustc::middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n \n@@ -84,6 +84,8 @@ pub struct CrateMetadata {\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n+    // Foreign items imported from a dylib (Windows only)\n+    pub dllimport_foreign_items: RefCell<Option<FxHashSet<DefIndex>>>,\n }\n \n pub struct CachedInlinedItem {\n@@ -100,7 +102,8 @@ pub struct CStore {\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n     used_libraries: RefCell<Vec<NativeLibrary>>,\n     used_link_args: RefCell<Vec<String>>,\n-    statically_included_foreign_items: RefCell<NodeSet>,\n+    statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n+    pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n     pub defid_for_inlined_node: RefCell<NodeMap<DefId>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n@@ -114,7 +117,8 @@ impl CStore {\n             extern_mod_crate_map: RefCell::new(FxHashMap()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n-            statically_included_foreign_items: RefCell::new(NodeSet()),\n+            statically_included_foreign_items: RefCell::new(FxHashSet()),\n+            dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n             inlined_item_cache: RefCell::new(FxHashMap()),\n             defid_for_inlined_node: RefCell::new(FxHashMap()),\n@@ -246,12 +250,13 @@ impl CStore {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n-    pub fn add_statically_included_foreign_item(&self, id: ast::NodeId) {\n+    pub fn add_statically_included_foreign_item(&self, id: DefIndex) {\n         self.statically_included_foreign_items.borrow_mut().insert(id);\n     }\n \n-    pub fn do_is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool {\n-        self.statically_included_foreign_items.borrow().contains(&id)\n+    pub fn do_is_statically_included_foreign_item(&self, def_id: DefId) -> bool {\n+        assert!(def_id.krate == LOCAL_CRATE);\n+        self.statically_included_foreign_items.borrow().contains(&def_id.index)\n     }\n \n     pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {"}, {"sha": "e3193d322bf3b4757d0ba3604d552adadd6b6ec1", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n@@ -217,9 +217,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(did.krate).is_foreign_item(did.index)\n     }\n \n-    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n+    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool\n     {\n-        self.do_is_statically_included_foreign_item(id)\n+        self.do_is_statically_included_foreign_item(def_id)\n+    }\n+\n+    fn is_dllimport_foreign_item(&self, def_id: DefId) -> bool {\n+        if def_id.krate == LOCAL_CRATE {\n+            self.dllimport_foreign_items.borrow().contains(&def_id.index)\n+        } else {\n+            self.get_crate_data(def_id.krate).is_dllimport_foreign_item(def_id.index)\n+        }\n     }\n \n     fn dylib_dependency_formats(&self, cnum: CrateNum)"}, {"sha": "f8f80a60c1696cc0b6b67886c987c02fcd31e9f4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -11,13 +11,13 @@\n // Decoding metadata from a single crate's metadata\n \n use astencode::decode_inlined_item;\n-use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n+use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, NativeLibraryKind};\n use index::Index;\n use schema::*;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::{DefKey, DefPathData};\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n@@ -36,6 +36,7 @@ use rustc::mir::Mir;\n use std::borrow::Cow;\n use std::cell::Ref;\n use std::io;\n+use std::iter::FromIterator;\n use std::mem;\n use std::str;\n use std::u32;\n@@ -1087,6 +1088,18 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    pub fn is_dllimport_foreign_item(&self, id: DefIndex) -> bool {\n+        if self.dllimport_foreign_items.borrow().is_none() {\n+            *self.dllimport_foreign_items.borrow_mut() = Some(FxHashSet::from_iter(\n+                self.get_native_libraries().iter()\n+                    .filter(|lib| lib.kind == NativeLibraryKind::NativeUnknown)\n+                    .flat_map(|lib| &lib.foreign_items)\n+                    .map(|id| *id)\n+            ));\n+        }\n+        self.dllimport_foreign_items.borrow().as_ref().unwrap().contains(&id)\n+    }\n+\n     pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n         match self.entry(trait_id).kind {\n             EntryKind::Trait(data) => data.decode(self).has_default_impl,"}, {"sha": "6a9c81dfd5d5a0703a60d99e9c8dc57df5a297d0", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -1498,7 +1498,8 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n         // let it through if it's included statically.\n         match tcx.map.get(id) {\n             hir_map::NodeForeignItem(..) => {\n-                tcx.sess.cstore.is_statically_included_foreign_item(id)\n+                let def_id = tcx.map.local_def_id(id);\n+                tcx.sess.cstore.is_statically_included_foreign_item(def_id)\n             }\n \n             // Only consider nodes that actually have exported symbols."}, {"sha": "9fd61caf6fe53de968559c066deb33134dad5a26", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -629,7 +629,11 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n             }\n         }\n-\n+        if ccx.use_dll_storage_attrs() && ccx.sess().cstore.is_dllimport_foreign_item(def_id) {\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n+            }\n+        }\n         llfn\n     };\n "}, {"sha": "730a4025a59a8ab3b0bd301302039080e0ae762d", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -191,14 +191,25 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                 llvm::set_thread_local(g, true);\n             }\n         }\n-        if ccx.use_dll_storage_attrs() {\n+        if ccx.use_dll_storage_attrs() && !ccx.sess().cstore.is_foreign_item(def_id) {\n+            // This item is external but not foreign, i.e. it originates from an external Rust\n+            // crate. Since we don't know whether this crate will be linked dynamically or\n+            // statically in the final application, we always mark such symbols as 'dllimport'.\n+            // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs to\n+            // make things work.\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n             }\n         }\n         g\n     };\n \n+    if ccx.use_dll_storage_attrs() && ccx.sess().cstore.is_dllimport_foreign_item(def_id) {\n+        // For foreign (native) libs we know the exact storage type to use.\n+        unsafe {\n+            llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+        }\n+    }\n     ccx.instances().borrow_mut().insert(instance, g);\n     ccx.statics().borrow_mut().insert(g, def_id);\n     g"}, {"sha": "06001c6b01426f1a0b18fa66f46019dfbb922b81", "filename": "src/test/codegen/dllimports/auxiliary/dummy.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Ftest%2Fcodegen%2Fdllimports%2Fauxiliary%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Ftest%2Fcodegen%2Fdllimports%2Fauxiliary%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdllimports%2Fauxiliary%2Fdummy.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+#![crate_type = \"staticlib\"]\n+\n+// Since codegen tests don't actually perform linking, this library doesn't need to export\n+// any symbols.  It's here just to satisfy the compiler looking for a .lib file when processing\n+// #[link(...)] attributes in wrapper.rs."}, {"sha": "c03f88092e583bd098c40915dd3b0b293cf2b0bc", "filename": "src/test/codegen/dllimports/auxiliary/wrapper.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Ftest%2Fcodegen%2Fdllimports%2Fauxiliary%2Fwrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Ftest%2Fcodegen%2Fdllimports%2Fauxiliary%2Fwrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdllimports%2Fauxiliary%2Fwrapper.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+#![crate_type = \"rlib\"]\n+\n+#[link(name = \"dummy\", kind=\"dylib\")]\n+extern \"C\" {\n+    pub fn dylib_func2(x: i32) -> i32;\n+    pub static dylib_global2: i32;\n+}\n+\n+#[link(name = \"dummy\", kind=\"static\")]\n+extern \"C\" {\n+    pub fn static_func2(x: i32) -> i32;\n+    pub static static_global2: i32;\n+}"}, {"sha": "140d95fb7be2d54cc2da9ccdda232b925e3fc331", "filename": "src/test/codegen/dllimports/main.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Ftest%2Fcodegen%2Fdllimports%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc019dfb39bab6979009bb89ecc2d3af460b3c37/src%2Ftest%2Fcodegen%2Fdllimports%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdllimports%2Fmain.rs?ref=bc019dfb39bab6979009bb89ecc2d3af460b3c37", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test is for Windows only.\n+// ignore-android\n+// ignore-bitrig\n+// ignore-macos\n+// ignore-dragonfly\n+// ignore-freebsd\n+// ignore-haiku\n+// ignore-ios\n+// ignore-linux\n+// ignore-netbsd\n+// ignore-openbsd\n+// ignore-solaris\n+// ignore-emscripten\n+\n+// aux-build:dummy.rs\n+// aux-build:wrapper.rs\n+\n+extern crate wrapper;\n+\n+// Check that external symbols coming from foreign dylibs are adorned with 'dllimport',\n+// whereas symbols coming from foreign staticlibs are not. (RFC-1717)\n+\n+// CHECK: @dylib_global1 = external dllimport local_unnamed_addr global i32\n+// CHECK: @dylib_global2 = external dllimport local_unnamed_addr global i32\n+// CHECK: @static_global1 = external local_unnamed_addr global i32\n+// CHECK: @static_global2 = external local_unnamed_addr global i32\n+\n+// CHECK: declare dllimport i32 @dylib_func1(i32)\n+// CHECK: declare dllimport i32 @dylib_func2(i32)\n+// CHECK: declare i32 @static_func1(i32)\n+// CHECK: declare i32 @static_func2(i32)\n+\n+#[link(name = \"dummy\", kind=\"dylib\")]\n+extern \"C\" {\n+    pub fn dylib_func1(x: i32) -> i32;\n+    pub static dylib_global1: i32;\n+}\n+\n+#[link(name = \"dummy\", kind=\"static\")]\n+extern \"C\" {\n+    pub fn static_func1(x: i32) -> i32;\n+    pub static static_global1: i32;\n+}\n+\n+fn main() {\n+    unsafe {\n+        dylib_func1(dylib_global1);\n+        wrapper::dylib_func2(wrapper::dylib_global2);\n+\n+        static_func1(static_global1);\n+        wrapper::static_func2(wrapper::static_global2);\n+    }\n+}"}]}