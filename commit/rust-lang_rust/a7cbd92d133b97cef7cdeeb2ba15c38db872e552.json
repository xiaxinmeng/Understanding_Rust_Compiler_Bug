{"sha": "a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3Y2JkOTJkMTMzYjk3Y2VmN2NkZWViMmJhMTVjMzhkYjg3MmU1NTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-01T23:09:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-01T23:09:26Z"}, "message": "Rollup merge of #60385 - nnethercote:earlier-metadata, r=alexcrichton\n\nEmit metadata files earlier\n\nThis will make cargo pipelining much more effective.", "tree": {"sha": "f4d2bfd2d6a9ba8d4c198a27fa30f8e451a69833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4d2bfd2d6a9ba8d4c198a27fa30f8e451a69833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcyicmCRBK7hj4Ov3rIwAAdHIIAFoET+zi9WADuWkavcUh6+YO\nPtjPqD/5Fgq/V8UWLKRqmnjXY++m41Ny7uO3YfFOYm6FUOnAMttHcTVxn0aHUhKC\ntCpq9SzzMGHavcqVhDhPUQCQyUFCQ0vYi5JkDGeLoHzoXj3daU6fxtWHi/oh7zNa\nOA8jEnmXX+bELULoIgAvZZj5Ikaw0ZWeOaXvqFC3HUQCH0sGculWWFxKFnXUqmTp\niiPLCVU5YhkWwocMhumazHJkGBMashjdG6wZgKWKqQVZ1irnVyTJq4RjFPR64IWt\ns4/4wD5LTcuGyvGSO3Fv46ywenv3CyOWUSrIlDc3CnTHwtGN9e9lknUKI5ZUVCg=\n=AFk+\n-----END PGP SIGNATURE-----\n", "payload": "tree f4d2bfd2d6a9ba8d4c198a27fa30f8e451a69833\nparent 01ce87ad148d0f7af616158d3345bde246663d08\nparent 38dffeba21842adc9deb647b30f3a4a00abca133\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556752166 +0200\ncommitter GitHub <noreply@github.com> 1556752166 +0200\n\nRollup merge of #60385 - nnethercote:earlier-metadata, r=alexcrichton\n\nEmit metadata files earlier\n\nThis will make cargo pipelining much more effective.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "html_url": "https://github.com/rust-lang/rust/commit/a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01ce87ad148d0f7af616158d3345bde246663d08", "url": "https://api.github.com/repos/rust-lang/rust/commits/01ce87ad148d0f7af616158d3345bde246663d08", "html_url": "https://github.com/rust-lang/rust/commit/01ce87ad148d0f7af616158d3345bde246663d08"}, {"sha": "38dffeba21842adc9deb647b30f3a4a00abca133", "url": "https://api.github.com/repos/rust-lang/rust/commits/38dffeba21842adc9deb647b30f3a4a00abca133", "html_url": "https://github.com/rust-lang/rust/commit/38dffeba21842adc9deb647b30f3a4a00abca133"}], "stats": {"total": 322, "additions": 166, "deletions": 156}, "files": [{"sha": "fd6a7a5604edf5abda19342842e98c9261ffc6dd", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -2802,6 +2802,7 @@ dependencies = [\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n+ \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -2821,6 +2822,7 @@ dependencies = [\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "9077e89a4020eae8cc5b479ec13d83d6b1d89008", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -28,7 +28,7 @@ use rustc::mir::mono::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::TyCtxt;\n use rustc::middle::exported_symbols;\n-use rustc::session::config::{self, DebugInfo};\n+use rustc::session::config::DebugInfo;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_data_structures::small_c_str::SmallCStr;\n \n@@ -42,47 +42,16 @@ use rustc::hir::CodegenFnAttrs;\n \n use crate::value::Value;\n \n-\n-pub fn write_metadata<'a, 'gcx>(\n+pub fn write_compressed_metadata<'a, 'gcx>(\n     tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    metadata: &EncodedMetadata,\n     llvm_module: &mut ModuleLlvm\n-) -> EncodedMetadata {\n+) {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n \n     let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed\n-    }\n-\n-    let kind = tcx.sess.crate_types.borrow().iter().map(|ty| {\n-        match *ty {\n-            config::CrateType::Executable |\n-            config::CrateType::Staticlib |\n-            config::CrateType::Cdylib => MetadataKind::None,\n-\n-            config::CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            config::CrateType::Dylib |\n-            config::CrateType::ProcMacro => MetadataKind::Compressed,\n-        }\n-    }).max().unwrap_or(MetadataKind::None);\n-\n-    if kind == MetadataKind::None {\n-        return EncodedMetadata::new();\n-    }\n-\n-    let metadata = tcx.encode_metadata();\n-    if kind == MetadataKind::Uncompressed {\n-        return metadata;\n-    }\n-\n-    assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n     DeflateEncoder::new(&mut compressed, Compression::fast())\n         .write_all(&metadata.raw_data).unwrap();\n@@ -107,7 +76,6 @@ pub fn write_metadata<'a, 'gcx>(\n         let directive = CString::new(directive).unwrap();\n         llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return metadata;\n }\n \n pub struct ValueIter<'ll> {"}, {"sha": "09b284052b3c488414f140c4ec9ac96ab66de9d2", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -110,12 +110,13 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         ModuleLlvm::new_metadata(tcx, mod_name)\n     }\n \n-    fn write_metadata<'b, 'gcx>(\n+    fn write_compressed_metadata<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,\n-        metadata: &mut ModuleLlvm\n-    ) -> EncodedMetadata {\n-        base::write_metadata(tcx, metadata)\n+        metadata: &EncodedMetadata,\n+        llvm_module: &mut ModuleLlvm\n+    ) {\n+        base::write_compressed_metadata(tcx, metadata, llvm_module)\n     }\n     fn codegen_allocator<'b, 'gcx>(\n         &self,\n@@ -289,9 +290,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n     fn codegen_crate<'b, 'tcx>(\n         &self,\n         tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+        metadata: EncodedMetadata,\n+        need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>\n     ) -> Box<dyn Any> {\n-        box rustc_codegen_ssa::base::codegen_crate(LlvmCodegenBackend(()), tcx, rx)\n+        box rustc_codegen_ssa::base::codegen_crate(\n+            LlvmCodegenBackend(()), tcx, metadata, need_metadata_module, rx)\n     }\n \n     fn join_codegen_and_link("}, {"sha": "f25891d77ce5353b6b4564ee96beb44537e46ca2", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 44, "deletions": 80, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -7,7 +7,7 @@ use rustc::session::config::{\n };\n use rustc::session::search_paths::PathKind;\n use rustc::middle::dependency_format::Linkage;\n-use rustc::middle::cstore::{LibSource, NativeLibrary, NativeLibraryKind};\n+use rustc::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n use rustc::util::common::{time, time_ext};\n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::fx::FxHashSet;\n@@ -50,9 +50,9 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                                               outputs: &OutputFilenames,\n                                               crate_name: &str,\n                                               target_cpu: &str) {\n+    let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-codegen, as they will error.\n-        let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n         if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n            !output_metadata &&\n            crate_type == config::CrateType::Executable {\n@@ -63,12 +63,43 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n         }\n-        link_binary_output::<B>(sess,\n-                                codegen_results,\n-                                crate_type,\n-                                outputs,\n-                                crate_name,\n-                                target_cpu);\n+\n+        for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+            check_file_is_writeable(obj, sess);\n+        }\n+\n+        let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n+            sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+\n+        if outputs.outputs.should_codegen() {\n+            let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n+            match crate_type {\n+                config::CrateType::Rlib => {\n+                    link_rlib::<B>(sess,\n+                              codegen_results,\n+                              RlibFlavor::Normal,\n+                              &out_filename,\n+                              &tmpdir).build();\n+                }\n+                config::CrateType::Staticlib => {\n+                    link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n+                }\n+                _ => {\n+                    link_natively::<B>(\n+                        sess,\n+                        crate_type,\n+                        &out_filename,\n+                        codegen_results,\n+                        tmpdir.path(),\n+                        target_cpu,\n+                    );\n+                }\n+            }\n+        }\n+\n+        if sess.opts.cg.save_temps {\n+            let _ = tmpdir.into_path();\n+        }\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n@@ -85,7 +116,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             if let Some(ref obj) = metadata_module.object {\n                 remove(sess, obj);\n             }\n-         }\n+        }\n         if let Some(ref allocator_module) = codegen_results.allocator_module {\n             if let Some(ref obj) = allocator_module.object {\n                 remove(sess, obj);\n@@ -97,73 +128,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n     }\n }\n \n-fn link_binary_output<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n-                                                 codegen_results: &CodegenResults,\n-                                                 crate_type: config::CrateType,\n-                                                 outputs: &OutputFilenames,\n-                                                 crate_name: &str,\n-                                                 target_cpu: &str) {\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        check_file_is_writeable(obj, sess);\n-    }\n-\n-    if outputs.outputs.contains_key(&OutputType::Metadata) {\n-        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with a `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n-        match fs::rename(&metadata, &out_filename) {\n-            Ok(_) => {\n-                if sess.opts.debugging_opts.emit_directives {\n-                    sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n-                        format!(\"metadata file written: {}\", out_filename.display()));\n-                }\n-            }\n-            Err(e) => sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n-        }\n-    }\n-\n-    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n-        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-\n-    if outputs.outputs.should_codegen() {\n-        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n-        match crate_type {\n-            config::CrateType::Rlib => {\n-                link_rlib::<B>(sess,\n-                          codegen_results,\n-                          RlibFlavor::Normal,\n-                          &out_filename,\n-                          &tmpdir).build();\n-            }\n-            config::CrateType::Staticlib => {\n-                link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n-            }\n-            _ => {\n-                link_natively::<B>(\n-                    sess,\n-                    crate_type,\n-                    &out_filename,\n-                    codegen_results,\n-                    tmpdir.path(),\n-                    target_cpu,\n-                );\n-            }\n-        }\n-    }\n-\n-    if sess.opts.cg.save_temps {\n-        let _ = tmpdir.into_path();\n-    }\n-}\n-\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n@@ -261,13 +225,13 @@ pub fn each_linked_rlib(sess: &Session,\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-fn emit_metadata<'a>(\n+pub fn emit_metadata<'a>(\n     sess: &'a Session,\n-    codegen_results: &CodegenResults,\n+    metadata: &EncodedMetadata,\n     tmpdir: &TempDir\n ) -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n+    let result = fs::write(&out_filename, &metadata.raw_data);\n \n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n@@ -351,7 +315,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n         RlibFlavor::Normal => {\n             // Instead of putting the metadata in an object file section, rlibs\n             // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n+            ab.add_file(&emit_metadata(sess, &codegen_results.metadata, tmpdir));\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive."}, {"sha": "3cd47dfbb29fb7cf6387cecc36406e59999565b0", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -17,6 +17,7 @@ use crate::{ModuleCodegen, ModuleKind, CachedModuleCodegen};\n \n use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n@@ -25,7 +26,7 @@ use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n-use rustc::session::config::{self, CrateType, EntryFnType, Lto};\n+use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_mir::monomorphize::Instance;\n@@ -530,26 +531,13 @@ pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    metadata: EncodedMetadata,\n+    need_metadata_module: bool,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>\n ) -> OngoingCodegen<B> {\n \n     check_for_rustc_errors_attr(tcx);\n \n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-\n-    // Codegen the metadata.\n-    tcx.sess.profiler(|p| p.start_activity(\"codegen crate metadata\"));\n-\n-    let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                            &[\"crate\"],\n-                                                            Some(\"metadata\")).as_str()\n-                                                                             .to_string();\n-    let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n-    let metadata = time(tcx.sess, \"write metadata\", || {\n-        backend.write_metadata(tcx, &mut metadata_llvm_module)\n-    });\n-    tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n-\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen ||\n        !tcx.sess.opts.output_types.should_codegen() {\n@@ -569,6 +557,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         return ongoing_codegen;\n     }\n \n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+\n     // Run the monomorphization collector and partition the collected items into\n     // codegen units.\n     let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n@@ -632,17 +622,21 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n     }\n \n-    let needs_metadata_module = tcx.sess.crate_types.borrow().iter().any(|ct| {\n-        match *ct {\n-            CrateType::Dylib |\n-            CrateType::ProcMacro => true,\n-            CrateType::Executable |\n-            CrateType::Rlib |\n-            CrateType::Staticlib |\n-            CrateType::Cdylib => false,\n-        }\n-    });\n-    if needs_metadata_module {\n+    if need_metadata_module {\n+        // Codegen the encoded metadata.\n+        tcx.sess.profiler(|p| p.start_activity(\"codegen crate metadata\"));\n+\n+        let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                                &[\"crate\"],\n+                                                                Some(\"metadata\")).as_str()\n+                                                                                 .to_string();\n+        let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n+        time(tcx.sess, \"write compressed metadata\", || {\n+            backend.write_compressed_metadata(tcx, &ongoing_codegen.metadata,\n+                                              &mut metadata_llvm_module);\n+        });\n+        tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n+\n         let metadata_module = ModuleCodegen {\n             name: metadata_cgu_name,\n             module_llvm: metadata_llvm_module,"}, {"sha": "530eba516a6c0c4a00094498a47424482809700d", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -33,11 +33,12 @@ impl<'tcx, T> Backend<'tcx> for T where\n \n pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send {\n     fn new_metadata(&self, sess: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self::Module;\n-    fn write_metadata<'b, 'gcx>(\n+    fn write_compressed_metadata<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,\n-        metadata: &mut Self::Module,\n-    ) -> EncodedMetadata;\n+        metadata: &EncodedMetadata,\n+        llvm_module: &mut Self::Module,\n+    );\n     fn codegen_allocator<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,"}, {"sha": "191c6605b43ff4022e636c1fa6fe758ebcf15d35", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -18,7 +18,7 @@ use rustc::util::common::ErrorReported;\n use rustc::session::config::{OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::dep_graph::DepGraph;\n \n pub use rustc_data_structures::sync::MetadataRef;\n@@ -37,6 +37,8 @@ pub trait CodegenBackend {\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        metadata: EncodedMetadata,\n+        need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>\n     ) -> Box<dyn Any>;\n "}, {"sha": "bcaa4216109aa7c839301286d4bae000ba6b7e2e", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -24,6 +24,7 @@ rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n@@ -34,3 +35,4 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n+tempfile = \"3.0.5\""}, {"sha": "6d3115c621343ad1eb131caa65d70a5e61fb26c1", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -16,11 +16,13 @@ use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n use rustc::util::profiling::ProfileCategory;\n use rustc::session::{CompileResult, CrateDisambiguator, Session};\n-use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n+use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n+use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -50,6 +52,7 @@ use syntax_pos::{FileName, hygiene};\n use syntax_ext;\n \n use serialize::json;\n+use tempfile::Builder as TempFileBuilder;\n \n use std::any::Any;\n use std::env;\n@@ -999,6 +1002,68 @@ fn analysis<'tcx>(\n     Ok(())\n }\n \n+fn encode_and_write_metadata<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    outputs: &OutputFilenames,\n+) -> (middle::cstore::EncodedMetadata, bool) {\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    enum MetadataKind {\n+        None,\n+        Uncompressed,\n+        Compressed\n+    }\n+\n+    let metadata_kind = tcx.sess.crate_types.borrow().iter().map(|ty| {\n+        match *ty {\n+            CrateType::Executable |\n+            CrateType::Staticlib |\n+            CrateType::Cdylib => MetadataKind::None,\n+\n+            CrateType::Rlib => MetadataKind::Uncompressed,\n+\n+            CrateType::Dylib |\n+            CrateType::ProcMacro => MetadataKind::Compressed,\n+        }\n+    }).max().unwrap_or(MetadataKind::None);\n+\n+    let metadata = match metadata_kind {\n+        MetadataKind::None => middle::cstore::EncodedMetadata::new(),\n+        MetadataKind::Uncompressed |\n+        MetadataKind::Compressed => tcx.encode_metadata(),\n+    };\n+\n+    let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n+    if need_metadata_file {\n+        let crate_name = &tcx.crate_name(LOCAL_CRATE).as_str();\n+        let out_filename = filename_for_metadata(tcx.sess, crate_name, outputs);\n+        // To avoid races with another rustc process scanning the output directory,\n+        // we need to write the file somewhere else and atomically move it to its\n+        // final destination, with an `fs::rename` call. In order for the rename to\n+        // always succeed, the temporary file needs to be on the same filesystem,\n+        // which is why we create it inside the output directory specifically.\n+        let metadata_tmpdir = TempFileBuilder::new()\n+            .prefix(\"rmeta\")\n+            .tempdir_in(out_filename.parent().unwrap())\n+            .unwrap_or_else(|err| {\n+                tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err))\n+            });\n+        let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n+        match std::fs::rename(&metadata_filename, &out_filename) {\n+            Ok(_) => {\n+                if tcx.sess.opts.debugging_opts.emit_directives {\n+                    tcx.sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n+                        format!(\"metadata file written: {}\", out_filename.display()));\n+                }\n+            }\n+            Err(e) => tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n+        }\n+    }\n+\n+    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n+\n+    (metadata, need_metadata_module)\n+}\n+\n /// Runs the codegen backend, after which the AST and analysis can\n /// be discarded.\n pub fn start_codegen<'tcx>(\n@@ -1013,11 +1078,17 @@ pub fn start_codegen<'tcx>(\n     }\n \n     time(tcx.sess, \"resolving dependency formats\", || {\n-        ::rustc::middle::dependency_format::calculate(tcx)\n+        middle::dependency_format::calculate(tcx)\n+    });\n+\n+    let (metadata, need_metadata_module) = time(tcx.sess, \"metadata encoding and writing\", || {\n+        encode_and_write_metadata(tcx, outputs)\n     });\n \n     tcx.sess.profiler(|p| p.start_activity(\"codegen crate\"));\n-    let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n+    let codegen = time(tcx.sess, \"codegen\", move || {\n+        codegen_backend.codegen_crate(tcx, metadata, need_metadata_module, rx)\n+    });\n     tcx.sess.profiler(|p| p.end_activity(\"codegen crate\"));\n \n     if log_enabled!(::log::Level::Info) {"}, {"sha": "4e43aa96e1d853895e90754a9cd747a36fb83d12", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7cbd92d133b97cef7cdeeb2ba15c38db872e552/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=a7cbd92d133b97cef7cdeeb2ba15c38db872e552", "patch": "@@ -15,7 +15,7 @@ use rustc::session::Session;\n use rustc::session::config::OutputFilenames;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::dep_graph::DepGraph;\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -61,6 +61,8 @@ impl CodegenBackend for TheBackend {\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _metadata: EncodedMetadata,\n+        _need_metadata_module: bool,\n         _rx: mpsc::Receiver<Box<Any + Send>>\n     ) -> Box<Any> {\n         use rustc::hir::def_id::LOCAL_CRATE;"}]}