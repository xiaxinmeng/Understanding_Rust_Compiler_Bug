{"sha": "b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NWNkOGNjN2M1NWE1MDk0MWNjNTVjZDM5OWY2ZDVhZWJkZjc3Zjg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-02-06T15:47:38Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-02-08T11:16:30Z"}, "message": "Fleshed out the test a lot more.", "tree": {"sha": "62f8d3687cee17e4bc1fc8b2a417b7839c213ba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62f8d3687cee17e4bc1fc8b2a417b7839c213ba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8", "html_url": "https://github.com/rust-lang/rust/commit/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81b93fa0b364e106f13c5810941857426a6c6756", "url": "https://api.github.com/repos/rust-lang/rust/commits/81b93fa0b364e106f13c5810941857426a6c6756", "html_url": "https://github.com/rust-lang/rust/commit/81b93fa0b364e106f13c5810941857426a6c6756"}], "stats": {"total": 239, "additions": 230, "deletions": 9}, "files": [{"sha": "795d45a776db595489dc8d76b6d26b5a6ba83beb", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 230, "deletions": 9, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8", "patch": "@@ -13,27 +13,248 @@\n //[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n //[g2p]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll -Z two-phase-beyond-autoref\n \n-#![feature(rustc_attrs)]\n-\n // This is a test checking that when we limit two-phase borrows to\n // method receivers, we do not let other kinds of auto-ref to leak\n // through.\n //\n // The g2p revision illustrates the \"undesirable\" behavior you would\n // otherwise observe without limiting the phasing to autoref on method\n-// receivers (namely, that the test would pass).\n+// receivers (namely, in many cases demonstrated below, the error\n+// would not arise).\n+\n+// (If we revise the compiler or this test so that the g2p revision\n+// passes, turn the `rustc_attrs` feature back on and tag the `fn\n+// main` with `#[rustc_error]` so that this remains a valid\n+// compile-fail test.)\n+//\n+// #![feature(rustc_attrs)]\n+\n+use std::ops::{Index, IndexMut};\n+use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+use std::ops::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n \n-fn bar(x: &mut u32) {\n+// This is case outlined by Niko that we want to ensure we reject\n+// (at least initially).\n+\n+fn foo(x: &mut u32, y: u32) {\n+    *x += y;\n+}\n+\n+fn deref_coercion(x: &mut u32) {\n     foo(x, *x);\n     //[lxl]~^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n     //[nll]~^^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n }\n \n-fn foo(x: &mut u32, y: u32) {\n-    *x += y;\n+// While adding a flag to adjustments (indicating whether they\n+// should support two-phase borrows, here are the cases I\n+// encountered:\n+//\n+// - [x] Resolving overloaded_call_traits (call, call_mut, call_once)\n+// - [x] deref_coercion (shown above)\n+// - [x] coerce_unsized e.g. `&[T; n]`, `&mut [T; n] -> &[T]`,\n+//                      `&mut [T; n] -> &mut [T]`, `&Concrete -> &Trait`\n+// - [x] Method Call Receivers (the case we want to support!)\n+// - [x] ExprIndex and ExprUnary Deref; only need to handle coerce_index_op\n+// - [x] overloaded_binops\n+\n+fn overloaded_call_traits() {\n+    // Regarding overloaded call traits, note that there is no\n+    // scenario where adding two-phase borrows should \"fix\" these\n+    // cases, because either we will resolve both invocations to\n+    // `call_mut` (in which case the inner call requires a mutable\n+    // borrow which will conflict with the outer reservation), or we\n+    // will resolve both to `call` (which will just work, regardless\n+    // of two-phase borrow support), or we will resolve both to\n+    // `call_once` (in which case the inner call requires moving the\n+    // receiver, invalidating the outer call).\n+\n+    fn twice_ten_sm<F: FnMut(i32) -> i32>(f: &mut F) {\n+        f(f(10));\n+        //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+    }\n+    fn twice_ten_si<F: Fn(i32) -> i32>(f: &mut F) {\n+        f(f(10));\n+    }\n+    fn twice_ten_so<F: FnOnce(i32) -> i32>(f: Box<F>) {\n+        f(f(10));\n+        //[lxl]~^   ERROR use of moved value: `*f`\n+        //[nll]~^^  ERROR use of moved value: `*f`\n+        //[g2p]~^^^ ERROR use of moved value: `*f`\n+    }\n+\n+    fn twice_ten_om(f: &mut FnMut(i32) -> i32) {\n+        f(f(10));\n+        //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+    }\n+    fn twice_ten_oi(f: &mut Fn(i32) -> i32) {\n+        f(f(10));\n+    }\n+    fn twice_ten_oo(f: Box<FnOnce(i32) -> i32>) {\n+        f(f(10));\n+        //[lxl]~^             ERROR cannot move a value of type\n+        //[lxl]~^^            ERROR cannot move a value of type\n+        //[lxl]~^^^           ERROR use of moved value: `*f`\n+        //[nll]~^^^^          ERROR cannot move a value of type\n+        //[nll]~^^^^^         ERROR cannot move a value of type\n+        //[nll]~^^^^^^        ERROR cannot move a value of type\n+        //[nll]~^^^^^^^       ERROR cannot move a value of type\n+        //[nll]~^^^^^^^^      ERROR use of moved value: `*f`\n+        //[g2p]~^^^^^^^^^     ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^    ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^^   ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^^^  ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^^^^ ERROR use of moved value: `*f`\n+    }\n+\n+    twice_ten_sm(&mut |x| x + 1);\n+    twice_ten_si(&mut |x| x + 1);\n+    twice_ten_so(Box::new(|x| x + 1));\n+    twice_ten_om(&mut |x| x + 1);\n+    twice_ten_oi(&mut |x| x + 1);\n+    twice_ten_oo(Box::new(|x| x + 1));\n+}\n+\n+trait TwoMethods {\n+    fn m(&mut self, x: i32) -> i32 { x + 1 }\n+    fn i(&self, x: i32) -> i32 { x + 1 }\n+}\n+\n+struct T;\n+\n+impl TwoMethods for T { }\n+\n+struct S;\n+\n+impl S {\n+    fn m(&mut self, x: i32) -> i32 { x + 1 }\n+    fn i(&self, x: i32) -> i32 { x + 1 }\n+}\n+\n+impl TwoMethods for [i32; 3] { }\n+\n+fn double_access<X: Copy>(m: &mut [X], s: &[X]) {\n+    m[0] = s[1];\n }\n \n-#[rustc_error]\n-fn main() { //[g2p]~ ERROR compilation successful\n-    bar(&mut 5);\n+fn coerce_unsized() {\n+    let mut a = [1, 2, 3];\n+\n+    // This is not okay.\n+    double_access(&mut a, &a);\n+    //[lxl]~^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[g2p]~^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+\n+    // But this is okay.\n+    a.m(a.i(10));\n+}\n+\n+struct I(i32);\n+\n+impl Index<i32> for I {\n+    type Output = i32;\n+    fn index(&self, _: i32) -> &i32 {\n+        &self.0\n+    }\n+}\n+\n+impl IndexMut<i32> for I {\n+    fn index_mut(&mut self, _: i32) -> &mut i32 {\n+        &mut self.0\n+    }\n+}\n+\n+fn coerce_index_op() {\n+    let mut i = I(10);\n+    i[i[3]] = 4;\n+    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+\n+    i[3] = i[4];\n+\n+    i[i[3]] = i[4];\n+    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+}\n+\n+struct A(i32);\n+\n+macro_rules! trivial_binop {\n+    ($Trait:ident, $m:ident) => {\n+        impl $Trait<i32> for A { fn $m(&mut self, rhs: i32) { self.0 = rhs; } }\n+    }\n+}\n+\n+trivial_binop!(AddAssign, add_assign);\n+trivial_binop!(SubAssign, sub_assign);\n+trivial_binop!(MulAssign, mul_assign);\n+trivial_binop!(DivAssign, div_assign);\n+trivial_binop!(RemAssign, rem_assign);\n+trivial_binop!(BitAndAssign, bitand_assign);\n+trivial_binop!(BitOrAssign, bitor_assign);\n+trivial_binop!(BitXorAssign, bitxor_assign);\n+trivial_binop!(ShlAssign, shl_assign);\n+trivial_binop!(ShrAssign, shr_assign);\n+\n+fn overloaded_binops() {\n+    let mut a = A(10);\n+    a += a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a -= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a *= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a /= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a &= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a |= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a ^= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a <<= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a >>= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+}\n+\n+fn main() {\n+\n+    // As a reminder, this is the basic case we want to ensure we handle.\n+    let mut v = vec![1, 2, 3];\n+    v.push(v.len());\n+\n+    // (as a rule, pnkfelix does not like to write tests with dead code.)\n+\n+    deref_coercion(&mut 5);\n+    overloaded_call_traits();\n+\n+\n+    let mut s = S;\n+    s.m(s.i(10));\n+\n+    let mut t = T;\n+    t.m(t.i(10));\n+\n+    coerce_unsized();\n+    coerce_index_op();\n+    overloaded_binops();\n }"}]}