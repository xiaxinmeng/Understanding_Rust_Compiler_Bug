{"sha": "d2482fd7631d05b1888e3beac0df3f25d33867b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNDgyZmQ3NjMxZDA1YjE4ODhlM2JlYWMwZGYzZjI1ZDMzODY3Yjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-13T18:59:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-13T18:59:17Z"}, "message": "use find not echo; this also brings fuzzer under the iron fist of tidy.py!", "tree": {"sha": "b153782efdd9ca49245147d0ddaf3e5bc6c50a1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b153782efdd9ca49245147d0ddaf3e5bc6c50a1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2482fd7631d05b1888e3beac0df3f25d33867b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2482fd7631d05b1888e3beac0df3f25d33867b8", "html_url": "https://github.com/rust-lang/rust/commit/d2482fd7631d05b1888e3beac0df3f25d33867b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2482fd7631d05b1888e3beac0df3f25d33867b8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27f1c2b74299a2a26d89d4986620d38fc31798e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/27f1c2b74299a2a26d89d4986620d38fc31798e3", "html_url": "https://github.com/rust-lang/rust/commit/27f1c2b74299a2a26d89d4986620d38fc31798e3"}], "stats": {"total": 170, "additions": 94, "deletions": 76}, "files": [{"sha": "49dc7d1d9eb32ab22c9753b9a23fa636c99a793e", "filename": "mk/tests.mk", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d2482fd7631d05b1888e3beac0df3f25d33867b8/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d2482fd7631d05b1888e3beac0df3f25d33867b8/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=d2482fd7631d05b1888e3beac0df3f25d33867b8", "patch": "@@ -2,11 +2,6 @@\n # Testing variables\n ######################################################################\n \n-SOME_TEST_INPUTS = $(wildcard $(S)src/test/*/*.rs)\n-\n-SOME_MOAR_TEST_INPUTS = $(wildcard $(S)src/test/*/*/*.rs \\\n-                                   $(S)src/test/*/*.rc)\n-\n RPASS_RC := $(wildcard $(S)src/test/run-pass/*.rc)\n RPASS_RS := $(wildcard $(S)src/test/run-pass/*.rs)\n RFAIL_RC := $(wildcard $(S)src/test/run-fail/*.rc)\n@@ -124,34 +119,13 @@ ALL_HS := $(filter-out $(S)src/rt/vg/valgrind.h \\\n \n tidy:\n \t\t@$(call E, check: formatting)\n-\t\t$(Q)echo \\\n-              $(wildcard $(S)src/etc/*.py)  \\\n-              $(COMPILER_CRATE) \\\n-              $(COMPILER_INPUTS) \\\n-              $(LIBRUSTSYNTAX_CRATE) \\\n-              $(LIBRUSTSYNTAX_INPUTS) \\\n-              $(CORELIB_CRATE) \\\n-              $(CORELIB_INPUTS) \\\n+\t\t$(Q)find $(S)src -name '*.r[sc]' \\\n \t\t| xargs -n 10 python $(S)src/etc/tidy.py\n-\t\t$(Q)echo \\\n-              $(STDLIB_CRATE) \\\n-              $(STDLIB_INPUTS) \\\n-              $(COMPILETEST_CRATE) \\\n-              $(COMPILETEST_INPUTS) \\\n-              $(CARGO_CRATE) \\\n-              $(CARGO_INPUTS) \\\n-              $(RUSTDOC_CRATE) \\\n-              $(RUSTDOC_INPUTS) \\\n+\t\t$(Q)find $(S)src/etc -name '*.py' \\\n \t\t| xargs -n 10 python $(S)src/etc/tidy.py\n-\t\t$(Q)echo \\\n-              $(SOME_TEST_INPUTS) \\\n-\t  \t| xargs -n 10 python $(S)src/etc/tidy.py\n-\t\t$(Q)echo \\\n-              $(SOME_MOAR_TEST_INPUTS) \\\n+\t\t$(Q)echo $(ALL_CS) \\\n \t  \t| xargs -n 10 python $(S)src/etc/tidy.py\n-\t\t$(Q)echo \\\n-              $(ALL_CS) \\\n-              $(ALL_HS) \\\n+\t\t$(Q)echo $(ALL_HS) \\\n \t  \t| xargs -n 10 python $(S)src/etc/tidy.py\n \n endif"}, {"sha": "3f2bf940aa1d43856ceee42362e3e1ef8c20b1d3", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=d2482fd7631d05b1888e3beac0df3f25d33867b8", "patch": "@@ -1,7 +1,8 @@\n use std;\n import vec;\n \n-fn vec_equal<T>(v: [T], u: [T], element_equality_test: fn@(&&T, &&T) -> bool) ->\n+fn vec_equal<T>(v: [T], u: [T],\n+                element_equality_test: fn@(&&T, &&T) -> bool) ->\n    bool {\n     let Lv = vec::len(v);\n     if Lv != vec::len(u) { ret false; }"}, {"sha": "e604d4a2357212f2535bf5b74ce2a0e76fceb57b", "filename": "src/fuzzer/cycles.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fcycles.rs?ref=d2482fd7631d05b1888e3beac0df3f25d33867b8", "patch": "@@ -3,10 +3,14 @@ import std::rand;\n import uint::range;\n \n // random uint less than n\n-fn under(r : rand::rng, n : uint) -> uint { assert n != 0u; r.next() as uint % n }\n+fn under(r : rand::rng, n : uint) -> uint {\n+    assert n != 0u; r.next() as uint % n\n+}\n \n // random choice from a vec\n-fn choice<T: copy>(r : rand::rng, v : [const T]) -> T { assert vec::len(v) != 0u; v[under(r, vec::len(v))] }\n+fn choice<T: copy>(r : rand::rng, v : [const T]) -> T {\n+    assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n+}\n \n // k in n chance of being true\n fn likelihood(r : rand::rng, k : uint, n : uint) -> bool { under(r, n) < k }\n@@ -68,7 +72,8 @@ fn test_cycles(r : rand::rng, k: uint, n: uint)\n         if (likelihood(r, k, n)) { v[i].c = @p(choice(r, v)); }\n \n         if (likelihood(r, k, n)) { v[i].f = bind nopP(choice(r, v)); }\n-        //if (false)               { v[i].g = bind (fn~(_x: @pointy) { })(choice(r, v)); }\n+        //if (false)               { v[i].g = bind (fn~(_x: @pointy) { })(\n+        // choice(r, v)); }\n           // https://github.com/mozilla/rust/issues/1899\n \n         if (likelihood(r, k, n)) { v[i].m = [p(choice(r, v))]; }"}, {"sha": "0d30f9c89a0afd9b497f15845cd72712c9eb0809", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 62, "deletions": 32, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=d2482fd7631d05b1888e3beac0df3f25d33867b8", "patch": "@@ -44,7 +44,8 @@ fn common_exprs() -> [ast::expr] {\n     [dse(ast::expr_break),\n      dse(ast::expr_cont),\n      dse(ast::expr_fail(option::none)),\n-     dse(ast::expr_fail(option::some(@dse(ast::expr_lit(@dsl(ast::lit_str(\"boo\"))))))),\n+     dse(ast::expr_fail(option::some(\n+         @dse(ast::expr_lit(@dsl(ast::lit_str(\"boo\"))))))),\n      dse(ast::expr_ret(option::none)),\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n@@ -64,9 +65,9 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     alt tm {\n       tm_converge {\n         alt e.node {\n-          // If the fuzzer moves a block-ending-in-semicolon into callee position,\n-          // the pretty-printer can't preserve this even by parenthesizing!!\n-          // See email to marijn.\n+          // If the fuzzer moves a block-ending-in-semicolon into callee\n+          // position, the pretty-printer can't preserve this even by\n+          // parenthesizing!!  See email to marijn.\n           ast::expr_if(_, _, _) { false }\n           ast::expr_if_check(_, _, _) { false }\n           ast::expr_block(_) { false }\n@@ -166,18 +167,21 @@ fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n     alt t {\n       ast::ty_infer { false } // always implicit, always top level\n-      ast::ty_bot { false }   // in source, can only appear as the out type of a function\n+      ast::ty_bot { false }   // in source, can only appear\n+                              // as the out type of a function\n       ast::ty_mac(_) { false }\n       _ { true }\n     }\n }\n \n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr, tm: test_mode) ->\n+fn replace_expr_in_crate(crate: ast::crate, i: uint,\n+                         newexpr: ast::expr, tm: test_mode) ->\n    ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n-                     original: ast::expr_, fld: fold::ast_fold, tm_: test_mode) ->\n+                     original: ast::expr_, fld: fold::ast_fold,\n+                     tm_: test_mode) ->\n        ast::expr_ {\n         *j_ += 1u;\n         if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n@@ -187,20 +191,22 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr, tm: tes\n         }\n     }\n     let afp =\n-        {fold_expr: fold::wrap(bind fold_expr_rep(j, i, newexpr.node, _, _, tm))\n-            with *fold::default_ast_fold()};\n+        {fold_expr: fold::wrap(bind fold_expr_rep(j, i,\n+                                                  newexpr.node, _, _, tm))\n+         with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2\n }\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty, tm: test_mode) ->\n-   ast::crate {\n+fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty,\n+                       tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n-                     original: ast::ty_, fld: fold::ast_fold, tm_: test_mode) ->\n+                   original: ast::ty_, fld: fold::ast_fold,\n+                   tm_: test_mode) ->\n        ast::ty_ {\n         *j_ += 1u;\n         if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n@@ -233,8 +239,11 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n                                   bind safe_to_use_expr(_, cx.mode));\n-    check_variants_T(crate, codemap, filename, \"expr\", extra_exprs + stolen.exprs, pprust::expr_to_str, replace_expr_in_crate, cx);\n-    check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate, cx);\n+    check_variants_T(crate, codemap, filename, \"expr\",\n+                     extra_exprs + stolen.exprs, pprust::expr_to_str,\n+                     replace_expr_in_crate, cx);\n+    check_variants_T(crate, codemap, filename, \"ty\", stolen.tys,\n+                     pprust::ty_to_str, replace_ty_in_crate, cx);\n }\n \n fn check_variants_T<T: copy>(\n@@ -247,7 +256,8 @@ fn check_variants_T<T: copy>(\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n   ) {\n-    #error(\"%s contains %u %s objects\", filename, vec::len(things), thing_label);\n+    #error(\"%s contains %u %s objects\", filename,\n+           vec::len(things), thing_label);\n \n     let L = vec::len(things);\n \n@@ -257,8 +267,8 @@ fn check_variants_T<T: copy>(\n             under(uint::min(L, 30u)) {|j|\n                 log(error, \"With... \" + stringifier(@things[j]));\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n-                // It would be best to test the *crate* for stability, but testing the\n-                // string for stability is easier and ok for now.\n+                // It would be best to test the *crate* for stability, but\n+                // testing the string for stability is easier and ok for now.\n                 let handler = diagnostic::mk_handler(none);\n                 let str3 =\n                     @as_str(bind pprust::print_crate(\n@@ -273,8 +283,11 @@ fn check_variants_T<T: copy>(\n                     check_roundtrip_convergence(str3, 1u);\n                   }\n                   tm_run {\n-                    let file_label = #fmt(\"rusttmp/%s_%s_%u_%u\", last_part(filename), thing_label, i, j);\n-                    let safe_to_run = !(content_is_dangerous_to_run(*str3) || has_raw_pointers(*crate2));\n+                    let file_label = #fmt(\"rusttmp/%s_%s_%u_%u\",\n+                                          last_part(filename),\n+                                          thing_label, i, j);\n+                    let safe_to_run = !(content_is_dangerous_to_run(*str3)\n+                                        || has_raw_pointers(*crate2));\n                     check_whole_compiler(*str3, file_label, safe_to_run);\n                   }\n                 }\n@@ -292,9 +305,11 @@ enum happiness { passed, cleanly_rejected(str), known_bug(str), failed(str), }\n \n // We'd find more bugs if we could take an AST here, but\n // - that would find many \"false positives\" or unimportant bugs\n-// - that would be tricky, requiring use of tasks or serialization or randomness.\n+// - that would be tricky, requiring use of tasks or serialization\n+//   or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: str, suggested_filename_prefix: str, allow_running: bool) {\n+fn check_whole_compiler(code: str, suggested_filename_prefix: str,\n+                        allow_running: bool) {\n     let filename = suggested_filename_prefix + \".rs\";\n     write_file(filename, code);\n \n@@ -331,7 +346,9 @@ fn removeDirIfExists(filename: str) {\n }\n \n fn check_running(exe_filename: str) -> happiness {\n-    let p = run::program_output(\"/Users/jruderman/scripts/timed_run_rust_program.py\", [exe_filename]);\n+    let p = run::program_output(\n+        \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n+        [exe_filename]);\n     let comb = p.out + \"\\n\" + p.err;\n     if str::len(comb) > 1u {\n         log(error, \"comb comb comb: \" + comb);\n@@ -352,17 +369,26 @@ fn check_running(exe_filename: str) -> happiness {\n             0         { passed }\n             100       { cleanly_rejected(\"running: explicit fail\") }\n             101 | 247 { cleanly_rejected(\"running: timed out\") }\n-            245 | 246 | 138 | 252 { known_bug(\"https://github.com/mozilla/rust/issues/1466\") }\n-            136 | 248 { known_bug(\"SIGFPE - https://github.com/mozilla/rust/issues/944\") }\n-            rc        { failed(\"Rust program ran but exited with status \" + int::str(rc)) }\n+            245 | 246 | 138 | 252 {\n+              known_bug(\"https://github.com/mozilla/rust/issues/1466\")\n+            }\n+            136 | 248 {\n+              known_bug(\n+                  \"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n+            }\n+            rc {\n+              failed(\"Rust program ran but exited with status \" +\n+                     int::str(rc))\n+            }\n         }\n     }\n }\n \n fn check_compiling(filename: str) -> happiness {\n     let p = run::program_output(\n-            \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/stage1/bin/rustc\",\n-            [filename]);\n+        \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n+         stage1/bin/rustc\",\n+        [filename]);\n \n     //#error(\"Status: %d\", p.status);\n     if p.status == 0 {\n@@ -454,10 +480,11 @@ fn content_might_not_converge(code: str) -> bool {\n     let confusing_patterns =\n         [\"xfail-test\",\n          \"xfail-pretty\",\n-         \"self\",       // crazy rules enforced by parser rather than typechecker?\n+         \"self\",       // crazy rules enforced by parser not typechecker?\n          \"spawn\",      // precedence issues?\n          \"bind\",       // precedence issues?\n-         \" be \",       // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n+         \" be \",       // don't want to replace its child with a non-call:\n+                       // \"Non-call expression in tail call\"\n          \"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n         ];\n \n@@ -467,7 +494,8 @@ fn content_might_not_converge(code: str) -> bool {\n \n fn file_might_not_converge(filename: str) -> bool {\n     let confusing_files = [\n-      \"expr-alt.rs\", // pretty-printing \"(a = b) = c\" vs \"a = b = c\" and wrapping\n+      \"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n+                     // vs \"a = b = c\" and wrapping\n       \"block-arg-in-ternary.rs\", // wrapping\n       \"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n       \"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n@@ -513,7 +541,8 @@ fn check_convergence(files: [str]) {\n             let s = @result::get(io::read_whole_file_str(file));\n             if !content_might_not_converge(*s) {\n                 #error(\"pp converge: %s\", file);\n-                // Change from 7u to 2u once https://github.com/mozilla/rust/issues/850 is fixed\n+                // Change from 7u to 2u once\n+                // https://github.com/mozilla/rust/issues/850 is fixed\n                 check_roundtrip_convergence(s, 7u);\n             }\n         }\n@@ -523,7 +552,8 @@ fn check_convergence(files: [str]) {\n fn check_variants(files: [str], cx: context) {\n     for files.each {|file|\n         if cx.mode == tm_converge && file_might_not_converge(file) {\n-            #error(\"Skipping convergence test based on file_might_not_converge\");\n+            #error(\"Skipping convergence test based on\\\n+                    file_might_not_converge\");\n             cont;\n         }\n "}, {"sha": "ed02550bb135d8be9f7bbf1a0bec2c1992a93fba", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=d2482fd7631d05b1888e3beac0df3f25d33867b8", "patch": "@@ -2,14 +2,16 @@\n \n Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n \n-  two functions, \"return all edits\" and \"return a random edit\" <-- leaning toward this model\n-    or\n-  two functions, \"return the number of possible edits\" and \"return edit #n\"\n+  two functions, \"return all edits\" and \"return a random edit\" <--\n+    leaning toward this model or two functions, \"return the number of\n+    possible edits\" and \"return edit #n\"\n \n-It would be nice if this could be data-driven, so the two functions could share information:\n+It would be nice if this could be data-driven, so the two functions\n+could share information:\n   type vec_modifier = rec(fn (<T> v, uint i) -> [T] fun, uint lo, uint di);\n   const [vec_modifier] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...];\n-But that gives me \"error: internal compiler error unimplemented consts that's not a plain literal\".\n+But that gives me \"error: internal compiler error unimplemented consts\n+that's not a plain literal\".\n https://github.com/graydon/rust/issues/570\n \n vec_edits is not an iter because iters might go away.\n@@ -47,7 +49,8 @@ fn ix(skip_low: uint, skip_high: uint, length: uint, it: block(uint)) {\n     while i + skip_high <= length { it(i); i += 1u; }\n }\n \n-// Returns a bunch of modified versions of v, some of which introduce new elements (borrowed from xs).\n+// Returns a bunch of modified versions of v, some of which introduce\n+// new elements (borrowed from xs).\n fn vec_edits<T: copy>(v: [T], xs: [T]) -> [[T]] {\n     let edits: [[T]] = [];\n     let Lv: uint = len(v);\n@@ -78,7 +81,8 @@ fn vec_edits<T: copy>(v: [T], xs: [T]) -> [[T]] {\n     edits\n }\n \n-// Would be nice if this were built in: https://github.com/graydon/rust/issues/424\n+// Would be nice if this were built in:\n+// https://github.com/graydon/rust/issues/424\n fn vec_to_str(v: [int]) -> str {\n     let i = 0u;\n     let s = \"[\";"}, {"sha": "1a51ab0cd4172d995644f01e6f7c8b43bfae8ecd", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=d2482fd7631d05b1888e3beac0df3f25d33867b8", "patch": "@@ -3,10 +3,14 @@ import std::rand;\n import vec;\n \n // random uint less than n\n-fn under(r : rand::rng, n : uint) -> uint { assert n != 0u; r.next() as uint % n }\n+fn under(r : rand::rng, n : uint) -> uint {\n+    assert n != 0u; r.next() as uint % n\n+}\n \n // random choice from a vec\n-fn choice<T: copy>(r : rand::rng, v : [T]) -> T { assert vec::len(v) != 0u; v[under(r, vec::len(v))] }\n+fn choice<T: copy>(r : rand::rng, v : [T]) -> T {\n+    assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n+}\n \n // 1 in n chance of being true\n fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }"}, {"sha": "fd14c90f00a3b84ea71513d9416ad39abd3039bb", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2482fd7631d05b1888e3beac0df3f25d33867b8/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=d2482fd7631d05b1888e3beac0df3f25d33867b8", "patch": "@@ -48,7 +48,7 @@ Options:\n     --out-dir <dir>    Write output to compiler-chosen filename in <dir>\n     --parse-only       Parse only; do not compile, assemble, or link\n     --pretty [type]    Pretty-print the input instead of compiling;\n-                       valid types are: normal (un-annotated source), \n+                       valid types are: normal (un-annotated source),\n                        expanded (crates expanded), typed (crates expanded,\n                        with type annotations), or identified (fully\n                        parenthesized, AST nodes and blocks with IDs)"}]}