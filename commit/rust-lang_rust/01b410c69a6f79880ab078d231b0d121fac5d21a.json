{"sha": "01b410c69a6f79880ab078d231b0d121fac5d21a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYjQxMGM2OWE2Zjc5ODgwYWIwNzhkMjMxYjBkMTIxZmFjNWQyMWE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-13T18:02:14Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-13T18:02:14Z"}, "message": "Slightly cleanup import_assets module", "tree": {"sha": "f73a34e1e8e3c43b401d5b5f62f7505e485ac7df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f73a34e1e8e3c43b401d5b5f62f7505e485ac7df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01b410c69a6f79880ab078d231b0d121fac5d21a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01b410c69a6f79880ab078d231b0d121fac5d21a", "html_url": "https://github.com/rust-lang/rust/commit/01b410c69a6f79880ab078d231b0d121fac5d21a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01b410c69a6f79880ab078d231b0d121fac5d21a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b844e9fbc351a53d56398e269e5861ed1ad5c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/02b844e9fbc351a53d56398e269e5861ed1ad5c1", "html_url": "https://github.com/rust-lang/rust/commit/02b844e9fbc351a53d56398e269e5861ed1ad5c1"}], "stats": {"total": 146, "additions": 84, "deletions": 62}, "files": [{"sha": "e595b5b937af36409f5116c76122421b9a462721", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01b410c69a6f79880ab078d231b0d121fac5d21a/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b410c69a6f79880ab078d231b0d121fac5d21a/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=01b410c69a6f79880ab078d231b0d121fac5d21a", "patch": "@@ -63,13 +63,13 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n fn import_group_message(import_candidate: &ImportCandidate) -> GroupLabel {\n     let name = match import_candidate {\n-        ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n-        ImportCandidate::QualifierStart(qualifier_start) => format!(\"Import {}\", qualifier_start),\n-        ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => {\n-            format!(\"Import a trait for item {}\", trait_assoc_item_name)\n+        ImportCandidate::UnqualifiedName(candidate)\n+        | ImportCandidate::QualifierStart(candidate) => format!(\"Import {}\", &candidate.name),\n+        ImportCandidate::TraitAssocItem(candidate) => {\n+            format!(\"Import a trait for item {}\", &candidate.name)\n         }\n-        ImportCandidate::TraitMethod(_, trait_method_name) => {\n-            format!(\"Import a trait for method {}\", trait_method_name)\n+        ImportCandidate::TraitMethod(candidate) => {\n+            format!(\"Import a trait for method {}\", &candidate.name)\n         }\n     };\n     GroupLabel(name)"}, {"sha": "601f51098d0c4a3fea7855f0e460f702da43600e", "filename": "crates/assists/src/utils/import_assets.rs", "status": "modified", "additions": 78, "deletions": 56, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/01b410c69a6f79880ab078d231b0d121fac5d21a/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b410c69a6f79880ab078d231b0d121fac5d21a/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs?ref=01b410c69a6f79880ab078d231b0d121fac5d21a", "patch": "@@ -12,18 +12,29 @@ use crate::assist_config::InsertUseConfig;\n #[derive(Debug)]\n pub(crate) enum ImportCandidate {\n     /// Simple name like 'HashMap'\n-    UnqualifiedName(String),\n+    UnqualifiedName(PathImportCandidate),\n     /// First part of the qualified name.\n     /// For 'std::collections::HashMap', that will be 'std'.\n-    QualifierStart(String),\n+    QualifierStart(PathImportCandidate),\n     /// A trait associated function (with no self parameter) or associated constant.\n-    /// For 'test_mod::TestEnum::test_function', `Type` is the `test_mod::TestEnum` expression type\n-    /// and `String` is the `test_function`\n-    TraitAssocItem(hir::Type, String),\n+    /// For 'test_mod::TestEnum::test_function', `ty` is the `test_mod::TestEnum` expression type\n+    /// and `name` is the `test_function`\n+    TraitAssocItem(TraitImportCandidate),\n     /// A trait method with self parameter.\n-    /// For 'test_enum.test_method()', `Type` is the `test_enum` expression type\n-    /// and `String` is the `test_method`\n-    TraitMethod(hir::Type, String),\n+    /// For 'test_enum.test_method()', `ty` is the `test_enum` expression type\n+    /// and `name` is the `test_method`\n+    TraitMethod(TraitImportCandidate),\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct TraitImportCandidate {\n+    pub ty: hir::Type,\n+    pub name: String,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct PathImportCandidate {\n+    pub name: String,\n }\n \n #[derive(Debug)]\n@@ -74,10 +85,10 @@ impl ImportAssets {\n \n     fn get_search_query(&self) -> &str {\n         match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(name) => name,\n-            ImportCandidate::QualifierStart(qualifier_start) => qualifier_start,\n-            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => trait_assoc_item_name,\n-            ImportCandidate::TraitMethod(_, trait_method_name) => trait_method_name,\n+            ImportCandidate::UnqualifiedName(candidate)\n+            | ImportCandidate::QualifierStart(candidate) => &candidate.name,\n+            ImportCandidate::TraitAssocItem(candidate)\n+            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n         }\n     }\n \n@@ -106,27 +117,29 @@ impl ImportAssets {\n         prefixed: Option<hir::PrefixKind>,\n     ) -> BTreeSet<hir::ModPath> {\n         let db = sema.db;\n+        let mut trait_candidates = FxHashSet::default();\n         let current_crate = self.module_with_name_to_import.krate();\n-        imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n-            .into_iter()\n-            .filter_map(|candidate| match &self.import_candidate {\n-                ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n+\n+        let filter = |candidate: Either<hir::ModuleDef, hir::MacroDef>| {\n+            trait_candidates.clear();\n+            match &self.import_candidate {\n+                ImportCandidate::TraitAssocItem(trait_candidate) => {\n                     let located_assoc_item = match candidate {\n-                        Either::Left(ModuleDef::Function(located_function)) => located_function\n-                            .as_assoc_item(db)\n-                            .map(|assoc| assoc.container(db))\n-                            .and_then(Self::assoc_to_trait),\n-                        Either::Left(ModuleDef::Const(located_const)) => located_const\n-                            .as_assoc_item(db)\n-                            .map(|assoc| assoc.container(db))\n-                            .and_then(Self::assoc_to_trait),\n+                        Either::Left(ModuleDef::Function(located_function)) => {\n+                            located_function.as_assoc_item(db)\n+                        }\n+                        Either::Left(ModuleDef::Const(located_const)) => {\n+                            located_const.as_assoc_item(db)\n+                        }\n                         _ => None,\n-                    }?;\n+                    }\n+                    .map(|assoc| assoc.container(db))\n+                    .and_then(Self::assoc_to_trait)?;\n \n-                    let mut trait_candidates = FxHashSet::default();\n                     trait_candidates.insert(located_assoc_item.into());\n \n-                    assoc_item_type\n+                    trait_candidate\n+                        .ty\n                         .iterate_path_candidates(\n                             db,\n                             current_crate,\n@@ -137,7 +150,7 @@ impl ImportAssets {\n                         .map(ModuleDef::from)\n                         .map(Either::Left)\n                 }\n-                ImportCandidate::TraitMethod(function_callee, _) => {\n+                ImportCandidate::TraitMethod(trait_candidate) => {\n                     let located_assoc_item =\n                         if let Either::Left(ModuleDef::Function(located_function)) = candidate {\n                             located_function\n@@ -148,10 +161,10 @@ impl ImportAssets {\n                             None\n                         }?;\n \n-                    let mut trait_candidates = FxHashSet::default();\n                     trait_candidates.insert(located_assoc_item.into());\n \n-                    function_callee\n+                    trait_candidate\n+                        .ty\n                         .iterate_method_candidates(\n                             db,\n                             current_crate,\n@@ -165,12 +178,14 @@ impl ImportAssets {\n                         .map(Either::Left)\n                 }\n                 _ => Some(candidate),\n-            })\n+            }\n+        };\n+\n+        imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n+            .into_iter()\n+            .filter_map(filter)\n             .filter_map(|candidate| {\n-                let item: hir::ItemInNs = match candidate {\n-                    Either::Left(module_def) => module_def.into(),\n-                    Either::Right(macro_def) => macro_def.into(),\n-                };\n+                let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n                 if let Some(prefix_kind) = prefixed {\n                     self.module_with_name_to_import.find_use_path_prefixed(db, item, prefix_kind)\n                 } else {\n@@ -196,13 +211,13 @@ impl ImportCandidate {\n         sema: &Semantics<RootDatabase>,\n         method_call: &ast::MethodCallExpr,\n     ) -> Option<Self> {\n-        if sema.resolve_method_call(method_call).is_some() {\n-            return None;\n+        match sema.resolve_method_call(method_call) {\n+            Some(_) => None,\n+            None => Some(Self::TraitMethod(TraitImportCandidate {\n+                ty: sema.type_of_expr(&method_call.receiver()?)?,\n+                name: method_call.name_ref()?.syntax().to_string(),\n+            })),\n         }\n-        Some(Self::TraitMethod(\n-            sema.type_of_expr(&method_call.receiver()?)?,\n-            method_call.name_ref()?.syntax().to_string(),\n-        ))\n     }\n \n     fn for_regular_path(\n@@ -214,7 +229,7 @@ impl ImportCandidate {\n         }\n \n         let segment = path_under_caret.segment()?;\n-        if let Some(qualifier) = path_under_caret.qualifier() {\n+        let candidate = if let Some(qualifier) = path_under_caret.qualifier() {\n             let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n             let qualifier_start_path =\n                 qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n@@ -224,23 +239,30 @@ impl ImportCandidate {\n                 } else {\n                     sema.resolve_path(&qualifier)?\n                 };\n-                if let hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) =\n-                    qualifier_resolution\n-                {\n-                    Some(ImportCandidate::TraitAssocItem(\n-                        assoc_item_path.ty(sema.db),\n-                        segment.syntax().to_string(),\n-                    ))\n-                } else {\n-                    None\n+                match qualifier_resolution {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n+                        ImportCandidate::TraitAssocItem(TraitImportCandidate {\n+                            ty: assoc_item_path.ty(sema.db),\n+                            name: segment.syntax().to_string(),\n+                        })\n+                    }\n+                    _ => return None,\n                 }\n             } else {\n-                Some(ImportCandidate::QualifierStart(qualifier_start.syntax().to_string()))\n+                ImportCandidate::QualifierStart(PathImportCandidate {\n+                    name: qualifier_start.syntax().to_string(),\n+                })\n             }\n         } else {\n-            Some(ImportCandidate::UnqualifiedName(\n-                segment.syntax().descendants().find_map(ast::NameRef::cast)?.syntax().to_string(),\n-            ))\n-        }\n+            ImportCandidate::UnqualifiedName(PathImportCandidate {\n+                name: segment\n+                    .syntax()\n+                    .descendants()\n+                    .find_map(ast::NameRef::cast)?\n+                    .syntax()\n+                    .to_string(),\n+            })\n+        };\n+        Some(candidate)\n     }\n }"}]}