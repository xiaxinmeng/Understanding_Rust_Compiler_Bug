{"sha": "aff7772a1da244af8a37c786c6c7cb87747b9d02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZjc3NzJhMWRhMjQ0YWY4YTM3Yzc4NmM2YzdjYjg3NzQ3YjlkMDI=", "commit": {"author": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2018-12-17T22:23:12Z"}, "committer": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2019-01-22T22:45:10Z"}, "message": "Move core::iter adapters to adapters.rs", "tree": {"sha": "879a1de3dd7a75b7310d07cf3bffe289dc166caf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/879a1de3dd7a75b7310d07cf3bffe289dc166caf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aff7772a1da244af8a37c786c6c7cb87747b9d02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aff7772a1da244af8a37c786c6c7cb87747b9d02", "html_url": "https://github.com/rust-lang/rust/commit/aff7772a1da244af8a37c786c6c7cb87747b9d02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aff7772a1da244af8a37c786c6c7cb87747b9d02/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96909179d9ec80db286605876ce67659dd16fd4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/96909179d9ec80db286605876ce67659dd16fd4b", "html_url": "https://github.com/rust-lang/rust/commit/96909179d9ec80db286605876ce67659dd16fd4b"}], "stats": {"total": 5559, "additions": 2790, "deletions": 2769}, "files": [{"sha": "abeb13180c3356a279ee1d481665f87c573e1f23", "filename": "src/libcore/iter/adapters/mod.rs", "status": "added", "additions": 2772, "deletions": 0, "changes": 2772, "blob_url": "https://github.com/rust-lang/rust/blob/aff7772a1da244af8a37c786c6c7cb87747b9d02/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff7772a1da244af8a37c786c6c7cb87747b9d02/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=aff7772a1da244af8a37c786c6c7cb87747b9d02", "patch": "@@ -0,0 +1,2772 @@\n+use cmp;\n+use fmt;\n+use iter_private::TrustedRandomAccess;\n+use ops::Try;\n+use usize;\n+use intrinsics;\n+use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n+use super::LoopState;\n+\n+/// A double-ended iterator with the direction inverted.\n+///\n+/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`rev`]: trait.Iterator.html#method.rev\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rev<T> {\n+    pub(super) iter: T\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth_back(n) }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_rfold(init, f)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, f)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.rfind(predicate)\n+    }\n+\n+    #[inline]\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n+        P: FnMut(Self::Item) -> bool\n+    {\n+        self.iter.position(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth(n) }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_fold(init, f)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, f)\n+    }\n+\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        where P: FnMut(&Self::Item) -> bool\n+    {\n+        self.iter.find(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Rev<I>\n+    where I: ExactSizeIterator + DoubleEndedIterator\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Rev<I>\n+    where I: FusedIterator + DoubleEndedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Rev<I>\n+    where I: TrustedLen + DoubleEndedIterator {}\n+\n+/// An iterator that copies the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`copied`]: trait.Iterator.html#method.copied\n+/// [`Iterator`]: trait.Iterator.html\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Copied<I> {\n+    pub(super) it: I,\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> Iterator for Copied<I>\n+    where I: Iterator<Item=&'a T>, T: Copy\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().copied()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Copy\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().copied()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Copy\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> FusedIterator for Copied<I>\n+    where I: FusedIterator<Item=&'a T>, T: Copy\n+{}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        *self.it.get_unchecked(i)\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n+    where I: TrustedLen<Item=&'a T>,\n+          T: Copy\n+{}\n+\n+/// An iterator that clones the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cloned`]: trait.Iterator.html#method.cloned\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Cloned<I> {\n+    pub(super) it: I,\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+    where I: Iterator<Item=&'a T>, T: Clone\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().cloned()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n+    where I: FusedIterator<Item=&'a T>, T: Clone\n+{}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n+{\n+    default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        self.it.get_unchecked(i).clone()\n+    }\n+\n+    #[inline]\n+    default fn may_have_side_effect() -> bool { true }\n+}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        *self.it.get_unchecked(i)\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n+    where I: TrustedLen<Item=&'a T>,\n+          T: Clone\n+{}\n+\n+/// An iterator that repeats endlessly.\n+///\n+/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cycle`]: trait.Iterator.html#method.cycle\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Cycle<I> {\n+    pub(super) orig: I,\n+    pub(super) iter: I,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        match self.iter.next() {\n+            None => { self.iter = self.orig.clone(); self.iter.next() }\n+            y => y\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // the cycle iterator is either empty or infinite\n+        match self.orig.size_hint() {\n+            sz @ (0, Some(0)) => sz,\n+            (0, _) => (0, None),\n+            _ => (usize::MAX, None)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n+\n+/// An iterator for stepping iterators by a custom amount.\n+///\n+/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n+/// its documentation for more.\n+///\n+/// [`step_by`]: trait.Iterator.html#method.step_by\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+#[derive(Clone, Debug)]\n+pub struct StepBy<I> {\n+    pub(super) iter: I,\n+    pub(super) step: usize,\n+    pub(super) first_take: bool,\n+}\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> Iterator for StepBy<I> where I: Iterator {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            self.iter.next()\n+        } else {\n+            self.iter.nth(self.step)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let inner_hint = self.iter.size_hint();\n+\n+        if self.first_take {\n+            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n+            (f(inner_hint.0), inner_hint.1.map(f))\n+        } else {\n+            let f = |n| n / (self.step+1);\n+            (f(inner_hint.0), inner_hint.1.map(f))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            let first = self.iter.next();\n+            if n == 0 {\n+                return first;\n+            }\n+            n -= 1;\n+        }\n+        // n and self.step are indices, we need to add 1 to get the amount of elements\n+        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n+        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n+        let mut step = self.step + 1;\n+        // n + 1 could overflow\n+        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n+        if n == usize::MAX {\n+            self.iter.nth(step - 1);\n+        } else {\n+            n += 1;\n+        }\n+\n+        // overflow handling\n+        loop {\n+            let mul = n.checked_mul(step);\n+            if unsafe { intrinsics::likely(mul.is_some()) } {\n+                return self.iter.nth(mul.unwrap() - 1);\n+            }\n+            let div_n = usize::MAX / n;\n+            let div_step = usize::MAX / step;\n+            let nth_n = div_n * n;\n+            let nth_step = div_step * step;\n+            let nth = if nth_n > nth_step {\n+                step -= div_n;\n+                nth_n\n+            } else {\n+                n -= div_step;\n+                nth_step\n+            };\n+            self.iter.nth(nth - 1);\n+        }\n+    }\n+}\n+\n+// StepBy can only make the iterator shorter, so the len will still fit.\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n+\n+/// An iterator that strings two iterators together.\n+///\n+/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`chain`]: trait.Iterator.html#method.chain\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chain<A, B> {\n+    pub(super) a: A,\n+    pub(super) b: B,\n+    pub(super) state: ChainState,\n+}\n+\n+// The iterator protocol specifies that iteration ends with the return value\n+// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n+// further calls return. The chain adaptor must account for this since it uses\n+// two subiterators.\n+//\n+//  It uses three states:\n+//\n+//  - Both: `a` and `b` are remaining\n+//  - Front: `a` remaining\n+//  - Back: `b` remaining\n+//\n+//  The fourth state (neither iterator is remaining) only occurs after Chain has\n+//  returned None once, so we don't need to store this state.\n+#[derive(Clone, Debug)]\n+pub(super) enum ChainState {\n+    // both front and back iterator are remaining\n+    Both,\n+    // only front is remaining\n+    Front,\n+    // only back is remaining\n+    Back,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Chain<A, B> where\n+    A: Iterator,\n+    B: Iterator<Item = A::Item>\n+{\n+    type Item = A::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.a.next() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.next()\n+                }\n+            },\n+            ChainState::Front => self.a.next(),\n+            ChainState::Back => self.b.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(self) -> usize {\n+        match self.state {\n+            ChainState::Both => self.a.count() + self.b.count(),\n+            ChainState::Front => self.a.count(),\n+            ChainState::Back => self.b.count(),\n+        }\n+    }\n+\n+    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.try_fold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Back = self.state {\n+            accum = self.b.try_fold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                for x in self.a.by_ref() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            ChainState::Back => {}\n+        }\n+        if let ChainState::Back = self.state {\n+            self.b.nth(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        match self.state {\n+            ChainState::Both => match self.a.find(&mut predicate) {\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.find(predicate)\n+                }\n+                v => v\n+            },\n+            ChainState::Front => self.a.find(predicate),\n+            ChainState::Back => self.b.find(predicate),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => {\n+                // Must exhaust a before b.\n+                let a_last = self.a.last();\n+                let b_last = self.b.last();\n+                b_last.or(a_last)\n+            },\n+            ChainState::Front => self.a.last(),\n+            ChainState::Back => self.b.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = a_lower.saturating_add(b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => x.checked_add(y),\n+            _ => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator,\n+    B: DoubleEndedIterator<Item=A::Item>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.b.next_back() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Front;\n+                    self.a.next_back()\n+                }\n+            },\n+            ChainState::Front => self.a.next_back(),\n+            ChainState::Back => self.b.next_back(),\n+        }\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.try_rfold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Front;\n+                }\n+            }\n+            _ => { }\n+        }\n+        if let ChainState::Front = self.state {\n+            accum = self.a.try_rfold(accum, &mut f)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n+}\n+\n+// Note: *both* must be fused to handle double-ended iterators.\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A, B> FusedIterator for Chain<A, B>\n+    where A: FusedIterator,\n+          B: FusedIterator<Item=A::Item>,\n+{}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Chain<A, B>\n+    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n+{}\n+\n+/// An iterator that iterates two other iterators simultaneously.\n+///\n+/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`zip`]: trait.Iterator.html#method.zip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Zip<A, B> {\n+    a: A,\n+    b: B,\n+    // index and len are only used by the specialized version of zip\n+    index: usize,\n+    len: usize,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        ZipImpl::next(self)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        ZipImpl::size_hint(self)\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        ZipImpl::nth(self, n)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: DoubleEndedIterator + ExactSizeIterator,\n+    B: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n+        ZipImpl::next_back(self)\n+    }\n+}\n+\n+// Zip specialization trait\n+#[doc(hidden)]\n+pub(super) trait ZipImpl<A, B> {\n+    type Item;\n+    fn new(a: A, b: B) -> Self;\n+    fn next(&mut self) -> Option<Self::Item>;\n+    fn size_hint(&self) -> (usize, Option<usize>);\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn super_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        while let Some(x) = self.next() {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+    fn next_back(&mut self) -> Option<Self::Item>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator;\n+}\n+\n+// General Zip impl\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+    default fn new(a: A, b: B) -> Self {\n+        Zip {\n+            a,\n+            b,\n+            index: 0, // unused\n+            len: 0, // unused\n+        }\n+    }\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        self.a.next().and_then(|x| {\n+            self.b.next().and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n+    }\n+\n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.super_nth(n)\n+    }\n+\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n+        let a_sz = self.a.len();\n+        let b_sz = self.b.len();\n+        if a_sz != b_sz {\n+            // Adjust a, b to equal length\n+            if a_sz > b_sz {\n+                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n+            } else {\n+                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n+            }\n+        }\n+        match (self.a.next_back(), self.b.next_back()) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            (None, None) => None,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: TrustedRandomAccess, B: TrustedRandomAccess\n+{\n+    fn new(a: A, b: B) -> Self {\n+        let len = cmp::min(a.len(), b.len());\n+        Zip {\n+            a,\n+            b,\n+            index: 0,\n+            len,\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        if self.index < self.len {\n+            let i = self.index;\n+            self.index += 1;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else if A::may_have_side_effect() && self.index < self.a.len() {\n+            // match the base implementation's potential side effects\n+            unsafe {\n+                self.a.get_unchecked(self.index);\n+            }\n+            self.index += 1;\n+            None\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len - self.index;\n+        (len, Some(len))\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let delta = cmp::min(n, self.len - self.index);\n+        let end = self.index + delta;\n+        while self.index < end {\n+            let i = self.index;\n+            self.index += 1;\n+            if A::may_have_side_effect() {\n+                unsafe { self.a.get_unchecked(i); }\n+            }\n+            if B::may_have_side_effect() {\n+                unsafe { self.b.get_unchecked(i); }\n+            }\n+        }\n+\n+        self.super_nth(n - delta)\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n+        // Adjust a, b to equal length\n+        if A::may_have_side_effect() {\n+            let sz = self.a.len();\n+            if sz > self.len {\n+                for _ in 0..sz - cmp::max(self.len, self.index) {\n+                    self.a.next_back();\n+                }\n+            }\n+        }\n+        if B::may_have_side_effect() {\n+            let sz = self.b.len();\n+            if sz > self.len {\n+                for _ in 0..sz - self.len {\n+                    self.b.next_back();\n+                }\n+            }\n+        }\n+        if self.index < self.len {\n+            self.len -= 1;\n+            let i = self.len;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> ExactSizeIterator for Zip<A, B>\n+    where A: ExactSizeIterator, B: ExactSizeIterator {}\n+\n+#[doc(hidden)]\n+unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n+    where A: TrustedRandomAccess,\n+          B: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n+        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        A::may_have_side_effect() || B::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A, B> FusedIterator for Zip<A, B>\n+    where A: FusedIterator, B: FusedIterator, {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Zip<A, B>\n+    where A: TrustedLen, B: TrustedLen,\n+{}\n+\n+/// An iterator that maps the values of `iter` with `f`.\n+///\n+/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map`]: trait.Iterator.html#method.map\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazily on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n+    pub(super) iter: I,\n+    pub(super) f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Map\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n+    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+        where G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        self.iter.next_back().map(&mut self.f)\n+    }\n+\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n+    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+        where G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n+    where F: FnMut(I::Item) -> B\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n+    where F: FnMut(I::Item) -> B {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<B, I, F> TrustedLen for Map<I, F>\n+    where I: TrustedLen,\n+          F: FnMut(I::Item) -> B {}\n+\n+#[doc(hidden)]\n+unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n+    where I: TrustedRandomAccess,\n+          F: FnMut(I::Item) -> B,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        (self.f)(self.iter.get_unchecked(i))\n+    }\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n+/// An iterator that filters the elements of `iter` with `predicate`.\n+///\n+/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter`]: trait.Iterator.html#method.filter\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n+    pub(super) iter: I,\n+    pub(super) predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Filter\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        for x in &mut self.iter {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    // this special case allows the compiler to make `.filter(_).count()`\n+    // branchless. Barring perfect branch prediction (which is unattainable in\n+    // the general case), this will be much faster in >90% of cases (containing\n+    // virtually all real workloads) and only a tiny bit slower in the rest.\n+    //\n+    // Having this specialization thus allows us to write `.filter(p).count()`\n+    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n+    // less readable and also less backwards-compatible to Rust before 1.10.\n+    //\n+    // Using the branchless version will also simplify the LLVM byte code, thus\n+    // leaving more budget for LLVM optimizations.\n+    #[inline]\n+    fn count(mut self) -> usize {\n+        let mut count = 0;\n+        for x in &mut self.iter {\n+            count += (self.predicate)(&x) as usize;\n+        }\n+        count\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref().rev() {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool {}\n+\n+/// An iterator that uses `f` to both filter and map elements from `iter`.\n+///\n+/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter_map`]: trait.Iterator.html#method.filter_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n+    pub(super) iter: I,\n+    pub(super) f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref().rev() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B> {}\n+\n+/// An iterator that yields the current count and the element during iteration.\n+///\n+/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`enumerate`]: trait.Iterator.html#method.enumerate\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Enumerate<I> {\n+    pub(super) iter: I,\n+    pub(super) count: usize,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Enumerate<I> where I: Iterator {\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next().map(|a| {\n+            let ret = (self.count, a);\n+            // Possible undefined overflow.\n+            self.count += 1;\n+            ret\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        self.iter.nth(n).map(|a| {\n+            let i = self.count + n;\n+            self.count = i + 1;\n+            (i, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let count = &mut self.count;\n+        self.iter.try_fold(init, move |acc, item| {\n+            let acc = fold(acc, (*count, item));\n+            *count += 1;\n+            acc\n+        })\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut count = self.count;\n+        self.iter.fold(init, move |acc, item| {\n+            let acc = fold(acc, (count, item));\n+            count += 1;\n+            acc\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Enumerate<I> where\n+    I: ExactSizeIterator + DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next_back().map(|a| {\n+            let len = self.iter.len();\n+            // Can safely add, `ExactSizeIterator` promises that the number of\n+            // elements fits into a `usize`.\n+            (self.count + len, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[doc(hidden)]\n+unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n+    where I: TrustedRandomAccess\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n+        (self.count + i, self.iter.get_unchecked(i))\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Enumerate<I>\n+    where I: TrustedLen,\n+{}\n+\n+\n+/// An iterator with a `peek()` that returns an optional reference to the next\n+/// element.\n+///\n+/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`peekable`]: trait.Iterator.html#method.peekable\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Peekable<I: Iterator> {\n+    pub(super) iter: I,\n+    /// Remember a peeked value, even if it was None.\n+    pub(super) peeked: Option<Option<I::Item>>,\n+}\n+\n+// Peekable must remember if a None has been seen in the `.peek()` method.\n+// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n+// underlying iterator at most once. This does not by itself make the iterator\n+// fused.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(v) => v,\n+            None => self.iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(mut self) -> usize {\n+        match self.peeked.take() {\n+            Some(None) => 0,\n+            Some(Some(_)) => 1 + self.iter.count(),\n+            None => self.iter.count(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(None) => None,\n+            Some(v @ Some(_)) if n == 0 => v,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        let peek_opt = match self.peeked.take() {\n+            Some(None) => return None,\n+            Some(v) => v,\n+            None => None,\n+        };\n+        self.iter.last().or(peek_opt)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let peek_len = match self.peeked {\n+            Some(None) => return (0, Some(0)),\n+            Some(Some(_)) => 1,\n+            None => 0,\n+        };\n+        let (lo, hi) = self.iter.size_hint();\n+        let lo = lo.saturating_add(peek_len);\n+        let hi = hi.and_then(|x| x.checked_add(peek_len));\n+        (lo, hi)\n+    }\n+\n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let acc = match self.peeked.take() {\n+            Some(None) => return Try::from_ok(init),\n+            Some(Some(v)) => f(init, v)?,\n+            None => init,\n+        };\n+        self.iter.try_fold(acc, f)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n+\n+impl<I: Iterator> Peekable<I> {\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n+    /// But if the iteration is over, `None` is returned.\n+    ///\n+    /// [`next`]: trait.Iterator.html#tymethod.next\n+    ///\n+    /// Because `peek()` returns a reference, and many iterators iterate over\n+    /// references, there can be a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // The iterator does not advance even if we `peek` multiple times\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // After the iterator is finished, so is `peek()`\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n+        let iter = &mut self.iter;\n+        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n+    }\n+}\n+\n+/// An iterator that rejects elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip_while`]: trait.Iterator.html#method.skip_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n+    pub(super) iter: I,\n+    pub(super) flag: bool,\n+    pub(super) predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let flag = &mut self.flag;\n+        let pred = &mut self.predicate;\n+        self.iter.find(move |x| {\n+            if *flag || !pred(x) {\n+                *flag = true;\n+                true\n+            } else {\n+                false\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v)?,\n+                None => return Try::from_ok(init),\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for SkipWhile<I, P>\n+    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n+\n+/// An iterator that only accepts elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take_while`]: trait.Iterator.html#method.take_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n+    pub(super) iter: I,\n+    pub(super) flag: bool,\n+    pub(super) predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.flag {\n+            None\n+        } else {\n+            self.iter.next().and_then(|x| {\n+                if (self.predicate)(&x) {\n+                    Some(x)\n+                } else {\n+                    self.flag = true;\n+                    None\n+                }\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.flag {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.flag {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, move |acc, x|{\n+                if p(&x) {\n+                    LoopState::from_try(fold(acc, x))\n+                } else {\n+                    *flag = true;\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            }).into_try()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for TakeWhile<I, P>\n+    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n+\n+/// An iterator that skips over `n` elements of `iter`.\n+///\n+/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip`]: trait.Iterator.html#method.skip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Skip<I> {\n+    pub(super) iter: I,\n+    pub(super) n: usize\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Skip<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.next()\n+        } else {\n+            let old_n = self.n;\n+            self.n = 0;\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n == 0 {\n+            self.iter.nth(n)\n+        } else {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            if self.iter.nth(to_skip-1).is_none() {\n+                return None;\n+            }\n+            self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count().saturating_sub(self.n)\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.last()\n+        } else {\n+            let next = self.next();\n+            if next.is_some() {\n+                // recurse. n should be 0.\n+                self.last().or(next)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = lower.saturating_sub(self.n);\n+        let upper = upper.map(|x| x.saturating_sub(self.n));\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let n = self.n;\n+        self.n = 0;\n+        if n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(n - 1).is_none() {\n+                return Try::from_ok(init);\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n+impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.len() > 0 {\n+            self.iter.next_back()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut n = self.len();\n+        if n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            self.iter.try_rfold(init, move |acc, x| {\n+                n -= 1;\n+                let r = fold(acc, x);\n+                if n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n+\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n+///\n+/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take`]: trait.Iterator.html#method.take\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Take<I> {\n+    pub(super) iter: I,\n+    pub(super) n: usize\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Take<I> where I: Iterator{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.n != 0 {\n+            self.n -= 1;\n+            self.iter.next()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.n == 0 {\n+            return (0, Some(0));\n+        }\n+\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n)\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, move |acc, x| {\n+                *n -= 1;\n+                let r = fold(acc, x);\n+                if *n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n+\n+/// An iterator to maintain state while iterating another iterator.\n+///\n+/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`scan`]: trait.Iterator.html#method.scan\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n+    pub(super) iter: I,\n+    pub(super) f: F,\n+    pub(super) state: St,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Scan\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"state\", &self.state)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I, St, F> Iterator for Scan<I, St, F> where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let state = &mut self.state;\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, x| {\n+            match f(state, x) {\n+                None => LoopState::Break(Try::from_ok(acc)),\n+                Some(x) => LoopState::from_try(fold(acc, x)),\n+            }\n+        }).into_try()\n+    }\n+}\n+\n+/// An iterator that maps each element to an iterator, and yields the elements\n+/// of the produced iterators.\n+///\n+/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flat_map`]: trait.Iterator.html#method.flat_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct FlatMap<I, U: IntoIterator, F> {\n+    pub(super) inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n+    where <U as IntoIterator>::IntoIter: Clone\n+{\n+    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n+    where U::IntoIter: fmt::Debug\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+          U: IntoIterator,\n+          U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n+    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+\n+/// An iterator that flattens one level of nesting in an iterator of things\n+/// that can be turned into iterators.\n+///\n+/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flatten`]: trait.Iterator.html#method.flatten\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub struct Flatten<I: Iterator>\n+where I::Item: IntoIterator {\n+    pub(super) inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> fmt::Debug for Flatten<I>\n+    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> Clone for Flatten<I>\n+    where I: Iterator + Clone, U: Iterator + Clone,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> Iterator for Flatten<I>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> DoubleEndedIterator for Flatten<I>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> FusedIterator for Flatten<I>\n+    where I: FusedIterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+\n+/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n+pub(super) fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n+    FlattenCompat { iter, frontiter: None, backiter: None }\n+}\n+\n+/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n+/// this type.\n+#[derive(Clone, Debug)]\n+pub(super) struct FlattenCompat<I, U> {\n+    iter: I,\n+    frontiter: Option<U>,\n+    backiter: Option<U>,\n+}\n+\n+impl<I, U> Iterator for FlattenCompat<I, U>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.frontiter {\n+                if let elt@Some(_) = inner.next() { return elt }\n+            }\n+            match self.iter.next() {\n+                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                Some(inner) => self.frontiter = Some(inner.into_iter()),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let lo = flo.saturating_add(blo);\n+        match (self.iter.size_hint(), fhi, bhi) {\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n+            _ => (lo, None)\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_fold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        {\n+            let frontiter = &mut self.frontiter;\n+            init = self.iter.try_fold(init, |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_fold(acc, &mut fold);\n+                *frontiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.frontiter = None;\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_fold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(IntoIterator::into_iter))\n+            .chain(self.backiter)\n+            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n+    }\n+}\n+\n+impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.backiter {\n+                if let elt@Some(_) = inner.next_back() { return elt }\n+            }\n+            match self.iter.next_back() {\n+                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                next => self.backiter = next.map(IntoIterator::into_iter),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        {\n+            let backiter = &mut self.backiter;\n+            init = self.iter.try_rfold(init, |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_rfold(acc, &mut fold);\n+                *backiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.backiter = None;\n+\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_rfold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(IntoIterator::into_iter))\n+            .chain(self.backiter)\n+            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+    }\n+}\n+\n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+///\n+/// This `struct` is created by the [`fuse`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`fuse`]: trait.Iterator.html#method.fuse\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Fuse<I> {\n+    pub(super) iter: I,\n+    pub(super) done: bool\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Fuse<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+\n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let nth = self.iter.nth(n);\n+            self.done = nth.is_none();\n+            nth\n+        }\n+    }\n+\n+    #[inline]\n+    default fn last(self) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            self.iter.last()\n+        }\n+    }\n+\n+    #[inline]\n+    default fn count(self) -> usize {\n+        if self.done {\n+            0\n+        } else {\n+            self.iter.count()\n+        }\n+    }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.done {\n+            (0, Some(0))\n+        } else {\n+            self.iter.size_hint()\n+        }\n+    }\n+\n+    #[inline]\n+    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_fold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n+    #[inline]\n+    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.fold(init, fold)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next_back();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+\n+    #[inline]\n+    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_rfold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n+    #[inline]\n+    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.rfold(init, fold)\n+        }\n+    }\n+}\n+\n+unsafe impl<I> TrustedRandomAccess for Fuse<I>\n+    where I: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n+        self.iter.get_unchecked(i)\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> Iterator for Fuse<I> where I: FusedIterator {\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        self.iter.last()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I>\n+    where I: DoubleEndedIterator + FusedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, fold)\n+    }\n+}\n+\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+/// An iterator that calls a function with a reference to each element before\n+/// yielding it.\n+///\n+/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`inspect`]: trait.Iterator.html#method.inspect\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n+    pub(super) iter: I,\n+    pub(super) f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Inspect\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n+    #[inline]\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n+        }\n+\n+        elt\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next_back();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item)\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item) {}"}, {"sha": "bc8760934d2ed9f3d9b77528fdce4744d032f5c0", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 18, "deletions": 2769, "changes": 2787, "blob_url": "https://github.com/rust-lang/rust/blob/aff7772a1da244af8a37c786c6c7cb87747b9d02/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff7772a1da244af8a37c786c6c7cb87747b9d02/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=aff7772a1da244af8a37c786c6c7cb87747b9d02", "patch": "@@ -306,12 +306,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use cmp;\n-use fmt;\n-use iter_private::TrustedRandomAccess;\n use ops::Try;\n-use usize;\n-use intrinsics;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::iterator::Iterator;\n@@ -343,10 +338,28 @@ pub use self::traits::FusedIterator;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Rev, Cycle, Chain, Zip, Map, Filter, FilterMap, Enumerate};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Peekable, SkipWhile, TakeWhile, Skip, Take, Scan, FlatMap};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::adapters::{Fuse, Inspect};\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+pub use self::adapters::Cloned;\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+pub use self::adapters::StepBy;\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub use self::adapters::Flatten;\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+pub use self::adapters::Copied;\n+\n+use self::adapters::{flatten_compat, ChainState, ZipImpl};\n+\n mod iterator;\n mod range;\n mod sources;\n mod traits;\n+mod adapters;\n \n /// Used to make try_fold closures more like normal loops\n #[derive(PartialEq)]\n@@ -397,2767 +410,3 @@ impl<R: Try> LoopState<R::Ok, R> {\n         }\n     }\n }\n-\n-/// A double-ended iterator with the direction inverted.\n-///\n-/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`rev`]: trait.Iterator.html#method.rev\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Rev<T> {\n-    iter: T\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth_back(n) }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.iter.try_rfold(init, f)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, f)\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-        where P: FnMut(&Self::Item) -> bool\n-    {\n-        self.iter.rfind(predicate)\n-    }\n-\n-    #[inline]\n-    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n-        P: FnMut(Self::Item) -> bool\n-    {\n-        self.iter.position(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth(n) }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.iter.try_fold(init, f)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, f)\n-    }\n-\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-        where P: FnMut(&Self::Item) -> bool\n-    {\n-        self.iter.find(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Rev<I>\n-    where I: ExactSizeIterator + DoubleEndedIterator\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Rev<I>\n-    where I: FusedIterator + DoubleEndedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Rev<I>\n-    where I: TrustedLen + DoubleEndedIterator {}\n-\n-/// An iterator that copies the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`copied`]: trait.Iterator.html#method.copied\n-/// [`Iterator`]: trait.Iterator.html\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Copied<I> {\n-    it: I,\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> Iterator for Copied<I>\n-    where I: Iterator<Item=&'a T>, T: Copy\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().copied()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.fold(init, move |acc, &elt| f(acc, elt))\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n-    where I: DoubleEndedIterator<Item=&'a T>, T: Copy\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().copied()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n-    where I: ExactSizeIterator<Item=&'a T>, T: Copy\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-impl<'a, I, T: 'a> FusedIterator for Copied<I>\n-    where I: FusedIterator<Item=&'a T>, T: Copy\n-{}\n-\n-#[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n-    }\n-\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n-    where I: TrustedLen<Item=&'a T>,\n-          T: Copy\n-{}\n-\n-/// An iterator that clones the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cloned`]: trait.Iterator.html#method.cloned\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Cloned<I> {\n-    it: I,\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> Iterator for Cloned<I>\n-    where I: Iterator<Item=&'a T>, T: Clone\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().cloned()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n-    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().cloned()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n-    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n-    where I: FusedIterator<Item=&'a T>, T: Clone\n-{}\n-\n-#[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n-{\n-    default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        self.it.get_unchecked(i).clone()\n-    }\n-\n-    #[inline]\n-    default fn may_have_side_effect() -> bool { true }\n-}\n-\n-#[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n-    }\n-\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n-    where I: TrustedLen<Item=&'a T>,\n-          T: Clone\n-{}\n-\n-/// An iterator that repeats endlessly.\n-///\n-/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cycle`]: trait.Iterator.html#method.cycle\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Cycle<I> {\n-    orig: I,\n-    iter: I,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        match self.iter.next() {\n-            None => { self.iter = self.orig.clone(); self.iter.next() }\n-            y => y\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // the cycle iterator is either empty or infinite\n-        match self.orig.size_hint() {\n-            sz @ (0, Some(0)) => sz,\n-            (0, _) => (0, None),\n-            _ => (usize::MAX, None)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n-\n-/// An iterator for stepping iterators by a custom amount.\n-///\n-/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n-/// its documentation for more.\n-///\n-/// [`step_by`]: trait.Iterator.html#method.step_by\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-#[derive(Clone, Debug)]\n-pub struct StepBy<I> {\n-    iter: I,\n-    step: usize,\n-    first_take: bool,\n-}\n-\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> Iterator for StepBy<I> where I: Iterator {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            self.iter.next()\n-        } else {\n-            self.iter.nth(self.step)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let inner_hint = self.iter.size_hint();\n-\n-        if self.first_take {\n-            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n-            (f(inner_hint.0), inner_hint.1.map(f))\n-        } else {\n-            let f = |n| n / (self.step+1);\n-            (f(inner_hint.0), inner_hint.1.map(f))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            let first = self.iter.next();\n-            if n == 0 {\n-                return first;\n-            }\n-            n -= 1;\n-        }\n-        // n and self.step are indices, we need to add 1 to get the amount of elements\n-        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n-        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n-        let mut step = self.step + 1;\n-        // n + 1 could overflow\n-        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n-        if n == usize::MAX {\n-            self.iter.nth(step - 1);\n-        } else {\n-            n += 1;\n-        }\n-\n-        // overflow handling\n-        loop {\n-            let mul = n.checked_mul(step);\n-            if unsafe { intrinsics::likely(mul.is_some()) } {\n-                return self.iter.nth(mul.unwrap() - 1);\n-            }\n-            let div_n = usize::MAX / n;\n-            let div_step = usize::MAX / step;\n-            let nth_n = div_n * n;\n-            let nth_step = div_step * step;\n-            let nth = if nth_n > nth_step {\n-                step -= div_n;\n-                nth_n\n-            } else {\n-                n -= div_step;\n-                nth_step\n-            };\n-            self.iter.nth(nth - 1);\n-        }\n-    }\n-}\n-\n-// StepBy can only make the iterator shorter, so the len will still fit.\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n-\n-/// An iterator that strings two iterators together.\n-///\n-/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`chain`]: trait.Iterator.html#method.chain\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Chain<A, B> {\n-    a: A,\n-    b: B,\n-    state: ChainState,\n-}\n-\n-// The iterator protocol specifies that iteration ends with the return value\n-// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n-// further calls return. The chain adaptor must account for this since it uses\n-// two subiterators.\n-//\n-//  It uses three states:\n-//\n-//  - Both: `a` and `b` are remaining\n-//  - Front: `a` remaining\n-//  - Back: `b` remaining\n-//\n-//  The fourth state (neither iterator is remaining) only occurs after Chain has\n-//  returned None once, so we don't need to store this state.\n-#[derive(Clone, Debug)]\n-enum ChainState {\n-    // both front and back iterator are remaining\n-    Both,\n-    // only front is remaining\n-    Front,\n-    // only back is remaining\n-    Back,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Chain<A, B> where\n-    A: Iterator,\n-    B: Iterator<Item = A::Item>\n-{\n-    type Item = A::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.a.next() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.next()\n-                }\n-            },\n-            ChainState::Front => self.a.next(),\n-            ChainState::Back => self.b.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(self) -> usize {\n-        match self.state {\n-            ChainState::Both => self.a.count() + self.b.count(),\n-            ChainState::Front => self.a.count(),\n-            ChainState::Back => self.b.count(),\n-        }\n-    }\n-\n-    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.try_fold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            _ => { }\n-        }\n-        if let ChainState::Back = self.state {\n-            accum = self.b.try_fold(accum, &mut f)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.fold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.fold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        accum\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                for x in self.a.by_ref() {\n-                    if n == 0 {\n-                        return Some(x)\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            ChainState::Back => {}\n-        }\n-        if let ChainState::Back = self.state {\n-            self.b.nth(n)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        match self.state {\n-            ChainState::Both => match self.a.find(&mut predicate) {\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.find(predicate)\n-                }\n-                v => v\n-            },\n-            ChainState::Front => self.a.find(predicate),\n-            ChainState::Back => self.b.find(predicate),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => {\n-                // Must exhaust a before b.\n-                let a_last = self.a.last();\n-                let b_last = self.b.last();\n-                b_last.or(a_last)\n-            },\n-            ChainState::Front => self.a.last(),\n-            ChainState::Back => self.b.last()\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n-\n-        let lower = a_lower.saturating_add(b_lower);\n-\n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(y),\n-            _ => None\n-        };\n-\n-        (lower, upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Chain<A, B> where\n-    A: DoubleEndedIterator,\n-    B: DoubleEndedIterator<Item=A::Item>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.b.next_back() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Front;\n-                    self.a.next_back()\n-                }\n-            },\n-            ChainState::Front => self.a.next_back(),\n-            ChainState::Back => self.b.next_back(),\n-        }\n-    }\n-\n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n-        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.try_rfold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n-                }\n-            }\n-            _ => { }\n-        }\n-        if let ChainState::Front = self.state {\n-            accum = self.a.try_rfold(accum, &mut f)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.rfold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.rfold(accum, &mut f);\n-            }\n-            _ => { }\n-        }\n-        accum\n-    }\n-\n-}\n-\n-// Note: *both* must be fused to handle double-ended iterators.\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A, B> FusedIterator for Chain<A, B>\n-    where A: FusedIterator,\n-          B: FusedIterator<Item=A::Item>,\n-{}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, B> TrustedLen for Chain<A, B>\n-    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n-{}\n-\n-/// An iterator that iterates two other iterators simultaneously.\n-///\n-/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`zip`]: trait.Iterator.html#method.zip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Zip<A, B> {\n-    a: A,\n-    b: B,\n-    // index and len are only used by the specialized version of zip\n-    index: usize,\n-    len: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n-{\n-    type Item = (A::Item, B::Item);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        ZipImpl::next(self)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        ZipImpl::size_hint(self)\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        ZipImpl::nth(self, n)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: DoubleEndedIterator + ExactSizeIterator,\n-    B: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n-        ZipImpl::next_back(self)\n-    }\n-}\n-\n-// Zip specialization trait\n-#[doc(hidden)]\n-trait ZipImpl<A, B> {\n-    type Item;\n-    fn new(a: A, b: B) -> Self;\n-    fn next(&mut self) -> Option<Self::Item>;\n-    fn size_hint(&self) -> (usize, Option<usize>);\n-    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n-    fn super_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        while let Some(x) = self.next() {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n-    }\n-    fn next_back(&mut self) -> Option<Self::Item>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator;\n-}\n-\n-// General Zip impl\n-#[doc(hidden)]\n-impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: Iterator, B: Iterator\n-{\n-    type Item = (A::Item, B::Item);\n-    default fn new(a: A, b: B) -> Self {\n-        Zip {\n-            a,\n-            b,\n-            index: 0, // unused\n-            len: 0, // unused\n-        }\n-    }\n-\n-    #[inline]\n-    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        self.a.next().and_then(|x| {\n-            self.b.next().and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n-    }\n-\n-    #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        self.super_nth(n)\n-    }\n-\n-    #[inline]\n-    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n-    {\n-        let a_sz = self.a.len();\n-        let b_sz = self.b.len();\n-        if a_sz != b_sz {\n-            // Adjust a, b to equal length\n-            if a_sz > b_sz {\n-                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n-            } else {\n-                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n-            }\n-        }\n-        match (self.a.next_back(), self.b.next_back()) {\n-            (Some(x), Some(y)) => Some((x, y)),\n-            (None, None) => None,\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n-\n-        let lower = cmp::min(a_lower, b_lower);\n-\n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n-            (Some(x), None) => Some(x),\n-            (None, Some(y)) => Some(y),\n-            (None, None) => None\n-        };\n-\n-        (lower, upper)\n-    }\n-}\n-\n-#[doc(hidden)]\n-impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: TrustedRandomAccess, B: TrustedRandomAccess\n-{\n-    fn new(a: A, b: B) -> Self {\n-        let len = cmp::min(a.len(), b.len());\n-        Zip {\n-            a,\n-            b,\n-            index: 0,\n-            len,\n-        }\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        if self.index < self.len {\n-            let i = self.index;\n-            self.index += 1;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n-        } else if A::may_have_side_effect() && self.index < self.a.len() {\n-            // match the base implementation's potential side effects\n-            unsafe {\n-                self.a.get_unchecked(self.index);\n-            }\n-            self.index += 1;\n-            None\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len - self.index;\n-        (len, Some(len))\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        let delta = cmp::min(n, self.len - self.index);\n-        let end = self.index + delta;\n-        while self.index < end {\n-            let i = self.index;\n-            self.index += 1;\n-            if A::may_have_side_effect() {\n-                unsafe { self.a.get_unchecked(i); }\n-            }\n-            if B::may_have_side_effect() {\n-                unsafe { self.b.get_unchecked(i); }\n-            }\n-        }\n-\n-        self.super_nth(n - delta)\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n-    {\n-        // Adjust a, b to equal length\n-        if A::may_have_side_effect() {\n-            let sz = self.a.len();\n-            if sz > self.len {\n-                for _ in 0..sz - cmp::max(self.len, self.index) {\n-                    self.a.next_back();\n-                }\n-            }\n-        }\n-        if B::may_have_side_effect() {\n-            let sz = self.b.len();\n-            if sz > self.len {\n-                for _ in 0..sz - self.len {\n-                    self.b.next_back();\n-                }\n-            }\n-        }\n-        if self.index < self.len {\n-            self.len -= 1;\n-            let i = self.len;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> ExactSizeIterator for Zip<A, B>\n-    where A: ExactSizeIterator, B: ExactSizeIterator {}\n-\n-#[doc(hidden)]\n-unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n-    where A: TrustedRandomAccess,\n-          B: TrustedRandomAccess,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n-        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        A::may_have_side_effect() || B::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A, B> FusedIterator for Zip<A, B>\n-    where A: FusedIterator, B: FusedIterator, {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, B> TrustedLen for Zip<A, B>\n-    where A: TrustedLen, B: TrustedLen,\n-{}\n-\n-/// An iterator that maps the values of `iter` with `f`.\n-///\n-/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map`]: trait.Iterator.html#method.map\n-/// [`Iterator`]: trait.Iterator.html\n-///\n-/// # Notes about side effects\n-///\n-/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n-/// you can also [`map`] backwards:\n-///\n-/// ```rust\n-/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n-///\n-/// assert_eq!(v, [4, 3, 2]);\n-/// ```\n-///\n-/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n-///\n-/// But if your closure has state, iterating backwards may act in a way you do\n-/// not expect. Let's go through an example. First, in the forward direction:\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) }) {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-///\n-/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n-///\n-/// Now consider this twist where we add a call to `rev`. This version will\n-/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n-/// but the values of the counter still go in order. This is because `map()` is\n-/// still being called lazily on each item, but we are popping items off the\n-/// back of the vector now, instead of shifting them from the front.\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) })\n-///                                .rev() {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Map<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Map\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.next().map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n-        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-\n-    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n-        where G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n-    F: FnMut(I::Item) -> B,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        self.iter.next_back().map(&mut self.f)\n-    }\n-\n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n-        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-\n-    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n-        where G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n-    where F: FnMut(I::Item) -> B\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n-    where F: FnMut(I::Item) -> B {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<B, I, F> TrustedLen for Map<I, F>\n-    where I: TrustedLen,\n-          F: FnMut(I::Item) -> B {}\n-\n-#[doc(hidden)]\n-unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n-    where I: TrustedRandomAccess,\n-          F: FnMut(I::Item) -> B,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        (self.f)(self.iter.get_unchecked(i))\n-    }\n-    #[inline]\n-    fn may_have_side_effect() -> bool { true }\n-}\n-\n-/// An iterator that filters the elements of `iter` with `predicate`.\n-///\n-/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter`]: trait.Iterator.html#method.filter\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Filter<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Filter\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        for x in &mut self.iter {\n-            if (self.predicate)(&x) {\n-                return Some(x);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    // this special case allows the compiler to make `.filter(_).count()`\n-    // branchless. Barring perfect branch prediction (which is unattainable in\n-    // the general case), this will be much faster in >90% of cases (containing\n-    // virtually all real workloads) and only a tiny bit slower in the rest.\n-    //\n-    // Having this specialization thus allows us to write `.filter(p).count()`\n-    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n-    // less readable and also less backwards-compatible to Rust before 1.10.\n-    //\n-    // Using the branchless version will also simplify the LLVM byte code, thus\n-    // leaving more budget for LLVM optimizations.\n-    #[inline]\n-    fn count(mut self) -> usize {\n-        let mut count = 0;\n-        for x in &mut self.iter {\n-            count += (self.predicate)(&x) as usize;\n-        }\n-        count\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut predicate = self.predicate;\n-        self.iter.fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n-    where P: FnMut(&I::Item) -> bool,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        for x in self.iter.by_ref().rev() {\n-            if (self.predicate)(&x) {\n-                return Some(x);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut predicate = self.predicate;\n-        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n-    where P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that uses `f` to both filter and map elements from `iter`.\n-///\n-/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter_map`]: trait.Iterator.html#method.filter_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct FilterMap<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FilterMap\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        for x in self.iter.by_ref() {\n-            if let Some(y) = (self.f)(x) {\n-                return Some(y);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        for x in self.iter.by_ref().rev() {\n-            if let Some(y) = (self.f)(x) {\n-                return Some(y);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B> {}\n-\n-/// An iterator that yields the current count and the element during iteration.\n-///\n-/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`enumerate`]: trait.Iterator.html#method.enumerate\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Enumerate<I> {\n-    iter: I,\n-    count: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Enumerate<I> where I: Iterator {\n-    type Item = (usize, <I as Iterator>::Item);\n-\n-    /// # Overflow Behavior\n-    ///\n-    /// The method does no guarding against overflows, so enumerating more than\n-    /// `usize::MAX` elements either produces the wrong result or panics. If\n-    /// debug assertions are enabled, a panic is guaranteed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Might panic if the index of the element overflows a `usize`.\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next().map(|a| {\n-            let ret = (self.count, a);\n-            // Possible undefined overflow.\n-            self.count += 1;\n-            ret\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        self.iter.nth(n).map(|a| {\n-            let i = self.count + n;\n-            self.count = i + 1;\n-            (i, a)\n-        })\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let count = &mut self.count;\n-        self.iter.try_fold(init, move |acc, item| {\n-            let acc = fold(acc, (*count, item));\n-            *count += 1;\n-            acc\n-        })\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut count = self.count;\n-        self.iter.fold(init, move |acc, item| {\n-            let acc = fold(acc, (count, item));\n-            count += 1;\n-            acc\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Enumerate<I> where\n-    I: ExactSizeIterator + DoubleEndedIterator\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next_back().map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[doc(hidden)]\n-unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n-    where I: TrustedRandomAccess\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n-        (self.count + i, self.iter.get_unchecked(i))\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Enumerate<I>\n-    where I: TrustedLen,\n-{}\n-\n-\n-/// An iterator with a `peek()` that returns an optional reference to the next\n-/// element.\n-///\n-/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`peekable`]: trait.Iterator.html#method.peekable\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Peekable<I: Iterator> {\n-    iter: I,\n-    /// Remember a peeked value, even if it was None.\n-    peeked: Option<Option<I::Item>>,\n-}\n-\n-// Peekable must remember if a None has been seen in the `.peek()` method.\n-// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n-// underlying iterator at most once. This does not by itself make the iterator\n-// fused.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> Iterator for Peekable<I> {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(v) => v,\n-            None => self.iter.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(mut self) -> usize {\n-        match self.peeked.take() {\n-            Some(None) => 0,\n-            Some(Some(_)) => 1 + self.iter.count(),\n-            None => self.iter.count(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(None) => None,\n-            Some(v @ Some(_)) if n == 0 => v,\n-            Some(Some(_)) => self.iter.nth(n - 1),\n-            None => self.iter.nth(n),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        let peek_opt = match self.peeked.take() {\n-            Some(None) => return None,\n-            Some(v) => v,\n-            None => None,\n-        };\n-        self.iter.last().or(peek_opt)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let peek_len = match self.peeked {\n-            Some(None) => return (0, Some(0)),\n-            Some(Some(_)) => 1,\n-            None => 0,\n-        };\n-        let (lo, hi) = self.iter.size_hint();\n-        let lo = lo.saturating_add(peek_len);\n-        let hi = hi.and_then(|x| x.checked_add(peek_len));\n-        (lo, hi)\n-    }\n-\n-    #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        let acc = match self.peeked.take() {\n-            Some(None) => return Try::from_ok(init),\n-            Some(Some(v)) => f(init, v)?,\n-            None => init,\n-        };\n-        self.iter.try_fold(acc, f)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let acc = match self.peeked {\n-            Some(None) => return init,\n-            Some(Some(v)) => fold(init, v),\n-            None => init,\n-        };\n-        self.iter.fold(acc, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n-\n-impl<I: Iterator> Peekable<I> {\n-    /// Returns a reference to the next() value without advancing the iterator.\n-    ///\n-    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n-    /// But if the iteration is over, `None` is returned.\n-    ///\n-    /// [`next`]: trait.Iterator.html#tymethod.next\n-    ///\n-    /// Because `peek()` returns a reference, and many iterators iterate over\n-    /// references, there can be a possibly confusing situation where the\n-    /// return value is a double reference. You can see this effect in the\n-    /// examples below.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let xs = [1, 2, 3];\n-    ///\n-    /// let mut iter = xs.iter().peekable();\n-    ///\n-    /// // peek() lets us see into the future\n-    /// assert_eq!(iter.peek(), Some(&&1));\n-    /// assert_eq!(iter.next(), Some(&1));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&2));\n-    ///\n-    /// // The iterator does not advance even if we `peek` multiple times\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&3));\n-    ///\n-    /// // After the iterator is finished, so is `peek()`\n-    /// assert_eq!(iter.peek(), None);\n-    /// assert_eq!(iter.next(), None);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&mut self) -> Option<&I::Item> {\n-        let iter = &mut self.iter;\n-        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n-    }\n-}\n-\n-/// An iterator that rejects elements while `predicate` is true.\n-///\n-/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip_while`]: trait.Iterator.html#method.skip_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct SkipWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"SkipWhile\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"flag\", &self.flag)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n-    where P: FnMut(&I::Item) -> bool\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        let flag = &mut self.flag;\n-        let pred = &mut self.predicate;\n-        self.iter.find(move |x| {\n-            if *flag || !pred(x) {\n-                *flag = true;\n-                true\n-            } else {\n-                false\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v)?,\n-                None => return Try::from_ok(init),\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v),\n-                None => return init,\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for SkipWhile<I, P>\n-    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that only accepts elements while `predicate` is true.\n-///\n-/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take_while`]: trait.Iterator.html#method.take_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct TakeWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"TakeWhile\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"flag\", &self.flag)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n-    where P: FnMut(&I::Item) -> bool\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.flag {\n-            None\n-        } else {\n-            self.iter.next().and_then(|x| {\n-                if (self.predicate)(&x) {\n-                    Some(x)\n-                } else {\n-                    self.flag = true;\n-                    None\n-                }\n-            })\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.flag {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper) // can't know a lower bound, due to the predicate\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.flag {\n-            Try::from_ok(init)\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, move |acc, x|{\n-                if p(&x) {\n-                    LoopState::from_try(fold(acc, x))\n-                } else {\n-                    *flag = true;\n-                    LoopState::Break(Try::from_ok(acc))\n-                }\n-            }).into_try()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for TakeWhile<I, P>\n-    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that skips over `n` elements of `iter`.\n-///\n-/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip`]: trait.Iterator.html#method.skip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Skip<I> {\n-    iter: I,\n-    n: usize\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Skip<I> where I: Iterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.next()\n-        } else {\n-            let old_n = self.n;\n-            self.n = 0;\n-            self.iter.nth(old_n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // Can't just add n + self.n due to overflow.\n-        if self.n == 0 {\n-            self.iter.nth(n)\n-        } else {\n-            let to_skip = self.n;\n-            self.n = 0;\n-            // nth(n) skips n+1\n-            if self.iter.nth(to_skip-1).is_none() {\n-                return None;\n-            }\n-            self.iter.nth(n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count().saturating_sub(self.n)\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.last()\n-        } else {\n-            let next = self.next();\n-            if next.is_some() {\n-                // recurse. n should be 0.\n-                self.last().or(next)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = lower.saturating_sub(self.n);\n-        let upper = upper.map(|x| x.saturating_sub(self.n));\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let n = self.n;\n-        self.n = 0;\n-        if n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(n - 1).is_none() {\n-                return Try::from_ok(init);\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return init;\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n-impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.len() > 0 {\n-            self.iter.next_back()\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let mut n = self.len();\n-        if n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            self.iter.try_rfold(init, move |acc, x| {\n-                n -= 1;\n-                let r = fold(acc, x);\n-                if n == 0 { LoopState::Break(r) }\n-                else { LoopState::from_try(r) }\n-            }).into_try()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n-\n-/// An iterator that only iterates over the first `n` iterations of `iter`.\n-///\n-/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take`]: trait.Iterator.html#method.take\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Take<I> {\n-    iter: I,\n-    n: usize\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Take<I> where I: Iterator{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.n != 0 {\n-            self.n -= 1;\n-            self.iter.next()\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.n > n {\n-            self.n -= n + 1;\n-            self.iter.nth(n)\n-        } else {\n-            if self.n > 0 {\n-                self.iter.nth(self.n - 1);\n-                self.n = 0;\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.n == 0 {\n-            return (0, Some(0));\n-        }\n-\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = cmp::min(lower, self.n);\n-\n-        let upper = match upper {\n-            Some(x) if x < self.n => Some(x),\n-            _ => Some(self.n)\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, move |acc, x| {\n-                *n -= 1;\n-                let r = fold(acc, x);\n-                if *n == 0 { LoopState::Break(r) }\n-                else { LoopState::from_try(r) }\n-            }).into_try()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n-\n-/// An iterator to maintain state while iterating another iterator.\n-///\n-/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`scan`]: trait.Iterator.html#method.scan\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Scan<I, St, F> {\n-    iter: I,\n-    f: F,\n-    state: St,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Scan\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"state\", &self.state)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I, St, F> Iterator for Scan<I, St, F> where\n-    I: Iterator,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the scan function\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let state = &mut self.state;\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, x| {\n-            match f(state, x) {\n-                None => LoopState::Break(Try::from_ok(acc)),\n-                Some(x) => LoopState::from_try(fold(acc, x)),\n-            }\n-        }).into_try()\n-    }\n-}\n-\n-/// An iterator that maps each element to an iterator, and yields the elements\n-/// of the produced iterators.\n-///\n-/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`flat_map`]: trait.Iterator.html#method.flat_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct FlatMap<I, U: IntoIterator, F> {\n-    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n-    where <U as IntoIterator>::IntoIter: Clone\n-{\n-    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n-    where U::IntoIter: fmt::Debug\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n-          U: IntoIterator,\n-          U::IntoIter: DoubleEndedIterator\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.rfold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n-\n-/// An iterator that flattens one level of nesting in an iterator of things\n-/// that can be turned into iterators.\n-///\n-/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`flatten`]: trait.Iterator.html#method.flatten\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-pub struct Flatten<I: Iterator>\n-where I::Item: IntoIterator {\n-    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> fmt::Debug for Flatten<I>\n-    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> Clone for Flatten<I>\n-    where I: Iterator + Clone, U: Iterator + Clone,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n-{\n-    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> Iterator for Flatten<I>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> DoubleEndedIterator for Flatten<I>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.rfold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> FusedIterator for Flatten<I>\n-    where I: FusedIterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n-\n-/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n-fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n-    FlattenCompat { iter, frontiter: None, backiter: None }\n-}\n-\n-/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n-/// this type.\n-#[derive(Clone, Debug)]\n-struct FlattenCompat<I, U> {\n-    iter: I,\n-    frontiter: Option<U>,\n-    backiter: Option<U>,\n-}\n-\n-impl<I, U> Iterator for FlattenCompat<I, U>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> {\n-        loop {\n-            if let Some(ref mut inner) = self.frontiter {\n-                if let elt@Some(_) = inner.next() { return elt }\n-            }\n-            match self.iter.next() {\n-                None => return self.backiter.as_mut().and_then(|it| it.next()),\n-                Some(inner) => self.frontiter = Some(inner.into_iter()),\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let lo = flo.saturating_add(blo);\n-        match (self.iter.size_hint(), fhi, bhi) {\n-            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n-            _ => (lo, None)\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if let Some(ref mut front) = self.frontiter {\n-            init = front.try_fold(init, &mut fold)?;\n-        }\n-        self.frontiter = None;\n-\n-        {\n-            let frontiter = &mut self.frontiter;\n-            init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_fold(acc, &mut fold);\n-                *frontiter = Some(mid);\n-                r\n-            })?;\n-        }\n-        self.frontiter = None;\n-\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_fold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n-        Try::from_ok(init)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.frontiter.into_iter()\n-            .chain(self.iter.map(IntoIterator::into_iter))\n-            .chain(self.backiter)\n-            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n-    }\n-}\n-\n-impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> {\n-        loop {\n-            if let Some(ref mut inner) = self.backiter {\n-                if let elt@Some(_) = inner.next_back() { return elt }\n-            }\n-            match self.iter.next_back() {\n-                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n-                next => self.backiter = next.map(IntoIterator::into_iter),\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_rfold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n-        {\n-            let backiter = &mut self.backiter;\n-            init = self.iter.try_rfold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_rfold(acc, &mut fold);\n-                *backiter = Some(mid);\n-                r\n-            })?;\n-        }\n-        self.backiter = None;\n-\n-        if let Some(ref mut front) = self.frontiter {\n-            init = front.try_rfold(init, &mut fold)?;\n-        }\n-        self.frontiter = None;\n-\n-        Try::from_ok(init)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.frontiter.into_iter()\n-            .chain(self.iter.map(IntoIterator::into_iter))\n-            .chain(self.backiter)\n-            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n-    }\n-}\n-\n-/// An iterator that yields `None` forever after the underlying iterator\n-/// yields `None` once.\n-///\n-/// This `struct` is created by the [`fuse`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`fuse`]: trait.Iterator.html#method.fuse\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Fuse<I> {\n-    iter: I,\n-    done: bool\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Fuse<I> where I: Iterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let next = self.iter.next();\n-            self.done = next.is_none();\n-            next\n-        }\n-    }\n-\n-    #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let nth = self.iter.nth(n);\n-            self.done = nth.is_none();\n-            nth\n-        }\n-    }\n-\n-    #[inline]\n-    default fn last(self) -> Option<I::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            self.iter.last()\n-        }\n-    }\n-\n-    #[inline]\n-    default fn count(self) -> usize {\n-        if self.done {\n-            0\n-        } else {\n-            self.iter.count()\n-        }\n-    }\n-\n-    #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.done {\n-            (0, Some(0))\n-        } else {\n-            self.iter.size_hint()\n-        }\n-    }\n-\n-    #[inline]\n-    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.done {\n-            Try::from_ok(init)\n-        } else {\n-            let acc = self.iter.try_fold(init, fold)?;\n-            self.done = true;\n-            Try::from_ok(acc)\n-        }\n-    }\n-\n-    #[inline]\n-    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.done {\n-            init\n-        } else {\n-            self.iter.fold(init, fold)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n-    #[inline]\n-    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let next = self.iter.next_back();\n-            self.done = next.is_none();\n-            next\n-        }\n-    }\n-\n-    #[inline]\n-    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if self.done {\n-            Try::from_ok(init)\n-        } else {\n-            let acc = self.iter.try_rfold(init, fold)?;\n-            self.done = true;\n-            Try::from_ok(acc)\n-        }\n-    }\n-\n-    #[inline]\n-    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.done {\n-            init\n-        } else {\n-            self.iter.rfold(init, fold)\n-        }\n-    }\n-}\n-\n-unsafe impl<I> TrustedRandomAccess for Fuse<I>\n-    where I: TrustedRandomAccess,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n-        self.iter.get_unchecked(i)\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> Iterator for Fuse<I> where I: FusedIterator {\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        self.iter.nth(n)\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<I::Item> {\n-        self.iter.last()\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I>\n-    where I: DoubleEndedIterator + FusedIterator\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next_back()\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.iter.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, fold)\n-    }\n-}\n-\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-/// An iterator that calls a function with a reference to each element before\n-/// yielding it.\n-///\n-/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`inspect`]: trait.Iterator.html#method.inspect\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Inspect<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Inspect\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n-    }\n-}\n-\n-impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n-    #[inline]\n-    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n-        if let Some(ref a) = elt {\n-            (self.f)(a);\n-        }\n-\n-        elt\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next_back();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item)\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item) {}"}]}