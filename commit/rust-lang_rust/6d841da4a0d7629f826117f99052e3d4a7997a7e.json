{"sha": "6d841da4a0d7629f826117f99052e3d4a7997a7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkODQxZGE0YTBkNzYyOWY4MjYxMTdmOTkwNTJlM2Q0YTc5OTdhN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T11:50:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T11:50:40Z"}, "message": "Auto merge of #39999 - bitshifter:struct_align, r=eddyb\n\nImplementation of repr struct alignment RFC 1358.\n\nThe main changes around rustc::ty::Layout::struct:\n* Added abi_align field which stores abi alignment before repr align is applied\n* align field contains transitive repr alignment\n* Added padding vec which stores padding required after fields\n\nThe main user of this information is rustc_trans::adt::struct_llfields\nwhich determines the LLVM fields to be used by LLVM, including padding\nfields.\n\nA possible future optimisation would be to put the padding Vec in an Option, since it will be unused unless you are using repr align.", "tree": {"sha": "27e04604a86c867e8146bf75ff0c1ea973aaf47c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27e04604a86c867e8146bf75ff0c1ea973aaf47c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d841da4a0d7629f826117f99052e3d4a7997a7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d841da4a0d7629f826117f99052e3d4a7997a7e", "html_url": "https://github.com/rust-lang/rust/commit/6d841da4a0d7629f826117f99052e3d4a7997a7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d841da4a0d7629f826117f99052e3d4a7997a7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff13b7c91813eb178c98a7abc661acaf5c41dc31", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff13b7c91813eb178c98a7abc661acaf5c41dc31", "html_url": "https://github.com/rust-lang/rust/commit/ff13b7c91813eb178c98a7abc661acaf5c41dc31"}, {"sha": "946f8e6a59242a8112c6983d1336fef54bc55b9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/946f8e6a59242a8112c6983d1336fef54bc55b9a", "html_url": "https://github.com/rust-lang/rust/commit/946f8e6a59242a8112c6983d1336fef54bc55b9a"}], "stats": {"total": 778, "additions": 692, "deletions": 86}, "files": [{"sha": "ee4e568a5ca9af263cd3fc50537d3cd18b652a1b", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -72,6 +72,7 @@\n     - [proc_macro](language-features/proc-macro.md)\n     - [quote](language-features/quote.md)\n     - [relaxed_adts](language-features/relaxed-adts.md)\n+    - [repr_align](language-features/repr-align.md)\n     - [repr_simd](language-features/repr-simd.md)\n     - [rustc_attrs](language-features/rustc-attrs.md)\n     - [rustc_diagnostic_macros](language-features/rustc-diagnostic-macros.md)"}, {"sha": "deea04f4c51cc7525328b0844034bebe1e603430", "filename": "src/doc/unstable-book/src/language-features/repr-align.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align.md?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -0,0 +1,11 @@\n+# `repr_align`\n+\n+The tracking issue for this feature is: [#33626]\n+\n+[#33626]: https://github.com/rust-lang/rust/issues/33626\n+\n+------------------------\n+\n+\n+\n+"}, {"sha": "2851191dc141a1373b04dbe78093f45245642686", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -1847,5 +1847,6 @@ register_diagnostics! {\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n-    E0566  // conflicting representation hints\n+    E0566, // conflicting representation hints\n+    E0587, // conflicting packed and align representation hints\n }"}, {"sha": "bf292ccb8d86d064212c1d33c40e56b90c0c144a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -57,6 +57,9 @@ impl<'a> CheckAttrVisitor<'a> {\n         };\n \n         let mut conflicting_reprs = 0;\n+        let mut found_packed = false;\n+        let mut found_align = false;\n+\n         for word in words {\n \n             let name = match word.name() {\n@@ -84,6 +87,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                                 (\"attribute should be applied to struct or union\",\n                                  \"a struct or union\")\n                     } else {\n+                        found_packed = true;\n                         continue\n                     }\n                 }\n@@ -96,6 +100,15 @@ impl<'a> CheckAttrVisitor<'a> {\n                         continue\n                     }\n                 }\n+                \"align\" => {\n+                    found_align = true;\n+                    if target != Target::Struct {\n+                        (\"attribute should be applied to struct\",\n+                         \"a struct\")\n+                    } else {\n+                        continue\n+                    }\n+                }\n                 \"i8\" | \"u8\" | \"i16\" | \"u16\" |\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n@@ -117,6 +130,10 @@ impl<'a> CheckAttrVisitor<'a> {\n             span_warn!(self.sess, attr.span, E0566,\n                        \"conflicting representation hints\");\n         }\n+        if found_align && found_packed {\n+            struct_span_err!(self.sess, attr.span, E0587,\n+                             \"conflicting packed and align representation hints\").emit();\n+        }\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {"}, {"sha": "6a206640b3baa0233e71bfbc15e794f61ab5c388", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -548,8 +548,12 @@ pub type FieldPath = Vec<u32>;\n /// A structure, a product type in ADT terms.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Struct {\n+    /// Maximum alignment of fields and repr alignment.\n     pub align: Align,\n \n+    /// Primitive alignment of fields without repr alignment.\n+    pub primitive_align: Align,\n+\n     /// If true, no alignment padding is used.\n     pub packed: bool,\n \n@@ -583,10 +587,20 @@ impl<'a, 'gcx, 'tcx> Struct {\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n                   repr: &ReprOptions, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = repr.packed();\n+        if repr.packed() && repr.align > 0 {\n+            bug!(\"Struct cannot be packed and aligned\");\n+        }\n+\n+        let align = if repr.packed() {\n+            dl.i8_align\n+        } else {\n+            dl.aggregate_align\n+        };\n+\n         let mut ret = Struct {\n-            align: if packed { dl.i8_align } else { dl.aggregate_align },\n-            packed: packed,\n+            align: align,\n+            primitive_align: align,\n+            packed: repr.packed(),\n             sized: true,\n             offsets: vec![],\n             memory_index: vec![],\n@@ -660,7 +674,9 @@ impl<'a, 'gcx, 'tcx> Struct {\n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n             if !ret.packed {\n                 let align = field.align(dl);\n+                let primitive_align = field.primitive_align(dl);\n                 ret.align = ret.align.max(align);\n+                ret.primitive_align = ret.primitive_align.max(primitive_align);\n                 offset = offset.abi_align(align);\n             }\n \n@@ -671,6 +687,11 @@ impl<'a, 'gcx, 'tcx> Struct {\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n+        if repr.align > 0 {\n+            let repr_align = repr.align as u64;\n+            ret.align = ret.align.max(Align::from_bytes(repr_align, repr_align).unwrap());\n+            debug!(\"Struct::new repr_align: {:?}\", repr_align);\n+        }\n \n         debug!(\"Struct::new min_size: {:?}\", offset);\n         ret.min_size = offset;\n@@ -836,12 +857,23 @@ impl<'a, 'gcx, 'tcx> Struct {\n         }\n         Ok(None)\n     }\n+\n+    pub fn over_align(&self) -> Option<u32> {\n+        let align = self.align.abi();\n+        let primitive_align = self.primitive_align.abi();\n+        if align > primitive_align {\n+            Some(align as u32)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// An untagged union.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Union {\n     pub align: Align,\n+    pub primitive_align: Align,\n \n     pub min_size: Size,\n \n@@ -851,8 +883,10 @@ pub struct Union {\n \n impl<'a, 'gcx, 'tcx> Union {\n     fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+        let align = if packed { dl.i8_align } else { dl.aggregate_align };\n         Union {\n-            align: if packed { dl.i8_align } else { dl.aggregate_align },\n+            align: align,\n+            primitive_align: align,\n             min_size: Size::from_bytes(0),\n             packed: packed,\n         }\n@@ -875,6 +909,7 @@ impl<'a, 'gcx, 'tcx> Union {\n \n             if !self.packed {\n                 self.align = self.align.max(field.align(dl));\n+                self.primitive_align = self.primitive_align.max(field.primitive_align(dl));\n             }\n             self.min_size = cmp::max(self.min_size, field.size(dl));\n         }\n@@ -888,6 +923,16 @@ impl<'a, 'gcx, 'tcx> Union {\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n+\n+    pub fn over_align(&self) -> Option<u32> {\n+        let align = self.align.abi();\n+        let primitive_align = self.primitive_align.abi();\n+        if align > primitive_align {\n+            Some(align as u32)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// The first half of a fat pointer.\n@@ -924,6 +969,7 @@ pub enum Layout {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n         align: Align,\n+        primitive_align: Align,\n         element_size: Size,\n         count: u64\n     },\n@@ -970,7 +1016,8 @@ pub enum Layout {\n         discr: Integer,\n         variants: Vec<Struct>,\n         size: Size,\n-        align: Align\n+        align: Align,\n+        primitive_align: Align,\n     },\n \n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n@@ -1118,6 +1165,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: true,\n                     align: element.align(dl),\n+                    primitive_align: element.primitive_align(dl),\n                     element_size: element_size,\n                     count: count\n                 }\n@@ -1127,6 +1175,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: false,\n                     align: element.align(dl),\n+                    primitive_align: element.primitive_align(dl),\n                     element_size: element.size(dl),\n                     count: 0\n                 }\n@@ -1135,6 +1184,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Array {\n                     sized: false,\n                     align: dl.i8_align,\n+                    primitive_align: dl.i8_align,\n                     element_size: Size::from_bytes(1),\n                     count: 0\n                 }\n@@ -1340,6 +1390,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 assert!(discr_max >= 0);\n                 let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n                 let mut align = dl.aggregate_align;\n+                let mut primitive_align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n \n                 // We're interested in the smallest alignment, so start large.\n@@ -1369,6 +1420,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n                     size = cmp::max(size, st.min_size);\n                     align = align.max(st.align);\n+                    primitive_align = primitive_align.max(st.primitive_align);\n                     Ok(st)\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n@@ -1435,7 +1487,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     discr: ity,\n                     variants: variants,\n                     size: size,\n-                    align: align\n+                    align: align,\n+                    primitive_align: primitive_align\n                 }\n             }\n \n@@ -1557,6 +1610,30 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n+    /// Returns alignment before repr alignment is applied\n+    pub fn primitive_align(&self, dl: &TargetDataLayout) -> Align {\n+        match *self {\n+            Array { primitive_align, .. } | General { primitive_align, .. } => primitive_align,\n+            Univariant { ref variant, .. } |\n+            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+                variant.primitive_align\n+            },\n+\n+            _ => self.align(dl)\n+        }\n+    }\n+\n+    /// Returns repr alignment if it is greater than the primitive alignment.\n+    pub fn over_align(&self, dl: &TargetDataLayout) -> Option<u32> {\n+        let align = self.align(dl);\n+        let primitive_align = self.primitive_align(dl);\n+        if align.abi() > primitive_align.abi() {\n+            Some(align.abi() as u32)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn field_offset<C: HasDataLayout>(&self,\n                                           cx: C,\n                                           i: usize,"}, {"sha": "5be73542b931dd5a73c17c4c761ba2a8e4b7fe9e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -37,6 +37,7 @@ use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n+use std::cmp;\n use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -1470,10 +1471,12 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n+    pub align: u16,\n     pub flags: ReprFlags,\n }\n \n impl_stable_hash_for!(struct ReprOptions {\n+    align,\n     int,\n     flags\n });\n@@ -1482,7 +1485,7 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-\n+        let mut max_align = 0;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n                 flags.insert(match r {\n@@ -1493,6 +1496,10 @@ impl ReprOptions {\n                         size = Some(i);\n                         ReprFlags::empty()\n                     },\n+                    attr::ReprAlign(align) => {\n+                        max_align = cmp::max(align, max_align);\n+                        ReprFlags::empty()\n+                    },\n                 });\n             }\n         }\n@@ -1506,7 +1513,7 @@ impl ReprOptions {\n         if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.item_path_str(did))) {\n             flags.insert(ReprFlags::IS_LINEAR);\n         }\n-        ReprOptions { int: size, flags: flags }\n+        ReprOptions { int: size, align: max_align, flags: flags }\n     }\n \n     #[inline]"}, {"sha": "998e392b1f9078ac78dc68e4746666e8d0309e2e", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -553,7 +553,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(ty, \"abi_cast\");\n+                let llscratch = bcx.alloca(ty, \"abi_cast\", None);\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value..."}, {"sha": "d1c1dd7436a5ba5fae0ea61492cb6ddf22cc4bb2", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 66, "deletions": 25, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -90,12 +90,12 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    generic_type_of(cx, t, None, false, false)\n+    generic_type_of(cx, t, None)\n }\n \n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     t: Ty<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, t, Some(name), false, false)\n+    generic_type_of(cx, t, Some(name))\n }\n \n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -114,7 +114,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 _ => unreachable!()\n             };\n             let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant, false, false),\n+            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant),\n                                  packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n@@ -123,12 +123,9 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              t: Ty<'tcx>,\n-                             name: Option<&str>,\n-                             sizing: bool,\n-                             dst: bool) -> Type {\n+                             name: Option<&str>) -> Type {\n     let l = cx.layout_of(t);\n-    debug!(\"adt::generic_type_of t: {:?} name: {:?} sizing: {} dst: {}\",\n-           t, name, sizing, dst);\n+    debug!(\"adt::generic_type_of t: {:?} name: {:?}\", t, name);\n     match *l {\n         layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n         layout::RawNullablePointer { nndiscr, .. } => {\n@@ -148,11 +145,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull, sizing, dst),\n+                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n-                    assert_eq!(sizing, false);\n                     Type::named_struct(cx, name)\n                 }\n             }\n@@ -163,13 +159,12 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, &fields, &variant, sizing, dst);\n+                    let fields = struct_llfields(cx, &fields, &variant);\n                     Type::struct_(cx, &fields, variant.packed)\n                 }\n                 Some(name) => {\n                     // Hypothesis: named_struct's can never need a\n                     // drop flag. (... needs validation.)\n-                    assert_eq!(sizing, false);\n                     Type::named_struct(cx, name)\n                 }\n             }\n@@ -190,7 +185,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        layout::General { discr, size, align, .. } => {\n+        layout::General { discr, size, align, primitive_align, .. } => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -203,14 +198,15 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             let size = size.bytes();\n             let align = align.abi();\n+            let primitive_align = primitive_align.abi();\n             assert!(align <= std::u32::MAX as u64);\n             let discr_ty = Type::from_integer(cx, discr);\n             let discr_size = discr.size().bytes();\n             let padded_discr_size = roundup(discr_size, align as u32);\n             let variant_part_size = size-padded_discr_size;\n-            let variant_fill = union_fill(cx, variant_part_size, align);\n+            let variant_fill = union_fill(cx, variant_part_size, primitive_align);\n \n-            assert_eq!(machine::llalign_of_min(cx, variant_fill), align as u32);\n+            assert_eq!(machine::llalign_of_min(cx, variant_fill), primitive_align as u32);\n             assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n             let fields: Vec<Type> =\n                 [discr_ty,\n@@ -245,15 +241,60 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n }\n \n \n-fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n-                             variant: &layout::Struct,\n-                             sizing: bool, _dst: bool) -> Vec<Type> {\n-    let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n-    if sizing {\n-        bug!()\n+// Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n+fn struct_llfields_path(discrfield: &layout::FieldPath) -> Vec<usize> {\n+    discrfield.iter().map(|&i| (i as usize) << 1).collect::<Vec<_>>()\n+}\n+\n+\n+// Lookup `Struct::memory_index` and double it to account for padding\n+pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n+    (variant.memory_index[index] as usize) << 1\n+}\n+\n+\n+pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, field_tys: &Vec<Ty<'tcx>>,\n+                             variant: &layout::Struct) -> Vec<Type> {\n+    debug!(\"struct_llfields: variant: {:?}\", variant);\n+    let mut first_field = true;\n+    let mut min_offset = 0;\n+    let mut result: Vec<Type> = Vec::with_capacity(field_tys.len() * 2);\n+    let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n+        (i, field_tys[i as usize], variant.offsets[i as usize].bytes()) });\n+    for (index, ty, target_offset) in field_iter {\n+        if first_field {\n+            debug!(\"struct_llfields: {} ty: {} min_offset: {} target_offset: {}\",\n+                index, ty, min_offset, target_offset);\n+            first_field = false;\n+        } else {\n+            assert!(target_offset >= min_offset);\n+            let padding_bytes = if variant.packed { 0 } else { target_offset - min_offset };\n+            result.push(Type::array(&Type::i8(cx), padding_bytes));\n+            debug!(\"struct_llfields: {} ty: {} pad_bytes: {} min_offset: {} target_offset: {}\",\n+                index, ty, padding_bytes, min_offset, target_offset);\n+        }\n+        let llty = type_of::in_memory_type_of(cx, ty);\n+        result.push(llty);\n+        let layout = cx.layout_of(ty);\n+        let target_size = layout.size(&cx.tcx().data_layout).bytes();\n+        min_offset = target_offset + target_size;\n+    }\n+    if variant.sized && !field_tys.is_empty() {\n+        if variant.stride().bytes() < min_offset {\n+            bug!(\"variant: {:?} stride: {} min_offset: {}\", variant, variant.stride().bytes(),\n+            min_offset);\n+        }\n+        let padding_bytes = variant.stride().bytes() - min_offset;\n+        debug!(\"struct_llfields: pad_bytes: {} min_offset: {} min_size: {} stride: {}\\n\",\n+               padding_bytes, min_offset, variant.min_size.bytes(), variant.stride().bytes());\n+        result.push(Type::array(&Type::i8(cx), padding_bytes));\n+        assert!(result.len() == (field_tys.len() * 2));\n     } else {\n-        fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n+        debug!(\"struct_llfields: min_offset: {} min_size: {} stride: {}\\n\",\n+               min_offset, variant.min_size.bytes(), variant.stride().bytes());\n     }\n+\n+    result\n }\n \n pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n@@ -309,8 +350,8 @@ fn struct_wrapped_nullable_bitdiscr(\n     scrutinee: ValueRef,\n     alignment: Alignment,\n ) -> ValueRef {\n-    let llptrptr = bcx.gepi(scrutinee,\n-        &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>());\n+    let path = struct_llfields_path(discrfield);\n+    let llptrptr = bcx.gepi(scrutinee, &path);\n     let llptr = bcx.load(llptrptr, alignment.to_align());\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n@@ -380,7 +421,7 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n                     let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {\n-                    let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n+                    let path = struct_llfields_path(discrfield);\n                     let llptrptr = bcx.gepi(val, &path);\n                     let llptrty = val_ty(llptrptr).element_type();\n                     bcx.store(C_null(llptrty), llptrptr, None);"}, {"sha": "5103ca5c5e1094ef94b66bbbe65a497e07f21cd7", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -477,24 +477,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+    pub fn alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n         let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        builder.dynamic_alloca(ty, name)\n+        builder.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n-            if name.is_empty() {\n+            let alloca = if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n                 let name = CString::new(name).unwrap();\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n                                       name.as_ptr())\n+            };\n+            if let Some(align) = align {\n+                llvm::LLVMSetAlignment(alloca, align as c_uint);\n             }\n+            alloca\n         }\n     }\n "}, {"sha": "54e20f590c6718350bd22c1b4326402202f4cc63", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -778,7 +778,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.alloca(i64p, \"slot\");\n+        let slot = bcx.alloca(i64p, \"slot\", None);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n "}, {"sha": "d94d7f4430bf006bfb0ed196e888c24e42e06c8b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -15,6 +15,7 @@ use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n+use adt;\n use base::{self, Lifetime};\n use callee;\n use builder::Builder;\n@@ -177,7 +178,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\");\n+                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\", None);\n                             self.store_operand(&bcx, llscratch, None, op);\n                             llscratch\n                         }\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n+                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n                     self.store_operand(bcx, llscratch, None, op);\n                     (llscratch, Alignment::AbiAligned, true)\n                 } else {\n@@ -642,7 +643,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n+                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n                 base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n                 (llscratch, Alignment::AbiAligned, true)\n             }\n@@ -711,7 +712,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bug!(\"Not a tuple.\");\n                 };\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(llval, v.memory_index[n] as usize);\n+                    let mut elem = bcx.extract_value(\n+                        llval, adt::struct_llfields_index(v, n));\n                     // Truncate bools to i1, if needed\n                     if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n                         elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n@@ -750,7 +752,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.alloca(llretty, \"personalityslot\");\n+            let slot = bcx.alloca(llretty, \"personalityslot\", None);\n             self.llpersonalityslot = Some(slot);\n             slot\n         }"}, {"sha": "88e46b5c99a44186a4a033e4ff630544049555c1", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -97,7 +97,8 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, ty);\n-        let tmp = bcx.alloca(type_of::type_of(bcx.ccx, ty), name);\n+        let tmp = bcx.alloca(\n+            type_of::type_of(bcx.ccx, ty), name, bcx.ccx.over_align_of(ty));\n         assert!(!ty.has_param_types());\n         Self::new_sized_ty(tmp, ty, Alignment::AbiAligned)\n     }\n@@ -131,11 +132,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let alignment = self.alignment | Alignment::from_packed(st.packed);\n \n+        let llfields = adt::struct_llfields(ccx, fields, st);\n         let ptr_val = if needs_cast {\n-            let fields = st.field_index_by_increasing_offset().map(|i| {\n-                type_of::in_memory_type_of(ccx, fields[i])\n-            }).collect::<Vec<_>>();\n-            let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n+            let real_ty = Type::struct_(ccx, &llfields[..], st.packed);\n             bcx.pointercast(self.llval, real_ty.ptr_to())\n         } else {\n             self.llval\n@@ -147,14 +146,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   * Field is sized - pointer is properly aligned already\n         if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n             bcx.ccx.shared().type_is_sized(fty) {\n-                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n+                return (bcx.struct_gep(\n+                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n             }\n \n         // If the type of the last field is [T] or str, then we don't need to do\n         // any adjusments\n         match fty.sty {\n             ty::TySlice(..) | ty::TyStr => {\n-                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n+                return (bcx.struct_gep(\n+                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n             }\n             _ => ()\n         }\n@@ -163,7 +164,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         if !self.has_extra() {\n             debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n                 ix, Value(ptr_val));\n-            return (bcx.struct_gep(ptr_val, ix), alignment);\n+            return (bcx.struct_gep(ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n         }\n \n         // We need to get the pointer manually now."}, {"sha": "d39a91405c1854a3cc2a8063e43ef35bcbbc6b4d", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -524,7 +524,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n+                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\", None);\n                 bcx.store(llval, alloc, None);\n                 alloc\n             } else {"}, {"sha": "6889b5064b649a9bf0098566e73503b256bd3943", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -15,6 +15,7 @@ use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n+use adt;\n use base;\n use common::{self, CrateContext, C_null};\n use builder::Builder;\n@@ -134,6 +135,12 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 if common::val_ty(elem) == Type::i1(bcx.ccx) {\n                     elem = bcx.zext(elem, Type::i8(bcx.ccx));\n                 }\n+                let layout = bcx.ccx.layout_of(self.ty);\n+                let i = if let Layout::Univariant { ref variant, .. } = *layout {\n+                    adt::struct_llfields_index(variant, i)\n+                } else {\n+                    i\n+                };\n                 llpair = bcx.insert_value(llpair, elem, i);\n             }\n             self.val = OperandValue::Immediate(llpair);\n@@ -183,14 +190,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             let (lldata, llextra) = base::load_fat_ptr(bcx, llval, align, ty);\n             OperandValue::Pair(lldata, llextra)\n         } else if common::type_is_imm_pair(bcx.ccx, ty) {\n-            let f_align = match *bcx.ccx.layout_of(ty) {\n-                Layout::Univariant { ref variant, .. } =>\n-                    Alignment::from_packed(variant.packed) | align,\n-                _ => align\n+            let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(ty) {\n+                Layout::Univariant { ref variant, .. } => {\n+                    (adt::struct_llfields_index(variant, 0),\n+                    adt::struct_llfields_index(variant, 1),\n+                    Alignment::from_packed(variant.packed) | align)\n+                },\n+                _ => (0, 1, align)\n             };\n             let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx, ty).unwrap();\n-            let a_ptr = bcx.struct_gep(llval, 0);\n-            let b_ptr = bcx.struct_gep(llval, 1);\n+            let a_ptr = bcx.struct_gep(llval, ix0);\n+            let b_ptr = bcx.struct_gep(llval, ix1);\n \n             OperandValue::Pair(\n                 base::load_ty(bcx, a_ptr, f_align, a_ty),\n@@ -302,17 +312,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx.store(base::from_immediate(bcx, s), lldest, align);\n             }\n             OperandValue::Pair(a, b) => {\n-                let f_align = match *bcx.ccx.layout_of(operand.ty) {\n-                    Layout::Univariant { ref variant, .. } if variant.packed => {\n-                        Some(1)\n+                let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(operand.ty) {\n+                    Layout::Univariant { ref variant, .. } => {\n+                        (adt::struct_llfields_index(variant, 0),\n+                        adt::struct_llfields_index(variant, 1),\n+                        if variant.packed { Some(1) } else { None })\n                     }\n-                    _ => align\n+                    _ => (0, 1, align)\n                 };\n \n                 let a = base::from_immediate(bcx, a);\n                 let b = base::from_immediate(bcx, b);\n-                bcx.store(a, bcx.struct_gep(lldest, 0), f_align);\n-                bcx.store(b, bcx.struct_gep(lldest, 1), f_align);\n+                bcx.store(a, bcx.struct_gep(lldest, ix0), f_align);\n+                bcx.store(b, bcx.struct_gep(lldest, ix1), f_align);\n             }\n         }\n     }"}, {"sha": "de1c1e492f39b78b647873fe7bbe19e2d588a1c0", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -130,10 +130,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => {\n                         // If this is a tuple or closure, we need to translate GEP indices.\n                         let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n-                        let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n-                            Some(&variant.memory_index)\n-                        } else {\n-                            None\n+                        let get_memory_index = |i| {\n+                            if let Layout::Univariant { ref variant, .. } = *layout {\n+                                adt::struct_llfields_index(variant, i)\n+                            } else {\n+                                i\n+                            }\n                         };\n                         let alignment = dest.alignment;\n                         for (i, operand) in operands.iter().enumerate() {\n@@ -143,11 +145,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 // Note: perhaps this should be StructGep, but\n                                 // note that in some cases the values here will\n                                 // not be structs but arrays.\n-                                let i = if let Some(ref t) = translation {\n-                                    t[i] as usize\n-                                } else {\n-                                    i\n-                                };\n+                                let i = get_memory_index(i);\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, alignment.to_align(), op);\n                             }"}, {"sha": "9f9126ba83a8f19fd59b8f66b5196d3c3982dbb1", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -214,6 +214,16 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n         self.layout_of(ty).size(self).bytes() as machine::llsize\n     }\n+\n+    pub fn over_align_of(&self, t: Ty<'tcx>)\n+                              -> Option<machine::llalign> {\n+        let layout = self.layout_of(t);\n+        if let Some(align) = layout.over_align(&self.tcx().data_layout) {\n+            Some(align as machine::llalign)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {"}, {"sha": "839af0fa6706cf0250ab7955586fd56903e689e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -953,6 +953,12 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if def.repr.simd() {\n         check_simd(tcx, span, def_id);\n     }\n+\n+    // if struct is packed and not aligned, check fields for alignment.\n+    // Checks for combining packed and align attrs on single struct are done elsewhere.\n+    if tcx.lookup_adt_def(def_id).repr.packed() && tcx.lookup_adt_def(def_id).repr.align == 0 {\n+        check_packed(tcx, span, def_id);\n+    }\n }\n \n fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1371,6 +1377,47 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n     }\n }\n \n+fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+    if check_packed_inner(tcx, def_id, &mut Vec::new()) {\n+        struct_span_err!(tcx.sess, sp, E0588,\n+            \"packed struct cannot transitively contain a `[repr(align)]` struct\").emit();\n+    }\n+}\n+\n+fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                def_id: DefId,\n+                                stack: &mut Vec<DefId>) -> bool {\n+    let t = tcx.item_type(def_id);\n+    if stack.contains(&def_id) {\n+        debug!(\"check_packed_inner: {:?} is recursive\", t);\n+        return false;\n+    }\n+    match t.sty {\n+        ty::TyAdt(def, substs) if def.is_struct() => {\n+            if tcx.lookup_adt_def(def.did).repr.align > 0 {\n+                return true;\n+            }\n+            // push struct def_id before checking fields\n+            stack.push(def_id);\n+            for field in &def.struct_variant().fields {\n+                let f = field.ty(tcx, substs);\n+                match f.sty {\n+                    ty::TyAdt(def, _) => {\n+                        if check_packed_inner(tcx, def.did, stack) {\n+                            return true;\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            // only need to pop if not early out\n+            stack.pop();\n+        }\n+        _ => ()\n+    }\n+    false\n+}\n+\n #[allow(trivial_numeric_casts)]\n pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             sp: Span,"}, {"sha": "c50156fa5f2714107dc73ee9e2572c665763a847", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -4168,5 +4168,6 @@ register_diagnostics! {\n            // but `{}` was found in the type `{}`\n     E0567, // auto traits can not have type parameters\n     E0568, // auto-traits can not have predicates,\n+    E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n }"}, {"sha": "82492d976276e05d6ed6d758872c48acc17405ee", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -147,6 +147,24 @@ impl NestedMetaItem {\n         self.meta_item().and_then(|meta_item| meta_item.value_str())\n     }\n \n+    /// Returns a name and single literal value tuple of the MetaItem.\n+    pub fn name_value_literal(&self) -> Option<(Name, &Lit)> {\n+        self.meta_item().and_then(\n+            |meta_item| meta_item.meta_item_list().and_then(\n+                |meta_item_list| {\n+                    if meta_item_list.len() == 1 {\n+                        let nested_item = &meta_item_list[0];\n+                        if nested_item.is_literal() {\n+                            Some((meta_item.name(), nested_item.literal().unwrap()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    else {\n+                        None\n+                    }}))\n+    }\n+\n     /// Returns a MetaItem if self is a MetaItem with Kind Word.\n     pub fn word(&self) -> Option<&MetaItem> {\n         self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n@@ -931,6 +949,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                     continue\n                 }\n \n+                let mut recognised = false;\n                 if let Some(mi) = item.word() {\n                     let word = &*mi.name().as_str();\n                     let hint = match word {\n@@ -941,20 +960,43 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         _ => match int_type_of_word(word) {\n                             Some(ity) => Some(ReprInt(ity)),\n                             None => {\n-                                // Not a word we recognize\n-                                span_err!(diagnostic, item.span, E0552,\n-                                          \"unrecognized representation hint\");\n                                 None\n                             }\n                         }\n                     };\n \n                     if let Some(h) = hint {\n+                        recognised = true;\n                         acc.push(h);\n                     }\n-                } else {\n-                    span_err!(diagnostic, item.span, E0553,\n-                              \"unrecognized enum representation hint\");\n+                } else if let Some((name, value)) = item.name_value_literal() {\n+                    if name == \"align\" {\n+                        recognised = true;\n+                        let mut align_error = None;\n+                        if let ast::LitKind::Int(align, ast::LitIntType::Unsuffixed) = value.node {\n+                            if align.is_power_of_two() {\n+                                // rustc::ty::layout::Align restricts align to <= 32768\n+                                if align <= 32768 {\n+                                    acc.push(ReprAlign(align as u16));\n+                                } else {\n+                                    align_error = Some(\"larger than 32768\");\n+                                }\n+                            } else {\n+                                align_error = Some(\"not a power of two\");\n+                            }\n+                        } else {\n+                            align_error = Some(\"not an unsuffixed integer\");\n+                        }\n+                        if let Some(align_error) = align_error {\n+                            span_err!(diagnostic, item.span, E0589,\n+                                      \"invalid `repr(align)` attribute: {}\", align_error);\n+                        }\n+                    }\n+                }\n+                if !recognised {\n+                    // Not a word we recognize\n+                    span_err!(diagnostic, item.span, E0552,\n+                              \"unrecognized representation hint\");\n                 }\n             }\n         }\n@@ -986,6 +1028,7 @@ pub enum ReprAttr {\n     ReprExtern,\n     ReprPacked,\n     ReprSimd,\n+    ReprAlign(u16),\n }\n \n #[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]"}, {"sha": "01d1277ea6265014c018401a8854033db84931fa", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -287,10 +287,10 @@ register_diagnostics! {\n     E0550, // multiple deprecated attributes\n     E0551, // incorrect meta item\n     E0552, // unrecognized representation hint\n-    E0553, // unrecognized enum representation hint\n     E0554, // #[feature] may not be used on the [] release channel\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n     E0557, // feature has been removed\n     E0584, // file for module `..` found at both .. and ..\n+    E0589, // invalid `repr(align)` attribute\n }"}, {"sha": "9b55a860b3595a0e4edd1bfb5e837d22f71ee7fd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -338,6 +338,9 @@ declare_features! (\n     // Allows the `catch {...}` expression\n     (active, catch_expr, \"1.17.0\", Some(31436)),\n \n+    // Allows `repr(align(u16))` struct attribute (RFC 1358)\n+    (active, repr_align, \"1.17.0\", Some(33626)),\n+\n     // See rust-lang/rfcs#1414. Allows code like `let x: &'static u32 = &42` to work.\n     (active, rvalue_static_promotion, \"1.15.1\", Some(38865)),\n \n@@ -1189,6 +1192,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                                     and possibly buggy\");\n \n                             }\n+                            if item.check_name(\"align\") {\n+                                gate_feature_post!(&self, repr_align, i.span,\n+                                                   \"the struct `#[repr(align(u16))]` attribute \\\n+                                                    is experimental\");\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "e96883c26f33a1c854996e89ecbdc39d1cb78655", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -773,7 +773,7 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprPacked | attr::ReprSimd => continue,\n+                attr::ReprPacked | attr::ReprSimd | attr::ReprAlign(_) => continue,\n                 attr::ReprExtern => \"i32\",\n \n                 attr::ReprInt(attr::SignedInt(ast::IntTy::Is)) => \"isize\","}, {"sha": "c0bfd3690c8598fd3b5989aaea5102f6afcca4c8", "filename": "src/test/compile-fail/attr-usage-repr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n+#![feature(attr_literals)]\n #![feature(repr_simd)]\n \n #[repr(C)] //~ ERROR: attribute should be applied to struct, enum or union\n@@ -29,6 +30,9 @@ struct SInt(f64, f64);\n #[repr(C)]\n enum EExtern { A, B }\n \n+#[repr(align(8))] //~ ERROR: attribute should be applied to struct\n+enum EAlign { A, B }\n+\n #[repr(packed)] //~ ERROR: attribute should be applied to struct\n enum EPacked { A, B }\n "}, {"sha": "01fa3ffbaa6ae7a82a9f9644ccba0209b4ee4f77", "filename": "src/test/compile-fail/conflicting-repr-hints.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n #![allow(dead_code)]\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n \n #[repr(C)]\n enum A { A }\n@@ -26,5 +27,7 @@ enum D { D }\n #[repr(C, packed)]\n struct E(i32);\n \n-#[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+#[repr(packed, align(8))] //~ ERROR conflicting packed and align representation hints\n+struct F(i32);\n+\n+fn main() {}"}, {"sha": "8e986e197f2694d9113949cac7046f6117c5d880", "filename": "src/test/compile-fail/feature-gate-repr_align.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr_align.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+\n+#[repr(align(64))]\n+struct Foo(u64, u64); //~ error: the struct `#[repr(align(u16))]` attribute is experimental\n+\n+fn main() {}"}, {"sha": "eb0b27fe9c07ed5307a658e87da2fda19cc630bb", "filename": "src/test/compile-fail/repr-align.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Frepr-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Frepr-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-align.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(dead_code)]\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+\n+#[repr(align(16.0))] //~ ERROR: invalid `repr(align)` attribute: not an unsuffixed integer\n+struct A(i32);\n+\n+#[repr(align(15))] //~ ERROR: invalid `repr(align)` attribute: not a power of two\n+struct B(i32);\n+\n+#[repr(align(65536))] //~ ERROR: invalid `repr(align)` attribute: larger than 32768\n+struct C(i32);\n+\n+fn main() {}"}, {"sha": "c584dcf3e5993eacd8eeeb083f53d5a88d2386c4", "filename": "src/test/compile-fail/repr-packed-contains-align.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-packed-contains-align.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+#![allow(dead_code)]\n+\n+#[repr(align(16))]\n+struct A(i32);\n+\n+struct B(A);\n+\n+#[repr(packed)]\n+struct C(A); //~ ERROR: packed struct cannot transitively contain a `[repr(align)]` struct\n+\n+#[repr(packed)]\n+struct D(B); //~ ERROR: packed struct cannot transitively contain a `[repr(align)]` struct\n+\n+fn main() {}"}, {"sha": "0b9a3594502b00bc0dcbaa04f9672a6a0e6ecffb", "filename": "src/test/run-pass/align-struct.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Frun-pass%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Frun-pass%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falign-struct.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -0,0 +1,196 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+\n+use std::mem;\n+\n+// Raising alignment\n+#[repr(align(16))]\n+struct Align16(i32);\n+\n+// Lowering has no effect\n+#[repr(align(1))]\n+struct Align1(i32);\n+\n+// Multiple attributes take the max\n+#[repr(align(4))]\n+#[repr(align(16))]\n+#[repr(align(8))]\n+struct AlignMany(i32);\n+\n+// Raising alignment may not alter size.\n+#[repr(align(8))]\n+#[allow(dead_code)]\n+struct Align8Many {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: u8,\n+}\n+\n+enum Enum {\n+    #[allow(dead_code)]\n+    A(i32),\n+    B(Align16)\n+}\n+\n+// Nested alignment - use `#[repr(C)]` to suppress field reordering for sizeof test\n+#[repr(C)]\n+struct Nested {\n+    a: i32,\n+    b: i32,\n+    c: Align16,\n+    d: i8,\n+}\n+\n+#[repr(packed)]\n+struct Packed(i32);\n+\n+#[repr(align(16))]\n+struct AlignContainsPacked {\n+    a: Packed,\n+    b: Packed,\n+}\n+\n+impl Align16 {\n+    // return aligned type\n+    pub fn new(i: i32) -> Align16 {\n+        Align16(i)\n+    }\n+    // pass aligned type\n+    pub fn consume(a: Align16) -> i32 {\n+        a.0\n+    }\n+}\n+\n+const CONST_ALIGN16: Align16 = Align16(7);\n+static STATIC_ALIGN16: Align16 = Align16(8);\n+\n+// Check the actual address is aligned\n+fn is_aligned_to<T>(p: &T, align: usize) -> bool {\n+    let addr = p as *const T as usize;\n+    (addr & (align - 1)) == 0\n+}\n+\n+pub fn main() {\n+    // check alignment and size by type and value\n+    assert_eq!(mem::align_of::<Align16>(), 16);\n+    assert_eq!(mem::size_of::<Align16>(), 16);\n+\n+    let a = Align16(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // lowering should have no effect\n+    assert_eq!(mem::align_of::<Align1>(), 4);\n+    assert_eq!(mem::size_of::<Align1>(), 4);\n+    let a = Align1(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 4);\n+    assert_eq!(mem::size_of_val(&a), 4);\n+    assert!(is_aligned_to(&a, 4));\n+\n+    // when multiple attributes are specified the max should be used\n+    assert_eq!(mem::align_of::<AlignMany>(), 16);\n+    assert_eq!(mem::size_of::<AlignMany>(), 16);\n+    let a = AlignMany(7);\n+    assert_eq!(a.0, 7);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // raising alignment should not reduce size\n+    assert_eq!(mem::align_of::<Align8Many>(), 8);\n+    assert_eq!(mem::size_of::<Align8Many>(), 16);\n+    let a = Align8Many { a: 1, b: 2, c: 3, d: 4 };\n+    assert_eq!(a.a, 1);\n+    assert_eq!(mem::align_of_val(&a), 8);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 8));\n+\n+    // return type\n+    let a = Align16::new(1);\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert_eq!(a.0, 1);\n+    assert!(is_aligned_to(&a, 16));\n+    assert_eq!(Align16::consume(a), 1);\n+\n+    // check const alignment, size and value\n+    assert_eq!(mem::align_of_val(&CONST_ALIGN16), 16);\n+    assert_eq!(mem::size_of_val(&CONST_ALIGN16), 16);\n+    assert_eq!(CONST_ALIGN16.0, 7);\n+    assert!(is_aligned_to(&CONST_ALIGN16, 16));\n+\n+    // check global static alignment, size and value\n+    assert_eq!(mem::align_of_val(&STATIC_ALIGN16), 16);\n+    assert_eq!(mem::size_of_val(&STATIC_ALIGN16), 16);\n+    assert_eq!(STATIC_ALIGN16.0, 8);\n+    assert!(is_aligned_to(&STATIC_ALIGN16, 16));\n+\n+    // Note that the size of Nested may change if struct field re-ordering is enabled\n+    assert_eq!(mem::align_of::<Nested>(), 16);\n+    assert_eq!(mem::size_of::<Nested>(), 48);\n+    let a = Nested{ a: 1, b: 2, c: Align16(3), d: 4};\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::align_of_val(&a.b), 4);\n+    assert_eq!(mem::align_of_val(&a.c), 16);\n+    assert_eq!(mem::size_of_val(&a), 48);\n+    assert!(is_aligned_to(&a, 16));\n+    // check the correct fields are indexed\n+    assert_eq!(a.a, 1);\n+    assert_eq!(a.b, 2);\n+    assert_eq!(a.c.0, 3);\n+    assert_eq!(a.d, 4);\n+\n+    // enum should be aligned to max alignment\n+    assert_eq!(mem::align_of::<Enum>(), 16);\n+    assert_eq!(mem::align_of_val(&Enum::B(Align16(0))), 16);\n+    let e = Enum::B(Align16(15));\n+    match e {\n+        Enum::B(ref a) => {\n+            assert_eq!(a.0, 15);\n+            assert_eq!(mem::align_of_val(a), 16);\n+            assert_eq!(mem::size_of_val(a), 16);\n+        },\n+        _ => ()\n+    }\n+    assert!(is_aligned_to(&e, 16));\n+\n+    // arrays of aligned elements should also be aligned\n+    assert_eq!(mem::align_of::<[Align16;2]>(), 16);\n+    assert_eq!(mem::size_of::<[Align16;2]>(), 32);\n+\n+    let a = [Align16(0), Align16(1)];\n+    assert_eq!(mem::align_of_val(&a[0]), 16);\n+    assert_eq!(mem::align_of_val(&a[1]), 16);\n+    assert!(is_aligned_to(&a, 16));\n+\n+    // check heap value is aligned\n+    assert_eq!(mem::align_of_val(Box::new(Align16(0)).as_ref()), 16);\n+\n+    // check heap array is aligned\n+    let a = vec!(Align16(0), Align16(1));\n+    assert_eq!(mem::align_of_val(&a[0]), 16);\n+    assert_eq!(mem::align_of_val(&a[1]), 16);\n+\n+    assert_eq!(mem::align_of::<AlignContainsPacked>(), 16);\n+    assert_eq!(mem::size_of::<AlignContainsPacked>(), 16);\n+    let a = AlignContainsPacked { a: Packed(1), b: Packed(2) };\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::align_of_val(&a.a), 1);\n+    assert_eq!(mem::align_of_val(&a.b), 1);\n+    assert_eq!(mem::size_of_val(&a), 16);\n+    assert!(is_aligned_to(&a, 16));\n+}"}, {"sha": "e9b43145de469706b199292371e4fa0be7542ede", "filename": "src/test/ui/print_type_sizes/repr-align.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.rs?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates how padding is handled: alignment\n+// requirements can lead to the introduction of padding, either before\n+// fields or at the end of the structure as a whole.\n+//\n+// It avoids using u64/i64 because on some targets that is only 4-byte\n+// aligned (while on most it is 8-byte aligned) and so the resulting\n+// padding and overall computed sizes can be quite different.\n+#![feature(attr_literals)]\n+#![feature(repr_align)]\n+#![allow(dead_code)]\n+\n+#[repr(align(16))]\n+#[derive(Default)]\n+struct A(i32);\n+\n+enum E {\n+    A(i32),\n+    B(A)\n+}\n+\n+#[derive(Default)]\n+struct S {\n+    a: i32,\n+    b: i32,\n+    c: A,\n+    d: i8,\n+}\n+\n+fn main() {\n+    let _s: S = Default::default();\n+}"}, {"sha": "7df12f040b15d4d24dbfa071ccc2853649b43e0a", "filename": "src/test/ui/print_type_sizes/repr-align.stdout", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6d841da4a0d7629f826117f99052e3d4a7997a7e/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stdout?ref=6d841da4a0d7629f826117f99052e3d4a7997a7e", "patch": "@@ -0,0 +1,16 @@\n+print-type-size type: `E`: 32 bytes, alignment: 16 bytes\n+print-type-size     discriminant: 4 bytes\n+print-type-size     variant `A`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `B`: 28 bytes\n+print-type-size         padding: 12 bytes\n+print-type-size         field `.0`: 16 bytes, alignment: 16 bytes\n+print-type-size type: `S`: 32 bytes, alignment: 16 bytes\n+print-type-size     field `.c`: 16 bytes\n+print-type-size     field `.a`: 4 bytes\n+print-type-size     field `.b`: 4 bytes\n+print-type-size     field `.d`: 1 bytes\n+print-type-size     end padding: 7 bytes\n+print-type-size type: `A`: 16 bytes, alignment: 16 bytes\n+print-type-size     field `.0`: 4 bytes\n+print-type-size     end padding: 12 bytes"}]}