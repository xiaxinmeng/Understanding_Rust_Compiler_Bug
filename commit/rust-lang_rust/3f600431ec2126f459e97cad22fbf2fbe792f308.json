{"sha": "3f600431ec2126f459e97cad22fbf2fbe792f308", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNjAwNDMxZWMyMTI2ZjQ1OWU5N2NhZDIyZmJmMmZiZTc5MmYzMDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-29T17:25:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-09T18:14:41Z"}, "message": "infer/mod.rs: rustfmt", "tree": {"sha": "842026ea7a03487a5a655c27a015834b7b50f4d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/842026ea7a03487a5a655c27a015834b7b50f4d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f600431ec2126f459e97cad22fbf2fbe792f308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f600431ec2126f459e97cad22fbf2fbe792f308", "html_url": "https://github.com/rust-lang/rust/commit/3f600431ec2126f459e97cad22fbf2fbe792f308", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f600431ec2126f459e97cad22fbf2fbe792f308/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c5741bf76f5b8144f656045997b9d11602e12fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c5741bf76f5b8144f656045997b9d11602e12fd", "html_url": "https://github.com/rust-lang/rust/commit/5c5741bf76f5b8144f656045997b9d11602e12fd"}], "stats": {"total": 702, "additions": 373, "deletions": 329}, "files": [{"sha": "66aa7d6d8eaf58262c16ccad45b48c55625ba8af", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 373, "deletions": 329, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/3f600431ec2126f459e97cad22fbf2fbe792f308/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f600431ec2126f459e97cad22fbf2fbe792f308/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3f600431ec2126f459e97cad22fbf2fbe792f308", "patch": "@@ -10,41 +10,41 @@\n \n //! See the Book for more information.\n \n+pub use self::freshen::TypeFreshener;\n pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n pub use ty::IntVarValue;\n-pub use self::freshen::TypeFreshener;\n \n+use arena::SyncDroplessArena;\n+use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n use middle::free_region::RegionRelations;\n-use middle::region;\n use middle::lang_items;\n-use ty::subst::{Kind, Substs};\n-use ty::{TyVid, IntVid, FloatVid};\n-use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n-use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n-use ty::relate::RelateResult;\n-use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use middle::region;\n use rustc_data_structures::unify as ut;\n-use std::cell::{Cell, RefCell, Ref, RefMut};\n+use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n-use errors::DiagnosticBuilder;\n-use syntax_pos::{self, Span};\n use syntax_pos::symbol::InternedString;\n+use syntax_pos::{self, Span};\n+use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use ty::fold::TypeFoldable;\n+use ty::relate::RelateResult;\n+use ty::subst::{Kind, Substs};\n+use ty::{self, GenericParamDefKind, Ty, TyCtxt};\n+use ty::{FloatVid, IntVid, TyVid};\n use util::nodemap::FxHashMap;\n-use arena::SyncDroplessArena;\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n-use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarInfos};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n+use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n+use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n@@ -54,16 +54,16 @@ pub mod canonical;\n mod combine;\n mod equate;\n pub mod error_reporting;\n+mod freshen;\n mod fudge;\n mod glb;\n mod higher_ranked;\n pub mod lattice;\n-mod lub;\n-pub mod region_constraints;\n mod lexical_region_resolve;\n+mod lub;\n pub mod outlives;\n+pub mod region_constraints;\n pub mod resolve;\n-mod freshen;\n mod sub;\n pub mod type_variable;\n pub mod unify_key;\n@@ -80,7 +80,7 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     /// During type-checking/inference of a body, `in_progress_tables`\n@@ -314,10 +314,10 @@ pub enum SubregionOrigin<'tcx> {\n /// Places that type/region parameters can appear.\n #[derive(Clone, Copy, Debug)]\n pub enum ParameterOrigin {\n-    Path, // foo::bar\n-    MethodCall, // foo.bar() <-- parameters on impl providing bar()\n+    Path,               // foo::bar\n+    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n     OverloadedOperator, // a + b when overloaded\n-    OverloadedDeref, // *a when overloaded\n+    OverloadedDeref,    // *a when overloaded\n }\n \n /// Times when we replace late-bound regions with variables:\n@@ -400,7 +400,7 @@ impl NLLRegionVariableOrigin {\n pub enum FixupError {\n     UnresolvedIntTy(IntVid),\n     UnresolvedFloatTy(FloatVid),\n-    UnresolvedTy(TyVid)\n+    UnresolvedTy(TyVid),\n }\n \n /// See the `region_obligations` field for more information.\n@@ -416,23 +416,25 @@ impl fmt::Display for FixupError {\n         use self::FixupError::*;\n \n         match *self {\n-            UnresolvedIntTy(_) => {\n-                write!(f, \"cannot determine the type of this integer; \\\n-                           add a suffix to specify the type explicitly\")\n-            }\n-            UnresolvedFloatTy(_) => {\n-                write!(f, \"cannot determine the type of this number; \\\n-                           add a suffix to specify the type explicitly\")\n-            }\n-            UnresolvedTy(_) => write!(f, \"unconstrained type\")\n+            UnresolvedIntTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this integer; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedFloatTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this number; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n         }\n     }\n }\n \n /// Helper type of a temporary returned by tcx.infer_ctxt().\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n-pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n@@ -444,7 +446,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             global_tcx: self,\n             arena: SyncDroplessArena::new(),\n             fresh_tables: None,\n-\n         }\n     }\n }\n@@ -458,48 +459,60 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n-        where F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R,\n     {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref arena,\n             ref fresh_tables,\n         } = *self;\n         let in_progress_tables = fresh_tables.as_ref();\n-        global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n-            tcx,\n-            in_progress_tables,\n-            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-            int_unification_table: RefCell::new(ut::UnificationTable::new()),\n-            float_unification_table: RefCell::new(ut::UnificationTable::new()),\n-            region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n-            lexical_region_resolutions: RefCell::new(None),\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n-            reported_trait_errors: RefCell::new(FxHashMap()),\n-            tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: tcx.sess.err_count(),\n-            in_snapshot: Cell::new(false),\n-            region_obligations: RefCell::new(vec![]),\n-            universe: Cell::new(ty::UniverseIndex::ROOT),\n-        }))\n+        global_tcx.enter_local(arena, |tcx| {\n+            f(InferCtxt {\n+                tcx,\n+                in_progress_tables,\n+                projection_cache: RefCell::new(traits::ProjectionCache::new()),\n+                type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+                int_unification_table: RefCell::new(ut::UnificationTable::new()),\n+                float_unification_table: RefCell::new(ut::UnificationTable::new()),\n+                region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n+                lexical_region_resolutions: RefCell::new(None),\n+                selection_cache: traits::SelectionCache::new(),\n+                evaluation_cache: traits::EvaluationCache::new(),\n+                reported_trait_errors: RefCell::new(FxHashMap()),\n+                tainted_by_errors_flag: Cell::new(false),\n+                err_count_on_creation: tcx.sess.err_count(),\n+                in_snapshot: Cell::new(false),\n+                region_obligations: RefCell::new(vec![]),\n+                universe: Cell::new(ty::UniverseIndex::ROOT),\n+            })\n+        })\n     }\n }\n \n impl<T> ExpectedFound<T> {\n     pub fn new(a_is_expected: bool, a: T, b: T) -> Self {\n         if a_is_expected {\n-            ExpectedFound {expected: a, found: b}\n+            ExpectedFound {\n+                expected: a,\n+                found: b,\n+            }\n         } else {\n-            ExpectedFound {expected: b, found: a}\n+            ExpectedFound {\n+                expected: b,\n+                found: a,\n+            }\n         }\n     }\n }\n \n impl<'tcx, T> InferOk<'tcx, T> {\n     pub fn unit(self) -> InferOk<'tcx, ()> {\n-        InferOk { value: (), obligations: self.obligations }\n+        InferOk {\n+            value: (),\n+            obligations: self.obligations,\n+        }\n     }\n \n     /// Extract `value`, registering any obligations into `fulfill_cx`\n@@ -523,7 +536,7 @@ impl<'tcx> InferOk<'tcx, ()> {\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot<'a, 'tcx:'a> {\n+pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n     int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n@@ -540,14 +553,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.get()\n     }\n \n-    pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n+    pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n         match ty.sty {\n             ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -557,22 +570,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty) -> UnconstrainedNumeric {\n         use ty::error::UnconstrainedNumeric::Neither;\n-        use ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n+        use ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.sty {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.int_unification_table\n+                    .borrow_mut()\n+                    .probe_value(vid)\n+                    .is_some()\n+                {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n-            },\n+            }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.float_unification_table\n+                    .borrow_mut()\n+                    .probe_value(vid)\n+                    .is_some()\n+                {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n                 }\n-            },\n+            }\n             _ => Neither,\n         }\n     }\n@@ -590,17 +611,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (0..int_unification_table.len())\n                     .map(|i| ty::IntVid { index: i as u32 })\n                     .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_int_var(v))\n-            ).chain(\n+                    .map(|v| self.tcx.mk_int_var(v)),\n+            )\n+            .chain(\n                 (0..float_unification_table.len())\n                     .map(|i| ty::FloatVid { index: i as u32 })\n                     .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_float_var(v))\n-            ).collect()\n+                    .map(|v| self.tcx.mk_float_var(v)),\n+            )\n+            .collect()\n     }\n \n-    fn combine_fields(&'a self, trace: TypeTrace<'tcx>, param_env: ty::ParamEnv<'tcx>)\n-                      -> CombineFields<'a, 'gcx, 'tcx> {\n+    fn combine_fields(\n+        &'a self,\n+        trace: TypeTrace<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n@@ -627,7 +653,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // escaping obligations in the main cx. In those cases, you can\n     // use this function.\n     pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-        where F: FnOnce(&Self) -> R\n+    where\n+        F: FnOnce(&Self) -> R,\n     {\n         let flag = self.in_snapshot.get();\n         self.in_snapshot.set(false);\n@@ -653,33 +680,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n-            _in_progress_tables: self.in_progress_tables.map(|tables| {\n-                tables.borrow()\n-            })\n+            _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n         }\n     }\n \n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_constraints_snapshot,\n-                               region_obligations_snapshot,\n-                               universe,\n-                               was_in_snapshot,\n-                               _in_progress_tables } = snapshot;\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot,\n+            universe,\n+            was_in_snapshot,\n+            _in_progress_tables,\n+        } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n \n         self.projection_cache\n             .borrow_mut()\n             .rollback_to(projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .rollback_to(type_snapshot);\n+        self.type_variables.borrow_mut().rollback_to(type_snapshot);\n         self.int_unification_table\n             .borrow_mut()\n             .rollback_to(int_snapshot);\n@@ -695,27 +720,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_constraints_snapshot,\n-                               region_obligations_snapshot: _,\n-                               universe: _,\n-                               was_in_snapshot,\n-                               _in_progress_tables } = snapshot;\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot: _,\n+            universe: _,\n+            was_in_snapshot,\n+            _in_progress_tables,\n+        } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n \n         self.projection_cache\n             .borrow_mut()\n             .commit(&projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .commit(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .commit(int_snapshot);\n+        self.type_variables.borrow_mut().commit(type_snapshot);\n+        self.int_unification_table.borrow_mut().commit(int_snapshot);\n         self.float_unification_table\n             .borrow_mut()\n             .commit(float_snapshot);\n@@ -724,7 +747,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings\n-    pub fn commit_unconditionally<R, F>(&self, f: F) -> R where\n+    pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n+    where\n         F: FnOnce() -> R,\n     {\n         debug!(\"commit()\");\n@@ -735,23 +759,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n-    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>\n+    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n     {\n         debug!(\"commit_if_ok()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n         debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n-            Ok(_) => { self.commit_from(snapshot); }\n-            Err(_) => { self.rollback_to(\"commit_if_ok -- error\", snapshot); }\n+            Ok(_) => {\n+                self.commit_from(snapshot);\n+            }\n+            Err(_) => {\n+                self.rollback_to(\"commit_if_ok -- error\", snapshot);\n+            }\n         }\n         r\n     }\n \n     // Execute `f` in a snapshot, and commit the bindings it creates\n-    pub fn in_snapshot<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T\n+    pub fn in_snapshot<T, F>(&self, f: F) -> T\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T,\n     {\n         debug!(\"in_snapshot()\");\n         let snapshot = self.start_snapshot();\n@@ -761,7 +791,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<R, F>(&self, f: F) -> R where\n+    pub fn probe<R, F>(&self, f: F) -> R\n+    where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n         debug!(\"probe()\");\n@@ -771,59 +802,57 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    pub fn add_given(&self,\n-                     sub: ty::Region<'tcx>,\n-                     sup: ty::RegionVid)\n-    {\n+    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n         self.borrow_region_constraints().add_given(sub, sup);\n     }\n \n-    pub fn can_sub<T>(&self,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      a: T,\n-                      b: T)\n-                      -> UnitResult<'tcx>\n-        where T: at::ToTrace<'tcx>\n+    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n+            self.at(origin, param_env)\n+                .sub(a, b)\n+                .map(|InferOk { obligations: _, .. }| {\n+                    // Ignore obligations, since we are unrolling\n+                    // everything anyway.\n+                })\n         })\n     }\n \n-    pub fn can_eq<T>(&self,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      a: T,\n-                      b: T)\n-                      -> UnitResult<'tcx>\n-        where T: at::ToTrace<'tcx>\n+    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n+            self.at(origin, param_env)\n+                .eq(a, b)\n+                .map(|InferOk { obligations: _, .. }| {\n+                    // Ignore obligations, since we are unrolling\n+                    // everything anyway.\n+                })\n         })\n     }\n \n-    pub fn sub_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: ty::Region<'tcx>,\n-                       b: ty::Region<'tcx>) {\n+    pub fn sub_regions(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.borrow_region_constraints()\n+            .make_subregion(origin, a, b);\n     }\n \n-    pub fn subtype_predicate(&self,\n-                             cause: &ObligationCause<'tcx>,\n-                             param_env: ty::ParamEnv<'tcx>,\n-                             predicate: &ty::PolySubtypePredicate<'tcx>)\n-        -> Option<InferResult<'tcx, ()>>\n-    {\n+    pub fn subtype_predicate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: &ty::PolySubtypePredicate<'tcx>,\n+    ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n         // `shallow_resolve` just ignores anything that is not a type\n         // variable, and because type variable's can't (at present, at\n@@ -845,8 +874,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         Some(self.commit_if_ok(|snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b}, skol_map) =\n-                self.skolemize_late_bound_regions(predicate);\n+            let (\n+                ty::SubtypePredicate {\n+                    a_is_expected,\n+                    a,\n+                    b,\n+                },\n+                skol_map,\n+            ) = self.skolemize_late_bound_regions(predicate);\n \n             let cause_span = cause.span;\n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n@@ -856,17 +891,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }))\n     }\n \n-    pub fn region_outlives_predicate(&self,\n-                                     cause: &traits::ObligationCause<'tcx>,\n-                                     predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n-        -> UnitResult<'tcx>\n-    {\n+    pub fn region_outlives_predicate(\n+        &self,\n+        cause: &traits::ObligationCause<'tcx>,\n+        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n+    ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate);\n-            let origin =\n-                SubregionOrigin::from_obligation_cause(cause,\n-                                                       || RelateRegionParamBound(cause.span));\n+            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n+                RelateRegionParamBound(cause.span)\n+            });\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n             self.leak_check(false, cause.span, &skol_map, snapshot)?;\n             Ok(self.pop_skolemized(skol_map, snapshot))\n@@ -888,15 +923,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n-        self.int_unification_table\n-            .borrow_mut()\n-            .new_key(None)\n+        self.int_unification_table.borrow_mut().new_key(None)\n     }\n \n     pub fn next_float_var_id(&self) -> FloatVid {\n-        self.float_unification_table\n-            .borrow_mut()\n-            .new_key(None)\n+        self.float_unification_table.borrow_mut().new_key(None)\n     }\n \n     /// Create a fresh region variable with the next available index.\n@@ -905,8 +936,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// - `origin`: information about why we created this variable, for use\n     ///   during diagnostics / error-reporting.\n-    pub fn next_region_var(&self, origin: RegionVariableOrigin)\n-                           -> ty::Region<'tcx> {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n         let region_var = self.borrow_region_constraints()\n             .new_region_var(self.universe(), origin);\n         self.tcx.mk_region(ty::ReVar(region_var))\n@@ -918,22 +948,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n-                               -> ty::Region<'tcx> {\n+    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var(RegionVariableOrigin::NLL(origin))\n     }\n \n-    pub fn var_for_def(&self,\n-                       span: Span,\n-                       param: &ty::GenericParamDef)\n-                       -> Kind<'tcx> {\n+    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> Kind<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 // Create a region inference variable for the given\n                 // region parameter definition.\n-                self.next_region_var(EarlyBoundRegion(span, param.name)).into()\n+                self.next_region_var(EarlyBoundRegion(span, param.name))\n+                    .into()\n             }\n-            GenericParamDefKind::Type {..} => {\n+            GenericParamDefKind::Type { .. } => {\n                 // Create a type inference variable for the given\n                 // type parameter definition. The substitutions are\n                 // for actual parameters that may be referred to by\n@@ -942,12 +969,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id =\n-                    self.type_variables\n-                        .borrow_mut()\n-                        .new_var(self.universe(),\n-                                    false,\n-                                    TypeVariableOrigin::TypeParameterDefinition(span, param.name));\n+                let ty_var_id = self.type_variables.borrow_mut().new_var(\n+                    self.universe(),\n+                    false,\n+                    TypeVariableOrigin::TypeParameterDefinition(span, param.name),\n+                );\n \n                 self.tcx.mk_var(ty_var_id).into()\n             }\n@@ -956,13 +982,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_item(&self,\n-                                 span: Span,\n-                                 def_id: DefId)\n-                                 -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx, def_id, |param, _| {\n-            self.var_for_def(span, param)\n-        })\n+    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n     }\n \n     /// True if errors have been reported since this infcx was\n@@ -971,11 +992,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n     pub fn is_tainted_by_errors(&self) -> bool {\n-        debug!(\"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n-                tainted_by_errors_flag={})\",\n-               self.tcx.sess.err_count(),\n-               self.err_count_on_creation,\n-               self.tainted_by_errors_flag.get());\n+        debug!(\n+            \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n+             tainted_by_errors_flag={})\",\n+            self.tcx.sess.err_count(),\n+            self.err_count_on_creation,\n+            self.tainted_by_errors_flag.get()\n+        );\n \n         if self.tcx.sess.err_count() > self.err_count_on_creation {\n             return true; // errors reported since this infcx was made\n@@ -1018,12 +1041,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n     ) {\n-        self.resolve_regions_and_report_errors_inner(\n-            region_context,\n-            region_map,\n-            outlives_env,\n-            true,\n-        )\n+        self.resolve_regions_and_report_errors_inner(region_context, region_map, outlives_env, true)\n     }\n \n     fn resolve_regions_and_report_errors_inner(\n@@ -1033,22 +1051,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         will_later_be_reported_by_nll: bool,\n     ) {\n-        assert!(self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                self.region_obligations.borrow());\n-\n-        let region_rels = &RegionRelations::new(self.tcx,\n-                                                region_context,\n-                                                region_map,\n-                                                outlives_env.free_region_map());\n-        let (var_infos, data) = self.region_constraints.borrow_mut()\n-                                                         .take()\n-                                                         .expect(\"regions already resolved\")\n-                                                         .into_infos_and_data();\n+        assert!(\n+            self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.region_obligations.borrow()\n+        );\n+\n+        let region_rels = &RegionRelations::new(\n+            self.tcx,\n+            region_context,\n+            region_map,\n+            outlives_env.free_region_map(),\n+        );\n+        let (var_infos, data) = self.region_constraints\n+            .borrow_mut()\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n         let (lexical_region_resolutions, errors) =\n             lexical_region_resolve::resolve(region_rels, var_infos, data);\n \n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        let old_value = self.lexical_region_resolutions\n+            .replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n \n         if !self.is_tainted_by_errors() {\n@@ -1072,9 +1096,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// translate them into the form that the NLL solver\n     /// understands. See the NLL module for mode details.\n     pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(self.region_obligations.borrow().is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                self.region_obligations.borrow());\n+        assert!(\n+            self.region_obligations.borrow().is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.region_obligations.borrow()\n+        );\n \n         self.borrow_region_constraints().take_and_reset_data()\n     }\n@@ -1095,10 +1121,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region vairables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n-        let (var_infos, data) = self.region_constraints.borrow_mut()\n-                                                         .take()\n-                                                         .expect(\"regions already resolved\")\n-                                                         .into_infos_and_data();\n+        let (var_infos, data) = self.region_constraints\n+            .borrow_mut()\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n         assert!(data.is_empty());\n         var_infos\n     }\n@@ -1132,32 +1159,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n-                self.type_variables.borrow_mut()\n-                                   .probe(v)\n-                                   .known()\n-                                   .map(|t| self.shallow_resolve(t))\n-                                   .unwrap_or(typ)\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => {\n-                self.int_unification_table\n+                self.type_variables\n                     .borrow_mut()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(self.tcx))\n+                    .probe(v)\n+                    .known()\n+                    .map(|t| self.shallow_resolve(t))\n                     .unwrap_or(typ)\n             }\n \n-            ty::Infer(ty::FloatVar(v)) => {\n-                self.float_unification_table\n-                    .borrow_mut()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(self.tcx))\n-                    .unwrap_or(typ)\n-            }\n+            ty::Infer(ty::IntVar(v)) => self.int_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.tcx))\n+                .unwrap_or(typ),\n \n-            _ => {\n-                typ\n-            }\n+            ty::Infer(ty::FloatVar(v)) => self.float_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.tcx))\n+                .unwrap_or(typ),\n+\n+            _ => typ,\n         }\n     }\n \n@@ -1166,7 +1188,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         /*!\n          * Where possible, replaces type/int/float variables in\n@@ -1190,20 +1213,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// resolved type, so it's more efficient than\n     /// `resolve_type_vars_if_possible()`.\n     pub fn any_unresolved_type_vars<T>(&self, value: &T) -> bool\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let mut r = resolve::UnresolvedTypeFinder::new(self);\n         value.visit_with(&mut r)\n     }\n \n     pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let mut r = resolve::OpportunisticTypeAndRegionResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n-    pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n+    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n          * `value`. Region inference must have been run already (e.g.,\n@@ -1228,12 +1253,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // types using one of these methods, and should not call span_err directly for such\n     // errors.\n \n-    pub fn type_error_struct_with_diag<M>(&self,\n-                                          sp: Span,\n-                                          mk_diag: M,\n-                                          actual_ty: Ty<'tcx>)\n-                                          -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n+    pub fn type_error_struct_with_diag<M>(\n+        &self,\n+        sp: Span,\n+        mk_diag: M,\n+        actual_ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx>\n+    where\n+        M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n@@ -1246,12 +1273,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         mk_diag(self.ty_to_string(actual_ty))\n     }\n \n-    pub fn report_mismatched_types(&self,\n-                                   cause: &ObligationCause<'tcx>,\n-                                   expected: Ty<'tcx>,\n-                                   actual: Ty<'tcx>,\n-                                   err: TypeError<'tcx>)\n-                                   -> DiagnosticBuilder<'tcx> {\n+    pub fn report_mismatched_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err)\n     }\n@@ -1260,13 +1288,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: &ty::Binder<T>)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-        where T : TypeFoldable<'tcx>\n+        value: &ty::Binder<T>,\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n-        self.tcx.replace_late_bound_regions(\n-            value,\n-            |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n+        self.tcx.replace_late_bound_regions(value, |br| {\n+            self.next_region_var(LateBoundRegion(span, br, lbrct))\n+        })\n     }\n \n     /// Given a higher-ranked projection predicate like:\n@@ -1284,43 +1313,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n     /// details.\n-    pub fn match_poly_projection_predicate(&self,\n-                                           cause: ObligationCause<'tcx>,\n-                                           param_env: ty::ParamEnv<'tcx>,\n-                                           match_a: ty::PolyProjectionPredicate<'tcx>,\n-                                           match_b: ty::TraitRef<'tcx>)\n-                                           -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n-    {\n+    pub fn match_poly_projection_predicate(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        match_a: ty::PolyProjectionPredicate<'tcx>,\n+        match_b: ty::TraitRef<'tcx>,\n+    ) -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>> {\n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n         let trace = TypeTrace {\n             cause,\n-            values: TraitRefs(ExpectedFound::new(true, match_pair.skip_binder().0, match_b))\n+            values: TraitRefs(ExpectedFound::new(\n+                true,\n+                match_pair.skip_binder().0,\n+                match_b,\n+            )),\n         };\n \n         let mut combine = self.combine_fields(trace, param_env);\n         let result = combine.higher_ranked_match(&match_pair, &match_b, true)?;\n-        Ok(InferOk { value: result, obligations: combine.obligations })\n+        Ok(InferOk {\n+            value: result,\n+            obligations: combine.obligations,\n+        })\n     }\n \n     /// See `verify_generic_bound` method in `region_constraints`\n-    pub fn verify_generic_bound(&self,\n-                                origin: SubregionOrigin<'tcx>,\n-                                kind: GenericKind<'tcx>,\n-                                a: ty::Region<'tcx>,\n-                                bound: VerifyBound<'tcx>) {\n-        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n-               kind,\n-               a,\n-               bound);\n-\n-        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n-    }\n-\n-    pub fn type_moves_by_default(&self,\n-                                 param_env: ty::ParamEnv<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 span: Span)\n-                                 -> bool {\n+    pub fn verify_generic_bound(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n+\n+        self.borrow_region_constraints()\n+            .verify_generic_bound(origin, kind, a, bound);\n+    }\n+\n+    pub fn type_moves_by_default(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only.\n@@ -1342,11 +1379,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Obtains the latest type of the given closure; this may be a\n     /// closure in the current function, in which case its\n     /// `ClosureKind` may not yet be known.\n-    pub fn closure_kind(&self,\n-                        closure_def_id: DefId,\n-                        closure_substs: ty::ClosureSubsts<'tcx>)\n-                        -> Option<ty::ClosureKind>\n-    {\n+    pub fn closure_kind(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    ) -> Option<ty::ClosureKind> {\n         let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n         let closure_kind_ty = self.shallow_resolve(&closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n@@ -1359,7 +1396,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_sig(\n         &self,\n         def_id: DefId,\n-        substs: ty::ClosureSubsts<'tcx>\n+        substs: ty::ClosureSubsts<'tcx>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n         let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n@@ -1368,29 +1405,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Normalizes associated types in `value`, potentially returning\n     /// new obligations that must further be processed.\n-    pub fn partially_normalize_associated_types_in<T>(&self,\n-                                                      span: Span,\n-                                                      body_id: ast::NodeId,\n-                                                      param_env: ty::ParamEnv<'tcx>,\n-                                                      value: &T)\n-                                                      -> InferOk<'tcx, T>\n-        where T : TypeFoldable<'tcx>\n+    pub fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: ast::NodeId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = ObligationCause::misc(span, body_id);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value,\n-            obligations);\n+        debug!(\n+            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value, obligations\n+        );\n         InferOk { value, obligations }\n     }\n \n     pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n-        RefMut::map(\n-            self.region_constraints.borrow_mut(),\n-            |c| c.as_mut().expect(\"region constraints already solved\"))\n+        RefMut::map(self.region_constraints.borrow_mut(), |c| {\n+            c.as_mut().expect(\"region constraints already solved\")\n+        })\n     }\n \n     /// Clears the selection, evaluation, and projection cachesThis is useful when\n@@ -1423,14 +1463,15 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n         self.cause.span\n     }\n \n-    pub fn types(cause: &ObligationCause<'tcx>,\n-                 a_is_expected: bool,\n-                 a: Ty<'tcx>,\n-                 b: Ty<'tcx>)\n-                 -> TypeTrace<'tcx> {\n+    pub fn types(\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+    ) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: cause.clone(),\n-            values: Types(ExpectedFound::new(a_is_expected, a, b))\n+            values: Types(ExpectedFound::new(a_is_expected, a, b)),\n         }\n     }\n \n@@ -1440,7 +1481,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n             values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n-            })\n+            }),\n         }\n     }\n }\n@@ -1482,24 +1523,25 @@ impl<'tcx> SubregionOrigin<'tcx> {\n         }\n     }\n \n-    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>,\n-                                    default: F)\n-                                    -> Self\n-        where F: FnOnce() -> Self\n+    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>, default: F) -> Self\n+    where\n+        F: FnOnce() -> Self,\n     {\n         match cause.code {\n-            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n-                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span),\n-\n-            traits::ObligationCauseCode::CompareImplMethodObligation { item_name,\n-                                                                       impl_item_def_id,\n-                                                                       trait_item_def_id, } =>\n-                SubregionOrigin::CompareImplMethodObligation {\n-                    span: cause.span,\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                },\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {\n+                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n+            }\n+\n+            traits::ObligationCauseCode::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => SubregionOrigin::CompareImplMethodObligation {\n+                span: cause.span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            },\n \n             _ => default(),\n         }\n@@ -1534,8 +1576,10 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-               self.sub_region,\n-               self.sup_type)\n+        write!(\n+            f,\n+            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+            self.sub_region, self.sup_type\n+        )\n     }\n }"}]}