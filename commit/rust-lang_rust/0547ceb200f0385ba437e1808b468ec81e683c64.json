{"sha": "0547ceb200f0385ba437e1808b468ec81e683c64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDdjZWIyMDBmMDM4NWJhNDM3ZTE4MDhiNDY4ZWM4MWU2ODNjNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-08T05:46:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-08T05:46:08Z"}, "message": "Auto merge of #58013 - Zoxc:stable-hash-macro-simple, r=oli-obk\n\nCreate a derive macro for HashStable and allow proc macros in rustc\n\nA combination of https://github.com/rust-lang/rust/pull/56864 and https://github.com/rust-lang/rust/pull/56795. There were complications with using `serde_derive` as rustc doesn't know which crate to use for the host when there is a serde_derive in the sysroot and cargo passes another on the command line built from crates.io.\n\nr? @eddyb (for proc macro changes) @alexcrichton (for rustbuild changes) @michaelwoerister (for the macro itself)", "tree": {"sha": "48abe82915f918cf06b7f419d38a9b663e806737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48abe82915f918cf06b7f419d38a9b663e806737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0547ceb200f0385ba437e1808b468ec81e683c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0547ceb200f0385ba437e1808b468ec81e683c64", "html_url": "https://github.com/rust-lang/rust/commit/0547ceb200f0385ba437e1808b468ec81e683c64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0547ceb200f0385ba437e1808b468ec81e683c64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "html_url": "https://github.com/rust-lang/rust/commit/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e"}, {"sha": "f2ef283b7265a35ee4b6e250e1160ba28b33953a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ef283b7265a35ee4b6e250e1160ba28b33953a", "html_url": "https://github.com/rust-lang/rust/commit/f2ef283b7265a35ee4b6e250e1160ba28b33953a"}], "stats": {"total": 479, "additions": 392, "deletions": 87}, "files": [{"sha": "ad4af76f4b3823606697981b39154755de4a7496", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -2365,6 +2365,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_fs_util 0.0.0\",\n+ \"rustc_macros 0.1.0\",\n  \"rustc_target 0.0.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n@@ -2817,6 +2818,16 @@ dependencies = [\n  \"core 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_macros\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc_metadata\"\n version = \"0.0.0\""}, {"sha": "ca86aeb8100a9e6a52e44e313355163e55b5f649", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -109,6 +109,12 @@ fn main() {\n \n         cmd.arg(\"-Zexternal-macro-backtrace\");\n \n+        // Link crates to the proc macro crate for the target, but use a host proc macro crate\n+        // to actually run the macros\n+        if env::var_os(\"RUST_DUAL_PROC_MACROS\").is_some() {\n+            cmd.arg(\"-Zdual-proc-macros\");\n+        }\n+\n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n         // linking all deps statically into the dylib.\n@@ -258,13 +264,6 @@ fn main() {\n             }\n         }\n \n-        // Force all crates compiled by this compiler to (a) be unstable and (b)\n-        // allow the `rustc_private` feature to link to other unstable crates\n-        // also in the sysroot.\n-        if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n-            cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n-        }\n-\n         if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n             cmd.arg(\"--remap-path-prefix\").arg(&map);\n         }\n@@ -284,6 +283,14 @@ fn main() {\n         }\n     }\n \n+    // Force all crates compiled by this compiler to (a) be unstable and (b)\n+    // allow the `rustc_private` feature to link to other unstable crates\n+    // also in the sysroot. We also do this for host crates, since those\n+    // may be proc macros, in which case we might ship them.\n+    if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() && (stage != \"0\" || target.is_some()) {\n+        cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n+    }\n+\n     if env::var_os(\"RUSTC_PARALLEL_COMPILER\").is_some() {\n         cmd.arg(\"--cfg\").arg(\"parallel_compiler\");\n     }"}, {"sha": "eb1a2a59fa3c52590de053f125b07b86f1904476", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -812,6 +812,17 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n \n+        match mode {\n+            Mode::Std | Mode::Test | Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolTest=> {},\n+            Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n+                // Build proc macros both for the host and the target\n+                if target != compiler.host && cmd != \"check\" {\n+                    cargo.arg(\"-Zdual-proc-macros\");\n+                    cargo.env(\"RUST_DUAL_PROC_MACROS\", \"1\");\n+                }\n+            },\n+        }\n+\n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n         // Remove make-related flags to ensure Cargo can correctly set things up\n         cargo.env_remove(\"MAKEFLAGS\");"}, {"sha": "a30b465698e2a263b40b10f7ef6b7a33dd3442a4", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -42,7 +42,8 @@ impl Step for Std {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&builder, &libdir, &libstd_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(&builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n     }\n }\n \n@@ -88,7 +89,8 @@ impl Step for Rustc {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&builder, &libdir, &librustc_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(&builder, &libdir, &hostdir, &librustc_stamp(builder, compiler, target));\n     }\n }\n \n@@ -175,7 +177,8 @@ impl Step for Test {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(builder, &libdir, &libtest_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(builder, &libdir, &hostdir, &libtest_stamp(builder, compiler, target));\n     }\n }\n \n@@ -222,7 +225,8 @@ impl Step for Rustdoc {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&builder, &libdir, &rustdoc_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+        add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n         builder.cargo(compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }"}, {"sha": "9498dbb59523294c9a1ec26fca48757fb4245939", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -224,7 +224,8 @@ impl Step for StdLink {\n                 target_compiler.host,\n                 target));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(builder, &libdir, &libstd_stamp(builder, compiler, target));\n+        let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+        add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n \n         if builder.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n@@ -431,8 +432,12 @@ impl Step for TestLink {\n                 &compiler.host,\n                 target_compiler.host,\n                 target));\n-        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n-                    &libtest_stamp(builder, compiler, target));\n+        add_to_sysroot(\n+            builder,\n+            &builder.sysroot_libdir(target_compiler, target),\n+            &builder.sysroot_libdir(target_compiler, compiler.host),\n+            &libtest_stamp(builder, compiler, target)\n+        );\n \n         builder.cargo(target_compiler, Mode::ToolTest, target, \"clean\");\n     }\n@@ -496,8 +501,8 @@ impl Step for Rustc {\n             return;\n         }\n \n-        // Ensure that build scripts have a std to link against.\n-        builder.ensure(Std {\n+        // Ensure that build scripts and proc macros have a std / libproc_macro to link against.\n+        builder.ensure(Test {\n             compiler: builder.compiler(self.compiler.stage, builder.config.build),\n             target: builder.config.build,\n         });\n@@ -592,8 +597,12 @@ impl Step for RustcLink {\n                  &compiler.host,\n                  target_compiler.host,\n                  target));\n-        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n-                       &librustc_stamp(builder, compiler, target));\n+        add_to_sysroot(\n+            builder,\n+            &builder.sysroot_libdir(target_compiler, target),\n+            &builder.sysroot_libdir(target_compiler, compiler.host),\n+            &librustc_stamp(builder, compiler, target)\n+        );\n         builder.cargo(target_compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n@@ -1015,10 +1024,20 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(builder: &Builder<'_>, sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(\n+    builder: &Builder<'_>,\n+    sysroot_dst: &Path,\n+    sysroot_host_dst: &Path,\n+    stamp: &Path\n+) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in builder.read_stamp_file(stamp) {\n-        builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    t!(fs::create_dir_all(&sysroot_host_dst));\n+    for (path, host) in builder.read_stamp_file(stamp) {\n+        if host {\n+            builder.copy(&path, &sysroot_host_dst.join(path.file_name().unwrap()));\n+        } else {\n+            builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+        }\n     }\n }\n \n@@ -1047,8 +1066,14 @@ pub fn run_cargo(builder: &Builder<'_>,\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n     let ok = stream_cargo(builder, cargo, &mut |msg| {\n-        let filenames = match msg {\n-            CargoMessage::CompilerArtifact { filenames, .. } => filenames,\n+        let (filenames, crate_types) = match msg {\n+            CargoMessage::CompilerArtifact {\n+                filenames,\n+                target: CargoTarget {\n+                    crate_types,\n+                },\n+                ..\n+            } => (filenames, crate_types),\n             _ => return,\n         };\n         for filename in filenames {\n@@ -1063,15 +1088,19 @@ pub fn run_cargo(builder: &Builder<'_>,\n             let filename = Path::new(&*filename);\n \n             // If this was an output file in the \"host dir\" we don't actually\n-            // worry about it, it's not relevant for us.\n+            // worry about it, it's not relevant for us\n             if filename.starts_with(&host_root_dir) {\n+                // Unless it's a proc macro used in the compiler\n+                if crate_types.iter().any(|t| t == \"proc-macro\") {\n+                    deps.push((filename.to_path_buf(), true));\n+                }\n                 continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n-                deps.push(filename.to_path_buf());\n+                deps.push((filename.to_path_buf(), false));\n                 continue;\n             }\n \n@@ -1124,10 +1153,10 @@ pub fn run_cargo(builder: &Builder<'_>,\n             let candidate = format!(\"{}.lib\", path_to_add);\n             let candidate = PathBuf::from(candidate);\n             if candidate.exists() {\n-                deps.push(candidate);\n+                deps.push((candidate, false));\n             }\n         }\n-        deps.push(path_to_add.into());\n+        deps.push((path_to_add.into(), false));\n     }\n \n     // Now we want to update the contents of the stamp file, if necessary. First\n@@ -1140,12 +1169,13 @@ pub fn run_cargo(builder: &Builder<'_>,\n     let mut new_contents = Vec::new();\n     let mut max = None;\n     let mut max_path = None;\n-    for dep in deps.iter() {\n+    for (dep, proc_macro) in deps.iter() {\n         let mtime = mtime(dep);\n         if Some(mtime) > max {\n             max = Some(mtime);\n             max_path = Some(dep.clone());\n         }\n+        new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n@@ -1157,15 +1187,15 @@ pub fn run_cargo(builder: &Builder<'_>,\n     if contents_equal && max <= stamp_mtime {\n         builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n-        return deps\n+        return deps.into_iter().map(|(d, _)| d).collect()\n     }\n     if max > stamp_mtime {\n         builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n     } else {\n         builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n     }\n     t!(fs::write(&stamp, &new_contents));\n-    deps\n+    deps.into_iter().map(|(d, _)| d).collect()\n }\n \n pub fn stream_cargo(\n@@ -1211,13 +1241,19 @@ pub fn stream_cargo(\n     status.success()\n }\n \n+#[derive(Deserialize)]\n+pub struct CargoTarget<'a> {\n+    crate_types: Vec<Cow<'a, str>>,\n+}\n+\n #[derive(Deserialize)]\n #[serde(tag = \"reason\", rename_all = \"kebab-case\")]\n pub enum CargoMessage<'a> {\n     CompilerArtifact {\n         package_id: Cow<'a, str>,\n         features: Vec<Cow<'a, str>>,\n         filenames: Vec<Cow<'a, str>>,\n+        target: CargoTarget<'a>,\n     },\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,"}, {"sha": "9317a40545eac9f2b4c208223bc92c31c0227e1b", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -1129,7 +1129,7 @@ impl Build {\n         ret\n     }\n \n-    fn read_stamp_file(&self, stamp: &Path) -> Vec<PathBuf> {\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, bool)> {\n         if self.config.dry_run {\n             return Vec::new();\n         }\n@@ -1142,8 +1142,9 @@ impl Build {\n             if part.is_empty() {\n                 continue\n             }\n-            let path = PathBuf::from(t!(str::from_utf8(part)));\n-            paths.push(path);\n+            let host = part[0] as char == 'h';\n+            let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n+            paths.push((path, host));\n         }\n         paths\n     }"}, {"sha": "9dbcacf70262c131f32a6608a6d8e0c9665f329f", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -91,7 +91,8 @@ impl Step for ToolBuild {\n                 compile::CargoMessage::CompilerArtifact {\n                     package_id,\n                     features,\n-                    filenames\n+                    filenames,\n+                    target: _,\n                 } => {\n                     (package_id, features, filenames)\n                 }"}, {"sha": "31e10c19c7a60599351cd664673d9cb8f0fa60dd", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -24,6 +24,7 @@ rustc-rayon = \"0.1.2\"\n rustc-rayon-core = \"0.1.2\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "4b5670af138581ded1684e067c82e3f8ea5ffb86", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -32,6 +32,7 @@ use crate::ty::query::Providers;\n \n use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_macros::HashStable;\n \n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::{BTreeSet, BTreeMap};\n@@ -149,7 +150,7 @@ pub const DUMMY_HIR_ID: HirId = HirId {\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,"}, {"sha": "d8d4157e20ec93e300a86af1d2c162869ab55553", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -157,12 +157,6 @@ impl_stable_hash_for!(struct ast::Label {\n     ident\n });\n \n-impl_stable_hash_for!(struct hir::Lifetime {\n-    hir_id,\n-    span,\n-    name\n-});\n-\n impl_stable_hash_for!(struct hir::Path {\n     span,\n     def,"}, {"sha": "6adfaa53946ac29615932017d041d8d49fd83840", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -141,14 +141,8 @@ pub mod util {\n     pub mod bug;\n }\n \n-// A private module so that macro-expanded idents like\n-// `::rustc::lint::Lint` will also work in `rustc` itself.\n-//\n-// `libstd` uses the same trick.\n-#[doc(hidden)]\n-mod rustc {\n-    pub use crate::lint;\n-}\n+// Allows macros to refer to this crate as `::rustc`\n+extern crate self as rustc;\n \n // FIXME(#27438): right now the unit tests of librustc don't refer to any actual\n //                functions generated in librustc_data_structures (all"}, {"sha": "a4c587b5ca76195d762e40935e06cced35bd5851", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -1232,6 +1232,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          Use with RUST_REGION_GRAPH=help for more info\"),\n     parse_only: bool = (false, parse_bool, [UNTRACKED],\n         \"parse only; do not compile, assemble, or link\"),\n+    dual_proc_macros: bool = (false, parse_bool, [TRACKED],\n+        \"load proc macros for both target and host, but only link to the target\"),\n     no_codegen: bool = (false, parse_bool, [TRACKED],\n         \"run all passes except codegen; no output\"),\n     treat_err_as_bug: bool = (false, parse_bool, [TRACKED],"}, {"sha": "cf09d45ca38fc3556ac6d3760496ff8160848798", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -18,6 +18,7 @@ pub enum FileMatch {\n \n // A module for searching for libraries\n \n+#[derive(Clone)]\n pub struct FileSearch<'a> {\n     sysroot: &'a Path,\n     triple: &'a str,"}, {"sha": "2fe51a22fb4845463e49754264e764309949e278", "filename": "src/librustc_macros/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"rustc_macros\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+proc-macro = true\n+\n+[dependencies]\n+synstructure = \"0.10.1\"\n+syn = { version = \"0.15.22\", features = [\"full\"] }\n+proc-macro2 = \"0.4.24\"\n+quote = \"0.6.10\""}, {"sha": "6d7590c7d1cd3928b4ecaaa7dec467fe895b0796", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -0,0 +1,87 @@\n+use synstructure;\n+use syn::{self, Meta, NestedMeta, parse_quote};\n+use proc_macro2::{self, Ident};\n+use quote::quote;\n+\n+struct Attributes {\n+    ignore: bool,\n+    project: Option<Ident>,\n+}\n+\n+fn parse_attributes(field: &syn::Field) -> Attributes {\n+    let mut attrs = Attributes {\n+        ignore: false,\n+        project: None,\n+    };\n+    for attr in &field.attrs {\n+        if let Ok(meta) = attr.parse_meta() {\n+            if &meta.name().to_string() != \"stable_hasher\" {\n+                continue;\n+            }\n+            let mut any_attr = false;\n+            if let Meta::List(list) = meta {\n+                for nested in list.nested.iter() {\n+                    if let NestedMeta::Meta(meta) = nested {\n+                        if &meta.name().to_string() == \"ignore\" {\n+                            attrs.ignore = true;\n+                            any_attr = true;\n+                        }\n+                        if &meta.name().to_string() == \"project\" {\n+                            if let Meta::List(list) = meta {\n+                                if let Some(nested) = list.nested.iter().next() {\n+                                    if let NestedMeta::Meta(meta) = nested {\n+                                        attrs.project = Some(meta.name());\n+                                        any_attr = true;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if !any_attr {\n+                panic!(\"error parsing stable_hasher\");\n+            }\n+        }\n+    }\n+    attrs\n+}\n+\n+pub fn hash_stable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    let generic: syn::GenericParam = parse_quote!('__ctx);\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+    s.add_impl_generic(generic);\n+    let body = s.each(|bi| {\n+        let attrs = parse_attributes(bi.ast());\n+        if attrs.ignore {\n+             quote!{}\n+        } else if let Some(project) = attrs.project {\n+            quote!{\n+                &#bi.#project.hash_stable(__hcx, __hasher);\n+            }\n+        } else {\n+            quote!{\n+                #bi.hash_stable(__hcx, __hasher);\n+            }\n+        }\n+    });\n+\n+    let discriminant = match s.ast().data {\n+        syn::Data::Enum(_) => quote! {\n+            ::std::mem::discriminant(self).hash_stable(__hcx, __hasher);\n+        },\n+        syn::Data::Struct(_) => quote! {},\n+        syn::Data::Union(_) => panic!(\"cannot derive on union\"),\n+    };\n+\n+    s.bound_impl(quote!(::rustc_data_structures::stable_hasher::HashStable\n+                        <::rustc::ich::StableHashingContext<'__ctx>>), quote!{\n+        fn hash_stable<__W: ::rustc_data_structures::stable_hasher::StableHasherResult>(\n+            &self,\n+            __hcx: &mut ::rustc::ich::StableHashingContext<'__ctx>,\n+            __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<__W>) {\n+            #discriminant\n+            match *self { #body }\n+        }\n+    })\n+}"}, {"sha": "cad31264b05a415c16628077e0eb079194b74a64", "filename": "src/librustc_macros/src/lib.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -0,0 +1,8 @@\n+#![feature(proc_macro_hygiene)]\n+#![deny(rust_2018_idioms)]\n+\n+use synstructure::decl_derive;\n+\n+mod hash_stable;\n+\n+decl_derive!([HashStable, attributes(stable_hasher)] => hash_stable::hash_stable_derive);"}, {"sha": "36d9bf9f50dd59b7c2a48e704102e3fa27f3cb1d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 86, "deletions": 33, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -188,13 +188,15 @@ impl<'a> CrateLoader<'a> {\n         });\n     }\n \n-    fn register_crate(&mut self,\n-                      root: &Option<CratePaths>,\n-                      ident: Symbol,\n-                      span: Span,\n-                      lib: Library,\n-                      dep_kind: DepKind)\n-                      -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    fn register_crate(\n+        &mut self,\n+        host_lib: Option<Library>,\n+        root: &Option<CratePaths>,\n+        ident: Symbol,\n+        span: Span,\n+        lib: Library,\n+        dep_kind: DepKind\n+    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n         let crate_root = lib.metadata.get_root();\n         info!(\"register crate `extern crate {} as {}`\", crate_root.name, ident);\n         self.verify_no_symbol_conflicts(span, &crate_root);\n@@ -222,7 +224,16 @@ impl<'a> CrateLoader<'a> {\n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n         let proc_macros = crate_root.proc_macro_decls_static.map(|_| {\n-            self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n+            if self.sess.opts.debugging_opts.dual_proc_macros {\n+                let host_lib = host_lib.unwrap();\n+                self.load_derive_macros(\n+                    &host_lib.metadata.get_root(),\n+                    host_lib.dylib.clone().map(|p| p.0),\n+                    span\n+                )\n+            } else {\n+                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n+            }\n         });\n \n         let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n@@ -269,6 +280,61 @@ impl<'a> CrateLoader<'a> {\n         (cnum, cmeta)\n     }\n \n+    fn load_proc_macro<'b> (\n+        &mut self,\n+        locate_ctxt: &mut locator::Context<'b>,\n+        path_kind: PathKind,\n+    ) -> Option<(LoadResult, Option<Library>)>\n+    where\n+        'a: 'b\n+    {\n+        // Use a new locator Context so trying to load a proc macro doesn't affect the error\n+        // message we emit\n+        let mut proc_macro_locator = locate_ctxt.clone();\n+\n+        // Try to load a proc macro\n+        proc_macro_locator.is_proc_macro = Some(true);\n+\n+        // Load the proc macro crate for the target\n+        let (locator, target_result) = if self.sess.opts.debugging_opts.dual_proc_macros {\n+            proc_macro_locator.reset();\n+            let result = match self.load(&mut proc_macro_locator)? {\n+                LoadResult::Previous(cnum) => return Some((LoadResult::Previous(cnum), None)),\n+                LoadResult::Loaded(library) => Some(LoadResult::Loaded(library))\n+            };\n+            // Don't look for a matching hash when looking for the host crate.\n+            // It won't be the same as the target crate hash\n+            locate_ctxt.hash = None;\n+            // Use the locate_ctxt when looking for the host proc macro crate, as that is required\n+            // so we want it to affect the error message\n+            (locate_ctxt, result)\n+        } else {\n+            (&mut proc_macro_locator, None)\n+        };\n+\n+        // Load the proc macro crate for the host\n+\n+        locator.reset();\n+        locator.is_proc_macro = Some(true);\n+        locator.target = &self.sess.host;\n+        locator.triple = TargetTriple::from_triple(config::host_triple());\n+        locator.filesearch = self.sess.host_filesearch(path_kind);\n+\n+        let host_result = self.load(locator)?;\n+\n+        Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n+            let host_result = match host_result {\n+                LoadResult::Previous(..) => {\n+                    panic!(\"host and target proc macros must be loaded in lock-step\")\n+                }\n+                LoadResult::Loaded(library) => library\n+            };\n+            (target_result.unwrap(), Some(host_result))\n+        } else {\n+            (host_result, None)\n+        })\n+    }\n+\n     fn resolve_crate<'b>(\n         &'b mut self,\n         root: &'b Option<CratePaths>,\n@@ -282,7 +348,7 @@ impl<'a> CrateLoader<'a> {\n     ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n         let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n-            LoadResult::Previous(cnum)\n+            (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n             let mut locate_ctxt = locator::Context {\n@@ -294,7 +360,7 @@ impl<'a> CrateLoader<'a> {\n                 extra_filename: extra_filename,\n                 filesearch: self.sess.target_filesearch(path_kind),\n                 target: &self.sess.target.target,\n-                triple: &self.sess.opts.target_triple,\n+                triple: self.sess.opts.target_triple.clone(),\n                 root,\n                 rejected_via_hash: vec![],\n                 rejected_via_triple: vec![],\n@@ -306,28 +372,14 @@ impl<'a> CrateLoader<'a> {\n                 metadata_loader: &*self.cstore.metadata_loader,\n             };\n \n-            self.load(&mut locate_ctxt).or_else(|| {\n+            self.load(&mut locate_ctxt).map(|r| (r, None)).or_else(|| {\n                 dep_kind = DepKind::UnexportedMacrosOnly;\n-\n-                let mut proc_macro_locator = locator::Context {\n-                    target: &self.sess.host,\n-                    triple: &TargetTriple::from_triple(config::host_triple()),\n-                    filesearch: self.sess.host_filesearch(path_kind),\n-                    rejected_via_hash: vec![],\n-                    rejected_via_triple: vec![],\n-                    rejected_via_kind: vec![],\n-                    rejected_via_version: vec![],\n-                    rejected_via_filename: vec![],\n-                    is_proc_macro: Some(true),\n-                    ..locate_ctxt\n-                };\n-\n-                self.load(&mut proc_macro_locator)\n+                self.load_proc_macro(&mut locate_ctxt, path_kind)\n             }).ok_or_else(move || LoadError::LocatorError(locate_ctxt))?\n         };\n \n         match result {\n-            LoadResult::Previous(cnum) => {\n+            (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n                 if data.root.proc_macro_decls_static.is_some() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n@@ -337,9 +389,10 @@ impl<'a> CrateLoader<'a> {\n                 });\n                 Ok((cnum, data))\n             }\n-            LoadResult::Loaded(library) => {\n-                Ok(self.register_crate(root, ident, span, library, dep_kind))\n+            (LoadResult::Loaded(library), host_library) => {\n+                Ok(self.register_crate(host_library, root, ident, span, library, dep_kind))\n             }\n+            _ => panic!()\n         }\n     }\n \n@@ -355,7 +408,7 @@ impl<'a> CrateLoader<'a> {\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n         let root = library.metadata.get_root();\n-        if locate_ctxt.triple == &self.sess.opts.target_triple {\n+        if locate_ctxt.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.root.name == root.name && root.hash == data.root.hash {\n@@ -451,9 +504,9 @@ impl<'a> CrateLoader<'a> {\n     fn read_extension_crate(&mut self, span: Span, orig_name: Symbol, rename: Symbol)\n                             -> ExtensionCrate {\n         info!(\"read extension crate `extern crate {} as {}`\", orig_name, rename);\n-        let target_triple = &self.sess.opts.target_triple;\n+        let target_triple = self.sess.opts.target_triple.clone();\n         let host_triple = TargetTriple::from_triple(config::host_triple());\n-        let is_cross = target_triple != &host_triple;\n+        let is_cross = target_triple != host_triple;\n         let mut target_only = false;\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n@@ -464,7 +517,7 @@ impl<'a> CrateLoader<'a> {\n             extra_filename: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n-            triple: &host_triple,\n+            triple: host_triple,\n             root: &None,\n             rejected_via_hash: vec![],\n             rejected_via_triple: vec![],"}, {"sha": "6fe00a4ad2ff2607090912870fbc4bc2875e4aac", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -648,7 +648,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n-            true => None,\n+            true => self.root.proc_macro_stability.clone(),\n             false => self.entry(id).stability.map(|stab| stab.decode(self)),\n         }\n     }"}, {"sha": "683056c9b33a0348b4e4b000aaa2d7f68bface94", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -490,7 +490,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-\n+            proc_macro_stability: if is_proc_macro {\n+                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| stab.clone())\n+            } else {\n+                None\n+            },\n             compiler_builtins: attr::contains_name(&attrs, \"compiler_builtins\"),\n             needs_allocator: attr::contains_name(&attrs, \"needs_allocator\"),\n             needs_panic_runtime: attr::contains_name(&attrs, \"needs_panic_runtime\"),"}, {"sha": "81878c4f687b6df0797527264ad082f2c71e679c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -244,11 +244,13 @@ use rustc_data_structures::owning_ref::OwningRef;\n \n use log::{debug, info, warn};\n \n+#[derive(Clone)]\n pub struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n }\n \n+#[derive(Clone)]\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n@@ -258,7 +260,7 @@ pub struct Context<'a> {\n     pub extra_filename: Option<&'a str>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n-    pub triple: &'a TargetTriple,\n+    pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n     pub root: &'a Option<CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n@@ -302,6 +304,14 @@ impl CratePaths {\n }\n \n impl<'a> Context<'a> {\n+    pub fn reset(&mut self) {\n+        self.rejected_via_hash.clear();\n+        self.rejected_via_triple.clear();\n+        self.rejected_via_kind.clear();\n+        self.rejected_via_version.clear();\n+        self.rejected_via_filename.clear();\n+    }\n+\n     pub fn maybe_load_library_crate(&mut self) -> Option<Library> {\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n@@ -399,7 +409,7 @@ impl<'a> Context<'a> {\n                                            add);\n \n             if (self.ident == \"std\" || self.ident == \"core\")\n-                && self.triple != &TargetTriple::from_triple(config::host_triple()) {\n+                && self.triple != TargetTriple::from_triple(config::host_triple()) {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }\n             err.span_label(self.span, \"can't find crate\");\n@@ -718,7 +728,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        if &root.triple != self.triple {\n+        if root.triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\",\n                   self.triple,\n                   root.triple);"}, {"sha": "afeea9947b5e3ecb149f9f42ecc1c0f7cdd13410", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -187,6 +187,7 @@ pub struct CrateRoot {\n     pub has_default_lib_allocator: bool,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub proc_macro_decls_static: Option<DefIndex>,\n+    pub proc_macro_stability: Option<attr::Stability>,\n \n     pub crate_deps: LazySeq<CrateDep>,\n     pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,"}, {"sha": "9f67f642df1cec67aab1b2be77d4b269a25dc317", "filename": "src/test/ui-fulldeps/hash-stable-is-unstable.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -0,0 +1,15 @@\n+// ignore-stage1\n+\n+extern crate rustc_data_structures;\n+//~^ use of unstable library feature 'rustc_private'\n+extern crate rustc;\n+//~^ use of unstable library feature 'rustc_private'\n+extern crate rustc_macros;\n+//~^ use of unstable library feature 'rustc_private'\n+\n+use rustc_macros::HashStable;\n+//~^ use of unstable library feature 'rustc_private'\n+\n+#[derive(HashStable)]\n+//~^ use of unstable library feature 'rustc_private'\n+struct Test;"}, {"sha": "e7007204d3895111fe006d2dc979459003fd6478", "filename": "src/test/ui-fulldeps/hash-stable-is-unstable.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.stderr?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -0,0 +1,48 @@\n+error[E0601]: `main` function not found in crate `hash_stable_is_unstable`\n+   |\n+   = note: consider adding a `main` function to `$DIR/hash-stable-is-unstable.rs`\n+\n+error[E0658]: use of unstable library feature 'rustc_private': this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via `Cargo.toml` instead? (see issue #27812)\n+  --> $DIR/hash-stable-is-unstable.rs:3:1\n+   |\n+LL | extern crate rustc_data_structures;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(rustc_private)] to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'rustc_private': this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via `Cargo.toml` instead? (see issue #27812)\n+  --> $DIR/hash-stable-is-unstable.rs:5:1\n+   |\n+LL | extern crate rustc;\n+   | ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(rustc_private)] to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'rustc_private': this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via `Cargo.toml` instead? (see issue #27812)\n+  --> $DIR/hash-stable-is-unstable.rs:7:1\n+   |\n+LL | extern crate rustc_macros;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(rustc_private)] to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'rustc_private': this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via `Cargo.toml` instead? (see issue #27812)\n+  --> $DIR/hash-stable-is-unstable.rs:10:5\n+   |\n+LL | use rustc_macros::HashStable;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(rustc_private)] to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'rustc_private': this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via `Cargo.toml` instead? (see issue #27812)\n+  --> $DIR/hash-stable-is-unstable.rs:13:10\n+   |\n+LL | #[derive(HashStable)]\n+   |          ^^^^^^^^^^\n+   |\n+   = help: add #![feature(rustc_private)] to the crate attributes to enable\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors occurred: E0601, E0658.\n+For more information about an error, try `rustc --explain E0601`."}, {"sha": "d7683aae841cdd923b157b8f1e4dfaa43eb890db", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547ceb200f0385ba437e1808b468ec81e683c64/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=0547ceb200f0385ba437e1808b468ec81e683c64", "patch": "@@ -137,6 +137,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"smallvec\"),\n     Crate(\"stable_deref_trait\"),\n     Crate(\"syn\"),\n+    Crate(\"synstructure\"),\n     Crate(\"tempfile\"),\n     Crate(\"termcolor\"),\n     Crate(\"terminon\"),"}]}