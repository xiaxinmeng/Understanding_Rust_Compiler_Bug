{"sha": "8403b82ddb6657dead95c6c3877824ffb3f13af2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MDNiODJkZGI2NjU3ZGVhZDk1YzZjMzg3NzgyNGZmYjNmMTNhZjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-22T19:11:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-31T13:51:18Z"}, "message": "Port over type inference to using the new type relation stuff", "tree": {"sha": "4433893f405be19ba0a0aec45c5d6b82afb61a80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4433893f405be19ba0a0aec45c5d6b82afb61a80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8403b82ddb6657dead95c6c3877824ffb3f13af2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8403b82ddb6657dead95c6c3877824ffb3f13af2", "html_url": "https://github.com/rust-lang/rust/commit/8403b82ddb6657dead95c6c3877824ffb3f13af2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8403b82ddb6657dead95c6c3877824ffb3f13af2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e301d7cab2d7f7dbbb6d5ee5d2fc1482f9fdd50d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e301d7cab2d7f7dbbb6d5ee5d2fc1482f9fdd50d", "html_url": "https://github.com/rust-lang/rust/commit/e301d7cab2d7f7dbbb6d5ee5d2fc1482f9fdd50d"}], "stats": {"total": 2095, "additions": 1140, "deletions": 955}, "files": [{"sha": "8a4790c17a4058b97879aaf6fb7fbf0ae3bd44fa", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -122,6 +122,7 @@ pub mod middle {\n     pub mod traits;\n     pub mod ty;\n     pub mod ty_fold;\n+    pub mod ty_relate;\n     pub mod ty_walk;\n     pub mod weak_lang_items;\n }"}, {"sha": "940dc75271c22f0a33d1585ab2af2a0eee1aede9", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -25,66 +25,54 @@\n //! In particular, it might be enough to say (A,B) are bivariant for\n //! all (A,B).\n \n-use middle::ty::BuiltinBounds;\n+use super::combine::{self, CombineFields};\n+use super::type_variable::{BiTo};\n+\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::infer::combine::*;\n-use middle::infer::CombineResult;\n-use middle::infer::type_variable::BiTo;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n-pub struct Bivariate<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Bivariate<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Bivariate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Bivariate<'f, 'tcx> {\n-    Bivariate { fields: cf }\n+impl<'a, 'tcx> Bivariate<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Bivariate<'a, 'tcx> {\n+        Bivariate { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Bivariate\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> CombineResult<'tcx, Ty<'tcx>>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Contravariant => self.tys(a, b),\n-            ty::Bivariant => self.tys(a, b),\n-        }\n-    }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> CombineResult<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Contravariant => self.regions(a, b),\n-            ty::Bivariant => self.regions(a, b),\n-        }\n-    }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions(&self, a: ty::Region, _: ty::Region) -> CombineResult<'tcx, ty::Region> {\n-        Ok(a)\n-    }\n-\n-    fn builtin_bounds(&self,\n-                      a: BuiltinBounds,\n-                      b: BuiltinBounds)\n-                      -> CombineResult<'tcx, BuiltinBounds>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n+        match variance {\n+            // If we have Foo<A> and Foo is invariant w/r/t A,\n+            // and we want to assert that\n+            //\n+            //     Foo<A> <: Foo<B> ||\n+            //     Foo<B> <: Foo<A>\n+            //\n+            // then still A must equal B.\n+            ty::Invariant => self.relate(a, b),\n+\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.relate(a, b),\n+            ty::Contravariant => self.relate(a, b),\n         }\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n@@ -109,17 +97,22 @@ impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> CombineResult<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, _: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n         let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n         let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n-        let c = try!(Combineable::combine(self, &a1, &b1));\n+        let c = try!(self.relate(&a1, &b1));\n         Ok(ty::Binder(c))\n     }\n }"}, {"sha": "86f12b669b35ebe42f714835d26cb2c5cb7a74dd", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 104, "deletions": 600, "changes": 704, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -37,648 +37,155 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::{InferCtxt, CombineResult};\n+use super::{InferCtxt};\n use super::{MiscVariable, TypeTrace};\n use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n-use middle::subst;\n-use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n-use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n+use middle::ty::{TyVar};\n use middle::ty::{IntType, UintType};\n-use middle::ty::BuiltinBounds;\n use middle::ty::{self, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n-use syntax::ast::Unsafety;\n use syntax::ast;\n-use syntax::abi;\n use syntax::codemap::Span;\n \n-pub trait Combine<'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n-    fn tag(&self) -> String;\n-\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx>;\n-\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields().infcx }\n-    fn a_is_expected(&self) -> bool { self.fields().a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields().trace.clone() }\n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { self.fields().equate() }\n-    fn bivariate<'a>(&'a self) -> Bivariate<'a, 'tcx> { self.fields().bivariate() }\n-\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { self.fields().sub() }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields().clone()) }\n-\n-    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> CombineResult<'tcx, ty::mt<'tcx>> {\n-        debug!(\"{}.mts({}, {})\",\n-               self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n-\n-        if a.mutbl != b.mutbl {\n-            Err(ty::terr_mutability)\n-        } else {\n-            let mutbl = a.mutbl;\n-            let variance = match mutbl {\n-                ast::MutImmutable => ty::Covariant,\n-                ast::MutMutable => ty::Invariant,\n-            };\n-            let ty = try!(self.tys_with_variance(variance, a.ty, b.ty));\n-            Ok(ty::mt {ty: ty, mutbl: mutbl})\n-        }\n-    }\n-\n-    fn tys_with_variance(&self, variance: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> CombineResult<'tcx, Ty<'tcx>>;\n-\n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, Ty<'tcx>>;\n-\n-    fn regions_with_variance(&self, variance: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> CombineResult<'tcx, ty::Region>;\n-\n-    fn regions(&self, a: ty::Region, b: ty::Region) -> CombineResult<'tcx, ty::Region>;\n-\n-    fn substs(&self,\n-              item_def_id: ast::DefId,\n-              a_subst: &subst::Substs<'tcx>,\n-              b_subst: &subst::Substs<'tcx>)\n-              -> CombineResult<'tcx, subst::Substs<'tcx>>\n-    {\n-        debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n-               item_def_id.repr(self.infcx().tcx),\n-               a_subst.repr(self.infcx().tcx),\n-               b_subst.repr(self.infcx().tcx));\n-\n-        let variances = if self.infcx().tcx.variance_computed.get() {\n-            Some(ty::item_variances(self.infcx().tcx, item_def_id))\n-        } else {\n-            None\n-        };\n-        self.substs_variances(variances.as_ref().map(|v| &**v), a_subst, b_subst)\n-    }\n-\n-    fn substs_variances(&self,\n-                        variances: Option<&ty::ItemVariances>,\n-                        a_subst: &subst::Substs<'tcx>,\n-                        b_subst: &subst::Substs<'tcx>)\n-                        -> CombineResult<'tcx, subst::Substs<'tcx>>\n-    {\n-        let mut substs = subst::Substs::empty();\n-\n-        for &space in &subst::ParamSpace::all() {\n-            let a_tps = a_subst.types.get_slice(space);\n-            let b_tps = b_subst.types.get_slice(space);\n-            let t_variances = variances.map(|v| v.types.get_slice(space));\n-            let tps = try!(relate_type_params(self, t_variances, a_tps, b_tps));\n-            substs.types.replace(space, tps);\n-        }\n-\n-        match (&a_subst.regions, &b_subst.regions) {\n-            (&ErasedRegions, _) | (_, &ErasedRegions) => {\n-                substs.regions = ErasedRegions;\n-            }\n-\n-            (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n-                for &space in &subst::ParamSpace::all() {\n-                    let a_regions = a.get_slice(space);\n-                    let b_regions = b.get_slice(space);\n-                    let r_variances = variances.map(|v| v.regions.get_slice(space));\n-                    let regions = try!(relate_region_params(self,\n-                                                            r_variances,\n-                                                            a_regions,\n-                                                            b_regions));\n-                    substs.mut_regions().replace(space, regions);\n-                }\n-            }\n-        }\n-\n-        return Ok(substs);\n-\n-        fn relate_type_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                      variances: Option<&[ty::Variance]>,\n-                                                      a_tys: &[Ty<'tcx>],\n-                                                      b_tys: &[Ty<'tcx>])\n-                                                      -> CombineResult<'tcx, Vec<Ty<'tcx>>>\n-        {\n-            if a_tys.len() != b_tys.len() {\n-                return Err(ty::terr_ty_param_size(expected_found(this,\n-                                                                 a_tys.len(),\n-                                                                 b_tys.len())));\n-            }\n-\n-            (0.. a_tys.len()).map(|i| {\n-                let a_ty = a_tys[i];\n-                let b_ty = b_tys[i];\n-                let v = variances.map_or(ty::Invariant, |v| v[i]);\n-                this.tys_with_variance(v, a_ty, b_ty)\n-            }).collect()\n-        }\n-\n-        fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                        variances: Option<&[ty::Variance]>,\n-                                                        a_rs: &[ty::Region],\n-                                                        b_rs: &[ty::Region])\n-                                                        -> CombineResult<'tcx, Vec<ty::Region>>\n-        {\n-            let tcx = this.infcx().tcx;\n-            let num_region_params = a_rs.len();\n-\n-            debug!(\"relate_region_params(\\\n-                   a_rs={}, \\\n-                   b_rs={},\n-                   variances={})\",\n-                   a_rs.repr(tcx),\n-                   b_rs.repr(tcx),\n-                   variances.repr(tcx));\n-\n-            assert_eq!(num_region_params,\n-                       variances.map_or(num_region_params,\n-                                        |v| v.len()));\n-\n-            assert_eq!(num_region_params, b_rs.len());\n-\n-            (0..a_rs.len()).map(|i| {\n-                let a_r = a_rs[i];\n-                let b_r = b_rs[i];\n-                let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-                this.regions_with_variance(variance, a_r, b_r)\n-            }).collect()\n-        }\n-    }\n-\n-    fn bare_fn_tys(&self, a: &ty::BareFnTy<'tcx>,\n-                   b: &ty::BareFnTy<'tcx>) -> CombineResult<'tcx, ty::BareFnTy<'tcx>> {\n-        let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n-        let abi = try!(self.abi(a.abi, b.abi));\n-        let sig = try!(self.binders(&a.sig, &b.sig));\n-        Ok(ty::BareFnTy {unsafety: unsafety,\n-                         abi: abi,\n-                         sig: sig})\n-    }\n-\n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> CombineResult<'tcx, ty::FnSig<'tcx>> {\n-        if a.variadic != b.variadic {\n-            return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n-        }\n-\n-        let inputs = try!(argvecs(self,\n-                                  &a.inputs,\n-                                  &b.inputs));\n-\n-        let output = try!(match (a.output, b.output) {\n-            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(try!(self.tys(a_ty, b_ty)))),\n-            (ty::FnDiverging, ty::FnDiverging) =>\n-                Ok(ty::FnDiverging),\n-            (a, b) =>\n-                Err(ty::terr_convergence_mismatch(\n-                    expected_found(self, a != ty::FnDiverging, b != ty::FnDiverging))),\n-        });\n-\n-        return Ok(ty::FnSig {inputs: inputs,\n-                             output: output,\n-                             variadic: a.variadic});\n-\n-\n-        fn argvecs<'tcx, C>(combiner: &C,\n-                            a_args: &[Ty<'tcx>],\n-                            b_args: &[Ty<'tcx>])\n-                            -> CombineResult<'tcx, Vec<Ty<'tcx>>>\n-                            where C: Combine<'tcx> {\n-            if a_args.len() == b_args.len() {\n-                a_args.iter().zip(b_args.iter())\n-                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n-            } else {\n-                Err(ty::terr_arg_count)\n-            }\n-        }\n-    }\n-\n-    fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, Ty<'tcx>> {\n-        self.tys_with_variance(ty::Contravariant, a, b).and_then(|t| Ok(t))\n-    }\n-\n-    fn unsafeties(&self, a: Unsafety, b: Unsafety) -> CombineResult<'tcx, Unsafety> {\n-        if a != b {\n-            Err(ty::terr_unsafety_mismatch(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n-    fn abi(&self, a: abi::Abi, b: abi::Abi) -> CombineResult<'tcx, abi::Abi> {\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n-        }\n-    }\n-\n-    fn projection_tys(&self,\n-                      a: &ty::ProjectionTy<'tcx>,\n-                      b: &ty::ProjectionTy<'tcx>)\n-                      -> CombineResult<'tcx, ty::ProjectionTy<'tcx>>\n-    {\n-        if a.item_name != b.item_name {\n-            Err(ty::terr_projection_name_mismatched(\n-                expected_found(self, a.item_name, b.item_name)))\n-        } else {\n-            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n-            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n-        }\n-    }\n-\n-    fn projection_predicates(&self,\n-                             a: &ty::ProjectionPredicate<'tcx>,\n-                             b: &ty::ProjectionPredicate<'tcx>)\n-                             -> CombineResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-    {\n-        let projection_ty = try!(self.projection_tys(&a.projection_ty, &b.projection_ty));\n-        let ty = try!(self.tys(a.ty, b.ty));\n-        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n-    }\n-\n-    fn projection_bounds(&self,\n-                         a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                         b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                         -> CombineResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n-    {\n-        // To be compatible, `a` and `b` must be for precisely the\n-        // same set of traits and item names. We always require that\n-        // projection bounds lists are sorted by trait-def-id and item-name,\n-        // so we can just iterate through the lists pairwise, so long as they are the\n-        // same length.\n-        if a.len() != b.len() {\n-            Err(ty::terr_projection_bounds_length(expected_found(self, a.len(), b.len())))\n-        } else {\n-            a.iter()\n-                .zip(b.iter())\n-                .map(|(a, b)| self.binders(a, b))\n-                .collect()\n-        }\n-    }\n-\n-    fn existential_bounds(&self,\n-                          a: &ty::ExistentialBounds<'tcx>,\n-                          b: &ty::ExistentialBounds<'tcx>)\n-                          -> CombineResult<'tcx, ty::ExistentialBounds<'tcx>>\n-    {\n-        let r = try!(self.regions_with_variance(ty::Contravariant, a.region_bound, b.region_bound));\n-        let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n-        let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n-        Ok(ty::ExistentialBounds { region_bound: r,\n-                                   builtin_bounds: nb,\n-                                   projection_bounds: pb })\n-    }\n-\n-    fn builtin_bounds(&self,\n-                      a: BuiltinBounds,\n-                      b: BuiltinBounds)\n-                      -> CombineResult<'tcx, BuiltinBounds>\n-    {\n-        // Two sets of builtin bounds are only relatable if they are\n-        // precisely the same (but see the coercion code).\n-        if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n-    fn trait_refs(&self,\n-                  a: &ty::TraitRef<'tcx>,\n-                  b: &ty::TraitRef<'tcx>)\n-                  -> CombineResult<'tcx, ty::TraitRef<'tcx>>\n-    {\n-        // Different traits cannot be related\n-        if a.def_id != b.def_id {\n-            Err(ty::terr_traits(expected_found(self, a.def_id, b.def_id)))\n-        } else {\n-            let substs = try!(self.substs(a.def_id, a.substs, b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id, substs: self.tcx().mk_substs(substs) })\n-        }\n-    }\n-\n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> CombineResult<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>;\n-    // this must be overridden to do correctly, so as to account for higher-ranked\n-    // behavior\n-}\n-\n-pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> CombineResult<'tcx, Self>;\n-}\n-\n-impl<'tcx,T> Combineable<'tcx> for Rc<T>\n-    where T : Combineable<'tcx>\n-{\n-    fn combine<C>(combiner: &C,\n-                  a: &Rc<T>,\n-                  b: &Rc<T>)\n-                  -> CombineResult<'tcx, Rc<T>>\n-                  where C: Combine<'tcx> {\n-        Ok(Rc::new(try!(Combineable::combine(combiner, &**a, &**b))))\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::TraitRef<'tcx>,\n-                  b: &ty::TraitRef<'tcx>)\n-                  -> CombineResult<'tcx, ty::TraitRef<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.trait_refs(a, b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &Ty<'tcx>,\n-                  b: &Ty<'tcx>)\n-                  -> CombineResult<'tcx, Ty<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.tys(*a, *b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::ProjectionPredicate<'tcx>,\n-                  b: &ty::ProjectionPredicate<'tcx>)\n-                  -> CombineResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.projection_predicates(a, b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::FnSig<'tcx>,\n-                  b: &ty::FnSig<'tcx>)\n-                  -> CombineResult<'tcx, ty::FnSig<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.fn_sigs(a, b)\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n }\n \n-pub fn expected_found<'tcx, C, T>(this: &C,\n-                                  a: T,\n-                                  b: T)\n-                                  -> ty::expected_found<T>\n-                                  where C: Combine<'tcx>\n-{\n-    expected_found_bool(this.a_is_expected(), a, b)\n-}\n-\n-fn expected_found_bool<T>(a_is_expected: bool,\n-                          a: T,\n-                          b: T)\n-                          -> ty::expected_found<T>\n+pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n+                                       relation: &mut R,\n+                                       a: Ty<'tcx>,\n+                                       b: Ty<'tcx>)\n+                                       -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n {\n-    if a_is_expected {\n-        ty::expected_found {expected: a, found: b}\n-    } else {\n-        ty::expected_found {expected: b, found: a}\n-    }\n-}\n-\n-pub fn super_tys<'tcx, C>(this: &C,\n-                          a: Ty<'tcx>,\n-                          b: Ty<'tcx>)\n-                          -> CombineResult<'tcx, Ty<'tcx>>\n-                          where C: Combine<'tcx> {\n-    let tcx = this.infcx().tcx;\n-    let a_sty = &a.sty;\n-    let b_sty = &b.sty;\n-    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n-    return match (a_sty, b_sty) {\n-        // The \"subtype\" ought to be handling cases involving var:\n-        (&ty::ty_infer(TyVar(_)), _)\n-        | (_, &ty::ty_infer(TyVar(_))) =>\n-            tcx.sess.bug(\n-                &format!(\"{}: bot and var types should have been handled ({},{})\",\n-                this.tag(),\n-                a.repr(this.infcx().tcx),\n-                b.repr(this.infcx().tcx))),\n-\n-        (&ty::ty_err, _) | (_, &ty::ty_err) => Ok(tcx.types.err),\n+    let a_is_expected = relation.a_is_expected();\n \n+    match (&a.sty, &b.sty) {\n         // Relate integral variables to other types\n-        (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n-            try!(this.infcx().int_unification_table\n-                             .borrow_mut()\n-                             .unify_var_var(a_id, b_id)\n-                             .map_err(|e| int_unification_error(this.a_is_expected(), e)));\n+        (&ty::ty_infer(ty::IntVar(a_id)), &ty::ty_infer(ty::IntVar(b_id))) => {\n+            try!(infcx.int_unification_table\n+                      .borrow_mut()\n+                      .unify_var_var(a_id, b_id)\n+                      .map_err(|e| int_unification_error(a_is_expected, e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(IntVar(v_id)), &ty::ty_int(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(), v_id, IntType(v))\n+        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_int(v)) => {\n+            unify_integral_variable(infcx, a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_int(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(), v_id, IntType(v))\n+        (&ty::ty_int(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+            unify_integral_variable(infcx, !a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_infer(IntVar(v_id)), &ty::ty_uint(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(), v_id, UintType(v))\n+        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_uint(v)) => {\n+            unify_integral_variable(infcx, a_is_expected, v_id, UintType(v))\n         }\n-        (&ty::ty_uint(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(), v_id, UintType(v))\n+        (&ty::ty_uint(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+            unify_integral_variable(infcx, !a_is_expected, v_id, UintType(v))\n         }\n \n         // Relate floating-point variables to other types\n-        (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n-            try!(this.infcx().float_unification_table\n-                             .borrow_mut()\n-                             .unify_var_var(a_id, b_id)\n-                             .map_err(|e| float_unification_error(this.a_is_expected(), e)));\n+        (&ty::ty_infer(ty::FloatVar(a_id)), &ty::ty_infer(ty::FloatVar(b_id))) => {\n+            try!(infcx.float_unification_table\n+                      .borrow_mut()\n+                      .unify_var_var(a_id, b_id)\n+                      .map_err(|e| float_unification_error(relation.a_is_expected(), e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(FloatVar(v_id)), &ty::ty_float(v)) => {\n-            unify_float_variable(this, this.a_is_expected(), v_id, v)\n-        }\n-        (&ty::ty_float(v), &ty::ty_infer(FloatVar(v_id))) => {\n-            unify_float_variable(this, !this.a_is_expected(), v_id, v)\n-        }\n-\n-        (&ty::ty_char, _)\n-        | (&ty::ty_bool, _)\n-        | (&ty::ty_int(_), _)\n-        | (&ty::ty_uint(_), _)\n-        | (&ty::ty_float(_), _) => {\n-            if a == b {\n-                Ok(a)\n-            } else {\n-                Err(ty::terr_sorts(expected_found(this, a, b)))\n-            }\n-        }\n-\n-        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p)) if\n-          a_p.idx == b_p.idx && a_p.space == b_p.space => Ok(a),\n-\n-        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n-          if a_id == b_id => {\n-            let substs = try!(this.substs(a_id, a_substs, b_substs));\n-            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n-        }\n-\n-        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) => {\n-            debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n-            let principal = try!(this.binders(&a_.principal, &b_.principal));\n-            let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n-            Ok(ty::mk_trait(tcx, principal, bounds))\n-        }\n-\n-        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n-          if a_id == b_id => {\n-            let substs = try!(this.substs(a_id, a_substs, b_substs));\n-            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n-        }\n-\n-        (&ty::ty_closure(a_id, a_substs),\n-         &ty::ty_closure(b_id, b_substs))\n-          if a_id == b_id => {\n-            // All ty_closure types with the same id represent\n-            // the (anonymous) type of the same closure expression. So\n-            // all of their regions should be equated.\n-            let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n-        }\n-\n-        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-            let typ = try!(this.tys(a_inner, b_inner));\n-            Ok(ty::mk_uniq(tcx, typ))\n-        }\n-\n-        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-            let mt = try!(this.mts(a_mt, b_mt));\n-            Ok(ty::mk_ptr(tcx, mt))\n-        }\n-\n-        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n-            let mt = try!(this.mts(a_mt, b_mt));\n-            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n-        }\n-\n-        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n-            this.tys(a_t, b_t).and_then(|t| {\n-                if sz_a == sz_b {\n-                    Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n-                } else {\n-                    Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n-                }\n-            })\n-        }\n-\n-        (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n-            this.tys(a_t, b_t).and_then(|t| {\n-                if sz_a == sz_b {\n-                    Ok(ty::mk_vec(tcx, t, sz_a))\n-                } else {\n-                    Err(ty::terr_sorts(expected_found(this, a, b)))\n-                }\n-            })\n-        }\n-\n-        (&ty::ty_str, &ty::ty_str) => Ok(ty::mk_str(tcx)),\n-\n-        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n-            if as_.len() == bs.len() {\n-                as_.iter().zip(bs.iter())\n-                   .map(|(a, b)| this.tys(*a, *b))\n-                   .collect::<Result<_, _>>()\n-                   .map(|ts| ty::mk_tup(tcx, ts))\n-            } else if as_.len() != 0 && bs.len() != 0 {\n-                Err(ty::terr_tuple_size(\n-                    expected_found(this, as_.len(), bs.len())))\n-            } else {\n-                Err(ty::terr_sorts(expected_found(this, a, b)))\n-            }\n+        (&ty::ty_infer(ty::FloatVar(v_id)), &ty::ty_float(v)) => {\n+            unify_float_variable(infcx, a_is_expected, v_id, v)\n         }\n-\n-        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n-            if a_opt_def_id == b_opt_def_id =>\n-        {\n-            let fty = try!(this.bare_fn_tys(a_fty, b_fty));\n-            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n+        (&ty::ty_float(v), &ty::ty_infer(ty::FloatVar(v_id))) => {\n+            unify_float_variable(infcx, !a_is_expected, v_id, v)\n         }\n \n-        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n-            let projection_ty = try!(this.projection_tys(a_data, b_data));\n-            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+        // All other cases of inference are errors\n+        (&ty::ty_infer(_), _) |\n+        (_, &ty::ty_infer(_)) => {\n+            Err(ty::terr_sorts(ty_relate::expected_found(relation, &a, &b)))\n         }\n \n-        _ => Err(ty::terr_sorts(expected_found(this, a, b))),\n-    };\n \n-    fn unify_integral_variable<'tcx, C>(this: &C,\n-                                        vid_is_expected: bool,\n-                                        vid: ty::IntVid,\n-                                        val: ty::IntVarValue)\n-                                        -> CombineResult<'tcx, Ty<'tcx>>\n-        where C: Combine<'tcx>\n-    {\n-        try!(this.infcx()\n-                 .int_unification_table\n-                 .borrow_mut()\n-                 .unify_var_value(vid, val)\n-                 .map_err(|e| int_unification_error(vid_is_expected, e)));\n-        match val {\n-            IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n-            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v)),\n+        _ => {\n+            ty_relate::super_relate_tys(relation, a, b)\n         }\n     }\n+}\n \n-    fn unify_float_variable<'tcx, C>(this: &C,\n-                                     vid_is_expected: bool,\n-                                     vid: ty::FloatVid,\n-                                     val: ast::FloatTy)\n-                                     -> CombineResult<'tcx, Ty<'tcx>>\n-        where C: Combine<'tcx>\n-    {\n-        try!(this.infcx().float_unification_table\n-                         .borrow_mut()\n-                         .unify_var_value(vid, val)\n-                         .map_err(|e| float_unification_error(vid_is_expected, e)));\n-        Ok(ty::mk_mach_float(this.tcx(), val))\n+fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                    vid_is_expected: bool,\n+                                    vid: ty::IntVid,\n+                                    val: ty::IntVarValue)\n+                                    -> RelateResult<'tcx, Ty<'tcx>>\n+{\n+    try!(infcx\n+         .int_unification_table\n+         .borrow_mut()\n+         .unify_var_value(vid, val)\n+         .map_err(|e| int_unification_error(vid_is_expected, e)));\n+    match val {\n+        IntType(v) => Ok(ty::mk_mach_int(infcx.tcx, v)),\n+        UintType(v) => Ok(ty::mk_mach_uint(infcx.tcx, v)),\n     }\n }\n \n-impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n-    pub fn switch_expected(&self) -> CombineFields<'f, 'tcx> {\n+fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                 vid_is_expected: bool,\n+                                 vid: ty::FloatVid,\n+                                 val: ast::FloatTy)\n+                                 -> RelateResult<'tcx, Ty<'tcx>>\n+{\n+    try!(infcx\n+         .float_unification_table\n+         .borrow_mut()\n+         .unify_var_value(vid, val)\n+         .map_err(|e| float_unification_error(vid_is_expected, e)));\n+    Ok(ty::mk_mach_float(infcx.tcx, val))\n+}\n+\n+impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    pub fn switch_expected(&self) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    fn equate(&self) -> Equate<'f, 'tcx> {\n-        Equate((*self).clone())\n+    pub fn equate(&self) -> Equate<'a, 'tcx> {\n+        Equate::new(self.clone())\n+    }\n+\n+    pub fn bivariate(&self) -> Bivariate<'a, 'tcx> {\n+        Bivariate::new(self.clone())\n+    }\n+\n+    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+        Sub::new(self.clone())\n     }\n \n-    fn bivariate(&self) -> Bivariate<'f, 'tcx> {\n-        Bivariate((*self).clone())\n+    pub fn lub(&self) -> Lub<'a, 'tcx> {\n+        Lub::new(self.clone())\n     }\n \n-    fn sub(&self) -> Sub<'f, 'tcx> {\n-        Sub((*self).clone())\n+    pub fn glb(&self) -> Glb<'a, 'tcx> {\n+        Glb::new(self.clone())\n     }\n \n     pub fn instantiate(&self,\n                        a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n                        b_vid: ty::TyVid)\n-                       -> CombineResult<'tcx, ()>\n+                       -> RelateResult<'tcx, ()>\n     {\n         let tcx = self.infcx.tcx;\n         let mut stack = Vec::new();\n@@ -742,15 +249,12 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // relations wind up attributed to the same spans. We need\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n-            match dir {\n-                BiTo => try!(self.bivariate().tys(a_ty, b_ty)),\n-\n-                EqTo => try!(self.equate().tys(a_ty, b_ty)),\n-\n-                SubtypeOf => try!(self.sub().tys(a_ty, b_ty)),\n-\n-                SupertypeOf => try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty)),\n-            };\n+            try!(match dir {\n+                BiTo => self.bivariate().relate(&a_ty, &b_ty),\n+                EqTo => self.equate().relate(&a_ty, &b_ty),\n+                SubtypeOf => self.sub().relate(&a_ty, &b_ty),\n+                SupertypeOf => self.sub().relate_with_variance(ty::Contravariant, &a_ty, &b_ty),\n+            });\n         }\n \n         Ok(())\n@@ -764,7 +268,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n                   make_region_vars: bool)\n-                  -> CombineResult<'tcx, Ty<'tcx>>\n+                  -> RelateResult<'tcx, Ty<'tcx>>\n     {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n@@ -858,18 +362,18 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n     }\n }\n \n-pub trait CombineResultCompare<'tcx, T> {\n-    fn compare<F>(&self, t: T, f: F) -> CombineResult<'tcx, T> where\n+pub trait RelateResultCompare<'tcx, T> {\n+    fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n         F: FnOnce() -> ty::type_err<'tcx>;\n }\n \n-impl<'tcx, T:Clone + PartialEq> CombineResultCompare<'tcx, T> for CombineResult<'tcx, T> {\n-    fn compare<F>(&self, t: T, f: F) -> CombineResult<'tcx, T> where\n+impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'tcx, T> {\n+    fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n         F: FnOnce() -> ty::type_err<'tcx>,\n     {\n-        (*self).clone().and_then(|s| {\n+        self.clone().and_then(|s| {\n             if s == t {\n-                (*self).clone()\n+                self.clone()\n             } else {\n                 Err(f())\n             }\n@@ -881,13 +385,13 @@ fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::Int\n                                -> ty::type_err<'tcx>\n {\n     let (a, b) = v;\n-    ty::terr_int_mismatch(expected_found_bool(a_is_expected, a, b))\n+    ty::terr_int_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n                                  v: (ast::FloatTy, ast::FloatTy))\n                                  -> ty::type_err<'tcx>\n {\n     let (a, b) = v;\n-    ty::terr_float_mismatch(expected_found_bool(a_is_expected, a, b))\n+    ty::terr_float_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n }"}, {"sha": "2003f459d89b42cb895625da636b8d3e74ecb04f", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -8,51 +8,43 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::combine::{self, CombineFields};\n+use super::higher_ranked::HigherRankedRelations;\n+use super::{Subtype};\n+use super::type_variable::{EqTo};\n+\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::infer::combine::*;\n-use middle::infer::CombineResult;\n-use middle::infer::Subtype;\n-use middle::infer::type_variable::EqTo;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n-pub struct Equate<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Equate<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n-    Equate { fields: cf }\n+impl<'a, 'tcx> Equate<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n+        Equate { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Equate\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tys_with_variance(&self, _: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> CombineResult<'tcx, Ty<'tcx>>\n-    {\n-        // Once we're equating, it doesn't matter what the variance is.\n-        self.tys(a, b)\n-    }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n \n-    fn regions_with_variance(&self, _: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> CombineResult<'tcx, ty::Region>\n-    {\n-        // Once we're equating, it doesn't matter what the variance is.\n-        self.regions(a, b)\n-    }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> CombineResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n-               self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n-        self.infcx().region_vars.make_eqregion(Subtype(self.trace()), a, b);\n-        Ok(a)\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               _: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n+    {\n+        self.relate(a, b)\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n@@ -77,15 +69,26 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> CombineResult<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+        let origin = Subtype(self.fields.trace.clone());\n+        self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n     {\n-        try!(self.sub().binders(a, b));\n-        self.sub().binders(b, a)\n+        try!(self.fields.higher_ranked_sub(a, b));\n+        self.fields.higher_ranked_sub(b, a)\n     }\n }"}, {"sha": "5822fb0f2d432fba8d7c3fe10959268c158d3fc4", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -8,67 +8,79 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n-use super::lattice::*;\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n-use super::CombineResult;\n+use super::InferCtxt;\n+use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Glb<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n-    Glb { fields: cf }\n+impl<'a, 'tcx> Glb<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n+        Glb { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Glb\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Glb\" }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n+\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> CombineResult<'tcx, Ty<'tcx>>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => self.lub().tys(a, b),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.lub().relate(a, b),\n         }\n     }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> CombineResult<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => self.lub().regions(a, b),\n-        }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> CombineResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n                b.repr(self.fields.infcx.tcx));\n \n-        Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n+        let origin = Subtype(self.fields.trace.clone());\n+        Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, Ty<'tcx>> {\n-        super_lattice_tys(self, a, b)\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n+    {\n+        self.fields.higher_ranked_glb(a, b)\n     }\n+}\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> CombineResult<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n-    {\n-        self.higher_ranked_glb(a, b)\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fields.infcx\n+    }\n+\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub();\n+        try!(sub.relate(&v, &a));\n+        try!(sub.relate(&v, &b));\n+        Ok(())\n     }\n }"}, {"sha": "f347d28b93c2b0aa06f41e6e4dd00abedc938ae1", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -11,25 +11,26 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{CombinedSnapshot, CombineResult, InferCtxt, HigherRankedType, SkolemizationMap};\n-use super::combine::{Combine, Combineable};\n+use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n+use super::combine::CombineFields;\n \n use middle::subst;\n use middle::ty::{self, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n-pub trait HigherRankedRelations<'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> CombineResult<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+pub trait HigherRankedRelations<'a,'tcx> {\n+    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> CombineResult<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> CombineResult<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n }\n \n trait InferCtxtExt {\n@@ -40,15 +41,15 @@ trait InferCtxtExt {\n                                         -> Vec<ty::RegionVid>;\n }\n \n-impl<'tcx,C> HigherRankedRelations<'tcx> for C\n-    where C : Combine<'tcx>\n-{\n+impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n-                            -> CombineResult<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+                            -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n+        let tcx = self.infcx.tcx;\n+\n         debug!(\"higher_ranked_sub(a={}, b={})\",\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n+               a.repr(tcx), b.repr(tcx));\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -60,32 +61,32 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().commit_if_ok(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n             let (a_prime, _) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(),\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(),\n                     HigherRankedType,\n                     a);\n \n             // Second, we instantiate each bound region in the supertype with a\n             // fresh concrete region.\n             let (b_prime, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(b, snapshot);\n+                self.infcx.skolemize_late_bound_regions(b, snapshot);\n \n-            debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n-            debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n+            debug!(\"a_prime={}\", a_prime.repr(tcx));\n+            debug!(\"b_prime={}\", b_prime.repr(tcx));\n \n             // Compare types now that bound regions have been replaced.\n-            let result = try!(Combineable::combine(self, &a_prime, &b_prime));\n+            let result = try!(self.sub().relate(&a_prime, &b_prime));\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            match leak_check(self.infcx(), &skol_map, snapshot) {\n+            match leak_check(self.infcx, &skol_map, snapshot) {\n                 Ok(()) => { }\n                 Err((skol_br, tainted_region)) => {\n-                    if self.a_is_expected() {\n+                    if self.a_is_expected {\n                         debug!(\"Not as polymorphic!\");\n                         return Err(ty::terr_regions_insufficiently_polymorphic(skol_br,\n                                                                                tainted_region));\n@@ -98,42 +99,42 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n \n             debug!(\"higher_ranked_sub: OK result={}\",\n-                   result.repr(self.tcx()));\n+                   result.repr(tcx));\n \n             Ok(ty::Binder(result))\n         });\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> CombineResult<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().commit_if_ok(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n-            let span = self.trace().origin.span();\n+            let span = self.trace.origin.span();\n             let (a_with_fresh, a_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, a);\n             let (b_with_fresh, _) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, b);\n \n             // Collect constraints.\n             let result0 =\n-                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(self.lub().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n-                self.infcx().resolve_type_vars_if_possible(&result0);\n+                self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n \n             // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace().origin.span();\n+            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace.origin.span();\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n                     &result0,\n-                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars, &a_map, r));\n \n             debug!(\"lub({},{}) = {}\",\n@@ -194,40 +195,40 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> CombineResult<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n-        debug!(\"{}.higher_ranked_glb({}, {})\",\n-               self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n+        debug!(\"higher_ranked_glb({}, {})\",\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n \n         // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().commit_if_ok(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n             let (a_with_fresh, a_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(), HigherRankedType, a);\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(), HigherRankedType, a);\n             let (b_with_fresh, b_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(), HigherRankedType, b);\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(), HigherRankedType, b);\n             let a_vars = var_ids(self, &a_map);\n             let b_vars = var_ids(self, &b_map);\n \n             // Collect constraints.\n             let result0 =\n-                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(self.glb().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n-                self.infcx().resolve_type_vars_if_possible(&result0);\n+                self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n \n             // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace().origin.span();\n+            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace.origin.span();\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n                     &result0,\n-                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars,\n                                                     &a_map, &a_vars, &b_vars,\n                                                     r));\n@@ -332,17 +333,19 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     }\n }\n \n-fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n-                                   map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n-                                   -> Vec<ty::RegionVid> {\n-    map.iter().map(|(_, r)| match *r {\n-            ty::ReInfer(ty::ReVar(r)) => { r }\n-            r => {\n-                combiner.infcx().tcx.sess.span_bug(\n-                    combiner.trace().origin.span(),\n-                    &format!(\"found non-region-vid: {:?}\", r));\n-            }\n-        }).collect()\n+fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n+                      map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                     -> Vec<ty::RegionVid> {\n+    map.iter()\n+       .map(|(_, r)| match *r {\n+           ty::ReInfer(ty::ReVar(r)) => { r }\n+           r => {\n+               fields.tcx().sess.span_bug(\n+                   fields.trace.origin.span(),\n+                   &format!(\"found non-region-vid: {:?}\", r));\n+           }\n+       })\n+       .collect()\n }\n \n fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n@@ -356,8 +359,8 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n                                unbound_value: &T,\n                                mut fldr: F)\n                                -> T\n-    where T : Combineable<'tcx>,\n-          F : FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n+    where T: TypeFoldable<'tcx>,\n+          F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n     unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,"}, {"sha": "57001083b03e200e410d7fa0e9de3a76854a09a4", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -29,48 +29,32 @@\n //! over a `LatticeValue`, which is a value defined with respect to\n //! a lattice.\n \n-use super::*;\n-use super::combine::*;\n-use super::glb::Glb;\n-use super::lub::Lub;\n+use super::combine;\n+use super::InferCtxt;\n \n use middle::ty::TyVar;\n use middle::ty::{self, Ty};\n+use middle::ty_relate::{RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n-pub trait LatticeDir<'tcx> {\n+pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n+    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, ()>;\n-}\n-\n-impl<'a, 'tcx> LatticeDir<'tcx> for Lub<'a, 'tcx> {\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, ()> {\n-        let sub = self.sub();\n-        try!(sub.tys(a, v));\n-        try!(sub.tys(b, v));\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, 'tcx> LatticeDir<'tcx> for Glb<'a, 'tcx> {\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, ()> {\n-        let sub = self.sub();\n-        try!(sub.tys(v, a));\n-        try!(sub.tys(v, b));\n-        Ok(())\n-    }\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n-                                                                 a: Ty<'tcx>,\n-                                                                 b: Ty<'tcx>)\n-                                                                 -> CombineResult<'tcx, Ty<'tcx>>\n+pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n+                                                        a: Ty<'tcx>,\n+                                                        b: Ty<'tcx>)\n+                                                        -> RelateResult<'tcx, Ty<'tcx>>\n+    where 'tcx: 'a\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n-           a.repr(this.infcx().tcx),\n-           b.repr(this.infcx().tcx));\n+           a.repr(this.tcx()),\n+           b.repr(this.tcx()));\n \n     if a == b {\n         return Ok(a);\n@@ -95,7 +79,7 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n         }\n \n         _ => {\n-            super_tys(this, a, b)\n+            combine::super_combine_tys(this.infcx(), this, a, b)\n         }\n     }\n }"}, {"sha": "f456687be13ac49567537768bfdc0c72f4a4a6a5", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -8,67 +8,80 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n-use super::lattice::*;\n-use super::CombineResult;\n+use super::InferCtxt;\n+use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Lub<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n-    Lub { fields: cf }\n+impl<'a, 'tcx> Lub<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n+        Lub { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Lub\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Lub\" }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n+\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> CombineResult<'tcx, Ty<'tcx>>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => self.glb().tys(a, b),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.glb().relate(a, b),\n         }\n     }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> CombineResult<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => self.glb().regions(a, b),\n-        }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> CombineResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n \n-        Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n+        let origin = Subtype(self.fields.trace.clone());\n+        Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, Ty<'tcx>> {\n-        super_lattice_tys(self, a, b)\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n+    {\n+        self.fields.higher_ranked_lub(a, b)\n     }\n+}\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> CombineResult<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n-    {\n-        self.higher_ranked_lub(a, b)\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fields.infcx\n+    }\n+\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub();\n+        try!(sub.relate(&a, &v));\n+        try!(sub.relate(&b, &v));\n+        Ok(())\n     }\n }\n+"}, {"sha": "da811c354578de5bbc4747c3439fe9f8efa74a5c", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -28,7 +28,8 @@ use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n use middle::ty::replace_late_bound_regions;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use std::cell::RefCell;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use std::cell::{RefCell};\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -38,11 +39,8 @@ use util::nodemap::FnvHashMap;\n use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n \n-use self::combine::{Combine, Combineable, CombineFields};\n+use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::equate::Equate;\n-use self::sub::Sub;\n-use self::lub::Lub;\n use self::unify::{ToType, UnificationTable};\n use self::error_reporting::ErrorReporting;\n \n@@ -62,9 +60,7 @@ pub mod type_variable;\n pub mod unify;\n \n pub type Bound<T> = Option<T>;\n-\n-pub type CombineResult<'tcx, T> = Result<T,ty::type_err<'tcx>>; // \"combine result\"\n-pub type UnitResult<'tcx> = CombineResult<'tcx, ()>; // \"unify result\"\n+pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n@@ -343,7 +339,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result = cx.commit_if_ok(|_| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n+    let result = cx.commit_if_ok(|_| cx.lub(a_is_expected, trace.clone()).relate(&a, &b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -374,11 +370,12 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n-        cx.sub(true, trace).tys(a, b).map(|_| ())\n+        cx.sub(true, trace).relate(&a, &b).map(|_| ())\n     })\n }\n \n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> UnitResult<'tcx>\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n+                             -> UnitResult<'tcx>\n {\n     cx.can_equate(&a, &b)\n }\n@@ -473,26 +470,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                          -> CombineFields<'b, 'tcx> {\n+    fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                      -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    fn equate<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                  -> Equate<'b, 'tcx> {\n-        Equate(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn equate(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+              -> equate::Equate<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).equate()\n     }\n \n-    fn sub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> Sub<'b, 'tcx> {\n-        Sub(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn sub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> sub::Sub<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).sub()\n     }\n \n-    fn lub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> Lub<'b, 'tcx> {\n-        Lub(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn lub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> lub::Lub<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).lub()\n+    }\n+\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn glb(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> glb::Glb<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).glb()\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -631,7 +641,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace).tys(a, b).map(|_| ())\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -644,7 +654,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace).tys(a, b).map(|_| ())\n+            self.equate(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -663,7 +673,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).trait_refs(&*a, &*b).map(|_| ())\n+            self.sub(a_is_expected, trace).relate(&*a, &*b).map(|_| ())\n         })\n     }\n \n@@ -682,7 +692,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).binders(&a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -1045,8 +1055,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n \n-    pub fn can_equate<T>(&self, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T : Combineable<'tcx> + Repr<'tcx>\n+    pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n+        where T: Relate<'b,'tcx> + Repr<'tcx>\n     {\n         debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n         self.probe(|_| {\n@@ -1057,8 +1067,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let e = self.tcx.types.err;\n             let trace = TypeTrace { origin: Misc(codemap::DUMMY_SP),\n                                     values: Types(expected_found(true, e, e)) };\n-            let eq = self.equate(true, trace);\n-            Combineable::combine(&eq, a, b)\n+            self.equate(true, trace).relate(a, b)\n         }).map(|_| ())\n     }\n }"}, {"sha": "45d4a8c5d9f348acf328485a1c0a984aff7e9680", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -18,14 +18,14 @@ pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n use self::Classification::*;\n \n-use super::CombineResult;\n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use middle::region;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n+use middle::ty_relate::RelateResult;\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n@@ -825,7 +825,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn glb_concrete_regions(&self,\n                             a: Region,\n                             b: Region)\n-                            -> CombineResult<'tcx, Region>\n+                            -> RelateResult<'tcx, Region>\n     {\n         debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -901,7 +901,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn glb_free_regions(&self,\n                         a: &FreeRegion,\n                         b: &FreeRegion)\n-                        -> CombineResult<'tcx, ty::Region>\n+                        -> RelateResult<'tcx, ty::Region>\n     {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n@@ -911,7 +911,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         fn helper<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n                             a: &FreeRegion,\n-                            b: &FreeRegion) -> CombineResult<'tcx, ty::Region>\n+                            b: &FreeRegion) -> RelateResult<'tcx, ty::Region>\n         {\n             if this.tcx.region_maps.sub_free_region(*a, *b) {\n                 Ok(ty::ReFree(*a))\n@@ -930,7 +930,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         region_b: ty::Region,\n                         scope_a: region::CodeExtent,\n                         scope_b: region::CodeExtent)\n-                        -> CombineResult<'tcx, Region>\n+                        -> RelateResult<'tcx, Region>\n     {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of"}, {"sha": "31b654a5b3fd3b5fcfba885019ade59349aa69a6", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -8,64 +8,49 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n-use super::CombineResult;\n+use super::combine::{self, CombineFields};\n use super::higher_ranked::HigherRankedRelations;\n use super::Subtype;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Sub<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Sub<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n-    Sub { fields: cf }\n+impl<'a, 'tcx> Sub<'a, 'tcx> {\n+    pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n+        Sub { fields: f }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Sub\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n-\n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> CombineResult<'tcx, Ty<'tcx>>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => Sub(self.fields.switch_expected()).tys(b, a),\n-        }\n-    }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Sub\" }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.infcx.tcx }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> CombineResult<'tcx, ty::Region>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => Sub(self.fields.switch_expected()).regions(b, a),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.switch_expected().sub().relate(b, a),\n         }\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> CombineResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n-               self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n-        self.infcx().region_vars.make_subregion(Subtype(self.trace()), a, b);\n-        Ok(a)\n-    }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CombineResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -80,8 +65,8 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n                 try!(self.fields\n-                       .switch_expected()\n-                       .instantiate(b, SupertypeOf, a_id));\n+                         .switch_expected()\n+                         .instantiate(b, SupertypeOf, a_id));\n                 Ok(a)\n             }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n@@ -94,14 +79,25 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> CombineResult<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n+        let origin = Subtype(self.fields.trace.clone());\n+        self.fields.infcx.region_vars.make_subregion(origin, a, b);\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n-        self.higher_ranked_sub(a, b)\n+        self.fields.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "7488b8f046e74eff8215258fe5127b4c99895384", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -291,6 +291,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n     }\n }\n \n+#[derive(Clone)]\n pub struct Normalized<'tcx,T> {\n     pub value: T,\n     pub obligations: Vec<PredicateObligation<'tcx>>,"}, {"sha": "5f77574f65ed4351692f8cc5868678bd73117b25", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -39,6 +39,8 @@ use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n use middle::traits;\n use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use util::ppaux::Repr;\n \n@@ -47,7 +49,7 @@ use util::ppaux::Repr;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable<'tcx> {\n+pub trait TypeFoldable<'tcx>: Repr<'tcx> + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n@@ -149,12 +151,20 @@ pub trait TypeFolder<'tcx> : Sized {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n-impl<'tcx> TypeFoldable<'tcx> for () {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n-        ()\n+macro_rules! CopyImpls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl<'tcx> TypeFoldable<'tcx> for $ty {\n+                fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n+                    *self\n+                }\n+            }\n+        )+\n     }\n }\n \n+CopyImpls! { (), ast::Unsafety, abi::Abi }\n+\n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))"}, {"sha": "1205b7d957930aaf8f25a0f540efe074a62f43f9", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -0,0 +1,655 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generalized type relating mechanism. A type relation R relates a\n+//! pair of values (A, B). A and B are usually types or regions but\n+//! can be other things. Examples of type relations are subtyping,\n+//! type equality, etc.\n+\n+use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n+use middle::ty::{self, Ty};\n+use middle::ty_fold::TypeFoldable;\n+use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast;\n+use util::ppaux::Repr;\n+\n+pub type RelateResult<'tcx, T> = Result<T, ty::type_err<'tcx>>;\n+\n+pub trait TypeRelation<'a,'tcx> : Sized {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx>;\n+\n+    /// Returns a static string we can use for printouts.\n+    fn tag(&self) -> &'static str;\n+\n+    /// Returns true if the value `a` is the \"expected\" type in the\n+    /// relation. Just affects error messages.\n+    fn a_is_expected(&self) -> bool;\n+\n+    /// Generic relation routine suitable for most anything.\n+    fn relate<T:Relate<'a,'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+        Relate::relate(self, a, b)\n+    }\n+\n+    /// Switch variance for the purpose of relating `a` and `b`.\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>;\n+\n+    // Overrideable relations. You shouldn't typically call these\n+    // directly, instead call `relate()`, which in turn calls\n+    // these. This is both more uniform but also allows us to add\n+    // additional hooks for other types in the future if needed\n+    // without making older code, which called `relate`, obsolete.\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n+           -> RelateResult<'tcx, Ty<'tcx>>;\n+\n+    fn regions(&mut self, a: ty::Region, b: ty::Region)\n+               -> RelateResult<'tcx, ty::Region>;\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>;\n+}\n+\n+pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> {\n+    fn relate<R:TypeRelation<'a,'tcx>>(relation: &mut R,\n+                                       a: &Self,\n+                                       b: &Self)\n+                                       -> RelateResult<'tcx, Self>;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Relate impls\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::mt<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::mt<'tcx>,\n+                 b: &ty::mt<'tcx>)\n+                 -> RelateResult<'tcx, ty::mt<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        debug!(\"{}.mts({}, {})\",\n+               relation.tag(),\n+               a.repr(relation.tcx()),\n+               b.repr(relation.tcx()));\n+        if a.mutbl != b.mutbl {\n+            Err(ty::terr_mutability)\n+        } else {\n+            let mutbl = a.mutbl;\n+            let variance = match mutbl {\n+                ast::MutImmutable => ty::Covariant,\n+                ast::MutMutable => ty::Invariant,\n+            };\n+            let ty = try!(relation.relate_with_variance(variance, &a.ty, &b.ty));\n+            Ok(ty::mt {ty: ty, mutbl: mutbl})\n+        }\n+    }\n+}\n+\n+// substitutions are not themselves relatable without more context,\n+// but they is an important subroutine for things that ARE relatable,\n+// like traits etc.\n+fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n+                                    item_def_id: ast::DefId,\n+                                    a_subst: &Substs<'tcx>,\n+                                    b_subst: &Substs<'tcx>)\n+                                    -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n+           item_def_id.repr(relation.tcx()),\n+           a_subst.repr(relation.tcx()),\n+           b_subst.repr(relation.tcx()));\n+\n+    let variances;\n+    let opt_variances = if relation.tcx().variance_computed.get() {\n+        variances = ty::item_variances(relation.tcx(), item_def_id);\n+        Some(&*variances)\n+    } else {\n+        None\n+    };\n+    relate_substs(relation, opt_variances, a_subst, b_subst)\n+}\n+\n+fn relate_substs<'a,'tcx,R>(relation: &mut R,\n+                            variances: Option<&ty::ItemVariances>,\n+                            a_subst: &Substs<'tcx>,\n+                            b_subst: &Substs<'tcx>)\n+                            -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let mut substs = Substs::empty();\n+\n+    for &space in &ParamSpace::all() {\n+        let a_tps = a_subst.types.get_slice(space);\n+        let b_tps = b_subst.types.get_slice(space);\n+        let t_variances = variances.map(|v| v.types.get_slice(space));\n+        let tps = try!(relate_type_params(relation, t_variances, a_tps, b_tps));\n+        substs.types.replace(space, tps);\n+    }\n+\n+    match (&a_subst.regions, &b_subst.regions) {\n+        (&ErasedRegions, _) | (_, &ErasedRegions) => {\n+            substs.regions = ErasedRegions;\n+        }\n+\n+        (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n+            for &space in &ParamSpace::all() {\n+                let a_regions = a.get_slice(space);\n+                let b_regions = b.get_slice(space);\n+                let r_variances = variances.map(|v| v.regions.get_slice(space));\n+                let regions = try!(relate_region_params(relation,\n+                                                        r_variances,\n+                                                        a_regions,\n+                                                        b_regions));\n+                substs.mut_regions().replace(space, regions);\n+            }\n+        }\n+    }\n+\n+    Ok(substs)\n+}\n+\n+fn relate_type_params<'a,'tcx,R>(relation: &mut R,\n+                                 variances: Option<&[ty::Variance]>,\n+                                 a_tys: &[Ty<'tcx>],\n+                                 b_tys: &[Ty<'tcx>])\n+                                 -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    if a_tys.len() != b_tys.len() {\n+        return Err(ty::terr_ty_param_size(expected_found(relation,\n+                                                         &a_tys.len(),\n+                                                         &b_tys.len())));\n+    }\n+\n+    (0 .. a_tys.len())\n+        .map(|i| {\n+            let a_ty = a_tys[i];\n+            let b_ty = b_tys[i];\n+            let v = variances.map_or(ty::Invariant, |v| v[i]);\n+            relation.relate_with_variance(v, &a_ty, &b_ty)\n+        })\n+        .collect()\n+}\n+\n+fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n+                                      variances: Option<&[ty::Variance]>,\n+                                      a_rs: &[ty::Region],\n+                                      b_rs: &[ty::Region])\n+                                      -> RelateResult<'tcx, Vec<ty::Region>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let tcx = relation.tcx();\n+    let num_region_params = a_rs.len();\n+\n+    debug!(\"relate_region_params(a_rs={}, \\\n+            b_rs={}, variances={})\",\n+           a_rs.repr(tcx),\n+           b_rs.repr(tcx),\n+           variances.repr(tcx));\n+\n+    assert_eq!(num_region_params,\n+               variances.map_or(num_region_params,\n+                                |v| v.len()));\n+\n+    assert_eq!(num_region_params, b_rs.len());\n+\n+    (0..a_rs.len())\n+        .map(|i| {\n+            let a_r = a_rs[i];\n+            let b_r = b_rs[i];\n+            let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+            relation.relate_with_variance(variance, &a_r, &b_r)\n+        })\n+        .collect()\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BareFnTy<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::BareFnTy<'tcx>,\n+                 b: &ty::BareFnTy<'tcx>)\n+                 -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let unsafety = try!(relation.relate(&a.unsafety, &b.unsafety));\n+        let abi = try!(relation.relate(&a.abi, &b.abi));\n+        let sig = try!(relation.relate(&a.sig, &b.sig));\n+        Ok(ty::BareFnTy {unsafety: unsafety,\n+                         abi: abi,\n+                         sig: sig})\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::FnSig<'tcx>,\n+                 b: &ty::FnSig<'tcx>)\n+                 -> RelateResult<'tcx, ty::FnSig<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a.variadic != b.variadic {\n+            return Err(ty::terr_variadic_mismatch(\n+                expected_found(relation, &a.variadic, &b.variadic)));\n+        }\n+\n+        let inputs = try!(relate_arg_vecs(relation,\n+                                          &a.inputs,\n+                                          &b.inputs));\n+\n+        let output = try!(match (a.output, b.output) {\n+            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+                Ok(ty::FnConverging(try!(relation.relate(&a_ty, &b_ty)))),\n+            (ty::FnDiverging, ty::FnDiverging) =>\n+                Ok(ty::FnDiverging),\n+            (a, b) =>\n+                Err(ty::terr_convergence_mismatch(\n+                    expected_found(relation, &(a != ty::FnDiverging), &(b != ty::FnDiverging)))),\n+        });\n+\n+        return Ok(ty::FnSig {inputs: inputs,\n+                             output: output,\n+                             variadic: a.variadic});\n+    }\n+}\n+\n+fn relate_arg_vecs<'a,'tcx,R>(relation: &mut R,\n+                              a_args: &[Ty<'tcx>],\n+                              b_args: &[Ty<'tcx>])\n+                              -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    if a_args.len() != b_args.len() {\n+        return Err(ty::terr_arg_count);\n+    }\n+\n+    a_args.iter()\n+          .zip(b_args.iter())\n+          .map(|(a, b)| relation.relate_with_variance(ty::Contravariant, a, b))\n+          .collect()\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ast::Unsafety,\n+                 b: &ast::Unsafety)\n+                 -> RelateResult<'tcx, ast::Unsafety>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a != b {\n+            Err(ty::terr_unsafety_mismatch(expected_found(relation, a, b)))\n+        } else {\n+            Ok(*a)\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n+    fn relate<R>(relation: &mut R,\n+                 a: &abi::Abi,\n+                 b: &abi::Abi)\n+                 -> RelateResult<'tcx, abi::Abi>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a == b {\n+            Ok(*a)\n+        } else {\n+            Err(ty::terr_abi_mismatch(expected_found(relation, a, b)))\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ProjectionTy<'tcx>,\n+                 b: &ty::ProjectionTy<'tcx>)\n+                 -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a.item_name != b.item_name {\n+            Err(ty::terr_projection_name_mismatched(\n+                expected_found(relation, &a.item_name, &b.item_name)))\n+        } else {\n+            let trait_ref = try!(relation.relate(&*a.trait_ref, &*b.trait_ref));\n+            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ProjectionPredicate<'tcx>,\n+                 b: &ty::ProjectionPredicate<'tcx>)\n+                 -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let projection_ty = try!(relation.relate(&a.projection_ty, &b.projection_ty));\n+        let ty = try!(relation.relate(&a.ty, &b.ty));\n+        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                 b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                 -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // To be compatible, `a` and `b` must be for precisely the\n+        // same set of traits and item names. We always require that\n+        // projection bounds lists are sorted by trait-def-id and item-name,\n+        // so we can just iterate through the lists pairwise, so long as they are the\n+        // same length.\n+        if a.len() != b.len() {\n+            Err(ty::terr_projection_bounds_length(expected_found(relation, &a.len(), &b.len())))\n+        } else {\n+            a.iter()\n+                .zip(b.iter())\n+                .map(|(a, b)| relation.relate(a, b))\n+                .collect()\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ExistentialBounds<'tcx>,\n+                 b: &ty::ExistentialBounds<'tcx>)\n+                 -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let r = try!(relation.relate_with_variance(ty::Contravariant,\n+                                                   &a.region_bound,\n+                                                   &b.region_bound));\n+        let nb = try!(relation.relate(&a.builtin_bounds, &b.builtin_bounds));\n+        let pb = try!(relation.relate(&a.projection_bounds, &b.projection_bounds));\n+        Ok(ty::ExistentialBounds { region_bound: r,\n+                                   builtin_bounds: nb,\n+                                   projection_bounds: pb })\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::BuiltinBounds,\n+                 b: &ty::BuiltinBounds)\n+                 -> RelateResult<'tcx, ty::BuiltinBounds>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // Two sets of builtin bounds are only relatable if they are\n+        // precisely the same (but see the coercion code).\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(relation, a, b)))\n+        } else {\n+            Ok(*a)\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::TraitRef<'tcx>,\n+                 b: &ty::TraitRef<'tcx>)\n+                 -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(expected_found(relation, &a.def_id, &b.def_id)))\n+        } else {\n+            let substs = try!(relate_item_substs(relation, a.def_id, a.substs, b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: relation.tcx().mk_substs(substs) })\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Ty<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Ty<'tcx>,\n+                 b: &Ty<'tcx>)\n+                 -> RelateResult<'tcx, Ty<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.tys(a, b)\n+    }\n+}\n+\n+/// The main \"type relation\" routine. Note that this does not handle\n+/// inference artifacts, so you should filter those out before calling\n+/// it.\n+pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n+                                      a: Ty<'tcx>,\n+                                      b: Ty<'tcx>)\n+                                      -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let tcx = relation.tcx();\n+    let a_sty = &a.sty;\n+    let b_sty = &b.sty;\n+    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    match (a_sty, b_sty) {\n+        (&ty::ty_infer(_), _) |\n+        (_, &ty::ty_infer(_)) =>\n+        {\n+            // The caller should handle these cases!\n+            tcx.sess.bug(\"var types encountered in super_relate_tys\")\n+        }\n+\n+        (&ty::ty_err, _) | (_, &ty::ty_err) =>\n+        {\n+            Ok(tcx.types.err)\n+        }\n+\n+        (&ty::ty_char, _) |\n+        (&ty::ty_bool, _) |\n+        (&ty::ty_int(_), _) |\n+        (&ty::ty_uint(_), _) |\n+        (&ty::ty_float(_), _) |\n+        (&ty::ty_str, _)\n+            if a == b =>\n+        {\n+            Ok(a)\n+        }\n+\n+        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p))\n+            if a_p.idx == b_p.idx && a_p.space == b_p.space =>\n+        {\n+            Ok(a)\n+        }\n+\n+        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n+            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) =>\n+        {\n+            let principal = try!(relation.relate(&a_.principal, &b_.principal));\n+            let bounds = try!(relation.relate(&a_.bounds, &b_.bounds));\n+            Ok(ty::mk_trait(tcx, principal, bounds))\n+        }\n+\n+        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n+            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_closure(a_id, a_substs),\n+         &ty::ty_closure(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            // All ty_closure types with the same id represent\n+            // the (anonymous) type of the same closure expression. So\n+            // all of their regions should be equated.\n+            let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n+            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) =>\n+        {\n+            let typ = try!(relation.relate(&a_inner, &b_inner));\n+            Ok(ty::mk_uniq(tcx, typ))\n+        }\n+\n+        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) =>\n+        {\n+            let mt = try!(relation.relate(a_mt, b_mt));\n+            Ok(ty::mk_ptr(tcx, mt))\n+        }\n+\n+        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) =>\n+        {\n+            let r = try!(relation.relate_with_variance(ty::Contravariant, a_r, b_r));\n+            let mt = try!(relation.relate(a_mt, b_mt));\n+            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n+        }\n+\n+        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) =>\n+        {\n+            let t = try!(relation.relate(&a_t, &b_t));\n+            if sz_a == sz_b {\n+                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+            } else {\n+                Err(ty::terr_fixed_array_size(expected_found(relation, &sz_a, &sz_b)))\n+            }\n+        }\n+\n+        (&ty::ty_vec(a_t, None), &ty::ty_vec(b_t, None)) =>\n+        {\n+            let t = try!(relation.relate(&a_t, &b_t));\n+            Ok(ty::mk_vec(tcx, t, None))\n+        }\n+\n+        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) =>\n+        {\n+            if as_.len() == bs.len() {\n+                let ts = try!(as_.iter()\n+                                 .zip(bs.iter())\n+                                 .map(|(a, b)| relation.relate(a, b))\n+                                 .collect::<Result<_, _>>());\n+                Ok(ty::mk_tup(tcx, ts))\n+            } else if as_.len() != 0 && bs.len() != 0 {\n+                Err(ty::terr_tuple_size(\n+                    expected_found(relation, &as_.len(), &bs.len())))\n+            } else {\n+                Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+            }\n+        }\n+\n+        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n+            if a_opt_def_id == b_opt_def_id =>\n+        {\n+            let fty = try!(relation.relate(a_fty, b_fty));\n+            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n+        }\n+\n+        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) =>\n+        {\n+            let projection_ty = try!(relation.relate(a_data, b_data));\n+            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+        }\n+\n+        _ =>\n+        {\n+            Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::Region,\n+                 b: &ty::Region)\n+                 -> RelateResult<'tcx, ty::Region>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.regions(*a, *b)\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for ty::Binder<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::Binder<T>,\n+                 b: &ty::Binder<T>)\n+                 -> RelateResult<'tcx, ty::Binder<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.binders(a, b)\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Rc<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &Rc<T>,\n+                 b: &Rc<T>)\n+                 -> RelateResult<'tcx, Rc<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let a: &T = a;\n+        let b: &T = b;\n+        Ok(Rc::new(try!(relation.relate(a, b))))\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &Box<T>,\n+                 b: &Box<T>)\n+                 -> RelateResult<'tcx, Box<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let a: &T = a;\n+        let b: &T = b;\n+        Ok(Box::new(try!(relation.relate(a, b))))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Error handling\n+\n+pub fn expected_found<'a,'tcx,R,T>(relation: &mut R,\n+                                   a: &T,\n+                                   b: &T)\n+                                   -> ty::expected_found<T>\n+    where R: TypeRelation<'a,'tcx>, T: Clone\n+{\n+    expected_found_bool(relation.a_is_expected(), a, b)\n+}\n+\n+pub fn expected_found_bool<T>(a_is_expected: bool,\n+                              a: &T,\n+                              b: &T)\n+                              -> ty::expected_found<T>\n+    where T: Clone\n+{\n+    let a = a.clone();\n+    let b = b.clone();\n+    if a_is_expected {\n+        ty::expected_found {expected: a, found: b}\n+    } else {\n+        ty::expected_found {expected: b, found: a}\n+    }\n+}\n+"}, {"sha": "91c320237d5ec88971b7506aae4ed66aa6c6d339", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -1532,3 +1532,9 @@ impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for ast::Unsafety {\n+    fn repr(&self, _: &ctxt<'tcx>) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}"}, {"sha": "ac444478fcf16ba3792f9dfaf74ec227d3a0e084", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -22,7 +22,7 @@ use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n use rustc_typeck::middle::ty::{self, Ty};\n-use rustc_typeck::middle::infer::combine::Combine;\n+use rustc_typeck::middle::ty_relate::TypeRelation;\n use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n@@ -350,21 +350,21 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn sub(&self) -> Sub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Sub(self.infcx.combine_fields(true, trace))\n+        self.infcx.sub(true, trace)\n     }\n \n     pub fn lub(&self) -> Lub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Lub(self.infcx.combine_fields(true, trace))\n+        self.infcx.lub(true, trace)\n     }\n \n     pub fn glb(&self) -> Glb<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Glb(self.infcx.combine_fields(true, trace))\n+        self.infcx.glb(true, trace)\n     }\n \n     pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.lub().tys(t1, t2) {\n+        match self.lub().relate(&t1, &t2) {\n             Ok(t) => t,\n             Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().tys(t1, t2) {\n+        match self.sub().relate(&t1, &t2) {\n             Ok(_) => { }\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({},{}): {}\",\n@@ -388,7 +388,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is false (this may register additional\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().tys(t1, t2) {\n+        match self.sub().relate(&t1, &t2) {\n             Err(_) => { }\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({},{})\",\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub().tys(t1, t2) {\n+        match self.lub().relate(&t1, &t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n             }\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                self.ty_to_string(t1),\n                self.ty_to_string(t2),\n                self.ty_to_string(t_glb));\n-        match self.glb().tys(t1, t2) {\n+        match self.glb().relate(&t1, &t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }"}, {"sha": "ced6cec3ef0dc3daef00349ce18f90f9e057a242", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -62,11 +62,11 @@\n \n use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n \n-use middle::infer::{self, CombineResult, Coercion};\n-use middle::infer::combine::Combine;\n+use middle::infer::{self, Coercion};\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{self, mt, Ty};\n+use middle::ty_relate::RelateResult;\n use util::common::indent;\n use util::ppaux;\n use util::ppaux::Repr;\n@@ -78,7 +78,7 @@ struct Coerce<'a, 'tcx: 'a> {\n     origin: infer::TypeOrigin,\n }\n \n-type CoerceResult<'tcx> = CombineResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n@@ -536,7 +536,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              expr: &ast::Expr,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n-                             -> CombineResult<'tcx, ()> {\n+                             -> RelateResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n     let adjustment = try!(indent(|| {\n         fcx.infcx().commit_if_ok(|_| {"}, {"sha": "51d0c18872dc4213b9756cb3585bb5d7a8bc34cd", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -30,7 +30,6 @@ use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::ty_projection;\n use middle::ty;\n use CrateCtxt;\n-use middle::infer::combine::Combine;\n use middle::infer::InferCtxt;\n use middle::infer::new_infer_ctxt;\n use std::collections::HashSet;"}, {"sha": "2d87345db2245f5c71701480ad892e3cceda4f61", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8403b82ddb6657dead95c6c3877824ffb3f13af2/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=8403b82ddb6657dead95c6c3877824ffb3f13af2", "patch": "@@ -23,10 +23,6 @@ pub fn main() {\n     let f2: &Fat<[isize; 3]> = &f1;\n     let f3: &Fat<[usize]> = f2;\n     //~^ ERROR mismatched types\n-    //~| expected `&Fat<[usize]>`\n-    //~| found `&Fat<[isize; 3]>`\n-    //~| expected usize\n-    //~| found isize\n \n     // With a trait.\n     let f1 = Fat { ptr: Foo };"}]}