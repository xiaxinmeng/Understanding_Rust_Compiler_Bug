{"sha": "38048c35d800230d3e5a79041186366dd0ef44ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MDQ4YzM1ZDgwMDIzMGQzZTVhNzkwNDExODYzNjZkZDBlZjQ0YWU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-20T22:22:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-20T22:22:09Z"}, "message": "Don't use an untyped String for ActiveParam tracking", "tree": {"sha": "5c0e60acc4760288143485ae0e36b173efb43fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c0e60acc4760288143485ae0e36b173efb43fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38048c35d800230d3e5a79041186366dd0ef44ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38048c35d800230d3e5a79041186366dd0ef44ae", "html_url": "https://github.com/rust-lang/rust/commit/38048c35d800230d3e5a79041186366dd0ef44ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38048c35d800230d3e5a79041186366dd0ef44ae/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cc8ad0c4afda0c8b6222156b0c725cfb61892c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc8ad0c4afda0c8b6222156b0c725cfb61892c0", "html_url": "https://github.com/rust-lang/rust/commit/5cc8ad0c4afda0c8b6222156b0c725cfb61892c0"}], "stats": {"total": 68, "additions": 44, "deletions": 24}, "files": [{"sha": "8e09401840749243c8bec6e235c49021f7338ad8", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=38048c35d800230d3e5a79041186366dd0ef44ae", "patch": "@@ -23,7 +23,7 @@ pub(super) fn ra_fixture(\n     expanded: SyntaxToken,\n ) -> Option<()> {\n     let active_parameter = ActiveParameter::at_token(&sema, expanded)?;\n-    if !active_parameter.name.starts_with(\"ra_fixture\") {\n+    if !active_parameter.ident().map_or(false, |name| name.text().starts_with(\"ra_fixture\")) {\n         return None;\n     }\n     let value = literal.value()?;"}, {"sha": "a60b8b09d0fa992b51d6e233db5f18c480656a51", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=38048c35d800230d3e5a79041186366dd0ef44ae", "patch": "@@ -4,8 +4,11 @@ use hir::{Local, ScopeDef, Semantics, SemanticsScope, Type};\n use ide_db::base_db::{FilePosition, SourceDatabase};\n use ide_db::{call_info::ActiveParameter, RootDatabase};\n use syntax::{\n-    algo::find_node_at_offset, ast, match_ast, AstNode, NodeOrToken, SyntaxKind::*, SyntaxNode,\n-    SyntaxToken, TextRange, TextSize,\n+    algo::find_node_at_offset,\n+    ast::{self, NameOrNameRef, NameOwner},\n+    match_ast, AstNode, NodeOrToken,\n+    SyntaxKind::*,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n use text_edit::Indel;\n@@ -35,7 +38,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// The token before the cursor, in the macro-expanded file.\n     pub(super) token: SyntaxToken,\n     pub(super) krate: Option<hir::Crate>,\n-    pub(super) expected_name: Option<String>,\n+    pub(super) expected_name: Option<NameOrNameRef>,\n     pub(super) expected_type: Option<Type>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n     pub(super) function_syntax: Option<ast::Fn>,\n@@ -292,21 +295,21 @@ impl<'a> CompletionContext<'a> {\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n     ) {\n-        let expected = {\n+        let (expected_type, expected_name) = {\n             let mut node = match self.token.parent() {\n                 Some(it) => it,\n                 None => return,\n             };\n             loop {\n-                let ret = match_ast! {\n+                break match_ast! {\n                     match node {\n                         ast::LetStmt(it) => {\n                             cov_mark::hit!(expected_type_let_with_leading_char);\n                             cov_mark::hit!(expected_type_let_without_leading_char);\n                             let ty = it.pat()\n                                 .and_then(|pat| self.sema.type_of_pat(&pat));\n                             let name = if let Some(ast::Pat::IdentPat(ident)) = it.pat() {\n-                                Some(ident.syntax().text().to_string())\n+                                ident.name().map(NameOrNameRef::Name)\n                             } else {\n                                 None\n                             };\n@@ -319,18 +322,21 @@ impl<'a> CompletionContext<'a> {\n                             ActiveParameter::at_token(\n                                 &self.sema,\n                                 self.token.clone(),\n-                            ).map(|ap| (Some(ap.ty), Some(ap.name)))\n+                            ).map(|ap| {\n+                                let name = ap.ident().map(NameOrNameRef::Name);\n+                                (Some(ap.ty), name)\n+                            })\n                             .unwrap_or((None, None))\n                         },\n                         ast::RecordExprFieldList(_it) => {\n                             cov_mark::hit!(expected_type_struct_field_without_leading_char);\n                             self.token.prev_sibling_or_token()\n                                 .and_then(|se| se.into_node())\n                                 .and_then(|node| ast::RecordExprField::cast(node))\n-                                .and_then(|rf| self.sema.resolve_record_field(&rf))\n-                                .map(|f|(\n+                                .and_then(|rf| self.sema.resolve_record_field(&rf).zip(Some(rf)))\n+                                .map(|(f, rf)|(\n                                     Some(f.0.signature_ty(self.db)),\n-                                    Some(f.0.name(self.db).to_string()),\n+                                    rf.field_name().map(NameOrNameRef::NameRef),\n                                 ))\n                                 .unwrap_or((None, None))\n                         },\n@@ -340,7 +346,7 @@ impl<'a> CompletionContext<'a> {\n                                 .resolve_record_field(&it)\n                                 .map(|f|(\n                                     Some(f.0.signature_ty(self.db)),\n-                                    Some(f.0.name(self.db).to_string()),\n+                                    it.field_name().map(NameOrNameRef::NameRef),\n                                 ))\n                                 .unwrap_or((None, None))\n                         },\n@@ -378,12 +384,10 @@ impl<'a> CompletionContext<'a> {\n                         },\n                     }\n                 };\n-\n-                break ret;\n             }\n         };\n-        self.expected_type = expected.0;\n-        self.expected_name = expected.1;\n+        self.expected_type = expected_type;\n+        self.expected_name = expected_name;\n         self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n \n         // First, let's try to complete a reference to some declaration.\n@@ -631,7 +635,9 @@ mod tests {\n             .map(|t| t.display_test(&db).to_string())\n             .unwrap_or(\"?\".to_owned());\n \n-        let name = completion_context.expected_name.unwrap_or(\"?\".to_owned());\n+        let name = completion_context\n+            .expected_name\n+            .map_or_else(|| \"?\".to_owned(), |name| name.to_string());\n \n         expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n     }"}, {"sha": "2b6e9ebd1f84f92f4803f120be655212b0d4c741", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=38048c35d800230d3e5a79041186366dd0ef44ae", "patch": "@@ -243,7 +243,7 @@ impl<'a> Render<'a> {\n \n             item.set_relevance(CompletionRelevance {\n                 exact_type_match: compute_exact_type_match(self.ctx.completion, &ty),\n-                exact_name_match: compute_exact_name_match(self.ctx.completion, local_name.clone()),\n+                exact_name_match: compute_exact_name_match(self.ctx.completion, &local_name),\n                 is_local: true,\n                 ..CompletionRelevance::default()\n             });\n@@ -319,8 +319,7 @@ fn compute_exact_type_match(ctx: &CompletionContext, completion_ty: &hir::Type)\n \n fn compute_exact_name_match(ctx: &CompletionContext, completion_name: impl Into<String>) -> bool {\n     let completion_name = completion_name.into();\n-\n-    Some(&completion_name) == ctx.expected_name.as_ref()\n+    ctx.expected_name.as_ref().map_or(false, |name| name.text() == completion_name)\n }\n \n fn compute_ref_match(ctx: &CompletionContext, completion_ty: &hir::Type) -> Option<Mutability> {"}, {"sha": "e583a52f46df3ec8b4c04927c81835c3cf7862bf", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=38048c35d800230d3e5a79041186366dd0ef44ae", "patch": "@@ -4,7 +4,7 @@ use either::Either;\n use hir::{HasAttrs, HirDisplay, Semantics, Type};\n use stdx::format_to;\n use syntax::{\n-    ast::{self, ArgListOwner},\n+    ast::{self, ArgListOwner, NameOwner},\n     match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n@@ -142,7 +142,7 @@ fn call_info_impl(\n #[derive(Debug)]\n pub struct ActiveParameter {\n     pub ty: Type,\n-    pub name: String,\n+    pub pat: Either<ast::SelfParam, ast::Pat>,\n }\n \n impl ActiveParameter {\n@@ -165,8 +165,14 @@ impl ActiveParameter {\n             return None;\n         }\n         let (pat, ty) = params.swap_remove(idx);\n-        let name = pat?.to_string();\n-        Some(ActiveParameter { ty, name })\n+        pat.map(|pat| ActiveParameter { ty, pat })\n+    }\n+\n+    pub fn ident(&self) -> Option<ast::Name> {\n+        self.pat.as_ref().right().and_then(|param| match param {\n+            ast::Pat::IdentPat(ident) => ident.name(),\n+            _ => None,\n+        })\n     }\n }\n "}, {"sha": "42a7b9c2a6382c69957c85c48fd92cd8c5445189", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38048c35d800230d3e5a79041186366dd0ef44ae/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=38048c35d800230d3e5a79041186366dd0ef44ae", "patch": "@@ -380,6 +380,15 @@ impl fmt::Display for NameOrNameRef {\n     }\n }\n \n+impl NameOrNameRef {\n+    pub fn text(&self) -> &str {\n+        match self {\n+            NameOrNameRef::Name(name) => name.text(),\n+            NameOrNameRef::NameRef(name_ref) => name_ref.text(),\n+        }\n+    }\n+}\n+\n impl ast::RecordPatField {\n     pub fn for_field_name_ref(field_name: &ast::NameRef) -> Option<ast::RecordPatField> {\n         let candidate = field_name.syntax().parent().and_then(ast::RecordPatField::cast)?;"}]}