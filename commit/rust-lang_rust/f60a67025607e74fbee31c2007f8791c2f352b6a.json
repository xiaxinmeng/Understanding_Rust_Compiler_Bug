{"sha": "f60a67025607e74fbee31c2007f8791c2f352b6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MGE2NzAyNTYwN2U3NGZiZWUzMWMyMDA3Zjg3OTFjMmYzNTJiNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-30T10:11:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-30T10:11:23Z"}, "message": "Auto merge of #85319 - cjgillot:query-simp, r=Mark-Simulacrum\n\nSimplification of query forcing\n\nExtracted from #78780", "tree": {"sha": "7523109bac093b121d5b8dd509119da951f89497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7523109bac093b121d5b8dd509119da951f89497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f60a67025607e74fbee31c2007f8791c2f352b6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f60a67025607e74fbee31c2007f8791c2f352b6a", "html_url": "https://github.com/rust-lang/rust/commit/f60a67025607e74fbee31c2007f8791c2f352b6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f60a67025607e74fbee31c2007f8791c2f352b6a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d93b6a4598946a6a97e8f1b073b1cfc08d332a86", "url": "https://api.github.com/repos/rust-lang/rust/commits/d93b6a4598946a6a97e8f1b073b1cfc08d332a86", "html_url": "https://github.com/rust-lang/rust/commit/d93b6a4598946a6a97e8f1b073b1cfc08d332a86"}, {"sha": "f3ed997254aad0354d79d79497ced1357999bfae", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ed997254aad0354d79d79497ced1357999bfae", "html_url": "https://github.com/rust-lang/rust/commit/f3ed997254aad0354d79d79497ced1357999bfae"}], "stats": {"total": 338, "additions": 167, "deletions": 171}, "files": [{"sha": "ac81c0261e29070b68c07cfe59054566afd70bb0", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=f60a67025607e74fbee31c2007f8791c2f352b6a", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_val\n use rustc_middle::ty::query::{Providers, QueryEngine};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_serialize::opaque;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n \n #[macro_use]\n mod plumbing;"}, {"sha": "08309d63a45f9a92f192fb3b06b5ec07d8ddcb53", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=f60a67025607e74fbee31c2007f8791c2f352b6a", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_serialize::opaque;\n-use rustc_span::def_id::{DefId, LocalDefId};\n+use rustc_span::def_id::LocalDefId;\n \n #[derive(Copy, Clone)]\n pub struct QueryCtxt<'tcx> {\n@@ -25,6 +25,7 @@ pub struct QueryCtxt<'tcx> {\n impl<'tcx> std::ops::Deref for QueryCtxt<'tcx> {\n     type Target = TyCtxt<'tcx>;\n \n+    #[inline]\n     fn deref(&self) -> &Self::Target {\n         &self.tcx\n     }\n@@ -42,10 +43,6 @@ impl HasDepContext for QueryCtxt<'tcx> {\n }\n \n impl QueryContext for QueryCtxt<'tcx> {\n-    fn def_path_str(&self, def_id: DefId) -> String {\n-        self.tcx.def_path_str(def_id)\n-    }\n-\n     fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>> {\n         tls::with_related_context(**self, |icx| icx.query)\n     }\n@@ -457,20 +454,7 @@ macro_rules! define_queries {\n                 }\n \n                 fn force_from_dep_node(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool {\n-                    if is_anon {\n-                        return false;\n-                    }\n-\n-                    if !can_reconstruct_query_key() {\n-                        return false;\n-                    }\n-\n-                    if let Some(key) = recover(*tcx, dep_node) {\n-                        force_query::<queries::$name<'_>, _>(tcx, key, DUMMY_SP, *dep_node);\n-                        return true;\n-                    }\n-\n-                    false\n+                    force_query::<queries::$name<'_>, _>(tcx, dep_node)\n                 }\n \n                 fn try_load_from_on_disk_cache(tcx: QueryCtxt<'_>, dep_node: &DepNode) {"}, {"sha": "cfae65abe8383b283f0ff89454fc3759dadbb548", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 113, "deletions": 118, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=f60a67025607e74fbee31c2007f8791c2f352b6a", "patch": "@@ -487,6 +487,117 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    fn try_mark_parent_green<Ctxt: QueryContext<DepKind = K>>(\n+        &self,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n+        parent_dep_node_index: SerializedDepNodeIndex,\n+        dep_node: &DepNode<K>,\n+    ) -> Option<()> {\n+        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n+        let dep_dep_node = &data.previous.index_to_node(parent_dep_node_index);\n+\n+        match dep_dep_node_color {\n+            Some(DepNodeColor::Green(_)) => {\n+                // This dependency has been marked as green before, we are\n+                // still fine and can continue with checking the other\n+                // dependencies.\n+                debug!(\n+                    \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n+                            be immediately green\",\n+                    dep_node, dep_dep_node,\n+                );\n+                return Some(());\n+            }\n+            Some(DepNodeColor::Red) => {\n+                // We found a dependency the value of which has changed\n+                // compared to the previous compilation session. We cannot\n+                // mark the DepNode as green and also don't need to bother\n+                // with checking any of the other dependencies.\n+                debug!(\n+                    \"try_mark_previous_green({:?}) - END - dependency {:?} was immediately red\",\n+                    dep_node, dep_dep_node,\n+                );\n+                return None;\n+            }\n+            None => {}\n+        }\n+\n+        // We don't know the state of this dependency. If it isn't\n+        // an eval_always node, let's try to mark it green recursively.\n+        if !dep_dep_node.kind.is_eval_always() {\n+            debug!(\n+                \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n+                                 is unknown, trying to mark it green\",\n+                dep_node, dep_dep_node, dep_dep_node.hash,\n+            );\n+\n+            let node_index =\n+                self.try_mark_previous_green(tcx, data, parent_dep_node_index, dep_dep_node);\n+            if node_index.is_some() {\n+                debug!(\n+                    \"try_mark_previous_green({:?}) --- managed to MARK dependency {:?} as green\",\n+                    dep_node, dep_dep_node\n+                );\n+                return Some(());\n+            }\n+        }\n+\n+        // We failed to mark it green, so we try to force the query.\n+        debug!(\n+            \"try_mark_previous_green({:?}) --- trying to force dependency {:?}\",\n+            dep_node, dep_dep_node\n+        );\n+        if !tcx.try_force_from_dep_node(dep_dep_node) {\n+            // The DepNode could not be forced.\n+            debug!(\n+                \"try_mark_previous_green({:?}) - END - dependency {:?} could not be forced\",\n+                dep_node, dep_dep_node\n+            );\n+            return None;\n+        }\n+\n+        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n+\n+        match dep_dep_node_color {\n+            Some(DepNodeColor::Green(_)) => {\n+                debug!(\n+                    \"try_mark_previous_green({:?}) --- managed to FORCE dependency {:?} to green\",\n+                    dep_node, dep_dep_node\n+                );\n+                return Some(());\n+            }\n+            Some(DepNodeColor::Red) => {\n+                debug!(\n+                    \"try_mark_previous_green({:?}) - END - dependency {:?} was red after forcing\",\n+                    dep_node, dep_dep_node\n+                );\n+                return None;\n+            }\n+            None => {}\n+        }\n+\n+        if !tcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n+            panic!(\"try_mark_previous_green() - Forcing the DepNode should have set its color\")\n+        }\n+\n+        // If the query we just forced has resulted in\n+        // some kind of compilation error, we cannot rely on\n+        // the dep-node color having been properly updated.\n+        // This means that the query system has reached an\n+        // invalid state. We let the compiler continue (by\n+        // returning `None`) so it can emit error messages\n+        // and wind down, but rely on the fact that this\n+        // invalid state will not be persisted to the\n+        // incremental compilation cache because of\n+        // compilation errors being present.\n+        debug!(\n+            \"try_mark_previous_green({:?}) - END - dependency {:?} resulted in compilation error\",\n+            dep_node, dep_dep_node\n+        );\n+        return None;\n+    }\n+\n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n@@ -511,123 +622,7 @@ impl<K: DepKind> DepGraph<K> {\n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n-\n-            match dep_dep_node_color {\n-                Some(DepNodeColor::Green(_)) => {\n-                    // This dependency has been marked as green before, we are\n-                    // still fine and can continue with checking the other\n-                    // dependencies.\n-                    debug!(\n-                        \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n-                            be immediately green\",\n-                        dep_node,\n-                        data.previous.index_to_node(dep_dep_node_index)\n-                    );\n-                }\n-                Some(DepNodeColor::Red) => {\n-                    // We found a dependency the value of which has changed\n-                    // compared to the previous compilation session. We cannot\n-                    // mark the DepNode as green and also don't need to bother\n-                    // with checking any of the other dependencies.\n-                    debug!(\n-                        \"try_mark_previous_green({:?}) - END - dependency {:?} was \\\n-                            immediately red\",\n-                        dep_node,\n-                        data.previous.index_to_node(dep_dep_node_index)\n-                    );\n-                    return None;\n-                }\n-                None => {\n-                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n-\n-                    // We don't know the state of this dependency. If it isn't\n-                    // an eval_always node, let's try to mark it green recursively.\n-                    if !dep_dep_node.kind.is_eval_always() {\n-                        debug!(\n-                            \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n-                                 is unknown, trying to mark it green\",\n-                            dep_node, dep_dep_node, dep_dep_node.hash,\n-                        );\n-\n-                        let node_index = self.try_mark_previous_green(\n-                            tcx,\n-                            data,\n-                            dep_dep_node_index,\n-                            dep_dep_node,\n-                        );\n-                        if node_index.is_some() {\n-                            debug!(\n-                                \"try_mark_previous_green({:?}) --- managed to MARK \\\n-                                    dependency {:?} as green\",\n-                                dep_node, dep_dep_node\n-                            );\n-                            continue;\n-                        }\n-                    }\n-\n-                    // We failed to mark it green, so we try to force the query.\n-                    debug!(\n-                        \"try_mark_previous_green({:?}) --- trying to force \\\n-                            dependency {:?}\",\n-                        dep_node, dep_dep_node\n-                    );\n-                    if tcx.try_force_from_dep_node(dep_dep_node) {\n-                        let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n-\n-                        match dep_dep_node_color {\n-                            Some(DepNodeColor::Green(_)) => {\n-                                debug!(\n-                                    \"try_mark_previous_green({:?}) --- managed to \\\n-                                        FORCE dependency {:?} to green\",\n-                                    dep_node, dep_dep_node\n-                                );\n-                            }\n-                            Some(DepNodeColor::Red) => {\n-                                debug!(\n-                                    \"try_mark_previous_green({:?}) - END - \\\n-                                        dependency {:?} was red after forcing\",\n-                                    dep_node, dep_dep_node\n-                                );\n-                                return None;\n-                            }\n-                            None => {\n-                                if !tcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n-                                    panic!(\n-                                        \"try_mark_previous_green() - Forcing the DepNode \\\n-                                          should have set its color\"\n-                                    )\n-                                } else {\n-                                    // If the query we just forced has resulted in\n-                                    // some kind of compilation error, we cannot rely on\n-                                    // the dep-node color having been properly updated.\n-                                    // This means that the query system has reached an\n-                                    // invalid state. We let the compiler continue (by\n-                                    // returning `None`) so it can emit error messages\n-                                    // and wind down, but rely on the fact that this\n-                                    // invalid state will not be persisted to the\n-                                    // incremental compilation cache because of\n-                                    // compilation errors being present.\n-                                    debug!(\n-                                        \"try_mark_previous_green({:?}) - END - \\\n-                                            dependency {:?} resulted in compilation error\",\n-                                        dep_node, dep_dep_node\n-                                    );\n-                                    return None;\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        // The DepNode could not be forced.\n-                        debug!(\n-                            \"try_mark_previous_green({:?}) - END - dependency {:?} \\\n-                                could not be forced\",\n-                            dep_node, dep_dep_node\n-                        );\n-                        return None;\n-                    }\n-                }\n-            }\n+            self.try_mark_parent_green(tcx, data, dep_dep_node_index, dep_node)?\n         }\n \n         // If we got here without hitting a `return` that means that all\n@@ -796,7 +791,7 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n+    pub(crate) fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n         let index = self.virtual_dep_node_index.fetch_add(1, Relaxed);\n         DepNodeIndex::from_u32(index)\n     }"}, {"sha": "927e8117f05ea9ae7d7b7b8dc3e8c9ec730b836a", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=f60a67025607e74fbee31c2007f8791c2f352b6a", "patch": "@@ -19,7 +19,6 @@ use crate::dep_graph::{DepNode, DepNodeIndex, HasDepContext, SerializedDepNodeIn\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n /// Description of a frame in the query stack.\n@@ -64,9 +63,6 @@ impl QueryStackFrame {\n }\n \n pub trait QueryContext: HasDepContext {\n-    /// Get string representation from DefPath.\n-    fn def_path_str(&self, def_id: DefId) -> String;\n-\n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>>;\n "}, {"sha": "c1f9fa39e98c5cf183abc8e66fce2f6b5004c98d", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60a67025607e74fbee31c2007f8791c2f352b6a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=f60a67025607e74fbee31c2007f8791c2f352b6a", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepKind, DepNode};\n+use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeParams};\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n@@ -19,7 +19,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n #[cfg(not(parallel_compiler))]\n use rustc_errors::DiagnosticBuilder;\n use rustc_errors::{Diagnostic, FatalError};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n@@ -431,7 +431,7 @@ fn try_execute_query<CTX, C>(\n ) -> C::Stored\n where\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+    C::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     let job = match JobOwner::<'_, CTX::DepKind, C>::try_start(\n@@ -452,29 +452,30 @@ where\n         }\n     };\n \n-    // Fast path for when incr. comp. is off. `to_dep_node` is\n-    // expensive for some `DepKind`s.\n-    if !tcx.dep_context().dep_graph().is_fully_enabled() {\n-        let null_dep_node = DepNode::new_no_params(DepKind::NULL);\n-        return force_query_with_job(tcx, key, job, null_dep_node, query).0;\n+    let dep_graph = tcx.dep_context().dep_graph();\n+\n+    // Fast path for when incr. comp. is off.\n+    if !dep_graph.is_fully_enabled() {\n+        let prof_timer = tcx.dep_context().profiler().query_provider();\n+        let result = tcx.start_query(job.id, None, || query.compute(tcx, key));\n+        let dep_node_index = dep_graph.next_virtual_depnode_index();\n+        prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+        return job.complete(result, dep_node_index);\n     }\n \n     if query.anon {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             tcx.start_query(job.id, diagnostics, || {\n-                tcx.dep_context().dep_graph().with_anon_task(\n-                    *tcx.dep_context(),\n-                    query.dep_kind,\n-                    || query.compute(tcx, key),\n-                )\n+                dep_graph\n+                    .with_anon_task(*tcx.dep_context(), query.dep_kind, || query.compute(tcx, key))\n             })\n         });\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-        tcx.dep_context().dep_graph().read_index(dep_node_index);\n+        dep_graph.read_index(dep_node_index);\n \n         if unlikely!(!diagnostics.is_empty()) {\n             tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n@@ -490,7 +491,7 @@ where\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         let loaded = tcx.start_query(job.id, None, || {\n-            let marked = tcx.dep_context().dep_graph().try_mark_green_and_read(tcx, &dep_node);\n+            let marked = dep_graph.try_mark_green_and_read(tcx, &dep_node);\n             marked.map(|(prev_dep_node_index, dep_node_index)| {\n                 (\n                     load_from_disk_and_cache_in_memory(\n@@ -511,7 +512,7 @@ where\n     }\n \n     let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query);\n-    tcx.dep_context().dep_graph().read_index(dep_node_index);\n+    dep_graph.read_index(dep_node_index);\n     result\n }\n \n@@ -693,7 +694,7 @@ fn get_query_impl<CTX, C>(\n where\n     CTX: QueryContext,\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+    C::Key: DepNodeParams<CTX::DepContext>,\n {\n     try_execute_query(tcx, state, cache, span, key, lookup, query)\n }\n@@ -743,15 +744,28 @@ fn force_query_impl<CTX, C>(\n     tcx: CTX,\n     state: &QueryState<CTX::DepKind, C::Key>,\n     cache: &QueryCacheStore<C>,\n-    key: C::Key,\n-    span: Span,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n-) where\n+) -> bool\n+where\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+    C::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n+    debug_assert!(!query.anon);\n+\n+    if !<C::Key as DepNodeParams<CTX::DepContext>>::can_reconstruct_query_key() {\n+        return false;\n+    }\n+\n+    let key = if let Some(key) =\n+        <C::Key as DepNodeParams<CTX::DepContext>>::recover(*tcx.dep_context(), &dep_node)\n+    {\n+        key\n+    } else {\n+        return false;\n+    };\n+\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n     let cached = cache.cache.lookup(cache, &key, |_, index| {\n@@ -765,25 +779,28 @@ fn force_query_impl<CTX, C>(\n     });\n \n     let lookup = match cached {\n-        Ok(()) => return,\n+        Ok(()) => return true,\n         Err(lookup) => lookup,\n     };\n \n     let job = match JobOwner::<'_, CTX::DepKind, C>::try_start(\n         tcx,\n         state,\n         cache,\n-        span,\n+        DUMMY_SP,\n         key.clone(),\n         lookup,\n         query,\n     ) {\n         TryGetJob::NotYetStarted(job) => job,\n-        TryGetJob::Cycle(_) => return,\n+        TryGetJob::Cycle(_) => return true,\n         #[cfg(parallel_compiler)]\n-        TryGetJob::JobCompleted(_) => return,\n+        TryGetJob::JobCompleted(_) => return true,\n     };\n+\n     force_query_with_job(tcx, key, job, dep_node, query);\n+\n+    true\n }\n \n pub enum QueryMode {\n@@ -800,7 +817,7 @@ pub fn get_query<Q, CTX>(\n ) -> Option<Q::Stored>\n where\n     Q: QueryDescription<CTX>,\n-    Q::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+    Q::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     let query = &Q::VTABLE;\n@@ -816,11 +833,15 @@ where\n     Some(value)\n }\n \n-pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, span: Span, dep_node: DepNode<CTX::DepKind>)\n+pub fn force_query<Q, CTX>(tcx: CTX, dep_node: &DepNode<CTX::DepKind>) -> bool\n where\n     Q: QueryDescription<CTX>,\n-    Q::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+    Q::Key: DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    force_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), key, span, dep_node, &Q::VTABLE)\n+    if Q::ANON {\n+        return false;\n+    }\n+\n+    force_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), *dep_node, &Q::VTABLE)\n }"}]}