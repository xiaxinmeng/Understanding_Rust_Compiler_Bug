{"sha": "d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MGE5ZDNkYTBmOGM3N2Q5OGJkMzgxNDhkNzhkYjk1ZjdmOGZjNWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-10T06:15:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-10T06:15:15Z"}, "message": "rt: Inline everything on the C-stack-switching path", "tree": {"sha": "cedc6690bfd31bf7e97463f8c187e0d0a69fbfc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cedc6690bfd31bf7e97463f8c187e0d0a69fbfc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "html_url": "https://github.com/rust-lang/rust/commit/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dff256cd198b6575f5194abb059c1798b7198f6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dff256cd198b6575f5194abb059c1798b7198f6f", "html_url": "https://github.com/rust-lang/rust/commit/dff256cd198b6575f5194abb059c1798b7198f6f"}], "stats": {"total": 303, "additions": 155, "deletions": 148}, "files": [{"sha": "815830e1974c79e234163db6d73003c866da3d5d", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "patch": "@@ -673,19 +673,6 @@ rust_task::record_stack_limit() {\n     record_sp(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);\n }\n \n-extern \"C\" uintptr_t get_sp();\n-\n-static bool\n-sp_in_stk_seg(uintptr_t sp, stk_seg *stk) {\n-    // Not positive these bounds for sp are correct.  I think that the first\n-    // possible value for esp on a new stack is stk->end, which points to the\n-    // address before the first value to be pushed onto a new stack. The last\n-    // possible address we can push data to is stk->data.  Regardless, there's\n-    // so much slop at either end that we should never hit one of these\n-    // boundaries.\n-    return (uintptr_t)stk->data <= sp && sp <= stk->end;\n-}\n-\n /*\n Called by landing pads during unwinding to figure out which\n stack segment we are currently running on, delete the others,\n@@ -702,25 +689,6 @@ rust_task::reset_stack_limit() {\n     record_stack_limit();\n }\n \n-/*\n-Returns true if we're currently running on the Rust stack\n- */\n-bool\n-rust_task::on_rust_stack() {\n-    uintptr_t sp = get_sp();\n-    bool in_first_segment = sp_in_stk_seg(sp, stk);\n-    if (in_first_segment) {\n-        return true;\n-    } else if (stk->next != NULL) {\n-        // This happens only when calling the upcall to delete\n-        // a stack segment\n-        bool in_second_segment = sp_in_stk_seg(sp, stk->next);\n-        return in_second_segment;\n-    } else {\n-        return false;\n-    }\n-}\n-\n void\n rust_task::check_stack_canary() {\n     ::check_stack_canary(stk);\n@@ -732,76 +700,6 @@ rust_task::config_notify(chan_handle chan) {\n     notify_chan = chan;\n }\n \n-// This is the function that switches stacks by calling another function with\n-// a single void* argument while changing the stack pointer. It has a funny\n-// name because gdb doesn't normally like to backtrace through split stacks\n-// (thinks it indicates a bug), but has a special case to allow functions\n-// named __morestack to move the stack pointer around.\n-extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n-\n-static uintptr_t\n-sanitize_next_sp(uintptr_t next_sp) {\n-\n-    // Since I'm not precisely sure where the next stack pointer sits in\n-    // relation to where the context switch actually happened, nor in relation\n-    // to the amount of stack needed for calling __morestack I've added some\n-    // extra bytes here.\n-\n-    // FIXME: On the rust stack this potentially puts is quite far into the\n-    // red zone. Might want to just allocate a new rust stack every time we\n-    // switch back to rust.\n-    const uintptr_t padding = 16;\n-\n-    return align_down(next_sp - padding);\n-}\n-\n-void\n-rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n-    I(thread, on_rust_stack());\n-\n-    next_rust_sp = get_sp();\n-\n-    bool borrowed_a_c_stack = false;\n-    uintptr_t sp;\n-    if (c_stack == NULL) {\n-        c_stack = thread->borrow_c_stack();\n-        next_c_sp = align_down(c_stack->end);\n-        sp = next_c_sp;\n-        borrowed_a_c_stack = true;\n-    } else {\n-        sp = sanitize_next_sp(next_c_sp);\n-    }\n-\n-    __morestack(args, fn_ptr, sp);\n-\n-    // Note that we may not actually get here if we threw an exception,\n-    // in which case we will return the c stack when the exception is caught.\n-    if (borrowed_a_c_stack) {\n-        return_c_stack();\n-    }\n-}\n-\n-void\n-rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n-    I(thread, !on_rust_stack());\n-    I(thread, next_rust_sp);\n-\n-    next_c_sp = get_sp();\n-\n-    uintptr_t sp = sanitize_next_sp(next_rust_sp);\n-\n-    __morestack(args, fn_ptr, sp);\n-}\n-\n-void\n-rust_task::return_c_stack() {\n-    I(thread, on_rust_stack());\n-    I(thread, c_stack != NULL);\n-    thread->return_c_stack(c_stack);\n-    c_stack = NULL;\n-    next_c_sp = 0;\n-}\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "beb09d149c42021cb028142cccad7e6ad5923500", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "patch": "@@ -198,6 +198,109 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     void call_on_rust_stack(void *args, void *fn_ptr);\n };\n \n+// Get a rough approximation of the current stack pointer\n+extern \"C\" uintptr_t get_sp();\n+\n+// This is the function that switches stacks by calling another function with\n+// a single void* argument while changing the stack pointer. It has a funny\n+// name because gdb doesn't normally like to backtrace through split stacks\n+// (thinks it indicates a bug), but has a special case to allow functions\n+// named __morestack to move the stack pointer around.\n+extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n+\n+inline static uintptr_t\n+sanitize_next_sp(uintptr_t next_sp) {\n+\n+    // Since I'm not precisely sure where the next stack pointer sits in\n+    // relation to where the context switch actually happened, nor in relation\n+    // to the amount of stack needed for calling __morestack I've added some\n+    // extra bytes here.\n+\n+    // FIXME: On the rust stack this potentially puts is quite far into the\n+    // red zone. Might want to just allocate a new rust stack every time we\n+    // switch back to rust.\n+    const uintptr_t padding = 16;\n+\n+    return align_down(next_sp - padding);\n+}\n+\n+inline void\n+rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n+    I(thread, on_rust_stack());\n+\n+    next_rust_sp = get_sp();\n+\n+    bool borrowed_a_c_stack = false;\n+    uintptr_t sp;\n+    if (c_stack == NULL) {\n+        c_stack = thread->borrow_c_stack();\n+        next_c_sp = align_down(c_stack->end);\n+        sp = next_c_sp;\n+        borrowed_a_c_stack = true;\n+    } else {\n+        sp = sanitize_next_sp(next_c_sp);\n+    }\n+\n+    __morestack(args, fn_ptr, sp);\n+\n+    // Note that we may not actually get here if we threw an exception,\n+    // in which case we will return the c stack when the exception is caught.\n+    if (borrowed_a_c_stack) {\n+        return_c_stack();\n+    }\n+}\n+\n+inline void\n+rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n+    I(thread, !on_rust_stack());\n+    I(thread, next_rust_sp);\n+\n+    next_c_sp = get_sp();\n+\n+    uintptr_t sp = sanitize_next_sp(next_rust_sp);\n+\n+    __morestack(args, fn_ptr, sp);\n+}\n+\n+inline void\n+rust_task::return_c_stack() {\n+    I(thread, on_rust_stack());\n+    I(thread, c_stack != NULL);\n+    thread->return_c_stack(c_stack);\n+    c_stack = NULL;\n+    next_c_sp = 0;\n+}\n+\n+inline bool\n+sp_in_stk_seg(uintptr_t sp, stk_seg *stk) {\n+    // Not positive these bounds for sp are correct.  I think that the first\n+    // possible value for esp on a new stack is stk->end, which points to the\n+    // address before the first value to be pushed onto a new stack. The last\n+    // possible address we can push data to is stk->data.  Regardless, there's\n+    // so much slop at either end that we should never hit one of these\n+    // boundaries.\n+    return (uintptr_t)stk->data <= sp && sp <= stk->end;\n+}\n+\n+/*\n+Returns true if we're currently running on the Rust stack\n+ */\n+inline bool\n+rust_task::on_rust_stack() {\n+    uintptr_t sp = get_sp();\n+    bool in_first_segment = sp_in_stk_seg(sp, stk);\n+    if (in_first_segment) {\n+        return true;\n+    } else if (stk->next != NULL) {\n+        // This happens only when calling the upcall to delete\n+        // a stack segment\n+        bool in_second_segment = sp_in_stk_seg(sp, stk->next);\n+        return in_second_segment;\n+    } else {\n+        return false;\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "e217c2e610e7941fa3ff89430e3cadb58b50261f", "filename": "src/rt/rust_task_thread.cpp", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.cpp?ref=d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "patch": "@@ -337,16 +337,6 @@ rust_task_thread::place_task_in_tls(rust_task *task) {\n     assert(!result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n-\n-rust_task *\n-rust_task_thread::get_task() {\n-    if (!tls_initialized)\n-        return NULL;\n-    rust_task *task = reinterpret_cast<rust_task *>\n-        (pthread_getspecific(task_key));\n-    assert(task && \"Couldn't get the task from TLS!\");\n-    return task;\n-}\n #else\n void\n rust_task_thread::init_tls() {\n@@ -361,15 +351,6 @@ rust_task_thread::place_task_in_tls(rust_task *task) {\n     assert(result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n-\n-rust_task *\n-rust_task_thread::get_task() {\n-    if (!tls_initialized)\n-        return NULL;\n-    rust_task *task = reinterpret_cast<rust_task *>(TlsGetValue(task_key));\n-    assert(task && \"Couldn't get the task from TLS!\");\n-    return task;\n-}\n #endif\n \n void\n@@ -402,32 +383,6 @@ rust_task_thread::unprepare_c_stack() {\n     }\n }\n \n-// NB: Runs on the Rust stack\n-stk_seg *\n-rust_task_thread::borrow_c_stack() {\n-    I(this, cached_c_stack);\n-    stk_seg *your_stack;\n-    if (extra_c_stack) {\n-        your_stack = extra_c_stack;\n-        extra_c_stack = NULL;\n-    } else {\n-        your_stack = cached_c_stack;\n-        cached_c_stack = NULL;\n-    }\n-    return your_stack;\n-}\n-\n-// NB: Runs on the Rust stack\n-void\n-rust_task_thread::return_c_stack(stk_seg *stack) {\n-    I(this, !extra_c_stack);\n-    if (!cached_c_stack) {\n-        cached_c_stack = stack;\n-    } else {\n-        extra_c_stack = stack;\n-    }\n-}\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "f5416a4a41ce4a09dd8b9135485fdf32088f5dee", "filename": "src/rt/rust_task_thread.h", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task_thread.h", "raw_url": "https://github.com/rust-lang/rust/raw/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_task_thread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.h?ref=d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "patch": "@@ -150,6 +150,58 @@ rust_task_thread::get_log() {\n     return _log;\n }\n \n+#ifndef __WIN32__\n+\n+inline rust_task *\n+rust_task_thread::get_task() {\n+    if (!tls_initialized)\n+        return NULL;\n+    rust_task *task = reinterpret_cast<rust_task *>\n+        (pthread_getspecific(task_key));\n+    assert(task && \"Couldn't get the task from TLS!\");\n+    return task;\n+}\n+\n+#else\n+\n+inline rust_task *\n+rust_task_thread::get_task() {\n+    if (!tls_initialized)\n+        return NULL;\n+    rust_task *task = reinterpret_cast<rust_task *>(TlsGetValue(task_key));\n+    assert(task && \"Couldn't get the task from TLS!\");\n+    return task;\n+}\n+\n+#endif\n+\n+// NB: Runs on the Rust stack\n+inline stk_seg *\n+rust_task_thread::borrow_c_stack() {\n+    I(this, cached_c_stack);\n+    stk_seg *your_stack;\n+    if (extra_c_stack) {\n+        your_stack = extra_c_stack;\n+        extra_c_stack = NULL;\n+    } else {\n+        your_stack = cached_c_stack;\n+        cached_c_stack = NULL;\n+    }\n+    return your_stack;\n+}\n+\n+// NB: Runs on the Rust stack\n+inline void\n+rust_task_thread::return_c_stack(stk_seg *stack) {\n+    I(this, !extra_c_stack);\n+    if (!cached_c_stack) {\n+        cached_c_stack = stack;\n+    } else {\n+        extra_c_stack = stack;\n+    }\n+}\n+\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "2eefe02aa2e7d184d3bf54caf9c1de4ab6ba5256", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=d90a9d3da0f8c77d98bd38148d78db95f7f8fc5a", "patch": "@@ -75,7 +75,6 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n         abort();\n     }\n \n-    task = rust_task_thread::get_task();\n     task->record_stack_limit();\n }\n "}]}