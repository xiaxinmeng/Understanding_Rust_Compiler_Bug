{"sha": "293966694c3c8e0c7028e8f54340fbc328d85bff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5Mzk2NjY5NGMzYzhlMGM3MDI4ZThmNTQzNDBmYmMzMjhkODViZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-14T04:21:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-14T04:21:58Z"}, "message": "Auto merge of #28816 - petrochenkov:unistruct, r=nrc\n\nThis patch uses the same data structures for structs and enum variants in AST and HIR. These changes in data structures lead to noticeable simplification in most of code dealing with them.\r\nI didn't touch the top level, i.e. `ItemStruct` is still `ItemStruct` and not `ItemEnum` with one variant, like in the type checker.\r\nAs part of this patch, structures and variants get the `kind` field making distinction between \"normal\" structs, tuple structs and unit structs explicit instead of relying on the number of fields and presence of constructor `NodeId`. In particular, we can now distinguish empty tuple structs from unit structs, which was impossible before! Comprehensive tests for empty structs are added and some improvements to empty struct feature gates are made. Some tests don't pass due to issue https://github.com/rust-lang/rust/issues/28692 , they are still there for completeness, but are commented out.\r\nThis patch fixes issue mentioned in https://github.com/rust-lang/rust/issues/16819#issuecomment-139509861, now emptiness of tuple structs is checked after expansion.\r\nIt also touches https://github.com/rust-lang/rust/issues/28750 by providing span for visit_struct_def\r\ncc https://github.com/rust-lang/rust/pull/28336\r\n\r\nr? @nrc", "tree": {"sha": "0c27cb6fd568cdb39da33c6d608bfe19c3c7af5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c27cb6fd568cdb39da33c6d608bfe19c3c7af5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293966694c3c8e0c7028e8f54340fbc328d85bff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293966694c3c8e0c7028e8f54340fbc328d85bff", "html_url": "https://github.com/rust-lang/rust/commit/293966694c3c8e0c7028e8f54340fbc328d85bff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293966694c3c8e0c7028e8f54340fbc328d85bff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0dc2cb81d29c051edba169f1527c149717f1c3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0dc2cb81d29c051edba169f1527c149717f1c3f", "html_url": "https://github.com/rust-lang/rust/commit/c0dc2cb81d29c051edba169f1527c149717f1c3f"}, {"sha": "607b8c38923878264980503227ff4911d0da5b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/607b8c38923878264980503227ff4911d0da5b4b", "html_url": "https://github.com/rust-lang/rust/commit/607b8c38923878264980503227ff4911d0da5b4b"}], "stats": {"total": 1739, "additions": 845, "deletions": 894}, "files": [{"sha": "8b4e94063f9bd950e1496b80f63ff567f9a32477", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -2357,7 +2357,7 @@ The currently implemented features of the reference compiler are:\n                               terms of encapsulation).\n * - `default_type_parameter_fallback` - Allows type parameter defaults to\n                                         influence type inference.\n-* - `braced_empty_structs` - Allows use of empty structs with braces.\n+* - `braced_empty_structs` - Allows use of empty structs and enum variants with braces.\n \n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled"}, {"sha": "fc7531d3f61bae924d5091dbd6ec080c59cd7cf6", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -134,40 +134,29 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             ItemEnum(ref enum_definition, _) => {\n                 for v in &enum_definition.variants {\n                     let variant_def_index =\n-                        self.insert_def(v.node.id,\n+                        self.insert_def(v.node.data.id(),\n                                         NodeVariant(&**v),\n                                         DefPathData::EnumVariant(v.node.name));\n \n-                    match v.node.kind {\n-                        TupleVariantKind(ref args) => {\n-                            for arg in args {\n-                                self.create_def_with_parent(Some(variant_def_index),\n-                                                            arg.id,\n-                                                            DefPathData::PositionalField);\n-                            }\n-                        }\n-                        StructVariantKind(ref def) => {\n-                            for field in &def.fields {\n-                                self.create_def_with_parent(\n-                                    Some(variant_def_index),\n-                                    field.node.id,\n-                                    DefPathData::Field(field.node.kind));\n-                            }\n-                        }\n+                    for field in v.node.data.fields() {\n+                        self.create_def_with_parent(\n+                            Some(variant_def_index),\n+                            field.node.id,\n+                            DefPathData::Field(field.node.kind));\n                     }\n                 }\n             }\n             ItemForeignMod(..) => {\n             }\n             ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n-                if let Some(ctor_id) = struct_def.ctor_id {\n-                    self.insert_def(ctor_id,\n+                if !struct_def.is_struct() {\n+                    self.insert_def(struct_def.id(),\n                                     NodeStructCtor(&**struct_def),\n                                     DefPathData::StructCtor);\n                 }\n \n-                for field in &struct_def.fields {\n+                for field in struct_def.fields() {\n                     self.create_def(field.node.id, DefPathData::Field(field.node.kind));\n                 }\n             }"}, {"sha": "028e1ad5ce97469b935fc50459acd62f18505c73", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -124,7 +124,7 @@ pub enum Node<'ast> {\n     NodeBlock(&'ast Block),\n \n     /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(&'ast StructDef),\n+    NodeStructCtor(&'ast VariantData),\n \n     NodeLifetime(&'ast Lifetime),\n     NodeTyParam(&'ast TyParam)\n@@ -149,7 +149,7 @@ pub enum MapEntry<'ast> {\n     EntryLocal(NodeId, &'ast Pat),\n     EntryPat(NodeId, &'ast Pat),\n     EntryBlock(NodeId, &'ast Block),\n-    EntryStructCtor(NodeId, &'ast StructDef),\n+    EntryStructCtor(NodeId, &'ast VariantData),\n     EntryLifetime(NodeId, &'ast Lifetime),\n     EntryTyParam(NodeId, &'ast TyParam),\n \n@@ -471,18 +471,19 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n+    pub fn expect_struct(&self, id: NodeId) -> &'ast VariantData {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) => &**struct_def,\n+                    ItemStruct(ref struct_def, _) => struct_def,\n                     _ => panic!(\"struct ID bound to non-struct\")\n                 }\n             }\n             Some(NodeVariant(variant)) => {\n-                match variant.node.kind {\n-                    StructVariantKind(ref struct_def) => &**struct_def,\n-                    _ => panic!(\"struct ID bound to enum variant that isn't struct-like\"),\n+                if variant.node.data.is_struct() {\n+                    &variant.node.data\n+                } else {\n+                    panic!(\"struct ID bound to enum variant that isn't struct-like\")\n                 }\n             }\n             _ => panic!(format!(\"expected struct, found {}\", self.node_to_string(id))),"}, {"sha": "f5c6cfe2437dcc66610b33d4cb58636946888af1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -661,14 +661,15 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         hir_visit::walk_fn(self, fk, decl, body, span);\n     }\n \n-    fn visit_struct_def(&mut self,\n-                        s: &hir::StructDef,\n+    fn visit_variant_data(&mut self,\n+                        s: &hir::VariantData,\n                         name: ast::Name,\n                         g: &hir::Generics,\n-                        id: ast::NodeId) {\n-        run_lints!(self, check_struct_def, late_passes, s, name, g, id);\n+                        item_id: ast::NodeId,\n+                        _: Span) {\n+        run_lints!(self, check_struct_def, late_passes, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, late_passes, s, name, g, id);\n+        run_lints!(self, check_struct_def_post, late_passes, s, name, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &hir::StructField) {\n@@ -678,10 +679,10 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics) {\n+    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, late_passes, v, g);\n-            hir_visit::walk_variant(cx, v, g);\n+            hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, late_passes, v, g);\n         })\n     }\n@@ -810,14 +811,15 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         ast_visit::walk_fn(self, fk, decl, body, span);\n     }\n \n-    fn visit_struct_def(&mut self,\n-                        s: &ast::StructDef,\n+    fn visit_variant_data(&mut self,\n+                        s: &ast::VariantData,\n                         ident: ast::Ident,\n                         g: &ast::Generics,\n-                        id: ast::NodeId) {\n-        run_lints!(self, check_struct_def, early_passes, s, ident, g, id);\n+                        item_id: ast::NodeId,\n+                        _: Span) {\n+        run_lints!(self, check_struct_def, early_passes, s, ident, g, item_id);\n         ast_visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, early_passes, s, ident, g, id);\n+        run_lints!(self, check_struct_def_post, early_passes, s, ident, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n@@ -827,10 +829,10 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, item_id: ast::NodeId) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, early_passes, v, g);\n-            ast_visit::walk_variant(cx, v, g);\n+            ast_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, early_passes, v, g);\n         })\n     }"}, {"sha": "14c11af6f3863293f4f4e51dee855bad2bf3ef2a", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -150,9 +150,9 @@ pub trait LateLintPass: LintPass {\n     fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n     fn check_struct_def(&mut self, _: &LateContext,\n-        _: &hir::StructDef, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n+        _: &hir::VariantData, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &LateContext,\n-        _: &hir::StructDef, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n+        _: &hir::VariantData, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n     fn check_struct_field(&mut self, _: &LateContext, _: &hir::StructField) { }\n     fn check_variant(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n     fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n@@ -192,9 +192,9 @@ pub trait EarlyLintPass: LintPass {\n     fn check_trait_item(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n     fn check_impl_item(&mut self, _: &EarlyContext, _: &ast::ImplItem) { }\n     fn check_struct_def(&mut self, _: &EarlyContext,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+        _: &ast::VariantData, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &EarlyContext,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+        _: &ast::VariantData, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n     fn check_struct_field(&mut self, _: &EarlyContext, _: &ast::StructField) { }\n     fn check_variant(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }"}, {"sha": "8e2c2e6a0bfbd2d0ce8fc09f787ee967edf3bd91", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -315,7 +315,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let vid = variant.did;\n         let variant_node_id = ecx.local_id(vid);\n \n-        if let ty::VariantKind::Dict = variant.kind() {\n+        if let ty::VariantKind::Struct = variant.kind() {\n             // tuple-like enum variant fields aren't really items so\n             // don't try to encode them.\n             for field in &variant.fields {\n@@ -328,7 +328,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_def_id_and_key(ecx, rbml_w, vid);\n         encode_family(rbml_w, match variant.kind() {\n             ty::VariantKind::Unit | ty::VariantKind::Tuple => 'v',\n-            ty::VariantKind::Dict => 'V'\n+            ty::VariantKind::Struct => 'V'\n         });\n         encode_name(rbml_w, variant.name);\n         encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(id));\n@@ -381,12 +381,8 @@ fn each_auxiliary_node_id<F>(item: &hir::Item, callback: F) -> bool where\n     match item.node {\n         hir::ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n-            match struct_def.ctor_id {\n-                Some(ctor_id) if !struct_def.fields.is_empty() &&\n-                        struct_def.fields[0].node.kind.is_unnamed() => {\n-                    continue_ = callback(ctor_id);\n-                }\n-                _ => {}\n+            if struct_def.is_tuple() {\n+                continue_ = callback(struct_def.id());\n             }\n         }\n         _ => {}\n@@ -1023,7 +1019,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n-            encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.id));\n+            encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n         }\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_path(rbml_w, path);\n@@ -1072,8 +1068,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-        if let Some(ctor_id) = struct_def.ctor_id {\n-            let ctor_did = ecx.tcx.map.local_def_id(ctor_id);\n+        if !struct_def.is_struct() {\n+            let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n             rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n                                  def_to_u64(ctor_did));\n         }\n@@ -1085,9 +1081,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n-        if let Some(ctor_id) = struct_def.ctor_id {\n-            encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n-                                        ctor_id, index, item.id);\n+        if !struct_def.is_struct() {\n+            encode_info_for_struct_ctor(ecx, rbml_w, item.name, struct_def.id(), index, item.id);\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {"}, {"sha": "e81445f19ede661ff85aadda7ee947415bf41ce7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -1315,17 +1315,17 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n                     def.variants.iter().zip(orig_def.variants.iter())\n                 {\n                     debug!(\"astencode: copying variant {:?} => {:?}\",\n-                           orig_variant.did, i_variant.node.id);\n-                    copy_item_type(dcx, i_variant.node.id, orig_variant.did);\n+                           orig_variant.did, i_variant.node.data.id());\n+                    copy_item_type(dcx, i_variant.node.data.id(), orig_variant.did);\n                 }\n             }\n             hir::ItemStruct(ref def, _) => {\n-                if let Some(ctor_id) = def.ctor_id {\n+                if !def.is_struct() {\n                     let ctor_did = dcx.tcx.lookup_adt_def(orig_did)\n                         .struct_variant().did;\n                     debug!(\"astencode: copying ctor {:?} => {:?}\", ctor_did,\n-                           ctor_id);\n-                    copy_item_type(dcx, ctor_id, ctor_did);\n+                           def.id());\n+                    copy_item_type(dcx, def.id(), ctor_did);\n                 }\n             }\n             _ => {}"}, {"sha": "4d7dd60a27156cff033ea7ec03f96039c3239167", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -518,7 +518,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n-            if let VariantKind::Dict = v.kind() {\n+            if let VariantKind::Struct = v.kind() {\n                 let field_pats: Vec<_> = v.fields.iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != hir::PatWild(hir::PatWildSingle))"}, {"sha": "fd73fe45180becc792314c348b6c0f0d6300d293", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n                         let mut recursion_visitor =\n                             CheckItemRecursionVisitor::new(self, &variant.span);\n                         recursion_visitor.populate_enum_discriminants(enum_def);\n-                        recursion_visitor.visit_variant(variant, generics);\n+                        recursion_visitor.visit_variant(variant, generics, it.id);\n                     }\n                 }\n             }\n@@ -168,7 +168,7 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n         let mut discriminant_map = self.discriminant_map.borrow_mut();\n         match enum_definition.variants.first() {\n             None => { return; }\n-            Some(variant) if discriminant_map.contains_key(&variant.node.id) => {\n+            Some(variant) if discriminant_map.contains_key(&variant.node.data.id()) => {\n                 return;\n             }\n             _ => {}\n@@ -177,7 +177,7 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n         // Go through all the variants.\n         let mut variant_stack: Vec<ast::NodeId> = Vec::new();\n         for variant in enum_definition.variants.iter().rev() {\n-            variant_stack.push(variant.node.id);\n+            variant_stack.push(variant.node.data.id());\n             // When we find an expression, every variant currently on the stack\n             // is affected by that expression.\n             if let Some(ref expr) = variant.node.disr_expr {\n@@ -201,14 +201,14 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n     }\n \n     fn visit_enum_def(&mut self, enum_definition: &'ast hir::EnumDef,\n-                      generics: &'ast hir::Generics) {\n+                      generics: &'ast hir::Generics, item_id: ast::NodeId) {\n         self.populate_enum_discriminants(enum_definition);\n-        visit::walk_enum_def(self, enum_definition, generics);\n+        visit::walk_enum_def(self, enum_definition, generics, item_id);\n     }\n \n     fn visit_variant(&mut self, variant: &'ast hir::Variant,\n-                     _: &'ast hir::Generics) {\n-        let variant_id = variant.node.id;\n+                     _: &'ast hir::Generics, _: ast::NodeId) {\n+        let variant_id = variant.node.data.id();\n         let maybe_expr;\n         if let Some(get_expr) = self.discriminant_map.borrow().get(&variant_id) {\n             // This is necessary because we need to let the `discriminant_map`\n@@ -269,9 +269,10 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                                 self.ast_map.expect_item(enum_node_id).node\n                             {\n                                 self.populate_enum_discriminants(enum_def);\n+                                let enum_id = self.ast_map.as_local_node_id(enum_id).unwrap();\n                                 let variant_id = self.ast_map.as_local_node_id(variant_id).unwrap();\n                                 let variant = self.ast_map.expect_variant(variant_id);\n-                                self.visit_variant(variant, generics);\n+                                self.visit_variant(variant, generics, enum_id);\n                             } else {\n                                 self.sess.span_bug(e.span,\n                                                    \"`check_static_recursion` found \\"}, {"sha": "3c68fb62e244519fad1b19848740bbe94304447d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -63,7 +63,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n     fn variant_expr<'a>(variants: &'a [P<hir::Variant>], id: ast::NodeId)\n                         -> Option<&'a Expr> {\n         for variant in variants {\n-            if variant.node.id == id {\n+            if variant.node.data.id() == id {\n                 return variant.node.disr_expr.as_ref().map(|e| &**e);\n             }\n         }"}, {"sha": "7b11419d92562c4e0300a05d87d15c49fc6c5243", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -215,11 +215,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n-    fn visit_struct_def(&mut self, def: &hir::StructDef, _: ast::Name,\n-                        _: &hir::Generics, _: ast::NodeId) {\n+    fn visit_variant_data(&mut self, def: &hir::VariantData, _: ast::Name,\n+                        _: &hir::Generics, _: ast::NodeId, _: codemap::Span) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n-        let live_fields = def.fields.iter().filter(|f| {\n+        let live_fields = def.fields().filter(|f| {\n             has_extern_repr || inherited_pub_visibility || match f.node.kind {\n                 hir::NamedField(_, hir::Public) => true,\n                 _ => false\n@@ -339,7 +339,8 @@ impl<'v> Visitor<'v> for LifeSeeder {\n         }\n         match item.node {\n             hir::ItemEnum(ref enum_def, _) if allow_dead_code => {\n-                self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+                self.worklist.extend(enum_def.variants.iter()\n+                                                      .map(|variant| variant.node.data.id()));\n             }\n             hir::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n@@ -426,7 +427,9 @@ fn find_live(tcx: &ty::ctxt,\n \n fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        hir::ItemStruct(ref struct_def, _) => struct_def.ctor_id,\n+        hir::ItemStruct(ref struct_def, _) if !struct_def.is_struct() => {\n+            Some(struct_def.id())\n+        }\n         _ => None\n     }\n }\n@@ -464,7 +467,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::Variant_) -> bool {\n-        !self.symbol_is_live(variant.id, None)\n+        !self.symbol_is_live(variant.data.id(), None)\n             && !has_allow_dead_code_or_lang_attr(&variant.attrs)\n     }\n \n@@ -540,7 +543,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                 hir::ItemEnum(ref enum_def, _) => {\n                     for variant in &enum_def.variants {\n                         if self.should_warn_about_variant(&variant.node) {\n-                            self.warn_dead_code(variant.node.id, variant.span,\n+                            self.warn_dead_code(variant.node.data.id(), variant.span,\n                                                 variant.node.name, \"variant\");\n                         }\n                     }"}, {"sha": "ef2b918a9f5d7ea449f5e8df4d4d87a947822a85", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -44,13 +44,13 @@ pub enum Def {\n              ast::NodeId), // expr node that creates the closure\n \n     /// Note that if it's a tuple struct's definition, the node id of the DefId\n-    /// may either refer to the item definition's id or the StructDef.ctor_id.\n+    /// may either refer to the item definition's id or the VariantData.ctor_id.\n     ///\n     /// The cases that I have encountered so far are (this is not exhaustive):\n     /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n     ///   it to a def whose id is the item definition's id.\n     /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the StructDef.ctor_id.\n+    ///   it to a def whose id is the VariantData.ctor_id.\n     DefStruct(DefId),\n     DefLabel(ast::NodeId),\n     DefMethod(DefId),"}, {"sha": "af295c3e584b04310fe160b6657d298fd3eba0bd", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -185,9 +185,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n                       |v| visit::walk_item(v, i), required);\n \n         if let hir::ItemStruct(ref sd, _) = i.node {\n-            sd.ctor_id.map(|id| {\n-                self.annotate(id, true, &i.attrs, i.span, |_| {}, true)\n-            });\n+            if !sd.is_struct() {\n+                self.annotate(sd.id(), true, &i.attrs, i.span, |_| {}, true)\n+            }\n         }\n     }\n \n@@ -207,9 +207,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n                       |v| visit::walk_impl_item(v, ii), true);\n     }\n \n-    fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n-        self.annotate(var.node.id, true, &var.node.attrs, var.span,\n-                      |v| visit::walk_variant(v, var, g), true)\n+    fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n+        self.annotate(var.node.data.id(), true, &var.node.attrs, var.span,\n+                      |v| visit::walk_variant(v, var, g, item_id), true)\n     }\n \n     fn visit_struct_field(&mut self, s: &StructField) {"}, {"sha": "975a5adad2bd21a3f23624829a84cf23e2f3c2ad", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -1533,7 +1533,7 @@ impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n pub enum AdtKind { Struct, Enum }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum VariantKind { Dict, Tuple, Unit }\n+pub enum VariantKind { Struct, Tuple, Unit }\n \n impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     fn new(tcx: &ctxt<'tcx>,\n@@ -1716,7 +1716,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n             Some(&FieldDefData { name, .. }) if name == special_idents::unnamed_field.name => {\n                 VariantKind::Tuple\n             }\n-            Some(_) => VariantKind::Dict\n+            Some(_) => VariantKind::Struct\n         }\n     }\n "}, {"sha": "a9cfc7138d8d967808aa44183e7d833035c9b52c", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -301,18 +301,18 @@ mod svh_visitor {\n     }\n \n     impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n-        fn visit_struct_def(&mut self, s: &StructDef, name: Name,\n-                            g: &Generics, _: NodeId) {\n+        fn visit_variant_data(&mut self, s: &VariantData, name: Name,\n+                            g: &Generics, _: NodeId, _: Span) {\n             SawStructDef(name.as_str()).hash(self.st);\n             visit::walk_generics(self, g);\n             visit::walk_struct_def(self, s)\n         }\n \n-        fn visit_variant(&mut self, v: &Variant, g: &Generics) {\n+        fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n             SawVariant.hash(self.st);\n             // walk_variant does not call walk_generics, so do it here.\n             visit::walk_generics(self, g);\n-            visit::walk_variant(self, v, g)\n+            visit::walk_variant(self, v, g, item_id)\n         }\n \n         // All of the remaining methods just record (in the hash"}, {"sha": "dafca7188d5adc7b7b7d88f77b0a43c228b76b2d", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -223,7 +223,7 @@ pub trait Folder : Sized {\n         noop_fold_poly_trait_ref(p, self)\n     }\n \n-    fn fold_struct_def(&mut self, struct_def: P<StructDef>) -> P<StructDef> {\n+    fn fold_variant_data(&mut self, struct_def: P<VariantData>) -> P<VariantData> {\n         noop_fold_struct_def(struct_def, self)\n     }\n \n@@ -247,10 +247,6 @@ pub trait Folder : Sized {\n         noop_fold_opt_lifetime(o_lt, self)\n     }\n \n-    fn fold_variant_arg(&mut self, va: VariantArg) -> VariantArg {\n-        noop_fold_variant_arg(va, self)\n-    }\n-\n     fn fold_opt_bounds(&mut self,\n                        b: Option<OwnedSlice<TyParamBound>>)\n                        -> Option<OwnedSlice<TyParamBound>> {\n@@ -435,24 +431,14 @@ pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod { abi, items }: ForeignMod,\n }\n \n pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n-    v.map(|Spanned { node: Variant_ { id, name, attrs, kind, disr_expr }, span }| {\n-        Spanned {\n-            node: Variant_ {\n-                id: fld.new_id(id),\n-                name: name,\n-                attrs: fold_attrs(attrs, fld),\n-                kind: match kind {\n-                    TupleVariantKind(variant_args) => {\n-                        TupleVariantKind(variant_args.move_map(|x| fld.fold_variant_arg(x)))\n-                    }\n-                    StructVariantKind(struct_def) => {\n-                        StructVariantKind(fld.fold_struct_def(struct_def))\n-                    }\n-                },\n-                disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n-            },\n-            span: fld.new_span(span),\n-        }\n+    v.map(|Spanned {node: Variant_ {name, attrs, data, disr_expr}, span}| Spanned {\n+        node: Variant_ {\n+            name: name,\n+            attrs: fold_attrs(attrs, fld),\n+            data: fld.fold_variant_data(data),\n+            disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n+        },\n+        span: fld.new_span(span),\n     })\n }\n \n@@ -707,11 +693,16 @@ pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -\n     }\n }\n \n-pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n-    struct_def.map(|StructDef { fields, ctor_id }| {\n-        StructDef {\n-            fields: fields.move_map(|f| fld.fold_struct_field(f)),\n-            ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n+pub fn noop_fold_struct_def<T: Folder>(struct_def: P<VariantData>, fld: &mut T) -> P<VariantData> {\n+    struct_def.map(|vdata| {\n+        match vdata {\n+            VariantData::Struct(fields, id) => {\n+                VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n+            }\n+            VariantData::Tuple(fields, id) => {\n+                VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n+            }\n+            VariantData::Unit(id) => VariantData::Unit(fld.new_id(id))\n         }\n     })\n }\n@@ -775,15 +766,6 @@ fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T) -> TyParam\n     bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n }\n \n-fn noop_fold_variant_arg<T: Folder>(VariantArg { id, ty }: VariantArg,\n-                                    folder: &mut T)\n-                                    -> VariantArg {\n-    VariantArg {\n-        id: folder.new_id(id),\n-        ty: folder.fold_ty(ty),\n-    }\n-}\n-\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block { id, stmts, expr, rules, span }| {\n         Block {\n@@ -828,7 +810,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                      folder.fold_generics(generics))\n         }\n         ItemStruct(struct_def, generics) => {\n-            let struct_def = folder.fold_struct_def(struct_def);\n+            let struct_def = folder.fold_variant_data(struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {"}, {"sha": "e62eadaa4387dd962418d043c4ecbae4a58d3e73", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -33,7 +33,6 @@ pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n-pub use self::VariantKind::*;\n pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n@@ -50,6 +49,7 @@ use print::pprust;\n use util;\n \n use std::fmt;\n+use std::{iter, option, slice};\n use serialize::{Encodable, Encoder, Decoder};\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n@@ -1015,20 +1015,6 @@ pub struct ForeignMod {\n     pub items: Vec<P<ForeignItem>>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct VariantArg {\n-    pub ty: P<Ty>,\n-    pub id: NodeId,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum VariantKind {\n-    /// Tuple variant, e.g. `Foo(A, B)`\n-    TupleVariantKind(Vec<VariantArg>),\n-    /// Struct variant, e.g. `Foo {x: A, y: B}`\n-    StructVariantKind(P<StructDef>),\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<P<Variant>>,\n@@ -1038,8 +1024,7 @@ pub struct EnumDef {\n pub struct Variant_ {\n     pub name: Name,\n     pub attrs: Vec<Attribute>,\n-    pub kind: VariantKind,\n-    pub id: NodeId,\n+    pub data: P<VariantData>,\n     /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<P<Expr>>,\n }\n@@ -1176,13 +1161,50 @@ impl StructFieldKind {\n     }\n }\n \n+/// Fields and Ids of enum variants and structs\n+///\n+/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n+/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n+/// One shared Id can be successfully used for these two purposes.\n+/// Id of the whole enum lives in `Item`.\n+///\n+/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n+/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n+/// the variant itself\" from enum variants.\n+/// Id of the whole struct lives in `Item`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct StructDef {\n-    /// Fields, not including ctor\n-    pub fields: Vec<StructField>,\n-    /// ID of the constructor. This is only used for tuple- or enum-like\n-    /// structs.\n-    pub ctor_id: Option<NodeId>,\n+pub enum VariantData {\n+    Struct(Vec<StructField>, NodeId),\n+    Tuple(Vec<StructField>, NodeId),\n+    Unit(NodeId),\n+}\n+\n+pub type FieldIter<'a> = iter::FlatMap<option::IntoIter<&'a Vec<StructField>>,\n+                                       slice::Iter<'a, StructField>,\n+                                       fn(&Vec<StructField>) -> slice::Iter<StructField>>;\n+\n+impl VariantData {\n+    pub fn fields(&self) -> FieldIter {\n+        fn vec_iter<T>(v: &Vec<T>) -> slice::Iter<T> { v.iter() }\n+        match *self {\n+            VariantData::Struct(ref fields, _) | VariantData::Tuple(ref fields, _) => Some(fields),\n+            _ => None,\n+        }.into_iter().flat_map(vec_iter)\n+    }\n+    pub fn id(&self) -> NodeId {\n+        match *self {\n+            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id\n+        }\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData::Struct(..) = *self { true } else { false }\n+    }\n+    pub fn is_tuple(&self) -> bool {\n+        if let VariantData::Tuple(..) = *self { true } else { false }\n+    }\n+    pub fn is_unit(&self) -> bool {\n+        if let VariantData::Unit(..) = *self { true } else { false }\n+    }\n }\n \n /*\n@@ -1226,7 +1248,7 @@ pub enum Item_ {\n     /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n     ItemEnum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n-    ItemStruct(P<StructDef>, Generics),\n+    ItemStruct(P<VariantData>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Unsafety, Generics, TyParamBounds, Vec<P<TraitItem>>),\n "}, {"sha": "890896eb1c5aafbeb84d3c38097a0217a4c60c92", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -264,19 +264,9 @@ pub fn lower_foreign_mod(_lctx: &LoweringContext, fm: &ForeignMod) -> hir::Forei\n pub fn lower_variant(_lctx: &LoweringContext, v: &Variant) -> P<hir::Variant> {\n     P(Spanned {\n         node: hir::Variant_ {\n-            id: v.node.id,\n             name: v.node.name.name,\n             attrs: v.node.attrs.clone(),\n-            kind: match v.node.kind {\n-                TupleVariantKind(ref variant_args) => {\n-                    hir::TupleVariantKind(variant_args.iter()\n-                                                      .map(|ref x| lower_variant_arg(_lctx, x))\n-                                                      .collect())\n-                }\n-                StructVariantKind(ref struct_def) => {\n-                    hir::StructVariantKind(lower_struct_def(_lctx, struct_def))\n-                }\n-            },\n+            data: lower_struct_def(_lctx, &v.node.data),\n             disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(_lctx, e)),\n         },\n         span: v.span,\n@@ -508,10 +498,17 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n     }\n }\n \n-pub fn lower_struct_def(_lctx: &LoweringContext, sd: &StructDef) -> P<hir::StructDef> {\n-    P(hir::StructDef {\n-        fields: sd.fields.iter().map(|f| lower_struct_field(_lctx, f)).collect(),\n-        ctor_id: sd.ctor_id,\n+pub fn lower_struct_def(_lctx: &LoweringContext, sd: &VariantData) -> P<hir::VariantData> {\n+    P(match *sd {\n+        VariantData::Struct(ref fields, id) => {\n+            hir::VariantData::Struct(fields.iter()\n+                                           .map(|f| lower_struct_field(_lctx, f)).collect(), id)\n+        }\n+        VariantData::Tuple(ref fields, id) => {\n+            hir::VariantData::Tuple(fields.iter()\n+                                          .map(|f| lower_struct_field(_lctx, f)).collect(), id)\n+        }\n+        VariantData::Unit(id) => hir::VariantData::Unit(id)\n     })\n }\n \n@@ -567,13 +564,6 @@ fn lower_bounds(_lctx: &LoweringContext, bounds: &TyParamBounds) -> hir::TyParam\n     bounds.iter().map(|bound| lower_ty_param_bound(_lctx, bound)).collect()\n }\n \n-fn lower_variant_arg(_lctx: &LoweringContext, va: &VariantArg) -> hir::VariantArg {\n-    hir::VariantArg {\n-        id: va.id,\n-        ty: lower_ty(_lctx, &va.ty),\n-    }\n-}\n-\n pub fn lower_block(_lctx: &LoweringContext, b: &Block) -> P<hir::Block> {\n     P(hir::Block {\n         id: b.id,"}, {"sha": "5e78aa5fbc1f8cf66e9af66bdeb41c826b073815", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -734,7 +734,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemStruct(ref struct_def, ref generics) => {\n                 try!(self.head(&visibility_qualified(item.vis, \"struct\")));\n-                try!(self.print_struct(&**struct_def, generics, item.name, item.span));\n+                try!(self.print_struct(&**struct_def, generics, item.name, item.span, true));\n             }\n \n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n@@ -888,18 +888,19 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_struct(&mut self,\n-                        struct_def: &hir::StructDef,\n+                        struct_def: &hir::VariantData,\n                         generics: &hir::Generics,\n                         name: ast::Name,\n-                        span: codemap::Span)\n+                        span: codemap::Span,\n+                        print_finalizer: bool)\n                         -> io::Result<()> {\n         try!(self.print_name(name));\n         try!(self.print_generics(generics));\n-        if ::util::struct_def_is_tuple_like(struct_def) {\n-            if !struct_def.fields.is_empty() {\n+        if !struct_def.is_struct() {\n+            if struct_def.is_tuple() {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent,\n-                                   &struct_def.fields,\n+                try!(self.commasep_iter(Inconsistent,\n+                                   struct_def.fields(),\n                                    |s, field| {\n                                        match field.node.kind {\n                                            hir::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -913,7 +914,9 @@ impl<'a> State<'a> {\n                 try!(self.pclose());\n             }\n             try!(self.print_where_clause(&generics.where_clause));\n-            try!(word(&mut self.s, \";\"));\n+            if print_finalizer {\n+                try!(word(&mut self.s, \";\"));\n+            }\n             try!(self.end());\n             self.end() // close the outer-box\n         } else {\n@@ -922,7 +925,7 @@ impl<'a> State<'a> {\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());\n \n-            for field in &struct_def.fields {\n+            for field in struct_def.fields() {\n                 match field.node.kind {\n                     hir::UnnamedField(..) => panic!(\"unexpected unnamed field\"),\n                     hir::NamedField(name, visibility) => {\n@@ -943,21 +946,9 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_variant(&mut self, v: &hir::Variant) -> io::Result<()> {\n-        match v.node.kind {\n-            hir::TupleVariantKind(ref args) => {\n-                try!(self.print_name(v.node.name));\n-                if !args.is_empty() {\n-                    try!(self.popen());\n-                    try!(self.commasep(Consistent, &args[..], |s, arg| s.print_type(&*arg.ty)));\n-                    try!(self.pclose());\n-                }\n-            }\n-            hir::StructVariantKind(ref struct_def) => {\n-                try!(self.head(\"\"));\n-                let generics = ::util::empty_generics();\n-                try!(self.print_struct(&**struct_def, &generics, v.node.name, v.span));\n-            }\n-        }\n+        try!(self.head(\"\"));\n+        let generics = ::util::empty_generics();\n+        try!(self.print_struct(&v.node.data, &generics, v.node.name, v.span, false));\n         match v.node.disr_expr {\n             Some(ref d) => {\n                 try!(space(&mut self.s));"}, {"sha": "5d8973ead47db27a1ddea1bc4a8128d9c7834b01", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -81,12 +81,6 @@ pub fn binop_to_string(op: BinOp_) -> &'static str {\n     }\n }\n \n-/// Returns true if the given struct def is tuple-like; i.e. that its fields\n-/// are unnamed.\n-pub fn struct_def_is_tuple_like(struct_def: &hir::StructDef) -> bool {\n-    struct_def.ctor_id.is_some()\n-}\n-\n pub fn stmt_id(s: &Stmt) -> NodeId {\n     match s.node {\n         StmtDecl(_, id) => id,\n@@ -200,11 +194,6 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n                     }\n                 }\n             }\n-            ItemEnum(ref enum_definition, _) => {\n-                for variant in &enum_definition.variants {\n-                    self.operation.visit_id(variant.node.id)\n-                }\n-            }\n             _ => {}\n         }\n \n@@ -292,13 +281,13 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n         visit::walk_struct_field(self, struct_field)\n     }\n \n-    fn visit_struct_def(&mut self,\n-                        struct_def: &StructDef,\n+    fn visit_variant_data(&mut self,\n+                        struct_def: &VariantData,\n                         _: Name,\n                         _: &hir::Generics,\n-                        id: NodeId) {\n-        self.operation.visit_id(id);\n-        struct_def.ctor_id.map(|ctor_id| self.operation.visit_id(ctor_id));\n+                        _: NodeId,\n+                        _: Span) {\n+        self.operation.visit_id(struct_def.id());\n         visit::walk_struct_def(self, struct_def);\n     }\n "}, {"sha": "00c2c3a3ddd65e1aca2561156be1639cef087d6c", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -112,20 +112,20 @@ pub trait Visitor<'v> : Sized {\n     fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_struct_def(&mut self, s: &'v StructDef, _: Name, _: &'v Generics, _: NodeId) {\n+    fn visit_variant_data(&mut self, s: &'v VariantData, _: Name,\n+                        _: &'v Generics, _: NodeId, _: Span) {\n         walk_struct_def(self, s)\n     }\n     fn visit_struct_field(&mut self, s: &'v StructField) {\n         walk_struct_field(self, s)\n     }\n-    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef, generics: &'v Generics) {\n-        walk_enum_def(self, enum_definition, generics)\n+    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n+                      generics: &'v Generics, item_id: NodeId) {\n+        walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) {\n-        walk_variant(self, v, g)\n+    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n+        walk_variant(self, v, g, item_id)\n     }\n-\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n@@ -293,7 +293,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n-            visitor.visit_enum_def(enum_definition, type_parameters)\n+            visitor.visit_enum_def(enum_definition, type_parameters, item.id)\n         }\n         ItemDefaultImpl(_, ref trait_ref) => {\n             visitor.visit_trait_ref(trait_ref)\n@@ -310,7 +310,8 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_struct_def(struct_definition, item.name, generics, item.id)\n+            visitor.visit_variant_data(struct_definition, item.name,\n+                                     generics, item.id, item.span);\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n@@ -323,30 +324,20 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n-                                         generics: &'v Generics) {\n+                                         generics: &'v Generics,\n+                                         item_id: NodeId) {\n     for variant in &enum_definition.variants {\n-        visitor.visit_variant(variant, generics);\n+        visitor.visit_variant(variant, generics, item_id);\n     }\n }\n \n pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n-                                        generics: &'v Generics) {\n+                                        generics: &'v Generics,\n+                                        item_id: NodeId) {\n     visitor.visit_name(variant.span, variant.node.name);\n-\n-    match variant.node.kind {\n-        TupleVariantKind(ref variant_arguments) => {\n-            for variant_argument in variant_arguments {\n-                visitor.visit_ty(&variant_argument.ty)\n-            }\n-        }\n-        StructVariantKind(ref struct_definition) => {\n-            visitor.visit_struct_def(struct_definition,\n-                                     variant.node.name,\n-                                     generics,\n-                                     variant.node.id)\n-        }\n-    }\n+    visitor.visit_variant_data(&variant.node.data, variant.node.name,\n+                             generics, item_id, variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n@@ -637,8 +628,8 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     }\n }\n \n-pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v StructDef) {\n-    walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n+pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n+    walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {"}, {"sha": "693de1740bfee9fdee03e7f453ef361ba40dc583", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -280,9 +280,9 @@ impl LateLintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n+    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::VariantData,\n                         _: ast::Name, _: &hir::Generics, _: ast::NodeId) {\n-        for sf in &s.fields {\n+        for sf in s.fields() {\n             if let hir::StructField_ { kind: hir::NamedField(name, _), .. } = sf.node {\n                 self.check_snake_case(cx, \"structure field\", &name.as_str(),\n                                       Some(sf.span));"}, {"sha": "f5a58656080db785f1fd276c677905637093d826", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -123,7 +123,7 @@ impl LateLintPass for BoxPointers {\n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             hir::ItemStruct(ref struct_def, _) => {\n-                for struct_field in &struct_def.fields {\n+                for struct_field in struct_def.fields() {\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.node_id_to_type(struct_field.node.id));\n                 }\n@@ -427,15 +427,15 @@ impl LateLintPass for MissingDoc {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &LateContext, _: &hir::StructDef,\n-                        _: ast::Name, _: &hir::Generics, id: ast::NodeId) {\n-        self.struct_def_stack.push(id);\n+    fn check_struct_def(&mut self, _: &LateContext, _: &hir::VariantData,\n+                        _: ast::Name, _: &hir::Generics, item_id: ast::NodeId) {\n+        self.struct_def_stack.push(item_id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &LateContext, _: &hir::StructDef,\n-                             _: ast::Name, _: &hir::Generics, id: ast::NodeId) {\n+    fn check_struct_def_post(&mut self, _: &LateContext, _: &hir::VariantData,\n+                             _: ast::Name, _: &hir::Generics, item_id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n-        assert!(popped == id);\n+        assert!(popped == item_id);\n     }\n \n     fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n@@ -527,7 +527,8 @@ impl LateLintPass for MissingDoc {\n     }\n \n     fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs, v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx, Some(v.node.data.id()),\n+                                      &v.node.attrs, v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }"}, {"sha": "608558ac2bdb9e6a7005192246d590cf2d4aa147", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -82,7 +82,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n                     // The parent is considered the enclosing enum because the\n                     // enum will dictate the privacy visibility of this variant\n                     // instead.\n-                    self.parents.insert(variant.node.id, item.id);\n+                    self.parents.insert(variant.node.data.id(), item.id);\n                 }\n             }\n \n@@ -128,18 +128,17 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_struct_def(&mut self, s: &hir::StructDef, _: ast::Name,\n-                        _: &'v hir::Generics, n: ast::NodeId) {\n+    fn visit_variant_data(&mut self, s: &hir::VariantData, _: ast::Name,\n+                        _: &'v hir::Generics, item_id: ast::NodeId, _: Span) {\n         // Struct constructors are parented to their struct definitions because\n         // they essentially are the struct definitions.\n-        match s.ctor_id {\n-            Some(id) => { self.parents.insert(id, n); }\n-            None => {}\n+        if !s.is_struct() {\n+            self.parents.insert(s.id(), item_id);\n         }\n \n         // While we have the id of the struct definition, go ahead and parent\n         // all the fields.\n-        for field in &s.fields {\n+        for field in s.fields() {\n             self.parents.insert(field.node.id, self.curparent);\n         }\n         visit::walk_struct_def(self, s)\n@@ -234,8 +233,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // public all variants are public unless they're explicitly priv\n             hir::ItemEnum(ref def, _) if public_first => {\n                 for variant in &def.variants {\n-                    self.exported_items.insert(variant.node.id);\n-                    self.public_items.insert(variant.node.id);\n+                    self.exported_items.insert(variant.node.data.id());\n+                    self.public_items.insert(variant.node.data.id());\n                 }\n             }\n \n@@ -320,12 +319,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             // Struct constructors are public if the struct is all public.\n             hir::ItemStruct(ref def, _) if public_first => {\n-                match def.ctor_id {\n-                    Some(id) => { self.exported_items.insert(id); }\n-                    None => {}\n+                if !def.is_struct() {\n+                    self.exported_items.insert(def.id());\n                 }\n                 // fields can be public or private, so lets check\n-                for field in &def.fields {\n+                for field in def.fields() {\n                     let vis = match field.node.kind {\n                         hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n                     };\n@@ -1090,8 +1088,8 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                           \"visibility has no effect inside functions\");\n             }\n         }\n-        let check_struct = |def: &hir::StructDef| {\n-            for f in &def.fields {\n+        let check_struct = |def: &hir::VariantData| {\n+            for f in def.fields() {\n                match f.node.kind {\n                     hir::NamedField(_, p) => check_inherited(tcx, f.span, p),\n                     hir::UnnamedField(..) => {}\n@@ -1432,20 +1430,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         visit::walk_ty(self, t)\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics) {\n-        if self.exported_items.contains(&v.node.id) {\n+    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+        if self.exported_items.contains(&v.node.data.id()) {\n             self.in_variant = true;\n-            visit::walk_variant(self, v, g);\n+            visit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n         }\n     }\n \n     fn visit_struct_field(&mut self, s: &hir::StructField) {\n-        match s.node.kind {\n-            hir::NamedField(_, vis) if vis == hir::Public || self.in_variant => {\n-                visit::walk_struct_field(self, s);\n-            }\n-            _ => {}\n+        let vis = match s.node.kind {\n+            hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n+        };\n+        if vis == hir::Public || self.in_variant {\n+            visit::walk_struct_field(self, s);\n         }\n     }\n "}, {"sha": "c051f8c263723916ede63359efcb5a17f644b067", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -49,8 +49,6 @@ use rustc_front::hir::{ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaul\n use rustc_front::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use rustc_front::hir::{NamedField, PathListIdent, PathListMod, Public};\n use rustc_front::hir::StmtDecl;\n-use rustc_front::hir::StructVariantKind;\n-use rustc_front::hir::TupleVariantKind;\n use rustc_front::hir::UnnamedField;\n use rustc_front::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use rustc_front::hir::Visibility;\n@@ -494,9 +492,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             // These items live in both the type and value namespaces.\n             ItemStruct(ref struct_def, _) => {\n                 // Adding to both Type and Value namespaces or just Type?\n-                let (forbid, ctor_id) = match struct_def.ctor_id {\n-                    Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n-                    None            => (ForbidDuplicateTypesAndModules, None)\n+                let (forbid, ctor_id) = if struct_def.is_struct() {\n+                    (ForbidDuplicateTypesAndModules, None)\n+                } else {\n+                    (ForbidDuplicateTypesAndValues, Some(struct_def.id()))\n                 };\n \n                 let name_bindings = self.add_child(name, parent, forbid, sp);\n@@ -515,7 +514,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n \n                 // Record the def ID and fields of this struct.\n-                let named_fields = struct_def.fields.iter().filter_map(|f| {\n+                let named_fields = struct_def.fields().filter_map(|f| {\n                     match f.node.kind {\n                         NamedField(name, _) => Some(name),\n                         UnnamedField(_) => None\n@@ -589,14 +588,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                        item_id: DefId,\n                                        parent: &Rc<Module>) {\n         let name = variant.node.name;\n-        let is_exported = match variant.node.kind {\n-            TupleVariantKind(_) => false,\n-            StructVariantKind(_) => {\n-                // Not adding fields for variants as they are not accessed with a self receiver\n-                let variant_def_id = self.ast_map.local_def_id(variant.node.id);\n-                self.structs.insert(variant_def_id, Vec::new());\n-                true\n-            }\n+        let is_exported = if variant.node.data.is_struct() {\n+            // Not adding fields for variants as they are not accessed with a self receiver\n+            let variant_def_id = self.ast_map.local_def_id(variant.node.data.id());\n+            self.structs.insert(variant_def_id, Vec::new());\n+            true\n+        } else {\n+            false\n         };\n \n         let child = self.add_child(name, parent,\n@@ -605,10 +603,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // variants are always treated as importable to allow them to be glob\n         // used\n         child.define_value(DefVariant(item_id,\n-                                      self.ast_map.local_def_id(variant.node.id), is_exported),\n+                                      self.ast_map.local_def_id(variant.node.data.id()),\n+                                      is_exported),\n                            variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n-                                     self.ast_map.local_def_id(variant.node.id), is_exported),\n+                                     self.ast_map.local_def_id(variant.node.data.id()),\n+                                     is_exported),\n                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n "}, {"sha": "ac09534f1e0e5eecff77883b9fd23f2a2f8b7a0d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -491,7 +491,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         }\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n-    fn visit_variant(&mut self, variant: &hir::Variant, generics: &Generics) {\n+    fn visit_variant(&mut self, variant: &hir::Variant, generics: &Generics, item_id: ast::NodeId) {\n         execute_callback!(hir_map::Node::NodeVariant(variant), self);\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n@@ -501,19 +501,8 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         }\n \n         // `visit::walk_variant` without the discriminant expression.\n-        match variant.node.kind {\n-            hir::TupleVariantKind(ref variant_arguments) => {\n-                for variant_argument in variant_arguments {\n-                    self.visit_ty(&*variant_argument.ty);\n-                }\n-            }\n-            hir::StructVariantKind(ref struct_definition) => {\n-                self.visit_struct_def(&**struct_definition,\n-                                      variant.node.name,\n-                                      generics,\n-                                      variant.node.id);\n-            }\n-        }\n+        self.visit_variant_data(&variant.node.data, variant.node.name,\n+                              generics, item_id, variant.span);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem) {\n         execute_callback!(hir_map::Node::NodeForeignItem(foreign_item), self);"}, {"sha": "146fa857fc8504e05648767b1424a03d1ae486b4", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 16, "deletions": 41, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -458,26 +458,22 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     fn process_struct(&mut self,\n                       item: &ast::Item,\n-                      def: &ast::StructDef,\n+                      def: &ast::VariantData,\n                       ty_params: &ast::Generics) {\n         let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n-        let ctor_id = match def.ctor_id {\n-            Some(node_id) => node_id,\n-            None => ast::DUMMY_NODE_ID,\n-        };\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n         self.fmt.struct_str(item.span,\n                             sub_span,\n                             item.id,\n-                            ctor_id,\n+                            def.id(),\n                             &qualname,\n                             self.cur_scope,\n                             &val);\n \n         // fields\n-        for field in &def.fields {\n+        for field in def.fields() {\n             self.process_struct_field_def(field, item.id);\n             self.visit_ty(&field.node.ty);\n         }\n@@ -504,40 +500,19 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             qualname.push_str(\"::\");\n             qualname.push_str(name);\n             let val = self.span.snippet(variant.span);\n-            match variant.node.kind {\n-                ast::TupleVariantKind(ref args) => {\n-                    // first ident in span is the variant's name\n-                    self.fmt.tuple_variant_str(variant.span,\n-                                               self.span.span_for_first_ident(variant.span),\n-                                               variant.node.id,\n-                                               name,\n-                                               &qualname,\n-                                               &enum_data.qualname,\n-                                               &val,\n-                                               enum_data.id);\n-                    for arg in args {\n-                        self.visit_ty(&*arg.ty);\n-                    }\n-                }\n-                ast::StructVariantKind(ref struct_def) => {\n-                    let ctor_id = match struct_def.ctor_id {\n-                        Some(node_id) => node_id,\n-                        None => ast::DUMMY_NODE_ID,\n-                    };\n-                    self.fmt.struct_variant_str(variant.span,\n-                                                self.span.span_for_first_ident(variant.span),\n-                                                variant.node.id,\n-                                                ctor_id,\n-                                                &qualname,\n-                                                &enum_data.qualname,\n-                                                &val,\n-                                                enum_data.id);\n-\n-                    for field in &struct_def.fields {\n-                        self.process_struct_field_def(field, variant.node.id);\n-                        self.visit_ty(&*field.node.ty);\n-                    }\n-                }\n+\n+            self.fmt.struct_variant_str(variant.span,\n+                                        self.span.span_for_first_ident(variant.span),\n+                                        variant.node.data.id(),\n+                                        variant.node.data.id(),\n+                                        &qualname,\n+                                        &enum_data.qualname,\n+                                        &val,\n+                                        enum_data.id);\n+\n+            for field in variant.node.data.fields() {\n+                self.process_struct_field_def(field, variant.node.data.id());\n+                self.visit_ty(&*field.node.ty);\n             }\n         }\n         self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);"}, {"sha": "9fa1aaf76f819dc5fcd1d31c42c954a9ff874e69", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -2428,13 +2428,12 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         hir_map::NodeVariant(ref v) => {\n             let llfn;\n-            let args = match v.node.kind {\n-                hir::TupleVariantKind(ref args) => args,\n-                hir::StructVariantKind(_) => {\n-                    ccx.sess().bug(\"struct variant kind unexpected in get_item_val\")\n-                }\n+            let fields = if v.node.data.is_struct() {\n+                ccx.sess().bug(\"struct variant kind unexpected in get_item_val\")\n+            } else {\n+                v.node.data.fields()\n             };\n-            assert!(!args.is_empty());\n+            assert!(fields.count() != 0);\n             let ty = ccx.tcx().node_id_to_type(id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);\n@@ -2455,12 +2454,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         hir_map::NodeStructCtor(struct_def) => {\n             // Only register the constructor if this is a tuple-like struct.\n-            let ctor_id = match struct_def.ctor_id {\n-                None => {\n-                    ccx.sess().bug(\"attempt to register a constructor of \\\n-                                    a non-tuple-like struct\")\n-                }\n-                Some(ctor_id) => ctor_id,\n+            let ctor_id = if struct_def.is_struct() {\n+                ccx.sess().bug(\"attempt to register a constructor of \\\n+                                  a non-tuple-like struct\")\n+            } else {\n+                struct_def.id()\n             };\n             let parent = ccx.tcx().map.get_parent(id);\n             let struct_item = ccx.tcx().map.expect_item(parent);"}, {"sha": "c8525e33e2667e6f22619c784cf422f97dd97ace", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -417,10 +417,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             || \"local item should be in ast map\".to_string());\n \n         match map_node {\n-            hir_map::NodeVariant(v) => match v.node.kind {\n-                hir::TupleVariantKind(ref args) => !args.is_empty(),\n-                _ => false\n-            },\n+            hir_map::NodeVariant(v) => {\n+                v.node.data.is_tuple()\n+            }\n             hir_map::NodeStructCtor(_) => true,\n             _ => false\n         }"}, {"sha": "7c72b249a6e81afa5f95181d8760cc74ec84389e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -818,7 +818,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         ty::VariantKind::Tuple => {\n                             expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                         }\n-                        ty::VariantKind::Dict => {\n+                        ty::VariantKind::Struct => {\n                             cx.sess().span_bug(e.span, \"path-expr refers to a dict variant!\")\n                         }\n                     }"}, {"sha": "aeda8f723cfeea3c7961b208b591bd10428fe78c", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -1365,7 +1365,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.kind() {\n                         ty::VariantKind::Tuple => \"__0\".to_string(),\n-                        ty::VariantKind::Dict => {\n+                        ty::VariantKind::Struct => {\n                             non_null_variant.fields[0].name.to_string()\n                         }\n                         ty::VariantKind::Unit => unreachable!()\n@@ -1540,7 +1540,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                    .map(|(i, _)| format!(\"__{}\", i))\n                    .collect()\n         }\n-        ty::VariantKind::Dict => {\n+        ty::VariantKind::Struct => {\n             variant.fields\n                    .iter()\n                    .map(|f| f.name.to_string())"}, {"sha": "14e1ca7675f790f9981089818017478ff4a362eb", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -110,18 +110,17 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n                     let ty_vs = &ccx.tcx().lookup_adt_def(parent_id).variants;\n                     assert_eq!(ast_vs.len(), ty_vs.len());\n                     for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n-                        if ty_v.did == fn_id { my_id = ast_v.node.id; }\n-                        ccx.external().borrow_mut().insert(ty_v.did, Some(ast_v.node.id));\n+                        if ty_v.did == fn_id { my_id = ast_v.node.data.id(); }\n+                        ccx.external().borrow_mut().insert(ty_v.did, Some(ast_v.node.data.id()));\n                     }\n                 }\n                 hir::ItemStruct(ref struct_def, _) => {\n-                    match struct_def.ctor_id {\n-                        None => ccx.sess().bug(\"instantiate_inline: called on a \\\n-                                                non-tuple struct\"),\n-                        Some(ctor_id) => {\n-                            ccx.external().borrow_mut().insert(fn_id, Some(ctor_id));\n-                            my_id = ctor_id;\n-                        }\n+                    if struct_def.is_struct() {\n+                        ccx.sess().bug(\"instantiate_inline: called on a \\\n+                                                                 non-tuple struct\")\n+                    } else {\n+                        ccx.external().borrow_mut().insert(fn_id, Some(struct_def.id()));\n+                        my_id = struct_def.id();\n                     }\n                 }\n                 _ => ccx.sess().bug(\"instantiate_inline: item has a \\"}, {"sha": "f84f0feb9603020e139ed75e6b6e3299b2b63884", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -246,9 +246,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         hir_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n+            if struct_def.is_struct() {\n+                panic!(\"ast-mapped struct didn't have a ctor id\")\n+            }\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n-                                                                didn't have a ctor id\"),\n+                                     struct_def.id(),\n                                      psubsts,\n                                      d);\n             d"}, {"sha": "db5dd19c9236c68013dacca90f87cb61f2c545df", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -530,7 +530,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx hir::Pat,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let variant = match fcx.def_struct_variant(def) {\n+    let variant = match fcx.def_struct_variant(def, path.span) {\n         Some((_, variant)) => variant,\n         None => {\n             let name = pprust::path_to_string(path);"}, {"sha": "ba1af220d8e0fb915d062864a577fd210be77eb9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -1464,7 +1464,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Return the dict-like variant corresponding to a given `Def`.\n     pub fn def_struct_variant(&self,\n-                              def: def::Def)\n+                              def: def::Def,\n+                              span: Span)\n                               -> Option<(ty::AdtDef<'tcx>, ty::VariantDef<'tcx>)>\n     {\n         let (adt, variant) = match def {\n@@ -1484,11 +1485,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let var_kind = variant.kind();\n-        if var_kind == ty::VariantKind::Dict || var_kind == ty::VariantKind::Unit {\n+        if var_kind == ty::VariantKind::Struct {\n             Some((adt, variant))\n-        } else {\n-            None\n-        }\n+        } else if var_kind == ty::VariantKind::Unit {\n+            if !self.tcx().sess.features.borrow().braced_empty_structs {\n+                self.tcx().sess.span_err(span, \"empty structs and enum variants \\\n+                                                with braces are unstable\");\n+                fileline_help!(self.tcx().sess, span, \"add #![feature(braced_empty_structs)] to \\\n+                                                       the crate features to enable\");\n+            }\n+\n+             Some((adt, variant))\n+         } else {\n+             None\n+         }\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -3177,7 +3187,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Find the relevant variant\n         let def = lookup_full_def(tcx, path.span, expr.id);\n-        let (adt, variant) = match fcx.def_struct_variant(def) {\n+        let (adt, variant) = match fcx.def_struct_variant(def, path.span) {\n             Some((adt, variant)) => (adt, variant),\n             None => {\n                 span_err!(fcx.tcx().sess, path.span, E0071,"}, {"sha": "14947d9955efdce9602e8564b4baf1d9d60f1888", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -624,11 +624,10 @@ struct AdtField<'tcx> {\n }\n \n fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            struct_def: &hir::StructDef)\n+                            struct_def: &hir::VariantData)\n                             -> AdtVariant<'tcx> {\n     let fields =\n-        struct_def.fields\n-        .iter()\n+        struct_def.fields()\n         .map(|field| {\n             let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,\n@@ -647,41 +646,7 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                            enum_def: &hir::EnumDef)\n                            -> Vec<AdtVariant<'tcx>> {\n     enum_def.variants.iter()\n-        .map(|variant| {\n-            match variant.node.kind {\n-                hir::TupleVariantKind(ref args) if !args.is_empty() => {\n-                    let ctor_ty = fcx.tcx().node_id_to_type(variant.node.id);\n-\n-                    // the regions in the argument types come from the\n-                    // enum def'n, and hence will all be early bound\n-                    let arg_tys = fcx.tcx().no_late_bound_regions(&ctor_ty.fn_args()).unwrap();\n-                    AdtVariant {\n-                        fields: args.iter().enumerate().map(|(index, arg)| {\n-                            let arg_ty = arg_tys[index];\n-                            let arg_ty =\n-                                fcx.instantiate_type_scheme(variant.span,\n-                                                            &fcx.inh\n-                                                                .infcx\n-                                                                .parameter_environment\n-                                                                .free_substs,\n-                                                            &arg_ty);\n-                            AdtField {\n-                                ty: arg_ty,\n-                                span: arg.ty.span\n-                            }\n-                        }).collect()\n-                    }\n-                }\n-                hir::TupleVariantKind(_) => {\n-                    AdtVariant {\n-                        fields: Vec::new()\n-                    }\n-                }\n-                hir::StructVariantKind(ref struct_def) => {\n-                    struct_variant(fcx, &**struct_def)\n-                }\n-            }\n-        })\n+        .map(|variant| struct_variant(fcx, &variant.node.data))\n         .collect()\n }\n "}, {"sha": "4cfc34dbb2384d836a5d3cf73740a9192e3830d1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -521,11 +521,10 @@ struct AdtField<'tcx> {\n }\n \n fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            struct_def: &hir::StructDef)\n+                            struct_def: &hir::VariantData)\n                             -> AdtVariant<'tcx> {\n     let fields =\n-        struct_def.fields\n-        .iter()\n+        struct_def.fields()\n         .map(|field| {\n             let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,\n@@ -544,41 +543,7 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                            enum_def: &hir::EnumDef)\n                            -> Vec<AdtVariant<'tcx>> {\n     enum_def.variants.iter()\n-        .map(|variant| {\n-            match variant.node.kind {\n-                hir::TupleVariantKind(ref args) if !args.is_empty() => {\n-                    let ctor_ty = fcx.tcx().node_id_to_type(variant.node.id);\n-\n-                    // the regions in the argument types come from the\n-                    // enum def'n, and hence will all be early bound\n-                    let arg_tys = fcx.tcx().no_late_bound_regions(&ctor_ty.fn_args()).unwrap();\n-                    AdtVariant {\n-                        fields: args.iter().enumerate().map(|(index, arg)| {\n-                            let arg_ty = arg_tys[index];\n-                            let arg_ty =\n-                                fcx.instantiate_type_scheme(variant.span,\n-                                                            &fcx.inh\n-                                                                .infcx\n-                                                                .parameter_environment\n-                                                                .free_substs,\n-                                                            &arg_ty);\n-                            AdtField {\n-                                ty: arg_ty,\n-                                span: arg.ty.span\n-                            }\n-                        }).collect()\n-                    }\n-                }\n-                hir::TupleVariantKind(_) => {\n-                    AdtVariant {\n-                        fields: Vec::new()\n-                    }\n-                }\n-                hir::StructVariantKind(ref struct_def) => {\n-                    struct_variant(fcx, &**struct_def)\n-                }\n-            }\n-        })\n+        .map(|variant| struct_variant(fcx, &variant.node.data))\n         .collect()\n }\n "}, {"sha": "194710a46fbceb388f30665b12aabe1c351f46ea", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 49, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -1010,12 +1010,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let it_def_id = ccx.tcx.map.local_def_id(it.id);\n             let variant = tcx.lookup_adt_def_master(it_def_id).struct_variant();\n \n-            for (f, ty_f) in struct_def.fields.iter().zip(variant.fields.iter()) {\n+            for (f, ty_f) in struct_def.fields().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n             }\n \n-            if let Some(ctor_id) = struct_def.ctor_id {\n-                convert_variant_ctor(tcx, ctor_id, variant, scheme, predicates);\n+            if !struct_def.is_struct() {\n+                convert_variant_ctor(tcx, struct_def.id(), variant, scheme, predicates);\n             }\n         },\n         hir::ItemTy(_, ref generics) => {\n@@ -1039,7 +1039,7 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   scheme: ty::TypeScheme<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let ctor_ty = match variant.kind() {\n-        VariantKind::Unit | VariantKind::Dict => scheme.ty,\n+        VariantKind::Unit | VariantKind::Struct => scheme.ty,\n         VariantKind::Tuple => {\n             let inputs: Vec<_> =\n                 variant.fields\n@@ -1065,32 +1065,17 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         scheme: ty::TypeScheme<'tcx>,\n                                         predicates: ty::GenericPredicates<'tcx>,\n                                         variants: &[P<hir::Variant>]) {\n-    let tcx = ccx.tcx;\n-    let icx = ccx.icx(&predicates);\n-\n     // fill the field types\n     for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n-        match variant.node.kind {\n-            hir::TupleVariantKind(ref args) => {\n-                let rs = ExplicitRscope;\n-                let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n-                for (field, &ty) in ty_variant.fields.iter().zip(input_tys.iter()) {\n-                    field.fulfill_ty(ty);\n-                }\n-            }\n-\n-            hir::StructVariantKind(ref struct_def) => {\n-                for (f, ty_f) in struct_def.fields.iter().zip(ty_variant.fields.iter()) {\n-                    convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n-                }\n-            }\n-        };\n+        for (f, ty_f) in variant.node.data.fields().zip(ty_variant.fields.iter()) {\n+            convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n+        }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n         convert_variant_ctor(\n-            tcx,\n-            variant.node.id,\n+            ccx.tcx,\n+            variant.node.data.id(),\n             ty_variant,\n             scheme.clone(),\n             predicates.clone()\n@@ -1102,9 +1087,9 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 did: DefId,\n                                 name: ast::Name,\n                                 disr_val: ty::Disr,\n-                                def: &hir::StructDef) -> ty::VariantDefData<'tcx, 'tcx> {\n+                                def: &hir::VariantData) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n-    let fields = def.fields.iter().map(|f| {\n+    let fields = def.fields().map(|f| {\n         let fid = tcx.map.local_def_id(f.node.id);\n         match f.node.kind {\n             hir::NamedField(name, vis) => {\n@@ -1135,13 +1120,16 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             it: &hir::Item,\n-                            def: &hir::StructDef)\n+                            def: &hir::VariantData)\n                             -> ty::AdtDefMaster<'tcx>\n {\n \n     let did = tcx.map.local_def_id(it.id);\n-    let ctor_id = def.ctor_id.map_or(did,\n-        |ctor_id| tcx.map.local_def_id(ctor_id));\n+    let ctor_id = if !def.is_struct() {\n+        tcx.map.local_def_id(def.id())\n+    } else {\n+        did\n+    };\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n@@ -1221,27 +1209,9 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   disr: ty::Disr)\n                                   -> ty::VariantDefData<'tcx, 'tcx>\n     {\n-        let did = tcx.map.local_def_id(v.node.id);\n+        let did = tcx.map.local_def_id(v.node.data.id());\n         let name = v.node.name;\n-        match v.node.kind {\n-            hir::TupleVariantKind(ref va) => {\n-                ty::VariantDefData {\n-                    did: did,\n-                    name: name,\n-                    disr_val: disr,\n-                    fields: va.iter().map(|&hir::VariantArg { id, .. }| {\n-                        ty::FieldDefData::new(\n-                            tcx.map.local_def_id(id),\n-                            special_idents::unnamed_field.name,\n-                            hir::Visibility::Public\n-                        )\n-                    }).collect()\n-                }\n-            }\n-            hir::StructVariantKind(ref def) => {\n-                convert_struct_variant(tcx, did, name, disr, &def)\n-            }\n-        }\n+        convert_struct_variant(tcx, did, name, disr, &v.node.data)\n     }\n     let did = tcx.map.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);"}, {"sha": "e4420d0dd92fa0ce11cf0994497aa3f6a2d9481c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -1805,11 +1805,11 @@ pub struct VariantStruct {\n     pub fields_stripped: bool,\n }\n \n-impl Clean<VariantStruct> for ::rustc_front::hir::StructDef {\n+impl Clean<VariantStruct> for ::rustc_front::hir::VariantData {\n     fn clean(&self, cx: &DocContext) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n-            fields: self.fields.clean(cx),\n+            fields: self.fields().map(|x| x.clean(cx)).collect(),\n             fields_stripped: false,\n         }\n     }\n@@ -1853,9 +1853,9 @@ impl Clean<Item> for doctree::Variant {\n             source: self.whence.clean(cx),\n             visibility: None,\n             stability: self.stab.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.map.local_def_id(self.def.id()),\n             inner: VariantItem(Variant {\n-                kind: self.kind.clean(cx),\n+                kind: struct_def_to_variant_kind(&self.def, cx),\n             }),\n         }\n     }\n@@ -1871,7 +1871,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                     self.fields.iter().map(|f| f.unsubst_ty().clean(cx)).collect()\n                 )\n             }\n-            ty::VariantKind::Dict => {\n+            ty::VariantKind::Struct => {\n                 StructVariant(VariantStruct {\n                     struct_type: doctree::Plain,\n                     fields_stripped: false,\n@@ -1917,18 +1917,13 @@ pub enum VariantKind {\n     StructVariant(VariantStruct),\n }\n \n-impl Clean<VariantKind> for hir::VariantKind {\n-    fn clean(&self, cx: &DocContext) -> VariantKind {\n-        match self {\n-            &hir::TupleVariantKind(ref args) => {\n-                if args.is_empty() {\n-                    CLikeVariant\n-                } else {\n-                    TupleVariant(args.iter().map(|x| x.ty.clean(cx)).collect())\n-                }\n-            },\n-            &hir::StructVariantKind(ref sd) => StructVariant(sd.clean(cx)),\n-        }\n+fn struct_def_to_variant_kind(struct_def: &hir::VariantData, cx: &DocContext) -> VariantKind {\n+    if struct_def.is_struct() {\n+        StructVariant(struct_def.clean(cx))\n+    } else if struct_def.is_unit() {\n+        CLikeVariant\n+    } else {\n+        TupleVariant(struct_def.fields().map(|x| x.node.ty.clean(cx)).collect())\n     }\n }\n "}, {"sha": "47cc007f605ebd1e10b8579652c24bcab86e0976", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -119,8 +119,7 @@ pub struct Enum {\n pub struct Variant {\n     pub name: Name,\n     pub attrs: Vec<ast::Attribute>,\n-    pub kind: hir::VariantKind,\n-    pub id: ast::NodeId,\n+    pub def: P<hir::VariantData>,\n     pub stab: Option<attr::Stability>,\n     pub whence: Span,\n }\n@@ -234,10 +233,10 @@ pub struct Import {\n     pub whence: Span,\n }\n \n-pub fn struct_type_from_def(sd: &hir::StructDef) -> StructType {\n-    if sd.ctor_id.is_some() {\n+pub fn struct_type_from_def(sd: &hir::VariantData) -> StructType {\n+    if !sd.is_struct() {\n         // We are in a tuple-struct\n-        match sd.fields.len() {\n+        match sd.fields().count() {\n             0 => Unit,\n             1 => Newtype,\n             _ => Tuple"}, {"sha": "1487c1668aac74a64211bb90074c8c02e6867885", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -84,8 +84,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.module.is_crate = true;\n     }\n \n-    pub fn visit_struct_def(&mut self, item: &hir::Item,\n-                            name: ast::Name, sd: &hir::StructDef,\n+    pub fn visit_variant_data(&mut self, item: &hir::Item,\n+                            name: ast::Name, sd: &hir::VariantData,\n                             generics: &hir::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             stab: self.stability(item.id),\n             attrs: item.attrs.clone(),\n             generics: generics.clone(),\n-            fields: sd.fields.clone(),\n+            fields: sd.fields().cloned().collect(),\n             whence: item.span\n         }\n     }\n@@ -111,9 +111,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             variants: def.variants.iter().map(|v| Variant {\n                 name: v.node.name,\n                 attrs: v.node.attrs.clone(),\n-                stab: self.stability(v.node.id),\n-                id: v.node.id,\n-                kind: v.node.kind.clone(),\n+                stab: self.stability(v.node.data.id()),\n+                def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n             vis: it.vis,\n@@ -299,7 +298,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::ItemEnum(ref ed, ref gen) =>\n                 om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n             hir::ItemStruct(ref sd, ref gen) =>\n-                om.structs.push(self.visit_struct_def(item, name, &**sd, gen)),\n+                om.structs.push(self.visit_variant_data(item, name, &**sd, gen)),\n             hir::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, _) =>\n                 om.fns.push(self.visit_fn(item, name, &**fd, unsafety,\n                                           constness, abi, gen)),"}, {"sha": "720c2ffc6d4830545fe5cbf59bc5e1dbcbe148f9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -44,7 +44,6 @@ pub use self::TyParamBound::*;\n pub use self::UintTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n-pub use self::VariantKind::*;\n pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n@@ -66,6 +65,7 @@ use std::fmt;\n use std::rc::Rc;\n use std::borrow::Cow;\n use std::hash::{Hash, Hasher};\n+use std::{iter, option, slice};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n@@ -1571,20 +1571,6 @@ pub struct ForeignMod {\n     pub items: Vec<P<ForeignItem>>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct VariantArg {\n-    pub ty: P<Ty>,\n-    pub id: NodeId,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum VariantKind {\n-    /// Tuple variant, e.g. `Foo(A, B)`\n-    TupleVariantKind(Vec<VariantArg>),\n-    /// Struct variant, e.g. `Foo {x: A, y: B}`\n-    StructVariantKind(P<StructDef>),\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<P<Variant>>,\n@@ -1594,8 +1580,7 @@ pub struct EnumDef {\n pub struct Variant_ {\n     pub name: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub kind: VariantKind,\n-    pub id: NodeId,\n+    pub data: P<VariantData>,\n     /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<P<Expr>>,\n }\n@@ -1756,13 +1741,50 @@ impl StructFieldKind {\n     }\n }\n \n+/// Fields and Ids of enum variants and structs\n+///\n+/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n+/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n+/// One shared Id can be successfully used for these two purposes.\n+/// Id of the whole enum lives in `Item`.\n+///\n+/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n+/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n+/// the variant itself\" from enum variants.\n+/// Id of the whole struct lives in `Item`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct StructDef {\n-    /// Fields, not including ctor\n-    pub fields: Vec<StructField>,\n-    /// ID of the constructor. This is only used for tuple- or enum-like\n-    /// structs.\n-    pub ctor_id: Option<NodeId>,\n+pub enum VariantData {\n+    Struct(Vec<StructField>, NodeId),\n+    Tuple(Vec<StructField>, NodeId),\n+    Unit(NodeId),\n+}\n+\n+pub type FieldIter<'a> = iter::FlatMap<option::IntoIter<&'a Vec<StructField>>,\n+                                       slice::Iter<'a, StructField>,\n+                                       fn(&Vec<StructField>) -> slice::Iter<StructField>>;\n+\n+impl VariantData {\n+    pub fn fields(&self) -> FieldIter {\n+        fn vec_iter<T>(v: &Vec<T>) -> slice::Iter<T> { v.iter() }\n+        match *self {\n+            VariantData::Struct(ref fields, _) | VariantData::Tuple(ref fields, _) => Some(fields),\n+            _ => None,\n+        }.into_iter().flat_map(vec_iter)\n+    }\n+    pub fn id(&self) -> NodeId {\n+        match *self {\n+            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id\n+        }\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData::Struct(..) = *self { true } else { false }\n+    }\n+    pub fn is_tuple(&self) -> bool {\n+        if let VariantData::Tuple(..) = *self { true } else { false }\n+    }\n+    pub fn is_unit(&self) -> bool {\n+        if let VariantData::Unit(..) = *self { true } else { false }\n+    }\n }\n \n /*\n@@ -1806,7 +1828,7 @@ pub enum Item_ {\n     /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n     ItemEnum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n-    ItemStruct(P<StructDef>, Generics),\n+    ItemStruct(P<VariantData>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Unsafety,\n               Generics,"}, {"sha": "8c3360512d512f632880670a7929f42bfabae4b4", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -360,11 +360,6 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n                     }\n                 }\n             }\n-            ItemEnum(ref enum_definition, _) => {\n-                for variant in &enum_definition.variants {\n-                    self.operation.visit_id(variant.node.id)\n-                }\n-            }\n             _ => {}\n         }\n \n@@ -457,13 +452,13 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_struct_field(self, struct_field)\n     }\n \n-    fn visit_struct_def(&mut self,\n-                        struct_def: &StructDef,\n+    fn visit_variant_data(&mut self,\n+                        struct_def: &VariantData,\n                         _: ast::Ident,\n                         _: &ast::Generics,\n-                        id: NodeId) {\n-        self.operation.visit_id(id);\n-        struct_def.ctor_id.map(|ctor_id| self.operation.visit_id(ctor_id));\n+                        _: NodeId,\n+                        _: Span) {\n+        self.operation.visit_id(struct_def.id());\n         visit::walk_struct_def(self, struct_def);\n     }\n \n@@ -529,12 +524,6 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n     id_visitor.operation.result\n }\n \n-/// Returns true if the given struct def is tuple-like; i.e. that its fields\n-/// are unnamed.\n-pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {\n-    struct_def.ctor_id.is_some()\n-}\n-\n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {"}, {"sha": "0ca110c5b1ed2cf1a490e7f3f9f782b91a8a5c53", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -140,19 +140,13 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n                 if !(cx.in_cfg)(&v.node.attrs) {\n                     None\n                 } else {\n-                    Some(v.map(|Spanned {node: ast::Variant_ {id, name, attrs, kind,\n+                    Some(v.map(|Spanned {node: ast::Variant_ {name, attrs, data,\n                                                               disr_expr}, span}| {\n                         Spanned {\n                             node: ast::Variant_ {\n-                                id: id,\n                                 name: name,\n                                 attrs: attrs,\n-                                kind: match kind {\n-                                    ast::TupleVariantKind(..) => kind,\n-                                    ast::StructVariantKind(def) => {\n-                                        ast::StructVariantKind(fold_struct(cx, def))\n-                                    }\n-                                },\n+                                data: fold_struct(cx, data),\n                                 disr_expr: disr_expr,\n                             },\n                             span: span\n@@ -170,15 +164,22 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n     fold::noop_fold_item_underscore(item, cx)\n }\n \n-fn fold_struct<F>(cx: &mut Context<F>, def: P<ast::StructDef>) -> P<ast::StructDef> where\n+fn fold_struct<F>(cx: &mut Context<F>, def: P<ast::VariantData>) -> P<ast::VariantData> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    def.map(|ast::StructDef { fields, ctor_id }| {\n-        ast::StructDef {\n-            fields: fields.into_iter().filter(|m| {\n-                (cx.in_cfg)(&m.node.attrs)\n-            }).collect(),\n-            ctor_id: ctor_id,\n+    def.map(|vdata| {\n+        match vdata {\n+            ast::VariantData::Struct(fields, id) => {\n+                ast::VariantData::Struct(fields.into_iter().filter(|m| {\n+                    (cx.in_cfg)(&m.node.attrs)\n+                }).collect(), id)\n+            }\n+            ast::VariantData::Tuple(fields, id) => {\n+                ast::VariantData::Tuple(fields.into_iter().filter(|m| {\n+                    (cx.in_cfg)(&m.node.attrs)\n+                }).collect(), id)\n+            }\n+            ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n         }\n     })\n }"}, {"sha": "9b06fbd0a0b858ef73b6615bbed3849be0b7ee4f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -247,9 +247,9 @@ pub trait AstBuilder {\n     fn item_struct_poly(&self,\n                         span: Span,\n                         name: Ident,\n-                        struct_def: ast::StructDef,\n+                        struct_def: ast::VariantData,\n                         generics: Generics) -> P<ast::Item>;\n-    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> P<ast::Item>;\n+    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::VariantData) -> P<ast::Item>;\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n                 name: Ident, attrs: Vec<ast::Attribute>,\n@@ -993,16 +993,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n-        let args = tys.into_iter().map(|ty| {\n-            ast::VariantArg { ty: ty, id: ast::DUMMY_NODE_ID }\n+        let fields: Vec<_> = tys.into_iter().map(|ty| {\n+            Spanned { span: ty.span, node: ast::StructField_ {\n+                ty: ty,\n+                kind: ast::UnnamedField(ast::Inherited),\n+                attrs: Vec::new(),\n+                id: ast::DUMMY_NODE_ID,\n+            }}\n         }).collect();\n \n+        let vdata = if fields.is_empty() {\n+            ast::VariantData::Unit(ast::DUMMY_NODE_ID)\n+        } else {\n+            ast::VariantData::Tuple(fields, ast::DUMMY_NODE_ID)\n+        };\n+\n         respan(span,\n                ast::Variant_ {\n                    name: name,\n                    attrs: Vec::new(),\n-                   kind: ast::TupleVariantKind(args),\n-                   id: ast::DUMMY_NODE_ID,\n+                   data: P(vdata),\n                    disr_expr: None,\n                })\n     }\n@@ -1020,7 +1030,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::StructDef) -> P<ast::Item> {\n+                   struct_def: ast::VariantData) -> P<ast::Item> {\n         self.item_struct_poly(\n             span,\n             name,\n@@ -1030,7 +1040,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::StructDef, generics: Generics) -> P<ast::Item> {\n+        struct_def: ast::VariantData, generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemStruct(P(struct_def), generics))\n     }\n "}, {"sha": "2a5c4993112a992e54edaafb8c94b6e7f5d2d1a7", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 17, "deletions": 59, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -174,9 +174,9 @@\n //! A static method on the types above would result in,\n //!\n //! ```{.text}\n-//! StaticStruct(<ast::StructDef of A>, Named(vec![(<ident of x>, <span of x>)]))\n+//! StaticStruct(<ast::VariantData of A>, Named(vec![(<ident of x>, <span of x>)]))\n //!\n-//! StaticStruct(<ast::StructDef of B>, Unnamed(vec![<span of x>]))\n+//! StaticStruct(<ast::VariantData of B>, Unnamed(vec![<span of x>]))\n //!\n //! StaticEnum(<ast::EnumDef of C>,\n //!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of i32>])),\n@@ -194,7 +194,7 @@ use std::vec;\n use abi::Abi;\n use abi;\n use ast;\n-use ast::{EnumDef, Expr, Ident, Generics, StructDef};\n+use ast::{EnumDef, Expr, Ident, Generics, VariantData};\n use ast_util;\n use attr;\n use attr::AttrMetaMethods;\n@@ -317,7 +317,7 @@ pub enum SubstructureFields<'a> {\n     EnumNonMatchingCollapsed(Vec<Ident>, &'a [P<ast::Variant>], &'a [Ident]),\n \n     /// A static method where `Self` is a struct.\n-    StaticStruct(&'a ast::StructDef, StaticFields),\n+    StaticStruct(&'a ast::VariantData, StaticFields),\n     /// A static method where `Self` is an enum.\n     StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)>),\n }\n@@ -649,10 +649,10 @@ impl<'a> TraitDef<'a> {\n \n     fn expand_struct_def(&self,\n                          cx: &mut ExtCtxt,\n-                         struct_def: &'a StructDef,\n+                         struct_def: &'a VariantData,\n                          type_ident: Ident,\n                          generics: &Generics) -> P<ast::Item> {\n-        let field_tys: Vec<P<ast::Ty>> = struct_def.fields.iter()\n+        let field_tys: Vec<P<ast::Ty>> = struct_def.fields()\n             .map(|field| field.node.ty.clone())\n             .collect();\n \n@@ -700,16 +700,8 @@ impl<'a> TraitDef<'a> {\n         let mut field_tys = Vec::new();\n \n         for variant in &enum_def.variants {\n-            match variant.node.kind {\n-                ast::VariantKind::TupleVariantKind(ref args) => {\n-                    field_tys.extend(args.iter()\n-                        .map(|arg| arg.ty.clone()));\n-                }\n-                ast::VariantKind::StructVariantKind(ref args) => {\n-                    field_tys.extend(args.fields.iter()\n-                        .map(|field| field.node.ty.clone()));\n-                }\n-            }\n+            field_tys.extend(variant.node.data.fields()\n+                .map(|field| field.node.ty.clone()));\n         }\n \n         let methods = self.methods.iter().map(|method_def| {\n@@ -935,7 +927,7 @@ impl<'a> MethodDef<'a> {\n     fn expand_struct_method_body<'b>(&self,\n                                  cx: &mut ExtCtxt,\n                                  trait_: &TraitDef<'b>,\n-                                 struct_def: &'b StructDef,\n+                                 struct_def: &'b VariantData,\n                                  type_ident: Ident,\n                                  self_args: &[P<Expr>],\n                                  nonself_args: &[P<Expr>])\n@@ -1004,7 +996,7 @@ impl<'a> MethodDef<'a> {\n     fn expand_static_struct_method_body(&self,\n                                         cx: &mut ExtCtxt,\n                                         trait_: &TraitDef,\n-                                        struct_def: &StructDef,\n+                                        struct_def: &VariantData,\n                                         type_ident: Ident,\n                                         self_args: &[P<Expr>],\n                                         nonself_args: &[P<Expr>])\n@@ -1413,14 +1405,7 @@ impl<'a> MethodDef<'a> {\n         -> P<Expr> {\n         let summary = enum_def.variants.iter().map(|v| {\n             let ident = v.node.name;\n-            let summary = match v.node.kind {\n-                ast::TupleVariantKind(ref args) => {\n-                    Unnamed(args.iter().map(|va| trait_.set_expn_info(cx, va.ty.span)).collect())\n-                }\n-                ast::StructVariantKind(ref struct_def) => {\n-                    trait_.summarise_struct(cx, &**struct_def)\n-                }\n-            };\n+            let summary = trait_.summarise_struct(cx, &v.node.data);\n             (ident, v.span, summary)\n         }).collect();\n         self.call_substructure_method(cx, trait_, type_ident,\n@@ -1456,10 +1441,10 @@ impl<'a> TraitDef<'a> {\n \n     fn summarise_struct(&self,\n                         cx: &mut ExtCtxt,\n-                        struct_def: &StructDef) -> StaticFields {\n+                        struct_def: &VariantData) -> StaticFields {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n-        for field in struct_def.fields.iter(){\n+        for field in struct_def.fields(){\n             let sp = self.set_expn_info(cx, field.span);\n             match field.node.kind {\n                 ast::NamedField(ident, _) => named_idents.push((ident, sp)),\n@@ -1492,21 +1477,21 @@ impl<'a> TraitDef<'a> {\n     fn create_struct_pattern(&self,\n                              cx: &mut ExtCtxt,\n                              struct_path: ast::Path,\n-                             struct_def: &'a StructDef,\n+                             struct_def: &'a VariantData,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n                              -> (P<ast::Pat>, Vec<(Span, Option<Ident>,\n                                                    P<Expr>,\n                                                    &'a [ast::Attribute])>) {\n-        if struct_def.fields.is_empty() {\n+        if struct_def.fields().count() == 0 {\n             return (cx.pat_enum(self.span, struct_path, vec![]), vec![]);\n         }\n \n         let mut paths = Vec::new();\n         let mut ident_expr = Vec::new();\n         let mut struct_type = Unknown;\n \n-        for (i, struct_field) in struct_def.fields.iter().enumerate() {\n+        for (i, struct_field) in struct_def.fields().enumerate() {\n             let sp = self.set_expn_info(cx, struct_field.span);\n             let opt_id = match struct_field.node.kind {\n                 ast::NamedField(ident, _) if (struct_type == Unknown ||\n@@ -1560,34 +1545,7 @@ impl<'a> TraitDef<'a> {\n         -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let variant_ident = variant.node.name;\n         let variant_path = cx.path(variant.span, vec![enum_ident, variant_ident]);\n-        match variant.node.kind {\n-            ast::TupleVariantKind(ref variant_args) => {\n-                if variant_args.is_empty() {\n-                    return (cx.pat_enum(variant.span, variant_path, vec![]), vec![]);\n-                }\n-\n-                let mut paths = Vec::new();\n-                let mut ident_expr: Vec<(_, _, _, &'a [ast::Attribute])> = Vec::new();\n-                for (i, va) in variant_args.iter().enumerate() {\n-                    let sp = self.set_expn_info(cx, va.ty.span);\n-                    let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n-                    let path1 = codemap::Spanned{span: sp, node: ident};\n-                    paths.push(path1);\n-                    let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n-                    let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, expr_path)));\n-                    ident_expr.push((sp, None, val, &[]));\n-                }\n-\n-                let subpats = self.create_subpatterns(cx, paths, mutbl);\n-\n-                (cx.pat_enum(variant.span, variant_path, subpats),\n-                 ident_expr)\n-            }\n-            ast::StructVariantKind(ref struct_def) => {\n-                self.create_struct_pattern(cx, variant_path, &**struct_def,\n-                                           prefix, mutbl)\n-            }\n-        }\n+        self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl)\n     }\n }\n "}, {"sha": "07b587783583e699d1bd6e0c5187999100aa172f", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -94,45 +94,35 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n             let mut arms = Vec::new();\n \n             for variant in &enum_def.variants {\n-                match variant.node.kind {\n-                    ast::TupleVariantKind(ref args) => {\n-                        if !args.is_empty() {\n-                            cx.span_err(trait_span,\n-                                        \"`FromPrimitive` cannot be derived for \\\n-                                        enum variants with arguments\");\n-                            return cx.expr_fail(trait_span,\n-                                                InternedString::new(\"\"));\n-                        }\n-                        let span = variant.span;\n+                let def = &variant.node.data;\n+                if !def.is_unit() {\n+                    cx.span_err(trait_span, \"`FromPrimitive` cannot be derived \\\n+                                             for enums with non-unit variants\");\n+                    return cx.expr_fail(trait_span,\n+                                        InternedString::new(\"\"));\n+                }\n \n-                        // expr for `$n == $variant as $name`\n-                        let path = cx.path(span, vec![substr.type_ident, variant.node.name]);\n-                        let variant = cx.expr_path(path);\n-                        let ty = cx.ty_ident(span, cx.ident_of(name));\n-                        let cast = cx.expr_cast(span, variant.clone(), ty);\n-                        let guard = cx.expr_binary(span, ast::BiEq, n.clone(), cast);\n+                let span = variant.span;\n \n-                        // expr for `Some($variant)`\n-                        let body = cx.expr_some(span, variant);\n+                // expr for `$n == $variant as $name`\n+                let path = cx.path(span, vec![substr.type_ident, variant.node.name]);\n+                let variant = cx.expr_path(path);\n+                let ty = cx.ty_ident(span, cx.ident_of(name));\n+                let cast = cx.expr_cast(span, variant.clone(), ty);\n+                let guard = cx.expr_binary(span, ast::BiEq, n.clone(), cast);\n \n-                        // arm for `_ if $guard => $body`\n-                        let arm = ast::Arm {\n-                            attrs: vec!(),\n-                            pats: vec!(cx.pat_wild(span)),\n-                            guard: Some(guard),\n-                            body: body,\n-                        };\n+                // expr for `Some($variant)`\n+                let body = cx.expr_some(span, variant);\n \n-                        arms.push(arm);\n-                    }\n-                    ast::StructVariantKind(_) => {\n-                        cx.span_err(trait_span,\n-                                    \"`FromPrimitive` cannot be derived for enums \\\n-                                    with struct variants\");\n-                        return cx.expr_fail(trait_span,\n-                                            InternedString::new(\"\"));\n-                    }\n-                }\n+                // arm for `_ if $guard => $body`\n+                let arm = ast::Arm {\n+                    attrs: vec!(),\n+                    pats: vec!(cx.pat_wild(span)),\n+                    guard: Some(guard),\n+                    body: body,\n+                };\n+\n+                arms.push(arm);\n             }\n \n             // arm for `_ => None`"}, {"sha": "be6ad9311114af434c797aec0120439faca7f03d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -196,7 +196,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     // allow `#[unwind]`\n     (\"unwind_attributes\", \"1.4.0\", None, Active),\n \n-    // allow empty structs/enum variants with braces\n+    // allow empty structs and enum variants with braces\n     (\"braced_empty_structs\", \"1.5.0\", None, Active),\n \n     // allow overloading augmented assignment operations like `a += b`\n@@ -486,6 +486,7 @@ pub struct Features {\n     pub cfg_target_feature: bool,\n     pub cfg_target_vendor: bool,\n     pub augmented_assignments: bool,\n+    pub braced_empty_structs: bool,\n }\n \n impl Features {\n@@ -516,6 +517,7 @@ impl Features {\n             cfg_target_feature: false,\n             cfg_target_vendor: false,\n             augmented_assignments: false,\n+            braced_empty_structs: false,\n         }\n     }\n }\n@@ -809,7 +811,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(ref def, _) => {\n+            ast::ItemStruct(..) => {\n                 if attr::contains_name(&i.attrs[..], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n@@ -828,10 +830,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                         }\n                     }\n                 }\n-                if def.fields.is_empty() && def.ctor_id.is_none() {\n-                    self.gate_feature(\"braced_empty_structs\", i.span,\n-                                      \"empty structs with braces are unstable\");\n-                }\n             }\n \n             ast::ItemDefaultImpl(..) => {\n@@ -859,6 +857,21 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_item(self, i);\n     }\n \n+    fn visit_variant_data(&mut self, s: &'v ast::VariantData, _: ast::Ident,\n+                        _: &'v ast::Generics, _: ast::NodeId, span: Span) {\n+        if s.fields().count() == 0 {\n+            if s.is_struct() {\n+                self.gate_feature(\"braced_empty_structs\", span,\n+                                  \"empty structs and enum variants with braces are unstable\");\n+            } else if s.is_tuple() {\n+                self.context.span_handler.span_err(span, \"empty tuple structs and enum variants \\\n+                                                          are not allowed, use unit structs and \\\n+                                                          enum variants instead\");\n+            }\n+        }\n+        visit::walk_struct_def(self, s)\n+    }\n+\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n                                                                      \"link_name\") {\n@@ -881,12 +894,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   \"box expression syntax is experimental; \\\n                                    you can call `Box::new` instead.\");\n             }\n-            ast::ExprStruct(_, ref fields, ref expr) => {\n-                if fields.is_empty() && expr.is_none() {\n-                    self.gate_feature(\"braced_empty_structs\", e.span,\n-                                      \"empty structs with braces are unstable\");\n-                }\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);\n@@ -911,12 +918,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");\n             }\n-            ast::PatStruct(_, ref fields, dotdot) => {\n-                if fields.is_empty() && !dotdot {\n-                    self.gate_feature(\"braced_empty_structs\", pattern.span,\n-                                      \"empty structs with braces are unstable\");\n-                }\n-            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)\n@@ -1086,6 +1087,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n         cfg_target_vendor: cx.has_feature(\"cfg_target_vendor\"),\n         augmented_assignments: cx.has_feature(\"augmented_assignments\"),\n+        braced_empty_structs: cx.has_feature(\"braced_empty_structs\"),\n     }\n }\n "}, {"sha": "219a4649339dd753d9093a4dee2060f52c3febc3", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -231,7 +231,7 @@ pub trait Folder : Sized {\n         noop_fold_poly_trait_ref(p, self)\n     }\n \n-    fn fold_struct_def(&mut self, struct_def: P<StructDef>) -> P<StructDef> {\n+    fn fold_variant_data(&mut self, struct_def: P<VariantData>) -> P<VariantData> {\n         noop_fold_struct_def(struct_def, self)\n     }\n \n@@ -271,10 +271,6 @@ pub trait Folder : Sized {\n         noop_fold_opt_lifetime(o_lt, self)\n     }\n \n-    fn fold_variant_arg(&mut self, va: VariantArg) -> VariantArg {\n-        noop_fold_variant_arg(va, self)\n-    }\n-\n     fn fold_opt_bounds(&mut self, b: Option<OwnedSlice<TyParamBound>>)\n                        -> Option<OwnedSlice<TyParamBound>> {\n         noop_fold_opt_bounds(b, self)\n@@ -450,20 +446,11 @@ pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n }\n \n pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n-    v.map(|Spanned {node: Variant_ {id, name, attrs, kind, disr_expr}, span}| Spanned {\n+    v.map(|Spanned {node: Variant_ {name, attrs, data, disr_expr}, span}| Spanned {\n         node: Variant_ {\n-            id: fld.new_id(id),\n             name: name,\n             attrs: fold_attrs(attrs, fld),\n-            kind: match kind {\n-                TupleVariantKind(variant_args) => {\n-                    TupleVariantKind(variant_args.move_map(|x|\n-                        fld.fold_variant_arg(x)))\n-                }\n-                StructVariantKind(struct_def) => {\n-                    StructVariantKind(fld.fold_struct_def(struct_def))\n-                }\n-            },\n+            data: fld.fold_variant_data(data),\n             disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n         },\n         span: fld.new_span(span),\n@@ -827,10 +814,19 @@ pub fn noop_fold_where_predicate<T: Folder>(\n     }\n }\n \n-pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n-    struct_def.map(|StructDef { fields, ctor_id }| StructDef {\n-        fields: fields.move_map(|f| fld.fold_struct_field(f)),\n-        ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n+pub fn noop_fold_struct_def<T: Folder>(struct_def: P<VariantData>, fld: &mut T) -> P<VariantData> {\n+    struct_def.map(|vdata| {\n+        match vdata {\n+            ast::VariantData::Struct(fields, id) => {\n+                ast::VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)),\n+                                         fld.new_id(id))\n+            }\n+            ast::VariantData::Tuple(fields, id) => {\n+                ast::VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)),\n+                                        fld.new_id(id))\n+            }\n+            ast::VariantData::Unit(id) => ast::VariantData::Unit(fld.new_id(id))\n+        }\n     })\n }\n \n@@ -892,14 +888,6 @@ fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n     bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n }\n \n-fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mut T)\n-                                    -> VariantArg {\n-    VariantArg {\n-        id: folder.new_id(id),\n-        ty: folder.fold_ty(ty)\n-    }\n-}\n-\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block {id, stmts, expr, rules, span}| Block {\n         id: folder.new_id(id),\n@@ -945,7 +933,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                 folder.fold_generics(generics))\n         }\n         ItemStruct(struct_def, generics) => {\n-            let struct_def = folder.fold_struct_def(struct_def);\n+            let struct_def = folder.fold_variant_data(struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {"}, {"sha": "934e4472bdc84827083127447febb2ce696f1e4a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -45,12 +45,12 @@ use ast::{PatRegion, PatStruct, PatTup, PatVec, PatWild, PatWildMulti};\n use ast::PatWildSingle;\n use ast::{PolyTraitRef, QSelf};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n-use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n-use ast::{StructVariantKind, BiSub, StrStyle};\n+use ast::{StmtExpr, StmtSemi, StmtMac, VariantData, StructField};\n+use ast::{BiSub, StrStyle};\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n-use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n+use ast::{Ty, Ty_, TypeBinding};\n use ast::{TyMac};\n use ast::{TyFixedLengthVec, TyBareFn, TyTypeof, TyInfer};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr};\n@@ -4640,38 +4640,34 @@ impl<'a> Parser<'a> {\n         // Otherwise if we look ahead and see a paren we parse a tuple-style\n         // struct.\n \n-        let (fields, ctor_id) = if self.token.is_keyword(keywords::Where) {\n+        let vdata = if self.token.is_keyword(keywords::Where) {\n             generics.where_clause = try!(self.parse_where_clause());\n             if try!(self.eat(&token::Semi)) {\n                 // If we see a: `struct Foo<T> where T: Copy;` style decl.\n-                (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+                VariantData::Unit(ast::DUMMY_NODE_ID)\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n-                (try!(self.parse_record_struct_body()), None)\n+                VariantData::Struct(try!(self.parse_record_struct_body()), ast::DUMMY_NODE_ID)\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if try!(self.eat(&token::Semi) ){\n-            (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+            VariantData::Unit(ast::DUMMY_NODE_ID)\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let fields = try!(self.parse_record_struct_body());\n-            (fields, None)\n+            VariantData::Struct(try!(self.parse_record_struct_body()), ast::DUMMY_NODE_ID)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n-            let fields = try!(self.parse_tuple_struct_body(class_name, &mut generics));\n-            (fields, Some(ast::DUMMY_NODE_ID))\n+            VariantData::Tuple(try!(self.parse_tuple_struct_body(&mut generics)),\n+                               ast::DUMMY_NODE_ID)\n         } else {\n             let token_str = self.this_token_to_string();\n             return Err(self.fatal(&format!(\"expected `where`, `{{`, `(`, or `;` after struct \\\n                                             name, found `{}`\", token_str)))\n         };\n \n         Ok((class_name,\n-         ItemStruct(P(ast::StructDef {\n-             fields: fields,\n-             ctor_id: ctor_id,\n-         }), generics),\n-         None))\n+            ItemStruct(P(vdata), generics),\n+            None))\n     }\n \n     pub fn parse_record_struct_body(&mut self) -> PResult<Vec<StructField>> {\n@@ -4693,7 +4689,6 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_tuple_struct_body(&mut self,\n-                                   class_name: ast::Ident,\n                                    generics: &mut ast::Generics)\n                                    -> PResult<Vec<StructField>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n@@ -4714,12 +4709,6 @@ impl<'a> Parser<'a> {\n                 Ok(spanned(lo, p.span.hi, struct_field_))\n             }));\n \n-        if fields.is_empty() {\n-            return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n-                                            written as `struct {};`\",\n-                                           class_name)));\n-        }\n-\n         generics.where_clause = try!(self.parse_where_clause());\n         try!(self.expect(&token::Semi));\n         Ok(fields)\n@@ -5109,17 +5098,14 @@ impl<'a> Parser<'a> {\n \n     /// Parse a structure-like enum variant definition\n     /// this should probably be renamed or refactored...\n-    fn parse_struct_def(&mut self) -> PResult<P<StructDef>> {\n+    fn parse_struct_def(&mut self) -> PResult<P<VariantData>> {\n         let mut fields: Vec<StructField> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n             fields.push(try!(self.parse_struct_decl_field(false)));\n         }\n         try!(self.bump());\n \n-        Ok(P(StructDef {\n-            fields: fields,\n-            ctor_id: None,\n-        }))\n+        Ok(P(VariantData::Struct(fields, ast::DUMMY_NODE_ID)))\n     }\n \n     /// Parse the part of an \"enum\" decl following the '{'\n@@ -5131,22 +5117,13 @@ impl<'a> Parser<'a> {\n             let variant_attrs = self.parse_outer_attributes();\n             let vlo = self.span.lo;\n \n-            let kind;\n-            let mut args = Vec::new();\n+            let struct_def;\n             let mut disr_expr = None;\n             let ident = try!(self.parse_ident());\n             if try!(self.eat(&token::OpenDelim(token::Brace)) ){\n                 // Parse a struct variant.\n                 all_nullary = false;\n-                let start_span = self.span;\n-                let struct_def = try!(self.parse_struct_def());\n-                if struct_def.fields.is_empty() {\n-                    self.span_err(start_span,\n-                        &format!(\"unit-like struct variant should be written \\\n-                                 without braces, as `{},`\",\n-                                ident));\n-                }\n-                kind = StructVariantKind(struct_def);\n+                struct_def = try!(self.parse_struct_def());\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n                 all_nullary = false;\n                 let arg_tys = try!(self.parse_enum_variant_seq(\n@@ -5155,26 +5132,28 @@ impl<'a> Parser<'a> {\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_ty_sum()\n                 ));\n+                let mut fields = Vec::new();\n                 for ty in arg_tys {\n-                    args.push(ast::VariantArg {\n+                    fields.push(Spanned { span: ty.span, node: ast::StructField_ {\n                         ty: ty,\n+                        kind: ast::UnnamedField(ast::Inherited),\n+                        attrs: Vec::new(),\n                         id: ast::DUMMY_NODE_ID,\n-                    });\n+                    }});\n                 }\n-                kind = TupleVariantKind(args);\n+                struct_def = P(ast::VariantData::Tuple(fields, ast::DUMMY_NODE_ID));\n             } else if try!(self.eat(&token::Eq) ){\n                 disr_expr = Some(try!(self.parse_expr_nopanic()));\n                 any_disr = disr_expr.as_ref().map(|expr| expr.span);\n-                kind = TupleVariantKind(args);\n+                struct_def = P(ast::VariantData::Unit(ast::DUMMY_NODE_ID));\n             } else {\n-                kind = TupleVariantKind(Vec::new());\n+                struct_def = P(ast::VariantData::Unit(ast::DUMMY_NODE_ID));\n             }\n \n             let vr = ast::Variant_ {\n                 name: ident,\n                 attrs: variant_attrs,\n-                kind: kind,\n-                id: ast::DUMMY_NODE_ID,\n+                data: struct_def,\n                 disr_expr: disr_expr,\n             };\n             variants.push(P(spanned(vlo, self.last_span.hi, vr)));"}, {"sha": "e5a9ce216a92ab5ff1ebe8f76c7d9ab76a7c03dd", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -520,6 +520,18 @@ pub trait PrintState<'a> {\n         self.end()\n     }\n \n+    fn commasep_iter<'it, T: 'it, F, I>(&mut self, b: Breaks, elts: I, mut op: F) -> io::Result<()>\n+        where F: FnMut(&mut Self, &T) -> io::Result<()>,\n+              I: Iterator<Item=&'it T>,\n+    {\n+        try!(self.rbox(0, b));\n+        let mut first = true;\n+        for elt in elts {\n+            if first { first = false; } else { try!(self.word_space(\",\")); }\n+            try!(op(self, elt));\n+        }\n+        self.end()\n+    }\n \n     fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n         let mut cur_lit = self.cur_cmnt_and_lit().cur_lit;\n@@ -1223,7 +1235,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemStruct(ref struct_def, ref generics) => {\n                 try!(self.head(&visibility_qualified(item.vis,\"struct\")));\n-                try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n+                try!(self.print_struct(&struct_def, generics, item.ident, item.span, true));\n             }\n \n             ast::ItemDefaultImpl(unsafety, ref trait_ref) => {\n@@ -1385,17 +1397,18 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_struct(&mut self,\n-                        struct_def: &ast::StructDef,\n+                        struct_def: &ast::VariantData,\n                         generics: &ast::Generics,\n                         ident: ast::Ident,\n-                        span: codemap::Span) -> io::Result<()> {\n+                        span: codemap::Span,\n+                        print_finalizer: bool) -> io::Result<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n-        if ast_util::struct_def_is_tuple_like(struct_def) {\n-            if !struct_def.fields.is_empty() {\n+        if !struct_def.is_struct() {\n+            if struct_def.is_tuple() {\n                 try!(self.popen());\n-                try!(self.commasep(\n-                    Inconsistent, &struct_def.fields,\n+                try!(self.commasep_iter(\n+                    Inconsistent, struct_def.fields(),\n                     |s, field| {\n                         match field.node.kind {\n                             ast::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -1410,7 +1423,9 @@ impl<'a> State<'a> {\n                 try!(self.pclose());\n             }\n             try!(self.print_where_clause(&generics.where_clause));\n-            try!(word(&mut self.s, \";\"));\n+            if print_finalizer {\n+                try!(word(&mut self.s, \";\"));\n+            }\n             try!(self.end());\n             self.end() // close the outer-box\n         } else {\n@@ -1419,7 +1434,7 @@ impl<'a> State<'a> {\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());\n \n-            for field in &struct_def.fields {\n+            for field in struct_def.fields() {\n                 match field.node.kind {\n                     ast::UnnamedField(..) => panic!(\"unexpected unnamed field\"),\n                     ast::NamedField(ident, visibility) => {\n@@ -1505,23 +1520,9 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n-        match v.node.kind {\n-            ast::TupleVariantKind(ref args) => {\n-                try!(self.print_ident(v.node.name));\n-                if !args.is_empty() {\n-                    try!(self.popen());\n-                    try!(self.commasep(Consistent,\n-                                       &args[..],\n-                                       |s, arg| s.print_type(&*arg.ty)));\n-                    try!(self.pclose());\n-                }\n-            }\n-            ast::StructVariantKind(ref struct_def) => {\n-                try!(self.head(\"\"));\n-                let generics = ast_util::empty_generics();\n-                try!(self.print_struct(&**struct_def, &generics, v.node.name, v.span));\n-            }\n-        }\n+        try!(self.head(\"\"));\n+        let generics = ast_util::empty_generics();\n+        try!(self.print_struct(&v.node.data, &generics, v.node.name, v.span, false));\n         match v.node.disr_expr {\n             Some(ref d) => {\n                 try!(space(&mut self.s));\n@@ -3103,6 +3104,7 @@ mod tests {\n     use ast_util;\n     use codemap;\n     use parse::token;\n+    use ptr::P;\n \n     #[test]\n     fn test_fun_to_string() {\n@@ -3129,8 +3131,7 @@ mod tests {\n             name: ident,\n             attrs: Vec::new(),\n             // making this up as I go.... ?\n-            kind: ast::TupleVariantKind(Vec::new()),\n-            id: 0,\n+            data: P(ast::VariantData::Unit(ast::DUMMY_NODE_ID)),\n             disr_expr: None,\n         });\n "}, {"sha": "b7d202804c5a42553c8adf8207279604f00c6700", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -80,17 +80,18 @@ pub trait Visitor<'v> : Sized {\n     fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_struct_def(&mut self, s: &'v StructDef, _: Ident, _: &'v Generics, _: NodeId) {\n+    fn visit_variant_data(&mut self, s: &'v VariantData, _: Ident,\n+                        _: &'v Generics, _: NodeId, _: Span) {\n         walk_struct_def(self, s)\n     }\n     fn visit_struct_field(&mut self, s: &'v StructField) { walk_struct_field(self, s) }\n     fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n-                      generics: &'v Generics) {\n-        walk_enum_def(self, enum_definition, generics)\n+                      generics: &'v Generics, item_id: NodeId) {\n+        walk_enum_def(self, enum_definition, generics, item_id)\n+    }\n+    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n+        walk_variant(self, v, g, item_id)\n     }\n-\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) { walk_variant(self, v, g) }\n-\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n@@ -271,7 +272,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n-            visitor.visit_enum_def(enum_definition, type_parameters)\n+            visitor.visit_enum_def(enum_definition, type_parameters, item.id)\n         }\n         ItemDefaultImpl(_, ref trait_ref) => {\n             visitor.visit_trait_ref(trait_ref)\n@@ -288,10 +289,8 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_struct_def(struct_definition,\n-                                     item.ident,\n-                                     generics,\n-                                     item.id)\n+            visitor.visit_variant_data(struct_definition, item.ident,\n+                                     generics, item.id, item.span);\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n@@ -305,30 +304,20 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n-                                         generics: &'v Generics) {\n+                                         generics: &'v Generics,\n+                                         item_id: NodeId) {\n     for variant in &enum_definition.variants {\n-        visitor.visit_variant(variant, generics);\n+        visitor.visit_variant(variant, generics, item_id);\n     }\n }\n \n pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n-                                        generics: &'v Generics) {\n+                                        generics: &'v Generics,\n+                                        item_id: NodeId) {\n     visitor.visit_ident(variant.span, variant.node.name);\n-\n-    match variant.node.kind {\n-        TupleVariantKind(ref variant_arguments) => {\n-            for variant_argument in variant_arguments {\n-                visitor.visit_ty(&variant_argument.ty)\n-            }\n-        }\n-        StructVariantKind(ref struct_definition) => {\n-            visitor.visit_struct_def(struct_definition,\n-                                     variant.node.name,\n-                                     generics,\n-                                     variant.node.id)\n-        }\n-    }\n+    visitor.visit_variant_data(&variant.node.data, variant.node.name,\n+                             generics, item_id, variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n@@ -614,8 +603,8 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n }\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                           struct_definition: &'v StructDef) {\n-    walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n+                                           struct_definition: &'v VariantData) {\n+    walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,"}, {"sha": "e8e37d8804986b60894687371c1fa997363475de", "filename": "src/test/compile-fail/deriving-primitive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -23,12 +23,12 @@ struct B(isize);\n \n #[derive(FromPrimitive)]\n enum C { Foo(isize), Bar(usize) }\n-//~^^ ERROR `FromPrimitive` cannot be derived for enum variants with arguments\n-//~^^^ ERROR `FromPrimitive` cannot be derived for enum variants with arguments\n+//~^^ ERROR `FromPrimitive` cannot be derived for enums with non-unit variants\n+//~^^^ ERROR `FromPrimitive` cannot be derived for enums with non-unit variants\n \n #[derive(FromPrimitive)]\n enum D { Baz { x: isize } }\n-//~^^ ERROR `FromPrimitive` cannot be derived for enums with struct variants\n-//~^^^ ERROR `FromPrimitive` cannot be derived for enums with struct variants\n+//~^^ ERROR `FromPrimitive` cannot be derived for enums with non-unit variants\n+//~^^^ ERROR `FromPrimitive` cannot be derived for enums with non-unit variants\n \n pub fn main() {}"}, {"sha": "67167086b9c4a8ac546bd17c5793a04652f57d3c", "filename": "src/test/compile-fail/empty-struct-braces-expr.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Can't use empty braced struct as constant or constructor function\n+\n+#![feature(braced_empty_structs)]\n+\n+struct Empty1 {}\n+\n+enum E {\n+    Empty2 {}\n+}\n+\n+fn main() {\n+    let e1 = Empty1; //~ ERROR `Empty1` is the name of a struct or struct variant\n+    let e1 = Empty1(); //~ ERROR `Empty1` is the name of a struct or struct variant\n+    let e2 = E::Empty2; //~ ERROR `E::Empty2` is the name of a struct or struct variant\n+    let e2 = E::Empty2(); //~ ERROR `E::Empty2` is the name of a struct or struct variant\n+}"}, {"sha": "a131b46e1c19b9687b32adaf772678eca6aa5d73", "filename": "src/test/compile-fail/empty-struct-braces-gate-1.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-gate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-gate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-gate-1.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -9,13 +9,15 @@\n // except according to those terms.\n \n // Feature gate test for empty struct with braces\n+// Can't define an empty braced struct\n \n-struct Empty {} //~ ERROR empty structs with braces are unstable\n+struct Empty1 {} //~ ERROR empty structs and enum variants with braces are unstable\n+struct Empty2;\n \n-fn main() {\n-    let e = Empty {}; //~ ERROR empty structs with braces are unstable\n+enum E {\n+    Empty4 {}, //~ ERROR empty structs and enum variants with braces are unstable\n+    Empty5,\n+}\n \n-    match e {\n-        Empty {} => {} //~ ERROR empty structs with braces are unstable\n-    }\n+fn main() {\n }", "previous_filename": "src/test/compile-fail/empty-struct-with-braces-3.rs"}, {"sha": "c1b73bdc96a8f14e7eb26b48f589fde64c08bf34", "filename": "src/test/compile-fail/empty-struct-braces-gate-2.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-gate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-gate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-gate-2.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Feature gate test for empty struct with braces\n+// Can't use braced expressions and patterns with structs defined without braces\n+\n+struct Empty2;\n+\n+enum E {\n+    Empty5,\n+}\n+\n+fn main() {\n+    let e2: Empty2 = Empty2 {}; //~ ERROR empty structs and enum variants with braces are unstable\n+    let e2: Empty2 = Empty2;\n+    // Issue #28692\n+    // let e5: E = E::Empty5 {}; // ERROR empty structs and enum variants with braces are unstable\n+    let e5: E = E::Empty5;\n+\n+    match e2 {\n+        Empty2 {} => {} //~ ERROR empty structs and enum variants with braces are unstable\n+    }\n+    match e2 {\n+        Empty2 => {}\n+    }\n+    match e2 {\n+        Empty2 { .. } => {} //~ ERROR empty structs and enum variants with braces are unstable\n+    }\n+    // Issue #28692\n+    // match e5 {\n+    //     E::Empty5 {} => {} // ERROR empty structs and enum variants with braces are unstable\n+    // }\n+    match e5 {\n+        E::Empty5 => {}\n+    }\n+    // Issue #28692\n+    // match e5 {\n+    //     E::Empty5 { .. } => {} // ERROR empty structs and enum variants with braces are unstable\n+    // }\n+\n+    let e22 = Empty2 { ..e2 }; //~ ERROR empty structs and enum variants with braces are unstable\n+}"}, {"sha": "e095f69ed7da67e12fb93ccb1f56f195b3ad2752", "filename": "src/test/compile-fail/empty-struct-braces-pat-1.rs", "status": "renamed", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -8,18 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Empty struct defined with braces shouldn't add names into value namespace\n+// Can't use empty braced struct as constant pattern\n \n-#![feature(braced_empty_structs)]\n #![deny(warnings)]\n+#![feature(braced_empty_structs)]\n \n-struct Empty {}\n+struct Empty1 {}\n+\n+enum E {\n+    Empty2 {}\n+}\n \n fn main() {\n-    let e = Empty {};\n+    let e1 = Empty1 {};\n+    let e2 = E::Empty2 {};\n \n-    match e {\n-        Empty => () //~ ERROR unused variable: `Empty`\n-        //~^ ERROR variable `Empty` should have a snake case name such as `empty`\n+    // Issue #28692\n+    // match e1 {\n+    //     Empty1 => () // ERROR incorrect error\n+    // }\n+    match e2 {\n+        E::Empty2 => () //~ ERROR `E::Empty2` does not name a non-struct variant or a tuple struct\n     }\n }", "previous_filename": "src/test/compile-fail/empty-struct-with-braces-2.rs"}, {"sha": "0e7152ec89a81ea3b81be01742eaf725a2e3c693", "filename": "src/test/compile-fail/empty-struct-braces-pat-2.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Can't use empty braced struct as enum pattern\n+\n+#![feature(braced_empty_structs)]\n+\n+struct Empty1 {}\n+\n+enum E {\n+    Empty2 {}\n+}\n+\n+fn main() {\n+    let e1 = Empty1 {};\n+    let e2 = E::Empty2 {};\n+\n+    // Rejected by parser as yet\n+    // match e1 {\n+    //     Empty1() => () // ERROR unresolved enum variant, struct or const `Empty1`\n+    // }\n+    match e1 {\n+        Empty1(..) => () //~ ERROR unresolved enum variant, struct or const `Empty1`\n+    }\n+    // Issue #28692\n+    // match e2 {\n+    //     E::Empty2() => () // ERROR unresolved enum variant, struct or const `Empty2`\n+    // }\n+    // match e2 {\n+    //     E::Empty2(..) => () // ERROR unresolved enum variant, struct or const `Empty2`\n+    // }\n+}"}, {"sha": "199065665b9f65842c236516a22872f08da35071", "filename": "src/test/compile-fail/empty-struct-unit-expr.rs", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-expr.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -8,12 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Empty struct defined with braces shouldn't add names into value namespace\n+// Can't use unit struct as constructor function\n \n #![feature(braced_empty_structs)]\n \n-struct Empty {}\n+struct Empty1;\n+\n+enum E {\n+    Empty2\n+}\n \n fn main() {\n-    let e = Empty; //~ ERROR `Empty` is the name of a struct or struct variant\n+    let e1 = Empty1(); //~ ERROR expected function, found `Empty1`\n+    let e2 = E::Empty2(); //~ ERROR expected function, found `E`\n }", "previous_filename": "src/test/compile-fail/empty-struct-with-braces-1.rs"}, {"sha": "966a2780f9f8c130c9bb4b5faab1313f7eced448", "filename": "src/test/compile-fail/empty-struct-unit-pat.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Can't use unit struct as enum pattern\n+\n+#![feature(braced_empty_structs)]\n+\n+FIXME //~ ERROR expected item, found `FIXME`\n+\n+struct Empty1;\n+\n+enum E {\n+    Empty2\n+}\n+\n+fn main() {\n+    let e1 = Empty1;\n+    let e2 = E::Empty2;\n+\n+    // Issue #28692\n+    // match e1 {\n+    //     Empty1() => () // ERROR variable `Empty1` should have a snake case name\n+    // }\n+    // match e1 {\n+    //     Empty1(..) => () // ERROR variable `Empty1` should have a snake case name\n+    // }\n+    // match e2 {\n+    //     E::Empty2() => () // ERROR variable `Empty2` should have a snake case name\n+    // }\n+    // match e2 {\n+    //     E::Empty2(..) => () // ERROR variable `Empty2` should have a snake case name\n+    // }\n+}"}, {"sha": "065b29d29aca53fdf1d07b3d61c67836fd967b5c", "filename": "src/test/compile-fail/issue-16819.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fissue-16819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fissue-16819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16819.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+struct TS ( //~ ERROR empty tuple structs and enum variants are not allowed\n+    #[cfg(untrue)]\n+    int,\n+);\n \n-enum Foo {\n-    Bar {} //~ ERROR unit-like struct variant should be written without braces, as `Bar,`\n+fn main() {\n+    let s = S;\n }", "previous_filename": "src/test/parse-fail/struct-variant-no-fields.rs"}, {"sha": "3cdb370f0e94c9156e62c52061ab7bb6a5c00601", "filename": "src/test/compile-fail/issue-27831.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -22,8 +22,8 @@ fn main() {\n     let Foo { .. } = x; //~ ERROR `Foo` does not name a struct\n \n     let x = Bar;\n-    Bar { ..x };\n-    let Bar { .. } = x;\n+    Bar { ..x }; //~ ERROR empty structs and enum variants with braces are unstable\n+    let Bar { .. } = x; //~ ERROR empty structs and enum variants with braces are unstable\n \n     match Enum::Bar {\n         Enum::Bar { .. } //~ ERROR `Enum::Bar` does not name a struct"}, {"sha": "6bdbae1e4b9d91009839352a8fb5f7113d6423da", "filename": "src/test/compile-fail/struct-no-fields-enumlike.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-enumlike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-enumlike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-enumlike.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n-struct Foo(); //~ ERROR unit-like struct definition should be written as `struct Foo;`\n+struct Foo(); //~ ERROR empty tuple structs and enum variants are not allowed\n \n fn main() {}", "previous_filename": "src/test/parse-fail/struct-no-fields-enumlike.rs"}, {"sha": "f2fbf2dd337e7d7a3fa2e2f9d4a80af319933768", "filename": "src/test/run-pass/empty-struct-braces.rs", "status": "renamed", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293966694c3c8e0c7028e8f54340fbc328d85bff/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs?ref=293966694c3c8e0c7028e8f54340fbc328d85bff", "patch": "@@ -18,39 +18,71 @@ struct Empty2;\n struct Empty3 {}\n const Empty3: Empty3 = Empty3 {};\n \n+enum E {\n+    Empty4 {},\n+    Empty5,\n+}\n+\n fn main() {\n     let e1: Empty1 = Empty1 {};\n     let e2: Empty2 = Empty2 {};\n     let e2: Empty2 = Empty2;\n     let e3: Empty3 = Empty3 {};\n     let e3: Empty3 = Empty3;\n+    let e4: E = E::Empty4 {};\n+    // let e5: E = E::Empty5 {}; // Issue #28692\n+    let e5: E = E::Empty5;\n \n     match e1 {\n-        Empty1 {} => ()\n-    }\n-    match e2 {\n-        Empty2 {} => ()\n+        Empty1 {} => {}\n     }\n     match e2 {\n-        Empty2 => ()\n+        Empty2 {} => {}\n     }\n     match e3 {\n-        Empty3 {} => ()\n+        Empty3 {} => {}\n     }\n-    match e3 {\n-        Empty3 => ()\n+    match e4 {\n+        E::Empty4 {} => {}\n+        _ => {}\n     }\n+    // Issue #28692\n+    // match e5 {\n+    //     E::Empty5 {} => {}\n+    //     _ => {}\n+    // }\n+\n     match e1 {\n-        Empty1 { .. } => ()\n+        Empty1 { .. } => {}\n     }\n     match e2 {\n-        Empty2 { .. } => ()\n+        Empty2 { .. } => {}\n     }\n     match e3 {\n-        Empty3 { .. } => ()\n+        Empty3 { .. } => {}\n+    }\n+    match e4 {\n+        E::Empty4 { .. } => {}\n+        _ => {}\n+    }\n+    // Issue #28692\n+    // match e5 {\n+    //     E::Empty5 { .. } => {}\n+    //     _ => {}\n+    // }\n+\n+    match e2 {\n+        Empty2 => {}\n+    }\n+    match e3 {\n+        Empty3 => {}\n+    }\n+    match e5 {\n+        E::Empty5 => {}\n+        _ => {}\n     }\n \n-    let e11 = Empty1 { ..e1 };\n-    let e22 = Empty2 { ..e2 };\n-    let e33 = Empty3 { ..e3 };\n+    let e11: Empty1 = Empty1 { ..e1 };\n+    let e22: Empty2 = Empty2 { ..e2 };\n+    let e33: Empty3 = Empty3 { ..e3 };\n }", "previous_filename": "src/test/run-pass/empty-struct-with-braces.rs"}]}