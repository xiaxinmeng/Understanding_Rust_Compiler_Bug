{"sha": "08d7fc76cf6b2fac291cecd7185af818940092e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDdmYzc2Y2Y2YjJmYWMyOTFjZWNkNzE4NWFmODE4OTQwMDkyZTQ=", "commit": {"author": {"name": "wickerwaka", "email": "martin.donlon@gmail.com", "date": "2014-08-15T04:44:55Z"}, "committer": {"name": "wickerwaka", "email": "martin.donlon@gmail.com", "date": "2014-08-15T13:34:24Z"}, "message": "Change how libgetopts handles options grouped together\n\nAs soon as an option is found that takes an argument, consume the rest\nof the string and store it into i_arg. Previously this would only happen\nif the character after the option was not a recognized option.\n\nAddresses issue #16348", "tree": {"sha": "49a057339ce16e4469332142e9f85564eea9eedc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49a057339ce16e4469332142e9f85564eea9eedc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d7fc76cf6b2fac291cecd7185af818940092e4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d7fc76cf6b2fac291cecd7185af818940092e4", "html_url": "https://github.com/rust-lang/rust/commit/08d7fc76cf6b2fac291cecd7185af818940092e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d7fc76cf6b2fac291cecd7185af818940092e4/comments", "author": null, "committer": null, "parents": [{"sha": "1d12b6d444ec083466020777be5bb9f19e9a6d3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d12b6d444ec083466020777be5bb9f19e9a6d3a", "html_url": "https://github.com/rust-lang/rust/commit/1d12b6d444ec083466020777be5bb9f19e9a6d3a"}], "stats": {"total": 55, "additions": 33, "deletions": 22}, "files": [{"sha": "d0c06f8e6ba2df0edc6c8c893249bbb93e2779c3", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/08d7fc76cf6b2fac291cecd7185af818940092e4/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d7fc76cf6b2fac291cecd7185af818940092e4/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=08d7fc76cf6b2fac291cecd7185af818940092e4", "patch": "@@ -567,7 +567,6 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 }\n             } else {\n                 let mut j = 1;\n-                let mut last_valid_opt_id = None;\n                 names = Vec::new();\n                 while j < curlen {\n                     let range = cur.as_slice().char_range_at(j);\n@@ -580,27 +579,24 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                        interpreted correctly\n                     */\n \n-                    match find_opt(opts.as_slice(), opt.clone()) {\n-                      Some(id) => last_valid_opt_id = Some(id),\n-                      None => {\n-                        let arg_follows =\n-                            last_valid_opt_id.is_some() &&\n-                            match opts[last_valid_opt_id.unwrap()]\n-                              .hasarg {\n-\n-                              Yes | Maybe => true,\n-                              No => false\n-                            };\n-                        if arg_follows && j < curlen {\n-                            i_arg = Some(cur.as_slice()\n-                                            .slice(j, curlen).to_string());\n-                            break;\n-                        } else {\n-                            last_valid_opt_id = None;\n-                        }\n-                      }\n-                    }\n+                    let opt_id = match find_opt(opts.as_slice(), opt.clone()) {\n+                      Some(id) => id,\n+                      None => return Err(UnrecognizedOption(opt.to_string()))\n+                    };\n+\n                     names.push(opt);\n+\n+                    let arg_follows = match opts[opt_id].hasarg {\n+                        Yes | Maybe => true,\n+                        No => false\n+                    };\n+\n+                    if arg_follows && range.next < curlen {\n+                        i_arg = Some(cur.as_slice()\n+                                        .slice(range.next, curlen).to_string());\n+                        break;\n+                    }\n+\n                     j = range.next;\n                 }\n             }\n@@ -613,7 +609,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 };\n                 match opts[optid].hasarg {\n                   No => {\n-                    if !i_arg.is_none() {\n+                    if name_pos == names.len() && !i_arg.is_none() {\n                         return Err(UnexpectedArgument(nm.to_string()));\n                     }\n                     vals.get_mut(optid).push(Given);\n@@ -1437,6 +1433,21 @@ mod tests {\n \n     }\n \n+    #[test]\n+    fn test_nospace_conflict() {\n+        let args = vec!(\"-vvLverbose\".to_string(), \"-v\".to_string() );\n+        let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                     optflagmulti(\"v\", \"verbose\", \"Verbose\"));\n+        let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n+          result::Ok(m) => m,\n+          result::Err(e) => fail!( \"{}\", e )\n+        };\n+        assert!(matches.opts_present([\"L\".to_string()]));\n+        assert_eq!(matches.opts_str([\"L\".to_string()]).unwrap(), \"verbose\".to_string());\n+        assert!(matches.opts_present([\"v\".to_string()]));\n+        assert_eq!(3, matches.opt_count(\"v\"));\n+    }\n+\n     #[test]\n     fn test_long_to_short() {\n         let mut short = Opt {"}]}