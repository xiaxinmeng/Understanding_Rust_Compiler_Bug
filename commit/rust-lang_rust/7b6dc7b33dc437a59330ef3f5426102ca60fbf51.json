{"sha": "7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNmRjN2IzM2RjNDM3YTU5MzMwZWYzZjU0MjYxMDJjYTYwZmJmNTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-19T13:14:52Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-06-07T19:09:47Z"}, "message": "add `unnested_or_patterns` lint", "tree": {"sha": "bbc8a68763b2536ff08a379edb6182819b4a3960", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbc8a68763b2536ff08a379edb6182819b4a3960"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEqv54U47RUUXZfOLnLO/Nsn7QvnkFAl7dO44ACgkQLO/Nsn7Q\nvnm7ww//a6vd69QzzXNB9PC+aNGL1sUGk0TNW/lhhkTmMKR0b+ZdHRf63aUMOAYw\nRSq/jBr2owhAgcmmVVzLtS6vex4SRmhPDakqkMMIqgN143aUBnUIhVVOUmmDdCL3\nMuNhAG8XRPR7C5Tnnb+FgSveQ0ra9VvWXmnFV2qJKpgYGIhvg8pZsFkcC5h3VtaR\nD2L9KMbnNXCWiRVrMRqOJmj3zSuGDBWSmXZbgF822fluWYi/shjGNmo3HM+N5a9p\n+/nSb5Luz/P5MKPcccUauHBRXQ1ybo5E2YY3EzKlrYDkob+kZYYf9UplEUoVtbvb\nxe/iJjq6bYNalgrETJ/tzxj1M51cdGok854jcY7a/P+2Y4Z1GVqS347RGCxoD7S/\nKPRRcPubWbqnWnSA3hnafC7RlKbKaj0oKq8hjA0pMOVNoJTtKBRelYrurOIM9RKZ\nV8Nbh3fwCsgu9NEHOS5ZK4oqB0lhu7FsH7bsXu61b7YzNI3m4jEDJI6jDcAQRcfZ\nk47mDmAUskPv5hz72ZM/+bs0gKCBQ98peUkBuxIbTB0vtSPjHxtJtrKFxE65eIfq\nQJDe8M1Jds7BJ6wlSKatwDwPrKk6z3amIdNg9SGKIJPZPBr1Mpdy+OZZHkAHfHCD\na7CKJBVAdr1eq3I96wGorjQ9FRPaKCIsAEJsU7ILOuRvVl7qY50=\n=blw0\n-----END PGP SIGNATURE-----", "payload": "tree bbc8a68763b2536ff08a379edb6182819b4a3960\nparent 67ec96c8f97ae810f72ccc08c8bf0c371ff11305\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584623692 +0100\ncommitter flip1995 <hello@philkrones.com> 1591556987 +0200\n\nadd `unnested_or_patterns` lint\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "html_url": "https://github.com/rust-lang/rust/commit/7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67ec96c8f97ae810f72ccc08c8bf0c371ff11305", "url": "https://api.github.com/repos/rust-lang/rust/commits/67ec96c8f97ae810f72ccc08c8bf0c371ff11305", "html_url": "https://github.com/rust-lang/rust/commit/67ec96c8f97ae810f72ccc08c8bf0c371ff11305"}], "stats": {"total": 1334, "additions": 1314, "deletions": 20}, "files": [{"sha": "adc945a69441d5a59fb288d31f98f66c979bb904", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -1683,6 +1683,7 @@ Released 2018-09-13\n [`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n [`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern\n [`unneeded_wildcard_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_wildcard_pattern\n+[`unnested_or_patterns`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnested_or_patterns\n [`unreachable`]: https://rust-lang.github.io/rust-clippy/master/index.html#unreachable\n [`unreadable_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#unreadable_literal\n [`unsafe_derive_deserialize`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_derive_deserialize"}, {"sha": "9809f953d6705148556f5ad8b718eda3878115f0", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -1,5 +1,6 @@\n // error-pattern:cargo-clippy\n \n+#![feature(bindings_after_at)]\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n #![feature(or_patterns)]\n@@ -12,6 +13,7 @@\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![feature(crate_visibility_modifier)]\n #![feature(concat_idents)]\n+#![feature(drain_filter)]\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n@@ -319,6 +321,7 @@ mod types;\n mod unicode;\n mod unnamed_address;\n mod unnecessary_sort_by;\n+mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_io_amount;\n mod unused_self;\n@@ -836,6 +839,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unnamed_address::FN_ADDRESS_COMPARISONS,\n         &unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n         &unnecessary_sort_by::UNNECESSARY_SORT_BY,\n+        &unnested_or_patterns::UNNESTED_OR_PATTERNS,\n         &unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n         &unused_io_amount::UNUSED_IO_AMOUNT,\n         &unused_self::UNUSED_SELF,\n@@ -1073,6 +1077,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold,\n     });\n+    store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1433,6 +1438,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n         LintId::of(&unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n+        LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n@@ -1616,6 +1622,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n+        LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&zero_div_zero::ZERO_DIVIDED_BY_ZERO),"}, {"sha": "2723af03c0b9865a733f3b730905aade4bf6c140", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -0,0 +1,407 @@\n+#![allow(clippy::wildcard_imports, clippy::enum_glob_use)]\n+\n+use crate::utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path};\n+use crate::utils::{over, span_lint_and_then};\n+use rustc_ast::ast::{self, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n+use rustc_ast::mut_visit::*;\n+use rustc_ast::ptr::P;\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::DUMMY_SP;\n+\n+use std::cell::Cell;\n+use std::mem;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    ///\n+    /// Checks for unnested or-patterns, e.g., `Some(0) | Some(2)` and\n+    /// suggests replacing the pattern with a nested one, `Some(0 | 2)`.\n+    ///\n+    /// Another way to think of this is that it rewrites patterns in\n+    /// *disjunctive normal form (DNF)* into *conjunctive normal form (CNF)*.\n+    ///\n+    /// **Why is this bad?**\n+    ///\n+    /// In the example above, `Some` is repeated, which unncessarily complicates the pattern.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn main() {\n+    ///     if let Some(0) | Some(2) = Some(0) {}\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #![feature(or_patterns)]\n+    ///\n+    /// fn main() {\n+    ///     if let Some(0 | 2) = Some(0) {}\n+    /// }\n+    /// ```\n+    pub UNNESTED_OR_PATTERNS,\n+    complexity,\n+    \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\"\n+}\n+\n+declare_lint_pass!(UnnestedOrPatterns => [UNNESTED_OR_PATTERNS]);\n+\n+impl EarlyLintPass for UnnestedOrPatterns {\n+    fn check_arm(&mut self, cx: &EarlyContext<'_>, a: &ast::Arm) {\n+        lint_unnested_or_patterns(cx, &a.pat);\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        if let ast::ExprKind::Let(pat, _) = &e.kind {\n+            lint_unnested_or_patterns(cx, pat);\n+        }\n+    }\n+\n+    fn check_param(&mut self, cx: &EarlyContext<'_>, p: &ast::Param) {\n+        lint_unnested_or_patterns(cx, &p.pat);\n+    }\n+\n+    fn check_local(&mut self, cx: &EarlyContext<'_>, l: &ast::Local) {\n+        lint_unnested_or_patterns(cx, &l.pat);\n+    }\n+}\n+\n+fn lint_unnested_or_patterns(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if !cx.sess.opts.unstable_features.is_nightly_build() {\n+        // User cannot do `#![feature(or_patterns)]`, so bail.\n+        return;\n+    }\n+\n+    if let Ident(.., None) | Lit(_) | Wild | Path(..) | Range(..) | Rest | MacCall(_) = pat.kind {\n+        // This is a leaf pattern, so cloning is unprofitable.\n+        return;\n+    }\n+\n+    let mut pat = P(pat.clone());\n+\n+    // Nix all the paren patterns everywhere so that they aren't in our way.\n+    remove_all_parens(&mut pat);\n+\n+    // Transform all unnested or-patterns into nested ones, and if there were none, quit.\n+    if !unnest_or_patterns(&mut pat) {\n+        return;\n+    }\n+\n+    span_lint_and_then(cx, UNNESTED_OR_PATTERNS, pat.span, \"unnested or-patterns\", |db| {\n+        insert_necessary_parens(&mut pat);\n+        db.span_suggestion_verbose(\n+            pat.span,\n+            \"nest the patterns\",\n+            pprust::pat_to_string(&pat),\n+            Applicability::MachineApplicable,\n+        );\n+    });\n+}\n+\n+/// Remove all `(p)` patterns in `pat`.\n+fn remove_all_parens(pat: &mut P<Pat>) {\n+    struct Visitor;\n+    impl MutVisitor for Visitor {\n+        fn visit_pat(&mut self, pat: &mut P<Pat>) {\n+            noop_visit_pat(pat, self);\n+            let inner = match &mut pat.kind {\n+                Paren(i) => mem::replace(&mut i.kind, Wild),\n+                _ => return,\n+            };\n+            pat.kind = inner;\n+        }\n+    }\n+    Visitor.visit_pat(pat);\n+}\n+\n+/// Insert parens where necessary according to Rust's precedence rules for patterns.\n+fn insert_necessary_parens(pat: &mut P<Pat>) {\n+    struct Visitor;\n+    impl MutVisitor for Visitor {\n+        fn visit_pat(&mut self, pat: &mut P<Pat>) {\n+            use ast::{BindingMode::*, Mutability::*};\n+            noop_visit_pat(pat, self);\n+            let target = match &mut pat.kind {\n+                // `i @ a | b`, `box a | b`, and `& mut? a | b`.\n+                Ident(.., Some(p)) | Box(p) | Ref(p, _) if matches!(&p.kind, Or(ps) if ps.len() > 1) => p,\n+                Ref(p, Not) if matches!(p.kind, Ident(ByValue(Mut), ..)) => p, // `&(mut x)`\n+                _ => return,\n+            };\n+            target.kind = Paren(P(take_pat(target)));\n+        }\n+    }\n+    Visitor.visit_pat(pat);\n+}\n+\n+/// Unnest or-patterns `p0 | ... | p1` in the pattern `pat`.\n+/// For example, this would transform `Some(0) | FOO | Some(2)` into `Some(0 | 2) | FOO`.\n+fn unnest_or_patterns(pat: &mut P<Pat>) -> bool {\n+    struct Visitor {\n+        changed: bool,\n+    }\n+    impl MutVisitor for Visitor {\n+        fn visit_pat(&mut self, p: &mut P<Pat>) {\n+            // This is a bottom up transformation, so recurse first.\n+            noop_visit_pat(p, self);\n+\n+            // Don't have an or-pattern? Just quit early on.\n+            let alternatives = match &mut p.kind {\n+                Or(ps) => ps,\n+                _ => return,\n+            };\n+\n+            // Collapse or-patterns directly nested in or-patterns.\n+            let mut idx = 0;\n+            let mut this_level_changed = false;\n+            while idx < alternatives.len() {\n+                let inner = if let Or(ps) = &mut alternatives[idx].kind {\n+                    mem::take(ps)\n+                } else {\n+                    idx += 1;\n+                    continue;\n+                };\n+                this_level_changed = true;\n+                alternatives.splice(idx..=idx, inner);\n+            }\n+\n+            // Focus on `p_n` and then try to transform all `p_i` where `i > n`.\n+            let mut focus_idx = 0;\n+            while focus_idx < alternatives.len() {\n+                this_level_changed |= transform_with_focus_on_idx(alternatives, focus_idx);\n+                focus_idx += 1;\n+            }\n+            self.changed |= this_level_changed;\n+\n+            // Deal with `Some(Some(0)) | Some(Some(1))`.\n+            if this_level_changed {\n+                noop_visit_pat(p, self);\n+            }\n+        }\n+    }\n+\n+    let mut visitor = Visitor { changed: false };\n+    visitor.visit_pat(pat);\n+    visitor.changed\n+}\n+\n+/// Match `$scrutinee` against `$pat` and extract `$then` from it.\n+/// Panics if there is no match.\n+macro_rules! always_pat {\n+    ($scrutinee:expr, $pat:pat => $then:expr) => {\n+        match $scrutinee {\n+            $pat => $then,\n+            _ => unreachable!(),\n+        }\n+    };\n+}\n+\n+/// Focus on `focus_idx` in `alternatives`,\n+/// attempting to extend it with elements of the same constructor `C`\n+/// in `alternatives[focus_idx + 1..]`.\n+fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize) -> bool {\n+    // Extract the kind; we'll need to make some changes in it.\n+    let mut focus_kind = mem::replace(&mut alternatives[focus_idx].kind, PatKind::Wild);\n+    // We'll focus on `alternatives[focus_idx]`,\n+    // so we're draining from `alternatives[focus_idx + 1..]`.\n+    let start = focus_idx + 1;\n+\n+    // We're trying to find whatever kind (~\"constructor\") we found in `alternatives[start..]`.\n+    let changed = match &mut focus_kind {\n+        // These pattern forms are \"leafs\" and do not have sub-patterns.\n+        // Therefore they are not some form of constructor `C`,\n+        // with which a pattern `C(P0)` may be formed,\n+        // which we would want to join with other `C(Pj)`s.\n+        Ident(.., None) | Lit(_) | Wild | Path(..) | Range(..) | Rest | MacCall(_)\n+        // Dealt with elsewhere.\n+        | Or(_) | Paren(_) => false,\n+        // Transform `box x | ... | box y` into `box (x | y)`.\n+        //\n+        // The cases below until `Slice(...)` deal *singleton* products.\n+        // These patterns have the shape `C(p)`, and not e.g., `C(p0, ..., pn)`.\n+        Box(target) => extend_with_matching(\n+            target, start, alternatives,\n+            |k| matches!(k, Box(_)),\n+            |k| always_pat!(k, Box(p) => p),\n+        ),\n+        // Transform `&m x | ... | &m y` into `&m (x, y)`.\n+        Ref(target, m1) => extend_with_matching(\n+            target, start, alternatives,\n+            |k| matches!(k, Ref(_, m2) if m1 == m2), // Mutabilities must match.\n+            |k| always_pat!(k, Ref(p, _) => p),\n+        ),\n+        // Transform `b @ p0 | ... b @ p1` into `b @ (p0 | p1)`.\n+        Ident(b1, i1, Some(target)) => extend_with_matching(\n+            target, start, alternatives,\n+            // Binding names must match.\n+            |k| matches!(k, Ident(b2, i2, Some(_)) if b1 == b2 && eq_id(*i1, *i2)),\n+            |k| always_pat!(k, Ident(_, _, Some(p)) => p),\n+        ),\n+        // Transform `[pre, x, post] | ... | [pre, y, post]` into `[pre, x | y, post]`.\n+        Slice(ps1) => extend_with_matching_product(\n+            ps1, start, alternatives,\n+            |k, ps1, idx| matches!(k, Slice(ps2) if eq_pre_post(ps1, ps2, idx)),\n+            |k| always_pat!(k, Slice(ps) => ps),\n+        ),\n+        // Transform `(pre, x, post) | ... | (pre, y, post)` into `(pre, x | y, post]`.\n+        Tuple(ps1) => extend_with_matching_product(\n+            ps1, start, alternatives,\n+            |k, ps1, idx| matches!(k, Tuple(ps2) if eq_pre_post(ps1, ps2, idx)),\n+            |k| always_pat!(k, Tuple(ps) => ps),\n+        ),\n+        // Transform `S(pre, x, post) | ... | S(pre, y, post)` into `S(pre, x | y, post]`.\n+        TupleStruct(path1, ps1) => extend_with_matching_product(\n+            ps1, start, alternatives,\n+            |k, ps1, idx| matches!(\n+                k,\n+                TupleStruct(path2, ps2) if eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n+            ),\n+            |k| always_pat!(k, TupleStruct(_, ps) => ps),\n+        ),\n+        // Transform a record pattern `S { fp_0, ..., fp_n }`.\n+        Struct(path1, fps1, rest1) => extend_with_struct_pat(path1, fps1, *rest1, start, alternatives),\n+    };\n+\n+    alternatives[focus_idx].kind = focus_kind;\n+    changed\n+}\n+\n+/// Here we focusing on a record pattern `S { fp_0, ..., fp_n }`.\n+/// In particular, for a record pattern, the order in which the field patterns is irrelevant.\n+/// So when we fixate on some `ident_k: pat_k`, we try to find `ident_k` in the other pattern\n+/// and check that all `fp_i` where `i \u2208 ((0...n) \\ k)` between two patterns are equal.\n+fn extend_with_struct_pat(\n+    path1: &ast::Path,\n+    fps1: &mut Vec<ast::FieldPat>,\n+    rest1: bool,\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+) -> bool {\n+    (0..fps1.len()).any(|idx| {\n+        let pos_in_2 = Cell::new(None); // The element `k`.\n+        let tail_or = drain_matching(\n+            start,\n+            alternatives,\n+            |k| {\n+                matches!(k, Struct(path2, fps2, rest2)\n+                if rest1 == *rest2 // If one struct pattern has `..` so must the other.\n+                && eq_path(path1, path2)\n+                && fps1.len() == fps2.len()\n+                && fps1.iter().enumerate().all(|(idx_1, fp1)| {\n+                    if idx_1 == idx {\n+                        // In the case of `k`, we merely require identical field names\n+                        // so that we will transform into `ident_k: p1_k | p2_k`.\n+                        let pos = fps2.iter().position(|fp2| eq_id(fp1.ident, fp2.ident));\n+                        pos_in_2.set(pos);\n+                        pos.is_some()\n+                    } else {\n+                        fps2.iter().any(|fp2| eq_field_pat(fp1, fp2))\n+                    }\n+                }))\n+            },\n+            // Extract `p2_k`.\n+            |k| always_pat!(k, Struct(_, mut fps, _) => fps.swap_remove(pos_in_2.take().unwrap()).pat),\n+        );\n+        extend_with_tail_or(&mut fps1[idx].pat, tail_or)\n+    })\n+}\n+\n+/// Like `extend_with_matching` but for products with > 1 factor, e.g., `C(p_0, ..., p_n)`.\n+/// Here, the idea is that we fixate on some `p_k` in `C`,\n+/// allowing it to vary between two `targets` and `ps2` (returned by `extract`),\n+/// while also requiring `ps1[..n] ~ ps2[..n]` (pre) and `ps1[n + 1..] ~ ps2[n + 1..]` (post),\n+/// where `~` denotes semantic equality.\n+fn extend_with_matching_product(\n+    targets: &mut Vec<P<Pat>>,\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+    predicate: impl Fn(&PatKind, &[P<Pat>], usize) -> bool,\n+    extract: impl Fn(PatKind) -> Vec<P<Pat>>,\n+) -> bool {\n+    (0..targets.len()).any(|idx| {\n+        let tail_or = drain_matching(\n+            start,\n+            alternatives,\n+            |k| predicate(k, targets, idx),\n+            |k| extract(k).swap_remove(idx),\n+        );\n+        extend_with_tail_or(&mut targets[idx], tail_or)\n+    })\n+}\n+\n+/// Extract the pattern from the given one and replace it with `Wild`.\n+/// This is meant for temporarily swapping out the pattern for manipulation.\n+fn take_pat(from: &mut Pat) -> Pat {\n+    let dummy = Pat {\n+        id: DUMMY_NODE_ID,\n+        kind: Wild,\n+        span: DUMMY_SP,\n+    };\n+    mem::replace(from, dummy)\n+}\n+\n+/// Extend `target` as an or-pattern with the alternatives\n+/// in `tail_or` if there are any and return if there were.\n+fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n+    fn extend(target: &mut Pat, mut tail_or: Vec<P<Pat>>) {\n+        match target {\n+            // On an existing or-pattern in the target, append to it.\n+            Pat { kind: Or(ps), .. } => ps.append(&mut tail_or),\n+            // Otherwise convert the target to an or-pattern.\n+            target => {\n+                let mut init_or = vec![P(take_pat(target))];\n+                init_or.append(&mut tail_or);\n+                target.kind = Or(init_or);\n+            },\n+        }\n+    }\n+\n+    let changed = !tail_or.is_empty();\n+    if changed {\n+        // Extend the target.\n+        extend(target, tail_or);\n+    }\n+    changed\n+}\n+\n+// Extract all inner patterns in `alternatives` matching our `predicate`.\n+// Only elements beginning with `start` are considered for extraction.\n+fn drain_matching(\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+    predicate: impl Fn(&PatKind) -> bool,\n+    extract: impl Fn(PatKind) -> P<Pat>,\n+) -> Vec<P<Pat>> {\n+    let mut tail_or = vec![];\n+    let mut idx = 0;\n+    for pat in alternatives.drain_filter(|p| {\n+        // Check if we should extract, but only if `idx >= start`.\n+        idx += 1;\n+        idx > start && predicate(&p.kind)\n+    }) {\n+        tail_or.push(extract(pat.into_inner().kind));\n+    }\n+    tail_or\n+}\n+\n+fn extend_with_matching(\n+    target: &mut Pat,\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+    predicate: impl Fn(&PatKind) -> bool,\n+    extract: impl Fn(PatKind) -> P<Pat>,\n+) -> bool {\n+    extend_with_tail_or(target, drain_matching(start, alternatives, predicate, extract))\n+}\n+\n+/// Are the patterns in `ps1` and `ps2` equal save for `ps1[idx]` compared to `ps2[idx]`?\n+fn eq_pre_post(ps1: &[P<Pat>], ps2: &[P<Pat>], idx: usize) -> bool {\n+    ps1[idx].is_rest() == ps2[idx].is_rest() // Avoid `[x, ..] | [x, 0]` => `[x, .. | 0]`.\n+        && ps1.len() == ps2.len()\n+        && over(&ps1[..idx], &ps2[..idx], |l, r| eq_pat(l, r))\n+        && over(&ps1[idx + 1..], &ps2[idx + 1..], |l, r| eq_pat(l, r))\n+}"}, {"sha": "69a7b6c051e3b62bf44de83b0865e26ca6ed5f57", "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -0,0 +1,525 @@\n+//! Utilities for manipulating and extracting information from `rustc_ast::ast`.\n+//!\n+//! - The `eq_foobar` functions test for semantic equality but ignores `NodeId`s and `Span`s.\n+\n+#![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n+\n+use crate::utils::{both, over};\n+use rustc_ast::ast::{self, *};\n+use rustc_ast::ptr::P;\n+use std::mem;\n+\n+/// Checks if each element in the first slice is contained within the latter as per `eq_fn`.\n+pub fn unordered_over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n+    left.len() == right.len() && left.iter().all(|l| right.iter().any(|r| eq_fn(l, r)))\n+}\n+\n+pub fn eq_id(l: Ident, r: Ident) -> bool {\n+    l.name == r.name\n+}\n+\n+pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n+    use PatKind::*;\n+    match (&l.kind, &r.kind) {\n+        (Paren(l), _) => eq_pat(l, r),\n+        (_, Paren(r)) => eq_pat(l, r),\n+        (Wild, Wild) | (Rest, Rest) => true,\n+        (Lit(l), Lit(r)) => eq_expr(l, r),\n+        (Ident(b1, i1, s1), Ident(b2, i2, s2)) => b1 == b2 && eq_id(*i1, *i2) && both(s1, s2, |l, r| eq_pat(l, r)),\n+        (Range(lf, lt, le), Range(rf, rt, re)) => {\n+            eq_expr_opt(lf, rf) && eq_expr_opt(lt, rt) && eq_range_end(&le.node, &re.node)\n+        },\n+        (Box(l), Box(r))\n+        | (Ref(l, Mutability::Not), Ref(r, Mutability::Not))\n+        | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n+        (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (TupleStruct(lp, lfs), TupleStruct(rp, rfs)) => eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n+        (Struct(lp, lfs, lr), Struct(rp, rfs, rr)) => {\n+            lr == rr && eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+        },\n+        (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_range_end(l: &RangeEnd, r: &RangeEnd) -> bool {\n+    match (l, r) {\n+        (RangeEnd::Excluded, RangeEnd::Excluded) => true,\n+        (RangeEnd::Included(l), RangeEnd::Included(r)) => {\n+            matches!(l, RangeSyntax::DotDotEq) == matches!(r, RangeSyntax::DotDotEq)\n+        },\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_field_pat(l: &FieldPat, r: &FieldPat) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && eq_id(l.ident, r.ident)\n+        && eq_pat(&l.pat, &r.pat)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n+    l.position == r.position && eq_ty(&l.ty, &r.ty)\n+}\n+\n+pub fn eq_path(l: &Path, r: &Path) -> bool {\n+    over(&l.segments, &r.segments, |l, r| eq_path_seg(l, r))\n+}\n+\n+pub fn eq_path_seg(l: &PathSegment, r: &PathSegment) -> bool {\n+    eq_id(l.ident, r.ident) && both(&l.args, &r.args, |l, r| eq_generic_args(l, r))\n+}\n+\n+pub fn eq_generic_args(l: &GenericArgs, r: &GenericArgs) -> bool {\n+    match (l, r) {\n+        (GenericArgs::AngleBracketed(l), GenericArgs::AngleBracketed(r)) => {\n+            over(&l.args, &r.args, |l, r| eq_angle_arg(l, r))\n+        },\n+        (GenericArgs::Parenthesized(l), GenericArgs::Parenthesized(r)) => {\n+            over(&l.inputs, &r.inputs, |l, r| eq_ty(l, r)) && eq_fn_ret_ty(&l.output, &r.output)\n+        },\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_angle_arg(l: &AngleBracketedArg, r: &AngleBracketedArg) -> bool {\n+    match (l, r) {\n+        (AngleBracketedArg::Arg(l), AngleBracketedArg::Arg(r)) => eq_generic_arg(l, r),\n+        (AngleBracketedArg::Constraint(l), AngleBracketedArg::Constraint(r)) => eq_assoc_constraint(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_generic_arg(l: &GenericArg, r: &GenericArg) -> bool {\n+    match (l, r) {\n+        (GenericArg::Lifetime(l), GenericArg::Lifetime(r)) => eq_id(l.ident, r.ident),\n+        (GenericArg::Type(l), GenericArg::Type(r)) => eq_ty(l, r),\n+        (GenericArg::Const(l), GenericArg::Const(r)) => eq_expr(&l.value, &r.value),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_expr_opt(l: &Option<P<Expr>>, r: &Option<P<Expr>>) -> bool {\n+    both(l, r, |l, r| eq_expr(l, r))\n+}\n+\n+pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n+    use ExprKind::*;\n+    if !over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r)) {\n+        return false;\n+    }\n+    match (&l.kind, &r.kind) {\n+        (Paren(l), _) => eq_expr(l, r),\n+        (_, Paren(r)) => eq_expr(l, r),\n+        (Err, Err) => true,\n+        (Box(l), Box(r)) | (Try(l), Try(r)) | (Await(l), Await(r)) => eq_expr(l, r),\n+        (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n+        (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n+        (MethodCall(lc, la), MethodCall(rc, ra)) => eq_path_seg(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n+        (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n+        (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n+        (Lit(l), Lit(r)) => l.kind == r.kind,\n+        (Cast(l, lt), Cast(r, rt)) | (Type(l, lt), Type(r, rt)) => eq_expr(l, r) && eq_ty(lt, rt),\n+        (Let(lp, le), Let(rp, re)) => eq_pat(lp, rp) && eq_expr(le, re),\n+        (If(lc, lt, le), If(rc, rt, re)) => eq_expr(lc, rc) && eq_block(lt, rt) && eq_expr_opt(le, re),\n+        (While(lc, lt, ll), While(rc, rt, rl)) => eq_label(ll, rl) && eq_expr(lc, rc) && eq_block(lt, rt),\n+        (ForLoop(lp, li, lt, ll), ForLoop(rp, ri, rt, rl)) => {\n+            eq_label(ll, rl) && eq_pat(lp, rp) && eq_expr(li, ri) && eq_block(lt, rt)\n+        },\n+        (Loop(lt, ll), Loop(rt, rl)) => eq_label(ll, rl) && eq_block(lt, rt),\n+        (Block(lb, ll), Block(rb, rl)) => eq_label(ll, rl) && eq_block(lb, rb),\n+        (TryBlock(l), TryBlock(r)) => eq_block(l, r),\n+        (Yield(l), Yield(r)) | (Ret(l), Ret(r)) => eq_expr_opt(l, r),\n+        (Break(ll, le), Break(rl, re)) => eq_label(ll, rl) && eq_expr_opt(le, re),\n+        (Continue(ll), Continue(rl)) => eq_label(ll, rl),\n+        (Assign(l1, l2, _), Assign(r1, r2, _)) | (Index(l1, l2), Index(r1, r2)) => eq_expr(l1, r1) && eq_expr(l2, r2),\n+        (AssignOp(lo, lp, lv), AssignOp(ro, rp, rv)) => lo.node == ro.node && eq_expr(lp, rp) && eq_expr(lv, rv),\n+        (Field(lp, lf), Field(rp, rf)) => eq_id(*lf, *rf) && eq_expr(lp, rp),\n+        (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, |l, r| eq_arm(l, r)),\n+        (Closure(lc, la, lm, lf, lb, _), Closure(rc, ra, rm, rf, rb, _)) => {\n+            lc == rc && la.is_async() == ra.is_async() && lm == rm && eq_fn_decl(lf, rf) && eq_expr(lb, rb)\n+        },\n+        (Async(lc, _, lb), Async(rc, _, rb)) => lc == rc && eq_block(lb, rb),\n+        (Range(lf, lt, ll), Range(rf, rt, rl)) => ll == rl && eq_expr_opt(lf, rf) && eq_expr_opt(lt, rt),\n+        (AddrOf(lbk, lm, le), AddrOf(rbk, rm, re)) => lbk == rbk && lm == rm && eq_expr(le, re),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        (Struct(lp, lfs, lb), Struct(rp, rfs, rb)) => {\n+            eq_path(lp, rp) && eq_expr_opt(lb, rb) && unordered_over(lfs, rfs, |l, r| eq_field(l, r))\n+        },\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_field(l: &Field, r: &Field) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && eq_id(l.ident, r.ident)\n+        && eq_expr(&l.expr, &r.expr)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_arm(l: &Arm, r: &Arm) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && eq_pat(&l.pat, &r.pat)\n+        && eq_expr(&l.body, &r.body)\n+        && eq_expr_opt(&l.guard, &r.guard)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_label(l: &Option<Label>, r: &Option<Label>) -> bool {\n+    both(l, r, |l, r| eq_id(l.ident, r.ident))\n+}\n+\n+pub fn eq_block(l: &Block, r: &Block) -> bool {\n+    l.rules == r.rules && over(&l.stmts, &r.stmts, |l, r| eq_stmt(l, r))\n+}\n+\n+pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n+    use StmtKind::*;\n+    match (&l.kind, &r.kind) {\n+        (Local(l), Local(r)) => {\n+            eq_pat(&l.pat, &r.pat)\n+                && both(&l.ty, &r.ty, |l, r| eq_ty(l, r))\n+                && eq_expr_opt(&l.init, &r.init)\n+                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        },\n+        (Item(l), Item(r)) => eq_item(l, r, eq_item_kind),\n+        (Expr(l), Expr(r)) | (Semi(l), Semi(r)) => eq_expr(l, r),\n+        (Empty, Empty) => true,\n+        (MacCall(l), MacCall(r)) => l.1 == r.1 && eq_mac_call(&l.0, &r.0) && over(&l.2, &r.2, |l, r| eq_attr(l, r)),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_item<K>(l: &Item<K>, r: &Item<K>, mut eq_kind: impl FnMut(&K, &K) -> bool) -> bool {\n+    eq_id(l.ident, r.ident)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && eq_vis(&l.vis, &r.vis)\n+        && eq_kind(&l.kind, &r.kind)\n+}\n+\n+pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n+    use ItemKind::*;\n+    match (l, r) {\n+        (ExternCrate(l), ExternCrate(r)) => l == r,\n+        (Use(l), Use(r)) => eq_use_tree(l, r),\n+        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n+        (Mod(l), Mod(r)) => l.inline == r.inline && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_item_kind)),\n+        (ForeignMod(l), ForeignMod(r)) => {\n+            both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n+                && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n+        },\n+        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && both(lt, rt, |l, r| eq_ty(l, r))\n+        },\n+        (Enum(le, lg), Enum(re, rg)) => {\n+            over(&le.variants, &re.variants, |l, r| eq_variant(l, r)) && eq_generics(lg, rg)\n+        },\n+        (Struct(lv, lg), Struct(rv, rg)) | (Union(lv, lg), Union(rv, rg)) => {\n+            eq_variant_data(lv, rv) && eq_generics(lg, rg)\n+        },\n+        (Trait(la, lu, lg, lb, li), Trait(ra, ru, rg, rb, ri)) => {\n+            la == ra\n+                && matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n+        },\n+        (TraitAlias(lg, lb), TraitAlias(rg, rb)) => eq_generics(lg, rg) && over(lb, rb, |l, r| eq_generic_bound(l, r)),\n+        (\n+            Impl {\n+                unsafety: lu,\n+                polarity: lp,\n+                defaultness: ld,\n+                constness: lc,\n+                generics: lg,\n+                of_trait: lot,\n+                self_ty: lst,\n+                items: li,\n+            },\n+            Impl {\n+                unsafety: ru,\n+                polarity: rp,\n+                defaultness: rd,\n+                constness: rc,\n+                generics: rg,\n+                of_trait: rot,\n+                self_ty: rst,\n+                items: ri,\n+            },\n+        ) => {\n+            matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n+                && matches!(lp, ImplPolarity::Positive) == matches!(rp, ImplPolarity::Positive)\n+                && eq_defaultness(*ld, *rd)\n+                && matches!(lc, ast::Const::No) == matches!(rc, ast::Const::No)\n+                && eq_generics(lg, rg)\n+                && both(lot, rot, |l, r| eq_path(&l.path, &r.path))\n+                && eq_ty(lst, rst)\n+                && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n+        },\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_mac_args(&l.body, &r.body),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n+    use ForeignItemKind::*;\n+    match (l, r) {\n+        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n+        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && both(lt, rt, |l, r| eq_ty(l, r))\n+        },\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n+    use AssocItemKind::*;\n+    match (l, r) {\n+        (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n+        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && both(lt, rt, |l, r| eq_ty(l, r))\n+        },\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_variant(l: &Variant, r: &Variant) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && eq_vis(&l.vis, &r.vis)\n+        && eq_id(l.ident, r.ident)\n+        && eq_variant_data(&l.data, &r.data)\n+        && both(&l.disr_expr, &r.disr_expr, |l, r| eq_expr(&l.value, &r.value))\n+}\n+\n+pub fn eq_variant_data(l: &VariantData, r: &VariantData) -> bool {\n+    use VariantData::*;\n+    match (l, r) {\n+        (Unit(_), Unit(_)) => true,\n+        (Struct(l, _), Struct(r, _)) | (Tuple(l, _), Tuple(r, _)) => over(l, r, |l, r| eq_struct_field(l, r)),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_struct_field(l: &StructField, r: &StructField) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && eq_vis(&l.vis, &r.vis)\n+        && both(&l.ident, &r.ident, |l, r| eq_id(*l, *r))\n+        && eq_ty(&l.ty, &r.ty)\n+}\n+\n+pub fn eq_fn_sig(l: &FnSig, r: &FnSig) -> bool {\n+    eq_fn_decl(&l.decl, &r.decl) && eq_fn_header(&l.header, &r.header)\n+}\n+\n+pub fn eq_fn_header(l: &FnHeader, r: &FnHeader) -> bool {\n+    matches!(l.unsafety, Unsafe::No) == matches!(r.unsafety, Unsafe::No)\n+        && l.asyncness.is_async() == r.asyncness.is_async()\n+        && matches!(l.constness, Const::No) == matches!(r.constness, Const::No)\n+        && eq_ext(&l.ext, &r.ext)\n+}\n+\n+pub fn eq_generics(l: &Generics, r: &Generics) -> bool {\n+    over(&l.params, &r.params, |l, r| eq_generic_param(l, r))\n+        && over(&l.where_clause.predicates, &r.where_clause.predicates, |l, r| {\n+            eq_where_predicate(l, r)\n+        })\n+}\n+\n+pub fn eq_where_predicate(l: &WherePredicate, r: &WherePredicate) -> bool {\n+    use WherePredicate::*;\n+    match (l, r) {\n+        (BoundPredicate(l), BoundPredicate(r)) => {\n+            over(&l.bound_generic_params, &r.bound_generic_params, |l, r| {\n+                eq_generic_param(l, r)\n+            }) && eq_ty(&l.bounded_ty, &r.bounded_ty)\n+                && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        },\n+        (RegionPredicate(l), RegionPredicate(r)) => {\n+            eq_id(l.lifetime.ident, r.lifetime.ident) && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        },\n+        (EqPredicate(l), EqPredicate(r)) => eq_ty(&l.lhs_ty, &r.lhs_ty) && eq_ty(&l.rhs_ty, &r.rhs_ty),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_use_tree(l: &UseTree, r: &UseTree) -> bool {\n+    eq_path(&l.prefix, &r.prefix) && eq_use_tree_kind(&l.kind, &r.kind)\n+}\n+\n+pub fn eq_use_tree_kind(l: &UseTreeKind, r: &UseTreeKind) -> bool {\n+    use UseTreeKind::*;\n+    match (l, r) {\n+        (Glob, Glob) => true,\n+        (Simple(l, _, _), Simple(r, _, _)) => both(l, r, |l, r| eq_id(*l, *r)),\n+        (Nested(l), Nested(r)) => over(l, r, |(l, _), (r, _)| eq_use_tree(l, r)),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_defaultness(l: Defaultness, r: Defaultness) -> bool {\n+    match (l, r) {\n+        (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)) => true,\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_vis(l: &Visibility, r: &Visibility) -> bool {\n+    use VisibilityKind::*;\n+    match (&l.node, &r.node) {\n+        (Public, Public) | (Inherited, Inherited) | (Crate(_), Crate(_)) => true,\n+        (Restricted { path: l, .. }, Restricted { path: r, .. }) => eq_path(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_fn_decl(l: &FnDecl, r: &FnDecl) -> bool {\n+    eq_fn_ret_ty(&l.output, &r.output)\n+        && over(&l.inputs, &r.inputs, |l, r| {\n+            l.is_placeholder == r.is_placeholder\n+                && eq_pat(&l.pat, &r.pat)\n+                && eq_ty(&l.ty, &r.ty)\n+                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        })\n+}\n+\n+pub fn eq_fn_ret_ty(l: &FnRetTy, r: &FnRetTy) -> bool {\n+    match (l, r) {\n+        (FnRetTy::Default(_), FnRetTy::Default(_)) => true,\n+        (FnRetTy::Ty(l), FnRetTy::Ty(r)) => eq_ty(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_ty(l: &Ty, r: &Ty) -> bool {\n+    use TyKind::*;\n+    match (&l.kind, &r.kind) {\n+        (Paren(l), _) => eq_ty(l, r),\n+        (_, Paren(r)) => eq_ty(l, r),\n+        (Never, Never) | (Infer, Infer) | (ImplicitSelf, ImplicitSelf) | (Err, Err) | (CVarArgs, CVarArgs) => true,\n+        (Slice(l), Slice(r)) => eq_ty(l, r),\n+        (Array(le, ls), Array(re, rs)) => eq_ty(le, re) && eq_expr(&ls.value, &rs.value),\n+        (Ptr(l), Ptr(r)) => l.mutbl == r.mutbl && eq_ty(&l.ty, &r.ty),\n+        (Rptr(ll, l), Rptr(rl, r)) => {\n+            both(ll, rl, |l, r| eq_id(l.ident, r.ident)) && l.mutbl == r.mutbl && eq_ty(&l.ty, &r.ty)\n+        },\n+        (BareFn(l), BareFn(r)) => {\n+            l.unsafety == r.unsafety\n+                && eq_ext(&l.ext, &r.ext)\n+                && over(&l.generic_params, &r.generic_params, |l, r| eq_generic_param(l, r))\n+                && eq_fn_decl(&l.decl, &r.decl)\n+        },\n+        (Tup(l), Tup(r)) => over(l, r, |l, r| eq_ty(l, r)),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (TraitObject(lg, ls), TraitObject(rg, rs)) => ls == rs && over(lg, rg, |l, r| eq_generic_bound(l, r)),\n+        (ImplTrait(_, lg), ImplTrait(_, rg)) => over(lg, rg, |l, r| eq_generic_bound(l, r)),\n+        (Typeof(l), Typeof(r)) => eq_expr(&l.value, &r.value),\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_ext(l: &Extern, r: &Extern) -> bool {\n+    use Extern::*;\n+    match (l, r) {\n+        (None, None) | (Implicit, Implicit) => true,\n+        (Explicit(l), Explicit(r)) => eq_str_lit(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_str_lit(l: &StrLit, r: &StrLit) -> bool {\n+    l.style == r.style && l.symbol == r.symbol && l.suffix == r.suffix\n+}\n+\n+pub fn eq_poly_ref_trait(l: &PolyTraitRef, r: &PolyTraitRef) -> bool {\n+    eq_path(&l.trait_ref.path, &r.trait_ref.path)\n+        && over(&l.bound_generic_params, &r.bound_generic_params, |l, r| {\n+            eq_generic_param(l, r)\n+        })\n+}\n+\n+pub fn eq_generic_param(l: &GenericParam, r: &GenericParam) -> bool {\n+    use GenericParamKind::*;\n+    l.is_placeholder == r.is_placeholder\n+        && eq_id(l.ident, r.ident)\n+        && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        && match (&l.kind, &r.kind) {\n+            (Lifetime, Lifetime) => true,\n+            (Type { default: l }, Type { default: r }) => both(l, r, |l, r| eq_ty(l, r)),\n+            (Const { ty: l }, Const { ty: r }) => eq_ty(l, r),\n+            _ => false,\n+        }\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_generic_bound(l: &GenericBound, r: &GenericBound) -> bool {\n+    use GenericBound::*;\n+    match (l, r) {\n+        (Trait(ptr1, tbm1), Trait(ptr2, tbm2)) => tbm1 == tbm2 && eq_poly_ref_trait(ptr1, ptr2),\n+        (Outlives(l), Outlives(r)) => eq_id(l.ident, r.ident),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_assoc_constraint(l: &AssocTyConstraint, r: &AssocTyConstraint) -> bool {\n+    use AssocTyConstraintKind::*;\n+    eq_id(l.ident, r.ident)\n+        && match (&l.kind, &r.kind) {\n+            (Equality { ty: l }, Equality { ty: r }) => eq_ty(l, r),\n+            (Bound { bounds: l }, Bound { bounds: r }) => over(l, r, |l, r| eq_generic_bound(l, r)),\n+            _ => false,\n+        }\n+}\n+\n+pub fn eq_mac_call(l: &MacCall, r: &MacCall) -> bool {\n+    eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args)\n+}\n+\n+pub fn eq_attr(l: &Attribute, r: &Attribute) -> bool {\n+    use AttrKind::*;\n+    l.style == r.style\n+        && match (&l.kind, &r.kind) {\n+            (DocComment(l), DocComment(r)) => l == r,\n+            (Normal(l), Normal(r)) => eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args),\n+            _ => false,\n+        }\n+}\n+\n+pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n+    use MacArgs::*;\n+    match (l, r) {\n+        (Empty, Empty) => true,\n+        (Delimited(_, ld, lts), Delimited(_, rd, rts)) => ld == rd && lts.eq_unspanned(rts),\n+        (Eq(_, lts), Eq(_, rts)) => lts.eq_unspanned(rts),\n+        _ => false,\n+    }\n+}"}, {"sha": "f8d197c15e8d698986a466e9bcfcf0d8fdf0cb76", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -332,19 +332,13 @@ fn swap_binop<'a>(\n \n /// Checks if the two `Option`s are both `None` or some equal values as per\n /// `eq_fn`.\n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n-where\n-    F: FnMut(&X, &X) -> bool,\n-{\n+pub fn both<X>(l: &Option<X>, r: &Option<X>, mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n     l.as_ref()\n         .map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n }\n \n /// Checks if two slices are equal as per `eq_fn`.\n-fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n-where\n-    F: FnMut(&X, &X) -> bool,\n-{\n+pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n "}, {"sha": "8f8aff622f49032b8992056882d7195eec832d14", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -1,6 +1,7 @@\n #[macro_use]\n pub mod sym;\n \n+pub mod ast_utils;\n pub mod attrs;\n pub mod author;\n pub mod camel_case;\n@@ -19,7 +20,7 @@ pub mod sugg;\n pub mod usage;\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n-pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{both, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n use std::mem;"}, {"sha": "745d543a4cc7a1bd4700be37325cdc17f0503d5b", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -2327,6 +2327,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"misc_early\",\n     },\n+    Lint {\n+        name: \"unnested_or_patterns\",\n+        group: \"complexity\",\n+        desc: \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\",\n+        deprecation: None,\n+        module: \"unnested_or_patterns\",\n+    },\n     Lint {\n         name: \"unreachable\",\n         group: \"restriction\","}, {"sha": "ca70e3b7148efd20c55403dff54ab2ed3515337a", "filename": "tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -4,6 +4,7 @@\n \n use std::cmp::Ordering;\n \n+#[allow(clippy::unnested_or_patterns)]\n #[warn(clippy::neg_cmp_op_on_partial_ord)]\n fn main() {\n     let a_value = 1.0;"}, {"sha": "8c5d548222e0dc789aeb3bc980bb980cc21058d4", "filename": "tests/ui/neg_cmp_op_on_partial_ord.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -1,25 +1,25 @@\n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:15:21\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:16:21\n    |\n LL |     let _not_less = !(a_value < another_value);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::neg-cmp-op-on-partial-ord` implied by `-D warnings`\n \n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:18:30\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:19:30\n    |\n LL |     let _not_less_or_equal = !(a_value <= another_value);\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:21:24\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:22:24\n    |\n LL |     let _not_greater = !(a_value > another_value);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:24:33\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:25:33\n    |\n LL |     let _not_greater_or_equal = !(a_value >= another_value);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e1bd5cd5562d3fca83c430aed04f2d6d0a653e4b", "filename": "tests/ui/unnested_or_patterns.fixed", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Funnested_or_patterns.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Funnested_or_patterns.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnested_or_patterns.fixed?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+#![warn(clippy::unnested_or_patterns)]\n+#![allow(clippy::cognitive_complexity, clippy::match_ref_pats)]\n+#![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n+\n+fn main() {\n+    if let box (0 | 2) = Box::new(0) {}\n+    if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+    const C0: &u8 = &1;\n+    if let &(0 | 2) | C0 = &0 {}\n+    if let &mut (0 | 2) = &mut 0 {}\n+    if let x @ (0 | 2) = 0 {}\n+    if let (0, 1 | 2 | 3) = (0, 0) {}\n+    if let (1 | 2 | 3, 0) = (0, 0) {}\n+    if let (x, ..) | (x, 1 | 2) = (0, 1) {}\n+    if let [0 | 1] = [0] {}\n+    if let [x, 0 | 1] = [0, 1] {}\n+    if let [x, 0 | 1 | 2] = [0, 1] {}\n+    if let [x, ..] | [x, 1 | 2] = [0, 1] {}\n+    struct TS(u8, u8);\n+    if let TS(0 | 1, x) = TS(0, 0) {}\n+    if let TS(1 | 2 | 3, 0) = TS(0, 0) {}\n+    if let TS(x, ..) | TS(x, 1 | 2) = TS(0, 0) {}\n+    struct S {\n+        x: u8,\n+        y: u8,\n+    }\n+    if let S { x: 0 | 1, y } = (S { x: 0, y: 1 }) {}\n+    if let S { x: 0, y, .. } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+    if let Some(Some(0 | 1)) = None {}\n+    if let Some(Some(0 | 1 | 2)) = None {}\n+    if let Some(Some(0 | 1 | 2 | 3 | 4)) = None {}\n+    if let Some(Some(0 | 1 | 2)) = None {}\n+    if let ((0 | 1 | 2,),) = ((0,),) {}\n+    if let 0 | 1 | 2 = 0 {}\n+    if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+    if let box box (0 | 2 | 4) = Box::new(Box::new(0)) {}\n+}"}, {"sha": "d5c3c1fb74a2d54d9db6b85fabe6a1ccdc73b973", "filename": "tests/ui/unnested_or_patterns.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnested_or_patterns.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+#![warn(clippy::unnested_or_patterns)]\n+#![allow(clippy::cognitive_complexity, clippy::match_ref_pats)]\n+#![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n+\n+fn main() {\n+    if let box 0 | box 2 = Box::new(0) {}\n+    if let box ((0 | 1)) | box (2 | 3) | box 4 = Box::new(0) {}\n+    const C0: &u8 = &1;\n+    if let &0 | C0 | &2 = &0 {}\n+    if let &mut 0 | &mut 2 = &mut 0 {}\n+    if let x @ 0 | x @ 2 = 0 {}\n+    if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}\n+    if let (1, 0) | (2, 0) | (3, 0) = (0, 0) {}\n+    if let (x, ..) | (x, 1) | (x, 2) = (0, 1) {}\n+    if let [0] | [1] = [0] {}\n+    if let [x, 0] | [x, 1] = [0, 1] {}\n+    if let [x, 0] | [x, 1] | [x, 2] = [0, 1] {}\n+    if let [x, ..] | [x, 1] | [x, 2] = [0, 1] {}\n+    struct TS(u8, u8);\n+    if let TS(0, x) | TS(1, x) = TS(0, 0) {}\n+    if let TS(1, 0) | TS(2, 0) | TS(3, 0) = TS(0, 0) {}\n+    if let TS(x, ..) | TS(x, 1) | TS(x, 2) = TS(0, 0) {}\n+    struct S {\n+        x: u8,\n+        y: u8,\n+    }\n+    if let S { x: 0, y } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+    if let S { x: 0, y, .. } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+    if let Some(Some(0)) | Some(Some(1)) = None {}\n+    if let Some(Some(0)) | Some(Some(1) | Some(2)) = None {}\n+    if let Some(Some(0 | 1) | Some(2)) | Some(Some(3) | Some(4)) = None {}\n+    if let Some(Some(0) | Some(1 | 2)) = None {}\n+    if let ((0,),) | ((1,) | (2,),) = ((0,),) {}\n+    if let 0 | (1 | 2) = 0 {}\n+    if let box (0 | 1) | (box 2 | box (3 | 4)) = Box::new(0) {}\n+    if let box box 0 | box (box 2 | box 4) = Box::new(Box::new(0)) {}\n+}"}, {"sha": "d1efe274c99248308d7f861ca6457d28cccfb8b5", "filename": "tests/ui/unnested_or_patterns.stderr", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Funnested_or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Funnested_or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnested_or_patterns.stderr?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -0,0 +1,267 @@\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:10:12\n+   |\n+LL |     if let box 0 | box 2 = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnested-or-patterns` implied by `-D warnings`\n+help: nest the patterns\n+   |\n+LL |     if let box (0 | 2) = Box::new(0) {}\n+   |            ^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:11:12\n+   |\n+LL |     if let box ((0 | 1)) | box (2 | 3) | box 4 = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:13:12\n+   |\n+LL |     if let &0 | C0 | &2 = &0 {}\n+   |            ^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let &(0 | 2) | C0 = &0 {}\n+   |            ^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:14:12\n+   |\n+LL |     if let &mut 0 | &mut 2 = &mut 0 {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let &mut (0 | 2) = &mut 0 {}\n+   |            ^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:15:12\n+   |\n+LL |     if let x @ 0 | x @ 2 = 0 {}\n+   |            ^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let x @ (0 | 2) = 0 {}\n+   |            ^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:16:12\n+   |\n+LL |     if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let (0, 1 | 2 | 3) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:17:12\n+   |\n+LL |     if let (1, 0) | (2, 0) | (3, 0) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let (1 | 2 | 3, 0) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:18:12\n+   |\n+LL |     if let (x, ..) | (x, 1) | (x, 2) = (0, 1) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let (x, ..) | (x, 1 | 2) = (0, 1) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:19:12\n+   |\n+LL |     if let [0] | [1] = [0] {}\n+   |            ^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [0 | 1] = [0] {}\n+   |            ^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:20:12\n+   |\n+LL |     if let [x, 0] | [x, 1] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [x, 0 | 1] = [0, 1] {}\n+   |            ^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:21:12\n+   |\n+LL |     if let [x, 0] | [x, 1] | [x, 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [x, 0 | 1 | 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:22:12\n+   |\n+LL |     if let [x, ..] | [x, 1] | [x, 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [x, ..] | [x, 1 | 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:24:12\n+   |\n+LL |     if let TS(0, x) | TS(1, x) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let TS(0 | 1, x) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:25:12\n+   |\n+LL |     if let TS(1, 0) | TS(2, 0) | TS(3, 0) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let TS(1 | 2 | 3, 0) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:26:12\n+   |\n+LL |     if let TS(x, ..) | TS(x, 1) | TS(x, 2) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let TS(x, ..) | TS(x, 1 | 2) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:31:12\n+   |\n+LL |     if let S { x: 0, y } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let S { x: 0 | 1, y } = (S { x: 0, y: 1 }) {}\n+   |            ^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:33:12\n+   |\n+LL |     if let Some(Some(0)) | Some(Some(1)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:34:12\n+   |\n+LL |     if let Some(Some(0)) | Some(Some(1) | Some(2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1 | 2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:35:12\n+   |\n+LL |     if let Some(Some(0 | 1) | Some(2)) | Some(Some(3) | Some(4)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1 | 2 | 3 | 4)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:36:12\n+   |\n+LL |     if let Some(Some(0) | Some(1 | 2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1 | 2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:37:12\n+   |\n+LL |     if let ((0,),) | ((1,) | (2,),) = ((0,),) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let ((0 | 1 | 2,),) = ((0,),) {}\n+   |            ^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:38:12\n+   |\n+LL |     if let 0 | (1 | 2) = 0 {}\n+   |            ^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let 0 | 1 | 2 = 0 {}\n+   |            ^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:39:12\n+   |\n+LL |     if let box (0 | 1) | (box 2 | box (3 | 4)) = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:40:12\n+   |\n+LL |     if let box box 0 | box (box 2 | box 4) = Box::new(Box::new(0)) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let box box (0 | 2 | 4) = Box::new(Box::new(0)) {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 24 previous errors\n+"}, {"sha": "4f8754a930120ecb55e1675788fa9b6d042d2369", "filename": "tests/ui/wildcard_enum_match_arm.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.fixed?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -6,7 +6,8 @@\n     unused_variables,\n     dead_code,\n     clippy::single_match,\n-    clippy::wildcard_in_or_patterns\n+    clippy::wildcard_in_or_patterns,\n+    clippy::unnested_or_patterns\n )]\n \n use std::io::ErrorKind;"}, {"sha": "5e66644ceca0ff202a14b221730e905e7bc8d1bb", "filename": "tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.rs?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -6,7 +6,8 @@\n     unused_variables,\n     dead_code,\n     clippy::single_match,\n-    clippy::wildcard_in_or_patterns\n+    clippy::wildcard_in_or_patterns,\n+    clippy::unnested_or_patterns\n )]\n \n use std::io::ErrorKind;"}, {"sha": "e03b3be43ed236ddc1bbe5e82234054f3f16263a", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b6dc7b33dc437a59330ef3f5426102ca60fbf51/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=7b6dc7b33dc437a59330ef3f5426102ca60fbf51", "patch": "@@ -1,5 +1,5 @@\n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:37:9\n+  --> $DIR/wildcard_enum_match_arm.rs:38:9\n    |\n LL |         _ => eprintln!(\"Not red\"),\n    |         ^ help: try this: `Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n@@ -11,25 +11,25 @@ LL | #![deny(clippy::wildcard_enum_match_arm)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:41:9\n+  --> $DIR/wildcard_enum_match_arm.rs:42:9\n    |\n LL |         _not_red => eprintln!(\"Not red\"),\n    |         ^^^^^^^^ help: try this: `_not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:45:9\n+  --> $DIR/wildcard_enum_match_arm.rs:46:9\n    |\n LL |         not_red => format!(\"{:?}\", not_red),\n    |         ^^^^^^^ help: try this: `not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:61:9\n+  --> $DIR/wildcard_enum_match_arm.rs:62:9\n    |\n LL |         _ => \"No red\",\n    |         ^ help: try this: `Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n \n error: match on non-exhaustive enum doesn't explicitly match all known variants\n-  --> $DIR/wildcard_enum_match_arm.rs:78:9\n+  --> $DIR/wildcard_enum_match_arm.rs:79:9\n    |\n LL |         _ => {},\n    |         ^ help: try this: `std::io::ErrorKind::PermissionDenied | std::io::ErrorKind::ConnectionRefused | std::io::ErrorKind::ConnectionReset | std::io::ErrorKind::ConnectionAborted | std::io::ErrorKind::NotConnected | std::io::ErrorKind::AddrInUse | std::io::ErrorKind::AddrNotAvailable | std::io::ErrorKind::BrokenPipe | std::io::ErrorKind::AlreadyExists | std::io::ErrorKind::WouldBlock | std::io::ErrorKind::InvalidInput | std::io::ErrorKind::InvalidData | std::io::ErrorKind::TimedOut | std::io::ErrorKind::WriteZero | std::io::ErrorKind::Interrupted | std::io::ErrorKind::Other | std::io::ErrorKind::UnexpectedEof | _`"}]}