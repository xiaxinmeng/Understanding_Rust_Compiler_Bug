{"sha": "7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MjBjMTVhZTExMTQxZTJiMWEyYTNhNTYwYjFjZGFjYjZkZGFkYTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-18T22:53:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:56:54Z"}, "message": "test: Implement pidigits and reverse-complement", "tree": {"sha": "b620e06ded65e24eda01986c5b22bf32d0d8ca18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b620e06ded65e24eda01986c5b22bf32d0d8ca18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "html_url": "https://github.com/rust-lang/rust/commit/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc0dd7f1083681375aa7fdfeacf8ad3e3942ce2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0dd7f1083681375aa7fdfeacf8ad3e3942ce2a", "html_url": "https://github.com/rust-lang/rust/commit/bc0dd7f1083681375aa7fdfeacf8ad3e3942ce2a"}], "stats": {"total": 328, "additions": 328, "deletions": 0}, "files": [{"sha": "722d72ece816474600fd63719590ab96e3db0092", "filename": "src/test/bench/shootout-pidigits.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "patch": "@@ -0,0 +1,176 @@\n+use core::cast::transmute;\n+use core::from_str::FromStr;\n+use core::libc::{STDOUT_FILENO, c_char, c_int, c_uint, c_void, fdopen, fputc};\n+use core::libc::{fputs};\n+use core::ptr::null;\n+\n+struct mpz_t {\n+    _mp_alloc: c_int,\n+    _mp_size: c_int,\n+    _mp_limb_t: *c_void,\n+}\n+\n+impl mpz_t {\n+    fn new() -> mpz_t {\n+        mpz_t {\n+            _mp_alloc: 0,\n+            _mp_size: 0,\n+            _mp_limb_t: null(),\n+        }\n+    }\n+}\n+\n+#[link_args=\"-lgmp\"]\n+extern {\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_add\"]\n+    fn mpz_add(x: *mpz_t, y: *mpz_t, z: *mpz_t);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_cmp\"]\n+    fn mpz_cmp(x: *mpz_t, y: *mpz_t) -> c_int;\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_fdiv_qr\"]\n+    fn mpz_fdiv_qr(a: *mpz_t, b: *mpz_t, c: *mpz_t, d: *mpz_t);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_get_ui\"]\n+    fn mpz_get_ui(x: *mpz_t) -> c_uint;\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_init\"]\n+    fn mpz_init(x: *mpz_t);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_init_set_ui\"]\n+    fn mpz_init_set_ui(x: *mpz_t, y: c_uint);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_mul_2exp\"]\n+    fn mpz_mul_2exp(x: *mpz_t, y: *mpz_t, z: c_uint);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_mul_ui\"]\n+    fn mpz_mul_ui(x: *mpz_t, y: *mpz_t, z: c_uint);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_submul_ui\"]\n+    fn mpz_submul_ui(x: *mpz_t, y: *mpz_t, z: c_uint);\n+}\n+\n+struct Context {\n+    numer: mpz_t,\n+    accum: mpz_t,\n+    denom: mpz_t,\n+    tmp1: mpz_t,\n+    tmp2: mpz_t,\n+}\n+\n+impl Context {\n+    fn new() -> Context {\n+        unsafe {\n+            let mut result = Context {\n+                numer: mpz_t::new(),\n+                accum: mpz_t::new(),\n+                denom: mpz_t::new(),\n+                tmp1: mpz_t::new(),\n+                tmp2: mpz_t::new(),\n+            };\n+            mpz_init(&result.tmp1);\n+            mpz_init(&result.tmp2);\n+            mpz_init_set_ui(&result.numer, 1);\n+            mpz_init_set_ui(&result.accum, 0);\n+            mpz_init_set_ui(&result.denom, 1);\n+            result\n+        }\n+    }\n+\n+    fn extract_digit(&mut self) -> i32 {\n+        unsafe {\n+            if mpz_cmp(&self.numer, &self.accum) > 0 {\n+                return -1;\n+            }\n+\n+            // Compute (numer * 3 + accum) / denom\n+            mpz_mul_2exp(&self.tmp1, &self.numer, 1);\n+            mpz_add(&self.tmp1, &self.tmp1, &self.numer);\n+            mpz_add(&self.tmp1, &self.tmp1, &self.accum);\n+            mpz_fdiv_qr(&self.tmp1, &self.tmp2, &self.tmp1, &self.denom);\n+\n+            // Now, if (numer * 4 + accum) % denom...\n+            mpz_add(&self.tmp2, &self.tmp2, &self.numer);\n+\n+            // ... is normalized, then the two divisions have the same result.\n+            if mpz_cmp(&self.tmp2, &self.denom) >= 0 {\n+                return -1;\n+            }\n+\n+            mpz_get_ui(&self.tmp1) as i32\n+        }\n+    }\n+\n+    fn next_term(&mut self, k: u32) {\n+        unsafe {\n+            let y2 = k*2 + 1;\n+\n+            mpz_mul_2exp(&self.tmp1, &self.numer, 1);\n+            mpz_add(&self.accum, &self.accum, &self.tmp1);\n+            mpz_mul_ui(&self.accum, &self.accum, y2);\n+            mpz_mul_ui(&self.numer, &self.numer, k);\n+            mpz_mul_ui(&self.denom, &self.denom, y2);\n+        }\n+    }\n+\n+    fn eliminate_digit(&mut self, d: u32) {\n+        unsafe {\n+            mpz_submul_ui(&self.accum, &self.denom, d);\n+            mpz_mul_ui(&self.accum, &self.accum, 10);\n+            mpz_mul_ui(&self.numer, &self.numer, 10);\n+        }\n+    }\n+}\n+\n+fn pidigits(n: u32) {\n+    unsafe {\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        let mut d: i32;\n+        let mut i: u32 = 0, k: u32 = 0, m: u32;\n+\n+        let mut context = Context::new();\n+        loop {\n+            loop {\n+                k += 1;\n+                context.next_term(k);\n+                d = context.extract_digit();\n+                if d != -1 {\n+                    break;\n+                }\n+            }\n+\n+            fputc((d as c_int) + ('0' as c_int), stdout);\n+\n+            i += 1;\n+            m = i % 10;\n+            if m == 0 {\n+                let res = fmt!(\"\\t:%d\\n\", i as int);\n+                fputs(transmute(&res[0]), stdout);\n+            }\n+            if i >= n {\n+                break;\n+            }\n+            context.eliminate_digit(d as u32);\n+        }\n+\n+        if m != 0 {\n+            m = 10 - m;\n+            while m != 0 {\n+                m -= 1;\n+                fputc(' ' as c_int, stdout);\n+            }\n+            let res = fmt!(\"\\t:%d\\n\", i as int);\n+            fputs(transmute(&res[0]), stdout);\n+        }\n+    }\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let n: u32 = FromStr::from_str(os::args()[1]).get();\n+    pidigits(n);\n+}\n+"}, {"sha": "21b1f8f3c82bef2364cf89f34ac4bed5ee75714b", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "patch": "@@ -0,0 +1,152 @@\n+use core::cast::transmute;\n+use core::libc::{STDOUT_FILENO, c_int, fdopen, fgets, fopen, fputc, fwrite};\n+use core::libc::{size_t};\n+use core::ptr::null;\n+use core::vec::{capacity, reserve, reserve_at_least};\n+use core::vec::raw::set_len;\n+\n+static LINE_LEN: u32 = 80;\n+\n+static COMPLEMENTS: [u8, ..256] = [\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0,\n+    'T' as u8,\n+    'V' as u8,\n+    'G' as u8,\n+    'H' as u8,\n+    0,\n+    0,\n+    'C' as u8,\n+    'D' as u8,\n+    0,\n+    0,\n+    'M' as u8,\n+    0,\n+    'K' as u8,\n+    'N' as u8,\n+    0,\n+    0,\n+    0,\n+    'Y' as u8,\n+    'S' as u8,\n+    'A' as u8,\n+    'A' as u8,\n+    'B' as u8,\n+    'W' as u8,\n+    0,\n+    'R' as u8,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+\n+    0,\n+    'T' as u8,\n+    'V' as u8,\n+    'G' as u8,\n+    'H' as u8,\n+    0,\n+    0,\n+    'C' as u8,\n+    'D' as u8,\n+    0,\n+    0,\n+    'M' as u8,\n+    0,\n+    'K' as u8,\n+    'N' as u8,\n+    0,\n+    0,\n+    0,\n+    'Y' as u8,\n+    'S' as u8,\n+    'A' as u8,\n+    'A' as u8,\n+    'B' as u8,\n+    'W' as u8,\n+    0,\n+    'R' as u8,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+];\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    unsafe {\n+        let mode = \"r\";\n+        //let stdin = fdopen(STDIN_FILENO as c_int, transmute(&mode[0]));\n+        let path = \"reversecomplement-input.txt\";\n+        let stdin = fopen(transmute(&path[0]), transmute(&mode[0]));\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        let mut out: ~[u8] = ~[];\n+        reserve(&mut out, 12777888);\n+        let mut pos = 0;\n+\n+        loop {\n+            let needed = pos + (LINE_LEN as uint) + 1;\n+            if capacity(&out) < needed {\n+                reserve_at_least(&mut out, needed);\n+            }\n+\n+            let mut ptr = out.unsafe_mut_ref(pos);\n+            if fgets(transmute(ptr), LINE_LEN as c_int, stdin) == null() {\n+                break;\n+            }\n+\n+            // Don't change lines that begin with '>' or ';'.\n+            let first = *ptr;\n+            if first == ('>' as u8) {\n+                while *ptr != 0 {\n+                    ptr = ptr.offset(1);\n+                }\n+                *ptr = '\\n' as u8;\n+\n+                pos = (ptr as uint) - (out.unsafe_ref(0) as uint);\n+                fwrite(transmute(out.unsafe_ref(0)),\n+                       1,\n+                       pos as size_t,\n+                       stdout);\n+\n+                pos = 0;\n+                loop;\n+            }\n+\n+            // Complement other lines.\n+            loop {\n+                let ch = *ptr;\n+                if ch == 0 {\n+                    break;\n+                }\n+                *ptr = COMPLEMENTS.unsafe_get(ch as uint);\n+                ptr = ptr.offset(1);\n+            }\n+            *ptr = '\\n' as u8;\n+\n+            pos = (ptr as uint) - (out.unsafe_ref(0) as uint);\n+        }\n+\n+        fwrite(transmute(out.unsafe_ref(0)), 1, pos as size_t, stdout);\n+    }\n+}\n+"}]}