{"sha": "16a5b3127a97424108180a79dcd4cd53a5646e24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YTViMzEyN2E5NzQyNDEwODE4MGE3OWRjZDRjZDUzYTU2NDZlMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T20:11:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T20:11:36Z"}, "message": "auto merge of #13670 : eddyb/rust/more-de-at, r=pcwalton", "tree": {"sha": "7ab522780bc733dbd3eb08034841e96be0ef5136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ab522780bc733dbd3eb08034841e96be0ef5136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16a5b3127a97424108180a79dcd4cd53a5646e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16a5b3127a97424108180a79dcd4cd53a5646e24", "html_url": "https://github.com/rust-lang/rust/commit/16a5b3127a97424108180a79dcd4cd53a5646e24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16a5b3127a97424108180a79dcd4cd53a5646e24/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c82eb5d4de012ccf38620f81d8655308d37e318", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c82eb5d4de012ccf38620f81d8655308d37e318", "html_url": "https://github.com/rust-lang/rust/commit/6c82eb5d4de012ccf38620f81d8655308d37e318"}, {"sha": "70f3409875be7c2d0f9d48092eb98f11ee734378", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f3409875be7c2d0f9d48092eb98f11ee734378", "html_url": "https://github.com/rust-lang/rust/commit/70f3409875be7c2d0f9d48092eb98f11ee734378"}], "stats": {"total": 5707, "additions": 2622, "deletions": 3085}, "files": [{"sha": "cf0e7e161c1fc3d89110fbe74134f1cffeb01ef4", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -299,7 +299,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         last_private_map: last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n-             middle::resolve::resolve_crate(&sess, lang_items, krate));\n+             middle::resolve::resolve_crate(&sess, &lang_items, krate));\n \n     // Discard MTWT tables that aren't required past resolution.\n     syntax::ext::mtwt::clear_tables();\n@@ -316,7 +316,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                 sess.diagnostic(), krate)));\n \n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n-                        freevars::annotate_freevars(def_map, krate));\n+                        freevars::annotate_freevars(&def_map, krate));\n \n     let region_map = time(time_passes, \"region resolution\", (), |_|\n                           middle::region::resolve_crate(&sess, krate));\n@@ -328,7 +328,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                             freevars, region_map, lang_items);\n \n     // passes are timed inside typeck\n-    let (method_map, vtable_map) = typeck::check_crate(&ty_cx, trait_map, krate);\n+    typeck::check_crate(&ty_cx, trait_map, krate);\n \n     time(time_passes, \"check static items\", (), |_|\n          middle::check_static::check_crate(&ty_cx, krate));\n@@ -338,56 +338,52 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::const_eval::process_crate(krate, &ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(krate, def_map, method_map, &ty_cx));\n+         middle::check_const::check_crate(krate, &ty_cx));\n \n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 middle::privacy::check_crate(&ty_cx, &method_map, &exp_map2,\n-                                              a, b, krate));\n+                 middle::privacy::check_crate(&ty_cx, &exp_map2, a, b, krate));\n \n     time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(&ty_cx, method_map, krate));\n+         middle::effect::check_crate(&ty_cx, krate));\n \n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n         time(time_passes, \"compute moves\", (), |_|\n-             middle::moves::compute_moves(&ty_cx, method_map, krate));\n+             middle::moves::compute_moves(&ty_cx, krate));\n \n     time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(&ty_cx, method_map,\n-                                          &moves_map, krate));\n+         middle::check_match::check_crate(&ty_cx, &moves_map, krate));\n \n     time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(&ty_cx, method_map,\n-                                       &capture_map, krate));\n+         middle::liveness::check_crate(&ty_cx, &capture_map, krate));\n \n     let root_map =\n         time(time_passes, \"borrow checking\", (), |_|\n-             middle::borrowck::check_crate(&ty_cx, method_map,\n-                                           &moves_map, &moved_variables_set,\n+             middle::borrowck::check_crate(&ty_cx, &moves_map,\n+                                           &moved_variables_set,\n                                            &capture_map, krate));\n \n     drop(moves_map);\n     drop(moved_variables_set);\n \n     time(time_passes, \"kind checking\", (), |_|\n-         kind::check_crate(&ty_cx, method_map, krate));\n+         kind::check_crate(&ty_cx, krate));\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n-             reachable::find_reachable(&ty_cx, method_map, &exported_items));\n+             reachable::find_reachable(&ty_cx, &exported_items));\n \n     time(time_passes, \"death checking\", (), |_| {\n         middle::dead::check_crate(&ty_cx,\n-                                  method_map,\n                                   &exported_items,\n                                   &reachable_map,\n                                   krate)\n     });\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(&ty_cx, method_map, &exported_items, krate));\n+         lint::check_crate(&ty_cx, &exported_items, krate));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n@@ -396,8 +392,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         public_items: public_items,\n         maps: astencode::Maps {\n             root_map: root_map,\n-            method_map: method_map,\n-            vtable_map: vtable_map,\n             capture_map: RefCell::new(capture_map)\n         },\n         reachable: reachable_map"}, {"sha": "ba7c50547947eee59087723bde1b05cd8e84cd09", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -1882,37 +1882,23 @@ impl TypeNames {\n \n /* Memory-managed interface to target data. */\n \n-pub struct target_data_res {\n-    pub td: TargetDataRef,\n+pub struct TargetData {\n+    pub lltd: TargetDataRef\n }\n \n-impl Drop for target_data_res {\n+impl Drop for TargetData {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeTargetData(self.td);\n+            llvm::LLVMDisposeTargetData(self.lltd);\n         }\n     }\n }\n \n-pub fn target_data_res(td: TargetDataRef) -> target_data_res {\n-    target_data_res {\n-        td: td\n-    }\n-}\n-\n-pub struct TargetData {\n-    pub lltd: TargetDataRef,\n-    dtor: @target_data_res\n-}\n-\n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let lltd = string_rep.with_c_str(|buf| {\n-        unsafe { llvm::LLVMCreateTargetData(buf) }\n-    });\n-\n     TargetData {\n-        lltd: lltd,\n-        dtor: @target_data_res(lltd)\n+        lltd: string_rep.with_c_str(|buf| {\n+            unsafe { llvm::LLVMCreateTargetData(buf) }\n+        })\n     }\n }\n \n@@ -1949,35 +1935,22 @@ impl Drop for ObjectFile {\n \n /* Memory-managed interface to section iterators. */\n \n-pub struct section_iter_res {\n-    pub si: SectionIteratorRef,\n+pub struct SectionIter {\n+    pub llsi: SectionIteratorRef\n }\n \n-impl Drop for section_iter_res {\n+impl Drop for SectionIter {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeSectionIterator(self.si);\n+            llvm::LLVMDisposeSectionIterator(self.llsi);\n         }\n     }\n }\n \n-pub fn section_iter_res(si: SectionIteratorRef) -> section_iter_res {\n-    section_iter_res {\n-        si: si\n-    }\n-}\n-\n-pub struct SectionIter {\n-    pub llsi: SectionIteratorRef,\n-    dtor: @section_iter_res\n-}\n-\n pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n     unsafe {\n-        let llsi = llvm::LLVMGetSections(llof);\n         SectionIter {\n-            llsi: llsi,\n-            dtor: @section_iter_res(llsi)\n+            llsi: llvm::LLVMGetSections(llof)\n         }\n     }\n }"}, {"sha": "efbfce1b2bb86c197314d96cc6f3219d2d28be02", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -23,7 +23,6 @@ use metadata::loader;\n use metadata::loader::Os;\n use metadata::loader::CratePaths;\n \n-use std::cell::RefCell;\n use std::rc::Rc;\n use collections::HashMap;\n use syntax::ast;\n@@ -280,7 +279,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                      hash: Option<&Svh>,\n                      should_link: bool,\n                      span: Span)\n-                     -> (ast::CrateNum, @cstore::crate_metadata,\n+                     -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n                          cstore::CrateSource) {\n     match existing_match(e, crate_id, hash) {\n         None => {\n@@ -317,7 +316,7 @@ fn resolve_crate<'a>(e: &mut Env,\n             let cnum_map = if should_link {\n                 resolve_crate_deps(e, root, metadata.as_slice(), span)\n             } else {\n-                @RefCell::new(HashMap::new())\n+                HashMap::new()\n             };\n \n             // Claim this crate number and cache it if we're linking to the\n@@ -331,13 +330,13 @@ fn resolve_crate<'a>(e: &mut Env,\n                 -1\n             };\n \n-            let cmeta = @cstore::crate_metadata {\n+            let cmeta = Rc::new(cstore::crate_metadata {\n                 name: load_ctxt.crate_id.name.to_owned(),\n                 data: metadata,\n                 cnum_map: cnum_map,\n                 cnum: cnum,\n                 span: span,\n-            };\n+            });\n \n             let source = cstore::CrateSource {\n                 dylib: dylib,\n@@ -346,7 +345,7 @@ fn resolve_crate<'a>(e: &mut Env,\n             };\n \n             if should_link {\n-                e.sess.cstore.set_crate_data(cnum, cmeta);\n+                e.sess.cstore.set_crate_data(cnum, cmeta.clone());\n                 e.sess.cstore.add_used_crate_source(source.clone());\n             }\n             (cnum, cmeta, source)\n@@ -365,20 +364,16 @@ fn resolve_crate_deps(e: &mut Env,\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n-    let mut cnum_map = HashMap::new();\n-    let r = decoder::get_crate_deps(cdata);\n-    for dep in r.iter() {\n-        let extrn_cnum = dep.cnum;\n+    decoder::get_crate_deps(cdata).iter().map(|dep| {\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n         let (local_cnum, _, _) = resolve_crate(e, root,\n                                                dep.crate_id.name.as_slice(),\n                                                &dep.crate_id,\n                                                Some(&dep.hash),\n                                                true,\n                                                span);\n-        cnum_map.insert(extrn_cnum, local_cnum);\n-    }\n-    return @RefCell::new(cnum_map);\n+        (dep.cnum, local_cnum)\n+    }).collect()\n }\n \n pub struct Loader<'a> {\n@@ -407,8 +402,8 @@ impl<'a> CrateLoader for Loader<'a> {\n                                                info.ident, &info.crate_id,\n                                                None, info.should_link,\n                                                krate.span);\n-        let macros = decoder::get_exported_macros(data);\n-        let registrar = decoder::get_macro_registrar_fn(data).map(|id| {\n+        let macros = decoder::get_exported_macros(&*data);\n+        let registrar = decoder::get_macro_registrar_fn(&*data).map(|id| {\n             decoder::get_symbol(data.data.as_slice(), id)\n         });\n         MacroCrate {"}, {"sha": "4ebf4a52e41847fc4cb3bfbd2800a6fb40c02673", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -33,8 +33,8 @@ pub struct StaticMethodInfo {\n }\n \n pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> ~str {\n-    let cdata = cstore.get_crate_data(def.krate).data();\n-    return decoder::get_symbol(cdata, def.node);\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_symbol(cdata.data(), def.node)\n }\n \n /// Iterates over all the language items in the given crate.\n@@ -43,7 +43,7 @@ pub fn each_lang_item(cstore: &cstore::CStore,\n                       f: |ast::NodeId, uint| -> bool)\n                       -> bool {\n     let crate_data = cstore.get_crate_data(cnum);\n-    decoder::each_lang_item(crate_data, f)\n+    decoder::each_lang_item(&*crate_data, f)\n }\n \n /// Iterates over each child of the given item.\n@@ -57,7 +57,7 @@ pub fn each_child_of_item(cstore: &cstore::CStore,\n         cstore.get_crate_data(cnum)\n     };\n     decoder::each_child_of_item(cstore.intr.clone(),\n-                                crate_data,\n+                                &*crate_data,\n                                 def_id.node,\n                                 get_crate_data,\n                                 callback)\n@@ -74,15 +74,15 @@ pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n         cstore.get_crate_data(cnum)\n     };\n     decoder::each_top_level_item_of_crate(cstore.intr.clone(),\n-                                          crate_data,\n+                                          &*crate_data,\n                                           get_crate_data,\n                                           callback)\n }\n \n pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    let path = decoder::get_item_path(cdata, def.node);\n+    let path = decoder::get_item_path(&*cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n@@ -103,101 +103,101 @@ pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n                        -> found_ast {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::maybe_get_item_ast(cdata, tcx, def.node, decode_inlined_item)\n+    decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)\n }\n \n pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n-                      -> Vec<@ty::VariantInfo> {\n+                      -> Vec<Rc<ty::VariantInfo>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    return decoder::get_enum_variants(cstore.intr.clone(), cdata, def.node, tcx)\n+    decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(tcx: &ty::ctxt, impl_def_id: ast::DefId)\n-                -> ty::Impl {\n-    let cdata = tcx.sess.cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl(tcx.sess.cstore.intr.clone(), cdata, impl_def_id.node, tcx)\n+pub fn get_impl_methods(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n+                        -> Vec<ast::DefId> {\n+    let cdata = cstore.get_crate_data(impl_def_id.krate);\n+    decoder::get_impl_methods(&*cdata, impl_def_id.node)\n }\n \n pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n-    decoder::get_method(tcx.sess.cstore.intr.clone(), cdata, def.node, tcx)\n+    decoder::get_method(tcx.sess.cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n pub fn get_method_name_and_explicit_self(cstore: &cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_method_name_and_explicit_self(cstore.intr.clone(), cdata, def.node)\n+    decoder::get_method_name_and_explicit_self(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: &cstore::CStore,\n                                 def: ast::DefId) -> Vec<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_method_def_ids(cdata, def.node)\n+    decoder::get_trait_method_def_ids(&*cdata, def.node)\n }\n \n pub fn get_item_variances(cstore: &cstore::CStore,\n                           def: ast::DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_variances(cdata, def.node)\n+    decoder::get_item_variances(&*cdata, def.node)\n }\n \n pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n                                   def: ast::DefId)\n-                               -> Vec<@ty::Method> {\n+                               -> Vec<Rc<ty::Method>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_provided_trait_methods(cstore.intr.clone(), cdata, def.node, tcx)\n+    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n+pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<Rc<ty::TraitRef>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_supertraits(cdata, def.node, tcx)\n+    decoder::get_supertraits(&*cdata, def.node, tcx)\n }\n \n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type_name_if_impl(cdata, def.node)\n+    decoder::get_type_name_if_impl(&*cdata, def.node)\n }\n \n pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<Vec<StaticMethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_static_methods_if_impl(cstore.intr.clone(), cdata, def.node)\n+    decoder::get_static_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n                       f: |Vec<@ast::MetaItem> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_item_attrs(cdata, def_id.node, f)\n+    decoder::get_item_attrs(&*cdata, def_id.node, f)\n }\n \n pub fn get_struct_fields(cstore: &cstore::CStore,\n                          def: ast::DefId)\n                       -> Vec<ty::field_ty> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_fields(cstore.intr.clone(), cdata, def.node)\n+    decoder::get_struct_fields(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_type(tcx: &ty::ctxt,\n                 def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type(cdata, def.node, tcx)\n+    decoder::get_type(&*cdata, def.node, tcx)\n }\n \n pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_def(cdata, def.node, tcx)\n+    decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n@@ -213,7 +213,7 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n         decoder::maybe_find_item(def.node, class_doc),\n         || format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                  class_id, def) );\n-    let ty = decoder::item_type(def, the_field, tcx, cdata);\n+    let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n                                 region_param_defs: Rc::new(Vec::new())},\n@@ -224,46 +224,46 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n pub fn get_impl_trait(tcx: &ty::ctxt,\n-                      def: ast::DefId) -> Option<@ty::TraitRef> {\n+                      def: ast::DefId) -> Option<Rc<ty::TraitRef>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_trait(cdata, def.node, tcx)\n+    decoder::get_impl_trait(&*cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n pub fn get_impl_vtables(tcx: &ty::ctxt,\n                         def: ast::DefId) -> typeck::impl_res {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_vtables(cdata, def.node, tcx)\n+    decoder::get_impl_vtables(&*cdata, def.node, tcx)\n }\n \n pub fn get_native_libraries(cstore: &cstore::CStore,\n                             crate_num: ast::CrateNum)\n                                 -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::get_native_libraries(cdata)\n+    decoder::get_native_libraries(&*cdata)\n }\n \n pub fn each_impl(cstore: &cstore::CStore,\n                  crate_num: ast::CrateNum,\n                  callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::each_impl(cdata, callback)\n+    decoder::each_impl(&*cdata, callback)\n }\n \n pub fn each_implementation_for_type(cstore: &cstore::CStore,\n                                     def_id: ast::DefId,\n                                     callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_type(cdata, def_id.node, callback)\n+    decoder::each_implementation_for_type(&*cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait(cstore: &cstore::CStore,\n                                      def_id: ast::DefId,\n                                      callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n+    decoder::each_implementation_for_trait(&*cdata, def_id.node, callback)\n }\n \n /// If the given def ID describes a method belonging to a trait (either a\n@@ -274,27 +274,27 @@ pub fn get_trait_of_method(cstore: &cstore::CStore,\n                            tcx: &ty::ctxt)\n                            -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_trait_of_method(cdata, def_id.node, tcx)\n+    decoder::get_trait_of_method(&*cdata, def_id.node, tcx)\n }\n \n pub fn get_macro_registrar_fn(cstore: &cstore::CStore,\n                               crate_num: ast::CrateNum)\n                               -> Option<ast::NodeId> {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::get_macro_registrar_fn(cdata)\n+    decoder::get_macro_registrar_fn(&*cdata)\n }\n \n pub fn get_exported_macros(cstore: &cstore::CStore,\n                            crate_num: ast::CrateNum)\n                            -> Vec<~str> {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::get_exported_macros(cdata)\n+    decoder::get_exported_macros(&*cdata)\n }\n \n pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n                                            def_id: ast::DefId)\n     -> Option<ast::DefId>\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_tuple_struct_definition_if_ctor(cdata, def_id.node)\n+    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.node)\n }"}, {"sha": "8e731a98dd7e70abf92b82e62ca490ae6abd1212", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -30,7 +30,7 @@ use syntax::parse::token::IdentInterner;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = @RefCell<HashMap<ast::CrateNum, ast::CrateNum>>;\n+pub type cnum_map = HashMap<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(CVec<u8>),\n@@ -68,7 +68,7 @@ pub struct CrateSource {\n }\n \n pub struct CStore {\n-    metas: RefCell<HashMap<ast::CrateNum, @crate_metadata>>,\n+    metas: RefCell<HashMap<ast::CrateNum, Rc<crate_metadata>>>,\n     extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(~str, NativeLibaryKind)>>,\n@@ -95,22 +95,22 @@ impl CStore {\n         self.metas.borrow().len() as ast::CrateNum + 1\n     }\n \n-    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> @crate_metadata {\n-        *self.metas.borrow().get(&cnum)\n+    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n+        self.metas.borrow().get(&cnum).clone()\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: @crate_metadata) {\n+    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<crate_metadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n-    pub fn iter_crate_data(&self, i: |ast::CrateNum, @crate_metadata|) {\n-        for (&k, &v) in self.metas.borrow().iter() {\n-            i(k, v);\n+    pub fn iter_crate_data(&self, i: |ast::CrateNum, &crate_metadata|) {\n+        for (&k, v) in self.metas.borrow().iter() {\n+            i(k, &**v);\n         }\n     }\n \n@@ -155,7 +155,7 @@ impl CStore {\n                  ordering: &mut Vec<ast::CrateNum>) {\n             if ordering.as_slice().contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.borrow().iter() {\n+            for (_, &dep) in meta.cnum_map.iter() {\n                 visit(cstore, dep, ordering);\n             }\n             ordering.push(cnum);"}, {"sha": "37d9d3417c9f5ef397a3d9044b685332252122ff", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -45,7 +45,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::crateid::CrateId;\n \n-pub type Cmd = @crate_metadata;\n+pub type Cmd<'a> = &'a crate_metadata;\n \n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n@@ -76,8 +76,6 @@ fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     ret\n }\n \n-pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Cmd;\n-\n pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: ebml::Doc<'a>) -> Option<ebml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n@@ -388,7 +386,7 @@ pub fn get_trait_def(cdata: Cmd,\n         generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param_defs: rp_defs},\n         bounds: bounds,\n-        trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n+        trait_ref: Rc::new(item_trait_ref(item_doc, tcx, cdata))\n     }\n }\n \n@@ -412,11 +410,11 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n \n pub fn get_impl_trait(cdata: Cmd,\n                       id: ast::NodeId,\n-                      tcx: &ty::ctxt) -> Option<@ty::TraitRef>\n+                      tcx: &ty::ctxt) -> Option<Rc<ty::TraitRef>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-        @doc_trait_ref(tp, tcx, cdata)\n+        Rc::new(doc_trait_ref(tp, tcx, cdata))\n     })\n }\n \n@@ -462,6 +460,8 @@ pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     })\n }\n \n+pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Rc<crate_metadata>;\n+\n fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n@@ -477,12 +477,17 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n \n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n-        let other_crates_items = if child_def_id.krate == cdata.cnum {\n-            reader::get_doc(reader::Doc(cdata.data()), tag_items)\n+        let crate_data = if child_def_id.krate == cdata.cnum {\n+            None\n         } else {\n-            let crate_data = get_crate_data(child_def_id.krate);\n-            reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n+            Some(get_crate_data(child_def_id.krate))\n         };\n+        let crate_data = match crate_data {\n+            Some(ref cdata) => &**cdata,\n+            None => cdata\n+        };\n+\n+        let other_crates_items = reader::get_doc(reader::Doc(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -565,12 +570,17 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n         let name = name_doc.as_str_slice();\n \n         // This reexport may be in yet another crate.\n-        let other_crates_items = if child_def_id.krate == cdata.cnum {\n-            reader::get_doc(reader::Doc(cdata.data()), tag_items)\n+        let crate_data = if child_def_id.krate == cdata.cnum {\n+            None\n         } else {\n-            let crate_data = get_crate_data(child_def_id.krate);\n-            reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n+            Some(get_crate_data(child_def_id.krate))\n         };\n+        let crate_data = match crate_data {\n+            Some(ref cdata) => &**cdata,\n+            None => cdata\n+        };\n+\n+        let other_crates_items = reader::get_doc(reader::Doc(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -634,7 +644,7 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n-pub type DecodeInlinedItem<'a> = |cdata: @cstore::crate_metadata,\n+pub type DecodeInlinedItem<'a> = |cdata: Cmd,\n                                   tcx: &ty::ctxt,\n                                   path: Vec<ast_map::PathElem>,\n                                   par_doc: ebml::Doc|: 'a\n@@ -665,39 +675,38 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n }\n \n pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                     tcx: &ty::ctxt) -> Vec<@ty::VariantInfo> {\n+                     tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n-    let mut infos: Vec<@ty::VariantInfo> = Vec::new();\n-    let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    for did in variant_ids.iter() {\n+    enum_variant_ids(item, cdata).iter().map(|did| {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n-          ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n-          _ => Vec::new(), // Nullary enum variant.\n+            ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n+            _ => Vec::new(), // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n-          Some(val) => { disr_val = val; }\n-          _         => { /* empty */ }\n+            Some(val) => { disr_val = val; }\n+            _         => { /* empty */ }\n         }\n-        infos.push(@ty::VariantInfo{\n+        let old_disr_val = disr_val;\n+        disr_val += 1;\n+        Rc::new(ty::VariantInfo {\n             args: arg_tys,\n             arg_names: None,\n             ctor_ty: ctor_ty,\n             name: name,\n             // I'm not even sure if we encode visibility\n             // for variants -- TEST -- tjc\n             id: *did,\n-            disr_val: disr_val,\n-            vis: ast::Inherited});\n-        disr_val += 1;\n-    }\n-    return infos;\n+            disr_val: old_disr_val,\n+            vis: ast::Inherited\n+        })\n+    }).collect()\n }\n \n fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n@@ -723,32 +732,17 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     }\n }\n \n-fn item_impl_methods(intr: Rc<IdentInterner>, cdata: Cmd, item: ebml::Doc,\n-                     tcx: &ty::ctxt) -> Vec<@ty::Method> {\n-    let mut rslt = Vec::new();\n-    reader::tagged_docs(item, tag_item_impl_method, |doc| {\n+/// Returns information about the given implementation.\n+pub fn get_impl_methods(cdata: Cmd, impl_id: ast::NodeId) -> Vec<ast::DefId> {\n+    let mut methods = Vec::new();\n+    reader::tagged_docs(lookup_item(impl_id, cdata.data()),\n+                        tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n-        rslt.push(@get_method(intr.clone(), cdata, m_did.node, tcx));\n+        methods.push(translate_def_id(cdata, m_did));\n         true\n     });\n \n-    rslt\n-}\n-\n-/// Returns information about the given implementation.\n-pub fn get_impl(intr: Rc<IdentInterner>, cdata: Cmd, impl_id: ast::NodeId,\n-               tcx: &ty::ctxt)\n-                -> ty::Impl {\n-    let data = cdata.data();\n-    let impl_item = lookup_item(impl_id, data);\n-    ty::Impl {\n-        did: ast::DefId {\n-            krate: cdata.cnum,\n-            node: impl_id,\n-        },\n-        ident: item_name(&*intr, impl_item),\n-        methods: item_impl_methods(intr, cdata, impl_item, tcx),\n-    }\n+    methods\n }\n \n pub fn get_method_name_and_explicit_self(\n@@ -821,8 +815,8 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n }\n \n pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n-                                  id: ast::NodeId, tcx: &ty::ctxt) ->\n-        Vec<@ty::Method> {\n+                                  id: ast::NodeId, tcx: &ty::ctxt)\n+                                  -> Vec<Rc<ty::Method>> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = Vec::new();\n@@ -832,7 +826,7 @@ pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n         let mth = lookup_item(did.node, data);\n \n         if item_method_sort(mth) == 'p' {\n-            result.push(@get_method(intr.clone(), cdata, did.node, tcx));\n+            result.push(Rc::new(get_method(intr.clone(), cdata, did.node, tcx)));\n         }\n         true\n     });\n@@ -842,7 +836,7 @@ pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n \n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-                    -> Vec<@ty::TraitRef> {\n+                    -> Vec<Rc<ty::TraitRef>> {\n     let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n@@ -851,7 +845,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n         // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n         let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n         if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_none() {\n-            results.push(@trait_ref);\n+            results.push(Rc::new(trait_ref));\n         }\n         true\n     });\n@@ -1155,7 +1149,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n         return ast::DefId { krate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.borrow().find(&did.krate) {\n+    match cdata.cnum_map.find(&did.krate) {\n         Some(&n) => {\n             ast::DefId {\n                 krate: n,"}, {"sha": "848fd8d362e12a30851a865175c5555bad978b72", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 128, "deletions": 159, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -27,7 +27,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cast;\n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n use std::hash;\n use std::hash::Hash;\n use std::io::MemWriter;\n@@ -52,9 +52,6 @@ use syntax::visit;\n use syntax;\n use writer = serialize::ebml::writer;\n \n-// used by astencode:\n-pub type abbrev_map = @RefCell<HashMap<ty::t, tyencode::ty_abbrev>>;\n-\n /// A borrowed version of ast::InlinedItem.\n pub enum InlinedItemRef<'a> {\n     IIItemRef(&'a ast::Item),\n@@ -71,41 +68,24 @@ pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n pub struct EncodeParams<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n-    pub reexports2: middle::resolve::ExportMap2,\n+    pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<~str>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: EncodeInlinedItem<'a>,\n }\n \n-pub struct Stats {\n-    inline_bytes: Cell<u64>,\n-    attr_bytes: Cell<u64>,\n-    dep_bytes: Cell<u64>,\n-    lang_item_bytes: Cell<u64>,\n-    native_lib_bytes: Cell<u64>,\n-    macro_registrar_fn_bytes: Cell<u64>,\n-    macro_defs_bytes: Cell<u64>,\n-    impl_bytes: Cell<u64>,\n-    misc_bytes: Cell<u64>,\n-    item_bytes: Cell<u64>,\n-    index_bytes: Cell<u64>,\n-    zero_bytes: Cell<u64>,\n-    total_bytes: Cell<u64>,\n-}\n-\n pub struct EncodeContext<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n-    pub stats: @Stats,\n-    pub reexports2: middle::resolve::ExportMap2,\n+    pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<~str>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: EncodeInlinedItem<'a>,\n-    pub type_abbrevs: abbrev_map,\n+    pub type_abbrevs: tyencode::abbrev_map,\n }\n \n fn encode_name(ebml_w: &mut Encoder, name: Name) {\n@@ -134,7 +114,7 @@ fn encode_trait_ref(ebml_w: &mut Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n \n     ebml_w.start_tag(tag);\n@@ -146,8 +126,8 @@ fn encode_impl_vtables(ebml_w: &mut Encoder,\n                        ecx: &EncodeContext,\n                        vtables: &typeck::impl_res) {\n     ebml_w.start_tag(tag_item_impl_vtables);\n-    astencode::encode_vtable_res(ecx, ebml_w, vtables.trait_vtables);\n-    astencode::encode_vtable_param_res(ecx, ebml_w, vtables.self_vtables);\n+    astencode::encode_vtable_res(ecx, ebml_w, &vtables.trait_vtables);\n+    astencode::encode_vtable_param_res(ecx, ebml_w, &vtables.self_vtables);\n     ebml_w.end_tag();\n }\n \n@@ -170,7 +150,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n     for param in params.iter() {\n         ebml_w.start_tag(tag);\n@@ -227,7 +207,7 @@ pub fn write_type(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n@@ -249,7 +229,7 @@ fn encode_method_fty(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n     tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n \n@@ -290,7 +270,7 @@ fn encode_parent_item(ebml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(ebml_w: &mut Encoder,\n-                        fields: &Vec<ty::field_ty>,\n+                        fields: &[ty::field_ty],\n                         origin: DefId) {\n     for f in fields.iter() {\n         if f.name == special_idents::unnamed_field.name {\n@@ -313,7 +293,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n-                            index: @RefCell<Vec<entry<i64>> >,\n+                            index: &mut Vec<entry<i64>>,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n@@ -323,7 +303,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                                ast::DefId { krate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n-        index.borrow_mut().push(entry {\n+        index.push(entry {\n             val: variant.node.id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n@@ -347,11 +327,10 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  ebml_w,\n-                                                 &fields,\n+                                                 fields.as_slice(),\n                                                  index);\n-                encode_struct_fields(ebml_w, &fields, def_id);\n-                let bkts = create_index(idx);\n-                encode_index(ebml_w, bkts, write_i64);\n+                encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n+                encode_index(ebml_w, idx, write_i64);\n             }\n         }\n         if vi.get(i).disr_val != disr_val {\n@@ -402,10 +381,12 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          ebml_w: &mut Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n+    let impl_methods = ecx.tcx.impl_methods.borrow();\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n-            for &base_impl in implementations.borrow().iter() {\n-                for &m in base_impl.methods.iter() {\n+            for base_impl_did in implementations.borrow().iter() {\n+                for &method_did in impl_methods.get(base_impl_did).iter() {\n+                    let m = ty::method(ecx.tcx, method_did);\n                     if m.explicit_self == ast::SelfStatic {\n                         encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                     }\n@@ -424,7 +405,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n         Some(methods) => {\n-            for &m in methods.iter() {\n+            for m in methods.iter() {\n                 if m.explicit_self == ast::SelfStatic {\n                     encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                 }\n@@ -666,8 +647,8 @@ fn encode_provided_source(ebml_w: &mut Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut Encoder,\n-                          fields: &Vec<ty::field_ty>,\n-                          global_index: @RefCell<Vec<entry<i64>> >)\n+                          fields: &[ty::field_ty],\n+                          global_index: &mut Vec<entry<i64>>)\n                           -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n@@ -680,7 +661,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         let id = field.id.node;\n \n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n-        global_index.borrow_mut().push(entry {\n+        global_index.push(entry {\n             val: id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n@@ -700,9 +681,9 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut Encoder,\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n-                               index: @RefCell<Vec<entry<i64>> >,\n+                               index: &mut Vec<entry<i64>>,\n                                struct_id: NodeId) {\n-    index.borrow_mut().push(entry {\n+    index.push(entry {\n         val: ctor_id as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n     });\n@@ -825,10 +806,10 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    def_id: DefId) {\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n-        Some(&implementations) => {\n-            for implementation in implementations.borrow().iter() {\n+        Some(implementations) => {\n+            for &impl_def_id in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_inherent_impl);\n-                encode_def_id(ebml_w, implementation.did);\n+                encode_def_id(ebml_w, impl_def_id);\n                 ebml_w.end_tag();\n             }\n         }\n@@ -841,10 +822,10 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n                                     trait_def_id: DefId) {\n     match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n         None => {}\n-        Some(&implementations) => {\n-            for implementation in implementations.borrow().iter() {\n+        Some(implementations) => {\n+            for &impl_def_id in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_extension_impl);\n-                encode_def_id(ebml_w, implementation.did);\n+                encode_def_id(ebml_w, impl_def_id);\n                 ebml_w.end_tag();\n             }\n         }\n@@ -854,14 +835,14 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut Encoder,\n                         item: &Item,\n-                        index: @RefCell<Vec<entry<i64>> >,\n+                        index: &mut Vec<entry<i64>>,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index(item: &Item, ebml_w: &Encoder,\n-                     index: @RefCell<Vec<entry<i64>> >) {\n-        index.borrow_mut().push(entry {\n+                    index: &mut Vec<entry<i64>>) {\n+        index.push(entry {\n             val: item.id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n@@ -988,7 +969,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          ebml_w,\n-                                         &fields,\n+                                         fields.as_slice(),\n                                          index);\n \n         /* Index the class*/\n@@ -1009,16 +990,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(ebml_w, &fields, def_id);\n+        encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n \n         (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n \n         /* Each class has its own index -- encode it */\n-        let bkts = create_index(idx);\n-        encode_index(ebml_w, bkts, write_i64);\n+        encode_index(ebml_w, idx, write_i64);\n         ebml_w.end_tag();\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n@@ -1033,8 +1013,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       ItemImpl(_, ref opt_trait, ty, ref ast_methods) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n-        let impls = tcx.impls.borrow();\n-        let imp = impls.get(&def_id);\n+        let impl_methods = tcx.impl_methods.borrow();\n+        let methods = impl_methods.get(&def_id);\n \n         add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1051,16 +1031,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for method in imp.methods.iter() {\n+        for &method_def_id in methods.iter() {\n             ebml_w.start_tag(tag_item_impl_method);\n-            let s = def_to_str(method.def_id);\n+            let s = def_to_str(method_def_id);\n             ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n         for ast_trait_ref in opt_trait.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n+            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_trait_ref);\n             let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n             encode_impl_vtables(ebml_w, ecx, &impl_vtables);\n         }\n@@ -1072,18 +1052,18 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // appear first in the impl structure, in the same order they do\n         // in the ast. This is a little sketchy.\n         let num_implemented_methods = ast_methods.len();\n-        for (i, m) in imp.methods.iter().enumerate() {\n+        for (i, &method_def_id) in methods.iter().enumerate() {\n             let ast_method = if i < num_implemented_methods {\n                 Some(*ast_methods.get(i))\n             } else { None };\n \n-            index.borrow_mut().push(entry {\n-                val: m.def_id.node as i64,\n+            index.push(entry {\n+                val: method_def_id.node as i64,\n                 pos: ebml_w.writer.tell().unwrap(),\n             });\n             encode_info_for_method(ecx,\n                                    ebml_w,\n-                                   *m,\n+                                   &*ty::method(tcx, method_def_id),\n                                    path.clone(),\n                                    false,\n                                    item.id,\n@@ -1101,7 +1081,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                   trait_def.generics.type_param_defs(),\n                                   tag_items_data_item_ty_param_bounds);\n         encode_region_param_defs(ebml_w, trait_def.generics.region_param_defs());\n-        encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+        encode_trait_ref(ebml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ebml_w, item.ident.name);\n         encode_attributes(ebml_w, item.attrs.as_slice());\n         encode_visibility(ebml_w, vis);\n@@ -1120,7 +1100,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n         for ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n+            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_super_trait_ref);\n         }\n \n         // Encode the implementations of this trait.\n@@ -1135,14 +1115,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n-            index.borrow_mut().push(entry {\n+            index.push(entry {\n                 val: method_def_id.node as i64,\n                 pos: ebml_w.writer.tell().unwrap(),\n             });\n \n             ebml_w.start_tag(tag_items_data_item);\n \n-            encode_method_ty_fields(ecx, ebml_w, method_ty);\n+            encode_method_ty_fields(ecx, ebml_w, &*method_ty);\n \n             encode_parent_item(ebml_w, def_id);\n \n@@ -1202,10 +1182,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut Encoder,\n                                 nitem: &ForeignItem,\n-                                index: @RefCell<Vec<entry<i64>> >,\n+                                index: &mut Vec<entry<i64>>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n-    index.borrow_mut().push(entry {\n+    index.push(entry {\n         val: nitem.id as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n     });\n@@ -1244,7 +1224,7 @@ fn my_visit_expr(_e: &Expr) { }\n fn my_visit_item(i: &Item,\n                  ebml_w: &mut Encoder,\n                  ecx_ptr: *int,\n-                 index: @RefCell<Vec<entry<i64>> >) {\n+                 index: &mut Vec<entry<i64>>) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n@@ -1256,7 +1236,7 @@ fn my_visit_item(i: &Item,\n fn my_visit_foreign_item(ni: &ForeignItem,\n                          ebml_w: &mut Encoder,\n                          ecx_ptr:*int,\n-                         index: @RefCell<Vec<entry<i64>> >) {\n+                         index: &mut Vec<entry<i64>>) {\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n@@ -1277,7 +1257,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx_ptr:*int,\n-    index: @RefCell<Vec<entry<i64>> >,\n+    index: &'a mut Vec<entry<i64>>,\n }\n \n impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n@@ -1305,9 +1285,9 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut Encoder,\n                          krate: &Crate)\n                          -> Vec<entry<i64>> {\n-    let index = @RefCell::new(Vec::new());\n+    let mut index = Vec::new();\n     ebml_w.start_tag(tag_items_data);\n-    index.borrow_mut().push(entry {\n+    index.push(entry {\n         val: CRATE_NODE_ID as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n     });\n@@ -1321,53 +1301,34 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n     let ecx_ptr: *int = unsafe { cast::transmute(ecx) };\n-    {\n-        let mut visitor = EncodeVisitor {\n-            index: index,\n-            ecx_ptr: ecx_ptr,\n-            ebml_w_for_visit_item: &mut *ebml_w,\n-        };\n-\n-        visit::walk_crate(&mut visitor, krate, ());\n-    }\n+    visit::walk_crate(&mut EncodeVisitor {\n+        index: &mut index,\n+        ecx_ptr: ecx_ptr,\n+        ebml_w_for_visit_item: &mut *ebml_w,\n+    }, krate, ());\n \n     ebml_w.end_tag();\n-    return /*bad*/index.borrow().clone();\n+    index\n }\n \n \n // Path and definition ID indexing\n \n-fn create_index<T:Clone + Hash + 'static>(\n-                index: Vec<entry<T>> )\n-                -> Vec<@Vec<entry<T>> > {\n-    let mut buckets: Vec<@RefCell<Vec<entry<T>> >> = Vec::new();\n-    for _ in range(0u, 256u) {\n-        buckets.push(@RefCell::new(Vec::new()));\n-    }\n-    for elt in index.iter() {\n+fn encode_index<T: Hash>(ebml_w: &mut Encoder, index: Vec<entry<T>>,\n+                         write_fn: |&mut MemWriter, &T|) {\n+    let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n+    for elt in index.move_iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        buckets.get_mut(h % 256).borrow_mut().push((*elt).clone());\n-    }\n-\n-    let mut buckets_frozen = Vec::new();\n-    for bucket in buckets.iter() {\n-        buckets_frozen.push(@/*bad*/bucket.borrow().clone());\n+        buckets.get_mut(h % 256).push(elt);\n     }\n-    return buckets_frozen;\n-}\n \n-fn encode_index<T:'static>(\n-                ebml_w: &mut Encoder,\n-                buckets: Vec<@Vec<entry<T>> > ,\n-                write_fn: |&mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs = Vec::new();\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell().unwrap());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for elt in (**bucket).iter() {\n+        for elt in bucket.iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n@@ -1614,7 +1575,7 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n-                let def_map = self.ecx.tcx.def_map;\n+                let def_map = &self.ecx.tcx.def_map;\n                 let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n                 let def_id = ast_util::def_id_of_def(trait_def);\n \n@@ -1723,20 +1684,33 @@ pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n }\n \n fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate) {\n-    let stats = Stats {\n-        inline_bytes: Cell::new(0),\n-        attr_bytes: Cell::new(0),\n-        dep_bytes: Cell::new(0),\n-        lang_item_bytes: Cell::new(0),\n-        native_lib_bytes: Cell::new(0),\n-        macro_registrar_fn_bytes: Cell::new(0),\n-        macro_defs_bytes: Cell::new(0),\n-        impl_bytes: Cell::new(0),\n-        misc_bytes: Cell::new(0),\n-        item_bytes: Cell::new(0),\n-        index_bytes: Cell::new(0),\n-        zero_bytes: Cell::new(0),\n-        total_bytes: Cell::new(0),\n+    struct Stats {\n+        attr_bytes: u64,\n+        dep_bytes: u64,\n+        lang_item_bytes: u64,\n+        native_lib_bytes: u64,\n+        macro_registrar_fn_bytes: u64,\n+        macro_defs_bytes: u64,\n+        impl_bytes: u64,\n+        misc_bytes: u64,\n+        item_bytes: u64,\n+        index_bytes: u64,\n+        zero_bytes: u64,\n+        total_bytes: u64,\n+    }\n+    let mut stats = Stats {\n+        attr_bytes: 0,\n+        dep_bytes: 0,\n+        lang_item_bytes: 0,\n+        native_lib_bytes: 0,\n+        macro_registrar_fn_bytes: 0,\n+        macro_defs_bytes: 0,\n+        impl_bytes: 0,\n+        misc_bytes: 0,\n+        item_bytes: 0,\n+        index_bytes: 0,\n+        zero_bytes: 0,\n+        total_bytes: 0,\n     };\n     let EncodeParams {\n         item_symbols,\n@@ -1749,19 +1723,16 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         non_inlineable_statics,\n         ..\n     } = parms;\n-    let type_abbrevs = @RefCell::new(HashMap::new());\n-    let stats = @stats;\n     let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n-        stats: stats,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: type_abbrevs,\n+        type_abbrevs: RefCell::new(HashMap::new()),\n      };\n \n     let mut ebml_w = writer::Encoder(wr);\n@@ -1772,88 +1743,86 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, krate);\n     encode_attributes(&mut ebml_w, crate_attrs.as_slice());\n-    ecx.stats.attr_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.attr_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     i = ebml_w.writer.tell().unwrap();\n     encode_crate_deps(&mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.dep_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode the language items.\n     i = ebml_w.writer.tell().unwrap();\n     encode_lang_items(&ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.lang_item_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode the native libraries used\n     i = ebml_w.writer.tell().unwrap();\n     encode_native_libraries(&ecx, &mut ebml_w);\n-    ecx.stats.native_lib_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.native_lib_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode the macro registrar function\n     i = ebml_w.writer.tell().unwrap();\n     encode_macro_registrar_fn(&ecx, &mut ebml_w);\n-    ecx.stats.macro_registrar_fn_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.macro_registrar_fn_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode macro definitions\n     i = ebml_w.writer.tell().unwrap();\n     encode_macro_defs(&ecx, krate, &mut ebml_w);\n-    ecx.stats.macro_defs_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.macro_defs_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n     i = ebml_w.writer.tell().unwrap();\n     encode_impls(&ecx, krate, &mut ebml_w);\n-    ecx.stats.impl_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.impl_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode miscellaneous info.\n     i = ebml_w.writer.tell().unwrap();\n     encode_misc_info(&ecx, krate, &mut ebml_w);\n-    ecx.stats.misc_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.misc_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = ebml_w.writer.tell().unwrap();\n     let items_index = encode_info_for_items(&ecx, &mut ebml_w, krate);\n-    ecx.stats.item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    stats.item_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     i = ebml_w.writer.tell().unwrap();\n-    let items_buckets = create_index(items_index);\n-    encode_index(&mut ebml_w, items_buckets, write_i64);\n-    ecx.stats.index_bytes.set(ebml_w.writer.tell().unwrap() - i);\n+    encode_index(&mut ebml_w, items_index, write_i64);\n+    stats.index_bytes = ebml_w.writer.tell().unwrap() - i;\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes.set(ebml_w.writer.tell().unwrap());\n+    stats.total_bytes = ebml_w.writer.tell().unwrap();\n \n     if tcx.sess.meta_stats() {\n         for e in ebml_w.writer.get_ref().iter() {\n             if *e == 0 {\n-                ecx.stats.zero_bytes.set(ecx.stats.zero_bytes.get() + 1);\n+                stats.zero_bytes += 1;\n             }\n         }\n \n         println!(\"metadata stats:\");\n-        println!(\"         inline bytes: {}\", ecx.stats.inline_bytes.get());\n-        println!(\"      attribute bytes: {}\", ecx.stats.attr_bytes.get());\n-        println!(\"            dep bytes: {}\", ecx.stats.dep_bytes.get());\n-        println!(\"      lang item bytes: {}\", ecx.stats.lang_item_bytes.get());\n-        println!(\"         native bytes: {}\", ecx.stats.native_lib_bytes.get());\n-        println!(\"macro registrar bytes: {}\", ecx.stats.macro_registrar_fn_bytes.get());\n-        println!(\"      macro def bytes: {}\", ecx.stats.macro_defs_bytes.get());\n-        println!(\"           impl bytes: {}\", ecx.stats.impl_bytes.get());\n-        println!(\"           misc bytes: {}\", ecx.stats.misc_bytes.get());\n-        println!(\"           item bytes: {}\", ecx.stats.item_bytes.get());\n-        println!(\"          index bytes: {}\", ecx.stats.index_bytes.get());\n-        println!(\"           zero bytes: {}\", ecx.stats.zero_bytes.get());\n-        println!(\"          total bytes: {}\", ecx.stats.total_bytes.get());\n+        println!(\"      attribute bytes: {}\", stats.attr_bytes);\n+        println!(\"            dep bytes: {}\", stats.dep_bytes);\n+        println!(\"      lang item bytes: {}\", stats.lang_item_bytes);\n+        println!(\"         native bytes: {}\", stats.native_lib_bytes);\n+        println!(\"macro registrar bytes: {}\", stats.macro_registrar_fn_bytes);\n+        println!(\"      macro def bytes: {}\", stats.macro_defs_bytes);\n+        println!(\"           impl bytes: {}\", stats.impl_bytes);\n+        println!(\"           misc bytes: {}\", stats.misc_bytes);\n+        println!(\"           item bytes: {}\", stats.item_bytes);\n+        println!(\"          index bytes: {}\", stats.index_bytes);\n+        println!(\"           zero bytes: {}\", stats.zero_bytes);\n+        println!(\"          total bytes: {}\", stats.total_bytes);\n     }\n }\n \n // Get the encoded string for a type\n pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> ~str {\n-    let cx = &tyencode::ctxt {\n+    let mut wr = MemWriter::new();\n+    tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_str,\n         tcx: tcx,\n-        abbrevs: tyencode::ac_no_abbrevs};\n-    let mut wr = MemWriter::new();\n-    tyencode::enc_ty(&mut wr, cx, t);\n+        abbrevs: &RefCell::new(HashMap::new())\n+    }, t);\n     str::from_utf8_owned(wr.get_ref().to_owned()).unwrap()\n }"}, {"sha": "3ba8dd3b30f00f7e3518e2fe1395f80fa3bd52d2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -18,6 +18,7 @@\n \n use middle::ty;\n \n+use std::rc::Rc;\n use std::str;\n use std::strbuf::StrBuf;\n use std::uint;\n@@ -563,7 +564,7 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n     ty::TypeParameterDef {\n         ident: parse_ident(st, ':'),\n         def_id: parse_def(st, NominalType, |x,y| conv(x,y)),\n-        bounds: @parse_bounds(st, |x,y| conv(x,y)),\n+        bounds: Rc::new(parse_bounds(st, |x,y| conv(x,y))),\n         default: parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)))\n     }\n }\n@@ -591,7 +592,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 param_bounds.builtin_bounds.add(ty::BoundShare);\n             }\n             'I' => {\n-                param_bounds.trait_bounds.push(@parse_trait_ref(st, |x,y| conv(x,y)));\n+                param_bounds.trait_bounds.push(Rc::new(parse_trait_ref(st, |x,y| conv(x,y))));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "13d24e7a1d057f7877738d6838e8f34b0b563f38", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 27, "deletions": 54, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -17,7 +17,6 @@ use std::cell::RefCell;\n use collections::HashMap;\n use std::io;\n use std::io::MemWriter;\n-use std::str;\n use std::fmt;\n \n use middle::ty::param_ty;\n@@ -39,7 +38,7 @@ pub struct ctxt<'a> {\n     pub ds: fn(DefId) -> ~str,\n     // The type context.\n     pub tcx: &'a ty::ctxt,\n-    pub abbrevs: abbrev_ctxt\n+    pub abbrevs: &'a abbrev_map\n }\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n@@ -51,61 +50,35 @@ pub struct ty_abbrev {\n     s: ~str\n }\n \n-pub enum abbrev_ctxt {\n-    ac_no_abbrevs,\n-    ac_use_abbrevs(@RefCell<HashMap<ty::t, ty_abbrev>>),\n-}\n+pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n     fmt::write(&mut *w as &mut io::Writer, fmt);\n }\n \n pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n-    match cx.abbrevs {\n-      ac_no_abbrevs => {\n-          let result_str_opt = cx.tcx.short_names_cache.borrow()\n-                                            .find(&t)\n-                                            .map(|result| {\n-                                                (*result).clone()\n-                                            });\n-          let result_str = match result_str_opt {\n-            Some(s) => s,\n-            None => {\n-                let wr = &mut MemWriter::new();\n-                enc_sty(wr, cx, &ty::get(t).sty);\n-                let s = str::from_utf8(wr.get_ref()).unwrap();\n-                cx.tcx.short_names_cache.borrow_mut().insert(t, s.to_str());\n-                s.to_str()\n-            }\n-          };\n-          w.write(result_str.as_bytes());\n-      }\n-      ac_use_abbrevs(abbrevs) => {\n-          match abbrevs.borrow_mut().find(&t) {\n-              Some(a) => { w.write(a.s.as_bytes()); return; }\n-              None => {}\n-          }\n-          let pos = w.tell().unwrap();\n-          enc_sty(w, cx, &ty::get(t).sty);\n-          let end = w.tell().unwrap();\n-          let len = end - pos;\n-          fn estimate_sz(u: u64) -> u64 {\n-              let mut n = u;\n-              let mut len = 0;\n-              while n != 0 { len += 1; n = n >> 4; }\n-              return len;\n-          }\n-          let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n-          if abbrev_len < len {\n-              // I.e. it's actually an abbreviation.\n-              let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len);\n-              let a = ty_abbrev { pos: pos as uint,\n-                                  len: len as uint,\n-                                  s: s };\n-              abbrevs.borrow_mut().insert(t, a);\n-          }\n-          return;\n-      }\n+    match cx.abbrevs.borrow_mut().find(&t) {\n+        Some(a) => { w.write(a.s.as_bytes()); return; }\n+        None => {}\n+    }\n+    let pos = w.tell().unwrap();\n+    enc_sty(w, cx, &ty::get(t).sty);\n+    let end = w.tell().unwrap();\n+    let len = end - pos;\n+    fn estimate_sz(u: u64) -> u64 {\n+        let mut n = u;\n+        let mut len = 0;\n+        while n != 0 { len += 1; n = n >> 4; }\n+        return len;\n+    }\n+    let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n+    if abbrev_len < len {\n+        // I.e. it's actually an abbreviation.\n+        cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n+            pos: pos as uint,\n+            len: len as uint,\n+            s: format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len)\n+        });\n     }\n }\n \n@@ -393,16 +366,16 @@ fn enc_bounds(w: &mut MemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n         }\n     }\n \n-    for &tp in bs.trait_bounds.iter() {\n+    for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, tp);\n+        enc_trait_ref(w, cx, &**tp);\n     }\n \n     mywrite!(w, \".\");\n }\n \n pub fn enc_type_param_def(w: &mut MemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n     mywrite!(w, \"{}:{}|\", token::get_ident(v.ident), (cx.ds)(v.def_id));\n-    enc_bounds(w, cx, v.bounds);\n+    enc_bounds(w, cx, &*v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }"}, {"sha": "08133a8b69e40f76af295438ad5663b649674000", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 42, "deletions": 50, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -55,13 +55,11 @@ use writer = serialize::ebml::writer;\n // Auxiliary maps of things to be encoded\n pub struct Maps {\n     pub root_map: middle::borrowck::root_map,\n-    pub method_map: middle::typeck::MethodMap,\n-    pub vtable_map: middle::typeck::vtable_map,\n     pub capture_map: RefCell<middle::moves::CaptureMap>,\n }\n \n struct DecodeContext<'a> {\n-    cdata: @cstore::crate_metadata,\n+    cdata: &'a cstore::crate_metadata,\n     tcx: &'a ty::ctxt,\n     maps: &'a Maps\n }\n@@ -112,7 +110,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            ebml_w.writer.tell());\n }\n \n-pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n+pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n                            tcx: &ty::ctxt,\n                            maps: &Maps,\n                            path: Vec<ast_map::PathElem>,\n@@ -273,7 +271,7 @@ impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n     fn read_def_id_noxcx(&mut self,\n-                         cdata: @cstore::crate_metadata) -> ast::DefId;\n+                         cdata: &cstore::crate_metadata) -> ast::DefId;\n }\n \n impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n@@ -283,7 +281,7 @@ impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n     }\n \n     fn read_def_id_noxcx(&mut self,\n-                         cdata: @cstore::crate_metadata) -> ast::DefId {\n+                         cdata: &cstore::crate_metadata) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n         decoder::translate_def_id(cdata, did)\n     }\n@@ -528,7 +526,7 @@ impl tr for ty::TraitStore {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: &mut Encoder, fv: @freevar_entry) {\n+fn encode_freevar_entry(ebml_w: &mut Encoder, fv: &freevar_entry) {\n     (*fv).encode(ebml_w).unwrap();\n }\n \n@@ -660,7 +658,7 @@ impl tr for MethodOrigin {\n fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n                               ebml_w: &mut Encoder,\n                               autoderef: u32,\n-                              dr: typeck::vtable_res) {\n+                              dr: &typeck::vtable_res) {\n     ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n         ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n             autoderef.encode(ebml_w)\n@@ -673,19 +671,19 @@ fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n \n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut Encoder,\n-                     dr: typeck::vtable_res) {\n+                     dr: &typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n     ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n-        Ok(encode_vtable_param_res(ecx, ebml_w, *param_tables))\n+        Ok(encode_vtable_param_res(ecx, ebml_w, param_tables))\n     }).unwrap()\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut Encoder,\n-                     param_tables: typeck::vtable_param_res) {\n+                     param_tables: &typeck::vtable_param_res) {\n     ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n         Ok(encode_vtable_origin(ecx, ebml_w, vtable_origin))\n     }).unwrap()\n@@ -697,7 +695,7 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         vtable_origin: &typeck::vtable_origin) {\n     ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n         match *vtable_origin {\n-          typeck::vtable_static(def_id, ref tys, vtable_res) => {\n+          typeck::vtable_static(def_id, ref tys, ref vtable_res) => {\n             ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n                 ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     Ok(ebml_w.emit_def_id(def_id))\n@@ -727,23 +725,23 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n pub trait vtable_decoder_helpers {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n-                                cdata: @cstore::crate_metadata)\n+                                cdata: &cstore::crate_metadata)\n                                 -> (u32, typeck::vtable_res);\n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_res;\n     fn read_vtable_param_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_param_res;\n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                           -> typeck::vtable_origin;\n }\n \n impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n-                                cdata: @cstore::crate_metadata)\n+                                cdata: &cstore::crate_metadata)\n                                 -> (u32, typeck::vtable_res) {\n         self.read_struct(\"VtableWithKey\", 2, |this| {\n             let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n@@ -756,27 +754,21 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|this|\n-                          Ok(this.read_vtable_param_res(tcx, cdata)))\n-             .unwrap()\n-             .move_iter()\n-             .collect()\n+        self.read_to_vec(|this| Ok(this.read_vtable_param_res(tcx, cdata)))\n+             .unwrap().move_iter().collect()\n     }\n \n     fn read_vtable_param_res(&mut self,\n-                             tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                             tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n-        @self.read_to_vec(|this|\n-                          Ok(this.read_vtable_origin(tcx, cdata)))\n-             .unwrap()\n-             .move_iter()\n-             .collect()\n+        self.read_to_vec(|this| Ok(this.read_vtable_origin(tcx, cdata)))\n+             .unwrap().move_iter().collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n         -> typeck::vtable_origin {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n@@ -828,7 +820,7 @@ impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_str,\n             tcx: self.tcx,\n-            abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)\n+            abbrevs: &self.type_abbrevs\n         }\n     }\n }\n@@ -1026,7 +1018,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                 ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n-                    Ok(encode_freevar_entry(ebml_w, *fv_entry))\n+                    Ok(encode_freevar_entry(ebml_w, fv_entry))\n                 });\n             })\n         })\n@@ -1052,7 +1044,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let method_call = MethodCall::expr(id);\n-    for &method in maps.method_map.borrow().find(&method_call).iter() {\n+    for &method in tcx.method_map.borrow().find(&method_call).iter() {\n         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1061,21 +1053,21 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &dr in maps.vtable_map.borrow().find(&method_call).iter() {\n+    for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n         ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_vtable_res_with_key(ecx, ebml_w, method_call.autoderef, *dr);\n+                encode_vtable_res_with_key(ecx, ebml_w, method_call.autoderef, dr);\n             })\n         })\n     }\n \n-    for adj in tcx.adjustments.borrow().find(&id).iter() {\n-        match ***adj {\n+    for &adj in tcx.adjustments.borrow().find(&id).iter() {\n+        match *adj {\n             ty::AutoDerefRef(adj) => {\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef as u32);\n-                    for &method in maps.method_map.borrow().find(&method_call).iter() {\n+                    for &method in tcx.method_map.borrow().find(&method_call).iter() {\n                         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n                             ebml_w.id(id);\n                             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1084,12 +1076,12 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                         })\n                     }\n \n-                    for &dr in maps.vtable_map.borrow().find(&method_call).iter() {\n+                    for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n                         ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n                             ebml_w.id(id);\n                             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                                 encode_vtable_res_with_key(ecx, ebml_w,\n-                                                           method_call.autoderef, *dr);\n+                                                           method_call.autoderef, dr);\n                             })\n                         })\n                     }\n@@ -1101,7 +1093,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_auto_adjustment(ecx, **adj);\n+                ebml_w.emit_auto_adjustment(ecx, adj);\n             })\n         })\n     }\n@@ -1148,15 +1140,15 @@ trait ebml_decoder_decoder_helpers {\n     // Versions of the type reading functions that don't need the full\n     // ExtendedDecodeContext.\n     fn read_ty_noxcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n+                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t;\n     fn read_tys_noxcx(&mut self,\n                       tcx: &ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> Vec<ty::t>;\n+                      cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n+                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_ty_data(\n                 doc.data,\n@@ -1169,7 +1161,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_tys_noxcx(&mut self,\n                       tcx: &ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n+                      cdata: &cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| Ok(this.read_ty_noxcx(tcx, cdata)) )\n             .unwrap()\n             .move_iter()\n@@ -1378,8 +1370,8 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.node_type_substs.borrow_mut().insert(id, tys);\n                     }\n                     c::tag_table_freevars => {\n-                        let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n-                            Ok(@val_dsr.read_freevar_entry(xcx))\n+                        let fv_info = val_dsr.read_to_vec(|val_dsr| {\n+                            Ok(val_dsr.read_freevar_entry(xcx))\n                         }).unwrap().move_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n@@ -1398,7 +1390,7 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                             expr_id: id,\n                             autoderef: autoderef\n                         };\n-                        dcx.maps.method_map.borrow_mut().insert(method_call, method);\n+                        dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }\n                     c::tag_table_vtable_map => {\n                         let (autoderef, vtable_res) =\n@@ -1408,10 +1400,10 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                             expr_id: id,\n                             autoderef: autoderef\n                         };\n-                        dcx.maps.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n+                        dcx.tcx.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n                     }\n                     c::tag_table_adjustments => {\n-                        let adj: @ty::AutoAdjustment = @val_dsr.read_auto_adjustment(xcx);\n+                        let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(xcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n                     c::tag_table_capture_map => {"}, {"sha": "e09507f5d5f44ac9fdc296796a6ad9dd19c0735a", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -30,6 +30,8 @@ use syntax::visit::Visitor;\n use syntax::visit;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n+\n struct CheckLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt<'a>,\n     dfcx_loans: &'a LoanDataFlow<'a>,\n@@ -82,7 +84,7 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n #[deriving(Eq)]\n enum MoveError {\n     MoveOk,\n-    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/Span)\n+    MoveWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)\n }\n \n impl<'a> CheckLoanCtxt<'a> {\n@@ -121,7 +123,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n     pub fn each_in_scope_restriction(&self,\n                                      scope_id: ast::NodeId,\n-                                     loan_path: @LoanPath,\n+                                     loan_path: &LoanPath,\n                                      op: |&Loan, &Restriction| -> bool)\n                                      -> bool {\n         //! Iterates through all the in-scope restrictions for the\n@@ -133,7 +135,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n             let mut ret = true;\n             for restr in loan.restrictions.iter() {\n-                if restr.loan_path == loan_path {\n+                if *restr.loan_path == *loan_path {\n                     if !op(loan, restr) {\n                         ret = false;\n                         break;\n@@ -243,7 +245,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 \"it\".to_owned()\n             } else {\n                 format!(\"`{}`\",\n-                        self.bccx.loan_path_to_str(old_loan.loan_path))\n+                        self.bccx.loan_path_to_str(&*old_loan.loan_path))\n             };\n \n             match (new_loan.kind, old_loan.kind) {\n@@ -252,15 +254,15 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as mutable \\\n                                 more than once at a time\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path)));\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n                                 old_pronoun));\n                 }\n \n@@ -269,7 +271,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n                                 previous closure requires unique access\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n                                 new_loan.kind.to_user_str()));\n                 }\n \n@@ -278,7 +280,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n                                 {} is also borrowed as {}\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n                                 new_loan.kind.to_user_str(),\n                                 old_pronoun,\n                                 old_loan.kind.to_user_str()));\n@@ -290,7 +292,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path)));\n                 }\n                 _ => { }\n             }\n@@ -300,34 +302,34 @@ impl<'a> CheckLoanCtxt<'a> {\n                     format!(\"the mutable borrow prevents subsequent \\\n                             moves, borrows, or modification of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n                 ty::ImmBorrow => {\n                     format!(\"the immutable borrow prevents subsequent \\\n                             moves or mutable borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n                 ty::UniqueImmBorrow => {\n                     format!(\"the unique capture prevents subsequent \\\n                             moves or borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n             };\n \n             let borrow_summary = match old_loan.cause {\n                 ClosureCapture(_) => {\n                     format!(\"previous borrow of `{}` occurs here due to \\\n                             use in closure\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n                 AddrOf | AutoRef | RefBinding => {\n                     format!(\"previous borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n             };\n \n@@ -356,7 +358,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                                   id: ast::NodeId,\n                                   span: Span,\n                                   use_kind: MovedValueUseKind,\n-                                  lp: @LoanPath) {\n+                                  lp: &Rc<LoanPath>) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -368,7 +370,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             self.bccx.report_use_of_moved_value(\n                 span,\n                 use_kind,\n-                lp,\n+                &**lp,\n                 move,\n                 moved_lp);\n             false\n@@ -378,7 +380,7 @@ impl<'a> CheckLoanCtxt<'a> {\n     pub fn check_assignment(&self, expr: &ast::Expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.borrow().find_copy(&expr.id) {\n+        let cmt = match self.bccx.tcx.adjustments.borrow().find(&expr.id) {\n             None => self.bccx.cat_expr_unadjusted(expr),\n             Some(adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n@@ -388,10 +390,9 @@ impl<'a> CheckLoanCtxt<'a> {\n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n         if cmt.mutbl.is_mutable() {\n-            if check_for_aliasable_mutable_writes(self, expr, cmt) {\n+            if check_for_aliasable_mutable_writes(self, expr, cmt.clone()) {\n                 if check_for_assignment_to_restricted_or_frozen_location(\n-                    self, expr, cmt)\n-                {\n+                    self, expr, cmt.clone()) {\n                     // Safe, but record for lint pass later:\n                     mark_variable_as_used_mut(self, cmt);\n                 }\n@@ -401,35 +402,35 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         // For immutable local variables, assignments are legal\n         // if they cannot already have been assigned\n-        if self.is_local_variable(cmt) {\n+        if self.is_local_variable(cmt.clone()) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(cmt).unwrap();\n-            self.move_data.each_assignment_of(expr.id, lp, |assign| {\n+            let lp = opt_loan_path(&cmt).unwrap();\n+            self.move_data.each_assignment_of(expr.id, &lp, |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,\n-                    lp,\n+                    &*lp,\n                     assign);\n                 false\n             });\n             return;\n         }\n \n         // Otherwise, just a plain error.\n-        match opt_loan_path(cmt) {\n+        match opt_loan_path(&cmt) {\n             Some(lp) => {\n                 self.bccx.span_err(\n                     expr.span,\n                     format!(\"cannot assign to {} {} `{}`\",\n                             cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(cmt),\n-                            self.bccx.loan_path_to_str(lp)));\n+                            self.bccx.cmt_to_str(&*cmt),\n+                            self.bccx.loan_path_to_str(&*lp)));\n             }\n             None => {\n                 self.bccx.span_err(\n                     expr.span,\n                     format!(\"cannot assign to {} {}\",\n                             cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(cmt)));\n+                            self.bccx.cmt_to_str(&*cmt)));\n             }\n         }\n         return;\n@@ -446,7 +447,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             loop {\n                 debug!(\"mark_writes_through_upvars_as_used_mut(cmt={})\",\n                        cmt.repr(this.tcx()));\n-                match cmt.cat {\n+                match cmt.cat.clone() {\n                     mc::cat_local(id) | mc::cat_arg(id) => {\n                         this.tcx().used_mut_nodes.borrow_mut().insert(id);\n                         return;\n@@ -494,10 +495,10 @@ impl<'a> CheckLoanCtxt<'a> {\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n-                mc::cat_deref(b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n+                mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n-                    check_for_aliasability_violation(this, expr, b);\n+                    check_for_aliasability_violation(this, expr, b.clone());\n                 }\n \n                 _ => {}\n@@ -535,7 +536,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             //! Check for assignments that violate the terms of an\n             //! outstanding loan.\n \n-            let loan_path = match opt_loan_path(cmt) {\n+            let loan_path = match opt_loan_path(&cmt) {\n                 Some(lp) => lp,\n                 None => { return true; /* no loan path, can't be any loans */ }\n             };\n@@ -571,10 +572,10 @@ impl<'a> CheckLoanCtxt<'a> {\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n             let cont = this.each_in_scope_restriction(expr.id,\n-                                                      loan_path,\n+                                                      &*loan_path,\n                                                       |loan, restr| {\n                 if restr.set.intersects(RESTR_MUTATE) {\n-                    this.report_illegal_mutation(expr, loan_path, loan);\n+                    this.report_illegal_mutation(expr, &*loan_path, loan);\n                     false\n                 } else {\n                     true\n@@ -623,17 +624,17 @@ impl<'a> CheckLoanCtxt<'a> {\n             //\n             // Here the restriction that `v` not be mutated would be misapplied\n             // to block the subpath `v[1]`.\n-            let full_loan_path = loan_path;\n+            let full_loan_path = loan_path.clone();\n             let mut loan_path = loan_path;\n             loop {\n-                match *loan_path {\n+                loan_path = match *loan_path {\n                     // Peel back one layer if, for `loan_path` to be\n                     // mutable, `lp_base` must be mutable. This occurs\n                     // with inherited mutability and with `&mut`\n                     // pointers.\n-                    LpExtend(lp_base, mc::McInherited, _) |\n-                    LpExtend(lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n-                        loan_path = lp_base;\n+                    LpExtend(ref lp_base, mc::McInherited, _) |\n+                    LpExtend(ref lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n+                        lp_base.clone()\n                     }\n \n                     // Otherwise stop iterating\n@@ -642,12 +643,12 @@ impl<'a> CheckLoanCtxt<'a> {\n                     LpVar(_) => {\n                         return true;\n                     }\n-                }\n+                };\n \n                 // Check for a non-const loan of `loan_path`\n                 let cont = this.each_in_scope_loan(expr.id, |loan| {\n                     if loan.loan_path == loan_path {\n-                        this.report_illegal_mutation(expr, full_loan_path, loan);\n+                        this.report_illegal_mutation(expr, &*full_loan_path, loan);\n                         false\n                     } else {\n                         true\n@@ -700,7 +701,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                                self.bccx.loan_path_to_str(loan_path)));\n+                                self.bccx.loan_path_to_str(&*loan_path)));\n                 }\n             }\n             true\n@@ -712,13 +713,12 @@ impl<'a> CheckLoanCtxt<'a> {\n                                 span: Span) {\n         for cap_var in self.bccx.capture_map.get(&closure_id).iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            let var_path = @LpVar(var_id);\n             self.check_if_path_is_moved(closure_id, span,\n-                                        MovedInCapture, var_path);\n+                                        MovedInCapture, &Rc::new(LpVar(var_id)));\n             match cap_var.mode {\n                 moves::CapRef | moves::CapCopy => {}\n                 moves::CapMove => {\n-                    check_by_move_capture(self, closure_id, cap_var, var_path);\n+                    check_by_move_capture(self, closure_id, cap_var, &LpVar(var_id));\n                 }\n             }\n         }\n@@ -727,7 +727,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         fn check_by_move_capture(this: &CheckLoanCtxt,\n                                  closure_id: ast::NodeId,\n                                  cap_var: &moves::CaptureVar,\n-                                 move_path: @LoanPath) {\n+                                 move_path: &LoanPath) {\n             let move_err = this.analyze_move_out_from(closure_id, move_path);\n             match move_err {\n                 MoveOk => {}\n@@ -740,38 +740,39 @@ impl<'a> CheckLoanCtxt<'a> {\n                     this.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                                this.bccx.loan_path_to_str(loan_path)));\n+                                this.bccx.loan_path_to_str(&*loan_path)));\n                 }\n             }\n         }\n     }\n \n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n-                                 mut move_path: @LoanPath)\n+                                 move_path: &LoanPath)\n                                  -> MoveError {\n         debug!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n                self.tcx().map.node_to_str(expr_id),\n                move_path.repr(self.tcx()));\n \n         // We must check every element of a move path. See\n         // `borrowck-move-subcomponent.rs` for a test case.\n-        loop {\n-            // check for a conflicting loan:\n-            let mut ret = MoveOk;\n-            self.each_in_scope_restriction(expr_id, move_path, |loan, _| {\n-                // Any restriction prevents moves.\n-                ret = MoveWhileBorrowed(loan.loan_path, loan.span);\n-                false\n-            });\n \n-            if ret != MoveOk {\n-                return ret\n-            }\n+        // check for a conflicting loan:\n+        let mut ret = MoveOk;\n+        self.each_in_scope_restriction(expr_id, move_path, |loan, _| {\n+            // Any restriction prevents moves.\n+            ret = MoveWhileBorrowed(loan.loan_path.clone(), loan.span);\n+            false\n+        });\n+\n+        if ret != MoveOk {\n+            return ret\n+        }\n \n-            match *move_path {\n-                LpVar(_) => return MoveOk,\n-                LpExtend(subpath, _, _) => move_path = subpath,\n+        match *move_path {\n+            LpVar(_) => MoveOk,\n+            LpExtend(ref subpath, _, _) => {\n+                self.analyze_move_out_from(expr_id, &**subpath)\n             }\n         }\n     }\n@@ -806,14 +807,13 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n     this.check_for_conflicting_loans(expr.id);\n     this.check_move_out_from_expr(expr);\n \n-    let method_map = this.bccx.method_map.borrow();\n+    let method_map = this.bccx.tcx.method_map.borrow();\n     match expr.node {\n       ast::ExprPath(..) => {\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt={}\", cmt.repr(this.tcx()));\n-              let r = opt_loan_path(cmt);\n-              for &lp in r.iter() {\n+              for lp in opt_loan_path(&cmt).iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n               }\n           }"}, {"sha": "f4eee0526dd9321ebb2a9e5f91bae43093d8fe7b", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -23,6 +23,8 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n+\n struct GatherMoveInfo {\n     id: ast::NodeId,\n     kind: MoveKind,\n@@ -35,7 +37,7 @@ pub fn gather_decl(bccx: &BorrowckCtxt,\n                    decl_id: ast::NodeId,\n                    _decl_span: Span,\n                    var_id: ast::NodeId) {\n-    let loan_path = @LpVar(var_id);\n+    let loan_path = Rc::new(LpVar(var_id));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n \n@@ -105,7 +107,7 @@ fn gather_move(bccx: &BorrowckCtxt,\n            move_info.id, move_info.cmt.repr(bccx.tcx));\n \n     let potentially_illegal_move =\n-                check_and_get_illegal_move_origin(bccx, move_info.cmt);\n+                check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n     match potentially_illegal_move {\n         Some(illegal_move_origin) => {\n             let error = MoveError::with_move_info(illegal_move_origin,\n@@ -116,7 +118,7 @@ fn gather_move(bccx: &BorrowckCtxt,\n         None => ()\n     }\n \n-    match opt_loan_path(move_info.cmt) {\n+    match opt_loan_path(&move_info.cmt) {\n         Some(loan_path) => {\n             move_data.add_move(bccx.tcx, loan_path,\n                                move_info.id, move_info.kind);\n@@ -131,7 +133,7 @@ pub fn gather_assignment(bccx: &BorrowckCtxt,\n                          move_data: &MoveData,\n                          assignment_id: ast::NodeId,\n                          assignment_span: Span,\n-                         assignee_loan_path: @LoanPath,\n+                         assignee_loan_path: Rc<LoanPath>,\n                          assignee_id: ast::NodeId) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,\n@@ -145,7 +147,7 @@ pub fn gather_move_and_assignment(bccx: &BorrowckCtxt,\n                                   move_data: &MoveData,\n                                   assignment_id: ast::NodeId,\n                                   assignment_span: Span,\n-                                  assignee_loan_path: @LoanPath,\n+                                  assignee_loan_path: Rc<LoanPath>,\n                                   assignee_id: ast::NodeId) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,\n@@ -156,14 +158,14 @@ pub fn gather_move_and_assignment(bccx: &BorrowckCtxt,\n }\n \n fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n-                                     cmt: mc::cmt) -> Option<mc::cmt> {\n+                                     cmt: &mc::cmt) -> Option<mc::cmt> {\n     match cmt.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::GcPtr) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n         mc::cat_upvar(..) | mc::cat_static_item |\n         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n-            Some(cmt)\n+            Some(cmt.clone())\n         }\n \n         // Can move out of captured upvars only if the destination closure\n@@ -179,12 +181,12 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n             None\n         }\n \n-        mc::cat_downcast(b) |\n-        mc::cat_interior(b, _) => {\n+        mc::cat_downcast(ref b) |\n+        mc::cat_interior(ref b, _) => {\n             match ty::get(b.ty).sty {\n                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n                     if ty::has_dtor(bccx.tcx, did) {\n-                        Some(cmt)\n+                        Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)\n                     }\n@@ -195,8 +197,8 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n             }\n         }\n \n-        mc::cat_deref(b, _, mc::OwnedPtr) |\n-        mc::cat_discr(b, _) => {\n+        mc::cat_deref(ref b, _, mc::OwnedPtr) |\n+        mc::cat_discr(ref b, _) => {\n             check_and_get_illegal_move_origin(bccx, b)\n         }\n     }"}, {"sha": "a27fe5cec225260b32d44ec880199c97c330e4d2", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -39,9 +39,9 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                                          cause: cause,\n                                          loan_region: loan_region,\n                                          loan_kind: loan_kind,\n-                                         cmt_original: cmt,\n+                                         cmt_original: cmt.clone(),\n                                          root_scope_id: root_scope_id};\n-    ctxt.check(cmt, None)\n+    ctxt.check(&cmt, None)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -69,7 +69,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         self.bccx.tcx\n     }\n \n-    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n+    fn check(&self, cmt: &mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n         debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n                cmt.repr(self.bccx.tcx),\n@@ -83,15 +83,14 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_upvar(..) |\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n-                let scope = self.scope(cmt);\n-                self.check_scope(scope)\n+                self.check_scope(self.scope(cmt))\n             }\n \n             mc::cat_static_item => {\n                 Ok(())\n             }\n \n-            mc::cat_deref(base, derefs, mc::GcPtr) => {\n+            mc::cat_deref(ref base, derefs, mc::GcPtr) => {\n                 let base_scope = self.scope(base);\n \n                 // L-Deref-Managed-Imm-User-Root\n@@ -111,13 +110,13 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 }\n             }\n \n-            mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::OwnedPtr) |     // L-Deref-Send\n-            mc::cat_interior(base, _) => {             // L-Field\n+            mc::cat_downcast(ref base) |\n+            mc::cat_deref(ref base, _, mc::OwnedPtr) |     // L-Deref-Send\n+            mc::cat_interior(ref base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n \n-            mc::cat_discr(base, new_discr_scope) => {\n+            mc::cat_discr(ref base, new_discr_scope) => {\n                 // Subtle: in a match, we must ensure that each binding\n                 // variable remains valid for the duration of the arm in\n                 // which it appears, presuming that this arm is taken.\n@@ -176,7 +175,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n     }\n \n     fn is_rvalue_or_immutable(&self,\n-                              cmt: mc::cmt) -> bool {\n+                              cmt: &mc::cmt) -> bool {\n         //! We can omit the root on an `@T` value if the location\n         //! that holds the box is either (1) an rvalue, in which case\n         //! it is in a non-user-accessible temporary, or (2) an immutable\n@@ -189,8 +188,8 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n     }\n \n     fn check_root(&self,\n-                  cmt_deref: mc::cmt,\n-                  cmt_base: mc::cmt,\n+                  cmt_deref: &mc::cmt,\n+                  cmt_base: &mc::cmt,\n                   derefs: uint,\n                   discr_scope: Option<ast::NodeId>) -> R {\n         debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, \\\n@@ -253,7 +252,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         }\n     }\n \n-    fn is_moved(&self, cmt: mc::cmt) -> bool {\n+    fn is_moved(&self, cmt: &mc::cmt) -> bool {\n         //! True if `cmt` is something that is potentially moved\n         //! out of the current stack frame.\n \n@@ -269,17 +268,17 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_upvar(..) => {\n                 false\n             }\n-            r @ mc::cat_downcast(..) |\n-            r @ mc::cat_interior(..) |\n-            r @ mc::cat_discr(..) => {\n+            ref r @ mc::cat_downcast(..) |\n+            ref r @ mc::cat_interior(..) |\n+            ref r @ mc::cat_discr(..) => {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n                     format!(\"illegal guarantor category: {:?}\", r));\n             }\n         }\n     }\n \n-    fn scope(&self, cmt: mc::cmt) -> ty::Region {\n+    fn scope(&self, cmt: &mc::cmt) -> ty::Region {\n         //! Returns the maximal region scope for the which the\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n@@ -307,18 +306,18 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_deref(_, _, mc::BorrowedPtr(_, r)) => {\n                 r\n             }\n-            mc::cat_downcast(cmt) |\n-            mc::cat_deref(cmt, _, mc::OwnedPtr) |\n-            mc::cat_deref(cmt, _, mc::GcPtr) |\n-            mc::cat_interior(cmt, _) |\n-            mc::cat_discr(cmt, _) => {\n+            mc::cat_downcast(ref cmt) |\n+            mc::cat_deref(ref cmt, _, mc::OwnedPtr) |\n+            mc::cat_deref(ref cmt, _, mc::GcPtr) |\n+            mc::cat_interior(ref cmt, _) |\n+            mc::cat_discr(ref cmt, _) => {\n                 self.scope(cmt)\n             }\n         }\n     }\n \n     fn report_error(&self, code: bckerr_code) {\n-        self.bccx.report(BckError { cmt: self.cmt_original,\n+        self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n                                     span: self.span,\n                                     cause: self.cause,\n                                     code: code });"}, {"sha": "7f748dffd702b6d16f27db7c19929974bb9a8ee4", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -36,6 +36,8 @@ use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{Expr, FnDecl, Block, NodeId, Stmt, Pat, Local};\n \n+use std::rc::Rc;\n+\n mod lifetime;\n mod restrictions;\n mod gather_moves;\n@@ -146,7 +148,7 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n         None => {\n             // Variable declarations without initializers are considered \"moves\":\n             let tcx = this.bccx.tcx;\n-            pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n+            pat_util::pat_bindings(&tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_decl(this.bccx,\n                                           &this.move_data,\n                                           id,\n@@ -177,7 +179,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for &adjustments in tcx.adjustments.borrow().find(&ex.id).iter() {\n-        this.guarantee_adjustments(ex, *adjustments);\n+        this.guarantee_adjustments(ex, adjustments);\n     }\n \n     // If this expression is a move, gather it:\n@@ -188,7 +190,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     }\n \n     // Special checks for various kinds of expressions:\n-    let method_map = this.bccx.method_map.borrow();\n+    let method_map = this.bccx.tcx.method_map.borrow();\n     match ex.node {\n       ast::ExprAddrOf(mutbl, base) => {\n         let base_cmt = this.bccx.cat_expr(base);\n@@ -228,7 +230,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n         let cmt = this.bccx.cat_expr(ex_v);\n         for arm in arms.iter() {\n             for pat in arm.pats.iter() {\n-                this.gather_pat(cmt, *pat, Some((arm.body.id, ex.id)));\n+                this.gather_pat(cmt.clone(), *pat, Some((arm.body.id, ex.id)));\n             }\n         }\n         visit::walk_expr(this, ex, ());\n@@ -296,9 +298,9 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     }\n }\n \n-fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |@LoanPath|) {\n+fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |Rc<LoanPath>|) {\n     let cmt = bccx.cat_expr(expr);\n-    match opt_loan_path(cmt) {\n+    match opt_loan_path(&cmt) {\n         Some(lp) => op(lp),\n         None => {\n             // This can occur with e.g. `*foo() = 5`.  In such\n@@ -375,14 +377,13 @@ impl<'a> GatherLoanCtxt<'a> {\n     pub fn guarantee_autoderefs(&mut self,\n                                 expr: &ast::Expr,\n                                 autoderefs: uint) {\n-        let method_map = self.bccx.method_map.borrow();\n+        let method_map = self.bccx.tcx.method_map.borrow();\n         for i in range(0, autoderefs) {\n             match method_map.find(&MethodCall::autoderef(expr.id, i as u32)) {\n                 Some(method) => {\n                     // Treat overloaded autoderefs as if an AutoRef adjustment\n                     // was applied on the base type, as that is always the case.\n-                    let mut mc = self.bccx.mc();\n-                    let cmt = match mc.cat_expr_autoderefd(expr, i) {\n+                    let cmt = match self.bccx.mc().cat_expr_autoderefd(expr, i) {\n                         Ok(v) => v,\n                         Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n                     };\n@@ -431,7 +432,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                     autoref: Some(ref autoref),\n                     autoderefs}) => {\n                 self.guarantee_autoderefs(expr, autoderefs);\n-                let mut mc = self.bccx.mc();\n+                let mc = self.bccx.mc();\n                 let cmt = match mc.cat_expr_autoderefd(expr, autoderefs) {\n                     Ok(v) => v,\n                     Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n@@ -551,28 +552,28 @@ impl<'a> GatherLoanCtxt<'a> {\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n         if lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n-                                        borrow_span, cause, cmt, loan_region,\n+                                        borrow_span, cause, cmt.clone(), loan_region,\n                                         req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n         if check_mutability(self.bccx, borrow_span, cause,\n-                            cmt, req_kind).is_err() {\n+                            cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n         if check_aliasability(self.bccx, borrow_span, cause,\n-                              cmt, req_kind).is_err() {\n+                              cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n             self.bccx, borrow_span, cause,\n-            cmt, loan_region, self.restriction_set(req_kind));\n+            cmt.clone(), loan_region, self.restriction_set(req_kind));\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -612,11 +613,11 @@ impl<'a> GatherLoanCtxt<'a> {\n                 let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n-                let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n+                let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n                 debug!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_kind == ty::MutBorrow {\n-                    self.mark_loan_path_as_mutated(loan_path);\n+                    self.mark_loan_path_as_mutated(&*loan_path);\n                 }\n \n                 Loan {\n@@ -718,16 +719,16 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    pub fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n+    pub fn mark_loan_path_as_mutated(&self, loan_path: &LoanPath) {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary.\n \n         match *loan_path {\n             LpVar(local_id) => {\n                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n             }\n-            LpExtend(base, mc::McInherited, _) => {\n-                self.mark_loan_path_as_mutated(base);\n+            LpExtend(ref base, mc::McInherited, _) => {\n+                self.mark_loan_path_as_mutated(&**base);\n             }\n             LpExtend(_, mc::McDeclared, _) |\n             LpExtend(_, mc::McImmutable, _) => {\n@@ -752,7 +753,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: ast::NodeId, lp: @LoanPath)\n+    pub fn compute_kill_scope(&self, loan_scope: ast::NodeId, lp: &LoanPath)\n                               -> ast::NodeId {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n@@ -793,7 +794,7 @@ impl<'a> GatherLoanCtxt<'a> {\n          * `gather_pat()`.\n          */\n \n-        let mut mc = self.bccx.mc();\n+        let mc = self.bccx.mc();\n         for arg in decl.inputs.iter() {\n             let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n \n@@ -822,12 +823,12 @@ impl<'a> GatherLoanCtxt<'a> {\n               ast::PatIdent(bm, _, _) if self.pat_is_binding(pat) => {\n                 // Each match binding is effectively an assignment.\n                 let tcx = self.bccx.tcx;\n-                pat_util::pat_bindings(tcx.def_map, pat, |_, id, span, _| {\n+                pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n                     gather_moves::gather_assignment(self.bccx,\n                                                     &self.move_data,\n                                                     id,\n                                                     span,\n-                                                    @LpVar(id),\n+                                                    Rc::new(LpVar(id)),\n                                                     id);\n                 });\n \n@@ -920,7 +921,7 @@ impl<'a> GatherLoanCtxt<'a> {\n     }\n \n     pub fn pat_is_binding(&self, pat: &ast::Pat) -> bool {\n-        pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n+        pat_util::pat_is_binding(&self.bccx.tcx.def_map, pat)\n     }\n \n     pub fn report_potential_errors(&self) {"}, {"sha": "24d873e0ff76b878c353c9f31783c734bf2eac7b", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -79,7 +79,7 @@ pub struct GroupedMoveErrors {\n fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n     let grouped_errors = group_errors_with_same_origin(errors);\n     for error in grouped_errors.iter() {\n-        report_cannot_move_out_of(bccx, error.move_from);\n+        report_cannot_move_out_of(bccx, error.move_from.clone());\n         let mut is_first_note = true;\n         for move_to in error.move_to_places.iter() {\n             note_move_destination(bccx, move_to.span,\n@@ -112,7 +112,7 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n             }\n         }\n         grouped_errors.push(GroupedMoveErrors {\n-            move_from: error.move_from,\n+            move_from: error.move_from.clone(),\n             move_to_places: move_to\n         })\n     }\n@@ -128,11 +128,11 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_str(move_from)));\n+                        bccx.cmt_to_str(&*move_from)));\n         }\n \n-        mc::cat_downcast(b) |\n-        mc::cat_interior(b, _) => {\n+        mc::cat_downcast(ref b) |\n+        mc::cat_interior(ref b, _) => {\n             match ty::get(b.ty).sty {\n                 ty::ty_struct(did, _)\n                 | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {"}, {"sha": "de4ce84fb0a59fd655886e49f8d472dbaba98d9b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -18,9 +18,11 @@ use middle::ty;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n+\n pub enum RestrictionResult {\n     Safe,\n-    SafeIf(@LoanPath, Vec<Restriction> )\n+    SafeIf(Rc<LoanPath>, Vec<Restriction>)\n }\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n@@ -33,7 +35,7 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n         bccx: bccx,\n         span: span,\n         cause: cause,\n-        cmt_original: cmt,\n+        cmt_original: cmt.clone(),\n         loan_region: loan_region,\n     };\n \n@@ -59,7 +61,7 @@ impl<'a> RestrictionsContext<'a> {\n                cmt.repr(self.bccx.tcx),\n                restrictions.repr(self.bccx.tcx));\n \n-        match cmt.cat {\n+        match cmt.cat.clone() {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n                 // non-aliasable temporary on the stack. Since they\n@@ -73,9 +75,11 @@ impl<'a> RestrictionsContext<'a> {\n             mc::cat_arg(local_id) |\n             mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n                 // R-Variable\n-                let lp = @LpVar(local_id);\n-                SafeIf(lp, vec!(Restriction {loan_path: lp,\n-                                          set: restrictions}))\n+                let lp = Rc::new(LpVar(local_id));\n+                SafeIf(lp.clone(), vec!(Restriction {\n+                    loan_path: lp,\n+                    set: restrictions\n+                }))\n             }\n \n             mc::cat_downcast(cmt_base) => {\n@@ -170,9 +174,13 @@ impl<'a> RestrictionsContext<'a> {\n               restrictions: RestrictionSet) -> RestrictionResult {\n         match result {\n             Safe => Safe,\n-            SafeIf(base_lp, base_vec) => {\n-                let lp = @LpExtend(base_lp, mc, elem);\n-                SafeIf(lp, base_vec.append_one(Restriction { loan_path: lp, set: restrictions }))\n+            SafeIf(base_lp, mut base_vec) => {\n+                let lp = Rc::new(LpExtend(base_lp, mc, elem));\n+                base_vec.push(Restriction {\n+                    loan_path: lp.clone(),\n+                    set: restrictions\n+                });\n+                SafeIf(lp, base_vec)\n             }\n         }\n     }"}, {"sha": "06491d36b021b5312ece3a25cb5b926800e66080", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 69, "deletions": 121, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -18,14 +18,14 @@ use middle::typeck;\n use middle::moves;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n-use util::nodemap::NodeSet;\n+use util::nodemap::{NodeMap, NodeSet};\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n-use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n+use std::cell::RefCell;\n use std::ops::{BitOr, BitAnd};\n-use std::result::Result;\n+use std::rc::Rc;\n use std::strbuf::StrBuf;\n+use collections::HashMap;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -76,49 +76,22 @@ impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   method_map: typeck::MethodMap,\n                    moves_map: &NodeSet,\n                    moved_variables_set: &NodeSet,\n                    capture_map: &moves::CaptureMap,\n                    krate: &ast::Crate)\n                    -> root_map {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        method_map: method_map,\n         moves_map: moves_map,\n         moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n-        root_map: root_map(),\n-        stats: @BorrowStats {\n-            loaned_paths_same: Cell::new(0),\n-            loaned_paths_imm: Cell::new(0),\n-            stable_paths: Cell::new(0),\n-            guaranteed_paths: Cell::new(0),\n-        }\n+        root_map: RefCell::new(HashMap::new())\n     };\n-    let bccx = &mut bccx;\n-\n-    visit::walk_crate(bccx, krate, ());\n \n-    if tcx.sess.borrowck_stats() {\n-        println!(\"--- borrowck stats ---\");\n-        println!(\"paths requiring guarantees: {}\",\n-                 bccx.stats.guaranteed_paths.get());\n-        println!(\"paths requiring loans     : {}\",\n-                 make_stat(bccx, bccx.stats.loaned_paths_same.get()));\n-        println!(\"paths requiring imm loans : {}\",\n-                 make_stat(bccx, bccx.stats.loaned_paths_imm.get()));\n-        println!(\"stable paths              : {}\",\n-                 make_stat(bccx, bccx.stats.stable_paths.get()));\n-    }\n-\n-    return bccx.root_map;\n+    visit::walk_crate(&mut bccx, krate, ());\n \n-    fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n-        let stat_f = stat as f64;\n-        let total = bccx.stats.guaranteed_paths.get() as f64;\n-        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n-    }\n+    return bccx.root_map.unwrap();\n }\n \n fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n@@ -149,7 +122,6 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n         gather_loans::gather_loans_in_fn(this, decl, body);\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n-                             this.method_map,\n                              LoanDataFlowOperator,\n                              id_range,\n                              all_loans.len());\n@@ -161,7 +133,6 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n                                                       this.tcx,\n-                                                      this.method_map,\n                                                       id_range,\n                                                       body);\n \n@@ -176,21 +147,10 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n pub struct BorrowckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n-    method_map: typeck::MethodMap,\n     moves_map: &'a NodeSet,\n     moved_variables_set: &'a NodeSet,\n     capture_map: &'a moves::CaptureMap,\n-    root_map: root_map,\n-\n-    // Statistics:\n-    stats: @BorrowStats\n-}\n-\n-pub struct BorrowStats {\n-    loaned_paths_same: Cell<uint>,\n-    loaned_paths_imm: Cell<uint>,\n-    stable_paths: Cell<uint>,\n-    guaranteed_paths: Cell<uint>,\n+    root_map: RefCell<root_map>,\n }\n \n // The keys to the root map combine the `id` of the deref expression\n@@ -226,10 +186,10 @@ pub enum PartialTotal {\n /// Record of a loan that was issued.\n pub struct Loan {\n     index: uint,\n-    loan_path: @LoanPath,\n+    loan_path: Rc<LoanPath>,\n     cmt: mc::cmt,\n     kind: ty::BorrowKind,\n-    restrictions: Vec<Restriction> ,\n+    restrictions: Vec<Restriction>,\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,\n@@ -247,7 +207,7 @@ pub enum LoanCause {\n #[deriving(Eq, TotalEq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n-    LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n+    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n #[deriving(Eq, TotalEq, Hash)]\n@@ -260,12 +220,12 @@ impl LoanPath {\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n             LpVar(local_id) => local_id,\n-            LpExtend(base, _, _) => base.node_id()\n+            LpExtend(ref base, _, _) => base.node_id()\n         }\n     }\n }\n \n-pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n+pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n     //! Computes the `LoanPath` (if any) for a `cmt`.\n     //! Note that this logic is somewhat duplicated in\n     //! the method `compute()` found in `gather_loans::restrictions`,\n@@ -283,23 +243,23 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         mc::cat_arg(id) |\n         mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id, .. }) |\n         mc::cat_upvar(ty::UpvarId {var_id: id, ..}, _) => {\n-            Some(@LpVar(id))\n+            Some(Rc::new(LpVar(id)))\n         }\n \n-        mc::cat_deref(cmt_base, _, pk) => {\n+        mc::cat_deref(ref cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                @LpExtend(lp, cmt.mutbl, LpDeref(pk))\n+                Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n             })\n         }\n \n-        mc::cat_interior(cmt_base, ik) => {\n+        mc::cat_interior(ref cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                @LpExtend(lp, cmt.mutbl, LpInterior(ik))\n+                Rc::new(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n             })\n         }\n \n-        mc::cat_downcast(cmt_base) |\n-        mc::cat_discr(cmt_base, _) => {\n+        mc::cat_downcast(ref cmt_base) |\n+        mc::cat_discr(ref cmt_base, _) => {\n             opt_loan_path(cmt_base)\n         }\n     }\n@@ -319,7 +279,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // because the restriction against moves is implied.\n \n pub struct Restriction {\n-    loan_path: @LoanPath,\n+    loan_path: Rc<LoanPath>,\n     set: RestrictionSet\n }\n \n@@ -380,11 +340,7 @@ pub struct RootInfo {\n     pub scope: ast::NodeId,\n }\n \n-pub type root_map = @RefCell<HashMap<root_map_key, RootInfo>>;\n-\n-pub fn root_map() -> root_map {\n-    return @RefCell::new(HashMap::new());\n-}\n+pub type root_map = HashMap<root_map_key, RootInfo>;\n \n ///////////////////////////////////////////////////////////////////////////\n // Errors\n@@ -437,12 +393,9 @@ impl<'a> BorrowckCtxt<'a> {\n         self.moves_map.contains(&id)\n     }\n \n-    pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper<'a>> {\n+    pub fn mc(&self) -> mc::MemCategorizationContext<&'a ty::ctxt> {\n         mc::MemCategorizationContext {\n-            typer: TcxTyper {\n-                tcx: self.tcx,\n-                method_map: self.method_map\n-            }\n+            typer: self.tcx,\n         }\n     }\n \n@@ -516,14 +469,16 @@ impl<'a> BorrowckCtxt<'a> {\n     }\n \n     pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n-        @mc::cmt_ {cat:mc::cat_discr(cmt, match_id),\n-                   mutbl:cmt.mutbl.inherit(),\n-                   ..*cmt}\n+        Rc::new(mc::cmt_ {\n+            cat: mc::cat_discr(cmt.clone(), match_id),\n+            mutbl: cmt.mutbl.inherit(),\n+            ..*cmt\n+        })\n     }\n \n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n-                       pat: @ast::Pat,\n+                       pat: &ast::Pat,\n                        op: |mc::cmt, &ast::Pat|) {\n         let r = self.mc().cat_pattern(cmt, pat, |_,x,y| op(x,y));\n         assert!(r.is_ok());\n@@ -532,7 +487,7 @@ impl<'a> BorrowckCtxt<'a> {\n     pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_str(err));\n+            self.bckerr_to_str(&err));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -541,7 +496,7 @@ impl<'a> BorrowckCtxt<'a> {\n                                      use_kind: MovedValueUseKind,\n                                      lp: &LoanPath,\n                                      move: &move_data::Move,\n-                                     moved_lp: @LoanPath) {\n+                                     moved_lp: &LoanPath) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -572,8 +527,7 @@ impl<'a> BorrowckCtxt<'a> {\n             move_data::MoveExpr => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr,\n-                                              &*self.method_map.borrow()), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -599,8 +553,7 @@ impl<'a> BorrowckCtxt<'a> {\n             move_data::Captured => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr,\n-                                              &*self.method_map.borrow()), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -656,17 +609,17 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.sess.span_end_note(s, m);\n     }\n \n-    pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n+    pub fn bckerr_to_str(&self, err: &BckError) -> ~str {\n         match err.code {\n             err_mutbl => {\n-                let descr = match opt_loan_path(err.cmt) {\n+                let descr = match opt_loan_path(&err.cmt) {\n                     None => format!(\"{} {}\",\n                                     err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_str(err.cmt)),\n+                                    self.cmt_to_str(&*err.cmt)),\n                     Some(lp) => format!(\"{} {} `{}`\",\n                                         err.cmt.mutbl.to_user_str(),\n-                                        self.cmt_to_str(err.cmt),\n-                                        self.loan_path_to_str(lp)),\n+                                        self.cmt_to_str(&*err.cmt),\n+                                        self.loan_path_to_str(&*lp)),\n                 };\n \n                 match err.cause {\n@@ -682,16 +635,16 @@ impl<'a> BorrowckCtxt<'a> {\n                 format!(\"cannot root managed value long enough\")\n             }\n             err_out_of_scope(..) => {\n-                let msg = match opt_loan_path(err.cmt) {\n+                let msg = match opt_loan_path(&err.cmt) {\n                     None => format!(\"borrowed value\"),\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n                 };\n                 format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n-                let descr = match opt_loan_path(err.cmt) {\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n-                    None => self.cmt_to_str(err.cmt),\n+                let descr = match opt_loan_path(&err.cmt) {\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n+                    None => self.cmt_to_str(&*err.cmt),\n                 };\n \n                 format!(\"lifetime of {} is too short to guarantee \\\n@@ -783,9 +736,9 @@ impl<'a> BorrowckCtxt<'a> {\n             }\n \n             err_borrowed_pointer_too_short(loan_scope, ptr_scope, _) => {\n-                let descr = match opt_loan_path(err.cmt) {\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n-                    None => self.cmt_to_str(err.cmt),\n+                let descr = match opt_loan_path(&err.cmt) {\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n+                    None => self.cmt_to_str(&*err.cmt),\n                 };\n                 note_and_explain_region(\n                     self.tcx,\n@@ -809,8 +762,8 @@ impl<'a> BorrowckCtxt<'a> {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n-                self.append_autoderefd_loan_path_to_str(lp_base, out);\n+            LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n+                self.append_autoderefd_loan_path_to_str(&**lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n                         out.push_char('.');\n@@ -823,14 +776,14 @@ impl<'a> BorrowckCtxt<'a> {\n                 }\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n-                self.append_autoderefd_loan_path_to_str(lp_base, out);\n+            LpExtend(ref lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n+                self.append_autoderefd_loan_path_to_str(&**lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n \n-            LpExtend(lp_base, _, LpDeref(_)) => {\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 out.push_char('*');\n-                self.append_loan_path_to_str(lp_base, out);\n+                self.append_loan_path_to_str(&**lp_base, out);\n             }\n         }\n     }\n@@ -839,11 +792,11 @@ impl<'a> BorrowckCtxt<'a> {\n                                               loan_path: &LoanPath,\n                                               out: &mut StrBuf) {\n         match *loan_path {\n-            LpExtend(lp_base, _, LpDeref(_)) => {\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n                 // rules would normally allow users to omit the `*x`.\n                 // So just serialize such paths to `x.f` or x[3]` respectively.\n-                self.append_autoderefd_loan_path_to_str(lp_base, out)\n+                self.append_autoderefd_loan_path_to_str(&**lp_base, out)\n             }\n \n             LpVar(..) | LpExtend(_, _, LpInterior(..)) => {\n@@ -858,7 +811,7 @@ impl<'a> BorrowckCtxt<'a> {\n         result.into_owned()\n     }\n \n-    pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: &mc::cmt_) -> ~str {\n         self.mc().cmt_to_str(cmt)\n     }\n }\n@@ -902,11 +855,11 @@ impl Repr for LoanPath {\n                 format!(\"$({})\", tcx.map.node_to_str(id))\n             }\n \n-            &LpExtend(lp, _, LpDeref(_)) => {\n+            &LpExtend(ref lp, _, LpDeref(_)) => {\n                 format!(\"{}.*\", lp.repr(tcx))\n             }\n \n-            &LpExtend(lp, _, LpInterior(ref interior)) => {\n+            &LpExtend(ref lp, _, LpInterior(ref interior)) => {\n                 format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n             }\n         }\n@@ -915,37 +868,32 @@ impl Repr for LoanPath {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub struct TcxTyper<'a> {\n-    tcx: &'a ty::ctxt,\n-    method_map: typeck::MethodMap,\n-}\n-\n-impl<'a> mc::Typer for TcxTyper<'a> {\n+impl<'a> mc::Typer for &'a ty::ctxt {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n-        self.tcx\n+        *self\n     }\n \n-    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n-        Ok(ty::node_id_to_type(self.tcx, id))\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        Ok(ty::node_id_to_type(*self, id))\n     }\n \n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n         self.method_map.borrow().find(&method_call).map(|method| method.ty)\n     }\n \n-    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n-        self.tcx.adjustments.borrow().find_copy(&id)\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+        &self.adjustments\n     }\n \n-    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n         self.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n \n-    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n-        self.tcx.region_maps.temporary_scope(id)\n+    fn temporary_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.region_maps.temporary_scope(id)\n     }\n \n-    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.tcx.upvar_borrow_map.borrow().get_copy(&id)\n+    fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+        self.upvar_borrow_map.borrow().get_copy(&id)\n     }\n }"}, {"sha": "efdc103d14d1e0f40e0e7e7373e01a84973248e4", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -16,13 +16,13 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n */\n \n use std::cell::RefCell;\n+use std::rc::Rc;\n use std::uint;\n use collections::{HashMap, HashSet};\n use middle::borrowck::*;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n use middle::ty;\n-use middle::typeck;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -33,7 +33,7 @@ pub struct MoveData {\n     pub paths: RefCell<Vec<MovePath>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<HashMap<@LoanPath, MovePathIndex>>,\n+    pub path_map: RefCell<HashMap<Rc<LoanPath>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -97,7 +97,7 @@ static InvalidMoveIndex: MoveIndex =\n \n pub struct MovePath {\n     /// Loan path corresponding to this move path\n-    pub loan_path: @LoanPath,\n+    pub loan_path: Rc<LoanPath>,\n \n     /// Parent pointer, `InvalidMovePathIndex` if root\n     pub parent: MovePathIndex,\n@@ -182,8 +182,8 @@ impl MoveData {\n         }\n     }\n \n-    fn path_loan_path(&self, index: MovePathIndex) -> @LoanPath {\n-        self.paths.borrow().get(index.get()).loan_path\n+    fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n+        self.paths.borrow().get(index.get()).loan_path.clone()\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n@@ -226,7 +226,7 @@ impl MoveData {\n \n     pub fn move_path(&self,\n                      tcx: &ty::ctxt,\n-                     lp: @LoanPath) -> MovePathIndex {\n+                     lp: Rc<LoanPath>) -> MovePathIndex {\n         /*!\n          * Returns the existing move path index for `lp`, if any,\n          * and otherwise adds a new index for `lp` and any of its\n@@ -245,7 +245,7 @@ impl MoveData {\n                 let index = MovePathIndex(self.paths.borrow().len());\n \n                 self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp,\n+                    loan_path: lp.clone(),\n                     parent: InvalidMovePathIndex,\n                     first_move: InvalidMoveIndex,\n                     first_child: InvalidMovePathIndex,\n@@ -255,16 +255,16 @@ impl MoveData {\n                 index\n             }\n \n-            LpExtend(base, _, _) => {\n-                let parent_index = self.move_path(tcx, base);\n+            LpExtend(ref base, _, _) => {\n+                let parent_index = self.move_path(tcx, base.clone());\n \n                 let index = MovePathIndex(self.paths.borrow().len());\n \n                 let next_sibling = self.path_first_child(parent_index);\n                 self.set_path_first_child(parent_index, index);\n \n                 self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp,\n+                    loan_path: lp.clone(),\n                     parent: parent_index,\n                     first_move: InvalidMoveIndex,\n                     first_child: InvalidMovePathIndex,\n@@ -284,39 +284,36 @@ impl MoveData {\n         return index;\n     }\n \n-    fn existing_move_path(&self,\n-                          lp: @LoanPath)\n+    fn existing_move_path(&self, lp: &Rc<LoanPath>)\n                           -> Option<MovePathIndex> {\n-        self.path_map.borrow().find_copy(&lp)\n+        self.path_map.borrow().find_copy(lp)\n     }\n \n-    fn existing_base_paths(&self,\n-                           lp: @LoanPath)\n+    fn existing_base_paths(&self, lp: &Rc<LoanPath>)\n                            -> Vec<MovePathIndex> {\n         let mut result = vec!();\n         self.add_existing_base_paths(lp, &mut result);\n         result\n     }\n \n-    fn add_existing_base_paths(&self,\n-                               lp: @LoanPath,\n+    fn add_existing_base_paths(&self, lp: &Rc<LoanPath>,\n                                result: &mut Vec<MovePathIndex>) {\n         /*!\n          * Adds any existing move path indices for `lp` and any base\n          * paths of `lp` to `result`, but does not add new move paths\n          */\n \n-        match self.path_map.borrow().find_copy(&lp) {\n+        match self.path_map.borrow().find_copy(lp) {\n             Some(index) => {\n                 self.each_base_path(index, |p| {\n                     result.push(p);\n                     true\n                 });\n             }\n             None => {\n-                match *lp {\n+                match **lp {\n                     LpVar(..) => { }\n-                    LpExtend(b, _, _) => {\n+                    LpExtend(ref b, _, _) => {\n                         self.add_existing_base_paths(b, result);\n                     }\n                 }\n@@ -327,7 +324,7 @@ impl MoveData {\n \n     pub fn add_move(&self,\n                     tcx: &ty::ctxt,\n-                    lp: @LoanPath,\n+                    lp: Rc<LoanPath>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n         /*!\n@@ -356,7 +353,7 @@ impl MoveData {\n \n     pub fn add_assignment(&self,\n                           tcx: &ty::ctxt,\n-                          lp: @LoanPath,\n+                          lp: Rc<LoanPath>,\n                           assign_id: ast::NodeId,\n                           span: Span,\n                           assignee_id: ast::NodeId,\n@@ -369,7 +366,7 @@ impl MoveData {\n         debug!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n                lp.repr(tcx), assign_id, assignee_id);\n \n-        let path_index = self.move_path(tcx, lp);\n+        let path_index = self.move_path(tcx, lp.clone());\n \n         if !is_also_move {\n             self.assignee_ids.borrow_mut().insert(assignee_id);\n@@ -511,19 +508,16 @@ impl MoveData {\n impl<'a> FlowedMoveData<'a> {\n     pub fn new(move_data: MoveData,\n                tcx: &'a ty::ctxt,\n-               method_map: typeck::MethodMap,\n                id_range: ast_util::IdRange,\n                body: &ast::Block)\n                -> FlowedMoveData<'a> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n-                                 method_map,\n                                  MoveDataFlowOperator,\n                                  id_range,\n                                  move_data.moves.borrow().len());\n         let mut dfcx_assign =\n             DataFlowContext::new(tcx,\n-                                 method_map,\n                                  AssignDataFlowOperator,\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n@@ -539,7 +533,7 @@ impl<'a> FlowedMoveData<'a> {\n \n     pub fn each_path_moved_by(&self,\n                               id: ast::NodeId,\n-                              f: |&Move, @LoanPath| -> bool)\n+                              f: |&Move, &LoanPath| -> bool)\n                               -> bool {\n         /*!\n          * Iterates through each path moved by `id`\n@@ -549,14 +543,14 @@ impl<'a> FlowedMoveData<'a> {\n             let move = self.move_data.moves.borrow();\n             let move = move.get(index);\n             let moved_path = move.path;\n-            f(move, self.move_data.path_loan_path(moved_path))\n+            f(move, &*self.move_data.path_loan_path(moved_path))\n         })\n     }\n \n     pub fn each_move_of(&self,\n                         id: ast::NodeId,\n-                        loan_path: @LoanPath,\n-                        f: |&Move, @LoanPath| -> bool)\n+                        loan_path: &Rc<LoanPath>,\n+                        f: |&Move, &LoanPath| -> bool)\n                         -> bool {\n         /*!\n          * Iterates through each move of `loan_path` (or some base path\n@@ -591,7 +585,7 @@ impl<'a> FlowedMoveData<'a> {\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n-                if !f(move, self.move_data.path_loan_path(moved_path)) {\n+                if !f(move, &*self.move_data.path_loan_path(moved_path)) {\n                     ret = false;\n                 }\n             } else {\n@@ -600,7 +594,7 @@ impl<'a> FlowedMoveData<'a> {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`\n                             // was moved\n-                            f(move, self.move_data.path_loan_path(moved_path))\n+                            f(move, &*self.move_data.path_loan_path(moved_path))\n                         } else {\n                             true\n                         }\n@@ -621,7 +615,7 @@ impl<'a> FlowedMoveData<'a> {\n \n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n-                              loan_path: @LoanPath,\n+                              loan_path: &Rc<LoanPath>,\n                               f: |&Assignment| -> bool)\n                               -> bool {\n         /*!"}, {"sha": "eb52aa18de85fa204e8dbc4af7c29605dc4f48f8", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -21,8 +21,6 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n pub struct CheckCrateVisitor<'a> {\n-    def_map: resolve::DefMap,\n-    method_map: typeck::MethodMap,\n     tcx: &'a ty::ctxt,\n }\n \n@@ -38,24 +36,16 @@ impl<'a> Visitor<bool> for CheckCrateVisitor<'a> {\n     }\n }\n \n-pub fn check_crate(krate: &Crate,\n-                   def_map: resolve::DefMap,\n-                   method_map: typeck::MethodMap,\n-                   tcx: &ty::ctxt) {\n-    let mut v = CheckCrateVisitor {\n-        def_map: def_map,\n-        method_map: method_map,\n-        tcx: tcx,\n-    };\n-    visit::walk_crate(&mut v, krate, false);\n+pub fn check_crate(krate: &Crate, tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx }, krate, false);\n     tcx.sess.abort_if_errors();\n }\n \n fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n             v.visit_expr(ex, true);\n-            check_item_recursion(&v.tcx.sess, &v.tcx.map, v.def_map, it);\n+            check_item_recursion(&v.tcx.sess, &v.tcx.map, &v.tcx.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n@@ -103,7 +93,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n-            if v.method_map.borrow().contains_key(&method_call) {\n+            if v.tcx.method_map.borrow().contains_key(&method_call) {\n                 v.tcx.sess.span_err(e.span, \"user-defined operators are not \\\n                                              allowed in constant expressions\");\n             }\n@@ -127,7 +117,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                                     \"paths in constants may only refer to \\\n                                      items without type parameters\");\n             }\n-            match v.def_map.borrow().find(&e.id) {\n+            match v.tcx.def_map.borrow().find(&e.id) {\n               Some(&DefStatic(..)) |\n               Some(&DefFn(_, _)) |\n               Some(&DefVariant(_, _, _)) |\n@@ -145,7 +135,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n             }\n           }\n           ExprCall(callee, _) => {\n-            match v.def_map.borrow().find(&callee.id) {\n+            match v.tcx.def_map.borrow().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n                 _ => {\n@@ -188,14 +178,14 @@ struct CheckItemRecursionVisitor<'a> {\n     root_it: &'a Item,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map,\n-    def_map: resolve::DefMap,\n+    def_map: &'a resolve::DefMap,\n     idstack: Vec<NodeId> }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion<'a>(sess: &'a Session,\n                                 ast_map: &'a ast_map::Map,\n-                                def_map: resolve::DefMap,\n+                                def_map: &'a resolve::DefMap,\n                                 it: &'a Item) {\n \n     let mut visitor = CheckItemRecursionVisitor {"}, {"sha": "2ef009e36e4eadcf62293b9448c0c0f5f72b8a92", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -15,7 +15,6 @@ use middle::const_eval::{eval_const_expr, const_val, const_bool, const_float};\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n-use middle::typeck::MethodMap;\n use util::nodemap::NodeSet;\n use util::ppaux::ty_to_str;\n \n@@ -30,7 +29,6 @@ use syntax::visit::{Visitor, FnKind};\n \n struct MatchCheckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n-    method_map: MethodMap,\n     moves_map: &'a NodeSet\n }\n \n@@ -47,12 +45,10 @@ impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   method_map: MethodMap,\n                    moves_map: &NodeSet,\n                    krate: &Crate) {\n     let mut cx = MatchCheckCtxt {\n         tcx: tcx,\n-        method_map: method_map,\n         moves_map: moves_map\n     };\n \n@@ -938,7 +934,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                        has_guard: bool,\n                                        pats: &[@Pat]) {\n     let tcx = cx.tcx;\n-    let def_map = tcx.def_map;\n+    let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n     for pat in pats.iter() {"}, {"sha": "cd3ab100e55c23f71fbe172296d6fb335b14d703", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -15,7 +15,7 @@ use middle::astencode;\n \n use middle::ty;\n use middle::typeck::astconv;\n-use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, NodeMap};\n \n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n@@ -127,9 +127,7 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             None => {}\n         }\n         let maps = astencode::Maps {\n-            root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(FnvHashMap::new()),\n-            vtable_map: @RefCell::new(FnvHashMap::new()),\n+            root_map: HashMap::new(),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n@@ -168,9 +166,7 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n             None => {}\n         }\n         let maps = astencode::Maps {\n-            root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(FnvHashMap::new()),\n-            vtable_map: @RefCell::new(FnvHashMap::new()),\n+            root_map: HashMap::new(),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,"}, {"sha": "742daa82ecd43ef54b1023fefa2c9c00696af949", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -32,7 +32,6 @@ use util::nodemap::NodeMap;\n #[deriving(Clone)]\n pub struct DataFlowContext<'a, O> {\n     tcx: &'a ty::ctxt,\n-    method_map: typeck::MethodMap,\n \n     /// the data flow operator\n     oper: O,\n@@ -123,7 +122,6 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n \n impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     pub fn new(tcx: &'a ty::ctxt,\n-               method_map: typeck::MethodMap,\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, O> {\n@@ -138,7 +136,6 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n \n         DataFlowContext {\n             tcx: tcx,\n-            method_map: method_map,\n             words_per_id: words_per_id,\n             nodeid_to_bitset: NodeMap::new(),\n             bits_per_id: bits_per_id,\n@@ -784,7 +781,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n         let method_call = typeck::MethodCall::expr(expr.id);\n-        self.dfcx.method_map.borrow().contains_key(&method_call)\n+        self.dfcx.tcx.method_map.borrow().contains_key(&method_call)\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {"}, {"sha": "74355357fe72c5c971bd3f94f8cc7733a6e86205", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -50,18 +50,15 @@ fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n \n struct MarkSymbolVisitor<'a> {\n     worklist: Vec<ast::NodeId>,\n-    method_map: typeck::MethodMap,\n     tcx: &'a ty::ctxt,\n     live_symbols: ~HashSet<ast::NodeId>,\n }\n \n impl<'a> MarkSymbolVisitor<'a> {\n     fn new(tcx: &'a ty::ctxt,\n-           method_map: typeck::MethodMap,\n            worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n-            method_map: method_map,\n             tcx: tcx,\n             live_symbols: ~HashSet::new(),\n         }\n@@ -93,7 +90,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n         let method_call = typeck::MethodCall::expr(id);\n-        match self.method_map.borrow().find(&method_call) {\n+        match self.tcx.method_map.borrow().find(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     typeck::MethodStatic(def_id) => {\n@@ -285,14 +282,13 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n }\n \n fn find_live(tcx: &ty::ctxt,\n-             method_map: typeck::MethodMap,\n              exported_items: &privacy::ExportedItems,\n              reachable_symbols: &NodeSet,\n              krate: &ast::Crate)\n              -> ~HashSet<ast::NodeId> {\n     let worklist = create_and_seed_worklist(tcx, exported_items,\n                                             reachable_symbols, krate);\n-    let mut symbol_visitor = MarkSymbolVisitor::new(tcx, method_map, worklist);\n+    let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n }\n@@ -340,13 +336,13 @@ impl<'a> DeadVisitor<'a> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = local_def(id);\n-        match self.tcx.inherent_impls.borrow().find(&def_id) {\n+        let impl_methods = self.tcx.impl_methods.borrow();\n+        match self.tcx.inherent_impls.borrow().find(&local_def(id)) {\n             None => (),\n-            Some(ref impl_list) => {\n-                for impl_ in impl_list.borrow().iter() {\n-                    for method in impl_.methods.iter() {\n-                        if self.live_symbols.contains(&method.def_id.node) {\n+            Some(impl_list) => {\n+                for impl_did in impl_list.borrow().iter() {\n+                    for method_did in impl_methods.get(impl_did).iter() {\n+                        if self.live_symbols.contains(&method_did.node) {\n                             return true;\n                         }\n                     }\n@@ -406,11 +402,10 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   method_map: typeck::MethodMap,\n                    exported_items: &privacy::ExportedItems,\n                    reachable_symbols: &NodeSet,\n                    krate: &ast::Crate) {\n-    let live_symbols = find_live(tcx, method_map, exported_items,\n+    let live_symbols = find_live(tcx, exported_items,\n                                  reachable_symbols, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n     visit::walk_crate(&mut visitor, krate, ());"}, {"sha": "ef7c59248449d1e9099c9e7d42402c7855725400", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -12,7 +12,7 @@\n /// `unsafe`.\n \n use middle::ty;\n-use middle::typeck::{MethodCall, MethodMap};\n+use middle::typeck::MethodCall;\n use util::ppaux;\n \n use syntax::ast;\n@@ -38,8 +38,6 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n struct EffectCheckVisitor<'a> {\n     tcx: &'a ty::ctxt,\n \n-    /// The method map.\n-    method_map: MethodMap,\n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n }\n@@ -138,7 +136,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.method_map.borrow().get(&method_call).ty;\n+                let base_type = self.tcx.method_map.borrow().get(&method_call).ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n@@ -190,10 +188,9 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, method_map: MethodMap, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n-        method_map: method_map,\n         unsafe_context: SafeContext,\n     };\n "}, {"sha": "83f6d5abfa4cfef0e072c31f43a9b206a1b4d730", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -29,16 +29,15 @@ pub struct freevar_entry {\n     pub def: ast::Def, //< The variable being accessed free.\n     pub span: Span     //< First span where it is accessed (there can be multiple)\n }\n-pub type freevar_info = @Vec<@freevar_entry> ;\n-pub type freevar_map = NodeMap<freevar_info>;\n+pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n \n-struct CollectFreevarsVisitor {\n+struct CollectFreevarsVisitor<'a> {\n     seen: NodeSet,\n-    refs: Vec<@freevar_entry> ,\n-    def_map: resolve::DefMap,\n+    refs: Vec<freevar_entry>,\n+    def_map: &'a resolve::DefMap,\n }\n \n-impl Visitor<int> for CollectFreevarsVisitor {\n+impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n \n     fn visit_item(&mut self, _: &ast::Item, _: int) {\n         // ignore_item\n@@ -65,7 +64,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n                         if i == depth { // Made it to end of loop\n                             let dnum = ast_util::def_id_of_def(def).node;\n                             if !self.seen.contains(&dnum) {\n-                                self.refs.push(@freevar_entry {\n+                                self.refs.push(freevar_entry {\n                                     def: def,\n                                     span: expr.span,\n                                 });\n@@ -87,30 +86,23 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block) -> freevar_info {\n-    let seen = NodeSet::new();\n-    let refs = Vec::new();\n-\n+fn collect_freevars(def_map: &resolve::DefMap, blk: &ast::Block) -> Vec<freevar_entry> {\n     let mut v = CollectFreevarsVisitor {\n-        seen: seen,\n-        refs: refs,\n+        seen: NodeSet::new(),\n+        refs: Vec::new(),\n         def_map: def_map,\n     };\n \n     v.visit_block(blk, 1);\n-    let CollectFreevarsVisitor {\n-        refs,\n-        ..\n-    } = v;\n-    return @refs;\n+    v.refs\n }\n \n-struct AnnotateFreevarsVisitor {\n-    def_map: resolve::DefMap,\n+struct AnnotateFreevarsVisitor<'a> {\n+    def_map: &'a resolve::DefMap,\n     freevars: freevar_map,\n }\n \n-impl Visitor<()> for AnnotateFreevarsVisitor {\n+impl<'a> Visitor<()> for AnnotateFreevarsVisitor<'a> {\n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n                 blk: &ast::Block, s: Span, nid: ast::NodeId, _: ()) {\n         let vars = collect_freevars(self.def_map, blk);\n@@ -124,24 +116,20 @@ impl Visitor<()> for AnnotateFreevarsVisitor {\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: resolve::DefMap, krate: &ast::Crate) ->\n+pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate) ->\n    freevar_map {\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n         freevars: NodeMap::new(),\n     };\n     visit::walk_crate(&mut visitor, krate, ());\n \n-    let AnnotateFreevarsVisitor {\n-        freevars,\n-        ..\n-    } = visitor;\n-    freevars\n+    visitor.freevars\n }\n \n-pub fn get_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> freevar_info {\n+pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]| -> T) -> T {\n     match tcx.freevars.borrow().find(&fid) {\n-        None => fail!(\"get_freevars: {} has no freevars\", fid),\n-        Some(&d) => return d\n+        None => fail!(\"with_freevars: {} has no freevars\", fid),\n+        Some(d) => f(d.as_slice())\n     }\n }"}, {"sha": "e6c885e56f176e47fc084fffb223df16309912af", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -47,7 +47,6 @@ use syntax::visit::Visitor;\n #[deriving(Clone)]\n pub struct Context<'a> {\n     tcx: &'a ty::ctxt,\n-    method_map: typeck::MethodMap,\n }\n \n impl<'a> Visitor<()> for Context<'a> {\n@@ -70,11 +69,9 @@ impl<'a> Visitor<()> for Context<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   method_map: typeck::MethodMap,\n                    krate: &Crate) {\n     let mut ctx = Context {\n         tcx: tcx,\n-        method_map: method_map,\n     };\n     visit::walk_crate(&mut ctx, krate, ());\n     tcx.sess.abort_if_errors();\n@@ -115,9 +112,9 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n                               .find(&trait_ref.ref_id)\n                               .expect(\"trait ref not in def map!\");\n     let trait_def_id = ast_util::def_id_of_def(ast_trait_def);\n-    let trait_def = *cx.tcx.trait_defs.borrow()\n-                           .find(&trait_def_id)\n-                           .expect(\"trait def not in trait-defs map!\");\n+    let trait_def = cx.tcx.trait_defs.borrow()\n+                          .find_copy(&trait_def_id)\n+                          .expect(\"trait def not in trait-defs map!\");\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n@@ -166,7 +163,7 @@ fn check_item(cx: &mut Context, item: &Item) {\n // closure.\n fn with_appropriate_checker(cx: &Context,\n                             id: NodeId,\n-                            b: |checker: |&Context, @freevar_entry||) {\n+                            b: |checker: |&Context, &freevar_entry||) {\n     fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n@@ -187,7 +184,7 @@ fn with_appropriate_checker(cx: &Context,\n                              bounds, Some(var_t));\n     }\n \n-    fn check_for_bare(cx: &Context, fv: @freevar_entry) {\n+    fn check_for_bare(cx: &Context, fv: &freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n             \"can't capture dynamic environment in a fn item; \\\n@@ -226,10 +223,11 @@ fn check_fn(\n \n     // Check kinds on free variables:\n     with_appropriate_checker(cx, fn_id, |chk| {\n-        let r = freevars::get_freevars(cx.tcx, fn_id);\n-        for fv in r.iter() {\n-            chk(cx, *fv);\n-        }\n+        freevars::with_freevars(cx.tcx, fn_id, |r| {\n+            for fv in r.iter() {\n+                chk(cx, fv);\n+            }\n+        })\n     });\n \n     visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());\n@@ -240,7 +238,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n \n     // Handle any kind bounds on type parameters\n     {\n-        let method_map = cx.method_map.borrow();\n+        let method_map = cx.tcx.method_map.borrow();\n         let method = method_map.find(&typeck::MethodCall::expr(e.id));\n         let node_type_substs = cx.tcx.node_type_substs.borrow();\n         let r = match method {\n@@ -309,11 +307,10 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     // Search for auto-adjustments to find trait coercions.\n     match cx.tcx.adjustments.borrow().find(&e.id) {\n         Some(adjustment) => {\n-            match **adjustment {\n+            match *adjustment {\n                 ty::AutoObject(..) => {\n                     let source_ty = ty::expr_ty(cx.tcx, e);\n-                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e,\n-                                                         &*cx.method_map.borrow());\n+                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n                     check_trait_cast(cx, source_ty, target_ty, e.span);\n                 }\n                 ty::AutoAddEnv(..) |"}, {"sha": "42ef8b9d51b08ce85775024355c245504506130f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -195,12 +195,12 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n }\n \n pub fn collect_language_items(krate: &ast::Crate,\n-                              session: &Session) -> @LanguageItems {\n+                              session: &Session) -> LanguageItems {\n     let mut collector = LanguageItemCollector::new(session);\n     collector.collect(krate);\n     let LanguageItemCollector { items, .. } = collector;\n     session.abort_if_errors();\n-    @items\n+    items\n }\n \n // End of the macro"}, {"sha": "d1cc7d7bc401b60d1519f879f73f9d4ef7aa1812", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -53,6 +53,7 @@ use std::i16;\n use std::i32;\n use std::i64;\n use std::i8;\n+use std::rc::Rc;\n use std::to_str::ToStr;\n use std::u16;\n use std::u32;\n@@ -423,23 +424,16 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n   '-' to '_' in command-line flags\n  */\n pub fn get_lint_dict() -> LintDict {\n-    let mut map = HashMap::new();\n-    for &(k, v) in lint_table.iter() {\n-        map.insert(k, v);\n-    }\n-    return map;\n+    lint_table.iter().map(|&(k, v)| (k, v)).collect()\n }\n \n struct Context<'a> {\n     // All known lint modes (string versions)\n-    dict: @LintDict,\n+    dict: LintDict,\n     // Current levels of each lint warning\n     cur: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: &'a ty::ctxt,\n-    // maps from an expression id that corresponds to a method call to the\n-    // details of the method to be invoked\n-    method_map: typeck::MethodMap,\n     // Items exported by the crate; used by the missing_doc lint.\n     exported_items: &'a privacy::ExportedItems,\n     // The id of the current `ast::StructDef` being walked.\n@@ -685,7 +679,7 @@ impl<'a> AstConv for Context<'a>{\n         ty::lookup_item_type(self.tcx, id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n         ty::lookup_trait_def(self.tcx, id)\n     }\n \n@@ -1340,7 +1334,7 @@ fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n     match p.node {\n         ast::PatIdent(ast::BindByValue(ast::MutMutable),\n-                      ref path, _) if pat_util::pat_is_binding(cx.tcx.def_map, p)=> {\n+                      ref path, _) if pat_util::pat_is_binding(&cx.tcx.def_map, p) => {\n             // `let mut _a = 1;` doesn't need a warning.\n             let initial_underscore = if path.segments.len() == 1 {\n                 token::get_ident(path.segments\n@@ -1390,7 +1384,7 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n         cx.span_lint(UnnecessaryAllocation, e.span, msg);\n     };\n \n-    match cx.tcx.adjustments.borrow().find_copy(&e.id) {\n+    match cx.tcx.adjustments.borrow().find(&e.id) {\n         Some(adjustment) => {\n             match *adjustment {\n                 ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n@@ -1472,7 +1466,7 @@ fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n         node: m.id\n     };\n \n-    match cx.tcx.methods.borrow().find(&did).map(|method| *method) {\n+    match cx.tcx.methods.borrow().find_copy(&did) {\n         None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md.container {\n@@ -1537,7 +1531,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         }\n         ast::ExprMethodCall(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n-            match cx.method_map.borrow().find(&method_call) {\n+            match cx.tcx.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n                     match method.origin {\n                         typeck::MethodStatic(def_id) => {\n@@ -1775,14 +1769,12 @@ impl<'a> IdVisitingOperation for Context<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   method_map: typeck::MethodMap,\n                    exported_items: &privacy::ExportedItems,\n                    krate: &ast::Crate) {\n     let mut cx = Context {\n-        dict: @get_lint_dict(),\n+        dict: get_lint_dict(),\n         cur: SmallIntMap::new(),\n         tcx: tcx,\n-        method_map: method_map,\n         exported_items: exported_items,\n         cur_struct_def_id: -1,\n         is_doc_hidden: false,\n@@ -1793,7 +1785,9 @@ pub fn check_crate(tcx: &ty::ctxt,\n     // Install default lint levels, followed by the command line levels, and\n     // then actually visit the whole crate.\n     for (_, spec) in cx.dict.iter() {\n-        cx.set_level(spec.lint, spec.default, Default);\n+        if spec.default != allow {\n+            cx.cur.insert(spec.lint as uint, (spec.default, Default));\n+        }\n     }\n     for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);"}, {"sha": "4be9992367d5f34faffb3a1f87f86960e037431c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -106,7 +106,6 @@\n use middle::lint::{UnusedVariable, DeadAssignment};\n use middle::pat_util;\n use middle::ty;\n-use middle::typeck;\n use middle::moves;\n use util::nodemap::NodeMap;\n \n@@ -171,10 +170,9 @@ impl<'a> Visitor<()> for IrMaps<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   method_map: typeck::MethodMap,\n                    capture_map: &moves::CaptureMap,\n                    krate: &Crate) {\n-    visit::walk_crate(&mut IrMaps(tcx, method_map, capture_map), krate, ());\n+    visit::walk_crate(&mut IrMaps(tcx, capture_map), krate, ());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -247,7 +245,6 @@ enum VarKind {\n \n struct IrMaps<'a> {\n     tcx: &'a ty::ctxt,\n-    method_map: typeck::MethodMap,\n     capture_map: &'a moves::CaptureMap,\n \n     num_live_nodes: uint,\n@@ -260,12 +257,10 @@ struct IrMaps<'a> {\n }\n \n fn IrMaps<'a>(tcx: &'a ty::ctxt,\n-              method_map: typeck::MethodMap,\n               capture_map: &'a moves::CaptureMap)\n               -> IrMaps<'a> {\n     IrMaps {\n         tcx: tcx,\n-        method_map: method_map,\n         capture_map: capture_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n@@ -366,14 +361,14 @@ fn visit_fn(ir: &mut IrMaps,\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let mut fn_maps = IrMaps(ir.tcx, ir.method_map, ir.capture_map);\n+    let mut fn_maps = IrMaps(ir.tcx, ir.capture_map);\n \n     unsafe {\n         debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(&fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {\n-        pat_util::pat_bindings(ir.tcx.def_map,\n+        pat_util::pat_bindings(&ir.tcx.def_map,\n                                arg.pat,\n                                |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n@@ -407,7 +402,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &Local) {\n-    pat_util::pat_bindings(ir.tcx.def_map, local.pat, |bm, p_id, sp, path| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -431,7 +426,7 @@ fn visit_local(ir: &mut IrMaps, local: &Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n@@ -601,7 +596,7 @@ impl<'a> Liveness<'a> {\n     fn pat_bindings(&mut self,\n                     pat: &Pat,\n                     f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n-        pat_util::pat_bindings(self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n+        pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n@@ -1529,7 +1524,7 @@ impl<'a> Liveness<'a> {\n \n     fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n-            pat_util::pat_bindings(self.ir.tcx.def_map,\n+            pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    arg.pat,\n                                    |_bm, p_id, sp, path| {\n                 let var = self.variable(p_id, sp);"}, {"sha": "35124aa9916990ddd32a5a56036809c2613d3060", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 113, "deletions": 112, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -64,6 +64,7 @@\n \n use middle::ty;\n use middle::typeck;\n+use util::nodemap::NodeMap;\n use util::ppaux::{ty_to_str, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n@@ -72,7 +73,10 @@ use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::parse::token;\n \n-#[deriving(Eq)]\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+#[deriving(Clone, Eq)]\n pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n@@ -88,14 +92,14 @@ pub enum categorization {\n     // (*1) downcast is only required if the enum has more than one variant\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n     pub onceness: ast::Onceness,\n }\n \n // different kinds of pointers:\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum PointerKind {\n     OwnedPtr,\n     GcPtr,\n@@ -105,26 +109,26 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum ElementKind {\n     VecElement,\n     StrElement,\n     OtherElement,\n }\n \n-#[deriving(Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable.\n@@ -145,7 +149,7 @@ pub enum MutabilityCategory {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.type` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct cmt_ {\n     pub id: ast::NodeId,          // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -154,7 +158,7 @@ pub struct cmt_ {\n     pub ty: ty::t                  // type of the expr (*see WARNING above*)\n }\n \n-pub type cmt = @cmt_;\n+pub type cmt = Rc<cmt_>;\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n@@ -263,12 +267,12 @@ pub type McResult<T> = Result<T, ()>;\n  */\n pub trait Typer {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n-    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t>;\n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n-    fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n-    fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n-    fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n-    fn upvar_borrow(&mut self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>>;\n+    fn is_method_call(&self, id: ast::NodeId) -> bool;\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n }\n \n impl MutabilityCategory {\n@@ -350,31 +354,27 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n-        self.typer.adjustment(id)\n-    }\n-\n-    fn expr_ty(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> McResult<ty::t> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<ty::t> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n-        let adjustment = self.adjustment(expr.id);\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty, adjustment,\n+        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n+                         self.typer.adjustments().borrow().find(&expr.id),\n                          |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n-    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&mut self, pat: @ast::Pat) -> McResult<ty::t> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> McResult<ty::t> {\n         self.typer.node_ty(pat.id)\n     }\n \n-    pub fn cat_expr(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n-        match self.adjustment(expr.id) {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt> {\n+        match self.typer.adjustments().borrow().find(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -386,8 +386,9 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                         // Implicity casts a concrete object to trait object\n                         // so just patch up the type\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        let expr_cmt = if_ok!(self.cat_expr_unadjusted(expr));\n-                        Ok(@cmt_ {ty: expr_ty, ..*expr_cmt})\n+                        let mut expr_cmt = (*if_ok!(self.cat_expr_unadjusted(expr))).clone();\n+                        expr_cmt.ty = expr_ty;\n+                        Ok(Rc::new(expr_cmt))\n                     }\n \n                     ty::AutoAddEnv(..) => {\n@@ -417,7 +418,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&mut self, expr: &ast::Expr, autoderefs: uint)\n+    pub fn cat_expr_autoderefd(&self, expr: &ast::Expr, autoderefs: uint)\n                                -> McResult<cmt> {\n         let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n         for deref in range(1u, autoderefs + 1) {\n@@ -426,7 +427,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n@@ -475,7 +476,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_def(&mut self,\n+    pub fn cat_def(&self,\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: ty::t,\n@@ -493,23 +494,23 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           ast::DefUse(_) | ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n           ast::DefTyParam(..) | ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n           ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n-              Ok(@cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty\n-              })\n+              }))\n           }\n \n           ast::DefStatic(_, true) => {\n-              Ok(@cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McDeclared,\n                   ty:expr_ty\n-              })\n+              }))\n           }\n \n           ast::DefArg(vid, binding_mode) => {\n@@ -521,13 +522,13 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 ast::BindByValue(ast::MutMutable) => McDeclared,\n                 _ => McImmutable\n             };\n-            Ok(@cmt_ {\n+            Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_arg(vid),\n                 mutbl: m,\n                 ty:expr_ty\n-            })\n+            }))\n           }\n \n           ast::DefUpvar(var_id, _, fn_node_id, _) => {\n@@ -551,15 +552,15 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                           self.cat_upvar(id, span, var_id, fn_node_id)\n                       } else {\n                           // FIXME #2152 allow mutation of moved upvars\n-                          Ok(@cmt_ {\n+                          Ok(Rc::new(cmt_ {\n                               id:id,\n                               span:span,\n                               cat:cat_copied_upvar(CopiedUpvar {\n                                   upvar_id: var_id,\n                                   onceness: closure_ty.onceness}),\n                               mutbl:McImmutable,\n                               ty:expr_ty\n-                          })\n+                          }))\n                       }\n                   }\n                   _ => {\n@@ -579,18 +580,18 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 _ => McImmutable\n             };\n \n-            Ok(@cmt_ {\n+            Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: m,\n                 ty: expr_ty\n-            })\n+            }))\n           }\n         }\n     }\n \n-    fn cat_upvar(&mut self,\n+    fn cat_upvar(&self,\n                  id: ast::NodeId,\n                  span: Span,\n                  var_id: ast::NodeId,\n@@ -619,28 +620,28 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // give err type. Nobody should be inspecting this type anyhow.\n         let upvar_ty = ty::mk_err();\n \n-        let base_cmt = @cmt_ {\n+        let base_cmt = Rc::new(cmt_ {\n             id:id,\n             span:span,\n             cat:cat_upvar(upvar_id, upvar_borrow),\n             mutbl:McImmutable,\n             ty:upvar_ty,\n-        };\n+        });\n \n         let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n \n-        let deref_cmt = @cmt_ {\n+        let deref_cmt = Rc::new(cmt_ {\n             id:id,\n             span:span,\n             cat:cat_deref(base_cmt, 0, ptr),\n             mutbl:MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n             ty:var_ty,\n-        };\n+        });\n \n         Ok(deref_cmt)\n     }\n \n-    pub fn cat_rvalue_node(&mut self,\n+    pub fn cat_rvalue_node(&self,\n                            id: ast::NodeId,\n                            span: Span,\n                            expr_ty: ty::t)\n@@ -655,40 +656,40 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_rvalue(&mut self,\n+    pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n                       expr_ty: ty::t) -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n             cat:cat_rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty\n-        }\n+        })\n     }\n \n-    pub fn cat_field<N:ast_node>(&mut self,\n+    pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt,\n                                  f_name: ast::Ident,\n                                  f_ty: ty::t)\n                                  -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name.name))),\n             mutbl: base_cmt.mutbl.inherit(),\n+            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name.name))),\n             ty: f_ty\n-        }\n+        })\n     }\n \n-    pub fn cat_deref_obj<N:ast_node>(&mut self, node: &N, base_cmt: cmt) -> cmt {\n+    pub fn cat_deref_obj<N:ast_node>(&self, node: &N, base_cmt: cmt) -> cmt {\n         self.cat_deref_common(node, base_cmt, 0, ty::mk_nil())\n     }\n \n-    fn cat_deref<N:ast_node>(&mut self,\n+    fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt,\n                              deref_cnt: uint)\n@@ -720,7 +721,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    fn cat_deref_common<N:ast_node>(&mut self,\n+    fn cat_deref_common<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     deref_cnt: uint,\n@@ -737,16 +738,16 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n         };\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n             ty: deref_ty\n-        }\n+        })\n     }\n \n-    pub fn cat_index<N:ast_node>(&mut self,\n+    pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n                                  base_cmt: cmt,\n                                  derefs: uint)\n@@ -799,21 +800,21 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n             let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n             // the deref is explicit in the resulting cmt\n-            let deref_cmt = @cmt_ {\n+            let deref_cmt = Rc::new(cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_deref(base_cmt, derefs, ptr),\n+                cat:cat_deref(base_cmt.clone(), derefs, ptr),\n                 mutbl:m,\n                 ty:element_ty\n-            };\n+            });\n \n             interior(elt, deref_cmt, base_cmt.ty, m.inherit(), element_ty)\n           }\n \n           deref_interior(_) => {\n             // fixed-length vectors have no deref\n             let m = base_cmt.mutbl.inherit();\n-            interior(elt, base_cmt, base_cmt.ty, m, element_ty)\n+            interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty)\n           }\n         };\n \n@@ -823,19 +824,19 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                                  mutbl: MutabilityCategory,\n                                  element_ty: ty::t) -> cmt\n         {\n-            @cmt_ {\n+            Rc::new(cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n                 cat:cat_interior(of_cmt, InteriorElement(element_kind(vec_ty))),\n                 mutbl:mutbl,\n                 ty:element_ty\n-            }\n+            })\n         }\n     }\n \n-    pub fn cat_slice_pattern(&mut self,\n+    pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt,\n-                             slice_pat: @ast::Pat)\n+                             slice_pat: &ast::Pat)\n                              -> McResult<(cmt, ast::Mutability, ty::Region)> {\n         /*!\n          * Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is\n@@ -855,7 +856,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         fn vec_slice_info(tcx: &ty::ctxt,\n-                          pat: @ast::Pat,\n+                          pat: &ast::Pat,\n                           slice_ty: ty::t)\n                           -> (ast::Mutability, ty::Region) {\n             /*!\n@@ -880,41 +881,41 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_imm_interior<N:ast_node>(&mut self,\n+    pub fn cat_imm_interior<N:ast_node>(&self,\n                                         node: &N,\n                                         base_cmt: cmt,\n                                         interior_ty: ty::t,\n                                         interior: InteriorKind)\n                                         -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_interior(base_cmt, interior),\n             mutbl: base_cmt.mutbl.inherit(),\n+            cat: cat_interior(base_cmt, interior),\n             ty: interior_ty\n-        }\n+        })\n     }\n \n-    pub fn cat_downcast<N:ast_node>(&mut self,\n+    pub fn cat_downcast<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     downcast_ty: ty::t)\n                                     -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_downcast(base_cmt),\n             mutbl: base_cmt.mutbl.inherit(),\n+            cat: cat_downcast(base_cmt),\n             ty: downcast_ty\n-        }\n+        })\n     }\n \n-    pub fn cat_pattern(&mut self,\n+    pub fn cat_pattern(&self,\n                        cmt: cmt,\n-                       pat: @ast::Pat,\n-                       op: |&mut MemCategorizationContext<TYPER>,\n+                       pat: &ast::Pat,\n+                       op: |&MemCategorizationContext<TYPER>,\n                             cmt,\n-                            @ast::Pat|)\n+                            &ast::Pat|)\n                        -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -965,7 +966,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                pat.id, pprust::pat_to_str(pat),\n                cmt.repr(self.tcx()));\n \n-        op(self, cmt, pat);\n+        op(self, cmt.clone(), pat);\n \n         match pat.node {\n           ast::PatWild | ast::PatWildMulti => {\n@@ -984,7 +985,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                         if ty::enum_is_univariant(self.tcx(), enum_did) {\n                             cmt // univariant, no downcast needed\n                         } else {\n-                            self.cat_downcast(pat, cmt, cmt.ty)\n+                            self.cat_downcast(pat, cmt.clone(), cmt.ty)\n                         }\n                     };\n \n@@ -993,7 +994,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n \n                         let subcmt =\n                             self.cat_imm_interior(\n-                                pat, downcast_cmt, subpat_ty,\n+                                pat, downcast_cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n                         if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n@@ -1005,14 +1006,14 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                         let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n-                                pat, cmt, subpat_ty,\n+                                pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n                         if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&ast::DefStatic(..)) => {\n                     for &subpat in subpats.iter() {\n-                        if_ok!(self.cat_pattern(cmt, subpat, |x,y,z| op(x,y,z)));\n+                        if_ok!(self.cat_pattern(cmt.clone(), subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 _ => {\n@@ -1035,7 +1036,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n                 let field_ty = if_ok!(self.pat_ty(fp.pat)); // see (*2)\n-                let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n+                let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident, field_ty);\n                 if_ok!(self.cat_pattern(cmt_field, fp.pat, |x,y,z| op(x,y,z)));\n             }\n           }\n@@ -1046,7 +1047,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n-                        pat, cmt, subpat_ty,\n+                        pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n                 if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n             }\n@@ -1061,15 +1062,15 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           ast::PatVec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n               for &before_pat in before.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt, before_pat, |x,y,z| op(x,y,z)));\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), before_pat, |x,y,z| op(x,y,z)));\n               }\n               for &slice_pat in slice.iter() {\n                   let slice_ty = if_ok!(self.pat_ty(slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n                   if_ok!(self.cat_pattern(slice_cmt, slice_pat, |x,y,z| op(x,y,z)));\n               }\n               for &after_pat in after.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt, after_pat, |x,y,z| op(x,y,z)));\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), after_pat, |x,y,z| op(x,y,z)));\n               }\n           }\n \n@@ -1081,7 +1082,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         Ok(())\n     }\n \n-    pub fn cmt_to_str(&self, cmt: cmt) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: &cmt_) -> ~str {\n         match cmt.cat {\n           cat_static_item => {\n               \"static item\".to_owned()\n@@ -1098,7 +1099,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           cat_arg(..) => {\n               \"argument\".to_owned()\n           }\n-          cat_deref(base, _, pk) => {\n+          cat_deref(ref base, _, pk) => {\n               match base.cat {\n                   cat_upvar(..) => {\n                       format!(\"captured outer variable\")\n@@ -1126,11 +1127,11 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           cat_upvar(..) => {\n               \"captured outer variable\".to_owned()\n           }\n-          cat_discr(cmt, _) => {\n-            self.cmt_to_str(cmt)\n+          cat_discr(ref cmt, _) => {\n+            self.cmt_to_str(&**cmt)\n           }\n-          cat_downcast(cmt) => {\n-            self.cmt_to_str(cmt)\n+          cat_downcast(ref cmt) => {\n+            self.cmt_to_str(&**cmt)\n           }\n         }\n     }\n@@ -1150,7 +1151,7 @@ pub enum AliasableReason {\n }\n \n impl cmt_ {\n-    pub fn guarantor(self) -> cmt {\n+    pub fn guarantor(&self) -> cmt {\n         //! Returns `self` after stripping away any owned pointer derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1165,12 +1166,12 @@ impl cmt_ {\n             cat_deref(_, _, GcPtr(..)) |\n             cat_deref(_, _, BorrowedPtr(..)) |\n             cat_upvar(..) => {\n-                @self\n+                Rc::new((*self).clone())\n             }\n-            cat_downcast(b) |\n-            cat_discr(b, _) |\n-            cat_interior(b, _) |\n-            cat_deref(b, _, OwnedPtr) => {\n+            cat_downcast(ref b) |\n+            cat_discr(ref b, _) |\n+            cat_interior(ref b, _) |\n+            cat_deref(ref b, _, OwnedPtr) => {\n                 b.guarantor()\n             }\n         }\n@@ -1187,12 +1188,12 @@ impl cmt_ {\n         // aliased and eventually recused.\n \n         match self.cat {\n-            cat_deref(b, _, BorrowedPtr(ty::MutBorrow, _)) |\n-            cat_deref(b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n-            cat_downcast(b) |\n-            cat_deref(b, _, OwnedPtr) |\n-            cat_interior(b, _) |\n-            cat_discr(b, _) => {\n+            cat_deref(ref b, _, BorrowedPtr(ty::MutBorrow, _)) |\n+            cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n+            cat_downcast(ref b) |\n+            cat_deref(ref b, _, OwnedPtr) |\n+            cat_interior(ref b, _) |\n+            cat_discr(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n             }\n@@ -1256,21 +1257,21 @@ impl Repr for categorization {\n             cat_arg(..) => {\n                 format!(\"{:?}\", *self)\n             }\n-            cat_deref(cmt, derefs, ptr) => {\n+            cat_deref(ref cmt, derefs, ptr) => {\n                 format!(\"{}-{}{}->\",\n                         cmt.cat.repr(tcx),\n                         ptr_sigil(ptr),\n                         derefs)\n             }\n-            cat_interior(cmt, interior) => {\n+            cat_interior(ref cmt, interior) => {\n                 format!(\"{}.{}\",\n                      cmt.cat.repr(tcx),\n                      interior.repr(tcx))\n             }\n-            cat_downcast(cmt) => {\n+            cat_downcast(ref cmt) => {\n                 format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n-            cat_discr(cmt, _) => {\n+            cat_discr(ref cmt, _) => {\n                 cmt.cat.repr(tcx)\n             }\n         }"}, {"sha": "53d3dec671301d1e9a6a218087a1f00fce757b2c", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -130,7 +130,7 @@ and so on.\n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n use middle::ty;\n-use middle::typeck::{MethodCall, MethodMap};\n+use middle::typeck::MethodCall;\n use util::ppaux;\n use util::ppaux::Repr;\n use util::common::indenter;\n@@ -177,7 +177,6 @@ pub struct MoveMaps {\n #[deriving(Clone)]\n struct VisitContext<'a> {\n     tcx: &'a ty::ctxt,\n-    method_map: MethodMap,\n     move_maps: MoveMaps\n }\n \n@@ -202,13 +201,9 @@ impl<'a> visit::Visitor<()> for VisitContext<'a> {\n     fn visit_ty(&mut self, _t: &Ty, _: ()) {}\n }\n \n-pub fn compute_moves(tcx: &ty::ctxt,\n-                     method_map: MethodMap,\n-                     krate: &Crate) -> MoveMaps\n-{\n+pub fn compute_moves(tcx: &ty::ctxt, krate: &Crate) -> MoveMaps {\n     let mut visit_cx = VisitContext {\n         tcx: tcx,\n-        method_map: method_map,\n         move_maps: MoveMaps {\n             moves_map: NodeSet::new(),\n             moved_variables_set: NodeSet::new(),\n@@ -274,8 +269,7 @@ impl<'a> VisitContext<'a> {\n         debug!(\"consume_expr(expr={})\",\n                expr.repr(self.tcx));\n \n-        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr,\n-                                           &*self.method_map.borrow());\n+        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n             self.move_maps.moves_map.insert(expr.id);\n             self.use_expr(expr, Move);\n@@ -318,7 +312,7 @@ impl<'a> VisitContext<'a> {\n         // reading the underlying expression, not moving it.\n         let comp_mode = match self.tcx.adjustments.borrow().find(&expr.id) {\n             Some(adjustment) => {\n-                match **adjustment {\n+                match *adjustment {\n                     ty::AutoDerefRef(ty::AutoDerefRef {\n                         autoref: Some(_),\n                         ..\n@@ -550,7 +544,7 @@ impl<'a> VisitContext<'a> {\n                     self.use_pat(a.pat);\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n-                self.move_maps.capture_map.insert(expr.id, cap_vars);\n+                self.move_maps.capture_map.insert(expr.id, Rc::new(cap_vars));\n                 self.consume_block(body);\n             }\n \n@@ -577,7 +571,7 @@ impl<'a> VisitContext<'a> {\n                                    arg_exprs: &[@Expr])\n                                    -> bool {\n         let method_call = MethodCall::expr(expr.id);\n-        if !self.method_map.borrow().contains_key(&method_call) {\n+        if !self.tcx.method_map.borrow().contains_key(&method_call) {\n             return false;\n         }\n \n@@ -611,7 +605,7 @@ impl<'a> VisitContext<'a> {\n          * into itself or not based on its type and annotation.\n          */\n \n-        pat_bindings(self.tcx.def_map, pat, |bm, id, _span, path| {\n+        pat_bindings(&self.tcx.def_map, pat, |bm, id, _span, path| {\n             let binding_moves = match bm {\n                 BindByRef(_) => false,\n                 BindByValue(_) => {\n@@ -645,34 +639,35 @@ impl<'a> VisitContext<'a> {\n         self.consume_expr(arg_expr)\n     }\n \n-    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> Rc<Vec<CaptureVar> > {\n+    fn compute_captures(&mut self, fn_expr_id: NodeId) -> Vec<CaptureVar> {\n         debug!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n-        let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n-        Rc::new(match ty::ty_closure_store(fn_ty) {\n-            ty::RegionTraitStore(..) => {\n-                // || captures everything by ref\n-                freevars.iter()\n-                        .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n-                        .collect()\n-            }\n-            ty::UniqTraitStore => {\n-                // proc captures by copy or by move depending on type\n-                freevars.iter()\n-                        .map(|fvar| {\n-                    let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n-                    let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                    debug!(\"fvar_def_id={:?} fvar_ty={}\",\n-                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n-                    let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n-                        CapMove\n-                    } else {\n-                        CapCopy\n-                    };\n-                    CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n-                }).collect()\n+        freevars::with_freevars(self.tcx, fn_expr_id, |freevars| {\n+            match ty::ty_closure_store(fn_ty) {\n+                ty::RegionTraitStore(..) => {\n+                    // || captures everything by ref\n+                    freevars.iter()\n+                            .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n+                            .collect()\n+                }\n+                ty::UniqTraitStore => {\n+                    // proc captures by copy or by move depending on type\n+                    freevars.iter()\n+                            .map(|fvar| {\n+                        let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n+                        let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n+                        debug!(\"fvar_def_id={:?} fvar_ty={}\",\n+                            fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n+                        let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n+                            CapMove\n+                        } else {\n+                            CapCopy\n+                        };\n+                        CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n+                    }).collect()\n+                }\n             }\n         })\n     }"}, {"sha": "842d3bae6a764cc231f63647a00fdec7fa948943", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -20,15 +20,15 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: resolve::DefMap, pat: &Pat) -> PatIdMap {\n+pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n     pat_bindings(dm, pat, |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     });\n     map\n }\n \n-pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n             match dm.borrow().find(&pat.id) {\n@@ -40,7 +40,7 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n             match dm.borrow().find(&pat.id) {\n@@ -52,7 +52,7 @@ pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n@@ -62,7 +62,7 @@ pub fn pat_is_binding(dm: resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(..) => pat_is_binding(dm, pat),\n         PatWild | PatWildMulti => true,\n@@ -72,7 +72,7 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: &Pat) -> bool {\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings(dm: resolve::DefMap,\n+pub fn pat_bindings(dm: &resolve::DefMap,\n                     pat: &Pat,\n                     it: |BindingMode, NodeId, Span, &Path|) {\n     walk_pat(pat, |p| {\n@@ -88,7 +88,7 @@ pub fn pat_bindings(dm: resolve::DefMap,\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {"}, {"sha": "427a7f406b01558862ad62e3f3312f144759349f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -254,7 +254,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                     _ => true,\n                 };\n                 let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n-                let public_trait = tr.map_or(false, |tr| {\n+                let public_trait = tr.clone().map_or(false, |tr| {\n                     !is_local(tr.def_id) ||\n                      self.exported_items.contains(&tr.def_id.node)\n                 });\n@@ -337,7 +337,6 @@ struct PrivacyVisitor<'a> {\n     curitem: ast::NodeId,\n     in_fn: bool,\n     in_foreign: bool,\n-    method_map: &'a MethodMap,\n     parents: NodeMap<ast::NodeId>,\n     external_exports: resolve::ExternalExports,\n     last_private_map: resolve::LastPrivateMap,\n@@ -775,8 +774,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprField(base, ident, _) => {\n-                match ty::get(ty::expr_ty_adjusted(self.tcx, base,\n-                                                   &*self.method_map.borrow())).sty {\n+                match ty::get(ty::expr_ty_adjusted(self.tcx, base)).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, NamedField(ident));\n                     }\n@@ -785,7 +783,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                match self.method_map.borrow().find(&method_call) {\n+                match self.tcx.method_map.borrow().find(&method_call) {\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                 \"method call not in \\\n@@ -1404,7 +1402,6 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   method_map: &MethodMap,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,\n                    last_private_map: resolve::LastPrivateMap,\n@@ -1423,7 +1420,6 @@ pub fn check_crate(tcx: &ty::ctxt,\n         in_foreign: false,\n         tcx: tcx,\n         parents: visitor.parents,\n-        method_map: method_map,\n         external_exports: external_exports,\n         last_private_map: last_private_map,\n     };"}, {"sha": "6e2edb4e8b2aefdbd1126dede1b9172dee707a90", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -84,9 +84,6 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n struct ReachableContext<'a> {\n     // The type context.\n     tcx: &'a ty::ctxt,\n-    // The method map, which links node IDs of method call expressions to the\n-    // methods they've been resolved to.\n-    method_map: typeck::MethodMap,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -133,7 +130,7 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = typeck::MethodCall::expr(expr.id);\n-                match self.method_map.borrow().get(&method_call).origin {\n+                match self.tcx.method_map.borrow().get(&method_call).origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n@@ -159,10 +156,9 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n \n impl<'a> ReachableContext<'a> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: &'a ty::ctxt, method_map: typeck::MethodMap) -> ReachableContext<'a> {\n+    fn new(tcx: &'a ty::ctxt) -> ReachableContext<'a> {\n         ReachableContext {\n             tcx: tcx,\n-            method_map: method_map,\n             reachable_symbols: NodeSet::new(),\n             worklist: Vec::new(),\n         }\n@@ -339,10 +335,9 @@ impl<'a> ReachableContext<'a> {\n }\n \n pub fn find_reachable(tcx: &ty::ctxt,\n-                      method_map: typeck::MethodMap,\n                       exported_items: &privacy::ExportedItems)\n                       -> NodeSet {\n-    let mut reachable_context = ReachableContext::new(tcx, method_map);\n+    let mut reachable_context = ReachableContext::new(tcx);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass along with all local lang items. If"}, {"sha": "d645b628affc5a6c68f30653a7daf9bbac35f91c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 507, "deletions": 585, "changes": 1092, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24"}, {"sha": "55f8b3d1fd22772a5e1800ca488f4a642147bcbc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 122, "deletions": 140, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -225,6 +225,7 @@ use util::ppaux::{Repr, vec_map_to_str};\n \n use collections::HashMap;\n use std::cell::Cell;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n@@ -250,7 +251,7 @@ pub enum VecLenOpt {\n // range)\n enum Opt {\n     lit(Lit),\n-    var(ty::Disr, @adt::Repr),\n+    var(ty::Disr, Rc<adt::Repr>),\n     range(@ast::Expr, @ast::Expr),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n@@ -351,8 +352,8 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n             let (llval, _) = consts::get_const_val(bcx.ccx(), lit_id);\n             return single_result(rslt(bcx, llval));\n         }\n-        var(disr_val, repr) => {\n-            return adt::trans_case(bcx, repr, disr_val);\n+        var(disr_val, ref repr) => {\n+            return adt::trans_case(bcx, &**repr, disr_val);\n         }\n         range(l1, l2) => {\n             let (l1, _) = consts::const_expr(ccx, l1, true);\n@@ -417,15 +418,10 @@ struct BindingInfo {\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n-struct ArmData<'a,'b> {\n+struct ArmData<'a, 'b> {\n     bodycx: &'b Block<'b>,\n     arm: &'a ast::Arm,\n-    bindings_map: @BindingsMap\n-}\n-\n-// FIXME #11820: method resolution is unreliable with &\n-impl<'a,'b> Clone for ArmData<'a, 'b> {\n-    fn clone(&self) -> ArmData<'a, 'b> { *self }\n+    bindings_map: BindingsMap\n }\n \n /**\n@@ -434,14 +430,13 @@ impl<'a,'b> Clone for ArmData<'a, 'b> {\n  * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n-#[deriving(Clone)]\n-struct Match<'a,'b> {\n-    pats: Vec<@ast::Pat> ,\n-    data: ArmData<'a,'b>,\n+struct Match<'a, 'b> {\n+    pats: Vec<@ast::Pat>,\n+    data: &'a ArmData<'a, 'b>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n \n-impl<'a,'b> Repr for Match<'a,'b> {\n+impl<'a, 'b> Repr for Match<'a, 'b> {\n     fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -462,12 +457,12 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'r,'b>(\n+fn expand_nested_bindings<'a, 'b>(\n                           bcx: &'b Block<'b>,\n-                          m: &[Match<'r,'b>],\n+                          m: &'a [Match<'a, 'b>],\n                           col: uint,\n                           val: ValueRef)\n-                          -> Vec<Match<'r,'b>> {\n+                          -> Vec<Match<'a, 'b>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -482,21 +477,25 @@ fn expand_nested_bindings<'r,'b>(\n                            .append((vec!(inner))\n                                    .append(br.pats.slice(col + 1u, br.pats.len())).as_slice());\n \n-                let mut res = Match {\n+                let mut bound_ptrs = br.bound_ptrs.clone();\n+                bound_ptrs.push((path_to_ident(path), val));\n+                Match {\n                     pats: pats,\n-                    data: br.data.clone(),\n-                    bound_ptrs: br.bound_ptrs.clone()\n-                };\n-                res.bound_ptrs.push((path_to_ident(path), val));\n-                res\n+                    data: &*br.data,\n+                    bound_ptrs: bound_ptrs\n+                }\n+            }\n+            _ => Match {\n+                pats: br.pats.clone(),\n+                data: &*br.data,\n+                bound_ptrs: br.bound_ptrs.clone()\n             }\n-            _ => (*br).clone(),\n         }\n     }).collect()\n }\n \n fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n-    if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n+    if !pat_is_binding_or_wild(&bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n             format!(\"expected an identifier pattern but found p: {}\",\n@@ -506,62 +505,54 @@ fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n \n type enter_pat<'a> = |@ast::Pat|: 'a -> Option<Vec<@ast::Pat>>;\n \n-fn enter_match<'r,'b>(\n+fn enter_match<'a, 'b>(\n                bcx: &'b Block<'b>,\n-               dm: DefMap,\n-               m: &[Match<'r,'b>],\n+               dm: &DefMap,\n+               m: &'a [Match<'a, 'b>],\n                col: uint,\n                val: ValueRef,\n                e: enter_pat)\n-               -> Vec<Match<'r,'b>> {\n+               -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let mut result = Vec::new();\n-    for br in m.iter() {\n-        match e(*br.pats.get(col)) {\n-            Some(sub) => {\n-                let pats = sub.append(br.pats.slice(0u, col))\n-                              .append(br.pats.slice(col + 1u, br.pats.len()));\n-\n-                let this = *br.pats.get(col);\n-                let mut bound_ptrs = br.bound_ptrs.clone();\n-                match this.node {\n-                    ast::PatIdent(_, ref path, None) => {\n-                        if pat_is_binding(dm, this) {\n-                            bound_ptrs.push((path_to_ident(path), val));\n-                        }\n+    m.iter().filter_map(|br| {\n+        e(*br.pats.get(col)).map(|sub| {\n+            let pats = sub.append(br.pats.slice(0u, col))\n+                            .append(br.pats.slice(col + 1u, br.pats.len()));\n+\n+            let this = *br.pats.get(col);\n+            let mut bound_ptrs = br.bound_ptrs.clone();\n+            match this.node {\n+                ast::PatIdent(_, ref path, None) => {\n+                    if pat_is_binding(dm, this) {\n+                        bound_ptrs.push((path_to_ident(path), val));\n                     }\n-                    _ => {}\n                 }\n-\n-                result.push(Match {\n-                    pats: pats,\n-                    data: br.data.clone(),\n-                    bound_ptrs: bound_ptrs\n-                });\n+                _ => {}\n             }\n-            None => ()\n-        }\n-    }\n-\n-    debug!(\"result={}\", result.repr(bcx.tcx()));\n \n-    return result;\n+            Match {\n+                pats: pats,\n+                data: br.data,\n+                bound_ptrs: bound_ptrs\n+            }\n+        })\n+    }).collect()\n }\n \n-fn enter_default<'r,'b>(\n+fn enter_default<'a, 'b>(\n                  bcx: &'b Block<'b>,\n-                 dm: DefMap,\n-                 m: &[Match<'r,'b>],\n+                 dm: &DefMap,\n+                 m: &'a [Match<'a, 'b>],\n                  col: uint,\n                  val: ValueRef,\n                  chk: &FailureHandler)\n-                 -> Vec<Match<'r,'b>> {\n+                 -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -625,14 +616,14 @@ fn enter_default<'r,'b>(\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-fn enter_opt<'r,'b>(\n+fn enter_opt<'a, 'b>(\n              bcx: &'b Block<'b>,\n-             m: &[Match<'r,'b>],\n+             m: &'a [Match<'a, 'b>],\n              opt: &Opt,\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> Vec<Match<'r,'b>> {\n+             -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -657,10 +648,10 @@ fn enter_opt<'r,'b>(\n     // \"column\" of arm patterns and the algorithm will converge.\n     let guarded = m.iter().any(|x| x.data.arm.guard.is_some());\n     let multi_pats = m.len() > 0 && m[0].pats.len() > 1;\n-    enter_match(bcx, tcx.def_map, m, col, val, |p| {\n+    enter_match(bcx, &tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(..) |\n-            ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n+            ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 let konst = lit(ConstLit(const_def_id));\n@@ -684,7 +675,7 @@ fn enter_opt<'r,'b>(\n                 }\n             }\n             ast::PatIdent(_, _, None)\n-                    if pat_is_variant_or_struct(tcx.def_map, p) => {\n+                    if pat_is_variant_or_struct(&tcx.def_map, p) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(Vec::new())\n                 } else {\n@@ -799,14 +790,14 @@ fn enter_opt<'r,'b>(\n     })\n }\n \n-fn enter_rec_or_struct<'r,'b>(\n+fn enter_rec_or_struct<'a, 'b>(\n                        bcx: &'b Block<'b>,\n-                       dm: DefMap,\n-                       m: &[Match<'r,'b>],\n+                       dm: &DefMap,\n+                       m: &'a [Match<'a, 'b>],\n                        col: uint,\n                        fields: &[ast::Ident],\n                        val: ValueRef)\n-                       -> Vec<Match<'r,'b>> {\n+                       -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -835,14 +826,14 @@ fn enter_rec_or_struct<'r,'b>(\n     })\n }\n \n-fn enter_tup<'r,'b>(\n+fn enter_tup<'a, 'b>(\n              bcx: &'b Block<'b>,\n-             dm: DefMap,\n-             m: &[Match<'r,'b>],\n+             dm: &DefMap,\n+             m: &'a [Match<'a, 'b>],\n              col: uint,\n              val: ValueRef,\n              n_elts: uint)\n-             -> Vec<Match<'r,'b>> {\n+             -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -868,14 +859,14 @@ fn enter_tup<'r,'b>(\n     })\n }\n \n-fn enter_tuple_struct<'r,'b>(\n+fn enter_tuple_struct<'a, 'b>(\n                       bcx: &'b Block<'b>,\n-                      dm: DefMap,\n-                      m: &[Match<'r,'b>],\n+                      dm: &DefMap,\n+                      m: &'a [Match<'a, 'b>],\n                       col: uint,\n                       val: ValueRef,\n                       n_elts: uint)\n-                      -> Vec<Match<'r,'b>> {\n+                      -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -897,13 +888,13 @@ fn enter_tuple_struct<'r,'b>(\n     })\n }\n \n-fn enter_uniq<'r,'b>(\n+fn enter_uniq<'a, 'b>(\n               bcx: &'b Block<'b>,\n-              dm: DefMap,\n-              m: &[Match<'r,'b>],\n+              dm: &DefMap,\n+              m: &'a [Match<'a, 'b>],\n               col: uint,\n               val: ValueRef)\n-              -> Vec<Match<'r,'b>> {\n+              -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -925,14 +916,13 @@ fn enter_uniq<'r,'b>(\n     })\n }\n \n-fn enter_region<'r,\n-                'b>(\n+fn enter_region<'a, 'b>(\n                 bcx: &'b Block<'b>,\n-                dm: DefMap,\n-                m: &[Match<'r,'b>],\n+                dm: &DefMap,\n+                m: &'a [Match<'a, 'b>],\n                 col: uint,\n                 val: ValueRef)\n-                -> Vec<Match<'r,'b>> {\n+                -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -1170,7 +1160,7 @@ fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat_id = br.pats.get(col).id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n-        bcx.ccx().maps.root_map.borrow().contains_key(&key)\n+        bcx.ccx().maps.root_map.contains_key(&key)\n     })\n }\n \n@@ -1424,12 +1414,11 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n     bcx\n }\n \n-fn compile_guard<'r,\n-                 'b>(\n+fn compile_guard<'a, 'b>(\n                  bcx: &'b Block<'b>,\n                  guard_expr: &ast::Expr,\n                  data: &ArmData,\n-                 m: &[Match<'r,'b>],\n+                 m: &'a [Match<'a, 'b>],\n                  vals: &[ValueRef],\n                  chk: &FailureHandler)\n                  -> &'b Block<'b> {\n@@ -1445,9 +1434,9 @@ fn compile_guard<'r,\n     let temp_scope = bcx.fcx.push_custom_cleanup_scope();\n \n     let mut bcx = bcx;\n-    bcx = store_non_ref_bindings(bcx, data.bindings_map,\n+    bcx = store_non_ref_bindings(bcx, &data.bindings_map,\n                                  Some(cleanup::CustomScope(temp_scope)));\n-    bcx = insert_lllocals(bcx, data.bindings_map,\n+    bcx = insert_lllocals(bcx, &data.bindings_map,\n                           cleanup::CustomScope(temp_scope));\n \n     let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n@@ -1482,10 +1471,9 @@ fn compile_guard<'r,\n     }\n }\n \n-fn compile_submatch<'r,\n-                    'b>(\n+fn compile_submatch<'a, 'b>(\n                     bcx: &'b Block<'b>,\n-                    m: &[Match<'r,'b>],\n+                    m: &'a [Match<'a, 'b>],\n                     vals: &[ValueRef],\n                     chk: &FailureHandler) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n@@ -1514,7 +1502,7 @@ fn compile_submatch<'r,\n             Some(guard_expr) => {\n                 bcx = compile_guard(bcx,\n                                     guard_expr,\n-                                    &m[0].data,\n+                                    m[0].data,\n                                     m.slice(1, m.len()),\n                                     vals,\n                                     chk);\n@@ -1541,17 +1529,16 @@ fn compile_submatch<'r,\n     }\n }\n \n-fn compile_submatch_continue<'r,\n-                             'b>(\n+fn compile_submatch_continue<'a, 'b>(\n                              mut bcx: &'b Block<'b>,\n-                             m: &[Match<'r,'b>],\n+                             m: &'a [Match<'a, 'b>],\n                              vals: &[ValueRef],\n                              chk: &FailureHandler,\n                              col: uint,\n                              val: ValueRef) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n-    let dm = tcx.def_map;\n+    let dm = &tcx.def_map;\n \n     let vals_left = Vec::from_slice(vals.slice(0u, col)).append(vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n@@ -1575,7 +1562,7 @@ fn compile_submatch_continue<'r,\n             expr::with_field_tys(tcx, pat_ty, Some(pat_id), |discr, field_tys| {\n                 let rec_vals = rec_fields.iter().map(|field_name| {\n                         let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n-                        adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n+                        adt::trans_field_ptr(bcx, &*pat_repr, val, discr, ix)\n                         }).collect::<Vec<_>>();\n                 compile_submatch(\n                         bcx,\n@@ -1601,7 +1588,7 @@ fn compile_submatch_continue<'r,\n           _ => ccx.sess().bug(\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = Vec::from_fn(n_tup_elts, |i| {\n-            adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n+            adt::trans_field_ptr(bcx, &*tup_repr, val, 0, i)\n         });\n         compile_submatch(bcx,\n                          enter_tup(bcx,\n@@ -1630,7 +1617,7 @@ fn compile_submatch_continue<'r,\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n         let llstructvals = Vec::from_fn(struct_element_count, |i| {\n-            adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n+            adt::trans_field_ptr(bcx, &*struct_repr, val, 0, i)\n         });\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n@@ -1666,8 +1653,8 @@ fn compile_submatch_continue<'r,\n     debug!(\"test_val={}\", bcx.val_to_str(test_val));\n     if opts.len() > 0u {\n         match *opts.get(0) {\n-            var(_, repr) => {\n-                let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n+            var(_, ref repr) => {\n+                let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n                 for &tval in val_opt.iter() { test_val = tval; }\n             }\n@@ -1813,9 +1800,9 @@ fn compile_submatch_continue<'r,\n         let mut size = 0u;\n         let mut unpacked = Vec::new();\n         match *opt {\n-            var(disr_val, repr) => {\n+            var(disr_val, ref repr) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n-                    extract_variant_args(opt_cx, repr, disr_val, val);\n+                    extract_variant_args(opt_cx, &**repr, disr_val, val);\n                 size = argvals.len();\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n@@ -1885,7 +1872,7 @@ fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    pat_bindings(tcx.def_map, pat, |bm, p_id, span, path| {\n+    pat_bindings(&tcx.def_map, pat, |bm, p_id, span, path| {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1933,26 +1920,6 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         return bcx;\n     }\n \n-    let mut arm_datas = Vec::new();\n-    let mut matches = Vec::new();\n-    for arm in arms.iter() {\n-        let body = fcx.new_id_block(\"case_body\", arm.body.id);\n-        let bindings_map = create_bindings_map(bcx, *arm.pats.get(0));\n-        let arm_data = ArmData {\n-            bodycx: body,\n-            arm: arm,\n-            bindings_map: @bindings_map\n-        };\n-        arm_datas.push(arm_data.clone());\n-        for p in arm.pats.iter() {\n-            matches.push(Match {\n-                pats: vec!(*p),\n-                data: arm_data.clone(),\n-                bound_ptrs: Vec::new(),\n-            });\n-        }\n-    }\n-\n     let t = node_id_type(bcx, discr_expr.id);\n     let chk = {\n         if ty::type_is_empty(tcx, t) {\n@@ -1970,8 +1937,23 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n             Infallible\n         }\n     };\n-    let lldiscr = discr_datum.val;\n-    compile_submatch(bcx, matches.as_slice(), [lldiscr], &chk);\n+\n+    let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n+        bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n+        arm: arm,\n+        bindings_map: create_bindings_map(bcx, *arm.pats.get(0))\n+    }).collect();\n+\n+    let mut matches = Vec::new();\n+    for arm_data in arm_datas.iter() {\n+        matches.extend(arm_data.arm.pats.iter().map(|p| Match {\n+            pats: vec!(*p),\n+            data: arm_data,\n+            bound_ptrs: Vec::new(),\n+        }));\n+    }\n+\n+    compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1982,12 +1964,12 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         // is just to reduce code space.  See extensive comment at the start\n         // of the file for more details.\n         if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, arm_data.bindings_map, None);\n+            bcx = store_non_ref_bindings(bcx, &arm_data.bindings_map, None);\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n         let cleanup_scope = fcx.push_custom_cleanup_scope();\n-        bcx = insert_lllocals(bcx, arm_data.bindings_map,\n+        bcx = insert_lllocals(bcx, &arm_data.bindings_map,\n                               cleanup::CustomScope(cleanup_scope));\n         bcx = expr::trans_into(bcx, arm_data.arm.body, dest);\n         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n@@ -2066,7 +2048,7 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(tcx.def_map, pat, |_, p_id, _, path| {\n+        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path| {\n                 let scope = cleanup::var_scope(tcx, p_id);\n                 bcx = mk_binding_alloca(\n                     bcx, p_id, path, BindLocal, scope, (),\n@@ -2199,7 +2181,7 @@ fn bind_irrefutable_pat<'a>(\n     let ccx = bcx.ccx();\n     match pat.node {\n         ast::PatIdent(pat_binding_mode, ref path, inner) => {\n-            if pat_is_binding(tcx.def_map, pat) {\n+            if pat_is_binding(&tcx.def_map, pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map.\n@@ -2238,7 +2220,7 @@ fn bind_irrefutable_pat<'a>(\n                                                          enum_id,\n                                                          var_id);\n                     let args = extract_variant_args(bcx,\n-                                                    repr,\n+                                                    &*repr,\n                                                     vinfo.disr_val,\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n@@ -2259,7 +2241,7 @@ fn bind_irrefutable_pat<'a>(\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for (i, elem) in elems.iter().enumerate() {\n-                                let fldptr = adt::trans_field_ptr(bcx, repr,\n+                                let fldptr = adt::trans_field_ptr(bcx, &*repr,\n                                                                   val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx, *elem,\n                                                            fldptr, binding_mode,\n@@ -2282,7 +2264,7 @@ fn bind_irrefutable_pat<'a>(\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n                 for f in fields.iter() {\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n-                    let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n+                    let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, f.pat, fldptr,\n                                                binding_mode, cleanup_scope);\n@@ -2292,7 +2274,7 @@ fn bind_irrefutable_pat<'a>(\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n+                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx, *elem, fldptr,\n                                            binding_mode, cleanup_scope);\n             }"}, {"sha": "fbd638b6191f6c9f3dbeaaf4bd8d6dd998fd7620", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -45,8 +45,8 @@\n \n use std::container::Map;\n use libc::c_ulonglong;\n-use std::option::{Option, Some, None};\n use std::num::{Bitwise};\n+use std::rc::Rc;\n \n use lib::llvm::{ValueRef, True, IntEQ, IntNE};\n use middle::trans::_match;\n@@ -115,22 +115,22 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: &Block, node: ast::NodeId) -> @Repr {\n+pub fn represent_node(bcx: &Block, node: ast::NodeId) -> Rc<Repr> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n+pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     debug!(\"Representing: {}\", ty_to_str(cx.tcx(), t));\n     match cx.adt_reprs.borrow().find(&t) {\n-        Some(repr) => return *repr,\n+        Some(repr) => return repr.clone(),\n         None => {}\n     }\n \n-    let repr = @represent_type_uncached(cx, t);\n+    let repr = Rc::new(represent_type_uncached(cx, t));\n     debug!(\"Represented as: {:?}\", repr)\n-    cx.adt_reprs.borrow_mut().insert(t, repr);\n-    return repr;\n+    cx.adt_reprs.borrow_mut().insert(t, repr.clone());\n+    repr\n }\n \n fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n@@ -267,7 +267,19 @@ impl Case {\n         mk_struct(cx, self.tys.as_slice(), false).size == 0\n     }\n     fn find_ptr(&self) -> Option<uint> {\n-        self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n+        self.tys.iter().position(|&ty| {\n+            match ty::get(ty).sty {\n+                ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                    ty::ty_vec(_, None) => false,\n+                    _ => true,\n+                },\n+                ty::ty_uniq(..) | ty::ty_box(..) |\n+                ty::ty_str(ty::VstoreUniq) |\n+                ty::ty_bare_fn(..) => true,\n+                // Is that everything?  Would closures or slices qualify?\n+                _ => false\n+            }\n+        })\n     }\n }\n "}, {"sha": "fda51e744ce0943f6f9bc7528c3468ee94a103ec", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 55, "deletions": 62, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -75,6 +75,7 @@ use libc::c_uint;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::local_data;\n+use std::rc::Rc;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n@@ -398,17 +399,17 @@ pub fn malloc_raw_dyn_managed<'a>(\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n+pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n     match ccx.tydescs.borrow().find(&t) {\n-        Some(&inf) => return inf,\n+        Some(inf) => return inf.clone(),\n         _ => { }\n     }\n \n     ccx.stats.n_static_tydescs.set(ccx.stats.n_static_tydescs.get() + 1u);\n-    let inf = glue::declare_tydesc(ccx, t);\n+    let inf = Rc::new(glue::declare_tydesc(ccx, t));\n \n-    ccx.tydescs.borrow_mut().insert(t, inf);\n-    return inf;\n+    ccx.tydescs.borrow_mut().insert(t, inf.clone());\n+    inf\n }\n \n #[allow(dead_code)] // useful\n@@ -637,7 +638,7 @@ pub fn iter_structural_ty<'r,\n                     cx: &'b Block<'b>,\n                     repr: &adt::Repr,\n                     av: ValueRef,\n-                    variant: @ty::VariantInfo,\n+                    variant: &ty::VariantInfo,\n                     tps: &[ty::t],\n                     f: val_and_ty_fn<'r,'b>)\n                     -> &'b Block<'b> {\n@@ -659,7 +660,7 @@ pub fn iter_structural_ty<'r,\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n-                  let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n+                  let llfld_a = adt::trans_field_ptr(cx, &*repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n           })\n@@ -677,7 +678,7 @@ pub fn iter_structural_ty<'r,\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for (i, arg) in args.iter().enumerate() {\n-              let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n+              let llfld_a = adt::trans_field_ptr(cx, &*repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n@@ -692,9 +693,9 @@ pub fn iter_structural_ty<'r,\n           // NB: we must hit the discriminant first so that structural\n           // comparison know not to proceed when the discriminants differ.\n \n-          match adt::trans_switch(cx, repr, av) {\n+          match adt::trans_switch(cx, &*repr, av) {\n               (_match::single, None) => {\n-                  cx = iter_variant(cx, repr, av, *variants.get(0),\n+                  cx = iter_variant(cx, &*repr, av, &**variants.get(0),\n                                     substs.tps.as_slice(), f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n@@ -709,7 +710,7 @@ pub fn iter_structural_ty<'r,\n                       let variant_cx =\n                           fcx.new_temp_block(\"enum-iter-variant-\".to_owned() +\n                                              variant.disr_val.to_str());\n-                      match adt::trans_case(cx, repr, variant.disr_val) {\n+                      match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n                           }\n@@ -718,9 +719,9 @@ pub fn iter_structural_ty<'r,\n                       }\n                       let variant_cx =\n                           iter_variant(variant_cx,\n-                                       repr,\n+                                       &*repr,\n                                        av,\n-                                       *variant,\n+                                       &**variant,\n                                        substs.tps.as_slice(),\n                                        |x,y,z| f(x,y,z));\n                       Br(variant_cx, next_cx.llbb);\n@@ -1112,15 +1113,15 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n                        id: ast::NodeId,\n                        has_env: bool,\n                        output_type: ty::t,\n-                       param_substs: Option<@param_substs>,\n+                       param_substs: Option<&'a param_substs>,\n                        sp: Option<Span>,\n                        block_arena: &'a TypedArena<Block<'a>>)\n                        -> FunctionContext<'a> {\n     for p in param_substs.iter() { p.validate(); }\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n            if id == -1 { \"\".to_owned() } else { ccx.tcx.map.path_to_str(id) },\n-           id, param_substs.repr(ccx.tcx()));\n+           id, param_substs.map(|s| s.repr(ccx.tcx())));\n \n     let substd_output_type = match param_substs {\n         None => output_type,\n@@ -1166,11 +1167,9 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n \n /// Performs setup on a newly created function, creating the entry scope block\n /// and allocating space for the return pointer.\n-pub fn init_function<'a>(\n-                     fcx: &'a FunctionContext<'a>,\n-                     skip_retptr: bool,\n-                     output_type: ty::t,\n-                     param_substs: Option<@param_substs>) {\n+pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n+                         skip_retptr: bool,\n+                         output_type: ty::t) {\n     let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n     *fcx.entry_bcx.borrow_mut() = Some(entry_bcx);\n@@ -1182,7 +1181,9 @@ pub fn init_function<'a>(\n         llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n     }));\n \n-    let substd_output_type = match param_substs {\n+    // This shouldn't need to recompute the return type,\n+    // as new_fn_ctxt did it already.\n+    let substd_output_type = match fcx.param_substs {\n         None => output_type,\n         Some(substs) => {\n             ty::subst_tps(fcx.ccx.tcx(),\n@@ -1329,7 +1330,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      llfndecl: ValueRef,\n-                     param_substs: Option<@param_substs>,\n+                     param_substs: Option<&param_substs>,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n@@ -1340,7 +1341,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     set_uwtable(llfndecl);\n \n     debug!(\"trans_closure(..., param_substs={})\",\n-           param_substs.repr(ccx.tcx()));\n+           param_substs.map(|s| s.repr(ccx.tcx())));\n \n     let has_env = match ty::get(ty::node_id_to_type(ccx.tcx(), id)).sty {\n         ty::ty_closure(_) => true,\n@@ -1353,10 +1354,10 @@ pub fn trans_closure(ccx: &CrateContext,\n                           id,\n                           has_env,\n                           output_type,\n-                          param_substs,\n+                          param_substs.map(|s| &*s),\n                           Some(body.span),\n                           &arena);\n-    init_function(&fcx, false, output_type, param_substs);\n+    init_function(&fcx, false, output_type);\n \n     // cleanup scope for the incoming arguments\n     let arg_scope = fcx.push_custom_cleanup_scope();\n@@ -1429,11 +1430,11 @@ pub fn trans_fn(ccx: &CrateContext,\n                 decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n-                param_substs: Option<@param_substs>,\n+                param_substs: Option<&param_substs>,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id));\n-    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n+    debug!(\"trans_fn(param_substs={})\", param_substs.map(|s| s.repr(ccx.tcx())));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n     trans_closure(ccx, decl, body, llfndecl,\n@@ -1445,7 +1446,7 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n                           variant: &ast::Variant,\n                           _args: &[ast::VariantArg],\n                           disr: ty::Disr,\n-                          param_substs: Option<@param_substs>,\n+                          param_substs: Option<&param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n@@ -1460,7 +1461,7 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n pub fn trans_tuple_struct(ccx: &CrateContext,\n                           _fields: &[ast::StructField],\n                           ctor_id: ast::NodeId,\n-                          param_substs: Option<@param_substs>,\n+                          param_substs: Option<&param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n@@ -1475,24 +1476,20 @@ pub fn trans_tuple_struct(ccx: &CrateContext,\n fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n                                            ctor_id: ast::NodeId,\n                                            disr: ty::Disr,\n-                                           param_substs: Option<@param_substs>,\n+                                           param_substs: Option<&param_substs>,\n                                            llfndecl: ValueRef) {\n-    let no_substs: &[ty::t] = [];\n-    let ty_param_substs = match param_substs {\n-        Some(ref substs) => {\n-            let v: &[ty::t] = substs.tys.as_slice();\n-            v\n-        }\n-        None => {\n-            let v: &[ty::t] = no_substs;\n-            v\n-        }\n-    };\n+    let ctor_ty = {\n+        let no_substs: &[ty::t] = [];\n+        let ty_param_substs: &[ty::t] = match param_substs {\n+            Some(substs) => substs.tys.as_slice(),\n+            None => no_substs\n+        };\n \n-    let ctor_ty = ty::subst_tps(ccx.tcx(),\n-                                ty_param_substs,\n-                                None,\n-                                ty::node_id_to_type(ccx.tcx(), ctor_id));\n+        ty::subst_tps(ccx.tcx(),\n+                      ty_param_substs,\n+                      None,\n+                      ty::node_id_to_type(ccx.tcx(), ctor_id))\n+    };\n \n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n@@ -1504,8 +1501,8 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n-                          param_substs, None, &arena);\n-    init_function(&fcx, false, result_ty, param_substs);\n+                          param_substs.map(|s| &*s), None, &arena);\n+    init_function(&fcx, false, result_ty);\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n@@ -1515,10 +1512,10 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n         let repr = adt::represent_type(ccx, result_ty);\n-        adt::trans_start_init(bcx, repr, fcx.llretptr.get().unwrap(), disr);\n+        adt::trans_start_init(bcx, &*repr, fcx.llretptr.get().unwrap(), disr);\n         for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n-                                                 repr,\n+                                                 &*repr,\n                                                  fcx.llretptr.get().unwrap(),\n                                                  disr,\n                                                  i);\n@@ -1529,11 +1526,11 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n     finish_fn(&fcx, bcx);\n }\n \n-pub fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n-                      id: ast::NodeId, vi: @Vec<@ty::VariantInfo>,\n-                      i: &mut uint) {\n+fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n+                  id: ast::NodeId, vi: &[Rc<ty::VariantInfo>],\n+                  i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n-        let disr_val = vi.get(*i).disr_val;\n+        let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n@@ -1596,7 +1593,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n         if !generics.is_type_parameterized() {\n             let vi = ty::enum_variants(ccx.tcx(), local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, enum_definition, item.id, vi, &mut i);\n+            trans_enum_def(ccx, enum_definition, item.id, vi.as_slice(), &mut i);\n         }\n       }\n       ast::ItemStatic(_, m, expr) => {\n@@ -2056,17 +2053,13 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n \n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n-\n-        let diag = cx.sess().diagnostic();\n-        let item_symbols = &cx.item_symbols;\n-        let link_meta = &cx.link_meta;\n         encoder::EncodeParams {\n-            diag: diag,\n+            diag: cx.sess().diagnostic(),\n             tcx: cx.tcx(),\n-            reexports2: cx.exp_map2,\n-            item_symbols: item_symbols,\n+            reexports2: &cx.exp_map2,\n+            item_symbols: &cx.item_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n-            link_meta: link_meta,\n+            link_meta: &cx.link_meta,\n             cstore: &cx.sess().cstore,\n             encode_inlined_item: ie,\n         }"}, {"sha": "642ae86a97989f718d5e3e6e7ccf1e6d6dbb6993", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -176,14 +176,14 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) ->\n            def_id.repr(bcx.tcx()), node, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n     trans_fn_ref_with_vtables(bcx, def_id, node,\n-                              type_params.as_slice(),\n+                              type_params,\n                               vtables)\n }\n \n fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            def_id: ast::DefId,\n                                            ref_id: ast::NodeId,\n-                                           type_params: &[ty::t],\n+                                           type_params: Vec<ty::t>,\n                                            vtables: Option<typeck::vtable_res>)\n                                            -> Callee<'a> {\n     Callee {bcx: bcx,\n@@ -203,32 +203,35 @@ fn resolve_default_method_vtables(bcx: &Block,\n \n     // Build up a param_substs that we are going to resolve the\n     // trait_vtables under.\n-    let param_substs = Some(@param_substs {\n+    let param_substs = param_substs {\n         tys: substs.tps.clone(),\n         self_ty: substs.self_ty,\n-        vtables: impl_vtables,\n+        vtables: impl_vtables.clone(),\n         self_vtables: None\n-    });\n+    };\n \n-    let trait_vtables_fixed = resolve_vtables_under_param_substs(\n-        bcx.tcx(), param_substs, impl_res.trait_vtables);\n+    let mut param_vtables = resolve_vtables_under_param_substs(\n+        bcx.tcx(), Some(&param_substs), impl_res.trait_vtables.as_slice());\n \n     // Now we pull any vtables for parameters on the actual method.\n     let num_method_vtables = method.generics.type_param_defs().len();\n-    let method_vtables = match impl_vtables {\n-        Some(vtables) => {\n+    match impl_vtables {\n+        Some(ref vtables) => {\n             let num_impl_type_parameters =\n                 vtables.len() - num_method_vtables;\n-            Vec::from_slice(vtables.tailn(num_impl_type_parameters))\n+            param_vtables.push_all(vtables.tailn(num_impl_type_parameters))\n         },\n-        None => Vec::from_elem(num_method_vtables, @Vec::new())\n-    };\n-\n-    let method_vtables = method_vtables.as_slice();\n-    let param_vtables = @((*trait_vtables_fixed).clone().append(method_vtables));\n+        None => {\n+            param_vtables.extend(range(0, num_method_vtables).map(\n+                |_| -> typeck::vtable_param_res {\n+                    Vec::new()\n+                }\n+            ))\n+        }\n+    }\n \n     let self_vtables = resolve_param_vtables_under_param_substs(\n-        bcx.tcx(), param_substs, impl_res.self_vtables);\n+        bcx.tcx(), Some(&param_substs), impl_res.self_vtables.as_slice());\n \n     (param_vtables, self_vtables)\n }\n@@ -238,7 +241,7 @@ pub fn trans_fn_ref_with_vtables(\n         bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n         node: ExprOrMethodCall,  // node id of use of fn; may be zero if N/A\n-        type_params: &[ty::t], // values for fn's ty params\n+        type_params: Vec<ty::t>, // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> ValueRef {\n     /*!\n@@ -273,9 +276,11 @@ pub fn trans_fn_ref_with_vtables(\n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n \n-    let substs = ty::substs { regions: ty::ErasedRegions,\n-                              self_ty: None,\n-                              tps: /*bad*/ Vec::from_slice(type_params) };\n+    let substs = ty::substs {\n+        regions: ty::ErasedRegions,\n+        self_ty: None,\n+        tps: type_params\n+    };\n \n     // Load the info for the appropriate trait if necessary.\n     match ty::trait_of_method(tcx, def_id) {\n@@ -313,24 +318,25 @@ pub fn trans_fn_ref_with_vtables(\n \n             // Compute the first substitution\n             let first_subst = make_substs_for_receiver_types(\n-                tcx, impl_id, trait_ref, method);\n+                tcx, impl_id, &*trait_ref, &*method);\n \n             // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n \n+            debug!(\"trans_fn_with_vtables - default method: \\\n+                    substs = {}, trait_subst = {}, \\\n+                    first_subst = {}, new_subst = {}, \\\n+                    vtables = {}\",\n+                   substs.repr(tcx), trait_ref.substs.repr(tcx),\n+                   first_subst.repr(tcx), new_substs.repr(tcx),\n+                   vtables.repr(tcx));\n \n             let (param_vtables, self_vtables) =\n                 resolve_default_method_vtables(bcx, impl_id,\n-                                               method, &substs, vtables);\n+                                               &*method, &substs, vtables);\n \n             debug!(\"trans_fn_with_vtables - default method: \\\n-                    substs = {}, trait_subst = {}, \\\n-                    first_subst = {}, new_subst = {}, \\\n-                    vtables = {}, \\\n                     self_vtable = {}, param_vtables = {}\",\n-                   substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                   first_subst.repr(tcx), new_substs.repr(tcx),\n-                   vtables.repr(tcx),\n                    self_vtables.repr(tcx), param_vtables.repr(tcx));\n \n             (true, source_id,\n@@ -352,7 +358,7 @@ pub fn trans_fn_ref_with_vtables(\n     // intrinsic, or is a default method.  In particular, if we see an\n     // intrinsic that is inlined from a different crate, we want to reemit the\n     // intrinsic instead of trying to call it in the other crate.\n-    let must_monomorphise = if type_params.len() > 0 || is_default {\n+    let must_monomorphise = if substs.tps.len() > 0 || is_default {\n         true\n     } else if def_id.krate == ast::LOCAL_CRATE {\n         let map_node = session::expect(\n@@ -391,7 +397,7 @@ pub fn trans_fn_ref_with_vtables(\n             let ref_ty = match node {\n                 ExprId(id) => node_id_type(bcx, id),\n                 MethodCall(method_call) => {\n-                    let t = bcx.ccx().maps.method_map.borrow().get(&method_call).ty;\n+                    let t = bcx.tcx().method_map.borrow().get(&method_call).ty;\n                     monomorphize_type(bcx, t)\n                 }\n             };\n@@ -474,7 +480,7 @@ pub fn trans_method_call<'a>(\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get(&method_call).ty;\n+    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n     trans_call_inner(\n         bcx,\n         Some(common::expr_info(call_ex)),\n@@ -504,7 +510,7 @@ pub fn trans_lang_call<'a>(\n                                 trans_fn_ref_with_vtables_to_callee(bcx,\n                                                                     did,\n                                                                     0,\n-                                                                    [],\n+                                                                    vec!(),\n                                                                     None)\n                              },\n                              ArgVals(args),"}, {"sha": "df17fb516a7e72d3bf2c10668bea1267462ed744", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -466,7 +466,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output, None, None, &arena);\n-    init_function(&fcx, true, f.sig.output, None);\n+    init_function(&fcx, true, f.sig.output);\n     let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n \n     let args = create_datums_for_fn_args(&fcx,"}, {"sha": "edb98db416ad302f0e9fc6c6555b6e24b87582d4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 35, "deletions": 95, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -154,21 +154,6 @@ pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n     NodeInfo { id: expr.id, span: expr.span }\n }\n \n-pub struct Stats {\n-    pub n_static_tydescs: Cell<uint>,\n-    pub n_glues_created: Cell<uint>,\n-    pub n_null_glues: Cell<uint>,\n-    pub n_real_glues: Cell<uint>,\n-    pub n_fns: Cell<uint>,\n-    pub n_monos: Cell<uint>,\n-    pub n_inlines: Cell<uint>,\n-    pub n_closures: Cell<uint>,\n-    pub n_llvm_insns: Cell<uint>,\n-    pub llvm_insns: RefCell<HashMap<~str, uint>>,\n-    // (ident, time-in-ms, llvm-instructions)\n-    pub fn_stats: RefCell<Vec<(~str, uint, uint)> >,\n-}\n-\n pub struct BuilderRef_res {\n     pub b: BuilderRef,\n }\n@@ -274,7 +259,7 @@ pub struct FunctionContext<'a> {\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n-    pub param_substs: Option<@param_substs>,\n+    pub param_substs: Option<&'a param_substs>,\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n@@ -686,53 +671,9 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-// Used to identify cached monomorphized functions and vtables\n-#[deriving(Eq, TotalEq, Hash)]\n-pub enum mono_param_id {\n-    mono_precise(ty::t, Option<@Vec<mono_id> >),\n-    mono_any,\n-    mono_repr(uint /* size */,\n-              uint /* align */,\n-              MonoDataClass,\n-              datum::RvalueMode),\n-}\n-\n-#[deriving(Eq, TotalEq, Hash)]\n-pub enum MonoDataClass {\n-    MonoBits,    // Anything not treated differently from arbitrary integer data\n-    MonoNonNull, // Non-null pointers (used for optional-pointer optimization)\n-    // FIXME(#3547)---scalars and floats are\n-    // treated differently in most ABIs.  But we\n-    // should be doing something more detailed\n-    // here.\n-    MonoFloat\n-}\n-\n-pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n-    match ty::get(t).sty {\n-        ty::ty_float(_) => MonoFloat,\n-        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n-            ty::ty_vec(_, None) => MonoBits,\n-            _ => MonoNonNull,\n-        },\n-        ty::ty_uniq(..) | ty::ty_box(..) |\n-        ty::ty_str(ty::VstoreUniq) |\n-        ty::ty_bare_fn(..) => MonoNonNull,\n-        // Is that everything?  Would closures or slices qualify?\n-        _ => MonoBits\n-    }\n-}\n-\n-#[deriving(Eq, TotalEq, Hash)]\n-pub struct mono_id_ {\n-    pub def: ast::DefId,\n-    pub params: Vec<mono_param_id> }\n-\n-pub type mono_id = @mono_id_;\n-\n pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n-        Some(substs) => {\n+        Some(ref substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys.as_slice(), substs.self_ty, t)\n         }\n         _ => {\n@@ -754,9 +695,7 @@ pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n }\n \n pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n-    let tcx = bcx.tcx();\n-    let t = ty::expr_ty_adjusted(tcx, ex, &*bcx.ccx().maps.method_map.borrow());\n-    monomorphize_type(bcx, t)\n+    monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n@@ -774,7 +713,7 @@ pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n     let params = match node {\n         ExprId(id) => ty::node_id_to_type_params(tcx, id),\n         MethodCall(method_call) => {\n-            bcx.ccx().maps.method_map.borrow().get(&method_call).substs.tps.clone()\n+            tcx.method_map.borrow().get(&method_call).substs.tps.clone()\n         }\n     };\n \n@@ -788,62 +727,63 @@ pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n     }\n \n     match bcx.fcx.param_substs {\n-      Some(substs) => {\n-        params.iter().map(|t| {\n-            ty::subst_tps(tcx, substs.tys.as_slice(), substs.self_ty, *t)\n-        }).collect()\n-      }\n-      _ => params\n+        Some(ref substs) => {\n+            params.iter().map(|t| {\n+                ty::subst_tps(tcx, substs.tys.as_slice(), substs.self_ty, *t)\n+            }).collect()\n+        }\n+        _ => params\n     }\n }\n \n pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n                  -> Option<typeck::vtable_res> {\n-    let vtable_map = bcx.ccx().maps.vtable_map.borrow();\n-    let raw_vtables = vtable_map.find(&id);\n-    raw_vtables.map(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n+    bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n+        resolve_vtables_in_fn_ctxt(bcx.fcx, vts.as_slice())\n+    })\n }\n \n // Apply the typaram substitutions in the FunctionContext to some\n // vtables. This should eliminate any vtable_params.\n-pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res)\n-    -> typeck::vtable_res {\n+pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext,\n+                                  vts: &[typeck::vtable_param_res])\n+                                  -> typeck::vtable_res {\n     resolve_vtables_under_param_substs(fcx.ccx.tcx(),\n                                        fcx.param_substs,\n                                        vts)\n }\n \n pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n-                                          param_substs: Option<@param_substs>,\n-                                          vts: typeck::vtable_res)\n-    -> typeck::vtable_res {\n-    @vts.iter().map(|ds|\n+                                          param_substs: Option<&param_substs>,\n+                                          vts: &[typeck::vtable_param_res])\n+                                          -> typeck::vtable_res {\n+    vts.iter().map(|ds| {\n       resolve_param_vtables_under_param_substs(tcx,\n                                                param_substs,\n-                                               *ds))\n-        .collect()\n+                                               ds.as_slice())\n+    }).collect()\n }\n \n pub fn resolve_param_vtables_under_param_substs(\n     tcx: &ty::ctxt,\n-    param_substs: Option<@param_substs>,\n-    ds: typeck::vtable_param_res)\n+    param_substs: Option<&param_substs>,\n+    ds: &[typeck::vtable_origin])\n     -> typeck::vtable_param_res {\n-    @ds.iter().map(\n-        |d| resolve_vtable_under_param_substs(tcx,\n-                                              param_substs,\n-                                              d))\n-        .collect()\n+    ds.iter().map(|d| {\n+        resolve_vtable_under_param_substs(tcx,\n+                                          param_substs,\n+                                          d)\n+    }).collect()\n }\n \n \n \n pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n-                                         param_substs: Option<@param_substs>,\n+                                         param_substs: Option<&param_substs>,\n                                          vt: &typeck::vtable_origin)\n                                          -> typeck::vtable_origin {\n     match *vt {\n-        typeck::vtable_static(trait_id, ref tys, sub) => {\n+        typeck::vtable_static(trait_id, ref tys, ref sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n                     tys.iter().map(|t| {\n@@ -857,7 +797,7 @@ pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n             };\n             typeck::vtable_static(\n                 trait_id, tys,\n-                resolve_vtables_under_param_substs(tcx, param_substs, sub))\n+                resolve_vtables_under_param_substs(tcx, param_substs, sub.as_slice()))\n         }\n         typeck::vtable_param(n_param, n_bound) => {\n             match param_substs {\n@@ -883,11 +823,11 @@ pub fn find_vtable(tcx: &ty::ctxt,\n            n_param, n_bound, ps.repr(tcx));\n \n     let param_bounds = match n_param {\n-        typeck::param_self => ps.self_vtables.expect(\"self vtables missing\"),\n+        typeck::param_self => ps.self_vtables.as_ref().expect(\"self vtables missing\"),\n         typeck::param_numbered(n) => {\n-            let tables = ps.vtables\n+            let tables = ps.vtables.as_ref()\n                 .expect(\"vtables missing where they are needed\");\n-            *tables.get(n)\n+            tables.get(n)\n         }\n     };\n     param_bounds.get(n_bound).clone()"}, {"sha": "759e48e633f062ff19f17d160e2bce7b15fb4828", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -130,7 +130,7 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: ty::t)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n-    adt::const_get_field(cx, repr, v, 0, 0)\n+    adt::const_get_field(cx, &*repr, v, 0, 0)\n }\n \n fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n@@ -187,13 +187,12 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e,\n-                                            &*cx.maps.method_map.borrow());\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n     let opt_adj = cx.tcx.adjustments.borrow().find_copy(&e.id);\n     match opt_adj {\n         None => { }\n         Some(adj) => {\n-            match *adj {\n+            match adj {\n                 ty::AutoAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n                     let def = ty::resolve_expr(cx.tcx(), e);\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n@@ -414,19 +413,17 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }, true)\n           }\n           ast::ExprField(base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n-                                            &*cx.maps.method_map.borrow());\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), base);\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.name, field_tys);\n-                  (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n+                  (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n           ast::ExprIndex(base, index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n-                                            &*cx.maps.method_map.borrow());\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), base);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), index) {\n                   const_eval::const_int(i) => i as u64,\n@@ -494,7 +491,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n                 let repr = adt::represent_type(cx, basety);\n-                let discr = adt::const_get_discrim(cx, repr, v);\n+                let discr = adt::const_get_discrim(cx, &*repr, v);\n                 let iv = C_integral(cx.int_type, discr, false);\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n@@ -527,7 +524,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let (vals, inlineable) = map_list(es.as_slice());\n-              (adt::trans_const(cx, repr, 0, vals.as_slice()), inlineable)\n+              (adt::trans_const(cx, &*repr, 0, vals.as_slice()), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -547,15 +544,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                           None => {\n                               match base_val {\n                                 Some((bv, inlineable)) => {\n-                                    (adt::const_get_field(cx, repr, bv, discr, ix),\n+                                    (adt::const_get_field(cx, &*repr, bv, discr, ix),\n                                      inlineable)\n                                 }\n                                 None => cx.sess().span_bug(e.span, \"missing struct field\")\n                               }\n                           }\n                       }\n                   }));\n-                  (adt::trans_const(cx, repr, discr, cs),\n+                  (adt::trans_const(cx, &*repr, discr, cs),\n                    inlineable.iter().fold(true, |a, &b| a && b))\n               })\n           }\n@@ -635,7 +632,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    (adt::trans_const(cx, repr, vinfo.disr_val, []), true)\n+                    (adt::trans_const(cx, &*repr, vinfo.disr_val, []), true)\n                 }\n                 Some(ast::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n@@ -654,7 +651,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, repr, 0, arg_vals.as_slice()),\n+                      (adt::trans_const(cx, &*repr, 0, arg_vals.as_slice()),\n                        inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n@@ -665,7 +662,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                                            variant_did);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx,\n-                                        repr,\n+                                        &*repr,\n                                         vinfo.disr_val,\n                                         arg_vals.as_slice()), inlineable)\n                   }"}, {"sha": "119750cd9ce03a7f2ba4cc00a50305a91bb8bcf7", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -20,8 +20,9 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::builder::Builder;\n-use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n+use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n use middle::trans::debuginfo;\n+use middle::trans::monomorphize::MonoId;\n use middle::trans::type_::Type;\n use middle::ty;\n use util::sha2::Sha256;\n@@ -30,10 +31,26 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n use std::ptr;\n+use std::rc::Rc;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n+pub struct Stats {\n+    pub n_static_tydescs: Cell<uint>,\n+    pub n_glues_created: Cell<uint>,\n+    pub n_null_glues: Cell<uint>,\n+    pub n_real_glues: Cell<uint>,\n+    pub n_fns: Cell<uint>,\n+    pub n_monos: Cell<uint>,\n+    pub n_inlines: Cell<uint>,\n+    pub n_closures: Cell<uint>,\n+    pub n_llvm_insns: Cell<uint>,\n+    pub llvm_insns: RefCell<HashMap<~str, uint>>,\n+    // (ident, time-in-ms, llvm-instructions)\n+    pub fn_stats: RefCell<Vec<(~str, uint, uint)> >,\n+}\n+\n pub struct CrateContext {\n     pub llmod: ModuleRef,\n     pub llcx: ContextRef,\n@@ -47,7 +64,7 @@ pub struct CrateContext {\n     pub item_symbols: RefCell<NodeMap<~str>>,\n     pub link_meta: LinkMeta,\n     pub drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n-    pub tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n+    pub tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n     /// created.\n     pub finished_tydescs: Cell<bool>,\n@@ -61,10 +78,10 @@ pub struct CrateContext {\n     /// that is generated\n     pub non_inlineable_statics: RefCell<NodeSet>,\n     /// Cache instances of monomorphized functions\n-    pub monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n+    pub monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n     pub monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n+    pub vtables: RefCell<HashMap<(ty::t, MonoId), ValueRef>>,\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n@@ -91,13 +108,13 @@ pub struct CrateContext {\n \n     pub lltypes: RefCell<HashMap<ty::t, Type>>,\n     pub llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n-    pub adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n+    pub adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n     pub symbol_hasher: RefCell<Sha256>,\n     pub type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n     pub all_llvm_symbols: RefCell<HashSet<~str>>,\n     pub tcx: ty::ctxt,\n     pub maps: astencode::Maps,\n-    pub stats: @Stats,\n+    pub stats: Stats,\n     pub int_type: Type,\n     pub opaque_vec_type: Type,\n     pub builder: BuilderRef_res,\n@@ -179,7 +196,7 @@ impl CrateContext {\n                 all_llvm_symbols: RefCell::new(HashSet::new()),\n                 tcx: tcx,\n                 maps: maps,\n-                stats: @Stats {\n+                stats: Stats {\n                     n_static_tydescs: Cell::new(0u),\n                     n_glues_created: Cell::new(0u),\n                     n_null_glues: Cell::new(0u),"}, {"sha": "4dd929e16f7252f9531151fa732ea3197e937bad", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -57,7 +57,7 @@ For example, the following simple type for a singly-linked list...\n ```\n struct List {\n     value: int,\n-    tail: Option<@List>,\n+    tail: Option<~List>,\n }\n ```\n \n@@ -66,8 +66,8 @@ will generate the following callstack with a naive DFS algorithm:\n ```\n describe(t = List)\n   describe(t = int)\n-  describe(t = Option<@List>)\n-    describe(t = @List)\n+  describe(t = Option<~List>)\n+    describe(t = ~List)\n       describe(t = List) // at the beginning again...\n       ...\n ```\n@@ -144,6 +144,7 @@ use util::ppaux;\n \n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n+use std::rc::{Rc, Weak};\n use collections::HashMap;\n use collections::HashSet;\n use libc::{c_uint, c_ulonglong, c_longlong};\n@@ -180,7 +181,7 @@ pub struct CrateDebugContext {\n     created_files: RefCell<HashMap<~str, DIFile>>,\n     created_types: RefCell<HashMap<uint, DIType>>,\n     created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n-    namespace_map: RefCell<HashMap<Vec<ast::Name> , @NamespaceTreeNode>>,\n+    namespace_map: RefCell<HashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n     composite_types_completed: RefCell<HashSet<DIType>>,\n@@ -369,7 +370,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     }\n \n     let cx = bcx.ccx();\n-    let def_map = cx.tcx.def_map;\n+    let def_map = &cx.tcx.def_map;\n \n     pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n@@ -509,7 +510,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n-    let def_map = cx.tcx.def_map;\n+    let def_map = &cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n@@ -609,7 +610,7 @@ pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n /// indicates why no debuginfo should be created for the function.\n pub fn create_function_debug_context(cx: &CrateContext,\n                                      fn_ast_id: ast::NodeId,\n-                                     param_substs: Option<@param_substs>,\n+                                     param_substs: Option<&param_substs>,\n                                      llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext { repr: DebugInfoDisabled };\n@@ -775,7 +776,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n                               fn_decl: &ast::FnDecl,\n-                              param_substs: Option<@param_substs>,\n+                              param_substs: Option<&param_substs>,\n                               error_span: Span) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), []);\n@@ -828,7 +829,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     fn get_template_parameters(cx: &CrateContext,\n                                generics: &ast::Generics,\n-                               param_substs: Option<@param_substs>,\n+                               param_substs: Option<&param_substs>,\n                                file_metadata: DIFile,\n                                name_to_append_suffix_to: &mut StrBuf)\n                                -> DIArray {\n@@ -1388,8 +1389,8 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n }\n \n struct GeneralMemberDescriptionFactory {\n-    type_rep: @adt::Repr,\n-    variants: @Vec<@ty::VariantInfo> ,\n+    type_rep: Rc<adt::Repr>,\n+    variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n     discriminant_type_metadata: ValueRef,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1412,7 +1413,7 @@ impl GeneralMemberDescriptionFactory {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          *self.variants.get(i),\n+                                          &**self.variants.get(i),\n                                           Some(self.discriminant_type_metadata),\n                                           self.containing_scope,\n                                           self.file_metadata,\n@@ -1617,7 +1618,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                  member_description_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          *variants.get(0),\n+                                          &**variants.get(0),\n                                           None,\n                                           containing_scope,\n                                           file_metadata,\n@@ -1661,7 +1662,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 llvm_type: enum_llvm_type,\n                 file_metadata: file_metadata,\n                 member_description_factory: GeneralMD(GeneralMemberDescriptionFactory {\n-                    type_rep: type_rep,\n+                    type_rep: type_rep.clone(),\n                     variants: variants,\n                     discriminant_type_metadata: discriminant_type_metadata,\n                     containing_scope: containing_scope,\n@@ -1676,7 +1677,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                  member_description_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          *variants.get(nndiscr as uint),\n+                                          &**variants.get(nndiscr as uint),\n                                           None,\n                                           containing_scope,\n                                           file_metadata,\n@@ -2381,7 +2382,7 @@ fn populate_scope_map(cx: &CrateContext,\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n-    let def_map = cx.tcx.def_map;\n+    let def_map = &cx.tcx.def_map;\n \n     struct ScopeStackEntry {\n         scope_metadata: DIScope,\n@@ -2494,7 +2495,7 @@ fn populate_scope_map(cx: &CrateContext,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n-        let def_map = cx.tcx.def_map;\n+        let def_map = &cx.tcx.def_map;\n \n         // Unfortunately, we cannot just use pat_util::pat_bindings() or ast_util::walk_pat() here\n         // because we have to visit *all* nodes in order to put them into the scope map. The above\n@@ -2830,14 +2831,14 @@ fn populate_scope_map(cx: &CrateContext,\n struct NamespaceTreeNode {\n     name: ast::Name,\n     scope: DIScope,\n-    parent: Option<@NamespaceTreeNode>,\n+    parent: Option<Weak<NamespaceTreeNode>>,\n }\n \n impl NamespaceTreeNode {\n     fn mangled_name_of_contained_item(&self, item_name: &str) -> ~str {\n         fn fill_nested(node: &NamespaceTreeNode, output: &mut StrBuf) {\n             match node.parent {\n-                Some(parent) => fill_nested(parent, output),\n+                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n@@ -2854,7 +2855,7 @@ impl NamespaceTreeNode {\n     }\n }\n \n-fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNode {\n+fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n     ty::with_path(cx.tcx(), def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n@@ -2866,7 +2867,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n         let mut path = krate.move_iter().chain(path).peekable();\n \n         let mut current_key = Vec::new();\n-        let mut parent_node: Option<@NamespaceTreeNode> = None;\n+        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n \n         // Create/Lookup namespace for each element of the path.\n         loop {\n@@ -2890,7 +2891,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n                 None => {\n                     // create and insert\n                     let parent_scope = match parent_node {\n-                        Some(node) => node.scope,\n+                        Some(ref node) => node.scope,\n                         None => ptr::null()\n                     };\n                     let namespace_name = token::get_name(name);\n@@ -2907,14 +2908,14 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n                         }\n                     });\n \n-                    let node = @NamespaceTreeNode {\n+                    let node = Rc::new(NamespaceTreeNode {\n                         name: name,\n                         scope: scope,\n-                        parent: parent_node,\n-                    };\n+                        parent: parent_node.map(|parent| parent.downgrade()),\n+                    });\n \n                     debug_context(cx).namespace_map.borrow_mut()\n-                                     .insert(current_key.clone(), node);\n+                                     .insert(current_key.clone(), node.clone());\n \n                     node\n                 }"}, {"sha": "3c1dfedcac6162bdd91cd8f9f46790294ae24ba9", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -118,7 +118,7 @@ pub fn trans_into<'a>(bcx: &'a Block<'a>,\n \n     bcx.fcx.push_ast_cleanup_scope(expr.id);\n \n-    let kind = ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr);\n+    let kind = ty::expr_kind(bcx.tcx(), expr);\n     bcx = match kind {\n         ty::LvalueExpr | ty::RvalueDatumExpr => {\n             trans_unadjusted(bcx, expr).store_to_dest(dest, expr.id)\n@@ -175,7 +175,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     };\n     debug!(\"unadjusted datum for expr {}: {}\",\n            expr.id, datum.to_str(bcx.ccx()));\n-    match *adjustment {\n+    match adjustment {\n         AutoAddEnv(..) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n@@ -205,8 +205,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             };\n         }\n         AutoObject(..) => {\n-            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr,\n-                                                   &*bcx.ccx().maps.method_map.borrow());\n+            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr);\n             let scratch = rvalue_scratch_datum(bcx, adjusted_ty, \"__adjust\");\n             bcx = meth::trans_trait_cast(\n                 bcx, datum, expr.id, SaveIn(scratch.val));\n@@ -323,7 +322,7 @@ fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n-    return match ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr) {\n+    return match ty::expr_kind(bcx.tcx(), expr) {\n         ty::LvalueExpr | ty::RvalueDatumExpr => {\n             let datum = unpack_datum!(bcx, {\n                 trans_datum_unadjusted(bcx, expr)\n@@ -444,7 +443,7 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n             let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n             let d = base_datum.get_element(\n                 field_tys[ix].mt.ty,\n-                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, ix));\n+                |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n         })\n }\n@@ -680,7 +679,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n             let numbered_fields: Vec<(uint, @ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n-            trans_adt(bcx, repr, 0, numbered_fields.as_slice(), None, dest)\n+            trans_adt(bcx, &*repr, 0, numbered_fields.as_slice(), None, dest)\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n@@ -798,7 +797,7 @@ fn trans_def_dps_unadjusted<'a>(\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_start_init(bcx, repr, lldest,\n+                adt::trans_start_init(bcx, &*repr, lldest,\n                                       variant_info.disr_val);\n                 return bcx;\n             }\n@@ -808,7 +807,7 @@ fn trans_def_dps_unadjusted<'a>(\n             match ty::get(ty).sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n-                    adt::trans_start_init(bcx, repr, lldest, 0);\n+                    adt::trans_start_init(bcx, &*repr, lldest, 0);\n                 }\n                 _ => {}\n             }\n@@ -1005,7 +1004,7 @@ fn trans_rec_or_struct<'a>(\n         };\n \n         let repr = adt::represent_type(bcx.ccx(), ty);\n-        trans_adt(bcx, repr, discr, numbered_fields.as_slice(), optbase, dest)\n+        trans_adt(bcx, &*repr, discr, numbered_fields.as_slice(), optbase, dest)\n     })\n }\n \n@@ -1118,7 +1117,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !ccx.maps.method_map.borrow().contains_key(&method_call));\n+        !ccx.tcx.method_map.borrow().contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1240,8 +1239,8 @@ fn trans_gc<'a>(mut bcx: &'a Block<'a>,\n         SaveIn(addr) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let repr = adt::represent_type(bcx.ccx(), expr_ty);\n-            adt::trans_start_init(bcx, repr, addr, 0);\n-            let field_dest = adt::trans_field_ptr(bcx, repr, addr, 0, 0);\n+            adt::trans_start_init(bcx, &*repr, addr, 0);\n+            let field_dest = adt::trans_field_ptr(bcx, &*repr, addr, 0, 0);\n             contents_datum.store_to(bcx, field_dest)\n         }\n     }\n@@ -1403,7 +1402,7 @@ fn trans_binary<'a>(bcx: &'a Block<'a>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.maps.method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n     match op {\n         ast::BiAnd => {\n@@ -1443,7 +1442,7 @@ fn trans_overloaded_op<'a, 'b>(\n                        rhs: Option<(Datum<Expr>, ast::NodeId)>,\n                        dest: Option<Dest>)\n                        -> Result<'a> {\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get(&method_call).ty;\n+    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n                              monomorphize_type(bcx, method_ty),\n@@ -1581,7 +1580,7 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n                 bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n             let llexpr_ptr = datum.to_llref();\n             let lldiscrim_a =\n-                adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64(ccx)));\n+                adt::trans_get_discr(bcx, &*repr, llexpr_ptr, Some(Type::i64(ccx)));\n             match k_out {\n                 cast_integral => int_cast(bcx, ll_t_out,\n                                           val_ty(lldiscrim_a),\n@@ -1614,7 +1613,7 @@ fn trans_assign_op<'a>(\n     debug!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!(!bcx.ccx().maps.method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!bcx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -1692,7 +1691,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n         expr_id: expr.id,\n         autoderef: derefs as u32\n     };\n-    let method_ty = ccx.maps.method_map.borrow()\n+    let method_ty = ccx.tcx.method_map.borrow()\n                        .find(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {"}, {"sha": "8488261db9c5cf376883ce97ed871e639469034f", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -145,39 +145,34 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     glue\n }\n \n-pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: @tydesc_info) {\n+pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: &tydesc_info) -> ValueRef {\n     let _icx = push_ctxt(\"lazily_emit_visit_glue\");\n \n     let llfnty = Type::glue_fn(ccx, type_of(ccx, ti.ty).ptr_to());\n \n     match ti.visit_glue.get() {\n-        Some(_) => (),\n+        Some(visit_glue) => visit_glue,\n         None => {\n             debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n             debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n+            glue_fn\n         }\n     }\n }\n \n // See [Note-arg-mode]\n pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n-                       static_ti: Option<@tydesc_info>) {\n+                       static_ti: Option<&tydesc_info>) {\n     let _icx = push_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n     if bcx.unreachable.get() && !ccx.sess().no_landing_pads() { return; }\n \n-    let static_glue_fn = match static_ti {\n-        None => None,\n-        Some(sti) => {\n-            lazily_emit_visit_glue(ccx, sti);\n-            sti.visit_glue.get()\n-        }\n-    };\n+    let static_glue_fn = static_ti.map(|sti| lazily_emit_visit_glue(ccx, sti));\n \n     // When static type info is available, avoid casting to a generic pointer.\n     let llrawptr = if static_glue_fn.is_none() {\n@@ -224,7 +219,7 @@ fn trans_struct_drop_flag<'a>(bcx: &'a Block<'a>,\n                               substs: &ty::substs)\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n+    let drop_flag = adt::trans_drop_flag_ptr(bcx, &*repr, v0);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n@@ -265,7 +260,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     // this scope.\n     let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n     for (i, fld) in field_tys.iter().enumerate() {\n-        let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n+        let llfld_a = adt::trans_field_ptr(bcx, &*repr, v0, 0, i);\n         bcx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n                                   llfld_a,\n                                   fld.mt.ty);\n@@ -404,7 +399,7 @@ fn incr_refcnt_of_boxed<'a>(bcx: &'a Block<'a>,\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n+pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n     assert!(!ccx.finished_tydescs.get());\n@@ -430,16 +425,15 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx(), t));\n     let ty_name = C_str_slice(ccx, ty_name);\n \n-    let inf = @tydesc_info {\n+    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx(), t));\n+    tydesc_info {\n         ty: t,\n         tydesc: gvar,\n         size: llsize,\n         align: llalign,\n         name: ty_name,\n         visit_glue: Cell::new(None),\n-    };\n-    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx(), t));\n-    return inf;\n+    }\n }\n \n fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n@@ -466,7 +460,7 @@ fn make_generic_glue(ccx: &CrateContext,\n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, llfn, -1, false, ty::mk_nil(), None, None, &arena);\n \n-    init_function(&fcx, false, ty::mk_nil(), None);\n+    init_function(&fcx, false, ty::mk_nil());\n \n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created.set(ccx.stats.n_glues_created.get() + 1u);\n@@ -491,9 +485,7 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs.set(true);\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    for (_, &val) in ccx.tydescs.borrow().iter() {\n-        let ti = val;\n-\n+    for (_, ti) in ccx.tydescs.borrow().iter() {\n         // Each of the glue functions needs to be cast to a generic type\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when"}, {"sha": "3a0083ba5c636f2b95858eb3615b244a43f2deed", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -85,7 +85,7 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n pub fn trans_intrinsic(ccx: &CrateContext,\n                        decl: ValueRef,\n                        item: &ast::ForeignItem,\n-                       substs: @param_substs,\n+                       substs: &param_substs,\n                        ref_id: Option<ast::NodeId>) {\n     debug!(\"trans_intrinsic(item.ident={})\", token::get_ident(item.ident));\n \n@@ -194,8 +194,8 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, decl, item.id, false, output_type,\n-                          Some(substs), Some(item.span), &arena);\n-    init_function(&fcx, true, output_type, Some(substs));\n+                          Some(&*substs), Some(item.span), &arena);\n+    init_function(&fcx, true, output_type);\n \n     set_always_inline(fcx.llfn);\n \n@@ -328,7 +328,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         \"get_tydesc\" => {\n             let tp_ty = *substs.tys.get(0);\n             let static_ti = get_tydesc(ccx, tp_ty);\n-            glue::lazily_emit_visit_glue(ccx, static_ti);\n+            glue::lazily_emit_visit_glue(ccx, &*static_ti);\n \n             // FIXME (#3730): ideally this shouldn't need a cast,\n             // but there's a circularity between translating rust types to llvm"}, {"sha": "d122edb7678576e1cecf41257ca1d93cf5c71cf1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 70, "deletions": 89, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -83,7 +83,7 @@ pub fn trans_method_callee<'a>(\n                            -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    let (origin, method_ty) = match bcx.ccx().maps.method_map\n+    let (origin, method_ty) = match bcx.tcx().method_map\n                                        .borrow().find(&method_call) {\n         Some(method) => {\n             debug!(\"trans_method_callee({:?}, method={})\",\n@@ -193,21 +193,21 @@ pub fn trans_static_method_callee(bcx: &Block,\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n     let vtable_key = MethodCall::expr(expr_id);\n-    let vtbls = ccx.maps.vtable_map.borrow().get_copy(&vtable_key);\n-    let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n+    let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, ccx.tcx.vtable_map.borrow()\n+                                                       .get(&vtable_key).as_slice());\n \n-    match vtbls.get(bound_index).get(0) {\n-        &typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n+    match vtbls.move_iter().nth(bound_index).unwrap().move_iter().nth(0).unwrap() {\n+        typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, ExprId(expr_id),\n-                    rcvr_substs.as_slice(), rcvr_origins);\n+                    rcvr_substs, rcvr_origins);\n \n             let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n-                                                 callee_substs.as_slice(),\n+                                                 callee_substs,\n                                                  Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, expr_id);\n@@ -221,22 +221,22 @@ pub fn trans_static_method_callee(bcx: &Block,\n     }\n }\n \n-pub fn method_with_name(ccx: &CrateContext,\n-                        impl_id: ast::DefId,\n-                        name: ast::Name) -> ast::DefId {\n+fn method_with_name(ccx: &CrateContext,\n+                    impl_id: ast::DefId,\n+                    name: ast::Name) -> ast::DefId {\n     match ccx.impl_method_cache.borrow().find_copy(&(impl_id, name)) {\n         Some(m) => return m,\n         None => {}\n     }\n \n-    let imp = ccx.tcx.impls.borrow();\n-    let imp = imp.find(&impl_id)\n-                 .expect(\"could not find impl while translating\");\n-    let meth = imp.methods.iter().find(|m| m.ident.name == name)\n-                  .expect(\"could not find method while translating\");\n+    let methods = ccx.tcx.impl_methods.borrow();\n+    let methods = methods.find(&impl_id)\n+                         .expect(\"could not find impl while translating\");\n+    let meth_did = methods.iter().find(|&did| ty::method(&ccx.tcx, *did).ident.name == name)\n+                                 .expect(\"could not find method while translating\");\n \n-    ccx.impl_method_cache.borrow_mut().insert((impl_id, name), meth.def_id);\n-    meth.def_id\n+    ccx.impl_method_cache.borrow_mut().insert((impl_id, name), *meth_did);\n+    *meth_did\n }\n \n fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n@@ -247,7 +247,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n                                   -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtbl {\n-      typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n+      typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_method(ccx.tcx(), trait_id, n_method).ident;\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n@@ -257,13 +257,13 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n                   bcx, mth_id,  MethodCall(method_call),\n-                  rcvr_substs.as_slice(), rcvr_origins);\n+                  rcvr_substs, rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n                                                mth_id,\n                                                MethodCall(method_call),\n-                                               callee_substs.as_slice(),\n+                                               callee_substs,\n                                                Some(callee_origins));\n \n           Callee { bcx: bcx, data: Fn(llfn) }\n@@ -277,9 +277,9 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n fn combine_impl_and_methods_tps(bcx: &Block,\n                                 mth_did: ast::DefId,\n                                 node: ExprOrMethodCall,\n-                                rcvr_substs: &[ty::t],\n+                                rcvr_substs: Vec<ty::t>,\n                                 rcvr_origins: typeck::vtable_res)\n-                                -> (Vec<ty::t> , typeck::vtable_res) {\n+                                -> (Vec<ty::t>, typeck::vtable_res) {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -302,10 +302,13 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     let n_m_tps = method.generics.type_param_defs().len();\n     let node_substs = node_id_type_params(bcx, node);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n-    let ty_substs\n-        = Vec::from_slice(rcvr_substs).append(node_substs.tailn(node_substs.len() - n_m_tps));\n-    debug!(\"n_m_tps={:?}\", n_m_tps);\n     debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n+    let mut ty_substs = rcvr_substs;\n+    {\n+        let start = node_substs.len() - n_m_tps;\n+        ty_substs.extend(node_substs.move_iter().skip(start));\n+    }\n+    debug!(\"n_m_tps={:?}\", n_m_tps);\n     debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx()));\n \n \n@@ -315,14 +318,20 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n         ExprId(id) => MethodCall::expr(id),\n         MethodCall(method_call) => method_call\n     };\n-    let vtables = node_vtables(bcx, vtable_key);\n-    let r_m_origins = match vtables {\n-        Some(vt) => vt,\n-        None => @Vec::from_elem(node_substs.len(), @Vec::new())\n-    };\n-    let vtables\n-        = @Vec::from_slice(rcvr_origins.as_slice())\n-                           .append(r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n+    let mut vtables = rcvr_origins;\n+    match node_vtables(bcx, vtable_key) {\n+        Some(vt) => {\n+            let start = vt.len() - n_m_tps;\n+            vtables.extend(vt.move_iter().skip(start));\n+        }\n+        None => {\n+            vtables.extend(range(0, n_m_tps).map(\n+                |_| -> typeck::vtable_param_res {\n+                    Vec::new()\n+                }\n+            ));\n+        }\n+    }\n \n     (ty_substs, vtables)\n }\n@@ -418,83 +427,50 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     };\n }\n \n-pub fn vtable_id(ccx: &CrateContext,\n-                 origin: &typeck::vtable_origin)\n-              -> mono_id {\n-    match origin {\n-        &typeck::vtable_static(impl_id, ref substs, sub_vtables) => {\n-            let psubsts = param_substs {\n-                tys: (*substs).clone(),\n-                vtables: Some(sub_vtables),\n-                self_ty: None,\n-                self_vtables: None\n-            };\n-\n-            monomorphize::make_mono_id(\n-                ccx,\n-                impl_id,\n-                &psubsts)\n-        }\n-\n-        // can't this be checked at the callee?\n-        _ => fail!(\"vtable_id\")\n-    }\n-}\n-\n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(bcx: &Block,\n-                  self_ty: ty::t,\n-                  origins: typeck::vtable_param_res)\n-                  -> ValueRef {\n+fn get_vtable(bcx: &Block,\n+              self_ty: ty::t,\n+              origins: typeck::vtable_param_res)\n+              -> ValueRef {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n     // Check the cache.\n-    let hash_id = (self_ty, vtable_id(ccx, origins.get(0)));\n+    let hash_id = (self_ty, monomorphize::make_vtable_id(ccx, origins.get(0)));\n     match ccx.vtables.borrow().find(&hash_id) {\n         Some(&val) => { return val }\n         None => { }\n     }\n \n     // Not in the cache. Actually build it.\n-    let mut methods = Vec::new();\n-    for origin in origins.iter() {\n-        match *origin {\n-            typeck::vtable_static(id, ref substs, sub_vtables) => {\n-                let vtable_methods = emit_vtable_methods(bcx,\n-                                                         id,\n-                                                         substs.as_slice(),\n-                                                         sub_vtables);\n-                for vtable_method in vtable_methods.move_iter() {\n-                    methods.push(vtable_method)\n-                }\n+    let methods = origins.move_iter().flat_map(|origin| {\n+        match origin {\n+            typeck::vtable_static(id, substs, sub_vtables) => {\n+                emit_vtable_methods(bcx, id, substs, sub_vtables).move_iter()\n             }\n             _ => ccx.sess().bug(\"get_vtable: expected a static origin\"),\n         }\n-    }\n+    });\n \n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n-    let vtable = make_vtable(ccx, drop_glue, methods.as_slice());\n+    let vtable = make_vtable(ccx, drop_glue, methods);\n \n     ccx.vtables.borrow_mut().insert(hash_id, vtable);\n-    return vtable;\n+    vtable\n }\n \n /// Helper function to declare and initialize the vtable.\n-pub fn make_vtable(ccx: &CrateContext,\n-                   drop_glue: ValueRef,\n-                   ptrs: &[ValueRef])\n-                   -> ValueRef {\n-    unsafe {\n-        let _icx = push_ctxt(\"meth::make_vtable\");\n+pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n+                                          drop_glue: ValueRef,\n+                                          ptrs: I)\n+                                          -> ValueRef {\n+    let _icx = push_ctxt(\"meth::make_vtable\");\n \n-        let mut components = vec!(drop_glue);\n-        for &ptr in ptrs.iter() {\n-            components.push(ptr)\n-        }\n+    let components: Vec<_> = Some(drop_glue).move_iter().chain(ptrs).collect();\n \n+    unsafe {\n         let tbl = C_struct(ccx, components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n@@ -509,7 +485,7 @@ pub fn make_vtable(ccx: &CrateContext,\n \n fn emit_vtable_methods(bcx: &Block,\n                        impl_id: ast::DefId,\n-                       substs: &[ty::t],\n+                       substs: Vec<ty::t>,\n                        vtables: typeck::vtable_res)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n@@ -539,7 +515,8 @@ fn emit_vtable_methods(bcx: &Block,\n                    token::get_ident(ident));\n             C_null(Type::nil(ccx).ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0), substs, Some(vtables))\n+            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0),\n+                                      substs.clone(), Some(vtables.clone()))\n         }\n     }).collect()\n }\n@@ -576,8 +553,12 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let res = *ccx.maps.vtable_map.borrow().get(&MethodCall::expr(id));\n-    let origins = *resolve_vtables_in_fn_ctxt(bcx.fcx, res).get(0);\n+    let origins = {\n+        let vtable_map = ccx.tcx.vtable_map.borrow();\n+        resolve_param_vtables_under_param_substs(ccx.tcx(),\n+            bcx.fcx.param_substs,\n+            vtable_map.get(&MethodCall::expr(id)).get(0).as_slice())\n+    };\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());"}, {"sha": "aa6e2dafd835ee9373d29c51b11f6baea8d797fb", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 91, "deletions": 61, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -16,7 +16,6 @@ use middle::trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n use middle::trans::base;\n use middle::trans::common::*;\n-use middle::trans::meth;\n use middle::trans::intrinsic;\n use middle::ty;\n use middle::typeck;\n@@ -26,7 +25,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n-use std::hash::sip;\n+use std::hash::{sip, Hash};\n \n pub fn monomorphic_fn(ccx: &CrateContext,\n                       fn_id: ast::DefId,\n@@ -47,26 +46,51 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n            self_vtables.repr(ccx.tcx()),\n            ref_id);\n \n-    assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n+    assert!(real_substs.tps.iter().all(|t| {\n+        !ty::type_needs_infer(*t) && !ty::type_has_params(*t)\n+    }));\n+\n     let _icx = push_ctxt(\"monomorphic_fn\");\n-    let mut must_cast = false;\n \n-    let psubsts = @param_substs {\n+    let substs_iter = real_substs.self_ty.iter().chain(real_substs.tps.iter());\n+    let param_ids: Vec<MonoParamId> = match vtables {\n+        Some(ref vts) => {\n+            debug!(\"make_mono_id vtables={} psubsts={}\",\n+                   vts.repr(ccx.tcx()), real_substs.tps.repr(ccx.tcx()));\n+            let vts_iter = self_vtables.iter().chain(vts.iter());\n+            vts_iter.zip(substs_iter).map(|(vtable, subst)| MonoParamId {\n+                subst: *subst,\n+                // Do we really need the vtables to be hashed? Isn't the type enough?\n+                vtables: vtable.iter().map(|vt| make_vtable_id(ccx, vt)).collect()\n+            }).collect()\n+        }\n+        None => substs_iter.map(|subst| MonoParamId {\n+            subst: *subst,\n+            vtables: Vec::new()\n+        }).collect()\n+    };\n+\n+    let hash_id = MonoId {\n+        def: fn_id,\n+        params: param_ids\n+    };\n+\n+    match ccx.monomorphized.borrow().find(&hash_id) {\n+        Some(&val) => {\n+            debug!(\"leaving monomorphic fn {}\",\n+            ty::item_path_str(ccx.tcx(), fn_id));\n+            return (val, false);\n+        }\n+        None => ()\n+    }\n+\n+    let psubsts = param_substs {\n         tys: real_substs.tps.clone(),\n         vtables: vtables,\n         self_ty: real_substs.self_ty.clone(),\n         self_vtables: self_vtables\n     };\n \n-    for s in real_substs.tps.iter() { assert!(!ty::type_has_params(*s)); }\n-    for s in psubsts.tys.iter() { assert!(!ty::type_has_params(*s)); }\n-\n-    let hash_id = make_mono_id(ccx, fn_id, &*psubsts);\n-    if hash_id.params.iter().any(\n-                |p| match *p { mono_precise(_, _) => false, _ => true }) {\n-        must_cast = true;\n-    }\n-\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             psubsts={}, \\\n@@ -75,15 +99,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n            psubsts.repr(ccx.tcx()),\n            hash_id);\n \n-    match ccx.monomorphized.borrow().find(&hash_id) {\n-        Some(&val) => {\n-            debug!(\"leaving monomorphic fn {}\",\n-            ty::item_path_str(ccx.tcx(), fn_id));\n-            return (val, must_cast);\n-        }\n-        None => ()\n-    }\n-\n     let tpt = ty::lookup_item_type(ccx.tcx(), fn_id);\n     let llitem_ty = tpt.ty;\n \n@@ -122,8 +137,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst_tps(ccx.tcx(), psubsts.tys.as_slice(),\n-                              psubsts.self_ty, llitem_ty),\n+        None => ty::subst_tps(ccx.tcx(), real_substs.tps.as_slice(),\n+                              real_substs.self_ty, llitem_ty),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n             // that the \"internal\" and \"external\" type of them differ.\n@@ -139,9 +154,9 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             // stick a substitution for the self type in.\n             // This is a bit unfortunate.\n \n-            let idx = psubsts.tys.len() - num_method_ty_params;\n-            let substs = psubsts.tys.slice(0, idx) +\n-                &[psubsts.self_ty.unwrap()] + psubsts.tys.tailn(idx);\n+            let idx = real_substs.tps.len() - num_method_ty_params;\n+            let substs = real_substs.tps.slice(0, idx) +\n+            &[real_substs.self_ty.unwrap()] + real_substs.tps.tailn(idx);\n             debug!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx()));\n \n@@ -178,16 +193,22 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     }\n \n     let s = ccx.tcx.map.with_path(fn_id.node, |path| {\n-        exported_name(path, format!(\"h{}\", sip::hash(&(hash_id, mono_ty))),\n+        let mut state = sip::SipState::new();\n+        hash_id.hash(&mut state);\n+        mono_ty.hash(&mut state);\n+\n+        exported_name(path, format!(\"h{}\", state.result()),\n                       ccx.link_meta.crateid.version_or_default())\n     });\n     debug!(\"monomorphize_fn mangled to {}\", s);\n \n+    // This shouldn't need to option dance.\n+    let mut hash_id = Some(hash_id);\n     let mk_lldecl = || {\n         let lldecl = decl_internal_rust_fn(ccx, false,\n                                            f.sig.inputs.as_slice(),\n                                            f.sig.output, s);\n-        ccx.monomorphized.borrow_mut().insert(hash_id, lldecl);\n+        ccx.monomorphized.borrow_mut().insert(hash_id.take_unwrap(), lldecl);\n         lldecl\n     };\n \n@@ -200,7 +221,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n               } => {\n                   let d = mk_lldecl();\n                   set_llvm_fn_attrs(i.attrs.as_slice(), d);\n-                  trans_fn(ccx, decl, body, d, Some(psubsts), fn_id.node, []);\n+                  trans_fn(ccx, decl, body, d, Some(&psubsts), fn_id.node, []);\n                   d\n               }\n               _ => {\n@@ -214,15 +235,15 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                 Some(decl) => decl,\n                 None => {\n                     let d = mk_lldecl();\n-                    intrinsic::trans_intrinsic(ccx, d, i, psubsts, ref_id);\n+                    intrinsic::trans_intrinsic(ccx, d, i, &psubsts, ref_id);\n                     d\n                 }\n             }\n         }\n         ast_map::NodeVariant(v) => {\n             let parent = ccx.tcx.map.get_parent(fn_id.node);\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n-            let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n+            let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl();\n             set_inline_hint(d);\n             match v.node.kind {\n@@ -232,7 +253,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                                        v,\n                                        args.as_slice(),\n                                        this_tv.disr_val,\n-                                       Some(psubsts),\n+                                       Some(&psubsts),\n                                        d);\n                 }\n                 ast::StructVariantKind(_) =>\n@@ -243,15 +264,15 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n+            trans_fn(ccx, mth.decl, mth.body, d, Some(&psubsts), mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n+                    trans_fn(ccx, mth.decl, mth.body, d, Some(&psubsts), mth.id, []);\n                     d\n                 }\n                 _ => {\n@@ -267,7 +288,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                                      struct_def.fields.as_slice(),\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n-                                     Some(psubsts),\n+                                     Some(&psubsts),\n                                      d);\n             d\n         }\n@@ -286,32 +307,41 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     ccx.monomorphizing.borrow_mut().insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n-    (lldecl, must_cast)\n+    (lldecl, false)\n }\n \n-pub fn make_mono_id(ccx: &CrateContext,\n-                    item: ast::DefId,\n-                    substs: &param_substs) -> mono_id {\n-    // FIXME (possibly #5801): Need a lot of type hints to get\n-    // .collect() to work.\n-    let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n-    let precise_param_ids: Vec<(ty::t, Option<@Vec<mono_id> >)> = match substs.vtables {\n-      Some(vts) => {\n-        debug!(\"make_mono_id vtables={} substs={}\",\n-               vts.repr(ccx.tcx()), substs.tys.repr(ccx.tcx()));\n-        let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n-        vts_iter.zip(substs_iter).map(|(vtable, subst)| {\n-            let v = vtable.iter().map(|vt| meth::vtable_id(ccx, vt)).collect::<Vec<_>>();\n-            (*subst, if !v.is_empty() { Some(@v) } else { None })\n-        }).collect()\n-      }\n-      None => substs_iter.map(|subst| (*subst, None::<@Vec<mono_id> >)).collect()\n-    };\n+// Used to identify cached monomorphized functions and vtables\n+#[deriving(Eq, TotalEq, Hash)]\n+pub struct MonoParamId {\n+    pub subst: ty::t,\n+    // Do we really need the vtables to be hashed? Isn't the type enough?\n+    pub vtables: Vec<MonoId>\n+}\n \n+#[deriving(Eq, TotalEq, Hash)]\n+pub struct MonoId {\n+    pub def: ast::DefId,\n+    pub params: Vec<MonoParamId>\n+}\n \n-    let param_ids = precise_param_ids.iter().map(|x| {\n-        let (a, b) = *x;\n-        mono_precise(a, b)\n-    }).collect();\n-    @mono_id_ {def: item, params: param_ids}\n+pub fn make_vtable_id(ccx: &CrateContext,\n+                      origin: &typeck::vtable_origin)\n+                      -> MonoId {\n+    match origin {\n+        &typeck::vtable_static(impl_id, ref substs, ref sub_vtables) => {\n+            MonoId {\n+                def: impl_id,\n+                params: sub_vtables.iter().zip(substs.iter()).map(|(vtable, subst)| {\n+                    MonoParamId {\n+                        subst: *subst,\n+                        // Do we really need the vtables to be hashed? Isn't the type enough?\n+                        vtables: vtable.iter().map(|vt| make_vtable_id(ccx, vt)).collect()\n+                    }\n+                }).collect()\n+            }\n+        }\n+\n+        // can't this be checked at the callee?\n+        _ => fail!(\"make_vtable_id needs vtable_static\")\n+    }\n }"}, {"sha": "a1752862715d0189c72bb00a421a1c028029446f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -25,6 +25,7 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use std::rc::Rc;\n use arena::TypedArena;\n use libc::c_uint;\n use syntax::ast::DefId;\n@@ -33,15 +34,15 @@ use syntax::ast_map;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n \n-pub struct Reflector<'a> {\n+pub struct Reflector<'a, 'b> {\n     visitor_val: ValueRef,\n-    visitor_methods: @Vec<@ty::Method> ,\n-    final_bcx: &'a Block<'a>,\n+    visitor_methods: &'a [Rc<ty::Method>],\n+    final_bcx: &'b Block<'b>,\n     tydesc_ty: Type,\n-    bcx: &'a Block<'a>\n+    bcx: &'b Block<'b>\n }\n \n-impl<'a> Reflector<'a> {\n+impl<'a, 'b> Reflector<'a, 'b> {\n     pub fn c_uint(&mut self, u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n     }\n@@ -75,7 +76,7 @@ impl<'a> Reflector<'a> {\n     pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n-        glue::lazily_emit_visit_glue(bcx.ccx(), static_ti);\n+        glue::lazily_emit_visit_glue(bcx.ccx(), &*static_ti);\n         PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n     }\n \n@@ -92,7 +93,7 @@ impl<'a> Reflector<'a> {\n                 format!(\"couldn't find visit method for {}\", ty_name));\n         let mth_ty =\n             ty::mk_bare_fn(tcx,\n-                           self.visitor_methods.get(mth_idx).fty.clone());\n+                           self.visitor_methods[mth_idx].fty.clone());\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -307,7 +308,7 @@ impl<'a> Reflector<'a> {\n                 let arena = TypedArena::new();\n                 let fcx = new_fn_ctxt(ccx, llfdecl, -1, false,\n                                       ty::mk_u64(), None, None, &arena);\n-                init_function(&fcx, false, ty::mk_u64(), None);\n+                init_function(&fcx, false, ty::mk_u64());\n \n                 let arg = unsafe {\n                     //\n@@ -319,7 +320,7 @@ impl<'a> Reflector<'a> {\n                 };\n                 let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64(ccx)));\n+                let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());\n                 match fcx.llreturn.get() {\n                     Some(llreturn) => Br(bcx, llreturn),\n@@ -344,7 +345,7 @@ impl<'a> Reflector<'a> {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n-                            let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n+                            let ptr = adt::trans_field_ptr(bcx, &*repr, null, v.disr_val, j);\n                             let offset = p2i(ccx, ptr);\n                             let field_args = [this.c_uint(j),\n                                                offset,\n@@ -401,9 +402,10 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n     let final = fcx.new_temp_block(\"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n+    let visitor_methods = ty::trait_methods(bcx.tcx(), visitor_trait_id);\n     let mut r = Reflector {\n         visitor_val: visitor_val,\n-        visitor_methods: ty::trait_methods(bcx.tcx(), visitor_trait_id),\n+        visitor_methods: visitor_methods.as_slice(),\n         final_bcx: final,\n         tydesc_ty: tydesc_ty,\n         bcx: bcx"}, {"sha": "0a539d5e6c6ba65b3c7afe38aa0930326753075c", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -142,7 +142,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_tup(..) | ty::ty_enum(..) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, repr)\n+            adt::sizing_type_of(cx, &*repr)\n         }\n \n         ty::ty_struct(..) => {\n@@ -152,7 +152,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n-                adt::sizing_type_of(cx, repr)\n+                adt::sizing_type_of(cx, &*repr)\n             }\n         }\n \n@@ -213,7 +213,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         // of the enum's variants refers to the enum itself.\n         let repr = adt::represent_type(cx, t);\n         let name = llvm_type_name(cx, an_enum, did, substs.tps.as_slice());\n-        adt::incomplete_type_of(cx, repr, name)\n+        adt::incomplete_type_of(cx, &*repr, name)\n       }\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n@@ -259,7 +259,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_trait(..) => Type::opaque_trait(cx),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n-          adt::type_of(cx, repr)\n+          adt::type_of(cx, &*repr)\n       }\n       ty::ty_struct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx(), t) {\n@@ -275,7 +275,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                                         a_struct,\n                                         did,\n                                         substs.tps.as_slice());\n-              adt::incomplete_type_of(cx, repr, name)\n+              adt::incomplete_type_of(cx, &*repr, name)\n           }\n       }\n \n@@ -297,7 +297,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     match ty::get(t).sty {\n         ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::finish_type_of(cx, repr, &mut llty);\n+            adt::finish_type_of(cx, &*repr, &mut llty);\n         }\n         _ => ()\n     }"}, {"sha": "8f114827bfd27223099eb18fcb41bd2d6a1bd9ab", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -34,7 +34,7 @@ pub fn root_and_write_guard<'a, K:KindOps>(datum: &Datum<K>,\n     //\n     // (Note: root'd values are always boxes)\n     let ccx = bcx.ccx();\n-    match ccx.maps.root_map.borrow().find(&key) {\n+    match ccx.maps.root_map.find(&key) {\n         None => bcx,\n         Some(&root_info) => root(datum, bcx, span, key, root_info)\n     }"}, {"sha": "9a3bdcc1e15e38388efa7c2c96cd09426ddfda6f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 193, "deletions": 244, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -22,7 +22,7 @@ use middle::resolve_lifetime;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n-use middle::typeck::{MethodCall, MethodCallee, MethodMap};\n+use middle::typeck::MethodCall;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n use middle;\n@@ -38,9 +38,11 @@ use std::cmp;\n use std::fmt::Show;\n use std::fmt;\n use std::hash::{Hash, sip};\n+use std::iter::AdditiveIterator;\n use std::ops;\n use std::rc::Rc;\n use collections::{HashMap, HashSet};\n+use syntax::abi;\n use syntax::ast::*;\n use syntax::ast_util::{is_local, lit_is_str};\n use syntax::ast_util;\n@@ -51,7 +53,7 @@ use syntax::parse::token;\n use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::abi;\n+use syntax::util::small_vector::SmallVector;\n use collections::enum_set::{EnumSet, CLike};\n \n pub type Disr = u64;\n@@ -116,12 +118,6 @@ impl Method {\n     }\n }\n \n-pub struct Impl {\n-    pub did: DefId,\n-    pub ident: Ident,\n-    pub methods: Vec<@Method>,\n-}\n-\n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct mt {\n     pub ty: t,\n@@ -212,6 +208,7 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n+#[deriving(Clone)]\n pub enum AutoAdjustment {\n     AutoAddEnv(ty::TraitStore),\n     AutoDerefRef(AutoDerefRef),\n@@ -221,13 +218,13 @@ pub enum AutoAdjustment {\n                ty::substs /* Trait substitutions */)\n }\n \n-#[deriving(Decodable, Encodable)]\n+#[deriving(Clone, Decodable, Encodable)]\n pub struct AutoDerefRef {\n     pub autoderefs: uint,\n     pub autoref: Option<AutoRef>\n }\n \n-#[deriving(Decodable, Encodable, Eq, Show)]\n+#[deriving(Clone, Decodable, Encodable, Eq, Show)]\n pub enum AutoRef {\n     /// Convert from T to &T\n     AutoPtr(Region, ast::Mutability),\n@@ -272,18 +269,18 @@ pub struct ctxt {\n     pub node_type_substs: RefCell<NodeMap<Vec<t>>>,\n \n     // Maps from a method to the method \"descriptor\"\n-    pub methods: RefCell<DefIdMap<@Method>>,\n+    pub methods: RefCell<DefIdMap<Rc<Method>>>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n-    pub trait_method_def_ids: RefCell<DefIdMap<@Vec<DefId> >>,\n+    pub trait_method_def_ids: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n \n     // A cache for the trait_methods() routine\n-    pub trait_methods_cache: RefCell<DefIdMap<@Vec<@Method> >>,\n+    pub trait_methods_cache: RefCell<DefIdMap<Rc<Vec<Rc<Method>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<@ty::TraitRef>>>,\n+    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef>>>>,\n \n-    pub trait_refs: RefCell<NodeMap<@TraitRef>>,\n-    pub trait_defs: RefCell<DefIdMap<@TraitDef>>,\n+    pub trait_refs: RefCell<NodeMap<Rc<TraitRef>>>,\n+    pub trait_defs: RefCell<DefIdMap<Rc<TraitDef>>>,\n \n     pub map: ast_map::Map,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n@@ -294,20 +291,20 @@ pub struct ctxt {\n     pub needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     pub tc_cache: RefCell<HashMap<uint, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n-    pub enum_var_cache: RefCell<DefIdMap<@Vec<@VariantInfo> >>,\n+    pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n-    pub adjustments: RefCell<NodeMap<@AutoAdjustment>>,\n+    pub adjustments: RefCell<NodeMap<AutoAdjustment>>,\n     pub normalized_cache: RefCell<HashMap<t, t>>,\n-    pub lang_items: @middle::lang_items::LanguageItems,\n+    pub lang_items: middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    pub supertraits: RefCell<DefIdMap<@Vec<@TraitRef> >>,\n+    pub supertraits: RefCell<DefIdMap<Rc<Vec<Rc<TraitRef>>>>>,\n     pub superstructs: RefCell<DefIdMap<Option<ast::DefId>>>,\n-    pub struct_fields: RefCell<DefIdMap<@Vec<field_ty>>>,\n+    pub struct_fields: RefCell<DefIdMap<Rc<Vec<field_ty>>>>,\n \n     // Maps from def-id of a type or region parameter to its\n     // (inferred) variance.\n-    pub item_variance_map: RefCell<DefIdMap<@ItemVariances>>,\n+    pub item_variance_map: RefCell<DefIdMap<Rc<ItemVariances>>>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n@@ -319,18 +316,18 @@ pub struct ctxt {\n     pub destructors: RefCell<DefIdSet>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    pub trait_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n+    pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n-    // Maps a def_id of a type to a list of its inherent impls.\n+    // Maps a DefId of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n+    pub inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n-    // Maps a def_id of an impl to an Impl structure.\n+    // Maps a DefId of an impl to a list of its methods.\n     // Note that this contains all of the impls that we know about,\n     // including ones in other crates. It's not clear that this is the best\n     // way to do it.\n-    pub impls: RefCell<DefIdMap<@Impl>>,\n+    pub impl_methods: RefCell<DefIdMap<Vec<ast::DefId>>>,\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n@@ -359,6 +356,9 @@ pub struct ctxt {\n     // and variants that are found.\n     pub extern_const_statics: RefCell<DefIdMap<Option<@ast::Expr>>>,\n     pub extern_const_variants: RefCell<DefIdMap<Option<@ast::Expr>>>,\n+\n+    pub method_map: typeck::MethodMap,\n+    pub vtable_map: typeck::vtable_map,\n }\n \n pub enum tbox_flag {\n@@ -816,7 +816,6 @@ pub enum type_err {\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n     terr_vstores_differ(terr_vstore_kind, expected_found<Vstore>),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n-    terr_in_field(@type_err, ast::Ident),\n     terr_sorts(expected_found<t>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n@@ -829,7 +828,8 @@ pub enum type_err {\n #[deriving(Eq, TotalEq, Hash)]\n pub struct ParamBounds {\n     pub builtin_bounds: BuiltinBounds,\n-    pub trait_bounds: Vec<@TraitRef> }\n+    pub trait_bounds: Vec<Rc<TraitRef>>\n+}\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n@@ -983,7 +983,7 @@ impl fmt::Show for IntVarValue {\n pub struct TypeParameterDef {\n     pub ident: ast::Ident,\n     pub def_id: ast::DefId,\n-    pub bounds: @ParamBounds,\n+    pub bounds: Rc<ParamBounds>,\n     pub default: Option<ty::t>\n }\n \n@@ -1038,7 +1038,7 @@ pub struct ParameterEnvironment {\n     pub free_substs: ty::substs,\n \n     /// Bound on the Self parameter\n-    pub self_param_bound: Option<@TraitRef>,\n+    pub self_param_bound: Option<Rc<TraitRef>>,\n \n     /// Bounds on each numbered type parameter\n     pub type_param_bounds: Vec<ParamBounds> ,\n@@ -1064,7 +1064,7 @@ pub struct ty_param_bounds_and_ty {\n pub struct TraitDef {\n     pub generics: Generics,\n     pub bounds: BuiltinBounds,\n-    pub trait_ref: @ty::TraitRef,\n+    pub trait_ref: Rc<ty::TraitRef>,\n }\n \n pub struct ty_param_substs_and_ty {\n@@ -1082,7 +1082,7 @@ pub fn mk_ctxt(s: Session,\n                map: ast_map::Map,\n                freevars: freevars::freevar_map,\n                region_maps: middle::region::RegionMaps,\n-               lang_items: @middle::lang_items::LanguageItems)\n+               lang_items: middle::lang_items::LanguageItems)\n             -> ctxt {\n     ctxt {\n         named_region_map: named_region_map,\n@@ -1122,7 +1122,7 @@ pub fn mk_ctxt(s: Session,\n         destructors: RefCell::new(DefIdSet::new()),\n         trait_impls: RefCell::new(DefIdMap::new()),\n         inherent_impls: RefCell::new(DefIdMap::new()),\n-        impls: RefCell::new(DefIdMap::new()),\n+        impl_methods: RefCell::new(DefIdMap::new()),\n         used_unsafe: RefCell::new(NodeSet::new()),\n         used_mut_nodes: RefCell::new(NodeSet::new()),\n         impl_vtables: RefCell::new(DefIdMap::new()),\n@@ -1131,6 +1131,8 @@ pub fn mk_ctxt(s: Session,\n         upvar_borrow_map: RefCell::new(HashMap::new()),\n         extern_const_statics: RefCell::new(DefIdMap::new()),\n         extern_const_variants: RefCell::new(DefIdMap::new()),\n+        method_map: RefCell::new(FnvHashMap::new()),\n+        vtable_map: RefCell::new(FnvHashMap::new()),\n     }\n }\n \n@@ -2174,7 +2176,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 // Self may be bounded if the associated trait has builtin kinds\n                 // for supertraits. If so we can use those bounds.\n                 let trait_def = lookup_trait_def(cx, def_id);\n-                let traits = [trait_def.trait_ref];\n+                let traits = [trait_def.trait_ref.clone()];\n                 kind_bounds_to_contents(cx, trait_def.bounds, traits)\n             }\n \n@@ -2271,7 +2273,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n     fn kind_bounds_to_contents(cx: &ctxt,\n                                bounds: BuiltinBounds,\n-                               traits: &[@TraitRef])\n+                               traits: &[Rc<TraitRef>])\n                                -> TypeContents {\n         let _i = indenter();\n         let mut tc = TC::All;\n@@ -2290,7 +2292,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         // those inherited from traits with builtin-kind-supertraits.\n         fn each_inherited_builtin_bound(cx: &ctxt,\n                                         bounds: BuiltinBounds,\n-                                        traits: &[@TraitRef],\n+                                        traits: &[Rc<TraitRef>],\n                                         f: |BuiltinBound|) {\n             for bound in bounds.iter() {\n                 f(bound);\n@@ -2656,12 +2658,12 @@ pub fn index(t: t) -> Option<mt> {\n     }\n }\n \n-pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> @ty::TraitRef {\n+pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n     match cx.trait_refs.borrow().find(&id) {\n-       Some(&t) => t,\n-       None => cx.sess.bug(\n-           format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-               cx.map.node_to_str(id)))\n+        Some(t) => t.clone(),\n+        None => cx.sess.bug(\n+            format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n+                cx.map.node_to_str(id)))\n     }\n }\n \n@@ -2791,10 +2793,7 @@ pub fn expr_ty_opt(cx: &ctxt, expr: &ast::Expr) -> Option<t> {\n     return node_id_to_type_opt(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: &ctxt,\n-                        expr: &ast::Expr,\n-                        method_map: &FnvHashMap<MethodCall, MethodCallee>)\n-                        -> t {\n+pub fn expr_ty_adjusted(cx: &ctxt, expr: &ast::Expr) -> t {\n     /*!\n      *\n      * Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -2808,11 +2807,9 @@ pub fn expr_ty_adjusted(cx: &ctxt,\n      * task at hand! -nmatsakis\n      */\n \n-    let unadjusted_ty = expr_ty(cx, expr);\n-    let adjustment = cx.adjustments.borrow().find_copy(&expr.id);\n-    adjust_ty(cx, expr.span, expr.id, unadjusted_ty, adjustment, |method_call| {\n-        method_map.find(&method_call).map(|method| method.ty)\n-    })\n+    adjust_ty(cx, expr.span, expr.id, expr_ty(cx, expr),\n+              cx.adjustments.borrow().find(&expr.id),\n+              |method_call| cx.method_map.borrow().find(&method_call).map(|method| method.ty))\n }\n \n pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n@@ -2857,8 +2854,8 @@ pub fn adjust_ty(cx: &ctxt,\n                  span: Span,\n                  expr_id: ast::NodeId,\n                  unadjusted_ty: ty::t,\n-                 adjustment: Option<@AutoAdjustment>,\n-                 method_type: |MethodCall| -> Option<ty::t>)\n+                 adjustment: Option<&AutoAdjustment>,\n+                 method_type: |typeck::MethodCall| -> Option<ty::t>)\n                  -> ty::t {\n     /*! See `expr_ty_adjusted` */\n \n@@ -2890,7 +2887,8 @@ pub fn adjust_ty(cx: &ctxt,\n \n                     if !ty::type_is_error(adjusted_ty) {\n                         for i in range(0, adj.autoderefs) {\n-                            match method_type(MethodCall::autoderef(expr_id, i as u32)) {\n+                            let method_call = typeck::MethodCall::autoderef(expr_id, i as u32);\n+                            match method_type(method_call) {\n                                 Some(method_ty) => {\n                                     adjusted_ty = ty_fn_ret(method_ty);\n                                 }\n@@ -3051,8 +3049,8 @@ pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n             let trait_type_param_defs =\n-                lookup_trait_def(tcx, trt_id).generics.type_param_defs();\n-            Rc::new(Vec::from_slice(trait_type_param_defs).append(\n+                Vec::from_slice(lookup_trait_def(tcx, trt_id).generics.type_param_defs());\n+            Rc::new(trait_type_param_defs.append(\n                         ty::trait_method(tcx, trt_id, n_mth).generics.type_param_defs()))\n         }\n     }\n@@ -3068,10 +3066,8 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> ast::Def {\n     }\n }\n \n-pub fn expr_is_lval(tcx: &ctxt,\n-                    method_map: MethodMap,\n-                    e: &ast::Expr) -> bool {\n-    match expr_kind(tcx, method_map, e) {\n+pub fn expr_is_lval(tcx: &ctxt, e: &ast::Expr) -> bool {\n+    match expr_kind(tcx, e) {\n         LvalueExpr => true,\n         RvalueDpsExpr | RvalueDatumExpr | RvalueStmtExpr => false\n     }\n@@ -3089,10 +3085,8 @@ pub enum ExprKind {\n     RvalueStmtExpr\n }\n \n-pub fn expr_kind(tcx: &ctxt,\n-                 method_map: MethodMap,\n-                 expr: &ast::Expr) -> ExprKind {\n-    if method_map.borrow().contains_key(&MethodCall::expr(expr.id)) {\n+pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n+    if tcx.method_map.borrow().contains_key(&typeck::MethodCall::expr(expr.id)) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are two exceptions:\n         return match expr.node {\n@@ -3236,7 +3230,7 @@ pub fn expr_kind(tcx: &ctxt,\n             }\n         }\n \n-        ast::ExprParen(e) => expr_kind(tcx, method_map, e),\n+        ast::ExprParen(e) => expr_kind(tcx, e),\n \n         ast::ExprMac(..) => {\n             tcx.sess.span_bug(\n@@ -3265,7 +3259,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         fields.iter().map(|f| token::get_ident(f.ident).get().to_str()).collect::<Vec<~str>>()));\n }\n \n-pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n+pub fn method_idx(id: ast::Ident, meths: &[Rc<Method>]) -> Option<uint> {\n     meths.iter().position(|m| m.ident == id)\n }\n \n@@ -3417,10 +3411,6 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n                  trait_store_to_str(cx, (*values).expected),\n                  trait_store_to_str(cx, (*values).found))\n         }\n-        terr_in_field(err, fname) => {\n-            format!(\"in field `{}`, {}\", token::get_ident(fname),\n-                 type_err_to_str(cx, err))\n-        }\n         terr_sorts(values) => {\n             format!(\"expected {} but found {}\",\n                  ty_sort_str(cx, values.expected),\n@@ -3500,42 +3490,29 @@ pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     cx.provided_method_sources.borrow().find(&id).map(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<@Method> {\n+pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n     if is_local(id) {\n-        {\n-            match cx.map.find(id.node) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    match item.node {\n-                        ItemTrait(_, _, ref ms) => {\n-                            let (_, p) =\n-                                ast_util::split_trait_methods(ms.as_slice());\n-                            p.iter()\n-                             .map(|m| method(cx, ast_util::local_def(m.id)))\n-                             .collect()\n-                        }\n-                        _ => {\n-                            cx.sess.bug(format!(\"provided_trait_methods: \\\n-                                                 `{:?}` is not a trait\",\n-                                                id))\n-                        }\n+        match cx.map.find(id.node) {\n+            Some(ast_map::NodeItem(item)) => {\n+                match item.node {\n+                    ItemTrait(_, _, ref ms) => {\n+                        let (_, p) = ast_util::split_trait_methods(ms.as_slice());\n+                        p.iter().map(|m| method(cx, ast_util::local_def(m.id))).collect()\n                     }\n-                }\n-                _ => {\n-                    cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is not \\\n-                                         a trait\",\n-                                        id))\n+                    _ => cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a trait\", id))\n                 }\n             }\n+            _ => cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a trait\", id))\n         }\n     } else {\n         csearch::get_provided_trait_methods(cx, id)\n     }\n }\n \n-pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n+pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<TraitRef>>> {\n     // Check the cache.\n     match cx.supertraits.borrow().find(&id) {\n-        Some(&trait_refs) => { return trait_refs; }\n+        Some(trait_refs) => { return trait_refs.clone(); }\n         None => {}  // Continue.\n     }\n \n@@ -3545,12 +3522,12 @@ pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n \n     // Get the supertraits out of the metadata and create the\n     // TraitRef for each.\n-    let result = @csearch::get_supertraits(cx, id);\n-    cx.supertraits.borrow_mut().insert(id, result);\n-    return result;\n+    let result = Rc::new(csearch::get_supertraits(cx, id));\n+    cx.supertraits.borrow_mut().insert(id, result.clone());\n+    result\n }\n \n-pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n+pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<Rc<TraitRef>> {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n     supertrait_refs.iter().map(\n         |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs)).collect()\n@@ -3584,44 +3561,46 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     v\n }\n \n-pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n+pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> Rc<Method> {\n     let method_def_id = *ty::trait_method_def_ids(cx, trait_did).get(idx);\n     ty::method(cx, method_def_id)\n }\n \n \n-pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n+pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> Rc<Vec<Rc<Method>>> {\n     let mut trait_methods = cx.trait_methods_cache.borrow_mut();\n-    match trait_methods.find(&trait_did) {\n-        Some(&methods) => methods,\n+    match trait_methods.find_copy(&trait_did) {\n+        Some(methods) => methods,\n         None => {\n             let def_ids = ty::trait_method_def_ids(cx, trait_did);\n-            let methods = @def_ids.iter().map(|d| ty::method(cx, *d)).collect();\n-            trait_methods.insert(trait_did, methods);\n+            let methods: Rc<Vec<Rc<Method>>> = Rc::new(def_ids.iter().map(|d| {\n+                ty::method(cx, *d)\n+            }).collect());\n+            trait_methods.insert(trait_did, methods.clone());\n             methods\n         }\n     }\n }\n \n-pub fn method(cx: &ctxt, id: ast::DefId) -> @Method {\n+pub fn method(cx: &ctxt, id: ast::DefId) -> Rc<Method> {\n     lookup_locally_or_in_crate_store(\"methods\", id,\n                                      &mut *cx.methods.borrow_mut(), || {\n-        @csearch::get_method(cx, id)\n+        Rc::new(csearch::get_method(cx, id))\n     })\n }\n \n-pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> @Vec<DefId> {\n+pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> Rc<Vec<DefId>> {\n     lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n                                      id,\n                                      &mut *cx.trait_method_def_ids.borrow_mut(),\n                                      || {\n-        @csearch::get_trait_method_def_ids(&cx.sess.cstore, id)\n+        Rc::new(csearch::get_trait_method_def_ids(&cx.sess.cstore, id))\n     })\n }\n \n-pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n+pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n     match cx.impl_trait_cache.borrow().find(&id) {\n-        Some(&ret) => { return ret; }\n+        Some(ret) => { return ret.clone(); }\n         None => {}\n     }\n \n@@ -3647,8 +3626,8 @@ pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         csearch::get_impl_trait(cx, id)\n     };\n \n-    cx.impl_trait_cache.borrow_mut().insert(id, ret);\n-    return ret;\n+    cx.impl_trait_cache.borrow_mut().insert(id, ret.clone());\n+    ret\n }\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n@@ -3751,18 +3730,18 @@ impl VariantInfo {\n pub fn substd_enum_variants(cx: &ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n-                         -> Vec<@VariantInfo> {\n+                         -> Vec<Rc<VariantInfo>> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n             .map(|aty| subst(cx, substs, *aty)).collect();\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n-        @VariantInfo {\n+        Rc::new(VariantInfo {\n             args: substd_args,\n             ctor_ty: substd_ctor_ty,\n             ..(**variant_info).clone()\n-        }\n+        })\n     }).collect()\n }\n \n@@ -3831,27 +3810,26 @@ pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n+pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n     match cx.enum_var_cache.borrow().find(&id) {\n-        Some(&variants) => return variants,\n+        Some(variants) => return variants.clone(),\n         _ => { /* fallthrough */ }\n     }\n \n     let result = if ast::LOCAL_CRATE != id.krate {\n-        @csearch::get_enum_variants(cx, id)\n+        Rc::new(csearch::get_enum_variants(cx, id))\n     } else {\n         /*\n           Although both this code and check_enum_variants in typeck/check\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        {\n-            match cx.map.get(id.node) {\n-              ast_map::NodeItem(item) => {\n-                  match item.node {\n+        match cx.map.get(id.node) {\n+            ast_map::NodeItem(item) => {\n+                match item.node {\n                     ast::ItemEnum(ref enum_definition, _) => {\n                         let mut last_discriminant: Option<Disr> = None;\n-                        @enum_definition.variants.iter().map(|&variant| {\n+                        Rc::new(enum_definition.variants.iter().map(|&variant| {\n \n                             let mut discriminant = match last_discriminant {\n                                 Some(val) => val + 1,\n@@ -3869,40 +3847,33 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n                                     Ok(_) => {\n                                         cx.sess\n                                           .span_err(e.span,\n-                                                    \"expected signed integer \\\n-                                                     constant\");\n+                                                    \"expected signed integer constant\");\n                                     }\n                                     Err(ref err) => {\n                                         cx.sess\n                                           .span_err(e.span,\n-                                                    format!(\"expected \\\n-                                                             constant: {}\",\n+                                                    format!(\"expected constant: {}\",\n                                                             *err));\n                                     }\n                                 },\n                                 None => {}\n                             };\n \n-                            let variant_info =\n-                                @VariantInfo::from_ast_variant(cx,\n-                                                               variant,\n-                                                               discriminant);\n                             last_discriminant = Some(discriminant);\n-                            variant_info\n-\n-                        }).collect()\n+                            Rc::new(VariantInfo::from_ast_variant(cx, variant,\n+                                                                  discriminant))\n+                        }).collect())\n                     }\n                     _ => {\n                         cx.sess.bug(\"enum_variants: id not bound to an enum\")\n                     }\n-                  }\n-              }\n-              _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+                }\n             }\n+            _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n     };\n \n-    cx.enum_var_cache.borrow_mut().insert(id, result);\n+    cx.enum_var_cache.borrow_mut().insert(id, result.clone());\n     result\n }\n \n@@ -3911,17 +3882,11 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n pub fn enum_variant_with_id(cx: &ctxt,\n                             enum_id: ast::DefId,\n                             variant_id: ast::DefId)\n-                         -> @VariantInfo {\n-    let variants = enum_variants(cx, enum_id);\n-    let mut i = 0;\n-    while i < variants.len() {\n-        let variant = *variants.get(i);\n-        if variant.id == variant_id {\n-            return variant\n-        }\n-        i += 1;\n-    }\n-    cx.sess.bug(\"enum_variant_with_id(): no variant exists with that ID\");\n+                         -> Rc<VariantInfo> {\n+    enum_variants(cx, enum_id).iter()\n+                              .find(|variant| variant.id == variant_id)\n+                              .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n+                              .clone()\n }\n \n \n@@ -3944,27 +3909,27 @@ pub fn lookup_impl_vtables(cx: &ctxt,\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> @ty::TraitDef {\n+pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n     let mut trait_defs = cx.trait_defs.borrow_mut();\n-    match trait_defs.find(&did) {\n-        Some(&trait_def) => {\n+    match trait_defs.find_copy(&did) {\n+        Some(trait_def) => {\n             // The item is in this crate. The caller should have added it to the\n             // type cache already\n-            return trait_def;\n+            trait_def\n         }\n         None => {\n             assert!(did.krate != ast::LOCAL_CRATE);\n-            let trait_def = @csearch::get_trait_def(cx, did);\n-            trait_defs.insert(did, trait_def);\n-            return trait_def;\n+            let trait_def = Rc::new(csearch::get_trait_def(cx, did));\n+            trait_defs.insert(did, trait_def.clone());\n+            trait_def\n         }\n     }\n }\n \n /// Iterate over meta_items of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: &ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n+pub fn each_attr(tcx: &ctxt, did: DefId, f: |@ast::MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n         item.attrs.iter().advance(|attr| f(attr.node.value))\n@@ -4038,20 +4003,21 @@ pub fn lookup_field_type(tcx: &ctxt,\n \n // Lookup all ancestor structs of a struct indicated by did. That is the reflexive,\n // transitive closure of doing a single lookup in cx.superstructs.\n-fn lookup_super_structs(cx: &ctxt,\n-                            did: ast::DefId) -> Vec<DefId> {\n-    let mut this_result: Vec<DefId> = vec!(did);\n-    match cx.superstructs.borrow().find(&did) {\n-        Some(&Some(def_id)) => {\n-            let ss: Vec<DefId> = lookup_super_structs(cx, def_id);\n-            this_result.extend(ss.move_iter());\n-            this_result\n-        },\n-        Some(&None) => this_result,\n-        None => {\n-            cx.sess.bug(\n-                format!(\"ID not mapped to super-struct: {}\",\n-                    cx.map.node_to_str(did.node)));\n+fn each_super_struct(cx: &ctxt, mut did: ast::DefId, f: |ast::DefId|) {\n+    let superstructs = cx.superstructs.borrow();\n+\n+    loop {\n+        f(did);\n+        match superstructs.find(&did) {\n+            Some(&Some(def_id)) => {\n+                did = def_id;\n+            },\n+            Some(&None) => break,\n+            None => {\n+                cx.sess.bug(\n+                    format!(\"ID not mapped to super-struct: {}\",\n+                        cx.map.node_to_str(did.node)));\n+            }\n         }\n     }\n }\n@@ -4064,26 +4030,22 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n         // we have to walk the inheritance chain of the struct to get all the\n         // structs (explicit and inherited) for a struct. If this is expensive\n         // we could cache the whole list of fields here.\n-        let structs = lookup_super_structs(cx, did);\n         let struct_fields = cx.struct_fields.borrow();\n-        let results: Vec<&@Vec<field_ty>> = structs.iter().map(|s| {\n-            match struct_fields.find(s) {\n-                Some(fields) => fields,\n+        let mut results: SmallVector<&[field_ty]> = SmallVector::zero();\n+        each_super_struct(cx, did, |s| {\n+            match struct_fields.find(&s) {\n+                Some(fields) => results.push(fields.as_slice()),\n                 _ => {\n                     cx.sess.bug(\n                         format!(\"ID not mapped to struct fields: {}\",\n                             cx.map.node_to_str(did.node)));\n                 }\n             }\n-        }).collect();\n+        });\n \n-        let len = results.iter().map(|x| x.len()).fold(0, |a, b| a + b);\n+        let len = results.as_slice().iter().map(|x| x.len()).sum();\n         let mut result: Vec<field_ty> = Vec::with_capacity(len);\n-        for rs in results.iter() {\n-            for r in rs.iter() {\n-                result.push(*r);\n-            }\n-        }\n+        result.extend(results.as_slice().iter().flat_map(|rs| rs.iter().map(|&f| f)));\n         assert!(result.len() == len);\n         result\n     } else {\n@@ -4314,39 +4276,39 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) ->\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n-                                        bounds: &[@TraitRef],\n-                                        f: |@TraitRef| -> bool)\n+                                        bounds: &[Rc<TraitRef>],\n+                                        f: |Rc<TraitRef>| -> bool)\n                                         -> bool {\n-    for &bound_trait_ref in bounds.iter() {\n+    for bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = Vec::new();\n         let mut i = 0;\n \n         // Seed the worklist with the trait from the bound\n         supertrait_set.insert(bound_trait_ref.def_id, ());\n-        trait_refs.push(bound_trait_ref);\n+        trait_refs.push(bound_trait_ref.clone());\n \n         // Add the given trait ty to the hash map\n         while i < trait_refs.len() {\n             debug!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n                    i, trait_refs.get(i).repr(tcx));\n \n-            if !f(*trait_refs.get(i)) {\n+            if !f(trait_refs.get(i).clone()) {\n                 return false;\n             }\n \n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx,\n-                                                        *trait_refs.get(i));\n-            for &supertrait_ref in supertrait_refs.iter() {\n+                                                        &**trait_refs.get(i));\n+            for supertrait_ref in supertrait_refs.iter() {\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n \n                 let d_id = supertrait_ref.def_id;\n                 if !supertrait_set.contains_key(&d_id) {\n                     // FIXME(#5527) Could have same trait multiple times\n                     supertrait_set.insert(d_id, ());\n-                    trait_refs.push(supertrait_ref);\n+                    trait_refs.push(supertrait_ref.clone());\n                 }\n             }\n \n@@ -4371,7 +4333,7 @@ pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, ~str> {\n }\n \n pub fn visitor_object_ty(tcx: &ctxt,\n-                         region: ty::Region) -> Result<(@TraitRef, t), ~str> {\n+                         region: ty::Region) -> Result<(Rc<TraitRef>, t), ~str> {\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n         Err(s) => { return Err(s); }\n@@ -4381,38 +4343,33 @@ pub fn visitor_object_ty(tcx: &ctxt,\n         self_ty: None,\n         tps: Vec::new()\n     };\n-    let trait_ref = @TraitRef { def_id: trait_lang_item, substs: substs };\n-    Ok((trait_ref,\n+    let trait_ref = Rc::new(TraitRef { def_id: trait_lang_item, substs: substs });\n+    Ok((trait_ref.clone(),\n         mk_trait(tcx,\n                  trait_ref.def_id,\n                  trait_ref.substs.clone(),\n                  RegionTraitStore(region, ast::MutMutable),\n                  EmptyBuiltinBounds())))\n }\n \n-pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n+pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),\n-        || @csearch::get_item_variances(&tcx.sess.cstore, item_id))\n+        || Rc::new(csearch::get_item_variances(&tcx.sess.cstore, item_id)))\n }\n \n /// Records a trait-to-implementation mapping.\n-fn record_trait_implementation(tcx: &ctxt,\n-                               trait_def_id: DefId,\n-                               implementation: @Impl) {\n-    let implementation_list;\n-    let mut trait_impls = tcx.trait_impls.borrow_mut();\n-    match trait_impls.find(&trait_def_id) {\n-        None => {\n-            implementation_list = @RefCell::new(Vec::new());\n-            trait_impls.insert(trait_def_id, implementation_list);\n-        }\n-        Some(&existing_implementation_list) => {\n-            implementation_list = existing_implementation_list\n+pub fn record_trait_implementation(tcx: &ctxt,\n+                                   trait_def_id: DefId,\n+                                   impl_def_id: DefId) {\n+    match tcx.trait_impls.borrow().find(&trait_def_id) {\n+        Some(impls_for_trait) => {\n+            impls_for_trait.borrow_mut().push(impl_def_id);\n+            return;\n         }\n+        None => {}\n     }\n-\n-    implementation_list.borrow_mut().push(implementation);\n+    tcx.trait_impls.borrow_mut().insert(trait_def_id, Rc::new(RefCell::new(vec!(impl_def_id))));\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -4427,45 +4384,38 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     }\n \n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n-            |implementation_def_id| {\n-        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+            |impl_def_id| {\n+        let methods = csearch::get_impl_methods(&tcx.sess.cstore, impl_def_id);\n \n         // Record the trait->implementation mappings, if applicable.\n-        let associated_traits = csearch::get_impl_trait(tcx,\n-                                                        implementation.did);\n+        let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n         for trait_ref in associated_traits.iter() {\n-            record_trait_implementation(tcx,\n-                                        trait_ref.def_id,\n-                                        implementation);\n+            record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for method in implementation.methods.iter() {\n-            for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut()\n-                   .insert(method.def_id, *source);\n+        for &method_def_id in methods.iter() {\n+            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n+                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n             }\n         }\n \n+        // Store the implementation info.\n+        tcx.impl_methods.borrow_mut().insert(impl_def_id, methods);\n+\n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n-            let implementation_list;\n-            let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n-            match inherent_impls.find(&type_id) {\n-                None => {\n-                    implementation_list = @RefCell::new(Vec::new());\n-                    inherent_impls.insert(type_id, implementation_list);\n-                }\n-                Some(&existing_implementation_list) => {\n-                    implementation_list = existing_implementation_list;\n+            match tcx.inherent_impls.borrow().find(&type_id) {\n+                Some(implementation_list) => {\n+                    implementation_list.borrow_mut().push(impl_def_id);\n+                    return;\n                 }\n+                None => {}\n             }\n-            implementation_list.borrow_mut().push(implementation);\n+            tcx.inherent_impls.borrow_mut().insert(type_id,\n+                                                   Rc::new(RefCell::new(vec!(impl_def_id))));\n         }\n-\n-        // Store the implementation info.\n-        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n     });\n \n     tcx.populated_external_types.borrow_mut().insert(type_id);\n@@ -4485,22 +4435,21 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n             |implementation_def_id| {\n-        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+        let methods = csearch::get_impl_methods(&tcx.sess.cstore, implementation_def_id);\n \n         // Record the trait->implementation mapping.\n-        record_trait_implementation(tcx, trait_id, implementation);\n+        record_trait_implementation(tcx, trait_id, implementation_def_id);\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for method in implementation.methods.iter() {\n-            for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut()\n-                   .insert(method.def_id, *source);\n+        for &method_def_id in methods.iter() {\n+            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n+                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n             }\n         }\n \n         // Store the implementation info.\n-        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n+        tcx.impl_methods.borrow_mut().insert(implementation_def_id, methods);\n     });\n \n     tcx.populated_external_traits.borrow_mut().insert(trait_id);\n@@ -4535,7 +4484,7 @@ pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n     if def_id.krate != LOCAL_CRATE {\n         return csearch::get_trait_of_method(&tcx.sess.cstore, def_id, tcx);\n     }\n-    match tcx.methods.borrow().find(&def_id).map(|m| *m) {\n+    match tcx.methods.borrow().find_copy(&def_id) {\n         Some(method) => {\n             match method.container {\n                 TraitContainer(def_id) => Some(def_id),\n@@ -4555,7 +4504,7 @@ pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n pub fn trait_method_of_method(tcx: &ctxt,\n                               def_id: ast::DefId) -> Option<ast::DefId> {\n     let method = match tcx.methods.borrow().find(&def_id) {\n-        Some(&m) => m,\n+        Some(m) => m.clone(),\n         None => return None,\n     };\n     let name = method.ident.name;\n@@ -4724,7 +4673,7 @@ impl Variance {\n \n pub fn construct_parameter_environment(\n     tcx: &ctxt,\n-    self_bound: Option<@TraitRef>,\n+    self_bound: Option<Rc<TraitRef>>,\n     item_type_params: &[TypeParameterDef],\n     method_type_params: &[TypeParameterDef],\n     item_region_params: &[RegionParameterDef],\n@@ -4739,7 +4688,7 @@ pub fn construct_parameter_environment(\n     //\n \n     // map Self => Self\n-    let self_ty = self_bound.map(|t| ty::mk_self(tcx, t.def_id));\n+    let self_ty = self_bound.as_ref().map(|t| ty::mk_self(tcx, t.def_id));\n \n     // map A => A\n     let num_item_type_params = item_type_params.len();"}, {"sha": "6ae68bdbad1281399841349823a5513eb71ad884", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -60,6 +60,7 @@ use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n@@ -69,7 +70,7 @@ use syntax::print::pprust::{lifetime_to_str, path_to_str};\n pub trait AstConv {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty;\n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef;\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n \n     // what type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> ty::t;\n@@ -261,25 +262,16 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n }\n \n pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n-    trait_def_id: ast::DefId,\n-    self_ty: Option<ty::t>,\n-    path: &ast::Path) -> @ty::TraitRef\n-{\n-    let trait_def =\n-        this.get_trait_def(trait_def_id);\n-    let substs =\n-        ast_path_substs(\n-            this,\n-            rscope,\n-            &trait_def.generics,\n-            self_ty,\n-            path);\n-    let trait_ref =\n-        @ty::TraitRef {def_id: trait_def_id,\n-                       substs: substs};\n-    return trait_ref;\n+        this: &AC,\n+        rscope: &RS,\n+        trait_def_id: ast::DefId,\n+        self_ty: Option<ty::t>,\n+        path: &ast::Path) -> Rc<ty::TraitRef> {\n+    let trait_def = this.get_trait_def(trait_def_id);\n+    Rc::new(ty::TraitRef {\n+        def_id: trait_def_id,\n+        substs: ast_path_substs(this, rscope, &trait_def.generics, self_ty, path)\n+    })\n }\n \n pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>("}, {"sha": "9ceb3132509019fd27b06dd3cc6abcc8b56b0918", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -40,7 +40,7 @@ pub fn check_match(fcx: &FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(tcx.def_map, *arm.pats.get(0)),\n+            map: pat_id_map(&tcx.def_map, *arm.pats.get(0)),\n         };\n \n         for p in arm.pats.iter() { check_pat(&mut pcx, *p, discrim_ty);}\n@@ -467,14 +467,14 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         fcx.write_ty(pat.id, b_ty);\n       }\n       ast::PatEnum(..) |\n-      ast::PatIdent(..) if pat_is_const(tcx.def_map, pat) => {\n+      ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n         let const_did = ast_util::def_id_of_def(tcx.def_map.borrow()\n                                                    .get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n-      ast::PatIdent(bm, ref name, sub) if pat_is_binding(tcx.def_map, pat) => {\n+      ast::PatIdent(bm, ref name, sub) if pat_is_binding(&tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {"}, {"sha": "3b33a17d5825f9e2ea657cf82aa3d00079ce0fa1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -30,7 +30,7 @@ itself (note that inherent impls can only be defined in the same\n module as the type itself).\n \n Inherent candidates are not always derived from impls.  If you have a\n-trait instance, such as a value of type `@ToStr`, then the trait\n+trait instance, such as a value of type `~ToStr`, then the trait\n methods (`to_str()`, in this case) are inherently associated with it.\n Another case is type parameters, in which case the methods of their\n bounds are inherent.\n@@ -97,7 +97,7 @@ use util::ppaux;\n use util::ppaux::Repr;\n \n use collections::HashSet;\n-use std::result;\n+use std::rc::Rc;\n use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic};\n use syntax::ast::{MutMutable, MutImmutable};\n@@ -203,7 +203,7 @@ pub fn lookup_in_trait<'a>(\n // to a trait and its supertraits.\n fn get_method_index(tcx: &ty::ctxt,\n                     trait_ref: &TraitRef,\n-                    subtrait: @TraitRef,\n+                    subtrait: Rc<TraitRef>,\n                     n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n@@ -311,7 +311,7 @@ struct LookupContext<'a> {\n struct Candidate {\n     rcvr_match_condition: RcvrMatchCondition,\n     rcvr_substs: ty::substs,\n-    method_ty: @ty::Method,\n+    method_ty: Rc<ty::Method>,\n     origin: MethodOrigin,\n }\n \n@@ -412,7 +412,7 @@ impl<'a> LookupContext<'a> {\n          * `self.inherent_candidates`.  See comment at the start of\n          * the file.  To find the inherent candidates, we repeatedly\n          * deref the self-ty to find the \"base-type\".  So, for\n-         * example, if the receiver is @@C where `C` is a struct type,\n+         * example, if the receiver is ~~C where `C` is a struct type,\n          * we'll want to find the inherent impls for `C`.\n          */\n \n@@ -468,9 +468,11 @@ impl<'a> LookupContext<'a> {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n \n         // Look for explicit implementations.\n+        let impl_methods = self.tcx().impl_methods.borrow();\n         for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n-            for impl_info in impl_infos.borrow().iter() {\n-                self.push_candidates_from_impl(*impl_info, true);\n+            for impl_did in impl_infos.borrow().iter() {\n+                let methods = impl_methods.get(impl_did);\n+                self.push_candidates_from_impl(*impl_did, methods.as_slice(), true);\n             }\n         }\n     }\n@@ -509,12 +511,15 @@ impl<'a> LookupContext<'a> {\n             self_ty: Some(ty::mk_err()),\n             ..(*substs).clone()\n         };\n-        let trait_ref = @TraitRef { def_id: did, substs: rcvr_substs.clone() };\n+        let trait_ref = Rc::new(TraitRef {\n+            def_id: did,\n+            substs: rcvr_substs.clone()\n+        });\n \n-        self.push_inherent_candidates_from_bounds_inner(&[trait_ref],\n+        self.push_inherent_candidates_from_bounds_inner(&[trait_ref.clone()],\n             |new_trait_ref, m, method_num, _bound_num| {\n-            let vtable_index = get_method_index(tcx, new_trait_ref,\n-                                                trait_ref, method_num);\n+            let vtable_index = get_method_index(tcx, &*new_trait_ref,\n+                                                trait_ref.clone(), method_num);\n             let mut m = (*m).clone();\n             // We need to fix up the transformed self type.\n             *m.fty.sig.inputs.get_mut(0) =\n@@ -524,7 +529,7 @@ impl<'a> LookupContext<'a> {\n             Some(Candidate {\n                 rcvr_match_condition: RcvrMatchesIfObject(did),\n                 rcvr_substs: new_trait_ref.substs.clone(),\n-                method_ty: @m,\n+                method_ty: Rc::new(m),\n                 origin: MethodObject(MethodObject {\n                         trait_id: new_trait_ref.def_id,\n                         object_trait_id: did,\n@@ -561,14 +566,14 @@ impl<'a> LookupContext<'a> {\n         debug!(\"push_inherent_candidates_from_self()\");\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n-            [self.fcx.inh.param_env.self_param_bound.unwrap()],\n+            [self.fcx.inh.param_env.self_param_bound.clone().unwrap()],\n             restrict_to,\n             param_self)\n     }\n \n     fn push_inherent_candidates_from_bounds(&mut self,\n                                             self_ty: ty::t,\n-                                            bounds: &[@TraitRef],\n+                                            bounds: &[Rc<TraitRef>],\n                                             restrict_to: Option<DefId>,\n                                             param: param_index) {\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n@@ -598,9 +603,9 @@ impl<'a> LookupContext<'a> {\n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n     fn push_inherent_candidates_from_bounds_inner(&mut self,\n-                                                  bounds: &[@TraitRef],\n-                                                  mk_cand: |tr: @TraitRef,\n-                                                            m: @ty::Method,\n+                                                  bounds: &[Rc<TraitRef>],\n+                                                  mk_cand: |tr: Rc<TraitRef>,\n+                                                            m: Rc<ty::Method>,\n                                                             method_num: uint,\n                                                             bound_num: uint|\n                                                             -> Option<Candidate>) {\n@@ -616,7 +621,7 @@ impl<'a> LookupContext<'a> {\n                 m.explicit_self != ast::SelfStatic &&\n                 m.ident.name == self.m_name }) {\n                 Some(pos) => {\n-                    let method = *trait_methods.get(pos);\n+                    let method = trait_methods.get(pos).clone();\n \n                     match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n                         Some(cand) => {\n@@ -643,48 +648,43 @@ impl<'a> LookupContext<'a> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n+        let impl_methods = self.tcx().impl_methods.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n-            for impl_info in impl_infos.borrow().iter() {\n-                self.push_candidates_from_impl(*impl_info, false);\n+            for impl_did in impl_infos.borrow().iter() {\n+                let methods = impl_methods.get(impl_did);\n+                self.push_candidates_from_impl(*impl_did, methods.as_slice(), false);\n             }\n         }\n     }\n \n     fn push_candidates_from_impl(&mut self,\n-                                 impl_info: &ty::Impl,\n+                                 impl_did: DefId,\n+                                 impl_methods: &[DefId],\n                                  is_extension: bool) {\n-        if !self.impl_dups.insert(impl_info.did) {\n+        if !self.impl_dups.insert(impl_did) {\n             return; // already visited\n         }\n \n-        debug!(\"push_candidates_from_impl: {} {} {}\",\n+        debug!(\"push_candidates_from_impl: {} {}\",\n                token::get_name(self.m_name),\n-               impl_info.ident.repr(self.tcx()),\n-               impl_info.methods.iter()\n-                                .map(|m| m.ident)\n-                                .collect::<Vec<ast::Ident>>()\n-                                .repr(self.tcx()));\n-\n-        let idx = {\n-            match impl_info.methods\n-                           .iter()\n-                           .position(|m| m.ident.name == self.m_name) {\n-                Some(idx) => idx,\n-                None => { return; } // No method with the right name.\n-            }\n+               impl_methods.iter().map(|&did| ty::method(self.tcx(), did).ident)\n+                                 .collect::<Vec<ast::Ident>>()\n+                                 .repr(self.tcx()));\n+\n+        let method = match impl_methods.iter().map(|&did| ty::method(self.tcx(), did))\n+                                              .find(|m| m.ident.name == self.m_name) {\n+            Some(method) => method,\n+            None => { return; } // No method with the right name.\n         };\n \n-        let method = ty::method(self.tcx(),\n-                                impl_info.methods.get(idx).def_id);\n-\n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let vcx = self.fcx.vtable_context();\n         let ty::ty_param_substs_and_ty {\n             substs: impl_substs,\n             ty: impl_ty\n-        } = impl_self_ty(&vcx, span, impl_info.did);\n+        } = impl_self_ty(&vcx, span, impl_did);\n \n         let candidates = if is_extension {\n             &mut self.extension_candidates\n@@ -695,8 +695,8 @@ impl<'a> LookupContext<'a> {\n         candidates.push(Candidate {\n             rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n             rcvr_substs: impl_substs,\n+            origin: MethodStatic(method.def_id),\n             method_ty: method,\n-            origin: MethodStatic(method.def_id)\n         });\n     }\n \n@@ -715,7 +715,7 @@ impl<'a> LookupContext<'a> {\n         // an explicit adjustment, but rather we hardwire the single deref\n         // that occurs in trans and mem_categorization.\n         let adjustment = match self.self_expr {\n-            Some(expr) => Some((expr.id, @ty::AutoDerefRef(auto_deref_ref))),\n+            Some(expr) => Some((expr.id, ty::AutoDerefRef(auto_deref_ref))),\n             None => return None\n         };\n \n@@ -877,7 +877,7 @@ impl<'a> LookupContext<'a> {\n             }\n \n             ty_trait(~ty::TyTrait { def_id: trt_did, substs: trt_substs, bounds: b, .. }) => {\n-                // Coerce ~/@/&Trait instances to &Trait.\n+                // Coerce ~/&Trait instances to &Trait.\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n@@ -962,7 +962,7 @@ impl<'a> LookupContext<'a> {\n                         Some(self_expr_id) => {\n                             self.fcx.write_adjustment(\n                                 self_expr_id,\n-                                @ty::AutoDerefRef(ty::AutoDerefRef {\n+                                ty::AutoDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: Some(kind(region, *mutbl))\n                                 }));\n@@ -1187,8 +1187,8 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         match self.fcx.mk_subty(false, infer::Misc(span),\n                                 rcvr_ty, transformed_self_ty) {\n-            result::Ok(_) => {}\n-            result::Err(_) => {\n+            Ok(_) => {}\n+            Err(_) => {\n                 self.bug(format!(\"{} was a subtype of {} but now is not?\",\n                               self.ty_to_str(rcvr_ty),\n                               self.ty_to_str(transformed_self_ty)));"}, {"sha": "dc5b4f6d520a4af6e5c81ec2dbaf8c0930dc42a1", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -117,7 +117,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::mem::replace;\n-use std::result;\n+use std::rc::Rc;\n use std::vec::Vec;\n use syntax::abi;\n use syntax::ast::{Provided, Required};\n@@ -155,13 +155,13 @@ pub mod method;\n /// share the inherited fields.\n pub struct Inherited<'a> {\n     infcx: infer::InferCtxt<'a>,\n-    locals: @RefCell<NodeMap<ty::t>>,\n+    locals: RefCell<NodeMap<ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n     // Temporary tables:\n     node_types: RefCell<NodeMap<ty::t>>,\n     node_type_substs: RefCell<NodeMap<ty::substs>>,\n-    adjustments: RefCell<NodeMap<@ty::AutoAdjustment>>,\n+    adjustments: RefCell<NodeMap<ty::AutoAdjustment>>,\n     method_map: MethodMap,\n     vtable_map: vtable_map,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n@@ -260,13 +260,13 @@ impl<'a> Inherited<'a> {\n            -> Inherited<'a> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n-            locals: @RefCell::new(NodeMap::new()),\n+            locals: RefCell::new(NodeMap::new()),\n             param_env: param_env,\n             node_types: RefCell::new(NodeMap::new()),\n             node_type_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n-            method_map: @RefCell::new(FnvHashMap::new()),\n-            vtable_map: @RefCell::new(FnvHashMap::new()),\n+            method_map: RefCell::new(FnvHashMap::new()),\n+            vtable_map: RefCell::new(FnvHashMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n     }\n@@ -387,7 +387,7 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n             match p.node {\n               ast::PatIdent(_, ref path, _)\n-                  if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n+                  if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n                 debug!(\"Pattern binding {} is assigned to {}\",\n                        token::get_ident(path.segments.get(0).identifier),\n@@ -469,7 +469,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n-            pat_util::pat_bindings(tcx.def_map,\n+            pat_util::pat_bindings(&tcx.def_map,\n                                    input.pat,\n                                    |_bm, pat_id, _sp, _path| {\n                                        visit.assign(pat_id, None);\n@@ -478,7 +478,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n             // Check the pattern.\n             let pcx = pat_ctxt {\n                 fcx: &fcx,\n-                map: pat_id_map(tcx.def_map, input.pat),\n+                map: pat_id_map(&tcx.def_map, input.pat),\n             };\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n@@ -622,9 +622,9 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                              it.span,\n                                              &impl_tpt.generics,\n                                              ast_trait_ref,\n-                                             impl_trait_ref,\n+                                             &*impl_trait_ref,\n                                              ms.as_slice());\n-                vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, impl_trait_ref);\n+                vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, &*impl_trait_ref);\n             }\n             None => { }\n         }\n@@ -640,7 +640,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n                 Provided(m) => {\n                     check_method_body(ccx, &trait_def.generics,\n-                                      Some(trait_def.trait_ref), m);\n+                                      Some(trait_def.trait_ref.clone()), m);\n                 }\n             }\n         }\n@@ -682,7 +682,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n fn check_method_body(ccx: &CrateCtxt,\n                      item_generics: &ty::Generics,\n-                     self_bound: Option<@ty::TraitRef>,\n+                     self_bound: Option<Rc<ty::TraitRef>>,\n                      method: &ast::Method) {\n     /*!\n      * Type checks a method body.\n@@ -744,10 +744,10 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n             Some(trait_method_ty) => {\n                 compare_impl_method(ccx.tcx,\n                                     impl_generics,\n-                                    impl_method_ty,\n+                                    &*impl_method_ty,\n                                     impl_method.span,\n                                     impl_method.body.id,\n-                                    *trait_method_ty,\n+                                    &**trait_method_ty,\n                                     &impl_trait_ref.substs);\n             }\n             None => {\n@@ -800,7 +800,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n  */\n fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_generics: &ty::Generics,\n-                       impl_m: @ty::Method,\n+                       impl_m: &ty::Method,\n                        impl_m_span: Span,\n                        impl_m_body_id: ast::NodeId,\n                        trait_m: &ty::Method,\n@@ -973,8 +973,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n \n     match infer::mk_subty(&infcx, false, infer::MethodCompatCheck(impl_m_span),\n                           impl_fty, trait_fty) {\n-        result::Ok(()) => {}\n-        result::Err(ref terr) => {\n+        Ok(()) => {}\n+        Err(ref terr) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n                 format!(\"method `{}` has an incompatible type for trait: {}\",\n@@ -992,7 +992,7 @@ impl<'a> AstConv for FnCtxt<'a> {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n         ty::lookup_trait_def(self.tcx(), id)\n     }\n \n@@ -1076,15 +1076,15 @@ impl<'a> FnCtxt<'a> {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n-            @ty::AutoDerefRef(ty::AutoDerefRef {\n+            ty::AutoDerefRef(ty::AutoDerefRef {\n                 autoderefs: derefs,\n                 autoref: None })\n         );\n     }\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n-                            adj: @ty::AutoAdjustment) {\n+                            adj: ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n         self.inh.adjustments.borrow_mut().insert(node_id, adj);\n     }\n@@ -1175,8 +1175,8 @@ impl<'a> FnCtxt<'a> {\n                                  infer::ExprAssignable(expr.span),\n                                  sub,\n                                  sup) {\n-            Ok(None) => result::Ok(()),\n-            Err(ref e) => result::Err((*e)),\n+            Ok(None) => Ok(()),\n+            Err(ref e) => Err((*e)),\n             Ok(Some(adjustment)) => {\n                 self.write_adjustment(expr.id, adjustment);\n                 Ok(())\n@@ -2100,7 +2100,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         op: ast::BinOp,\n                         rhs: @ast::Expr) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n-        let lang = tcx.lang_items;\n+        let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n             ast::BiAdd => (\"add\", lang.add_trait()),\n             ast::BiSub => (\"sub\", lang.sub_trait()),\n@@ -2690,7 +2690,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         demand::suptype(fcx, expr.span, result_t, lhs_t);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, fcx.ccx.method_map, lhs) {\n+        if !ty::expr_is_lval(tcx, lhs) {\n             tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n         }\n \n@@ -2846,8 +2846,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match expr_opt {\n           None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n                                     ret_ty, ty::mk_nil()) {\n-            result::Ok(_) => { /* fall through */ }\n-            result::Err(_) => {\n+            Ok(_) => { /* fall through */ }\n+            Err(_) => {\n                 tcx.sess.span_err(\n                     expr.span,\n                     \"`return;` in function returning non-nil\");\n@@ -2867,7 +2867,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_expr_with_lvalue_pref(fcx, lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, fcx.ccx.method_map, lhs) {\n+        if !ty::expr_is_lval(tcx, lhs) {\n             tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n         }\n \n@@ -3268,7 +3268,7 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n \n     let pcx = pat_ctxt {\n         fcx: fcx,\n-        map: pat_id_map(tcx.def_map, local.pat),\n+        map: pat_id_map(&tcx.def_map, local.pat),\n     };\n     _match::check_pat(&pcx, local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n@@ -3543,10 +3543,10 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 vs: &[ast::P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n-                -> Vec<@ty::VariantInfo> {\n+                -> Vec<Rc<ty::VariantInfo>> {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants: Vec<@ty::VariantInfo> = Vec::new();\n+        let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n@@ -3602,7 +3602,8 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             }\n             disr_vals.push(current_disr_val);\n \n-            let variant_info = @VariantInfo::from_ast_variant(ccx.tcx, v, current_disr_val);\n+            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, v,\n+                                                                     current_disr_val));\n             prev_disr_val = Some(current_disr_val);\n \n             variants.push(variant_info);\n@@ -3624,7 +3625,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     let variants = do_check(ccx, vs, id, hint);\n \n     // cache so that ty::enum_variants won't repeat this work\n-    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), @variants);\n+    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), Rc::new(variants));\n \n     // Check that it is possible to represent this enum.\n     check_representable(ccx.tcx, sp, id, \"enum\");"}, {"sha": "94cbd3a3a750748000085fb95bcc18a1d0310b21", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 80, "deletions": 84, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -131,6 +131,7 @@ use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::MethodCall;\n use middle::pat_util;\n+use util::nodemap::NodeMap;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n@@ -140,6 +141,8 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+use std::cell::RefCell;\n+\n // If mem categorization results in an error, it's because the type\n // check failed (or will fail, when the error is uncovered and\n // reported during writeback). In this case, we just ignore this part\n@@ -155,7 +158,6 @@ macro_rules! ignore_err(\n \n pub struct Rcx<'a> {\n     fcx: &'a FnCtxt<'a>,\n-    errors_reported: uint,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n@@ -234,7 +236,7 @@ impl<'a> Rcx<'a> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&mut self, id: ast::NodeId) -> ty::t {\n+    fn resolve_node_type(&self, id: ast::NodeId) -> ty::t {\n         let t = self.fcx.node_ty(id);\n         self.resolve_type(t)\n     }\n@@ -252,19 +254,19 @@ impl<'a> Rcx<'a> {\n             ty_unadjusted\n         } else {\n             let tcx = self.fcx.tcx();\n-            let adjustment = self.fcx.inh.adjustments.borrow().find_copy(&expr.id);\n-            ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted, adjustment,\n+            ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted,\n+                          self.fcx.inh.adjustments.borrow().find(&expr.id),\n                           |method_call| self.resolve_method_type(method_call))\n         }\n     }\n }\n \n-impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n+impl<'a, 'b> mc::Typer for &'a Rcx<'b> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n \n-    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n         let t = self.resolve_node_type(id);\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n@@ -273,26 +275,25 @@ impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n         self.resolve_method_type(method_call)\n     }\n \n-    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n-        self.fcx.inh.adjustments.borrow().find_copy(&id)\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+        &self.fcx.inh.adjustments\n     }\n \n-    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n         self.fcx.inh.method_map.borrow().contains_key(&MethodCall::expr(id))\n     }\n \n-    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n+    fn temporary_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         self.tcx().region_maps.temporary_scope(id)\n     }\n \n-    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+    fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n         self.fcx.inh.upvar_borrow_map.borrow().get_copy(&id)\n     }\n }\n \n pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n-    let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n-                         repeating_scope: e.id };\n+    let mut rcx = Rcx { fcx: fcx, repeating_scope: e.id };\n     let rcx = &mut rcx;\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n@@ -302,8 +303,7 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n }\n \n pub fn regionck_fn(fcx: &FnCtxt, blk: &ast::Block) {\n-    let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n-                         repeating_scope: blk.id };\n+    let mut rcx = Rcx { fcx: fcx, repeating_scope: blk.id };\n     let rcx = &mut rcx;\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n@@ -361,7 +361,7 @@ fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n-    pat_util::pat_bindings(tcx.def_map, pat, |_, id, span, _| {\n+    pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n         // accessed. We must be wary of loops like this:\n@@ -402,7 +402,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     // Check any autoderefs or autorefs that appear.\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n         debug!(\"adjustment={:?}\", adjustment);\n-        match **adjustment {\n+        match *adjustment {\n             ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n@@ -611,20 +611,21 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     match ty::get(function_type).sty {\n         ty::ty_closure(~ty::ClosureTy {\n                 store: ty::RegionTraitStore(region, _), ..}) => {\n-            let freevars = freevars::get_freevars(tcx, expr.id);\n-            if freevars.is_empty() {\n-                // No free variables means that the environment\n-                // will be NULL at runtime and hence the closure\n-                // has static lifetime.\n-            } else {\n-                // Closure must not outlive the variables it closes over.\n-                constrain_free_variables(rcx, region, expr, freevars);\n-\n-                // Closure cannot outlive the appropriate temporary scope.\n-                let s = rcx.repeating_scope;\n-                rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n-                                region, ty::ReScope(s));\n-            }\n+            freevars::with_freevars(tcx, expr.id, |freevars| {\n+                if freevars.is_empty() {\n+                    // No free variables means that the environment\n+                    // will be NULL at runtime and hence the closure\n+                    // has static lifetime.\n+                } else {\n+                    // Closure must not outlive the variables it closes over.\n+                    constrain_free_variables(rcx, region, expr, freevars);\n+\n+                    // Closure cannot outlive the appropriate temporary scope.\n+                    let s = rcx.repeating_scope;\n+                    rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n+                                    region, ty::ReScope(s));\n+                }\n+            });\n         }\n         _ => ()\n     }\n@@ -635,16 +636,17 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     match ty::get(function_type).sty {\n         ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n-            let freevars = freevars::get_freevars(tcx, expr.id);\n-            propagate_upupvar_borrow_kind(rcx, expr, freevars);\n+            freevars::with_freevars(tcx, expr.id, |freevars| {\n+                propagate_upupvar_borrow_kind(rcx, expr, freevars);\n+            });\n         }\n         _ => ()\n     }\n \n     fn constrain_free_variables(rcx: &mut Rcx,\n                                 region: ty::Region,\n                                 expr: &ast::Expr,\n-                                freevars: freevars::freevar_info) {\n+                                freevars: &[freevars::freevar_entry]) {\n         /*!\n          * Make sure that all free variables referenced inside the closure\n          * outlive the closure itself. Also, create an entry in the\n@@ -690,7 +692,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n                                      expr: &ast::Expr,\n-                                     freevars: freevars::freevar_info) {\n+                                     freevars: &[freevars::freevar_entry]) {\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n         for freevar in freevars.iter() {\n@@ -870,7 +872,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                                 method.ty.repr(rcx.tcx())))\n                 };\n                 {\n-                    let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+                    let mc = mc::MemCategorizationContext { typer: &*rcx };\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     link_region(mc.typer, deref_expr.span, r, m, self_cmt);\n                 }\n@@ -948,8 +950,7 @@ fn constrain_regions_in_type_of_node(\n     rcx: &mut Rcx,\n     id: ast::NodeId,\n     minimum_lifetime: ty::Region,\n-    origin: infer::SubregionOrigin) -> bool\n-{\n+    origin: infer::SubregionOrigin) {\n     //! Guarantees that any lifetimes which appear in the type of\n     //! the node `id` (after applying adjustments) are valid for at\n     //! least `minimum_lifetime`\n@@ -960,22 +961,21 @@ fn constrain_regions_in_type_of_node(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n-    let adjustment = rcx.fcx.inh.adjustments.borrow().find_copy(&id);\n-    let ty = ty::adjust_ty(tcx, origin.span(), id, ty0, adjustment,\n+    let ty = ty::adjust_ty(tcx, origin.span(), id, ty0,\n+                           rcx.fcx.inh.adjustments.borrow().find(&id),\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty={}, ty0={}, id={}, minimum_lifetime={:?}, adjustment={:?})\",\n+            ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n-           id, minimum_lifetime, adjustment);\n-    constrain_regions_in_type(rcx, minimum_lifetime, origin, ty)\n+           id, minimum_lifetime);\n+    constrain_regions_in_type(rcx, minimum_lifetime, origin, ty);\n }\n \n fn constrain_regions_in_type(\n     rcx: &mut Rcx,\n     minimum_lifetime: ty::Region,\n     origin: infer::SubregionOrigin,\n-    ty: ty::t) -> bool\n-{\n+    ty: ty::t) {\n     /*!\n      * Requires that any regions which appear in `ty` must be\n      * superregions of `minimum_lifetime`.  Also enforces the constraint\n@@ -990,7 +990,6 @@ fn constrain_regions_in_type(\n      * code that R corresponds to.\"\n      */\n \n-    let e = rcx.errors_reported;\n     let tcx = rcx.fcx.ccx.tcx;\n \n     debug!(\"constrain_regions_in_type(minimum_lifetime={}, ty={})\",\n@@ -1009,16 +1008,14 @@ fn constrain_regions_in_type(\n             // for regions that are as-yet-unknown.\n         } else if r_sub == minimum_lifetime {\n             rcx.fcx.mk_subr(\n-                true, origin,\n+                true, origin.clone(),\n                 r_sub, r_sup);\n         } else {\n             rcx.fcx.mk_subr(\n                 true, infer::ReferenceOutlivesReferent(ty, origin.span()),\n                 r_sub, r_sup);\n         }\n     });\n-\n-    return e == rcx.errors_reported;\n }\n \n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n@@ -1032,13 +1029,13 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n     debug!(\"link_addr_of(base=?)\");\n \n     let cmt = {\n-        let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+        let mc = mc::MemCategorizationContext { typer: &*rcx };\n         ignore_err!(mc.cat_expr(base))\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n \n-fn link_local(rcx: &mut Rcx, local: &ast::Local) {\n+fn link_local(rcx: &Rcx, local: &ast::Local) {\n     /*!\n      * Computes the guarantors for any ref bindings in a `let` and\n      * then ensures that the lifetime of the resulting pointer is\n@@ -1050,32 +1047,32 @@ fn link_local(rcx: &mut Rcx, local: &ast::Local) {\n         None => { return; }\n         Some(expr) => expr,\n     };\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(&mut mc, discr_cmt, local.pat);\n+    link_pattern(mc, discr_cmt, local.pat);\n }\n \n-fn link_match(rcx: &mut Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n+fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     /*!\n      * Computes the guarantors for any ref bindings in a match and\n      * then ensures that the lifetime of the resulting pointer is\n      * linked to the lifetime of its guarantor (if any).\n      */\n \n     debug!(\"regionck::for_match()\");\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(mc.typer.tcx()));\n     for arm in arms.iter() {\n         for &root_pat in arm.pats.iter() {\n-            link_pattern(&mut mc, discr_cmt, root_pat);\n+            link_pattern(mc, discr_cmt.clone(), root_pat);\n         }\n     }\n }\n \n-fn link_pattern(mc: &mut mc::MemCategorizationContext<&mut Rcx>,\n+fn link_pattern(mc: mc::MemCategorizationContext<&Rcx>,\n                 discr_cmt: mc::cmt,\n-                root_pat: @ast::Pat) {\n+                root_pat: &ast::Pat) {\n     /*!\n      * Link lifetimes of any ref bindings in `root_pat` to\n      * the pointers found in the discriminant, if needed.\n@@ -1105,7 +1102,7 @@ fn link_pattern(mc: &mut mc::MemCategorizationContext<&mut Rcx>,\n         });\n }\n \n-fn link_autoref(rcx: &mut Rcx,\n+fn link_autoref(rcx: &Rcx,\n                 expr: &ast::Expr,\n                 autoderefs: uint,\n                 autoref: &ty::AutoRef) {\n@@ -1115,7 +1112,7 @@ fn link_autoref(rcx: &mut Rcx,\n      */\n \n     debug!(\"link_autoref(autoref={:?})\", autoref);\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(mc.typer.tcx()));\n \n@@ -1138,7 +1135,7 @@ fn link_autoref(rcx: &mut Rcx,\n     }\n }\n \n-fn link_by_ref(rcx: &mut Rcx,\n+fn link_by_ref(rcx: &Rcx,\n                expr: &ast::Expr,\n                callee_scope: ast::NodeId) {\n     /*!\n@@ -1150,13 +1147,13 @@ fn link_by_ref(rcx: &mut Rcx,\n     let tcx = rcx.tcx();\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let region_min = ty::ReScope(callee_scope);\n     link_region(mc.typer, expr.span, region_min, ast::MutImmutable, expr_cmt);\n }\n \n-fn link_region_from_node_type(rcx: &mut Rcx,\n+fn link_region_from_node_type(rcx: &Rcx,\n                               span: Span,\n                               id: ast::NodeId,\n                               mutbl: ast::Mutability,\n@@ -1176,7 +1173,7 @@ fn link_region_from_node_type(rcx: &mut Rcx,\n     }\n }\n \n-fn link_region(rcx: &mut Rcx,\n+fn link_region(rcx: &Rcx,\n                span: Span,\n                region_min: ty::Region,\n                mutbl: ast::Mutability,\n@@ -1197,7 +1194,7 @@ fn link_region(rcx: &mut Rcx,\n                region_min.repr(rcx.tcx()),\n                mutbl.repr(rcx.tcx()),\n                cmt_borrowed.repr(rcx.tcx()));\n-        match cmt_borrowed.cat {\n+        match cmt_borrowed.cat.clone() {\n             mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) => {\n                 // References to an upvar `x` are translated to\n                 // `*x`, since that is what happens in the\n@@ -1287,27 +1284,27 @@ fn link_region(rcx: &mut Rcx,\n     }\n }\n \n-fn adjust_borrow_kind_for_assignment_lhs(rcx: &mut Rcx,\n+fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n                                          lhs: &ast::Expr) {\n     /*!\n      * Adjusts the inferred borrow_kind as needed to account\n      * for upvars that are assigned to in an assignment\n      * expression.\n      */\n \n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let cmt = ignore_err!(mc.cat_expr(lhs));\n     adjust_upvar_borrow_kind_for_mut(mc.typer, cmt);\n }\n \n-fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n+fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n                                     cmt: mc::cmt) {\n     let mut cmt = cmt;\n     loop {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n                cmt.repr(rcx.tcx()));\n \n-        match cmt.cat {\n+        match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n             mc::cat_downcast(base) |\n@@ -1331,14 +1328,14 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n                         return adjust_upvar_borrow_kind(*upvar_id, ub, ty::MutBorrow);\n                     }\n \n-                    _ => {\n-                        // assignment to deref of an `&mut`\n-                        // borrowed pointer implies that the\n-                        // pointer itself must be unique, but not\n-                        // necessarily *mutable*\n-                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-                    }\n+                    _ => {}\n                 }\n+\n+                // assignment to deref of an `&mut`\n+                // borrowed pointer implies that the\n+                // pointer itself must be unique, but not\n+                // necessarily *mutable*\n+                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n             }\n \n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n@@ -1355,14 +1352,13 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n     }\n }\n \n-fn adjust_upvar_borrow_kind_for_unique(rcx: &mut Rcx,\n-                                       cmt: mc::cmt) {\n+fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n     let mut cmt = cmt;\n     loop {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n                cmt.repr(rcx.tcx()));\n \n-        match cmt.cat {\n+        match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n             mc::cat_downcast(base) |\n@@ -1385,12 +1381,12 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &mut Rcx,\n                         return adjust_upvar_borrow_kind(*upvar_id, ub, ty::UniqueImmBorrow);\n                     }\n \n-                    _ => {\n-                        // for a borrowed pointer to be unique, its\n-                        // base must be unique\n-                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-                    }\n+                    _ => {}\n                 }\n+\n+                // for a borrowed pointer to be unique, its\n+                // base must be unique\n+                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n             }\n \n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |"}, {"sha": "bb57fa2646bf654ef2efbfe3f59987d62871e62e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -27,9 +27,8 @@ use util::common::indenter;\n use util::ppaux;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n use collections::HashSet;\n-use std::cell::RefCell;\n-use std::result;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -112,7 +111,7 @@ fn lookup_vtables(vcx: &VtableContext,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()),\n            result.repr(vcx.tcx()));\n-    @result\n+    result\n }\n \n fn lookup_vtables_for_param(vcx: &VtableContext,\n@@ -139,21 +138,21 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n \n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n-        let trait_ref = substs.as_ref().map_or(trait_ref, |substs| {\n+        let trait_ref = substs.as_ref().map_or(trait_ref.clone(), |substs| {\n             debug!(\"about to subst: {}, {}\",\n                    trait_ref.repr(tcx), substs.repr(tcx));\n             trait_ref.subst(tcx, *substs)\n         });\n \n         debug!(\"after subst: {}\", trait_ref.repr(tcx));\n \n-        match lookup_vtable(vcx, span, ty, trait_ref, is_early) {\n+        match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {\n             Some(vtable) => param_result.push(vtable),\n             None => {\n                 vcx.tcx().sess.span_fatal(span,\n                     format!(\"failed to find an implementation of \\\n                           trait {} for {}\",\n-                         vcx.infcx.trait_ref_to_str(trait_ref),\n+                         vcx.infcx.trait_ref_to_str(&*trait_ref),\n                          vcx.infcx.ty_to_str(ty)));\n             }\n         }\n@@ -170,13 +169,13 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n            ty.repr(vcx.tcx()),\n            param_result.repr(vcx.tcx()));\n \n-    return @param_result;\n+    param_result\n }\n \n fn relate_trait_refs(vcx: &VtableContext,\n                      span: Span,\n-                     act_trait_ref: @ty::TraitRef,\n-                     exp_trait_ref: @ty::TraitRef) {\n+                     act_trait_ref: Rc<ty::TraitRef>,\n+                     exp_trait_ref: Rc<ty::TraitRef>) {\n     /*!\n      *\n      * Checks that an implementation of `act_trait_ref` is suitable\n@@ -187,17 +186,17 @@ fn relate_trait_refs(vcx: &VtableContext,\n     match infer::mk_sub_trait_refs(vcx.infcx,\n                                    false,\n                                    infer::RelateTraitRefs(span),\n-                                   act_trait_ref,\n-                                   exp_trait_ref) {\n-        result::Ok(()) => {} // Ok.\n-        result::Err(ref err) => {\n+                                   act_trait_ref.clone(),\n+                                   exp_trait_ref.clone()) {\n+        Ok(()) => {} // Ok.\n+        Err(ref err) => {\n             // There is an error, but we need to do some work to make\n             // the message good.\n             // Resolve any type vars in the trait refs\n             let r_act_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(act_trait_ref);\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);\n             let r_exp_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(exp_trait_ref);\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);\n             // Only print the message if there aren't any previous type errors\n             // inside the types.\n             if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n@@ -218,12 +217,12 @@ fn relate_trait_refs(vcx: &VtableContext,\n fn lookup_vtable(vcx: &VtableContext,\n                  span: Span,\n                  ty: ty::t,\n-                 trait_ref: @ty::TraitRef,\n+                 trait_ref: Rc<ty::TraitRef>,\n                  is_early: bool)\n                  -> Option<vtable_origin> {\n     debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n            vcx.infcx.ty_to_str(ty),\n-           vcx.infcx.trait_ref_to_str(trait_ref));\n+           vcx.infcx.trait_ref_to_str(&*trait_ref));\n     let _i = indenter();\n \n     let ty = match fixup_ty(vcx, span, ty, is_early) {\n@@ -244,23 +243,23 @@ fn lookup_vtable(vcx: &VtableContext,\n         ty::ty_param(param_ty {idx: n, ..}) => {\n             let env_bounds = &vcx.param_env.type_param_bounds;\n             if env_bounds.len() > n {\n-                let type_param_bounds: &[@ty::TraitRef] =\n+                let type_param_bounds: &[Rc<ty::TraitRef>] =\n                     env_bounds.get(n).trait_bounds.as_slice();\n                 lookup_vtable_from_bounds(vcx, span,\n                                           type_param_bounds,\n                                           param_numbered(n),\n-                                          trait_ref)\n+                                          trait_ref.clone())\n             } else {\n                 None\n             }\n         }\n \n         ty::ty_self(_) => {\n-            let self_param_bound = vcx.param_env.self_param_bound.unwrap();\n+            let self_param_bound = vcx.param_env.self_param_bound.clone().unwrap();\n             lookup_vtable_from_bounds(vcx, span,\n                                       [self_param_bound],\n                                       param_self,\n-                                      trait_ref)\n+                                      trait_ref.clone())\n         }\n \n         // Default case just falls through\n@@ -278,9 +277,9 @@ fn lookup_vtable(vcx: &VtableContext,\n // of them are the vtable we are looking for.\n fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                              span: Span,\n-                             bounds: &[@ty::TraitRef],\n+                             bounds: &[Rc<ty::TraitRef>],\n                              param: param_index,\n-                             trait_ref: @ty::TraitRef)\n+                             trait_ref: Rc<ty::TraitRef>)\n                              -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n@@ -291,7 +290,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                bound_trait_ref.repr(vcx.tcx()));\n \n         if bound_trait_ref.def_id == trait_ref.def_id {\n-            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref);\n+            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref.clone());\n             let vtable = vtable_param(param, n_bound);\n             debug!(\"found param vtable: {:?}\",\n                    vtable);\n@@ -308,7 +307,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n fn search_for_vtable(vcx: &VtableContext,\n                      span: Span,\n                      ty: ty::t,\n-                     trait_ref: @ty::TraitRef,\n+                     trait_ref: Rc<ty::TraitRef>,\n                      is_early: bool)\n                      -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n@@ -320,26 +319,28 @@ fn search_for_vtable(vcx: &VtableContext,\n     ty::populate_implementations_for_trait_if_necessary(tcx,\n                                                         trait_ref.def_id);\n \n-    // FIXME: this is a bad way to do this, since we do\n-    // pointless allocations.\n-    let impls = tcx.trait_impls.borrow().find(&trait_ref.def_id)\n-                               .map_or(@RefCell::new(Vec::new()), |x| *x);\n+    let impls = match tcx.trait_impls.borrow().find_copy(&trait_ref.def_id) {\n+        Some(impls) => impls,\n+        None => {\n+            return None;\n+        }\n+    };\n     // impls is the list of all impls in scope for trait_ref.\n-    for im in impls.borrow().iter() {\n+    for &impl_did in impls.borrow().iter() {\n         // im is one specific impl of trait_ref.\n \n         // First, ensure we haven't processed this impl yet.\n-        if impls_seen.contains(&im.did) {\n+        if impls_seen.contains(&impl_did) {\n             continue;\n         }\n-        impls_seen.insert(im.did);\n+        impls_seen.insert(impl_did);\n \n         // ty::impl_traits gives us the trait im implements.\n         //\n         // If foo implements a trait t, and if t is the same trait as\n         // trait_ref, we need to unify it with trait_ref in order to\n         // get all the ty vars sorted out.\n-        let r = ty::impl_trait_ref(tcx, im.did);\n+        let r = ty::impl_trait_ref(tcx, impl_did);\n         let of_trait_ref = r.expect(\"trait_ref missing on trait impl\");\n         if of_trait_ref.def_id != trait_ref.def_id { continue; }\n \n@@ -362,14 +363,14 @@ fn search_for_vtable(vcx: &VtableContext,\n         let ty::ty_param_substs_and_ty {\n             substs: substs,\n             ty: for_ty\n-        } = impl_self_ty(vcx, span, im.did);\n+        } = impl_self_ty(vcx, span, impl_did);\n         match infer::mk_subty(vcx.infcx,\n                               false,\n                               infer::RelateSelfType(span),\n                               ty,\n                               for_ty) {\n-            result::Err(_) => continue,\n-            result::Ok(()) => ()\n+            Err(_) => continue,\n+            Ok(()) => ()\n         }\n \n         // Now, in the previous example, for_ty is bound to\n@@ -388,13 +389,13 @@ fn search_for_vtable(vcx: &VtableContext,\n         // some value of U) with some_trait<T>. This would fail if T\n         // and U weren't compatible.\n \n-        debug!(\"(checking vtable) @2 relating trait \\\n+        debug!(\"(checking vtable) \\\\#2 relating trait \\\n                 ty {} to of_trait_ref {}\",\n-               vcx.infcx.trait_ref_to_str(trait_ref),\n-               vcx.infcx.trait_ref_to_str(of_trait_ref));\n+               vcx.infcx.trait_ref_to_str(&*trait_ref),\n+               vcx.infcx.trait_ref_to_str(&*of_trait_ref));\n \n         let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-        relate_trait_refs(vcx, span, of_trait_ref, trait_ref);\n+        relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());\n \n \n         // Recall that trait_ref -- the trait type we're casting to --\n@@ -405,7 +406,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // type variables in substs. This might still be OK: the\n         // process of looking up bounds might constrain some of them.\n         let im_generics =\n-            ty::lookup_item_type(tcx, im.did).generics;\n+            ty::lookup_item_type(tcx, impl_did).generics;\n         let subres = lookup_vtables(vcx, span,\n                                     im_generics.type_param_defs(), &substs,\n                                     is_early);\n@@ -429,7 +430,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                 they will be unified with the bounds for \\\n                 the target ty, {}\",\n                vcx.infcx.tys_to_str(substs_f.tps.as_slice()),\n-               vcx.infcx.trait_ref_to_str(trait_ref));\n+               vcx.infcx.trait_ref_to_str(&*trait_ref));\n \n         // Next, we unify the fixed-up substitutions for the impl self\n         // ty with the substitutions from the trait type that we're\n@@ -438,12 +439,12 @@ fn search_for_vtable(vcx: &VtableContext,\n         // I am a little confused about this, since it seems to be\n         // very similar to the relate_trait_refs we already do,\n         // but problems crop up if it is removed, so... -sully\n-        connect_trait_tps(vcx, span, &substs_f, trait_ref, im.did);\n+        connect_trait_tps(vcx, span, &substs_f, trait_ref.clone(), impl_did);\n \n         // Finally, we register that we found a matching impl, and\n         // record the def ID of the impl as well as the resolved list\n         // of type substitutions for the target trait.\n-        found.push(vtable_static(im.did, substs_f.tps.clone(), subres));\n+        found.push(vtable_static(impl_did, substs_f.tps.clone(), subres));\n     }\n \n     match found.len() {\n@@ -502,7 +503,7 @@ fn fixup_ty(vcx: &VtableContext,\n fn connect_trait_tps(vcx: &VtableContext,\n                      span: Span,\n                      impl_substs: &ty::substs,\n-                     trait_ref: @ty::TraitRef,\n+                     trait_ref: Rc<ty::TraitRef>,\n                      impl_did: ast::DefId) {\n     let tcx = vcx.tcx();\n \n@@ -561,14 +562,14 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                     };\n \n                       let vcx = fcx.vtable_context();\n-                      let target_trait_ref = @ty::TraitRef {\n+                      let target_trait_ref = Rc::new(ty::TraitRef {\n                           def_id: target_def_id,\n                           substs: ty::substs {\n                               tps: target_substs.tps.clone(),\n                               regions: target_substs.regions.clone(),\n                               self_ty: Some(typ)\n                           }\n-                      };\n+                      });\n \n                       let param_bounds = ty::ParamBounds {\n                           builtin_bounds: ty::EmptyBuiltinBounds(),\n@@ -583,7 +584,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                                      is_early);\n \n                       if !is_early {\n-                          insert_vtables(fcx, MethodCall::expr(ex.id), @vec!(vtables));\n+                          insert_vtables(fcx, MethodCall::expr(ex.id), vec!(vtables));\n                       }\n \n                       // Now, if this is &trait, we need to link the\n@@ -683,7 +684,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     // Search for auto-adjustments to find trait coercions\n     match fcx.inh.adjustments.borrow().find(&ex.id) {\n         Some(adjustment) => {\n-            match **adjustment {\n+            match *adjustment {\n                 AutoDerefRef(adj) => {\n                     for autoderef in range(0, adj.autoderefs) {\n                         let method_call = MethodCall::autoderef(ex.id, autoderef as u32);\n@@ -743,7 +744,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n         [],\n         impl_item.id);\n \n-    let impl_trait_ref = @impl_trait_ref.subst(tcx, &param_env.free_substs);\n+    let impl_trait_ref = impl_trait_ref.subst(tcx, &param_env.free_substs);\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n@@ -761,7 +762,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n     // but that falls out of doing this.\n     let param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n-        trait_bounds: vec!(impl_trait_ref)\n+        trait_bounds: vec!(Rc::new(impl_trait_ref))\n     };\n     let t = ty::node_id_to_type(tcx, impl_item.id);\n     let t = t.subst(tcx, &param_env.free_substs);"}, {"sha": "3843c38fd180029ca63ecdbc24b5a89ad1589386", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 65, "deletions": 86, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -51,96 +51,83 @@ fn resolve_type_vars_in_type(fcx: &FnCtxt, sp: Span, typ: ty::t)\n     }\n }\n \n-fn resolve_type_vars_in_types(fcx: &FnCtxt, sp: Span, tys: &[ty::t])\n-                          -> Vec<ty::t> {\n-    tys.iter().map(|t| {\n-        match resolve_type_vars_in_type(fcx, sp, *t) {\n-            Some(t1) => t1,\n-            None => ty::mk_err()\n-        }\n-    }).collect()\n-}\n-\n fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall) {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any method map entry\n-    match fcx.inh.method_map.borrow().find(&method_call) {\n+    match fcx.inh.method_map.borrow_mut().pop(&method_call) {\n         Some(method) => {\n             debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                    method_call, method.repr(tcx));\n-            let method_ty = match resolve_type_vars_in_type(fcx, sp, method.ty) {\n-                Some(t) => t,\n-                None => {\n-                    wbcx.success = false;\n-                    return;\n-                }\n-            };\n-            let mut new_tps = Vec::new();\n-            for &subst in method.substs.tps.iter() {\n-                match resolve_type_vars_in_type(fcx, sp, subst) {\n-                    Some(t) => new_tps.push(t),\n-                    None => { wbcx.success = false; return; }\n-                }\n-            }\n             let new_method = MethodCallee {\n                 origin: method.origin,\n-                ty: method_ty,\n+                ty: match resolve_type_vars_in_type(fcx, sp, method.ty) {\n+                    Some(t) => t,\n+                    None => {\n+                        wbcx.success = false;\n+                        return;\n+                    }\n+                },\n                 substs: ty::substs {\n-                    tps: new_tps,\n+                    tps: method.substs.tps.move_iter().map(|subst| {\n+                        match resolve_type_vars_in_type(fcx, sp, subst) {\n+                            Some(t) => t,\n+                            None => { wbcx.success = false; ty::mk_err() }\n+                        }\n+                    }).collect(),\n                     regions: ty::ErasedRegions,\n                     self_ty: None\n                 }\n             };\n-            fcx.ccx.method_map.borrow_mut().insert(method_call, new_method);\n+            tcx.method_map.borrow_mut().insert(method_call, new_method);\n         }\n         None => {}\n     }\n }\n \n fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, vtable_key: MethodCall) {\n     // Resolve any vtable map entry\n-    match fcx.inh.vtable_map.borrow().find_copy(&vtable_key) {\n+    match fcx.inh.vtable_map.borrow_mut().pop(&vtable_key) {\n         Some(origins) => {\n             let r_origins = resolve_origins(fcx, sp, origins);\n-            fcx.ccx.vtable_map.borrow_mut().insert(vtable_key, r_origins);\n             debug!(\"writeback::resolve_vtable_map_entry(vtable_key={}, vtables={:?})\",\n                     vtable_key, r_origins.repr(fcx.tcx()));\n+            fcx.tcx().vtable_map.borrow_mut().insert(vtable_key, r_origins);\n         }\n         None => {}\n     }\n \n     fn resolve_origins(fcx: &FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n-        @vtbls.iter().map(|os| @os.iter().map(|origin| {\n+        vtbls.move_iter().map(|os| os.move_iter().map(|origin| {\n             match origin {\n-                &vtable_static(def_id, ref tys, origins) => {\n-                    let r_tys = resolve_type_vars_in_types(fcx,\n-                                                           sp,\n-                                                           tys.as_slice());\n+                vtable_static(def_id, tys, origins) => {\n+                    let r_tys = tys.move_iter().map(|t| {\n+                        match resolve_type_vars_in_type(fcx, sp, t) {\n+                            Some(t1) => t1,\n+                            None => ty::mk_err()\n+                        }\n+                    }).collect();\n                     let r_origins = resolve_origins(fcx, sp, origins);\n                     vtable_static(def_id, r_tys, r_origins)\n                 }\n-                &vtable_param(n, b) => {\n-                    vtable_param(n, b)\n-                }\n+                vtable_param(n, b) => vtable_param(n, b)\n             }\n         }).collect()).collect()\n     }\n }\n \n-fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n-                           -> Option<ty::t> {\n+fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    match fcx.inh.adjustments.borrow().find_copy(&id) {\n-        None => (),\n+    let resolved_adj = match fcx.inh.adjustments.borrow_mut().pop(&id) {\n+        None => None,\n \n         Some(adjustment) => {\n-            match *adjustment {\n+            Some(match adjustment {\n                 ty::AutoAddEnv(store) => {\n                     let r = match store {\n                         ty::RegionTraitStore(r, _) => r,\n@@ -156,6 +143,8 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                                 format!(\"cannot resolve bound for closure: \\\n                                          {}\",\n                                         infer::fixup_err_to_str(e)));\n+                            wbcx.success = false;\n+                            return;\n                         }\n                         Ok(r1) => {\n                             // FIXME(eddyb) #2190 Allow only statically resolved\n@@ -170,15 +159,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                                         \"cannot coerce non-statically resolved bare fn\")\n                             }\n \n-                            let resolved_adj = @ty::AutoAddEnv(match store {\n+                            ty::AutoAddEnv(match store {\n                                 ty::RegionTraitStore(..) => {\n                                     ty::RegionTraitStore(r1, ast::MutMutable)\n                                 }\n                                 ty::UniqTraitStore => ty::UniqTraitStore\n-                            });\n-                            debug!(\"Adjustments for node {}: {:?}\",\n-                                   id, resolved_adj);\n-                            tcx.adjustments.borrow_mut().insert(id, resolved_adj);\n+                            })\n                         }\n                     }\n                 }\n@@ -190,69 +176,62 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                         resolve_vtable_map_entry(wbcx.fcx, sp, method_call);\n                     }\n \n-                    let fixup_region = |r| {\n-                        match resolve_region(fcx.infcx(),\n-                                             r,\n-                                             resolve_all | force_all) {\n-                            Ok(r1) => r1,\n-                            Err(e) => {\n-                                // This should not, I think, happen.\n-                                tcx.sess.span_err(\n-                                    sp,\n-                                    format!(\"cannot resolve scope of borrow: \\\n-                                             {}\",\n-                                             infer::fixup_err_to_str(e)));\n-                                r\n-                            }\n-                        }\n-                    };\n-\n-                    let resolved_autoref = match adj.autoref {\n-                        None => None,\n-                        Some(ref r) => Some(r.map_region(fixup_region))\n-                    };\n-\n-                    let resolved_adj = @ty::AutoDerefRef(ty::AutoDerefRef {\n+                    ty::AutoDerefRef(ty::AutoDerefRef {\n                         autoderefs: adj.autoderefs,\n-                        autoref: resolved_autoref,\n-                    });\n-                    debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-                    tcx.adjustments.borrow_mut().insert(id, resolved_adj);\n+                        autoref: adj.autoref.map(|r| r.map_region(|r| {\n+                            match resolve_region(fcx.infcx(), r,\n+                                                resolve_all | force_all) {\n+                                Ok(r1) => r1,\n+                                Err(e) => {\n+                                    // This should not, I think, happen.\n+                                    tcx.sess.span_err(\n+                                        sp,\n+                                        format!(\"cannot resolve scope of borrow: \\\n+                                                {}\",\n+                                                infer::fixup_err_to_str(e)));\n+                                    r\n+                                }\n+                            }\n+                        })),\n+                    })\n                 }\n \n-                ty::AutoObject(..) => {\n-                    debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n-                    tcx.adjustments.borrow_mut().insert(id, adjustment);\n-                }\n-            }\n+                adjustment => adjustment\n+            })\n         }\n+    };\n+\n+    debug!(\"Adjustments for node {}: {:?}\",\n+           id, resolved_adj);\n+    match resolved_adj {\n+        Some(adj) => {\n+            tcx.adjustments.borrow_mut().insert(id, adj);\n+        }\n+        None => {}\n     }\n \n     // Resolve the type of the node with id `id`\n     let n_ty = fcx.node_ty(id);\n     match resolve_type_vars_in_type(fcx, sp, n_ty) {\n       None => {\n         wbcx.success = false;\n-        return None;\n       }\n \n       Some(t) => {\n         debug!(\"resolve_type_vars_for_node(id={}, n_ty={}, t={})\",\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n-        let mut ret = Some(t);\n         fcx.opt_node_ty_substs(id, |substs| {\n           let mut new_tps = Vec::new();\n           for subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),\n-                None => { wbcx.success = false; ret = None; break }\n+                None => { wbcx.success = false; break }\n               }\n           }\n           write_substs_to_tcx(tcx, id, new_tps);\n-          ret.is_some()\n+          wbcx.success\n         });\n-        ret\n       }\n     }\n }\n@@ -401,7 +380,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt, decl: &ast::FnDecl,\n     for arg in decl.inputs.iter() {\n         wbcx.visit_pat(arg.pat, ());\n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(fcx.tcx().def_map, arg.pat) {\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map, arg.pat) {\n             resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);\n         }\n     }"}, {"sha": "3a50b0681e8b89abd5bc2921f7d61de3dae23057", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 74, "deletions": 100, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -27,7 +27,6 @@ use middle::ty::{ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::type_is_ty_var;\n use middle::subst::Subst;\n use middle::ty;\n-use middle::ty::{Impl, Method};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n@@ -252,7 +251,8 @@ impl<'a> CoherenceChecker<'a> {\n     fn check_implementation(&self, item: &Item,\n                             associated_traits: &[TraitRef]) {\n         let tcx = self.crate_context.tcx;\n-        let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n+        let impl_did = local_def(item.id);\n+        let self_type = ty::lookup_item_type(tcx, impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -276,7 +276,7 @@ impl<'a> CoherenceChecker<'a> {\n             }\n         }\n \n-        let implementation = self.create_impl_from_item(item);\n+        let impl_methods = self.create_impl_from_item(item);\n \n         for associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n@@ -285,7 +285,7 @@ impl<'a> CoherenceChecker<'a> {\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));\n \n-            self.add_trait_impl(trait_ref.def_id, implementation);\n+            self.add_trait_impl(trait_ref.def_id, impl_did);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -300,20 +300,20 @@ impl<'a> CoherenceChecker<'a> {\n             Some(base_type_def_id) => {\n                 // FIXME: Gather up default methods?\n                 if associated_traits.len() == 0 {\n-                    self.add_inherent_impl(base_type_def_id, implementation);\n+                    self.add_inherent_impl(base_type_def_id, impl_did);\n                 }\n             }\n         }\n \n-        tcx.impls.borrow_mut().insert(implementation.did, implementation);\n+        tcx.impl_methods.borrow_mut().insert(impl_did, impl_methods);\n     }\n \n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(&self, impl_id: ast::DefId,\n+    fn instantiate_default_methods(&self, impl_id: DefId,\n                                    trait_ref: &ty::TraitRef,\n-                                   all_methods: &mut Vec<@Method> ) {\n+                                   all_methods: &mut Vec<DefId>) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n@@ -330,16 +330,16 @@ impl<'a> CoherenceChecker<'a> {\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n-                @subst_receiver_types_in_method_ty(\n+                Rc::new(subst_receiver_types_in_method_ty(\n                     tcx,\n                     impl_id,\n                     trait_ref,\n                     new_did,\n-                    *trait_method,\n-                    Some(trait_method.def_id));\n+                    &**trait_method,\n+                    Some(trait_method.def_id)));\n \n             debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n-            all_methods.push(new_method_ty);\n+            all_methods.push(new_did);\n \n             // construct the polytype for the method based on the method_ty\n             let new_generics = ty::Generics {\n@@ -366,40 +366,24 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    fn add_inherent_impl(&self, base_def_id: DefId,\n-                         implementation: @Impl) {\n+    fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n         let tcx = self.crate_context.tcx;\n-        let implementation_list;\n-        let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n-        match inherent_impls.find(&base_def_id) {\n-            None => {\n-                implementation_list = @RefCell::new(Vec::new());\n-                inherent_impls.insert(base_def_id, implementation_list);\n-            }\n-            Some(&existing_implementation_list) => {\n-                implementation_list = existing_implementation_list;\n+        match tcx.inherent_impls.borrow().find(&base_def_id) {\n+            Some(implementation_list) => {\n+                implementation_list.borrow_mut().push(impl_def_id);\n+                return;\n             }\n+            None => {}\n         }\n \n-        implementation_list.borrow_mut().push(implementation);\n+        tcx.inherent_impls.borrow_mut().insert(base_def_id,\n+                                               Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n-    fn add_trait_impl(&self, base_def_id: DefId,\n-                      implementation: @Impl) {\n-        let tcx = self.crate_context.tcx;\n-        let implementation_list;\n-        let mut trait_impls = tcx.trait_impls.borrow_mut();\n-        match trait_impls.find(&base_def_id) {\n-            None => {\n-                implementation_list = @RefCell::new(Vec::new());\n-                trait_impls.insert(base_def_id, implementation_list);\n-            }\n-            Some(&existing_implementation_list) => {\n-                implementation_list = existing_implementation_list;\n-            }\n-        }\n-\n-        implementation_list.borrow_mut().push(implementation);\n+    fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n+        ty::record_trait_implementation(self.crate_context.tcx,\n+                                        base_def_id,\n+                                        impl_def_id);\n     }\n \n     fn check_implementation_coherence(&self) {\n@@ -410,34 +394,32 @@ impl<'a> CoherenceChecker<'a> {\n \n     fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n         // Unify pairs of polytypes.\n-        self.iter_impls_of_trait_local(trait_def_id, |a| {\n-            let implementation_a = a;\n+        self.iter_impls_of_trait_local(trait_def_id, |impl_a| {\n             let polytype_a =\n-                self.get_self_type_for_implementation(implementation_a);\n+                self.get_self_type_for_implementation(impl_a);\n \n             // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n-            // and that impl is <implementation_a>\"\n-            self.iter_impls_of_trait(trait_def_id, |b| {\n-                let implementation_b = b;\n+            // and that impl is <impl_a>\"\n+            self.iter_impls_of_trait(trait_def_id, |impl_b| {\n \n                 // An impl is coherent with itself\n-                if a.did != b.did {\n+                if impl_a != impl_b {\n                     let polytype_b = self.get_self_type_for_implementation(\n-                            implementation_b);\n+                            impl_b);\n \n                     if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n                         let session = &self.crate_context.tcx.sess;\n                         session.span_err(\n-                            self.span_of_impl(implementation_a),\n+                            self.span_of_impl(impl_a),\n                             format!(\"conflicting implementations for trait `{}`\",\n                                  ty::item_path_str(self.crate_context.tcx,\n                                                    trait_def_id)));\n-                        if implementation_b.did.krate == LOCAL_CRATE {\n-                            session.span_note(self.span_of_impl(implementation_b),\n+                        if impl_b.krate == LOCAL_CRATE {\n+                            session.span_note(self.span_of_impl(impl_b),\n                                               \"note conflicting implementation here\");\n                         } else {\n                             let crate_store = &self.crate_context.tcx.sess.cstore;\n-                            let cdata = crate_store.get_crate_data(implementation_b.did.krate);\n+                            let cdata = crate_store.get_crate_data(impl_b.krate);\n                             session.note(\n                                 \"conflicting implementation in crate `\" + cdata.name + \"`\");\n                         }\n@@ -447,7 +429,7 @@ impl<'a> CoherenceChecker<'a> {\n         })\n     }\n \n-    fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n+    fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |DefId|) {\n         self.iter_impls_of_trait_local(trait_def_id, |x| f(x));\n \n         if trait_def_id.krate == LOCAL_CRATE {\n@@ -456,17 +438,17 @@ impl<'a> CoherenceChecker<'a> {\n \n         let crate_store = &self.crate_context.tcx.sess.cstore;\n         csearch::each_implementation_for_trait(crate_store, trait_def_id, |impl_def_id| {\n-            let implementation = @csearch::get_impl(self.crate_context.tcx, impl_def_id);\n-            let _ = lookup_item_type(self.crate_context.tcx, implementation.did);\n-            f(implementation);\n+            // Is this actually necessary?\n+            let _ = lookup_item_type(self.crate_context.tcx, impl_def_id);\n+            f(impl_def_id);\n         });\n     }\n \n-    fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |@Impl|) {\n+    fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |DefId|) {\n         match self.crate_context.tcx.trait_impls.borrow().find(&trait_def_id) {\n             Some(impls) => {\n-                for &im in impls.borrow().iter() {\n-                    f(im);\n+                for &impl_did in impls.borrow().iter() {\n+                    f(impl_did);\n                 }\n             }\n             None => { /* no impls? */ }\n@@ -526,9 +508,9 @@ impl<'a> CoherenceChecker<'a> {\n                             b.monotype).is_ok()\n     }\n \n-    fn get_self_type_for_implementation(&self, implementation: @Impl)\n+    fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> ty_param_bounds_and_ty {\n-        self.crate_context.tcx.tcache.borrow().get_copy(&implementation.did)\n+        self.crate_context.tcx.tcache.borrow().get_copy(&impl_did)\n     }\n \n     // Privileged scope checking\n@@ -538,7 +520,7 @@ impl<'a> CoherenceChecker<'a> {\n     }\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n-        let def_map = self.crate_context.tcx.def_map;\n+        let def_map = &self.crate_context.tcx.def_map;\n         let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n@@ -580,31 +562,25 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    // Converts an implementation in the AST to an Impl structure.\n-    fn create_impl_from_item(&self, item: &Item) -> @Impl {\n-        let tcx = self.crate_context.tcx;\n+    // Converts an implementation in the AST to a vector of methods.\n+    fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n         match item.node {\n             ItemImpl(_, ref trait_refs, _, ref ast_methods) => {\n-                let mut methods = Vec::new();\n-                for ast_method in ast_methods.iter() {\n-                    methods.push(ty::method(tcx, local_def(ast_method.id)));\n-                }\n+                let mut methods: Vec<DefId> = ast_methods.iter().map(|ast_method| {\n+                    local_def(ast_method.id)\n+                }).collect();\n \n                 for trait_ref in trait_refs.iter() {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n                         self.crate_context.tcx,\n                         trait_ref.ref_id);\n \n                     self.instantiate_default_methods(local_def(item.id),\n-                                                     ty_trait_ref,\n+                                                     &*ty_trait_ref,\n                                                      &mut methods);\n                 }\n \n-                return @Impl {\n-                    did: local_def(item.id),\n-                    ident: item.ident,\n-                    methods: methods\n-                };\n+                methods\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n@@ -613,9 +589,9 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    fn span_of_impl(&self, implementation: @Impl) -> Span {\n-        assert_eq!(implementation.did.krate, LOCAL_CRATE);\n-        self.crate_context.tcx.map.span(implementation.did.node)\n+    fn span_of_impl(&self, impl_did: DefId) -> Span {\n+        assert_eq!(impl_did.krate, LOCAL_CRATE);\n+        self.crate_context.tcx.map.span(impl_did.node)\n     }\n \n     // External crate handling\n@@ -624,36 +600,35 @@ impl<'a> CoherenceChecker<'a> {\n                          impls_seen: &mut HashSet<DefId>,\n                          impl_def_id: DefId) {\n         let tcx = self.crate_context.tcx;\n-        let implementation = @csearch::get_impl(tcx, impl_def_id);\n+        let methods = csearch::get_impl_methods(&tcx.sess.cstore, impl_def_id);\n \n         // Make sure we don't visit the same implementation multiple times.\n-        if !impls_seen.insert(implementation.did) {\n+        if !impls_seen.insert(impl_def_id) {\n             // Skip this one.\n             return\n         }\n         // Good. Continue.\n \n-        let _ = lookup_item_type(tcx, implementation.did);\n-        let associated_traits = get_impl_trait(tcx, implementation.did);\n+        let _ = lookup_item_type(tcx, impl_def_id);\n+        let associated_traits = get_impl_trait(tcx, impl_def_id);\n \n         // Do a sanity check.\n         assert!(associated_traits.is_some());\n \n         // Record all the trait methods.\n         for trait_ref in associated_traits.iter() {\n-              self.add_trait_impl(trait_ref.def_id, implementation);\n+            self.add_trait_impl(trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for method in implementation.methods.iter() {\n-            for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut()\n-                   .insert(method.def_id, *source);\n+        for &method_def_id in methods.iter() {\n+            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n+                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n             }\n         }\n \n-        tcx.impls.borrow_mut().insert(implementation.did, implementation);\n+        tcx.impl_methods.borrow_mut().insert(impl_def_id, methods);\n     }\n \n     // Adds implementations and traits from external crates to the coherence\n@@ -680,22 +655,21 @@ impl<'a> CoherenceChecker<'a> {\n             Some(id) => id, None => { return }\n         };\n \n-        let trait_impls = tcx.trait_impls.borrow();\n-        let impls_opt = trait_impls.find(&drop_trait);\n-        let impls;\n-        match impls_opt {\n+        let impl_methods = tcx.impl_methods.borrow();\n+        let trait_impls = match tcx.trait_impls.borrow().find_copy(&drop_trait) {\n             None => return, // No types with (new-style) dtors present.\n-            Some(found_impls) => impls = found_impls\n-        }\n+            Some(found_impls) => found_impls\n+        };\n \n-        for impl_info in impls.borrow().iter() {\n-            if impl_info.methods.len() < 1 {\n+        for &impl_did in trait_impls.borrow().iter() {\n+            let methods = impl_methods.get(&impl_did);\n+            if methods.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }\n-            let method_def_id = impl_info.methods.get(0).def_id;\n+            let method_def_id = *methods.get(0);\n \n-            let self_type = self.get_self_type_for_implementation(*impl_info);\n+            let self_type = self.get_self_type_for_implementation(impl_did);\n             match ty::get(self_type.ty).sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) => {\n@@ -705,9 +679,9 @@ impl<'a> CoherenceChecker<'a> {\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n-                    if impl_info.did.krate == ast::LOCAL_CRATE {\n+                    if impl_did.krate == ast::LOCAL_CRATE {\n                         {\n-                            match tcx.map.find(impl_info.did.node) {\n+                            match tcx.map.find(impl_did.node) {\n                                 Some(ast_map::NodeItem(item)) => {\n                                     tcx.sess.span_err((*item).span,\n                                                       \"the Drop trait may \\"}, {"sha": "0102001aa3cd997a830d5540de5f9c2576889ac9", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -126,7 +126,7 @@ impl<'a> AstConv for CrateCtxt<'a> {\n         }\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n         get_trait_def(self, id)\n     }\n \n@@ -195,7 +195,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     // For each method, construct a suitable ty::Method and\n                     // store it into the `tcx.methods` table:\n                     for m in ms.iter() {\n-                        let ty_method = @match m {\n+                        let ty_method = Rc::new(match m {\n                             &ast::Required(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n@@ -209,10 +209,10 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                     &m.id, &m.ident, &m.explicit_self,\n                                     &m.generics, &m.fn_style, m.decl)\n                             }\n-                        };\n+                        });\n \n                         if ty_method.explicit_self == ast::SelfStatic {\n-                            make_static_method_ty(ccx, trait_id, ty_method,\n+                            make_static_method_ty(ccx, trait_id, &*ty_method,\n                                                   &trait_ty_generics);\n                         }\n \n@@ -221,7 +221,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     }\n \n                     // Add an entry mapping\n-                    let method_def_ids = @ms.iter().map(|m| {\n+                    let method_def_ids = Rc::new(ms.iter().map(|m| {\n                         match m {\n                             &ast::Required(ref ty_method) => {\n                                 local_def(ty_method.id)\n@@ -230,7 +230,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                 local_def(method.id)\n                             }\n                         }\n-                    }).collect();\n+                    }).collect());\n \n                     let trait_def_id = local_def(trait_id);\n                     tcx.trait_method_def_ids.borrow_mut()\n@@ -342,10 +342,10 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         new_type_param_defs.push(ty::TypeParameterDef {\n             ident: special_idents::self_,\n             def_id: dummy_defid,\n-            bounds: @ty::ParamBounds {\n+            bounds: Rc::new(ty::ParamBounds {\n                 builtin_bounds: ty::EmptyBuiltinBounds(),\n                 trait_bounds: vec!(self_trait_ref)\n-            },\n+            }),\n             default: None\n         });\n \n@@ -412,7 +412,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     assert!(!tcx.supertraits.borrow().contains_key(&local_def(id)));\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n-    let mut ty_trait_refs: Vec<@ty::TraitRef> = Vec::new();\n+    let mut ty_trait_refs: Vec<Rc<ty::TraitRef>> = Vec::new();\n     let mut bounds = ty::EmptyBuiltinBounds();\n     for ast_trait_ref in ast_trait_refs.iter() {\n         let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n@@ -434,7 +434,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         }\n     }\n \n-    tcx.supertraits.borrow_mut().insert(local_def(id), @ty_trait_refs);\n+    tcx.supertraits.borrow_mut().insert(local_def(id), Rc::new(ty_trait_refs));\n     bounds\n }\n \n@@ -489,12 +489,12 @@ fn convert_methods(ccx: &CrateCtxt,\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs().len();\n         let m_ty_generics = ty_generics_for_fn_or_method(ccx, &m.generics,\n                                                          num_rcvr_ty_params);\n-        let mty = @ty_of_method(ccx,\n-                                container,\n-                                *m,\n-                                untransformed_rcvr_ty,\n-                                rcvr_ast_generics,\n-                                rcvr_visibility);\n+        let mty = Rc::new(ty_of_method(ccx,\n+                                       container,\n+                                       *m,\n+                                       untransformed_rcvr_ty,\n+                                       rcvr_ast_generics,\n+                                       rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n                 m.ident.repr(ccx.tcx),\n@@ -726,7 +726,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         result\n     }).collect();\n \n-    tcx.struct_fields.borrow_mut().insert(local_def(id), @field_tys);\n+    tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n     let super_struct = match struct_def.super_struct {\n         Some(t) => match t.node {\n@@ -813,8 +813,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                              ast_trait_ref: &ast::TraitRef,\n-                             self_ty: ty::t) -> @ty::TraitRef\n-{\n+                             self_ty: ty::t) -> Rc<ty::TraitRef> {\n     /*!\n      * Instantiates the path for the given trait reference, assuming that\n      * it's bound to a valid trait type. Returns the def_id for the defining\n@@ -831,8 +830,8 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                     ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n \n             ccx.tcx.trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n-                                                   trait_ref);\n-            return trait_ref;\n+                                                   trait_ref.clone());\n+            trait_ref\n         }\n         _ => {\n             ccx.tcx.sess.span_fatal(\n@@ -843,7 +842,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     }\n }\n \n-fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n+fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n     }\n@@ -855,11 +854,11 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n     }\n }\n \n-pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n+pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.trait_defs.borrow().find(&def_id) {\n-        Some(&def) => return def,\n+        Some(def) => return def.clone(),\n         _ => {}\n     }\n \n@@ -872,13 +871,16 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n                                             it.id,\n                                             it.span,\n                                             supertraits.as_slice());\n-            let trait_ref = @ty::TraitRef {def_id: def_id,\n-                                           substs: substs};\n-            let trait_def = @ty::TraitDef {generics: ty_generics,\n-                                           bounds: bounds,\n-                                           trait_ref: trait_ref};\n-            tcx.trait_defs.borrow_mut().insert(def_id, trait_def);\n-            return trait_def;\n+            let trait_def = Rc::new(ty::TraitDef {\n+                generics: ty_generics,\n+                bounds: bounds,\n+                trait_ref: Rc::new(ty::TraitRef {\n+                    def_id: def_id,\n+                    substs: substs\n+                })\n+            });\n+            tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n+            trait_def\n         }\n         ref s => {\n             tcx.sess.span_bug(\n@@ -999,24 +1001,24 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn ty_generics_for_type(ccx: &CrateCtxt,\n-                            generics: &ast::Generics)\n-                            -> ty::Generics {\n+fn ty_generics_for_type(ccx: &CrateCtxt,\n+                        generics: &ast::Generics)\n+                        -> ty::Generics {\n     ty_generics(ccx, &generics.lifetimes, &generics.ty_params, 0)\n }\n \n-pub fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n-                                    generics: &ast::Generics,\n-                                    base_index: uint)\n-                                    -> ty::Generics {\n+fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n+                                generics: &ast::Generics,\n+                                base_index: uint)\n+                                -> ty::Generics {\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(ccx, &early_lifetimes, &generics.ty_params, base_index)\n }\n \n-pub fn ty_generics(ccx: &CrateCtxt,\n-                   lifetimes: &Vec<ast::Lifetime>,\n-                   ty_params: &OwnedSlice<ast::TyParam>,\n-                   base_index: uint) -> ty::Generics {\n+fn ty_generics(ccx: &CrateCtxt,\n+               lifetimes: &Vec<ast::Lifetime>,\n+               ty_params: &OwnedSlice<ast::TyParam>,\n+               base_index: uint) -> ty::Generics {\n     return ty::Generics {\n         region_param_defs: Rc::new(lifetimes.iter().map(|l| {\n                 ty::RegionParameterDef { name: l.name,\n@@ -1025,12 +1027,12 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         type_param_defs: Rc::new(ty_params.iter().enumerate().map(|(offset, param)| {\n             let existing_def_opt = {\n                 let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n-                ty_param_defs.find(&param.id).map(|&def| def)\n+                ty_param_defs.find(&param.id).map(|def| def.clone())\n             };\n             existing_def_opt.unwrap_or_else(|| {\n                 let param_ty = ty::param_ty {idx: base_index + offset,\n                                              def_id: local_def(param.id)};\n-                let bounds = @compute_bounds(ccx, param_ty, &param.bounds);\n+                let bounds = Rc::new(compute_bounds(ccx, param_ty, &param.bounds));\n                 let default = param.default.map(|path| {\n                     let ty = ast_ty_to_ty(ccx, &ExplicitRscope, path);\n                     let cur_idx = param_ty.idx;\n@@ -1056,7 +1058,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                     default: default\n                 };\n                 debug!(\"def for param: {}\", def.repr(ccx.tcx));\n-                ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def);\n+                ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n                 def\n             })\n         }).collect()),"}, {"sha": "e921674ad83fd7ce4fb756be588a86136d1527ac", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -195,7 +195,7 @@ impl<'f> Coerce<'f> {\n     }\n \n     pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n-        match Sub(*self.get_ref()).tys(a, b) {\n+        match Sub(self.get_ref().clone()).tys(a, b) {\n             Ok(_) => Ok(None),         // No coercion required.\n             Err(ref e) => Err(*e)\n         }\n@@ -232,8 +232,9 @@ impl<'f> Coerce<'f> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let sub = Sub(*self.get_ref());\n-        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let sub = Sub(self.get_ref().clone());\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n \n         let inner_ty = match *sty_a {\n             ty::ty_box(typ) | ty::ty_uniq(typ) => typ,\n@@ -247,7 +248,7 @@ impl<'f> Coerce<'f> {\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mt_b.mutbl});\n         if_ok!(sub.tys(a_borrowed, b));\n-        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(AutoPtr(r_borrow, mt_b.mutbl))\n         })))\n@@ -269,10 +270,11 @@ impl<'f> Coerce<'f> {\n             }\n         };\n \n-        let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_a = self.get_ref().infcx.next_region_var(coercion);\n         let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, VstoreSlice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n-        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n             autoref: Some(AutoBorrowVec(r_a, MutImmutable))\n         })))\n@@ -288,8 +290,9 @@ impl<'f> Coerce<'f> {\n                a.inf_str(self.get_ref().infcx), sty_a,\n                b.inf_str(self.get_ref().infcx));\n \n-        let sub = Sub(*self.get_ref());\n-        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let sub = Sub(self.get_ref().clone());\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n         let ty_inner = match *sty_a {\n             ty::ty_uniq(t) | ty::ty_ptr(ty::mt{ty: t, ..}) |\n             ty::ty_rptr(_, ty::mt{ty: t, ..}) => match ty::get(t).sty {\n@@ -307,7 +310,7 @@ impl<'f> Coerce<'f> {\n         let a_borrowed = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n                                       mt {ty: ty_inner, mutbl: mutbl_b});\n         if_ok!(sub.tys(a_borrowed, b));\n-        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n             autoref: Some(AutoBorrowVec(r_borrow, mutbl_b))\n         })))\n@@ -324,7 +327,8 @@ impl<'f> Coerce<'f> {\n                b.inf_str(self.get_ref().infcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n-        let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         let a_borrowed = match *sty_a {\n             ty::ty_trait(~ty::TyTrait { def_id, ref substs, bounds, .. }) => {\n@@ -337,7 +341,7 @@ impl<'f> Coerce<'f> {\n         };\n \n         if_ok!(self.subtype(a_borrowed, b));\n-        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n             autoref: Some(AutoBorrowObj(r_a, b_mutbl))\n         })))\n@@ -384,7 +388,7 @@ impl<'f> Coerce<'f> {\n                 _ => return self.subtype(a, b)\n             };\n \n-            let adj = @ty::AutoAddEnv(fn_ty_b.store);\n+            let adj = ty::AutoAddEnv(fn_ty_b.store);\n             let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n                                            ty::ClosureTy {\n                                                 sig: fn_ty_a.sig.clone(),\n@@ -419,7 +423,7 @@ impl<'f> Coerce<'f> {\n         // although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here\n-        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(ty::AutoUnsafe(mt_b.mutbl))\n         })))\n@@ -438,7 +442,7 @@ impl<'f> Coerce<'f> {\n                a.inf_str(self.get_ref().infcx), sty_a,\n                b.inf_str(self.get_ref().infcx));\n \n-        Ok(Some(@ty::AutoObject(trait_store, bounds,\n-                                trait_def_id, trait_substs.clone())))\n+        Ok(Some(ty::AutoObject(trait_store, bounds,\n+                               trait_def_id, trait_substs.clone())))\n     }\n }"}, {"sha": "54cf6524664c507fd324210d6bf359af5005fb70", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -235,19 +235,6 @@ pub trait Combine {\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n \n-    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n-        if a.ident == b.ident {\n-            self.mts(&a.mt, &b.mt)\n-                .and_then(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n-                .or_else(|e| Err(ty::terr_in_field(@e, a.ident)) )\n-        } else {\n-            Err(ty::terr_record_fields(\n-                                       expected_found(self,\n-                                                      a.ident,\n-                                                      b.ident)))\n-        }\n-    }\n-\n     fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         self.contratys(a, b).and_then(|t| Ok(t))\n     }\n@@ -337,6 +324,7 @@ pub trait Combine {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct CombineFields<'a> {\n     pub infcx: &'a InferCtxt<'a>,\n     pub a_is_expected: bool,"}, {"sha": "a5d41b15d5d312607966be95500506c1adcb4feb", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -76,6 +76,7 @@ use middle::typeck::infer::region_inference::ProcessedErrors;\n use middle::typeck::infer::region_inference::SameRegions;\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n+use std::rc::Rc;\n use std::strbuf::StrBuf;\n use syntax::ast;\n use syntax::ast_map;\n@@ -158,7 +159,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         let p_errors = self.process_errors(errors);\n         let errors = if p_errors.is_empty() { errors } else { &p_errors };\n         for error in errors.iter() {\n-            match *error {\n+            match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup);\n                 }\n@@ -206,7 +207,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         let mut same_regions = Vec::new();\n         let mut processed_errors = Vec::new();\n         for error in errors.iter() {\n-            match *error {\n+            match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\")\n                     let trace = match origin {\n@@ -661,10 +662,10 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                                same_regions: &[SameRegions]) {\n         self.give_suggestion(same_regions);\n         for vo in var_origins.iter() {\n-            self.report_inference_failure(*vo);\n+            self.report_inference_failure(vo.clone());\n         }\n-        for &(trace, terr) in trace_origins.iter() {\n-            self.report_type_error(trace, &terr);\n+        for &(ref trace, terr) in trace_origins.iter() {\n+            self.report_type_error(trace.clone(), &terr);\n         }\n     }\n \n@@ -1391,12 +1392,12 @@ impl Resolvable for ty::t {\n     }\n }\n \n-impl Resolvable for @ty::TraitRef {\n-    fn resolve(&self, infcx: &InferCtxt) -> @ty::TraitRef {\n-        @infcx.resolve_type_vars_in_trait_ref_if_possible(*self)\n+impl Resolvable for Rc<ty::TraitRef> {\n+    fn resolve(&self, infcx: &InferCtxt) -> Rc<ty::TraitRef> {\n+        Rc::new(infcx.resolve_type_vars_in_trait_ref_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(*self)\n+        ty::trait_ref_contains_error(&**self)\n     }\n }\n "}, {"sha": "32bc7eedf2fcf3141a55b22e5739ef2680b29486", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -38,11 +38,11 @@ impl<'f> Combine for Glb<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { \"glb\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.get_ref().infcx.tcx;\n@@ -78,7 +78,7 @@ impl<'f> Combine for Glb<'f> {\n     }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Lub(*self.get_ref()).tys(a, b)\n+        self.lub().tys(a, b)\n     }\n \n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n@@ -108,12 +108,12 @@ impl<'f> Combine for Glb<'f> {\n                a.inf_str(self.get_ref().infcx),\n                b.inf_str(self.get_ref().infcx));\n \n-        Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.get_ref().trace), a, b))\n+        Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n-        Lub(*self.get_ref()).regions(a, b)\n+        self.lub().regions(a, b)\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n@@ -137,11 +137,11 @@ impl<'f> Combine for Glb<'f> {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, a);\n+                self.trace(), a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, b);\n+                self.trace(), b);\n         let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints."}, {"sha": "ebfb17a887633a646d11ee65cb3584fe71f5f0e4", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -47,26 +47,26 @@ use util::common::indenter;\n \n use collections::HashMap;\n \n-pub trait LatticeValue {\n-    fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n-    fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n-    fn glb(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n+trait LatticeValue {\n+    fn sub(cf: CombineFields, a: &Self, b: &Self) -> ures;\n+    fn lub(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n+    fn glb(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n }\n \n pub type LatticeOp<'a, T> =\n-    |cf: &CombineFields, a: &T, b: &T|: 'a -> cres<T>;\n+    |cf: CombineFields, a: &T, b: &T|: 'a -> cres<T>;\n \n impl LatticeValue for ty::t {\n-    fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n-        Sub(*cf).tys(*a, *b).to_ures()\n+    fn sub(cf: CombineFields, a: &ty::t, b: &ty::t) -> ures {\n+        Sub(cf).tys(*a, *b).to_ures()\n     }\n \n-    fn lub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Lub(*cf).tys(*a, *b)\n+    fn lub(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+        Lub(cf).tys(*a, *b)\n     }\n \n-    fn glb(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Glb(*cf).tys(*a, *b)\n+    fn glb(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+        Glb(cf).tys(*a, *b)\n     }\n }\n \n@@ -142,7 +142,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n         match (&a_bounds.ub, &b_bounds.lb) {\n             (&Some(ref a_ub), &Some(ref b_lb)) => {\n                 let r = self.infcx.try(\n-                    || LatticeValue::sub(self, a_ub, b_lb));\n+                    || LatticeValue::sub(self.clone(), a_ub, b_lb));\n                 match r {\n                     Ok(()) => {\n                         return Ok(());\n@@ -232,7 +232,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n             (&Some(_),       &None) => Ok((*a).clone()),\n             (&None,          &Some(_)) => Ok((*b).clone()),\n             (&Some(ref v_a), &Some(ref v_b)) => {\n-                lattice_op(self, v_a, v_b).and_then(|v| Ok(Some(v)))\n+                lattice_op(self.clone(), v_a, v_b).and_then(|v| Ok(Some(v)))\n             }\n         }\n     }\n@@ -314,7 +314,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n                 uok()\n             }\n             (&Some(ref t_a), &Some(ref t_b)) => {\n-                LatticeValue::sub(self, t_a, t_b)\n+                LatticeValue::sub(self.clone(), t_a, t_b)\n             }\n         }\n     }\n@@ -337,7 +337,7 @@ pub trait TyLatticeDir {\n }\n \n impl<'f> LatticeDir for Lub<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { *self.get_ref() }\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..(*b).clone() }\n@@ -351,7 +351,7 @@ impl<'f> TyLatticeDir for Lub<'f> {\n }\n \n impl<'f> LatticeDir for Glb<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { *self.get_ref() }\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..(*b).clone() }"}, {"sha": "d09bbc4253ba93a81ed340ca55492d4145e22a67", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -37,11 +37,11 @@ impl<'f> Combine for Lub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { \"lub\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.get_ref().infcx.tcx;\n@@ -72,7 +72,7 @@ impl<'f> Combine for Lub<'f> {\n     }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Glb(*self.get_ref()).tys(a, b)\n+        self.glb().tys(a, b)\n     }\n \n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n@@ -98,7 +98,7 @@ impl<'f> Combine for Lub<'f> {\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n-        return Glb(*self.get_ref()).regions(a, b);\n+        self.glb().regions(a, b)\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n@@ -107,7 +107,7 @@ impl<'f> Combine for Lub<'f> {\n                a.inf_str(self.get_ref().infcx),\n                b.inf_str(self.get_ref().infcx));\n \n-        Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.get_ref().trace), a, b))\n+        Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -123,10 +123,10 @@ impl<'f> Combine for Lub<'f> {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, a);\n+                self.trace(), a);\n         let (b_with_fresh, _) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, b);\n+                self.trace(), b);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));"}, {"sha": "258f286d8f02542f237e21d6faa03514379cc064", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -38,7 +38,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{Cell, RefCell};\n-use std::result;\n+use std::rc::Rc;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n@@ -72,7 +72,7 @@ pub struct Bounds<T> {\n pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n pub type ures = cres<()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-pub type CoerceResult = cres<Option<@ty::AutoAdjustment>>;\n+pub type CoerceResult = cres<Option<ty::AutoAdjustment>>;\n \n pub struct InferCtxt<'a> {\n     pub tcx: &'a ty::ctxt,\n@@ -129,7 +129,7 @@ pub enum TypeOrigin {\n #[deriving(Clone)]\n pub enum ValuePairs {\n     Types(ty::expected_found<ty::t>),\n-    TraitRefs(ty::expected_found<@ty::TraitRef>),\n+    TraitRefs(ty::expected_found<Rc<ty::TraitRef>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -301,7 +301,7 @@ pub fn common_supertype(cx: &InferCtxt,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result = cx.commit(|| cx.lub(a_is_expected, trace).tys(a, b));\n+    let result = cx.commit(|| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -375,8 +375,8 @@ pub fn mk_eqty(cx: &InferCtxt,\n pub fn mk_sub_trait_refs(cx: &InferCtxt,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n-                         a: @ty::TraitRef,\n-                         b: @ty::TraitRef)\n+                         a: Rc<ty::TraitRef>,\n+                         b: Rc<ty::TraitRef>)\n     -> ures\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n@@ -385,10 +385,10 @@ pub fn mk_sub_trait_refs(cx: &InferCtxt,\n         cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected, a, b))\n+                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n             let suber = cx.sub(a_is_expected, trace);\n-            suber.trait_refs(a, b)\n+            suber.trait_refs(&*a, &*b)\n         })\n     }).to_ures()\n }\n@@ -666,8 +666,8 @@ impl<'a> InferCtxt<'a> {\n \n     pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n-          result::Ok(new_type) => new_type,\n-          result::Err(_) => typ\n+            Ok(new_type) => new_type,\n+            Err(_) => typ\n         }\n     }\n \n@@ -854,7 +854,7 @@ impl Repr for TypeOrigin {\n impl SubregionOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n-            Subtype(a) => a.span(),\n+            Subtype(ref a) => a.span(),\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n@@ -877,7 +877,7 @@ impl SubregionOrigin {\n impl Repr for SubregionOrigin {\n     fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n-            Subtype(a) => format!(\"Subtype({})\", a.repr(tcx)),\n+            Subtype(ref a) => format!(\"Subtype({})\", a.repr(tcx)),\n             InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n             InvokeClosure(a) => format!(\"InvokeClosure({})\", a.repr(tcx)),\n             DerefPointer(a) => format!(\"DerefPointer({})\", a.repr(tcx)),\n@@ -907,7 +907,7 @@ impl RegionVariableOrigin {\n             AddrOfRegion(a) => a,\n             AddrOfSlice(a) => a,\n             Autoref(a) => a,\n-            Coercion(a) => a.span(),\n+            Coercion(ref a) => a.span(),\n             EarlyBoundRegion(a, _) => a,\n             LateBoundRegion(a, _) => a,\n             BoundRegionInFnType(a, _) => a,\n@@ -925,7 +925,7 @@ impl Repr for RegionVariableOrigin {\n             AddrOfRegion(a) => format!(\"AddrOfRegion({})\", a.repr(tcx)),\n             AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            Coercion(ref a) => format!(\"Coercion({})\", a.repr(tcx)),\n             EarlyBoundRegion(a, b) => format!(\"EarlyBoundRegion({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n             LateBoundRegion(a, b) => format!(\"LateBoundRegion({},{})\","}, {"sha": "bb6d479870b91293c41cbae41980d2728560f177", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -212,7 +212,7 @@ impl<'a> RegionVarBindings<'a> {\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n-        self.var_origins.borrow_mut().push(origin);\n+        self.var_origins.borrow_mut().push(origin.clone());\n         let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n@@ -330,9 +330,9 @@ impl<'a> RegionVarBindings<'a> {\n \n             _ => {\n                 self.combine_vars(\n-                    Lub, a, b, origin,\n+                    Lub, a, b, origin.clone(),\n                     |this, old_r, new_r|\n-                    this.make_subregion(origin, old_r, new_r))\n+                    this.make_subregion(origin.clone(), old_r, new_r))\n             }\n         }\n     }\n@@ -354,9 +354,9 @@ impl<'a> RegionVarBindings<'a> {\n \n             _ => {\n                 self.combine_vars(\n-                    Glb, a, b, origin,\n+                    Glb, a, b, origin.clone(),\n                     |this, old_r, new_r|\n-                    this.make_subregion(origin, new_r, old_r))\n+                    this.make_subregion(origin.clone(), new_r, old_r))\n             }\n         }\n     }\n@@ -1150,10 +1150,10 @@ impl<'a> RegionVarBindings<'a> {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n-                        *self.var_origins.borrow().get(node_idx.to_uint()),\n-                        lower_bound.origin,\n+                        self.var_origins.borrow().get(node_idx.to_uint()).clone(),\n+                        lower_bound.origin.clone(),\n                         lower_bound.region,\n-                        upper_bound.origin,\n+                        upper_bound.origin.clone(),\n                         upper_bound.region));\n                     return;\n                 }\n@@ -1200,10 +1200,10 @@ impl<'a> RegionVarBindings<'a> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        *self.var_origins.borrow().get(node_idx.to_uint()),\n-                        upper_bound_1.origin,\n+                        self.var_origins.borrow().get(node_idx.to_uint()).clone(),\n+                        upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n-                        upper_bound_2.origin,\n+                        upper_bound_2.origin.clone(),\n                         upper_bound_2.region));\n                     return;\n                   }"}, {"sha": "2c8acd0573b74f5945f675705e1859fb1c5929fc", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -37,23 +37,25 @@ impl<'f> Combine for Sub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { \"sub\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,.. *self.get_ref()\n+            a_is_expected: !self.get_ref().a_is_expected,\n+            ..self.get_ref().clone()\n         };\n         Sub(opp).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n         let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,.. *self.get_ref()\n+            a_is_expected: !self.get_ref().a_is_expected,\n+            ..self.get_ref().clone()\n         };\n         Sub(opp).regions(b, a)\n     }\n@@ -63,7 +65,7 @@ impl<'f> Combine for Sub<'f> {\n                self.tag(),\n                a.inf_str(self.get_ref().infcx),\n                b.inf_str(self.get_ref().infcx));\n-        self.get_ref().infcx.region_vars.make_subregion(Subtype(self.get_ref().trace), a, b);\n+        self.get_ref().infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n         Ok(a)\n     }\n \n@@ -167,7 +169,7 @@ impl<'f> Combine for Sub<'f> {\n         // region variable.\n         let (a_sig, _) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, a);\n+                self.trace(), a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region."}, {"sha": "26f0bc7ec728cf0ac983fdf73241262f54ff605b", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -171,11 +171,11 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap = @RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n+pub type MethodMap = RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n \n-pub type vtable_param_res = @Vec<vtable_origin> ;\n+pub type vtable_param_res = Vec<vtable_origin>;\n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = @Vec<vtable_param_res> ;\n+pub type vtable_res = Vec<vtable_param_res>;\n \n #[deriving(Clone)]\n pub enum vtable_origin {\n@@ -184,7 +184,7 @@ pub enum vtable_origin {\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself\n      */\n-    vtable_static(ast::DefId, Vec<ty::t> , vtable_res),\n+    vtable_static(ast::DefId, Vec<ty::t>, vtable_res),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -215,7 +215,7 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = @RefCell<FnvHashMap<MethodCall, vtable_res>>;\n+pub type vtable_map = RefCell<FnvHashMap<MethodCall, vtable_res>>;\n \n \n // Information about the vtable resolutions for a trait impl.\n@@ -242,8 +242,6 @@ pub type impl_vtable_map = RefCell<DefIdMap<impl_res>>;\n pub struct CrateCtxt<'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: resolve::TraitMap,\n-    method_map: MethodMap,\n-    vtable_map: vtable_map,\n     tcx: &'a ty::ctxt\n }\n \n@@ -315,25 +313,6 @@ pub fn require_same_types(tcx: &ty::ctxt,\n     }\n }\n \n-// a list of mapping from in-scope-region-names (\"isr\") to the\n-// corresponding ty::Region\n-pub type isr_alist = @Vec<(ty::BoundRegion, ty::Region)>;\n-\n-trait get_region<'a, T:'static> {\n-    fn get(&'a self, br: ty::BoundRegion) -> ty::Region;\n-}\n-\n-impl<'a, T:'static> get_region <'a, T> for isr_alist {\n-    fn get(&'a self, br: ty::BoundRegion) -> ty::Region {\n-        let mut region = None;\n-        for isr in self.iter() {\n-            let (isr_br, isr_r) = *isr;\n-            if isr_br == br { region = Some(isr_r); break; }\n-        };\n-        region.unwrap()\n-    }\n-}\n-\n fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n@@ -445,13 +424,10 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    trait_map: resolve::TraitMap,\n-                   krate: &ast::Crate)\n-                -> (MethodMap, vtable_map) {\n+                   krate: &ast::Crate) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,\n-        method_map: @RefCell::new(FnvHashMap::new()),\n-        vtable_map: @RefCell::new(FnvHashMap::new()),\n         tcx: tcx\n     };\n \n@@ -473,5 +449,4 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n-    (ccx.method_map, ccx.vtable_map)\n }"}, {"sha": "9e7c221d3c55f7b3be4357de677a73d6cd9a0ab9", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -197,6 +197,7 @@ use arena;\n use arena::Arena;\n use middle::ty;\n use std::fmt;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -254,7 +255,7 @@ struct TermsContext<'a> {\n     tcx: &'a ty::ctxt,\n     arena: &'a Arena,\n \n-    empty_variances: @ty::ItemVariances,\n+    empty_variances: Rc<ty::ItemVariances>,\n \n     // Maps from the node id of a type/generic parameter to the\n     // corresponding inferred index.\n@@ -286,9 +287,11 @@ fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n-        empty_variances: @ty::ItemVariances { self_param: None,\n-                                              type_params: OwnedSlice::empty(),\n-                                              region_params: OwnedSlice::empty() }\n+        empty_variances: Rc::new(ty::ItemVariances {\n+            self_param: None,\n+            type_params: OwnedSlice::empty(),\n+            region_params: OwnedSlice::empty()\n+        })\n     };\n \n     visit::walk_crate(&mut terms_cx, krate, ());\n@@ -362,7 +365,7 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n                 if self.num_inferred() == inferreds_on_entry {\n                     let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n                         ast_util::local_def(item.id),\n-                        self.empty_variances);\n+                        self.empty_variances.clone());\n                     assert!(newly_added);\n                 }\n \n@@ -1016,7 +1019,7 @@ impl<'a> SolveContext<'a> {\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()\n-                                 .insert(item_def_id, @item_variances);\n+                                 .insert(item_def_id, Rc::new(item_variances));\n             assert!(newly_added);\n         }\n     }"}, {"sha": "7d7d5d16d74f40f36d6d709dd3a6e89143ad9fe3", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -16,12 +16,13 @@ use std::io;\n use syntax::ast;\n \n pub type FnvHashMap<K, V> = HashMap<K, V, FnvHasher>;\n+pub type FnvHashSet<V> = HashSet<V, FnvHasher>;\n \n pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n \n-pub type NodeSet = HashSet<ast::NodeId, FnvHasher>;\n-pub type DefIdSet = HashSet<ast::DefId, FnvHasher>;\n+pub type NodeSet = FnvHashSet<ast::NodeId>;\n+pub type DefIdSet = FnvHashSet<ast::DefId>;\n \n // Hacks to get good names\n pub mod FnvHashMap {\n@@ -31,6 +32,13 @@ pub mod FnvHashMap {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }\n+pub mod FnvHashSet {\n+    use std::hash::Hash;\n+    use collections::HashSet;\n+    pub fn new<V: Hash<super::FnvState> + TotalEq>() -> super::FnvHashSet<V> {\n+        HashSet::with_hasher(super::FnvHasher)\n+    }\n+}\n pub mod NodeMap {\n     pub fn new<T>() -> super::NodeMap<T> {\n         super::FnvHashMap::new()\n@@ -42,15 +50,13 @@ pub mod DefIdMap {\n     }\n }\n pub mod NodeSet {\n-    use collections::HashSet;\n     pub fn new() -> super::NodeSet {\n-        HashSet::with_hasher(super::FnvHasher)\n+        super::FnvHashSet::new()\n     }\n }\n pub mod DefIdSet {\n-    use collections::HashSet;\n     pub fn new() -> super::DefIdSet {\n-        HashSet::with_hasher(super::FnvHasher)\n+        super::FnvHashSet::new()\n     }\n }\n "}, {"sha": "316b5c6a45a6f15c86929cae5828890edb4ab4a5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n \n-use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{BrFresh, ctxt};\n@@ -23,6 +22,7 @@ use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n \n+use std::rc::Rc;\n use std::strbuf::StrBuf;\n use syntax::abi;\n use syntax::ast_map;\n@@ -469,7 +469,7 @@ pub fn parameterized(cx: &ctxt,\n }\n \n pub fn ty_to_short_str(cx: &ctxt, typ: t) -> ~str {\n-    let mut s = encoder::encoded_ty(cx, typ);\n+    let mut s = typ.repr(cx);\n     if s.len() >= 32u { s = s.slice(0u, 32u).to_owned(); }\n     return s;\n }\n@@ -498,6 +498,12 @@ impl Repr for () {\n     }\n }\n \n+impl<T:Repr> Repr for Rc<T> {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n+        (&**self).repr(tcx)\n+    }\n+}\n+\n impl<T:Repr> Repr for @T {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         (&**self).repr(tcx)\n@@ -888,7 +894,7 @@ impl Repr for Span {\n     }\n }\n \n-impl<A:UserString> UserString for @A {\n+impl<A:UserString> UserString for Rc<A> {\n     fn user_string(&self, tcx: &ctxt) -> ~str {\n         let this: &A = &**self;\n         this.user_string(tcx)"}, {"sha": "693407b854fb923e9a3038333071d435cbaabd4c", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a5b3127a97424108180a79dcd4cd53a5646e24/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=16a5b3127a97424108180a79dcd4cd53a5646e24", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::mem;\n+use std::slice;\n use std::vec;\n \n /// A vector type optimized for cases where the size is almost always 0 or 1\n@@ -61,6 +62,14 @@ impl<T> SmallVector<T> {\n         SmallVector { repr: Many(vs) }\n     }\n \n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match self.repr {\n+            Zero => &[],\n+            One(ref v) => slice::ref_slice(v),\n+            Many(ref vs) => vs.as_slice()\n+        }\n+    }\n+\n     pub fn push(&mut self, v: T) {\n         match self.repr {\n             Zero => self.repr = One(v),"}]}