{"sha": "3f7c74d0225354b93bf7649fed8cdd2774480106", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmN2M3NGQwMjI1MzU0YjkzYmY3NjQ5ZmVkOGNkZDI3NzQ0ODAxMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T20:22:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T20:22:11Z"}, "message": "auto merge of #5467 : nikomatsakis/rust/issues-3888-4036-4492-cannot-encode-region-variables, r=nikomatsakis\n\nThe basic problem was that vtables were not being resolved.  The fix uncovered another issue, which was that the syntax extensions were not creating method calls properly and were relying on outdated code in typeck, so I fixed that too.  \r\n\r\nResolves issues #3888, #4036, #4492.\r\n\r\nr? @catamorphism", "tree": {"sha": "77507568bcaf392e0a57d09deb7fe6cadf867baf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77507568bcaf392e0a57d09deb7fe6cadf867baf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f7c74d0225354b93bf7649fed8cdd2774480106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f7c74d0225354b93bf7649fed8cdd2774480106", "html_url": "https://github.com/rust-lang/rust/commit/3f7c74d0225354b93bf7649fed8cdd2774480106", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f7c74d0225354b93bf7649fed8cdd2774480106/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc4ca134900456ba2a00368ec1f19bc1a357528", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc4ca134900456ba2a00368ec1f19bc1a357528", "html_url": "https://github.com/rust-lang/rust/commit/bbc4ca134900456ba2a00368ec1f19bc1a357528"}, {"sha": "3ca7c225e5e2c907393e7e87660509cf877bffc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca7c225e5e2c907393e7e87660509cf877bffc8", "html_url": "https://github.com/rust-lang/rust/commit/3ca7c225e5e2c907393e7e87660509cf877bffc8"}], "stats": {"total": 483, "additions": 276, "deletions": 207}, "files": [{"sha": "1a5b01feb0aff9ec8826250f97282c1d1e562504", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -1579,7 +1579,17 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         id: ast::node_id,\n                         impl_id: Option<ast::def_id>,\n                         param_substs: Option<@param_substs>,\n-                        sp: Option<span>) -> fn_ctxt {\n+                        sp: Option<span>) -> fn_ctxt\n+{\n+    for param_substs.each |p| { p.validate(); }\n+\n+    debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, impl_id=%?, \\\n+            param_substs=%s\",\n+           path_str(ccx.sess, path),\n+           id,\n+           impl_id,\n+           opt_param_substs_to_str(ccx.tcx, &param_substs));\n+\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     return @mut fn_ctxt_ {\n           llfn: llfndecl,"}, {"sha": "8c5729637ac594f4ad5b673b5203aef6429c6bf5", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -217,7 +217,7 @@ pub fn trans_fn_ref_with_vtables(\n     // - `type_params`: values for each of the fn/method's type parameters\n     // - `vtables`: values for each bound on each of the type parameters\n \n-    let _icx = bcx.insn_ctxt(\"trans_fn_with_vtables\");\n+    let _icx = bcx.insn_ctxt(\"trans_fn_ref_with_vtables\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n@@ -228,6 +228,8 @@ pub fn trans_fn_ref_with_vtables(\n            vtables);\n     let _indenter = indenter();\n \n+    fail_unless!(type_params.all(|t| !ty::type_needs_infer(*t)));\n+\n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n "}, {"sha": "bcdfc7cf95b4934f6993811d56703efc2b465c3e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -250,13 +250,25 @@ pub struct param_substs {\n     self_ty: Option<ty::t>\n }\n \n+pub impl param_substs {\n+    fn validate(&self) {\n+        for self.tys.each |t| { fail_unless!(!ty::type_needs_infer(*t)); }\n+        for self.self_ty.each |t| { fail_unless!(!ty::type_needs_infer(*t)); }\n+    }\n+}\n+\n pub fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n     fmt!(\"param_substs {tys:%?, vtables:%?, bounds:%?}\",\n          substs.tys.map(|t| ty_to_str(tcx, *t)),\n          substs.vtables.map(|vs| vs.map(|v| v.to_str(tcx))),\n          substs.bounds.map(|b| ty::param_bounds_to_str(tcx, *b)))\n }\n \n+pub fn opt_param_substs_to_str(tcx: ty::ctxt,\n+                               substs: &Option<@param_substs>) -> ~str {\n+    substs.map_default(~\"None\", |&ps| param_substs_to_str(tcx, ps))\n+}\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct fn_ctxt_ {\n@@ -1367,6 +1379,13 @@ pub fn expr_ty_adjusted(bcx: block, ex: @ast::expr) -> ty::t {\n pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n+\n+    if !params.all(|t| !ty::type_needs_infer(*t)) {\n+        bcx.sess().bug(\n+            fmt!(\"Type parameters for node %d include inference types: %s\",\n+                 id, str::connect(params.map(|t| bcx.ty_to_str(*t)), \",\")));\n+    }\n+\n     match bcx.fcx.param_substs {\n       Some(substs) => {\n         do vec::map(params) |t| {\n@@ -1423,7 +1442,7 @@ pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n }\n \n pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n-               n_param: uint, n_bound: uint)\n+                   n_param: uint, n_bound: uint)\n     -> typeck::vtable_origin {\n     debug!(\"find_vtable_in_fn_ctxt(n_param=%u, n_bound=%u, ps=%?)\",\n            n_param, n_bound, param_substs_to_str(tcx, ps));"}, {"sha": "b49bdbba426370378eff0ba9c38549f8351b67ac", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -175,6 +175,9 @@ pub fn trans_method_callee(bcx: block,\n                         -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n \n+    debug!(\"trans_method_callee(callee_id=%?, self=%s, mentry=%?)\",\n+           callee_id, bcx.expr_to_str(self), mentry);\n+\n     // Replace method_self with method_static here.\n     let mut origin = mentry.origin;\n     match origin {\n@@ -218,6 +221,8 @@ pub fn trans_method_callee(bcx: block,\n         typeck::method_trait(*) => {}\n     }\n \n+    debug!(\"origin=%?\", origin);\n+\n     match origin {\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n@@ -322,6 +327,7 @@ pub fn trans_static_method_callee(bcx: block,\n \n     match vtbls[bound_index] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n+            fail_unless!(rcvr_substs.all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n             let callee_substs = combine_impl_and_methods_tps("}, {"sha": "67bba3e0bd98923b852b6ae1b3531c02b8bad1ef", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -47,6 +47,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                       impl_did_opt: Option<ast::def_id>,\n                       ref_id: Option<ast::node_id>) ->\n                       (ValueRef, bool) {\n+    fail_unless!(real_substs.all(|t| !ty::type_needs_infer(*t)));\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n@@ -67,9 +68,11 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         must_cast = true;\n     }\n \n-    debug!(\"monomorphic_fn(fn_id=%? (%s), real_substs=%?, substs=%?, \\\n-           hash_id = %?\",\n+    debug!(\"monomorphic_fn(fn_id=%? (%s), vtables=%?, \\\n+            real_substs=%?, substs=%?, \\\n+            hash_id = %?\",\n            fn_id, ty::item_path_str(ccx.tcx, fn_id),\n+           vtables,\n            real_substs.map(|s| ty_to_str(ccx.tcx, *s)),\n            substs.map(|s| ty_to_str(ccx.tcx, *s)), hash_id);\n "}, {"sha": "5d69ab5766d7d28f59e1cfa21a5fa1d1fcbf5230", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -60,7 +60,7 @@ use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::rscope::{in_binding_rscope};\n use middle::typeck::rscope::{region_scope, type_rscope, RegionError};\n-use middle::typeck::{CrateCtxt, write_substs_to_tcx, write_ty_to_tcx};\n+use middle::typeck::{CrateCtxt};\n \n use core::result;\n use core::vec;\n@@ -186,19 +186,15 @@ pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: &AC,\n         rscope: &RS,\n         did: ast::def_id,\n-        path: @ast::path,\n-        path_id: ast::node_id)\n-     -> ty_param_substs_and_ty {\n+        path: @ast::path)\n+     -> ty_param_substs_and_ty\n+{\n     // Look up the polytype of the item and then substitute the provided types\n     // for any type/region parameters.\n-    let tcx = self.tcx();\n     let ty::ty_param_substs_and_ty {\n         substs: substs,\n         ty: ty\n     } = ast_path_to_substs_and_ty(self, rscope, did, path);\n-    write_ty_to_tcx(tcx, path_id, ty);\n-    write_substs_to_tcx(tcx, path_id, /*bad*/copy substs.tps);\n-\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n@@ -368,7 +364,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n         };\n         match a_def {\n           ast::def_ty(did) | ast::def_struct(did) => {\n-            ast_path_to_ty(self, rscope, did, path, id).ty\n+            ast_path_to_ty(self, rscope, did, path).ty\n           }\n           ast::def_prim_ty(nty) => {\n             match nty {"}, {"sha": "e216f9266e910419d4eb1e809fabd6244ff1cb43", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -104,6 +104,7 @@ use middle::typeck::rscope::{RegionError};\n use middle::typeck::rscope::{in_binding_rscope, region_scope, type_rscope};\n use middle::typeck::rscope;\n use middle::typeck::{isr_alist, lookup_def_ccx, method_map_entry};\n+use middle::typeck::{method_map, vtable_map};\n use middle::typeck::{method_origin, method_self, method_trait, no_params};\n use middle::typeck::{require_same_types};\n use util::common::{block_query, indenter, loop_query};\n@@ -160,9 +161,13 @@ pub struct SelfInfo {\n pub struct inherited {\n     infcx: @mut infer::InferCtxt,\n     locals: HashMap<ast::node_id, ty::t>,\n+\n+    // Temporary tables:\n     node_types: HashMap<ast::node_id, ty::t>,\n     node_type_substs: HashMap<ast::node_id, ty::substs>,\n-    adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>\n+    adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>,\n+    method_map: method_map,\n+    vtable_map: vtable_map,\n }\n \n pub enum FnKind {\n@@ -220,7 +225,9 @@ pub fn blank_inherited(ccx: @mut CrateCtxt) -> @inherited {\n         locals: HashMap(),\n         node_types: oldmap::HashMap(),\n         node_type_substs: oldmap::HashMap(),\n-        adjustments: oldmap::HashMap()\n+        adjustments: oldmap::HashMap(),\n+        method_map: oldmap::HashMap(),\n+        vtable_map: oldmap::HashMap(),\n     }\n }\n \n@@ -1321,13 +1328,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   sugar: ast::CallSugar) {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n-        match f.node {\n-            ast::expr_field(ref base, ref field, ref tys) => {\n-                check_field(fcx, f, true, *base, *field, *tys)\n-            }\n-            _ => check_expr(fcx, f)\n-        };\n-\n+        let mut bot = check_expr(fcx, f);\n         check_call_or_method(fcx,\n                              sp,\n                              call_expr_id,\n@@ -1363,7 +1364,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              CheckTraitsAndInherentMethods,\n                              AutoderefReceiver) {\n             Some(ref entry) => {\n-                let method_map = fcx.ccx.method_map;\n+                let method_map = fcx.inh.method_map;\n                 method_map.insert(expr.id, (*entry));\n             }\n             None => {\n@@ -1435,7 +1436,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              deref_args, CheckTraitsOnly, autoderef_receiver) {\n             Some(ref origin) => {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n-                let method_map = fcx.ccx.method_map;\n+                let method_map = fcx.inh.method_map;\n                 method_map.insert(op_ex.id, *origin);\n                 check_call_inner(fcx, op_ex.span,\n                                  op_ex.id, method_ty,\n@@ -1689,7 +1690,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // Check field access expressions\n     fn check_field(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n-                   is_callee: bool,\n                    base: @ast::expr,\n                    field: ast::ident,\n                    tys: &[@ast::Ty]) {\n@@ -1723,7 +1723,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n \n         let tps = vec::map(tys, |ty| fcx.to_ty(*ty));\n-\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -1734,34 +1733,30 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              DontDerefArgs,\n                              CheckTraitsAndInherentMethods,\n                              AutoderefReceiver) {\n-            Some(ref entry) => {\n-                let method_map = fcx.ccx.method_map;\n-                method_map.insert(expr.id, (*entry));\n-\n-                // If we have resolved to a method but this is not in\n-                // a callee position, error\n-                if !is_callee {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        ~\"attempted to take value of method \\\n-                          (try writing an anonymous function)\");\n-                    // Add error type for the result\n-                    fcx.write_error(expr.id);\n-                }\n+            Some(_) => {\n+                fcx.type_error_message(\n+                    expr.span,\n+                    |actual| {\n+                        fmt!(\"attempted to take value of method `%s` on type `%s` \\\n+                              (try writing an anonymous function)\",\n+                             *tcx.sess.str_of(field), actual)\n+                    },\n+                    expr_t, None);\n             }\n+\n             None => {\n-                fcx.type_error_message(expr.span,\n-                  |actual| {\n-                      fmt!(\"attempted access of field `%s` on type `%s`, but \\\n-                            no field or method with that name was found\",\n-                           *tcx.sess.str_of(field), actual)\n-                  },\n-                  expr_t, None);\n-                // Add error type for the result\n-                fcx.write_error(expr.id);\n+                fcx.type_error_message(\n+                    expr.span,\n+                    |actual| {\n+                        fmt!(\"attempted access of field `%s` on type `%s`, \\\n+                              but no field with that name was found\",\n+                             *tcx.sess.str_of(field), actual)\n+                    },\n+                    expr_t, None);\n             }\n         }\n \n+        fcx.write_error(expr.id);\n     }\n \n     fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n@@ -2750,15 +2745,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::expr_field(base, field, ref tys) => {\n-          check_field(fcx, expr, false, base, field, * tys);\n-          let base_t = fcx.expr_ty(base);\n-          if ty::type_is_error(base_t) {\n-              fcx.write_error(id);\n-          }\n-          else if ty::type_is_bot(base_t) {\n-              fcx.write_bot(id);\n-          }\n-          // Otherwise, type already got written\n+        check_field(fcx, expr, base, field, *tys);\n       }\n       ast::expr_index(base, idx) => {\n           check_expr(fcx, base);"}, {"sha": "fa0d9e81c2debf9bbd5989a88a4d9a5f84db8081", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -215,7 +215,7 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n             // `constrain_auto_ref()` on all exprs.  But that causes a\n             // lot of spurious errors because of how the region\n             // hierarchy is setup.\n-            if rcx.fcx.ccx.method_map.contains_key(&callee.id) {\n+            if rcx.fcx.inh.method_map.contains_key(&callee.id) {\n                 match callee.node {\n                     ast::expr_field(base, _, _) => {\n                         constrain_auto_ref(rcx, base);\n@@ -713,7 +713,7 @@ pub mod guarantor {\n             ast::expr_repeat(*) |\n             ast::expr_vec(*) => {\n                 fail_unless!(!ty::expr_is_lval(\n-                    rcx.fcx.tcx(), rcx.fcx.ccx.method_map, expr));\n+                    rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n                 None\n             }\n         }\n@@ -765,7 +765,7 @@ pub mod guarantor {\n         let _i = ::util::common::indenter();\n \n         let guarantor = {\n-            if rcx.fcx.ccx.method_map.contains_key(&expr.id) {\n+            if rcx.fcx.inh.method_map.contains_key(&expr.id) {\n                 None\n             } else {\n                 guarantor(rcx, expr)"}, {"sha": "6dfe34191d3c59a02f4c1acc44ccd0582548c96c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -486,13 +486,12 @@ pub fn connect_trait_tps(vcx: &VtableContext,\n     }\n }\n \n-pub fn insert_vtables(ccx: @mut CrateCtxt,\n+pub fn insert_vtables(fcx: @mut FnCtxt,\n                       callee_id: ast::node_id,\n                       vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n-           callee_id, vtables.map(|v| v.to_str(ccx.tcx)));\n-    let vtable_map = ccx.vtable_map;\n-    vtable_map.insert(callee_id, vtables);\n+           callee_id, vtables.map(|v| v.to_str(fcx.tcx())));\n+    fcx.inh.vtable_map.insert(callee_id, vtables);\n }\n \n pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n@@ -529,8 +528,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            item_ty.bounds, substs, is_early);\n                 if !is_early {\n-                    let vtable_map = cx.vtable_map;\n-                    vtable_map.insert(ex.id, vtbls);\n+                    insert_vtables(fcx, ex.id, vtbls);\n                 }\n             }\n           }\n@@ -543,10 +541,10 @@ pub fn early_resolve_expr(ex: @ast::expr,\n       }\n \n       // Must resolve bounds on methods with bounded params\n-      ast::expr_field(*) | ast::expr_binary(*) |\n+      ast::expr_binary(*) |\n       ast::expr_unary(*) | ast::expr_assign_op(*) |\n       ast::expr_index(*) | ast::expr_method_call(*) => {\n-        match ty::method_call_bounds(cx.tcx, cx.method_map, ex.id) {\n+        match ty::method_call_bounds(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(bounds) => {\n             if has_trait_bounds(/*bad*/copy *bounds) {\n                 let callee_id = match ex.node {\n@@ -559,7 +557,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            bounds, &substs, is_early);\n                 if !is_early {\n-                    insert_vtables(cx, callee_id, vtbls);\n+                    insert_vtables(fcx, callee_id, vtbls);\n                 }\n             }\n           }\n@@ -599,10 +597,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                   // vtable (that is: \"ex has vtable\n                                   // <vtable>\")\n                                   if !is_early {\n-                                      let vtable_map =\n-                                          cx.vtable_map;\n-                                      vtable_map.insert(ex.id,\n-                                                        @~[vtable]);\n+                                      insert_vtables(fcx, ex.id, @~[vtable]);\n                                   }\n                               }\n                               None => {"}, {"sha": "53b0275f95debc776f5a87312819a3fd36c9d5f3", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -21,7 +21,8 @@ use middle::typeck::check::{FnCtxt, SelfInfo};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::{resolve_type};\n use middle::typeck::infer;\n-use middle::typeck::method_map_entry;\n+use middle::typeck::{method_map_entry};\n+use middle::typeck::{vtable_origin, vtable_static, vtable_param};\n use middle::typeck::{vtable_param, write_substs_to_tcx};\n use middle::typeck::{write_ty_to_tcx};\n use util::ppaux;\n@@ -51,21 +52,60 @@ fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: span, typ: ty::t)\n     }\n }\n \n+fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: span, tys: &[ty::t])\n+                          -> ~[ty::t] {\n+    tys.map(|t| {\n+        match resolve_type_vars_in_type(fcx, sp, *t) {\n+            Some(t1) => t1,\n+            None => ty::mk_err(fcx.ccx.tcx)\n+        }\n+    })\n+}\n+\n fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     // Resolve any method map entry\n-    match fcx.ccx.method_map.find(&id) {\n+    match fcx.inh.method_map.find(&id) {\n         None => {}\n         Some(ref mme) => {\n             for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n                 let method_map = fcx.ccx.method_map;\n-                method_map.insert(id,\n-                                  method_map_entry {\n-                                    self_arg: arg {\n-                                        mode: mme.self_arg.mode,\n-                                        ty: *t\n-                                    },\n-                                    .. *mme\n-                                  });\n+                let new_entry = method_map_entry {\n+                    self_arg: arg {mode: mme.self_arg.mode, ty: *t },\n+                    ..*mme\n+                };\n+                debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n+                        new_entry=%?)\",\n+                       id, new_entry);\n+                method_map.insert(id, new_entry);\n+            }\n+        }\n+    }\n+}\n+\n+fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n+    // Resolve any method map entry\n+    match fcx.inh.vtable_map.find(&id) {\n+        None => {}\n+        Some(origins) => {\n+            let r_origins = @origins.map(|o| resolve_origin(fcx, sp, o));\n+            let vtable_map = fcx.ccx.vtable_map;\n+            vtable_map.insert(id, r_origins);\n+            debug!(\"writeback::resolve_vtable_map_entry(id=%d, vtables=%?)\",\n+                   id, r_origins.map(|v| v.to_str(fcx.tcx())));\n+        }\n+    }\n+\n+    fn resolve_origin(fcx: @mut FnCtxt,\n+                      sp: span,\n+                      origin: &vtable_origin) -> vtable_origin {\n+        match origin {\n+            &vtable_static(def_id, ref tys, origins) => {\n+                let r_tys = resolve_type_vars_in_types(fcx, sp, *tys);\n+                let r_origins = @origins.map(|o| resolve_origin(fcx, sp, o));\n+                vtable_static(def_id, r_tys, r_origins)\n+            }\n+            &vtable_param(n, b) => {\n+                vtable_param(n, b)\n             }\n         }\n     }\n@@ -185,6 +225,8 @@ fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n+    resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n+    resolve_vtable_map_entry(wbcx.fcx, e.span, e.callee_id);\n     match e.node {\n       ast::expr_fn_block(ref decl, _) => {\n           for vec::each(decl.inputs) |input| {"}, {"sha": "a74ea5dff8ba02185b14171eaf4af2b60ae097ab", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -42,7 +42,8 @@ use middle::typeck::astconv;\n use middle::typeck::infer;\n use middle::typeck::rscope::*;\n use middle::typeck::rscope;\n-use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n+use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx,\n+                     write_tpt_to_tcx};\n use util::common::{indenter, pluralize};\n use util::ppaux;\n \n@@ -807,8 +808,10 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt, t: @ast::trait_ref,\n \n     match lookup_def_tcx(ccx.tcx, t.path.span, t.ref_id) {\n       ast::def_ty(t_id) => {\n-        let tpt = astconv::ast_path_to_ty(ccx, &rscope, t_id, t.path,\n-                                          t.ref_id);\n+        let tpt = astconv::ast_path_to_ty(ccx, &rscope, t_id, t.path);\n+\n+        write_tpt_to_tcx(ccx.tcx, t.ref_id, &tpt);\n+\n         match ty::get(tpt.ty).sty {\n            ty::ty_trait(*) => {\n               (t_id, tpt)"}, {"sha": "a5265deafdde981a6afe05fbaa4e4c0fb38f6027", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -142,6 +142,7 @@ pub enum vtable_origin {\n       vtable_res is the vtable itself\n      */\n     vtable_static(ast::def_id, ~[ty::t], vtable_res),\n+\n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n       fn foo<T:quux,baz,bar>(a: T) -- a's vtable would have a\n@@ -184,6 +185,7 @@ pub struct CrateCtxt {\n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n+    fail_unless!(!ty::type_needs_infer(ty));\n     tcx.node_types.insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n@@ -192,9 +194,18 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n+        fail_unless!(substs.all(|t| !ty::type_needs_infer(*t)));\n         tcx.node_type_substs.insert(node_id, substs);\n     }\n }\n+pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n+                        node_id: ast::node_id,\n+                        tpt: &ty::ty_param_substs_and_ty) {\n+    write_ty_to_tcx(tcx, node_id, tpt.ty);\n+    if !tpt.substs.tps.is_empty() {\n+        write_substs_to_tcx(tcx, node_id, copy tpt.substs.tps);\n+    }\n+}\n \n pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     match tcx.def_map.find(&id) {"}, {"sha": "e81e460e832e4a0904605db170a172319e30cf62", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 44, "deletions": 67, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -416,6 +416,16 @@ priv impl @ext_ctxt {\n         self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n \n+    fn expr_method_call(\n+        &self,\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident,\n+        +args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+    }\n+\n     fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr {\n         self.lambda(self.expr_blk(expr))\n     }\n@@ -712,30 +722,24 @@ fn mk_struct_ser_impl(\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| self.$(name).encode(__s)`\n         let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n+            cx.expr_method_call(\n                 span,\n                 cx.expr_field(\n                     span,\n-                    cx.expr_field(\n-                        span,\n-                        cx.expr_var(span, ~\"self\"),\n-                        field.ident\n-                    ),\n-                    cx.ident_of(~\"encode\")\n+                    cx.expr_var(span, ~\"self\"),\n+                    field.ident\n                 ),\n+                cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n             )\n         );\n \n         // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n         cx.stmt(\n-            cx.expr_call(\n+            cx.expr_method_call(\n                 span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_var(span, ~\"__s\"),\n-                    cx.ident_of(~\"emit_field\")\n-                ),\n+                cx.expr_var(span, ~\"__s\"),\n+                cx.ident_of(~\"emit_field\"),\n                 ~[\n                     cx.lit_str(span, @cx.str_of(field.ident)),\n                     cx.lit_uint(span, idx),\n@@ -746,13 +750,10 @@ fn mk_struct_ser_impl(\n     };\n \n     // ast for `__s.emit_struct($(name), || $(fields))`\n-    let ser_body = cx.expr_call(\n+    let ser_body = cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_struct\")\n-        ),\n+        cx.expr_var(span, ~\"__s\"),\n+        cx.ident_of(~\"emit_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n@@ -788,13 +789,10 @@ fn mk_struct_deser_impl(\n         );\n \n         // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n-        let expr: @ast::expr = cx.expr_call(\n+        let expr: @ast::expr = cx.expr_method_call(\n             span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_field\")\n-            ),\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_field\"),\n             ~[\n                 cx.lit_str(span, @cx.str_of(field.ident)),\n                 cx.lit_uint(span, idx),\n@@ -813,13 +811,10 @@ fn mk_struct_deser_impl(\n     };\n \n     // ast for `read_struct($(name), || $(fields))`\n-    let body = cx.expr_call(\n+    let body = cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_struct\")\n-        ),\n+        cx.expr_var(span, ~\"__d\"),\n+        cx.ident_of(~\"read_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n@@ -943,13 +938,10 @@ fn ser_variant(\n \n         // ast for `|| $(v).encode(__s)`\n         let expr_encode = cx.lambda_expr(\n-             cx.expr_call(\n+             cx.expr_method_call(\n                 span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_path(span, ~[names[a_idx]]),\n-                    cx.ident_of(~\"encode\")\n-                ),\n+                 cx.expr_path(span, ~[names[a_idx]]),\n+                 cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n             )\n         );\n@@ -965,13 +957,10 @@ fn ser_variant(\n     };\n \n     // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n-    let body = cx.expr_call(\n+    let body = cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum_variant\")\n-        ),\n+        cx.expr_var(span, ~\"__s\"),\n+        cx.ident_of(~\"emit_enum_variant\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(v_name)),\n             cx.lit_uint(span, v_idx),\n@@ -1019,13 +1008,10 @@ fn mk_enum_ser_body(\n     );\n \n     // ast for `__s.emit_enum($(name), || $(match_expr))`\n-    cx.expr_call(\n+    cx.expr_method_call(\n         span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum\")\n-        ),\n+        cx.expr_var(span, ~\"__s\"),\n+        cx.ident_of(~\"emit_enum\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(name)),\n             cx.lambda_expr(match_expr),\n@@ -1055,13 +1041,10 @@ fn mk_enum_deser_variant_nary(\n         );\n \n         // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n-        cx.expr_call(\n+        cx.expr_method_call(\n             span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_enum_variant_arg\")\n-            ),\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_enum_variant_arg\"),\n             ~[cx.lit_uint(span, idx), expr_lambda]\n         )\n     };\n@@ -1171,25 +1154,19 @@ fn mk_enum_deser_body(\n \n     // ast for `__d.read_enum_variant($(expr_lambda))`\n     let expr_lambda = ext_cx.lambda_expr(\n-        ext_cx.expr_call(\n+        ext_cx.expr_method_call(\n             span,\n-            ext_cx.expr_field(\n-                span,\n-                ext_cx.expr_var(span, ~\"__d\"),\n-                ext_cx.ident_of(~\"read_enum_variant\")\n-            ),\n+            ext_cx.expr_var(span, ~\"__d\"),\n+            ext_cx.ident_of(~\"read_enum_variant\"),\n             ~[expr_lambda]\n         )\n     );\n \n     // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n-    ext_cx.expr_call(\n+    ext_cx.expr_method_call(\n         span,\n-        ext_cx.expr_field(\n-            span,\n-            ext_cx.expr_var(span, ~\"__d\"),\n-            ext_cx.ident_of(~\"read_enum\")\n-        ),\n+        ext_cx.expr_var(span, ~\"__d\"),\n+        ext_cx.ident_of(~\"read_enum\"),\n         ~[\n             ext_cx.lit_str(span, @ext_cx.str_of(name)),\n             expr_lambda"}, {"sha": "ad71441e0466fbc462601b0b623dc4eff30a357e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -111,6 +111,13 @@ pub fn mk_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n pub fn mk_mut_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_mutbl, e));\n }\n+pub fn mk_method_call(cx: @ext_ctxt,\n+                      sp: span,\n+                      rcvr_expr: @ast::expr,\n+                      method_ident: ast::ident,\n+                      +args: ~[@ast::expr]) -> @ast::expr {\n+    mk_expr(cx, sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n+}\n pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n                 +args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))"}, {"sha": "68458bd516eedd122debeda0bf6e2800d8675867", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -120,8 +120,9 @@ fn call_substructure_clone_method(cx: @ext_ctxt,\n                                -> @expr {\n     // Call the substructure method.\n     let clone_ident = cx.ident_of(~\"clone\");\n-    let self_method = build::mk_access_(cx, span, self_field, clone_ident);\n-    build::mk_call_(cx, span, self_method, ~[])\n+    build::mk_method_call(cx, span,\n+                          self_field, clone_ident,\n+                          ~[])\n }\n \n fn expand_deriving_clone_struct_def(cx: @ext_ctxt,"}, {"sha": "8cee6bd7290b46fee7898ec15e8f0eb3f7a72f6a", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -147,11 +147,9 @@ fn call_substructure_eq_method(cx: @ext_ctxt,\n                                junction: Junction,\n                                chain_expr: &mut Option<@expr>) {\n     // Call the substructure method.\n-    let self_method = build::mk_access_(cx, span, self_field, method_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ other_field_ref ]);\n+    let self_call = build::mk_method_call(cx, span,\n+                                          self_field, method_ident,\n+                                          ~[ other_field_ref ]);\n \n     // Connect to the outer expression if necessary.\n     *chain_expr = match *chain_expr {"}, {"sha": "3c1ee7e0296448ea8833c9691799555ff2558a59", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -125,14 +125,11 @@ fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n \n     // Call the substructure method.\n     let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n-    let self_method = build::mk_access_(cx,\n-                                        span,\n-                                        self_field,\n-                                        iter_bytes_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ lsb0_expr, f_expr ]);\n+    let self_call = build::mk_method_call(cx,\n+                                          span,\n+                                          self_field,\n+                                          iter_bytes_ident,\n+                                          ~[ lsb0_expr, f_expr ]);\n \n     // Create a statement out of this expression.\n     build::mk_stmt(cx, span, self_call)"}, {"sha": "6044c3ad3d24ba6f689c10b0f325eb1f91ef0b87", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -270,11 +270,11 @@ fn id_ext(cx: @ext_ctxt, +str: ~str) -> ast::ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n-    let e_meth = build::mk_access(cx, sp,\n-                                  ids_ext(cx, ~[~\"ext_cx\"]),\n-                                  id_ext(cx, ~\"ident_of\"));\n     let e_str = build::mk_uniq_str(cx, sp, cx.str_of(ident));\n-    build::mk_call_(cx, sp, e_meth, ~[e_str])\n+    build::mk_method_call(cx, sp,\n+                          build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+                          id_ext(cx, ~\"ident_of\"),\n+                          ~[e_str])\n }\n \n fn mk_bytepos(cx: @ext_ctxt, sp: span, bpos: BytePos) -> @ast::expr {\n@@ -462,11 +462,10 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n                                ids_ext(cx, ~[~\"tt_tok\"]),\n                                ~[e_sp, mk_token(cx, sp, *tok)]);\n             let e_push =\n-                build::mk_call_(cx, sp,\n-                                build::mk_access(cx, sp,\n-                                                 ids_ext(cx, ~[~\"tt\"]),\n-                                                 id_ext(cx, ~\"push\")),\n-                                ~[e_tok]);\n+                build::mk_method_call(cx, sp,\n+                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n+                                      id_ext(cx, ~\"push\"),\n+                                      ~[e_tok]);\n             ~[build::mk_stmt(cx, sp, e_push)]\n \n         }\n@@ -479,21 +478,17 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n             // tt.push_all_move($ident.to_tokens(ext_cx))\n \n             let e_to_toks =\n-                build::mk_call_(cx, sp,\n-                                build::mk_access\n-                                (cx, sp,\n-                                 ~[ident],\n-                                 id_ext(cx, ~\"to_tokens\")),\n-                                ~[build::mk_path(cx, sp,\n-                                        ids_ext(cx, ~[~\"ext_cx\"]))]);\n+                build::mk_method_call(cx, sp,\n+                                      build::mk_path(cx, sp, ~[ident]),\n+                                      id_ext(cx, ~\"to_tokens\"),\n+                                      ~[build::mk_path(cx, sp,\n+                                                       ids_ext(cx, ~[~\"ext_cx\"]))]);\n \n             let e_push =\n-                build::mk_call_(cx, sp,\n-                                build::mk_access\n-                                (cx, sp,\n-                                 ids_ext(cx, ~[~\"tt\"]),\n-                                 id_ext(cx, ~\"push_all_move\")),\n-                                ~[e_to_toks]);\n+                build::mk_method_call(cx, sp,\n+                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n+                                      id_ext(cx, ~\"push_all_move\"),\n+                                      ~[e_to_toks]);\n \n             ~[build::mk_stmt(cx, sp, e_push)]\n         }\n@@ -562,11 +557,10 @@ fn expand_tts(cx: @ext_ctxt,\n     // of quotes, for example) but at this point it seems not likely to be\n     // worth the hassle.\n \n-    let e_sp = build::mk_call_(cx, sp,\n-                               build::mk_access(cx, sp,\n-                                                ids_ext(cx, ~[~\"ext_cx\"]),\n-                                                id_ext(cx, ~\"call_site\")),\n-                               ~[]);\n+    let e_sp = build::mk_method_call(cx, sp,\n+                                     build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+                                     id_ext(cx, ~\"call_site\"),\n+                                     ~[]);\n \n     let stmt_let_sp = build::mk_local(cx, sp, false,\n                                       id_ext(cx, ~\"sp\"),\n@@ -590,13 +584,13 @@ fn expand_parse_call(cx: @ext_ctxt,\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || build::mk_call_(\n-        cx, sp, build::mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                                 id_ext(cx, ~\"cfg\")), ~[]);\n+    let cfg_call = || build::mk_method_call(\n+        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+        id_ext(cx, ~\"cfg\"), ~[]);\n \n-    let parse_sess_call = || build::mk_call_(\n-        cx, sp, build::mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                                 id_ext(cx, ~\"parse_sess\")), ~[]);\n+    let parse_sess_call = || build::mk_method_call(\n+        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+        id_ext(cx, ~\"parse_sess\"), ~[]);\n \n     let new_parser_call =\n         build::mk_call_global(cx, sp,\n@@ -609,9 +603,9 @@ fn expand_parse_call(cx: @ext_ctxt,\n                                 cfg_call(),\n                                 tts_expr]);\n \n-    build::mk_call_(cx, sp,\n-                    build::mk_access_(cx, sp, new_parser_call,\n-                                      id_ext(cx, parse_method)),\n-                    arg_exprs)\n+    build::mk_method_call(cx, sp,\n+                          new_parser_call,\n+                          id_ext(cx, parse_method),\n+                          arg_exprs)\n }\n "}, {"sha": "f24875cbf8e0b0c17d9fa57413564dcd06aa2c37", "filename": "src/test/run-pass/issue-4036.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7c74d0225354b93bf7649fed8cdd2774480106/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=3f7c74d0225354b93bf7649fed8cdd2774480106", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #4036: Test for an issue that arose around fixing up type inference\n+// byproducts in vtable records.\n+\n+extern mod std;\n+use self::std::json;\n+use self::std::serialize;\n+\n+pub fn main() {\n+    let json = json::from_str(\"[1]\").unwrap();\n+    let _x: ~[int] = serialize::Decodable::decode(&json::Decoder(json));\n+}"}]}