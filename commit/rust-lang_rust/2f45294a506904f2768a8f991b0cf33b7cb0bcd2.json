{"sha": "2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNDUyOTRhNTA2OTA0ZjI3NjhhOGY5OTFiMGNmMzNiN2NiMGJjZDI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-06-17T18:54:22Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-30T21:12:12Z"}, "message": "Clean-up assignment checking in borrowck", "tree": {"sha": "b91ac91610b208802077a1929eb164cacb42c8c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b91ac91610b208802077a1929eb164cacb42c8c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "html_url": "https://github.com/rust-lang/rust/commit/2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40db46c6ba0d59e5ad9aa056a73055d2d3b83d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/40db46c6ba0d59e5ad9aa056a73055d2d3b83d04", "html_url": "https://github.com/rust-lang/rust/commit/40db46c6ba0d59e5ad9aa056a73055d2d3b83d04"}], "stats": {"total": 401, "additions": 137, "deletions": 264}, "files": [{"sha": "f06dc105d9cc1389e803a82749b76a308b87d905", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 21, "deletions": 186, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "patch": "@@ -565,13 +565,6 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         true\n     }\n \n-    fn is_local_variable_or_arg(&self, cmt: mc::cmt<'tcx>) -> bool {\n-        match cmt.cat {\n-          mc::cat_local(_) => true,\n-          _ => false\n-        }\n-    }\n-\n     fn consume_common(&self,\n                       id: ast::NodeId,\n                       span: Span,\n@@ -793,198 +786,40 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         mode: euv::MutateMode) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n-        // Mutable values can be assigned, as long as they obey loans\n-        // and aliasing restrictions:\n-        if assignee_cmt.mutbl.is_mutable() {\n-            if check_for_aliasable_mutable_writes(self, assignment_span, assignee_cmt.clone()) {\n-                if mode != euv::Init {\n-                    check_for_assignment_to_borrowed_path(\n-                        self, assignment_id, assignment_span, assignee_cmt.clone());\n-                    mark_variable_as_used_mut(self, assignee_cmt);\n-                }\n-            }\n-\n-            return;\n-        }\n-\n-        // Initializations are OK if and only if they aren't partial\n-        // reinitialization of a partially-uninitialized structure.\n+        // Initializations never cause borrow errors as they only\n+        // affect a fresh local.\n         if mode == euv::Init {\n             return\n         }\n \n-        // For immutable local variables, assignments are legal\n-        // if they cannot already have been assigned\n-        if self.is_local_variable_or_arg(assignee_cmt.clone()) {\n-            assert!(assignee_cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(&assignee_cmt).unwrap();\n-            self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n-                self.bccx.report_reassigned_immutable_variable(\n-                    assignment_span,\n-                    &*lp,\n-                    assign);\n+        // Check that we don't invalidate any outstanding loans\n+        if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n+            let scope = region::CodeExtent::from_node_id(assignment_id);\n+            self.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n+                self.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                 false\n             });\n-            return;\n-        }\n-\n-        // Otherwise, just a plain error.\n-        match assignee_cmt.note {\n-            mc::NoteClosureEnv(upvar_id) => {\n-                // If this is an `Fn` closure, it simply can't mutate upvars.\n-                // If it's an `FnMut` closure, the original variable was declared immutable.\n-                // We need to determine which is the case here.\n-                let kind = match assignee_cmt.upvar().unwrap().cat {\n-                    mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n-                    _ => unreachable!()\n-                };\n-                if kind == ty::FnClosureKind {\n-                    self.bccx.span_err(\n-                        assignment_span,\n-                        &format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt)));\n-                    self.bccx.span_help(\n-                        self.tcx().map.span(upvar_id.closure_expr_id),\n-                        \"consider changing this closure to take self by mutable reference\");\n-                } else {\n-                    self.bccx.span_err(\n-                        assignment_span,\n-                        &format!(\"cannot assign to {} {}\",\n-                                assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)));\n-                }\n-            }\n-            _ => match opt_loan_path(&assignee_cmt) {\n-                Some(lp) => {\n-                    self.bccx.span_err(\n-                        assignment_span,\n-                        &format!(\"cannot assign to {} {} `{}`\",\n-                                assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp)));\n-                }\n-                None => {\n-                    self.bccx.span_err(\n-                        assignment_span,\n-                        &format!(\"cannot assign to {} {}\",\n-                                assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)));\n-                }\n-            }\n-        }\n-        return;\n-\n-        fn mark_variable_as_used_mut<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n-                                               mut cmt: mc::cmt<'tcx>) {\n-            //! If the mutability of the `cmt` being written is inherited\n-            //! from a local variable, liveness will\n-            //! not have been able to detect that this variable's mutability\n-            //! is important, so we must add the variable to the\n-            //! `used_mut_nodes` table here.\n-\n-            loop {\n-                debug!(\"mark_variable_as_used_mut(cmt={:?})\", cmt);\n-                match cmt.cat.clone() {\n-                    mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: id, .. }, .. }) |\n-                    mc::cat_local(id) => {\n-                        this.tcx().used_mut_nodes.borrow_mut().insert(id);\n-                        return;\n-                    }\n-\n-                    mc::cat_rvalue(..) |\n-                    mc::cat_static_item |\n-                    mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-                    mc::cat_deref(_, _, mc::Implicit(..)) => {\n-                        assert_eq!(cmt.mutbl, mc::McDeclared);\n-                        return;\n-                    }\n-\n-                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) => {\n-                        assert_eq!(cmt.mutbl, mc::McDeclared);\n-                        // We need to drill down to upvar if applicable\n-                        match cmt.upvar() {\n-                            Some(b) => cmt = b,\n-                            None => return\n-                        }\n-                    }\n-\n-                    mc::cat_deref(b, _, mc::Unique) => {\n-                        assert_eq!(cmt.mutbl, mc::McInherited);\n-                        cmt = b;\n-                    }\n-\n-                    mc::cat_downcast(b, _) |\n-                    mc::cat_interior(b, _) => {\n-                        assert_eq!(cmt.mutbl, mc::McInherited);\n-                        cmt = b;\n-                    }\n-                }\n-            }\n         }\n \n-        fn check_for_aliasable_mutable_writes<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n-                                                        span: Span,\n-                                                        cmt: mc::cmt<'tcx>) -> bool {\n-            //! Safety checks related to writes to aliasable, mutable locations\n-\n-            let guarantor = cmt.guarantor();\n-            debug!(\"check_for_aliasable_mutable_writes(cmt={:?}, guarantor={:?})\",\n-                   cmt, guarantor);\n-            if let mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) = guarantor.cat {\n-                // Statically prohibit writes to `&mut` when aliasable\n-                check_for_aliasability_violation(this, span, b.clone());\n+        // Local variables can always be assigned to, expect for reassignments\n+        // of immutable variables (or assignments that invalidate loans,\n+        // of course).\n+        if let mc::cat_local(local_id) = assignee_cmt.cat {\n+            if assignee_cmt.mutbl.is_mutable() {\n+                self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n             }\n \n-            return true; // no errors reported\n-        }\n-\n-        fn check_for_aliasability_violation<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n-                                                      span: Span,\n-                                                      cmt: mc::cmt<'tcx>)\n-                                                      -> bool {\n-            match cmt.freely_aliasable(this.tcx()) {\n-                mc::Aliasability::NonAliasable => {\n-                    return true;\n-                }\n-                mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)) => {\n-                    return true;\n-                }\n-                mc::Aliasability::ImmutableUnique(_) => {\n-                    this.bccx.report_aliasability_violation(\n-                        span,\n-                        MutabilityViolation,\n-                        mc::AliasableReason::UnaliasableImmutable);\n-                    return false;\n-                }\n-                mc::Aliasability::FreelyAliasable(cause) => {\n-                    this.bccx.report_aliasability_violation(\n-                        span,\n-                        MutabilityViolation,\n-                        cause);\n-                    return false;\n+            let lp = opt_loan_path(&assignee_cmt).unwrap();\n+            self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n+                if !assignee_cmt.mutbl.is_mutable() {\n+                    self.bccx.report_reassigned_immutable_variable(\n+                        assignment_span,\n+                        &*lp,\n+                        assign);\n                 }\n-            }\n-        }\n-\n-        fn check_for_assignment_to_borrowed_path<'a, 'tcx>(\n-            this: &CheckLoanCtxt<'a, 'tcx>,\n-            assignment_id: ast::NodeId,\n-            assignment_span: Span,\n-            assignee_cmt: mc::cmt<'tcx>)\n-        {\n-            //! Check for assignments that violate the terms of an\n-            //! outstanding loan.\n-\n-            let loan_path = match opt_loan_path(&assignee_cmt) {\n-                Some(lp) => lp,\n-                None => { return; /* no loan path, can't be any loans */ }\n-            };\n-\n-            let scope = region::CodeExtent::from_node_id(assignment_id);\n-            this.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n-                this.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                 false\n             });\n+            return\n         }\n     }\n "}, {"sha": "919bc45f00ddfe955e4ae188574ef83af8cb3a54", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n     fn report_error(&self, code: bckerr_code) {\n         self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n                                     span: self.span,\n-                                    cause: self.cause,\n+                                    cause: BorrowViolation(self.cause),\n                                     code: code });\n     }\n }"}, {"sha": "39b9f07604353e864337938e1dd5b6c988d40f9a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 96, "deletions": 59, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "patch": "@@ -151,22 +151,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n-        let opt_lp = opt_loan_path(&assignee_cmt);\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={:?}) opt_lp={:?}\",\n-               assignment_id, assignee_cmt, opt_lp);\n-\n-        match opt_lp {\n-            Some(lp) => {\n-                gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                assignment_id, assignment_span,\n-                                                lp, assignee_cmt.id, mode);\n-            }\n-            None => {\n-                // This can occur with e.g. `*foo() = 5`.  In such\n-                // cases, there is no need to check for conflicts\n-                // with moves etc, just ignore.\n-            }\n-        }\n+        self.guarantee_assignment_valid(assignment_id,\n+                                        assignment_span,\n+                                        assignee_cmt,\n+                                        mode);\n     }\n \n     fn decl_without_init(&mut self, id: ast::NodeId, span: Span) {\n@@ -177,7 +165,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n /// Implements the A-* rules in README.md.\n fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 borrow_span: Span,\n-                                loan_cause: euv::LoanCause,\n+                                loan_cause: AliasableViolationKind,\n                                 cmt: mc::cmt<'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n@@ -203,15 +191,15 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         (mc::Aliasability::ImmutableUnique(_), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n-                        BorrowViolation(loan_cause),\n+                        loan_cause,\n                         mc::AliasableReason::UnaliasableImmutable);\n             Err(())\n         }\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n-                        BorrowViolation(loan_cause),\n+                        loan_cause,\n                         alias_cause);\n             Err(())\n         }\n@@ -221,9 +209,94 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     }\n }\n \n+/// Implements the M-* rules in README.md.\n+fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                              borrow_span: Span,\n+                              cause: AliasableViolationKind,\n+                              cmt: mc::cmt<'tcx>,\n+                              req_kind: ty::BorrowKind)\n+                              -> Result<(),()> {\n+    debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n+           cause, cmt, req_kind);\n+    match req_kind {\n+        ty::UniqueImmBorrow | ty::ImmBorrow => {\n+            match cmt.mutbl {\n+                // I am intentionally leaving this here to help\n+                // refactoring if, in the future, we should add new\n+                // kinds of mutability.\n+                mc::McImmutable | mc::McDeclared | mc::McInherited => {\n+                    // both imm and mut data can be lent as imm;\n+                    // for mutable data, this is a freeze\n+                    Ok(())\n+                }\n+            }\n+        }\n+\n+        ty::MutBorrow => {\n+            // Only mutable data can be lent as mutable.\n+            if !cmt.mutbl.is_mutable() {\n+                Err(bccx.report(BckError { span: borrow_span,\n+                                           cause: cause,\n+                                           cmt: cmt,\n+                                           code: err_mutbl }))\n+            } else {\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n+    /// Guarantees that `cmt` is assignable, or reports an error.\n+    fn guarantee_assignment_valid(&mut self,\n+                                  assignment_id: ast::NodeId,\n+                                  assignment_span: Span,\n+                                  cmt: mc::cmt<'tcx>,\n+                                  mode: euv::MutateMode) {\n+\n+        let opt_lp = opt_loan_path(&cmt);\n+        debug!(\"guarantee_assignment_valid(assignment_id={}, cmt={:?}) opt_lp={:?}\",\n+               assignment_id, cmt, opt_lp);\n+\n+        if let mc::cat_local(..) = cmt.cat {\n+            // Only re-assignments to locals require it to be\n+            // mutable - this is checked in check_loans.\n+        } else {\n+            // Check that we don't allow assignments to non-mutable data.\n+            if check_mutability(self.bccx, assignment_span, MutabilityViolation,\n+                                cmt.clone(), ty::MutBorrow).is_err() {\n+                return; // reported an error, no sense in reporting more.\n+            }\n+        }\n+\n+        // Check that we don't allow assignments to aliasable data\n+        if check_aliasability(self.bccx, assignment_span, MutabilityViolation,\n+                              cmt.clone(), ty::MutBorrow).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n+\n+        match opt_lp {\n+            Some(lp) => {\n+                if let mc::cat_local(..) = cmt.cat {\n+                    // Only re-assignments to locals require it to be\n+                    // mutable - this is checked in check_loans.\n+                } else {\n+                    self.mark_loan_path_as_mutated(&lp);\n+                }\n+                gather_moves::gather_assignment(self.bccx, &self.move_data,\n+                                                assignment_id, assignment_span,\n+                                                lp, cmt.id, mode);\n+            }\n+            None => {\n+                // This can occur with e.g. `*foo() = 5`.  In such\n+                // cases, there is no need to check for conflicts\n+                // with moves etc, just ignore.\n+            }\n+        }\n+    }\n+\n     /// Guarantees that `addr_of(cmt)` will be valid for the duration of `static_scope_r`, or\n     /// reports an error.  This may entail taking out loans, which will be added to the\n     /// `req_loan_map`.\n@@ -256,13 +329,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n-        if check_mutability(self.bccx, borrow_span, cause,\n+        if check_mutability(self.bccx, borrow_span, BorrowViolation(cause),\n                             cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n-        if check_aliasability(self.bccx, borrow_span, cause,\n+        if check_aliasability(self.bccx, borrow_span, BorrowViolation(cause),\n                               cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n@@ -368,43 +441,6 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             //        restrictions: restrictions\n             //    }\n         // }\n-\n-        fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      borrow_span: Span,\n-                                      cause: euv::LoanCause,\n-                                      cmt: mc::cmt<'tcx>,\n-                                      req_kind: ty::BorrowKind)\n-                                      -> Result<(),()> {\n-            //! Implements the M-* rules in README.md.\n-            debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n-                   cause, cmt, req_kind);\n-            match req_kind {\n-                ty::UniqueImmBorrow | ty::ImmBorrow => {\n-                    match cmt.mutbl {\n-                        // I am intentionally leaving this here to help\n-                        // refactoring if, in the future, we should add new\n-                        // kinds of mutability.\n-                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n-                            // both imm and mut data can be lent as imm;\n-                            // for mutable data, this is a freeze\n-                            Ok(())\n-                        }\n-                    }\n-                }\n-\n-                ty::MutBorrow => {\n-                    // Only mutable data can be lent as mutable.\n-                    if !cmt.mutbl.is_mutable() {\n-                        Err(bccx.report(BckError { span: borrow_span,\n-                                                   cause: cause,\n-                                                   cmt: cmt,\n-                                                   code: err_mutbl }))\n-                    } else {\n-                        Ok(())\n-                    }\n-                }\n-            }\n-        }\n     }\n \n     pub fn mark_loan_path_as_mutated(&self, loan_path: &LoanPath) {\n@@ -495,7 +531,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n-            if check_aliasability(self.bccx, ex.span, euv::AddrOf,\n+            if check_aliasability(self.bccx, ex.span,\n+                                  BorrowViolation(euv::AddrOf),\n                                   base_cmt, borrow_kind).is_err() {\n                 return; // reported an error, no sense in reporting more.\n             }"}, {"sha": "4c186dd840610a071816952be41a50c671314d4f", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                             self.bccx.report(\n                                 BckError {\n                                     span: self.span,\n-                                    cause: self.cause,\n+                                    cause: BorrowViolation(self.cause),\n                                     cmt: cmt_base,\n                                     code: err_borrowed_pointer_too_short(\n                                         self.loan_region, lt)});"}, {"sha": "65e3e443e7de2e0222d89212370a628d10998a61", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f45294a506904f2768a8f991b0cf33b7cb0bcd2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=2f45294a506904f2768a8f991b0cf33b7cb0bcd2", "patch": "@@ -546,12 +546,12 @@ pub enum bckerr_code {\n #[derive(PartialEq)]\n pub struct BckError<'tcx> {\n     span: Span,\n-    cause: euv::LoanCause,\n+    cause: AliasableViolationKind,\n     cmt: mc::cmt<'tcx>,\n     code: bckerr_code\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum AliasableViolationKind {\n     MutabilityViolation,\n     BorrowViolation(euv::LoanCause)\n@@ -576,8 +576,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         // Catch and handle some particular cases.\n         match (&err.code, &err.cause) {\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic), &euv::ClosureCapture(span)) |\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..)), &euv::ClosureCapture(span)) => {\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic),\n+             &BorrowViolation(euv::ClosureCapture(span))) |\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..)),\n+             &BorrowViolation(euv::ClosureCapture(span))) => {\n                 return self.report_out_of_scope_escaping_closure_capture(&err, span);\n             }\n             _ => { }\n@@ -796,10 +798,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_end_note(s, m);\n     }\n \n-    pub fn span_help(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_help(s, m);\n-    }\n-\n     pub fn fileline_help(&self, s: Span, m: &str) {\n         self.tcx.sess.fileline_help(s, m);\n     }\n@@ -827,19 +825,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n \n                 match err.cause {\n-                    euv::ClosureCapture(_) => {\n+                    MutabilityViolation => {\n+                        format!(\"cannot assign to {}\", descr)\n+                    }\n+                    BorrowViolation(euv::ClosureCapture(_)) => {\n                         format!(\"closure cannot assign to {}\", descr)\n                     }\n-                    euv::OverloadedOperator |\n-                    euv::AddrOf |\n-                    euv::RefBinding |\n-                    euv::AutoRef |\n-                    euv::AutoUnsafe |\n-                    euv::ForLoop |\n-                    euv::MatchDiscriminant => {\n+                    BorrowViolation(euv::OverloadedOperator) |\n+                    BorrowViolation(euv::AddrOf) |\n+                    BorrowViolation(euv::RefBinding) |\n+                    BorrowViolation(euv::AutoRef) |\n+                    BorrowViolation(euv::AutoUnsafe) |\n+                    BorrowViolation(euv::ForLoop) |\n+                    BorrowViolation(euv::MatchDiscriminant) => {\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n-                    euv::ClosureInvocation => {\n+                    BorrowViolation(euv::ClosureInvocation) => {\n                         self.tcx.sess.span_bug(err.span,\n                             \"err_mutbl with a closure invocation\");\n                     }"}]}