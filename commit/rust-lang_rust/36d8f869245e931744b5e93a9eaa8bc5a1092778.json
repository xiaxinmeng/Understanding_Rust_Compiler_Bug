{"sha": "36d8f869245e931744b5e93a9eaa8bc5a1092778", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZDhmODY5MjQ1ZTkzMTc0NGI1ZTkzYTllYWE4YmM1YTEwOTI3Nzg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T00:19:11Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T22:59:01Z"}, "message": "librustc_lexer: Unconfigure tests during normal build", "tree": {"sha": "467b916717d961bce5197b74fe5fad153c09858d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467b916717d961bce5197b74fe5fad153c09858d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36d8f869245e931744b5e93a9eaa8bc5a1092778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36d8f869245e931744b5e93a9eaa8bc5a1092778", "html_url": "https://github.com/rust-lang/rust/commit/36d8f869245e931744b5e93a9eaa8bc5a1092778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36d8f869245e931744b5e93a9eaa8bc5a1092778/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d511cca5c3ba900b1997b5fa635140aaff8cdc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d511cca5c3ba900b1997b5fa635140aaff8cdc2", "html_url": "https://github.com/rust-lang/rust/commit/7d511cca5c3ba900b1997b5fa635140aaff8cdc2"}], "stats": {"total": 560, "additions": 279, "deletions": 281}, "files": [{"sha": "d8e00d4c7c5ea9a66a97c24f8d07eb4789005804", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 3, "deletions": 280, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/36d8f869245e931744b5e93a9eaa8bc5a1092778/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d8f869245e931744b5e93a9eaa8bc5a1092778/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=36d8f869245e931744b5e93a9eaa8bc5a1092778", "patch": "@@ -4,6 +4,9 @@\n use std::str::Chars;\n use std::ops::Range;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Debug, PartialEq, Eq)]\n pub enum EscapeError {\n     ZeroChars,\n@@ -320,283 +323,3 @@ fn byte_from_char(c: char) -> u8 {\n fn is_ascii(x: u32) -> bool {\n     x <= 0x7F\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_unescape_char_bad() {\n-        fn check(literal_text: &str, expected_error: EscapeError) {\n-            let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n-            assert_eq!(actual_result, Err(expected_error));\n-        }\n-\n-        check(\"\", EscapeError::ZeroChars);\n-        check(r\"\\\", EscapeError::LoneSlash);\n-\n-        check(\"\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\t\", EscapeError::EscapeOnlyChar);\n-        check(\"'\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\", EscapeError::BareCarriageReturn);\n-\n-        check(\"spam\", EscapeError::MoreThanOneChar);\n-        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n-        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n-        check(r\"\\na\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n-        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\u{0}x\", EscapeError::MoreThanOneChar);\n-        check(r\"\\u{1F63b}}\", EscapeError::MoreThanOneChar);\n-\n-        check(r\"\\v\", EscapeError::InvalidEscape);\n-        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n-        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n-\n-        check(r\"\\x\", EscapeError::TooShortHexEscape);\n-        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xff\", EscapeError::OutOfRangeHexEscape);\n-        check(r\"\\xFF\", EscapeError::OutOfRangeHexEscape);\n-        check(r\"\\x80\", EscapeError::OutOfRangeHexEscape);\n-\n-        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n-        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n-        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n-        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n-        check(r\"\\u{FFFFFF}\", EscapeError::OutOfRangeUnicodeEscape);\n-        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n-        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n-\n-        check(r\"\\u{DC00}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DDDD}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DFFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n-\n-        check(r\"\\u{D800}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DAAA}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DBFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n-    }\n-\n-    #[test]\n-    fn test_unescape_char_good() {\n-        fn check(literal_text: &str, expected_char: char) {\n-            let actual_result = unescape_char(literal_text);\n-            assert_eq!(actual_result, Ok(expected_char));\n-        }\n-\n-        check(\"a\", 'a');\n-        check(\"\u044b\", '\u044b');\n-        check(\"\ud83e\udd80\", '\ud83e\udd80');\n-\n-        check(r#\"\\\"\"#, '\"');\n-        check(r\"\\n\", '\\n');\n-        check(r\"\\r\", '\\r');\n-        check(r\"\\t\", '\\t');\n-        check(r\"\\\\\", '\\\\');\n-        check(r\"\\'\", '\\'');\n-        check(r\"\\0\", '\\0');\n-\n-        check(r\"\\x00\", '\\0');\n-        check(r\"\\x5a\", 'Z');\n-        check(r\"\\x5A\", 'Z');\n-        check(r\"\\x7f\", 127 as char);\n-\n-        check(r\"\\u{0}\", '\\0');\n-        check(r\"\\u{000000}\", '\\0');\n-        check(r\"\\u{41}\", 'A');\n-        check(r\"\\u{0041}\", 'A');\n-        check(r\"\\u{00_41}\", 'A');\n-        check(r\"\\u{4__1__}\", 'A');\n-        check(r\"\\u{1F63b}\", '\ud83d\ude3b');\n-    }\n-\n-    #[test]\n-    fn test_unescape_str_good() {\n-        fn check(literal_text: &str, expected: &str) {\n-            let mut buf = Ok(String::with_capacity(literal_text.len()));\n-            unescape_str(literal_text, &mut |range, c| {\n-                if let Ok(b) = &mut buf {\n-                    match c {\n-                        Ok(c) => b.push(c),\n-                        Err(e) => buf = Err((range, e)),\n-                    }\n-                }\n-            });\n-            let buf = buf.as_ref().map(|it| it.as_ref());\n-            assert_eq!(buf, Ok(expected))\n-        }\n-\n-        check(\"foo\", \"foo\");\n-        check(\"\", \"\");\n-        check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n-\n-        check(\"hello \\\\\\n     world\", \"hello world\");\n-        check(\"hello \\\\\\r\\n     world\", \"hello world\");\n-        check(\"thread's\", \"thread's\")\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_bad() {\n-        fn check(literal_text: &str, expected_error: EscapeError) {\n-            let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n-            assert_eq!(actual_result, Err(expected_error));\n-        }\n-\n-        check(\"\", EscapeError::ZeroChars);\n-        check(r\"\\\", EscapeError::LoneSlash);\n-\n-        check(\"\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\t\", EscapeError::EscapeOnlyChar);\n-        check(\"'\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\", EscapeError::BareCarriageReturn);\n-\n-        check(\"spam\", EscapeError::MoreThanOneChar);\n-        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n-        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n-        check(r\"\\na\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n-        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n-\n-        check(r\"\\v\", EscapeError::InvalidEscape);\n-        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n-        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n-\n-        check(r\"\\x\", EscapeError::TooShortHexEscape);\n-        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n-\n-        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n-        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n-        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n-        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n-\n-        check(\"\u044b\", EscapeError::NonAsciiCharInByte);\n-        check(\"\ud83e\udd80\", EscapeError::NonAsciiCharInByte);\n-\n-        check(r\"\\u{0}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{000000}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{41}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{0041}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{00_41}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{4__1__}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{1F63b}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{0}x\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{1F63b}}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{FFFFFF}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DC00}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DDDD}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DFFF}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{D800}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DAAA}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DBFF}\", EscapeError::UnicodeEscapeInByte);\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_good() {\n-        fn check(literal_text: &str, expected_byte: u8) {\n-            let actual_result = unescape_byte(literal_text);\n-            assert_eq!(actual_result, Ok(expected_byte));\n-        }\n-\n-        check(\"a\", b'a');\n-\n-        check(r#\"\\\"\"#, b'\"');\n-        check(r\"\\n\", b'\\n');\n-        check(r\"\\r\", b'\\r');\n-        check(r\"\\t\", b'\\t');\n-        check(r\"\\\\\", b'\\\\');\n-        check(r\"\\'\", b'\\'');\n-        check(r\"\\0\", b'\\0');\n-\n-        check(r\"\\x00\", b'\\0');\n-        check(r\"\\x5a\", b'Z');\n-        check(r\"\\x5A\", b'Z');\n-        check(r\"\\x7f\", 127);\n-        check(r\"\\x80\", 128);\n-        check(r\"\\xff\", 255);\n-        check(r\"\\xFF\", 255);\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_str_good() {\n-        fn check(literal_text: &str, expected: &[u8]) {\n-            let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-            unescape_byte_str(literal_text, &mut |range, c| {\n-                if let Ok(b) = &mut buf {\n-                    match c {\n-                        Ok(c) => b.push(c),\n-                        Err(e) => buf = Err((range, e)),\n-                    }\n-                }\n-            });\n-            let buf = buf.as_ref().map(|it| it.as_ref());\n-            assert_eq!(buf, Ok(expected))\n-        }\n-\n-        check(\"foo\", b\"foo\");\n-        check(\"\", b\"\");\n-        check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n-\n-        check(\"hello \\\\\\n     world\", b\"hello world\");\n-        check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n-        check(\"thread's\", b\"thread's\")\n-    }\n-\n-    #[test]\n-    fn test_unescape_raw_str() {\n-        fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n-            let mut unescaped = Vec::with_capacity(literal.len());\n-            unescape_raw_str(literal, &mut |range, res| unescaped.push((range, res)));\n-            assert_eq!(unescaped, expected);\n-        }\n-\n-        check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n-        check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n-        check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n-    }\n-\n-    #[test]\n-    fn test_unescape_raw_byte_str() {\n-        fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n-            let mut unescaped = Vec::with_capacity(literal.len());\n-            unescape_raw_byte_str(literal, &mut |range, res| unescaped.push((range, res)));\n-            assert_eq!(unescaped, expected);\n-        }\n-\n-        check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n-        check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n-        check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n-        check(\n-            \"\ud83e\udd80a\",\n-            &[(0..4, Err(EscapeError::NonAsciiCharInByteString)), (4..5, Ok(byte_from_char('a')))],\n-        );\n-    }\n-}"}, {"sha": "496527eb265b06f7f825b6b3bb22e3d8bcf77516", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/36d8f869245e931744b5e93a9eaa8bc5a1092778/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d8f869245e931744b5e93a9eaa8bc5a1092778/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=36d8f869245e931744b5e93a9eaa8bc5a1092778", "patch": "@@ -0,0 +1,276 @@\n+use super::*;\n+\n+#[test]\n+fn test_unescape_char_bad() {\n+    fn check(literal_text: &str, expected_error: EscapeError) {\n+        let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n+        assert_eq!(actual_result, Err(expected_error));\n+    }\n+\n+    check(\"\", EscapeError::ZeroChars);\n+    check(r\"\\\", EscapeError::LoneSlash);\n+\n+    check(\"\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\t\", EscapeError::EscapeOnlyChar);\n+    check(\"'\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+    check(\"spam\", EscapeError::MoreThanOneChar);\n+    check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+    check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+    check(r\"\\na\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+    check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\u{0}x\", EscapeError::MoreThanOneChar);\n+    check(r\"\\u{1F63b}}\", EscapeError::MoreThanOneChar);\n+\n+    check(r\"\\v\", EscapeError::InvalidEscape);\n+    check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+    check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+    check(r\"\\x\", EscapeError::TooShortHexEscape);\n+    check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\xff\", EscapeError::OutOfRangeHexEscape);\n+    check(r\"\\xFF\", EscapeError::OutOfRangeHexEscape);\n+    check(r\"\\x80\", EscapeError::OutOfRangeHexEscape);\n+\n+    check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+    check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+    check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+    check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+    check(r\"\\u{FFFFFF}\", EscapeError::OutOfRangeUnicodeEscape);\n+    check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+    check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+\n+    check(r\"\\u{DC00}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DDDD}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DFFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+\n+    check(r\"\\u{D800}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DAAA}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DBFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+}\n+\n+#[test]\n+fn test_unescape_char_good() {\n+    fn check(literal_text: &str, expected_char: char) {\n+        let actual_result = unescape_char(literal_text);\n+        assert_eq!(actual_result, Ok(expected_char));\n+    }\n+\n+    check(\"a\", 'a');\n+    check(\"\u044b\", '\u044b');\n+    check(\"\ud83e\udd80\", '\ud83e\udd80');\n+\n+    check(r#\"\\\"\"#, '\"');\n+    check(r\"\\n\", '\\n');\n+    check(r\"\\r\", '\\r');\n+    check(r\"\\t\", '\\t');\n+    check(r\"\\\\\", '\\\\');\n+    check(r\"\\'\", '\\'');\n+    check(r\"\\0\", '\\0');\n+\n+    check(r\"\\x00\", '\\0');\n+    check(r\"\\x5a\", 'Z');\n+    check(r\"\\x5A\", 'Z');\n+    check(r\"\\x7f\", 127 as char);\n+\n+    check(r\"\\u{0}\", '\\0');\n+    check(r\"\\u{000000}\", '\\0');\n+    check(r\"\\u{41}\", 'A');\n+    check(r\"\\u{0041}\", 'A');\n+    check(r\"\\u{00_41}\", 'A');\n+    check(r\"\\u{4__1__}\", 'A');\n+    check(r\"\\u{1F63b}\", '\ud83d\ude3b');\n+}\n+\n+#[test]\n+fn test_unescape_str_good() {\n+    fn check(literal_text: &str, expected: &str) {\n+        let mut buf = Ok(String::with_capacity(literal_text.len()));\n+        unescape_str(literal_text, &mut |range, c| {\n+            if let Ok(b) = &mut buf {\n+                match c {\n+                    Ok(c) => b.push(c),\n+                    Err(e) => buf = Err((range, e)),\n+                }\n+            }\n+        });\n+        let buf = buf.as_ref().map(|it| it.as_ref());\n+        assert_eq!(buf, Ok(expected))\n+    }\n+\n+    check(\"foo\", \"foo\");\n+    check(\"\", \"\");\n+    check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+\n+    check(\"hello \\\\\\n     world\", \"hello world\");\n+    check(\"hello \\\\\\r\\n     world\", \"hello world\");\n+    check(\"thread's\", \"thread's\")\n+}\n+\n+#[test]\n+fn test_unescape_byte_bad() {\n+    fn check(literal_text: &str, expected_error: EscapeError) {\n+        let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n+        assert_eq!(actual_result, Err(expected_error));\n+    }\n+\n+    check(\"\", EscapeError::ZeroChars);\n+    check(r\"\\\", EscapeError::LoneSlash);\n+\n+    check(\"\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\t\", EscapeError::EscapeOnlyChar);\n+    check(\"'\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+    check(\"spam\", EscapeError::MoreThanOneChar);\n+    check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+    check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+    check(r\"\\na\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+    check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+\n+    check(r\"\\v\", EscapeError::InvalidEscape);\n+    check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+    check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+    check(r\"\\x\", EscapeError::TooShortHexEscape);\n+    check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+\n+    check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+    check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+    check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+    check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+\n+    check(\"\u044b\", EscapeError::NonAsciiCharInByte);\n+    check(\"\ud83e\udd80\", EscapeError::NonAsciiCharInByte);\n+\n+    check(r\"\\u{0}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{000000}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{41}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{0041}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{00_41}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{4__1__}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{1F63b}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{0}x\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{1F63b}}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{FFFFFF}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DC00}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DDDD}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DFFF}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{D800}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DAAA}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DBFF}\", EscapeError::UnicodeEscapeInByte);\n+}\n+\n+#[test]\n+fn test_unescape_byte_good() {\n+    fn check(literal_text: &str, expected_byte: u8) {\n+        let actual_result = unescape_byte(literal_text);\n+        assert_eq!(actual_result, Ok(expected_byte));\n+    }\n+\n+    check(\"a\", b'a');\n+\n+    check(r#\"\\\"\"#, b'\"');\n+    check(r\"\\n\", b'\\n');\n+    check(r\"\\r\", b'\\r');\n+    check(r\"\\t\", b'\\t');\n+    check(r\"\\\\\", b'\\\\');\n+    check(r\"\\'\", b'\\'');\n+    check(r\"\\0\", b'\\0');\n+\n+    check(r\"\\x00\", b'\\0');\n+    check(r\"\\x5a\", b'Z');\n+    check(r\"\\x5A\", b'Z');\n+    check(r\"\\x7f\", 127);\n+    check(r\"\\x80\", 128);\n+    check(r\"\\xff\", 255);\n+    check(r\"\\xFF\", 255);\n+}\n+\n+#[test]\n+fn test_unescape_byte_str_good() {\n+    fn check(literal_text: &str, expected: &[u8]) {\n+        let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n+        unescape_byte_str(literal_text, &mut |range, c| {\n+            if let Ok(b) = &mut buf {\n+                match c {\n+                    Ok(c) => b.push(c),\n+                    Err(e) => buf = Err((range, e)),\n+                }\n+            }\n+        });\n+        let buf = buf.as_ref().map(|it| it.as_ref());\n+        assert_eq!(buf, Ok(expected))\n+    }\n+\n+    check(\"foo\", b\"foo\");\n+    check(\"\", b\"\");\n+    check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+\n+    check(\"hello \\\\\\n     world\", b\"hello world\");\n+    check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n+    check(\"thread's\", b\"thread's\")\n+}\n+\n+#[test]\n+fn test_unescape_raw_str() {\n+    fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n+        let mut unescaped = Vec::with_capacity(literal.len());\n+        unescape_raw_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        assert_eq!(unescaped, expected);\n+    }\n+\n+    check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n+    check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n+    check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n+}\n+\n+#[test]\n+fn test_unescape_raw_byte_str() {\n+    fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n+        let mut unescaped = Vec::with_capacity(literal.len());\n+        unescape_raw_byte_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        assert_eq!(unescaped, expected);\n+    }\n+\n+    check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n+    check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n+    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n+    check(\n+        \"\ud83e\udd80a\",\n+        &[(0..4, Err(EscapeError::NonAsciiCharInByteString)), (4..5, Ok(byte_from_char('a')))],\n+    );\n+}"}, {"sha": "d8ee1ef57b7877f4023c50efef6e53cbbecffc4a", "filename": "src/tools/tidy/src/unit_tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36d8f869245e931744b5e93a9eaa8bc5a1092778/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d8f869245e931744b5e93a9eaa8bc5a1092778/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs?ref=36d8f869245e931744b5e93a9eaa8bc5a1092778", "patch": "@@ -30,7 +30,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n         \"librustc\",\n         \"librustc_data_structures\",\n         \"librustc_incremental/persist\",\n-        \"librustc_lexer/src\",\n         \"librustc_target/spec\",\n         \"librustdoc\",\n         \"libstd\","}]}