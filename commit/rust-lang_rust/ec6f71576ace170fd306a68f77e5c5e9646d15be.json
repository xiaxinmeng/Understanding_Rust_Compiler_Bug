{"sha": "ec6f71576ace170fd306a68f77e5c5e9646d15be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNmY3MTU3NmFjZTE3MGZkMzA2YTY4Zjc3ZTVjNWU5NjQ2ZDE1YmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-05T14:19:12Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-05T14:19:12Z"}, "message": "Merge #1491\n\n1491: More clippy r=matklad a=kjeremy\n\nA few more clippy changes.\r\n\r\nI'm a little unsure of the second commit. It's the trivially_copy_pass_by_ref lint and there are a number of places in the code we could use it if it makes sense.\n\nCo-authored-by: Jeremy Kolb <kjeremy@gmail.com>", "tree": {"sha": "d39853a3366ea849b60b342240a5908f16899dcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d39853a3366ea849b60b342240a5908f16899dcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec6f71576ace170fd306a68f77e5c5e9646d15be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6f71576ace170fd306a68f77e5c5e9646d15be", "html_url": "https://github.com/rust-lang/rust/commit/ec6f71576ace170fd306a68f77e5c5e9646d15be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec6f71576ace170fd306a68f77e5c5e9646d15be/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "3be2d1db6c04a99efdd32b1af724caeb10d9676b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3be2d1db6c04a99efdd32b1af724caeb10d9676b", "html_url": "https://github.com/rust-lang/rust/commit/3be2d1db6c04a99efdd32b1af724caeb10d9676b"}, {"sha": "98d769a799e430f152e573c28f101d9d6aee5376", "url": "https://api.github.com/repos/rust-lang/rust/commits/98d769a799e430f152e573c28f101d9d6aee5376", "html_url": "https://github.com/rust-lang/rust/commit/98d769a799e430f152e573c28f101d9d6aee5376"}], "stats": {"total": 70, "additions": 34, "deletions": 36}, "files": [{"sha": "deef166b565e4d1fb2b7e9254bb5365d8b36ed28", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=ec6f71576ace170fd306a68f77e5c5e9646d15be", "patch": "@@ -23,27 +23,24 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     // We already have some match arms, so we don't provide any assists.\n     // Unless if there is only one trivial match arm possibly created\n     // by match postfix complete. Trivial match arm is the catch all arm.\n-    match match_expr.match_arm_list() {\n-        Some(arm_list) => {\n-            let mut arm_iter = arm_list.arms();\n-            let first = arm_iter.next();\n-\n-            match first {\n-                // If there arm list is empty or there is only one trivial arm, then proceed.\n-                Some(arm) if is_trivial_arm(arm) => {\n-                    if arm_iter.next() != None {\n-                        return None;\n-                    }\n-                }\n-                None => {}\n-\n-                _ => {\n+    if let Some(arm_list) = match_expr.match_arm_list() {\n+        let mut arm_iter = arm_list.arms();\n+        let first = arm_iter.next();\n+\n+        match first {\n+            // If there arm list is empty or there is only one trivial arm, then proceed.\n+            Some(arm) if is_trivial_arm(arm) => {\n+                if arm_iter.next() != None {\n                     return None;\n                 }\n             }\n+            None => {}\n+\n+            _ => {\n+                return None;\n+            }\n         }\n-        _ => {}\n-    }\n+    };\n \n     let expr = match_expr.expr()?;\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, expr.syntax(), None);"}, {"sha": "ad8e10c526d3d743546a17682443b0457efe60db", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=ec6f71576ace170fd306a68f77e5c5e9646d15be", "patch": "@@ -131,7 +131,8 @@ impl CrateGraph {\n         if self.dfs_find(from, to, &mut FxHashSet::default()) {\n             return Err(CyclicDependencies);\n         }\n-        Ok(self.arena.get_mut(&from).unwrap().add_dep(name, to))\n+        self.arena.get_mut(&from).unwrap().add_dep(name, to);\n+        Ok(())\n     }\n \n     pub fn is_empty(&self) -> bool {"}, {"sha": "b2fb5a56394f3e28d5da41d6cee5769433b1bd40", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=ec6f71576ace170fd306a68f77e5c5e9646d15be", "patch": "@@ -240,10 +240,10 @@ impl Module {\n     }\n \n     pub fn path_to_root(self, db: &impl HirDatabase) -> Vec<Module> {\n-        let mut res = vec![self.clone()];\n-        let mut curr = self.clone();\n+        let mut res = vec![self];\n+        let mut curr = self;\n         while let Some(next) = curr.parent(db) {\n-            res.push(next.clone());\n+            res.push(next);\n             curr = next\n         }\n         res\n@@ -299,7 +299,7 @@ impl Module {\n             .collect()\n     }\n \n-    fn with_module_id(&self, module_id: CrateModuleId) -> Module {\n+    fn with_module_id(self, module_id: CrateModuleId) -> Module {\n         Module { module_id, krate: self.krate }\n     }\n }\n@@ -463,33 +463,33 @@ pub struct EnumVariant {\n }\n \n impl EnumVariant {\n-    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.parent.module(db)\n     }\n-    pub fn parent_enum(&self, _db: &impl DefDatabase) -> Enum {\n+    pub fn parent_enum(self, _db: &impl DefDatabase) -> Enum {\n         self.parent\n     }\n \n-    pub fn name(&self, db: &impl DefDatabase) -> Option<Name> {\n+    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n         db.enum_data(self.parent).variants[self.id].name.clone()\n     }\n \n-    pub fn fields(&self, db: &impl HirDatabase) -> Vec<StructField> {\n+    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n         self.variant_data(db)\n             .fields()\n             .into_iter()\n             .flat_map(|it| it.iter())\n-            .map(|(id, _)| StructField { parent: (*self).into(), id })\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n             .collect()\n     }\n \n-    pub fn field(&self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n         self.variant_data(db)\n             .fields()\n             .into_iter()\n             .flat_map(|it| it.iter())\n             .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: (*self).into(), id })\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n     }\n }\n \n@@ -517,11 +517,11 @@ impl DefWithBody {\n     }\n \n     /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n-        match *self {\n-            DefWithBody::Const(ref c) => c.resolver(db),\n-            DefWithBody::Function(ref f) => f.resolver(db),\n-            DefWithBody::Static(ref s) => s.resolver(db),\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n+        match self {\n+            DefWithBody::Const(c) => c.resolver(db),\n+            DefWithBody::Function(f) => f.resolver(db),\n+            DefWithBody::Static(s) => s.resolver(db),\n         }\n     }\n }"}, {"sha": "8322de0a88d431a2a77a9e7abf54424b6b8c0249", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=ec6f71576ace170fd306a68f77e5c5e9646d15be", "patch": "@@ -529,7 +529,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 match matching_def {\n                     Some(_) => {\n                         self.write_assoc_resolution(id, item);\n-                        return matching_def;\n+                        matching_def\n                     }\n                     None => None,\n                 }"}, {"sha": "7eed6c663360fa7df7680650422908c555fc49dd", "filename": "crates/ra_syntax/src/validation/unescape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6f71576ace170fd306a68f77e5c5e9646d15be/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Funescape.rs?ref=ec6f71576ace170fd306a68f77e5c5e9646d15be", "patch": "@@ -262,7 +262,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::Byte\");\n+    assert!(res <= u32::from(u8::max_value()), \"guaranteed because of Mode::Byte\");\n     res as u8\n }\n "}]}