{"sha": "0d3bd7720c50e3ada4bac77331d43926493be4fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkM2JkNzcyMGM1MGUzYWRhNGJhYzc3MzMxZDQzOTI2NDkzYmU0ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-27T21:31:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-27T21:31:13Z"}, "message": "auto merge of #16757 : steveklabnik/rust/lets_not_lie_in_the_concurrency_guide, r=alexcrichton\n\nThis cleans up blatant lies in the concurrency guide, and modernizes it\r\na bit. There's a lot more to do, but until I get to it, let's make it a\r\nlittle bit better.", "tree": {"sha": "523724ec02cf6485fb511f6a80ac7c0d1af619f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/523724ec02cf6485fb511f6a80ac7c0d1af619f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d3bd7720c50e3ada4bac77331d43926493be4fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3bd7720c50e3ada4bac77331d43926493be4fe", "html_url": "https://github.com/rust-lang/rust/commit/0d3bd7720c50e3ada4bac77331d43926493be4fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d3bd7720c50e3ada4bac77331d43926493be4fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2b87e9ff0ffa1e08556bf8f41058f1caeb99ac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b87e9ff0ffa1e08556bf8f41058f1caeb99ac6", "html_url": "https://github.com/rust-lang/rust/commit/f2b87e9ff0ffa1e08556bf8f41058f1caeb99ac6"}, {"sha": "263d65cb01105605609d58b309608fd396cf787b", "url": "https://api.github.com/repos/rust-lang/rust/commits/263d65cb01105605609d58b309608fd396cf787b", "html_url": "https://github.com/rust-lang/rust/commit/263d65cb01105605609d58b309608fd396cf787b"}], "stats": {"total": 399, "additions": 125, "deletions": 274}, "files": [{"sha": "687f2a3a83343ec3906907e4188863351c93a157", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 125, "deletions": 274, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/0d3bd7720c50e3ada4bac77331d43926493be4fe/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d3bd7720c50e3ada4bac77331d43926493be4fe/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=0d3bd7720c50e3ada4bac77331d43926493be4fe", "patch": "@@ -2,113 +2,51 @@\n \n # Introduction\n \n-Rust provides safe concurrency through a combination\n-of lightweight, memory-isolated tasks and message passing.\n-This guide will describe the concurrency model in Rust, how it\n-relates to the Rust type system, and introduce\n-the fundamental library abstractions for constructing concurrent programs.\n-\n-Rust tasks are not the same as traditional threads: rather,\n-they are considered _green threads_, lightweight units of execution that the Rust\n-runtime schedules cooperatively onto a small number of operating system threads.\n-On a multi-core system Rust tasks will be scheduled in parallel by default.\n-Because tasks are significantly\n-cheaper to create than traditional threads, Rust can create hundreds of\n-thousands of concurrent tasks on a typical 32-bit system.\n-In general, all Rust code executes inside a task, including the `main` function.\n-\n-In order to make efficient use of memory Rust tasks have dynamically sized stacks.\n-A task begins its life with a small\n-amount of stack space (currently in the low thousands of bytes, depending on\n-platform), and acquires more stack as needed.\n-Unlike in languages such as C, a Rust task cannot accidentally write to\n-memory beyond the end of the stack, causing crashes or worse.\n+Rust provides safe concurrent abstractions through a number of core library\n+primitives. This guide will describe the concurrency model in Rust, how it\n+relates to the Rust type system, and introduce the fundamental library\n+abstractions for constructing concurrent programs.\n \n Tasks provide failure isolation and recovery. When a fatal error occurs in Rust\n code as a result of an explicit call to `fail!()`, an assertion failure, or\n-another invalid operation, the runtime system destroys the entire\n-task. Unlike in languages such as Java and C++, there is no way to `catch` an\n-exception. Instead, tasks may monitor each other for failure.\n-\n-Tasks use Rust's type system to provide strong memory safety guarantees. In\n-particular, the type system guarantees that tasks cannot share mutable state\n-with each other. Tasks communicate with each other by transferring _owned_\n-data through the global _exchange heap_.\n-\n-## A note about the libraries\n-\n-While Rust's type system provides the building blocks needed for safe\n-and efficient tasks, all of the task functionality itself is implemented\n-in the standard and sync libraries, which are still under development\n-and do not always present a consistent or complete interface.\n-\n-For your reference, these are the standard modules involved in Rust\n-concurrency at this writing:\n-\n-* [`std::task`] - All code relating to tasks and task scheduling,\n-* [`std::comm`] - The message passing interface,\n-* [`sync::DuplexStream`] - An extension of `pipes::stream` that allows both sending and receiving,\n-* [`sync::Arc`] - The Arc (atomically reference counted) type, for safely sharing immutable data,\n-* [`sync::Semaphore`] - A counting, blocking, bounded-waiting semaphore,\n-* [`sync::Mutex`] - A blocking, bounded-waiting, mutual exclusion lock with an associated\n-    FIFO condition variable,\n-* [`sync::RWLock`] - A blocking, no-starvation, reader-writer lock with an associated condvar,\n-* [`sync::Barrier`] - A barrier enables multiple tasks to synchronize the beginning\n-    of some computation,\n-* [`sync::TaskPool`] - A task pool abstraction,\n-* [`sync::Future`] - A type encapsulating the result of a computation which may not be complete,\n-* [`sync::one`] - A \"once initialization\" primitive\n-* [`sync::mutex`] - A proper mutex implementation regardless of the \"flavor of task\" which is\n-    acquiring the lock.\n-\n-[`std::task`]: std/task/index.html\n-[`std::comm`]: std/comm/index.html\n-[`sync::DuplexStream`]: sync/struct.DuplexStream.html\n-[`sync::Arc`]: sync/struct.Arc.html\n-[`sync::Semaphore`]: sync/raw/struct.Semaphore.html\n-[`sync::Mutex`]: sync/struct.Mutex.html\n-[`sync::RWLock`]: sync/struct.RWLock.html\n-[`sync::Barrier`]: sync/struct.Barrier.html\n-[`sync::TaskPool`]: sync/struct.TaskPool.html\n-[`sync::Future`]: sync/struct.Future.html\n-[`sync::one`]: sync/one/index.html\n-[`sync::mutex`]: sync/mutex/index.html\n+another invalid operation, the runtime system destroys the entire task. Unlike\n+in languages such as Java and C++, there is no way to `catch` an exception.\n+Instead, tasks may monitor each other for failure.\n+\n+Tasks use Rust's type system to provide strong memory safety guarantees.  In\n+particular, the type system guarantees that tasks cannot induce a data race\n+from shared mutable state.\n \n # Basics\n \n-The programming interface for creating and managing tasks lives\n-in the `task` module of the `std` library, and is thus available to all\n-Rust code by default. At its simplest, creating a task is a matter of\n-calling the `spawn` function with a closure argument. `spawn` executes the\n-closure in the new task.\n+At its simplest, creating a task is a matter of calling the `spawn` function\n+with a closure argument. `spawn` executes the closure in the new task.\n \n-~~~~\n+```{rust}\n # use std::task::spawn;\n \n // Print something profound in a different task using a named function\n fn print_message() { println!(\"I am running in a different task!\"); }\n spawn(print_message);\n \n // Alternatively, use a `proc` expression instead of a named function.\n-// The `proc` expression evaluates to an (unnamed) owned closure.\n-// That closure will call `println!(...)` when the spawned task runs.\n+// The `proc` expression evaluates to an (unnamed) proc.\n+// That proc will call `println!(...)` when the spawned task runs.\n spawn(proc() println!(\"I am also running in a different task!\") );\n-~~~~\n-\n-In Rust, there is nothing special about creating tasks: a task is not a\n-concept that appears in the language semantics. Instead, Rust's type system\n-provides all the tools necessary to implement safe concurrency: particularly,\n-_owned types_. The language leaves the implementation details to the standard\n-library.\n-\n-The `spawn` function has a very simple type signature: `fn spawn(f:\n-proc())`. Because it accepts only owned closures, and owned closures\n-contain only owned data, `spawn` can safely move the entire closure\n-and all its associated state into an entirely different task for\n-execution. Like any closure, the function passed to `spawn` may capture\n-an environment that it carries across tasks.\n-\n-~~~\n+```\n+\n+In Rust, a task is not a concept that appears in the language semantics.\n+Instead, Rust's type system provides all the tools necessary to implement safe\n+concurrency: particularly, ownership. The language leaves the implementation\n+details to the standard library.\n+\n+The `spawn` function has a very simple type signature: `fn spawn(f: proc():\n+Send)`.  Because it accepts only procs, and procs contain only owned data,\n+`spawn` can safely move the entire proc and all its associated state into an\n+entirely different task for execution. Like any closure, the function passed to\n+`spawn` may capture an environment that it carries across tasks.\n+\n+```{rust}\n # use std::task::spawn;\n # fn generate_task_number() -> int { 0 }\n // Generate some state locally\n@@ -118,27 +56,20 @@ spawn(proc() {\n     // Capture it in the remote task\n     println!(\"I am child number {}\", child_task_number);\n });\n-~~~\n+```\n \n ## Communication\n \n-Now that we have spawned a new task, it would be nice if we could\n-communicate with it. Recall that Rust does not have shared mutable\n-state, so one task may not manipulate variables owned by another task.\n-Instead we use *pipes*.\n-\n-A pipe is simply a pair of endpoints: one for sending messages and another for\n-receiving messages. Pipes are low-level communication building-blocks and so\n-come in a variety of forms, each one appropriate for a different use case. In\n-what follows, we cover the most commonly used varieties.\n+Now that we have spawned a new task, it would be nice if we could communicate\n+with it. For this, we use *channels*. A channel is simply a pair of endpoints:\n+one for sending messages and another for receiving messages.\n \n-The simplest way to create a pipe is to use the `channel`\n-function to create a `(Sender, Receiver)` pair. In Rust parlance, a *sender*\n-is a sending endpoint of a pipe, and a *receiver* is the receiving\n-endpoint. Consider the following example of calculating two results\n-concurrently:\n+The simplest way to create a channel is to use the `channel` function to create a\n+`(Sender, Receiver)` pair. In Rust parlance, a **sender** is a sending endpoint\n+of a channel, and a **receiver** is the receiving endpoint. Consider the following\n+example of calculating two results concurrently:\n \n-~~~~\n+```{rust}\n # use std::task::spawn;\n \n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n@@ -152,56 +83,55 @@ some_other_expensive_computation();\n let result = rx.recv();\n # fn some_expensive_computation() -> int { 42 }\n # fn some_other_expensive_computation() {}\n-~~~~\n+```\n \n Let's examine this example in detail. First, the `let` statement creates a\n stream for sending and receiving integers (the left-hand side of the `let`,\n-`(tx, rx)`, is an example of a *destructuring let*: the pattern separates\n-a tuple into its component parts).\n+`(tx, rx)`, is an example of a destructuring let: the pattern separates a tuple\n+into its component parts).\n \n-~~~~\n+```{rust}\n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n-~~~~\n+```\n \n-The child task will use the sender to send data to the parent task,\n-which will wait to receive the data on the receiver. The next statement\n-spawns the child task.\n+The child task will use the sender to send data to the parent task, which will\n+wait to receive the data on the receiver. The next statement spawns the child\n+task.\n \n-~~~~\n+```{rust}\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (tx, rx) = channel();\n spawn(proc() {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n-~~~~\n+```\n \n-Notice that the creation of the task closure transfers `tx` to the child\n-task implicitly: the closure captures `tx` in its environment. Both `Sender`\n-and `Receiver` are sendable types and may be captured into tasks or otherwise\n+Notice that the creation of the task closure transfers `tx` to the child task\n+implicitly: the closure captures `tx` in its environment. Both `Sender` and\n+`Receiver` are sendable types and may be captured into tasks or otherwise\n transferred between them. In the example, the child task runs an expensive\n computation, then sends the result over the captured channel.\n \n-Finally, the parent continues with some other expensive\n-computation, then waits for the child's result to arrive on the\n-receiver:\n+Finally, the parent continues with some other expensive computation, then waits\n+for the child's result to arrive on the receiver:\n \n-~~~~\n+```{rust}\n # fn some_other_expensive_computation() {}\n # let (tx, rx) = channel::<int>();\n # tx.send(0);\n some_other_expensive_computation();\n let result = rx.recv();\n-~~~~\n+```\n \n The `Sender` and `Receiver` pair created by `channel` enables efficient\n communication between a single sender and a single receiver, but multiple\n senders cannot use a single `Sender` value, and multiple receivers cannot use a\n single `Receiver` value.  What if our example needed to compute multiple\n results across a number of tasks? The following program is ill-typed:\n \n-~~~ {.ignore}\n+```{rust,ignore}\n # fn some_expensive_computation() -> int { 42 }\n let (tx, rx) = channel();\n \n@@ -214,11 +144,11 @@ spawn(proc() {\n spawn(proc() {\n     tx.send(some_expensive_computation());\n });\n-~~~\n+```\n \n Instead we can clone the `tx`, which allows for multiple senders.\n \n-~~~\n+```{rust}\n let (tx, rx) = channel();\n \n for init_val in range(0u, 3) {\n@@ -231,20 +161,19 @@ for init_val in range(0u, 3) {\n \n let result = rx.recv() + rx.recv() + rx.recv();\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n-~~~\n+```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n tasks to send data to a single receiver. It upgrades the channel internally in\n order to allow this functionality, which means that channels that are not\n cloned can avoid the overhead required to handle multiple senders. But this\n fact has no bearing on the channel's usage: the upgrade is transparent.\n \n-Note that the above cloning example is somewhat contrived since\n-you could also simply use three `Sender` pairs, but it serves to\n-illustrate the point. For reference, written with multiple streams, it\n-might look like the example below.\n+Note that the above cloning example is somewhat contrived since you could also\n+simply use three `Sender` pairs, but it serves to illustrate the point. For\n+reference, written with multiple streams, it might look like the example below.\n \n-~~~\n+```{rust}\n # use std::task::spawn;\n \n // Create a vector of ports, one for each child task\n@@ -259,15 +188,16 @@ let rxs = Vec::from_fn(3, |init_val| {\n // Wait on each port, accumulating the results\n let result = rxs.iter().fold(0, |accum, rx| accum + rx.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n-~~~\n+```\n \n ## Backgrounding computations: Futures\n-With `sync::Future`, rust has a mechanism for requesting a computation and getting the result\n-later.\n+\n+With `sync::Future`, rust has a mechanism for requesting a computation and\n+getting the result later.\n \n The basic example below illustrates this.\n \n-~~~\n+```{rust}\n use std::sync::Future;\n \n # fn main() {\n@@ -281,18 +211,20 @@ let mut delayed_fib = Future::spawn(proc() fib(50));\n make_a_sandwich();\n println!(\"fib(50) = {}\", delayed_fib.get())\n # }\n-~~~\n+```\n \n-The call to `future::spawn` returns immediately a `future` object regardless of how long it\n-takes to run `fib(50)`. You can then make yourself a sandwich while the computation of `fib` is\n-running. The result of the execution of the method is obtained by calling `get` on the future.\n-This call will block until the value is available (*i.e.* the computation is complete). Note that\n-the future needs to be mutable so that it can save the result for next time `get` is called.\n+The call to `future::spawn` returns immediately a `future` object regardless of\n+how long it takes to run `fib(50)`. You can then make yourself a sandwich while\n+the computation of `fib` is running. The result of the execution of the method\n+is obtained by calling `get` on the future. This call will block until the\n+value is available (*i.e.* the computation is complete). Note that the future\n+needs to be mutable so that it can save the result for next time `get` is\n+called.\n \n-Here is another example showing how futures allow you to background computations. The workload will\n-be distributed on the available cores.\n+Here is another example showing how futures allow you to background\n+computations. The workload will be distributed on the available cores.\n \n-~~~\n+```{rust}\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n@@ -311,23 +243,25 @@ fn main() {\n     }\n     println!(\"\u03c0^2/6 is not far from : {}\", final_res);\n }\n-~~~\n+```\n \n-## Sharing immutable data without copy: Arc\n+## Sharing without copying: Arc\n \n-To share immutable data between tasks, a first approach would be to only use pipes as we have seen\n-previously. A copy of the data to share would then be made for each task. In some cases, this would\n-add up to a significant amount of wasted memory and would require copying the same data more than\n-necessary.\n+To share data between tasks, a first approach would be to only use channel as\n+we have seen previously. A copy of the data to share would then be made for\n+each task. In some cases, this would add up to a significant amount of wasted\n+memory and would require copying the same data more than necessary.\n \n-To tackle this issue, one can use an Atomically Reference Counted wrapper (`Arc`) as implemented in\n-the `sync` library of Rust. With an Arc, the data will no longer be copied for each task. The Arc\n-acts as a reference to the shared data and only this reference is shared and cloned.\n+To tackle this issue, one can use an Atomically Reference Counted wrapper\n+(`Arc`) as implemented in the `sync` library of Rust. With an Arc, the data\n+will no longer be copied for each task. The Arc acts as a reference to the\n+shared data and only this reference is shared and cloned.\n \n-Here is a small example showing how to use Arcs. We wish to run concurrently several computations on\n-a single large vector of floats. Each task needs the full vector to perform its duty.\n+Here is a small example showing how to use Arcs. We wish to run concurrently\n+several computations on a single large vector of floats. Each task needs the\n+full vector to perform its duty.\n \n-~~~\n+```{rust}\n use std::rand;\n use std::sync::Arc;\n \n@@ -347,26 +281,27 @@ fn main() {\n         });\n     }\n }\n-~~~\n+```\n \n-The function `pnorm` performs a simple computation on the vector (it computes the sum of its items\n-at the power given as argument and takes the inverse power of this value). The Arc on the vector is\n-created by the line:\n+The function `pnorm` performs a simple computation on the vector (it computes\n+the sum of its items at the power given as argument and takes the inverse power\n+of this value). The Arc on the vector is created by the line:\n \n-~~~\n+```{rust}\n # use std::rand;\n # use std::sync::Arc;\n # fn main() {\n # let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n let numbers_arc = Arc::new(numbers);\n # }\n-~~~\n+```\n \n-and a unique clone is captured for each task via a procedure. This only copies the wrapper and not\n-it's contents. Within the task's procedure, the captured Arc reference can be used as an immutable\n-reference to the underlying vector as if it were local.\n+and a clone is captured for each task via a procedure. This only copies\n+the wrapper and not it's contents. Within the task's procedure, the captured\n+Arc reference can be used as a shared reference to the underlying vector as\n+if it were local.\n \n-~~~\n+```{rust}\n # use std::rand;\n # use std::sync::Arc;\n # fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n@@ -380,50 +315,47 @@ spawn(proc() {\n     println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n });\n # }\n-~~~\n-\n-The `arc` module also implements Arcs around mutable data that are not covered here.\n+```\n \n # Handling task failure\n \n Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n (which can also be written with an error string as an argument: `fail!(\n-~reason)`) and the `assert!` construct (which effectively calls `fail!()`\n-if a boolean expression is false) are both ways to raise exceptions. When a\n-task raises an exception the task unwinds its stack---running destructors and\n+~reason)`) and the `assert!` construct (which effectively calls `fail!()` if a\n+boolean expression is false) are both ways to raise exceptions. When a task\n+raises an exception the task unwinds its stack---running destructors and\n freeing memory along the way---and then exits. Unlike exceptions in C++,\n exceptions in Rust are unrecoverable within a single task: once a task fails,\n there is no way to \"catch\" the exception.\n \n While it isn't possible for a task to recover from failure, tasks may notify\n each other of failure. The simplest way of handling task failure is with the\n-`try` function, which is similar to `spawn`, but immediately blocks waiting\n-for the child task to finish. `try` returns a value of type `Result<T,\n-()>`. `Result` is an `enum` type with two variants: `Ok` and `Err`. In this\n+`try` function, which is similar to `spawn`, but immediately blocks waiting for\n+the child task to finish. `try` returns a value of type `Result<T, Box<Any +\n+Send>>`.  `Result` is an `enum` type with two variants: `Ok` and `Err`. In this\n case, because the type arguments to `Result` are `int` and `()`, callers can\n pattern-match on a result to check whether it's an `Ok` result with an `int`\n field (representing a successful result) or an `Err` result (representing\n termination with an error).\n \n-~~~{.ignore .linked-failure}\n+```{rust}\n # use std::task;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, ()> = task::try(proc() {\n+let result: Result<int, Box<std::any::Any + Send>> = task::try(proc() {\n     if some_condition() {\n         calculate_result()\n     } else {\n         fail!(\"oops!\");\n     }\n });\n assert!(result.is_err());\n-~~~\n+```\n \n-Unlike `spawn`, the function spawned using `try` may return a value,\n-which `try` will dutifully propagate back to the caller in a [`Result`]\n-enum. If the child task terminates successfully, `try` will\n-return an `Ok` result; if the child task fails, `try` will return\n-an `Error` result.\n+Unlike `spawn`, the function spawned using `try` may return a value, which\n+`try` will dutifully propagate back to the caller in a [`Result`] enum. If the\n+child task terminates successfully, `try` will return an `Ok` result; if the\n+child task fails, `try` will return an `Error` result.\n \n [`Result`]: std/result/index.html\n \n@@ -432,90 +364,9 @@ an `Error` result.\n > future, it may be possible for tasks to intercept the value passed to\n > `fail!()`.\n \n-TODO: Need discussion of `future_result` in order to make failure\n-modes useful.\n-\n-But not all failures are created equal. In some cases you might need to\n-abort the entire program (perhaps you're writing an assert which, if\n-it trips, indicates an unrecoverable logic error); in other cases you\n-might want to contain the failure at a certain boundary (perhaps a\n-small piece of input from the outside world, which you happen to be\n-processing in parallel, is malformed and its processing task can't\n-proceed).\n-\n-## Creating a task with a bi-directional communication path\n-\n-A very common thing to do is to spawn a child task where the parent\n-and child both need to exchange messages with each other. The\n-function `sync::comm::duplex` supports this pattern.  We'll\n-look briefly at how to use it.\n-\n-To see how `duplex` works, we will create a child task\n-that repeatedly receives a `uint` message, converts it to a string, and sends\n-the string in response.  The child terminates when it receives `0`.\n-Here is the function that implements the child task:\n-\n-~~~\n-#![allow(deprecated)]\n-\n-use std::comm::DuplexStream;\n-# fn main() {\n-fn stringifier(channel: &DuplexStream<String, uint>) {\n-    let mut value: uint;\n-    loop {\n-        value = channel.recv();\n-        channel.send(value.to_string());\n-        if value == 0 { break; }\n-    }\n-}\n-# }\n-~~~\n-\n-The implementation of `DuplexStream` supports both sending and\n-receiving. The `stringifier` function takes a `DuplexStream` that can\n-send strings (the first type parameter) and receive `uint` messages\n-(the second type parameter). The body itself simply loops, reading\n-from the channel and then sending its response back.  The actual\n-response itself is simply the stringified version of the received value,\n-`uint::to_string(value)`.\n-\n-Here is the code for the parent task:\n-\n-~~~\n-#![allow(deprecated)]\n-\n-use std::comm::duplex;\n-# use std::task::spawn;\n-# use std::comm::DuplexStream;\n-# fn stringifier(channel: &DuplexStream<String, uint>) {\n-#     let mut value: uint;\n-#     loop {\n-#         value = channel.recv();\n-#         channel.send(value.to_string());\n-#         if value == 0u { break; }\n-#     }\n-# }\n-# fn main() {\n-\n-let (from_child, to_child) = duplex();\n-\n-spawn(proc() {\n-    stringifier(&to_child);\n-});\n-\n-from_child.send(22);\n-assert!(from_child.recv().as_slice() == \"22\");\n-\n-from_child.send(23);\n-from_child.send(0);\n-\n-assert!(from_child.recv().as_slice() == \"23\");\n-assert!(from_child.recv().as_slice() == \"0\");\n-\n-# }\n-~~~\n-\n-The parent task first calls `DuplexStream` to create a pair of bidirectional\n-endpoints. It then uses `task::spawn` to create the child task, which captures\n-one end of the communication channel.  As a result, both parent and child can\n-send and receive data to and from the other.\n+But not all failures are created equal. In some cases you might need to abort\n+the entire program (perhaps you're writing an assert which, if it trips,\n+indicates an unrecoverable logic error); in other cases you might want to\n+contain the failure at a certain boundary (perhaps a small piece of input from\n+the outside world, which you happen to be processing in parallel, is malformed\n+and its processing task can't proceed)."}]}