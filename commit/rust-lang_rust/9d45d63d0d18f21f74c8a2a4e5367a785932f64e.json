{"sha": "9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNDVkNjNkMGQxOGYyMWY3NGM4YTJhNGU1MzY3YTc4NTkzMmY2NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-14T03:46:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-14T03:46:22Z"}, "message": "auto merge of #15929 : pcwalton/rust/by-ref-closures, r=alexcrichton\n\nby-reference upvars.\r\n\r\nThis partially implements RFC 38. A snapshot will be needed to turn this\r\non, because stage0 cannot yet parse the keyword.\r\n\r\nPart of #12831.\r\n\r\nr? @alexcrichton", "tree": {"sha": "b87ab6a2dd1256c5068314d0773dcf485c58a624", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b87ab6a2dd1256c5068314d0773dcf485c58a624"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "html_url": "https://github.com/rust-lang/rust/commit/9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa98b25c4f0c10729dff37c699904ad57b8fbda8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa98b25c4f0c10729dff37c699904ad57b8fbda8", "html_url": "https://github.com/rust-lang/rust/commit/aa98b25c4f0c10729dff37c699904ad57b8fbda8"}, {"sha": "a63003fe1aac487d3c0c527c4c984375c998de99", "url": "https://api.github.com/repos/rust-lang/rust/commits/a63003fe1aac487d3c0c527c4c984375c998de99", "html_url": "https://github.com/rust-lang/rust/commit/a63003fe1aac487d3c0c527c4c984375c998de99"}], "stats": {"total": 326, "additions": 254, "deletions": 72}, "files": [{"sha": "5f86745f3f2210cb37dfbed38d8e16fe49dda674", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -360,8 +360,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n             plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n-    let freevars = time(time_passes, \"freevar finding\", (), |_|\n-                        freevars::annotate_freevars(&def_map, krate));\n+    let (freevars, capture_modes) =\n+        time(time_passes, \"freevar finding\", (), |_|\n+             freevars::annotate_freevars(&def_map, krate));\n \n     let region_map = time(time_passes, \"region resolution\", (), |_|\n                           middle::region::resolve_crate(&sess, krate));\n@@ -372,8 +373,15 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     let stability_index = time(time_passes, \"stability index\", (), |_|\n                                stability::Index::build(krate));\n \n-    let ty_cx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map,\n-                            freevars, region_map, lang_items, stability_index);\n+    let ty_cx = ty::mk_ctxt(sess,\n+                            def_map,\n+                            named_region_map,\n+                            ast_map,\n+                            freevars,\n+                            capture_modes,\n+                            region_map,\n+                            lang_items,\n+                            stability_index);\n \n     // passes are timed inside typeck\n     typeck::check_crate(&ty_cx, trait_map, krate);"}, {"sha": "633ad8293491b527ddba9ea1b176d38233086db9", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -141,9 +141,10 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_capture_map = 0x53,\n     tag_table_unboxed_closure_type = 0x54,\n     tag_table_upvar_borrow_map = 0x55,\n+    tag_table_capture_modes = 0x56,\n }\n static first_astencode_tag: uint = tag_ast as uint;\n-static last_astencode_tag: uint = tag_table_upvar_borrow_map as uint;\n+static last_astencode_tag: uint = tag_table_capture_modes as uint;\n impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;"}, {"sha": "e31af8b58b9f1bf208950779c65f7bffab7b423a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -18,8 +18,8 @@ use driver::session::Session;\n use metadata::decoder;\n use middle::def;\n use e = metadata::encoder;\n+use middle::freevars::{CaptureMode, freevar_entry};\n use middle::freevars;\n-use middle::freevars::freevar_entry;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n@@ -530,9 +530,14 @@ fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &freevar_entry) {\n     (*fv).encode(rbml_w).unwrap();\n }\n \n+fn encode_capture_mode(rbml_w: &mut Encoder, cm: CaptureMode) {\n+    cm.encode(rbml_w).unwrap();\n+}\n+\n trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry;\n+    fn read_capture_mode(&mut self) -> CaptureMode;\n }\n \n impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n@@ -541,6 +546,11 @@ impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n         let fv: freevar_entry = Decodable::decode(self).unwrap();\n         fv.tr(xcx)\n     }\n+\n+    fn read_capture_mode(&mut self) -> CaptureMode {\n+        let cm: CaptureMode = Decodable::decode(self).unwrap();\n+        cm\n+    }\n }\n \n impl tr for freevar_entry {\n@@ -1096,6 +1106,15 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n+    for &cm in tcx.capture_modes.borrow().find(&id).iter() {\n+        rbml_w.tag(c::tag_table_capture_modes, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                encode_capture_mode(rbml_w, *cm);\n+            })\n+        })\n+    }\n+\n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n     for &pty in tcx.tcache.borrow().find(&lid).iter() {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n@@ -1509,6 +1528,13 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         let ub: ty::UpvarBorrow = Decodable::decode(val_dsr).unwrap();\n                         dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(xcx));\n                     }\n+                    c::tag_table_capture_modes => {\n+                        let capture_mode = val_dsr.read_capture_mode();\n+                        dcx.tcx\n+                           .capture_modes\n+                           .borrow_mut()\n+                           .insert(id, capture_mode);\n+                    }\n                     c::tag_table_tcache => {\n                         let pty = val_dsr.read_polytype(xcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };"}, {"sha": "fd1369439c9a492ebbf5c3167569605580627119", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -291,7 +291,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n             ast::ExprProc(_decl, block) |\n-            ast::ExprFnBlock(_decl, block) => { block.id }\n+            ast::ExprFnBlock(_, _decl, block) => { block.id }\n             _ => fail!(\"encountered non-closure id: {}\", closure_id)\n         },\n         _ => fail!(\"encountered non-expr id: {}\", closure_id)"}, {"sha": "f973b33ef2c862e7c319855e9b5da0921dfbb5bd", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -46,9 +46,9 @@ impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n                 self.visit_expr(&**e, cx);\n                 self.visit_block(&**b, Loop);\n             }\n-            ast::ExprFnBlock(_, ref b) |\n+            ast::ExprFnBlock(_, _, ref b) |\n             ast::ExprProc(_, ref b) |\n-            ast::ExprUnboxedFn(_, ref b) => {\n+            ast::ExprUnboxedFn(_, _, ref b) => {\n                 self.visit_block(&**b, Closure);\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", cx, e.span),"}, {"sha": "b092d45e0396ac021cd521979946138898bfc31c", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 48, "deletions": 19, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -17,14 +17,14 @@ use middle::def;\n use middle::mem_categorization::Typer;\n use middle::resolve;\n use middle::ty;\n-use util::nodemap::{DefIdSet, NodeMap, NodeSet};\n+use util::nodemap::{NodeMap, NodeSet};\n \n+use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::{ast};\n-use syntax::visit;\n use syntax::visit::Visitor;\n+use syntax::visit;\n \n-#[deriving(Show)]\n+#[deriving(Clone, Decodable, Encodable, Show)]\n pub enum CaptureMode {\n     /// Copy/move the value from this llvm ValueRef into the environment.\n     CaptureByValue,\n@@ -43,12 +43,13 @@ pub struct freevar_entry {\n \n pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n \n-pub type UnboxedClosureList = DefIdSet;\n+pub type CaptureModeMap = NodeMap<CaptureMode>;\n \n struct CollectFreevarsVisitor<'a> {\n     seen: NodeSet,\n     refs: Vec<freevar_entry>,\n     def_map: &'a resolve::DefMap,\n+    capture_mode_map: &'a mut CaptureModeMap,\n }\n \n impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n@@ -58,8 +59,27 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, depth: int) {\n         match expr.node {\n-            ast::ExprFnBlock(..) | ast::ExprProc(..) |\n-            ast::ExprUnboxedFn(..) => {\n+            ast::ExprProc(..) => {\n+                self.capture_mode_map.insert(expr.id, CaptureByValue);\n+                visit::walk_expr(self, expr, depth + 1)\n+            }\n+            ast::ExprFnBlock(_, _, _) => {\n+                // NOTE(stage0): After snapshot, change to:\n+                //\n+                //let capture_mode = match capture_clause {\n+                //    ast::CaptureByValue => CaptureByValue,\n+                //    ast::CaptureByRef => CaptureByRef,\n+                //};\n+                let capture_mode = CaptureByRef;\n+                self.capture_mode_map.insert(expr.id, capture_mode);\n+                visit::walk_expr(self, expr, depth + 1)\n+            }\n+            ast::ExprUnboxedFn(capture_clause, _, _) => {\n+                let capture_mode = match capture_clause {\n+                    ast::CaptureByValue => CaptureByValue,\n+                    ast::CaptureByRef => CaptureByRef,\n+                };\n+                self.capture_mode_map.insert(expr.id, capture_mode);\n                 visit::walk_expr(self, expr, depth + 1)\n             }\n             ast::ExprPath(..) => {\n@@ -91,35 +111,41 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n             _ => visit::walk_expr(self, expr, depth)\n         }\n     }\n-\n-\n }\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: &resolve::DefMap, blk: &ast::Block) -> Vec<freevar_entry> {\n+fn collect_freevars(def_map: &resolve::DefMap,\n+                    blk: &ast::Block,\n+                    capture_mode_map: &mut CaptureModeMap)\n+                    -> Vec<freevar_entry> {\n     let mut v = CollectFreevarsVisitor {\n         seen: NodeSet::new(),\n         refs: Vec::new(),\n         def_map: def_map,\n+        capture_mode_map: &mut *capture_mode_map,\n     };\n \n     v.visit_block(blk, 1);\n+\n     v.refs\n }\n \n struct AnnotateFreevarsVisitor<'a> {\n     def_map: &'a resolve::DefMap,\n     freevars: freevar_map,\n+    capture_mode_map: CaptureModeMap,\n }\n \n impl<'a> Visitor<()> for AnnotateFreevarsVisitor<'a> {\n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n                 blk: &ast::Block, s: Span, nid: ast::NodeId, _: ()) {\n-        let vars = collect_freevars(self.def_map, blk);\n+        let vars = collect_freevars(self.def_map,\n+                                    blk,\n+                                    &mut self.capture_mode_map);\n         self.freevars.insert(nid, vars);\n         visit::walk_fn(self, fk, fd, blk, s, ());\n     }\n@@ -131,14 +157,20 @@ impl<'a> Visitor<()> for AnnotateFreevarsVisitor<'a> {\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n-                         -> freevar_map {\n+                         -> (freevar_map, CaptureModeMap) {\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n         freevars: NodeMap::new(),\n+        capture_mode_map: NodeMap::new(),\n     };\n     visit::walk_crate(&mut visitor, krate, ());\n \n-    visitor.freevars\n+    let AnnotateFreevarsVisitor {\n+        freevars,\n+        capture_mode_map,\n+        ..\n+    } = visitor;\n+    (freevars, capture_mode_map)\n }\n \n pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]| -> T) -> T {\n@@ -148,10 +180,7 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]|\n     }\n }\n \n-pub fn get_capture_mode<T: Typer>(tcx: &T, closure_expr_id: ast::NodeId) -> CaptureMode {\n-    let fn_ty = tcx.node_ty(closure_expr_id).ok().expect(\"couldn't find closure ty?\");\n-    match ty::ty_closure_store(fn_ty) {\n-        ty::RegionTraitStore(..) => CaptureByRef,\n-        ty::UniqTraitStore => CaptureByValue\n-    }\n+pub fn get_capture_mode<T:Typer>(tcx: &T, closure_expr_id: ast::NodeId)\n+                        -> CaptureMode {\n+    tcx.capture_mode(closure_expr_id)\n }"}, {"sha": "1e4841787883498e1c0bc5b9682cfcb0fc392388", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -965,9 +965,9 @@ impl<'a> Liveness<'a> {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprFnBlock(_, ref blk) |\n+          ExprFnBlock(_, _, ref blk) |\n           ExprProc(_, ref blk) |\n-          ExprUnboxedFn(_, ref blk) => {\n+          ExprUnboxedFn(_, _, ref blk) => {\n               debug!(\"{} is an ExprFnBlock, ExprProc, or ExprUnboxedFn\",\n                      expr_to_string(expr));\n "}, {"sha": "6ad8bc0c1e9b1b3fb40e83fed57129bcefd82153", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -63,6 +63,7 @@\n #![allow(non_camel_case_types)]\n \n use middle::def;\n+use middle::freevars;\n use middle::ty;\n use middle::typeck;\n use util::nodemap::NodeMap;\n@@ -270,6 +271,8 @@ pub trait Typer {\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n+    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> freevars::CaptureMode;\n }\n \n impl MutabilityCategory {"}, {"sha": "1e4cbdbdb6e5a00e0dcad863bca275dcf616a810", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -5287,9 +5287,9 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr, ());\n             }\n \n-            ExprFnBlock(fn_decl, block) |\n+            ExprFnBlock(_, fn_decl, block) |\n             ExprProc(fn_decl, block) |\n-            ExprUnboxedFn(fn_decl, block) => {\n+            ExprUnboxedFn(_, fn_decl, block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n                                       Some(fn_decl), NoTypeParameters,\n                                       block);"}, {"sha": "4a58a8bba99c87a23ee8ba57bd534ea19535dac9", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -1237,7 +1237,7 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n                                             \"Expected struct type, but not ty_struct\"),\n                 }\n             },\n-            ast::ExprFnBlock(decl, body) => {\n+            ast::ExprFnBlock(_, decl, body) => {\n                 if generated_code(body.span) {\n                     return\n                 }"}, {"sha": "b7bb383ad3cb2e990beb7bda1369e8223f17f133", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -1306,7 +1306,9 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprFnBlock(_, blk) | ast::ExprProc(_, blk) | ast::ExprUnboxedFn(_, blk) => {\n+                ast::ExprFnBlock(_, _, blk) |\n+                ast::ExprProc(_, blk) |\n+                ast::ExprUnboxedFn(_, _, blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor { found: false };\n                     let mut implicit = CheckForNestedReturnsVisitor { found: false };\n                     visit::walk_expr(&mut explicit, &*e, false);"}, {"sha": "8b36270ee540231d58ce2082da427097b6cd6bc8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -18,6 +18,7 @@ use llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use llvm::{True, False, Bool};\n use mc = middle::mem_categorization;\n use middle::def;\n+use middle::freevars;\n use middle::lang_items::LangItem;\n use middle::subst;\n use middle::subst::Subst;\n@@ -516,6 +517,11 @@ impl<'a> mc::Typer for Block<'a> {\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n         self.tcx().upvar_borrow_map.borrow().get_copy(&upvar_id)\n     }\n+\n+    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> freevars::CaptureMode {\n+        self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n+    }\n }\n \n pub struct Result<'a> {"}, {"sha": "ad1c5bf6ef13318bfc2d338b289005d406be164c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -1150,9 +1150,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n-                ast::ExprFnBlock(fn_decl, top_level_block) |\n+                ast::ExprFnBlock(_, fn_decl, top_level_block) |\n                 ast::ExprProc(fn_decl, top_level_block) |\n-                ast::ExprUnboxedFn(fn_decl, top_level_block) => {\n+                ast::ExprUnboxedFn(_, fn_decl, top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n                     (name, fn_decl,\n@@ -3618,9 +3618,9 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprFnBlock(ref decl, ref block) |\n+            ast::ExprFnBlock(_, ref decl, ref block) |\n             ast::ExprProc(ref decl, ref block) |\n-            ast::ExprUnboxedFn(ref decl, ref block) => {\n+            ast::ExprUnboxedFn(_, ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,"}, {"sha": "7cd2bd631f091666158cd78d8a0b7fb553439ed5", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -782,15 +782,15 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             tvec::trans_fixed_vstore(bcx, expr, expr, dest)\n         }\n-        ast::ExprFnBlock(ref decl, ref body) |\n+        ast::ExprFnBlock(_, ref decl, ref body) |\n         ast::ExprProc(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let store = ty::ty_closure_store(expr_ty);\n             debug!(\"translating block function {} with type {}\",\n                    expr_to_string(expr), expr_ty.repr(tcx));\n             closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n-        ast::ExprUnboxedFn(decl, body) => {\n+        ast::ExprUnboxedFn(_, decl, body) => {\n             closure::trans_unboxed_closure(bcx, &*decl, &*body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {"}, {"sha": "3346b475267b96c953f2fecfb2af3d8082dc4106", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -18,14 +18,15 @@ use lint;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n+use middle::freevars::CaptureModeMap;\n+use middle::freevars;\n use middle::lang_items::{FnMutTraitLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n-use middle::freevars;\n use middle::resolve;\n use middle::resolve_lifetime;\n-use middle::subst;\n-use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::stability;\n+use middle::subst::{Subst, Substs, VecPerParamSpace};\n+use middle::subst;\n use middle::ty;\n use middle::typeck;\n use middle::typeck::MethodCall;\n@@ -384,6 +385,9 @@ pub struct ctxt {\n \n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index>,\n+\n+    /// Maps closures to their capture clauses.\n+    pub capture_modes: RefCell<CaptureModeMap>,\n }\n \n pub enum tbox_flag {\n@@ -1057,6 +1061,7 @@ pub fn mk_ctxt(s: Session,\n                named_region_map: resolve_lifetime::NamedRegionMap,\n                map: ast_map::Map,\n                freevars: freevars::freevar_map,\n+               capture_modes: freevars::CaptureModeMap,\n                region_maps: middle::region::RegionMaps,\n                lang_items: middle::lang_items::LanguageItems,\n                stability: stability::Index)\n@@ -1115,7 +1120,8 @@ pub fn mk_ctxt(s: Session,\n         unboxed_closure_types: RefCell::new(DefIdMap::new()),\n         node_lint_levels: RefCell::new(HashMap::new()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n-        stability: RefCell::new(stability)\n+        stability: RefCell::new(stability),\n+        capture_modes: RefCell::new(capture_modes),\n     }\n }\n \n@@ -4862,6 +4868,11 @@ impl mc::Typer for ty::ctxt {\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n         self.upvar_borrow_map.borrow().get_copy(&upvar_id)\n     }\n+\n+    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> freevars::CaptureMode {\n+        self.capture_modes.borrow().get_copy(&closure_expr_id)\n+    }\n }\n \n /// The category of explicit self."}, {"sha": "33acb521780080dc58ca6fe9ce426015705b0415", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -3390,7 +3390,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprMatch(ref discrim, ref arms) => {\n         _match::check_match(fcx, expr, &**discrim, arms.as_slice());\n       }\n-      ast::ExprFnBlock(ref decl, ref body) => {\n+      ast::ExprFnBlock(_, ref decl, ref body) => {\n         let region = astconv::opt_ast_region_to_region(fcx,\n                                                        fcx.infcx(),\n                                                        expr.span,\n@@ -3402,7 +3402,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       body.clone(),\n                       expected);\n       }\n-      ast::ExprUnboxedFn(ref decl, ref body) => {\n+      ast::ExprUnboxedFn(_, ref decl, ref body) => {\n         check_unboxed_closure(fcx,\n                               expr,\n                               &**decl,"}, {"sha": "47f5c45dde24865f70bccbdc8069268fdfb10892", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -290,6 +290,11 @@ impl<'fcx> mc::Typer for Rcx<'fcx> {\n     fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n         self.fcx.inh.upvar_borrow_map.borrow().get_copy(&id)\n     }\n+\n+    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> freevars::CaptureMode {\n+        self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n+    }\n }\n \n pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n@@ -587,9 +592,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprFnBlock(_, ref body) |\n+        ast::ExprFnBlock(_, _, ref body) |\n         ast::ExprProc(_, ref body) |\n-        ast::ExprUnboxedFn(_, ref body) => {\n+        ast::ExprUnboxedFn(_, _, ref body) => {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n "}, {"sha": "6e6ebd181fbc95bd8917b58c2f19112200fda4e7", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -132,9 +132,9 @@ impl<'cx> Visitor<()> for WritebackCx<'cx> {\n                                     MethodCall::expr(e.id));\n \n         match e.node {\n-            ast::ExprFnBlock(ref decl, _) |\n+            ast::ExprFnBlock(_, ref decl, _) |\n             ast::ExprProc(ref decl, _) |\n-            ast::ExprUnboxedFn(ref decl, _) => {\n+            ast::ExprUnboxedFn(_, ref decl, _) => {\n                 for input in decl.inputs.iter() {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);"}, {"sha": "dd00fc62079813c31e3dbc6985ef4709f866f6b8", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -124,12 +124,20 @@ fn test_env(_test_name: &str,\n     let lang_items = lang_items::collect_language_items(&krate, &sess);\n     let resolve::CrateMap { def_map: def_map, .. } =\n         resolve::resolve_crate(&sess, &lang_items, &krate);\n-    let freevars_map = freevars::annotate_freevars(&def_map, &krate);\n+    let (freevars_map, captures_map) = freevars::annotate_freevars(&def_map,\n+                                                                   &krate);\n     let named_region_map = resolve_lifetime::krate(&sess, &krate);\n     let region_map = region::resolve_crate(&sess, &krate);\n     let stability_index = stability::Index::build(&krate);\n-    let tcx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map,\n-                          freevars_map, region_map, lang_items, stability_index);\n+    let tcx = ty::mk_ctxt(sess,\n+                          def_map,\n+                          named_region_map,\n+                          ast_map,\n+                          freevars_map,\n+                          captures_map,\n+                          region_map,\n+                          lang_items,\n+                          stability_index);\n     let infcx = infer::new_infer_ctxt(&tcx);\n     let env = Env {krate: krate,\n                    tcx: &tcx,"}, {"sha": "46039a70fb21d720cf5cd1266050fe2d2b187f86", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -526,9 +526,9 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(Gc<Expr>, Vec<Arm>),\n-    ExprFnBlock(P<FnDecl>, P<Block>),\n+    ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n-    ExprUnboxedFn(P<FnDecl>, P<Block>),\n+    ExprUnboxedFn(CaptureClause, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(Gc<Expr>, Gc<Expr>),\n@@ -559,6 +559,12 @@ pub enum Expr_ {\n     ExprParen(Gc<Expr>)\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum CaptureClause {\n+    CaptureByValue,\n+    CaptureByRef,\n+}\n+\n /// When the main rust parser encounters a syntax-extension invocation, it\n /// parses the arguments to the invocation as a token-tree. This is a very\n /// loose structure, such that all sorts of different AST-fragments can"}, {"sha": "83af390c4edc3e2f995bf5145eb45c8bce7de83f", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -206,7 +206,7 @@ impl FnLikeNode {\n             },\n             ast_map::NodeMethod(ref m) => method(&**m),\n             ast_map::NodeExpr(ref e) => match e.node {\n-                ast::ExprFnBlock(ref decl, ref block) =>\n+                ast::ExprFnBlock(_, ref decl, ref block) =>\n                     closure(ClosureParts::new(*decl, *block, e.id, e.span)),\n                 ast::ExprProc(ref decl, ref block) =>\n                     closure(ClosureParts::new(*decl, *block, e.id, e.span)),"}, {"sha": "f7eddca4b7aed4d25c2ffd39aed3a5eab2edb537", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -876,14 +876,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr> {\n-        self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n+        self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n     }\n     fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n-        self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n+        self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n     }\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)"}, {"sha": "d918b28d4dc8f31cf8a8625e7bcf326e4dce35ad", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -74,10 +74,12 @@ fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n             fld.cx.expr(e.span, ast::ExprForLoop(pat, head, body, opt_ident))\n         }\n \n-        ast::ExprFnBlock(fn_decl, block) => {\n+        ast::ExprFnBlock(capture_clause, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(&*fn_decl, block, fld);\n-            let new_node = ast::ExprFnBlock(rewritten_fn_decl, rewritten_block);\n+            let new_node = ast::ExprFnBlock(capture_clause,\n+                                            rewritten_fn_decl,\n+                                            rewritten_block);\n             box(GC) ast::Expr{id:e.id, node: new_node, span: fld.new_span(e.span)}\n         }\n "}, {"sha": "02f1f4646a4669b4d9aa15872e6d8209b4570b15", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -1094,16 +1094,18 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n             ExprMatch(folder.fold_expr(expr),\n                       arms.iter().map(|x| folder.fold_arm(x)).collect())\n         }\n-        ExprFnBlock(ref decl, ref body) => {\n-            ExprFnBlock(folder.fold_fn_decl(&**decl),\n+        ExprFnBlock(capture_clause, ref decl, ref body) => {\n+            ExprFnBlock(capture_clause,\n+                        folder.fold_fn_decl(&**decl),\n                         folder.fold_block(body.clone()))\n         }\n         ExprProc(ref decl, ref body) => {\n             ExprProc(folder.fold_fn_decl(&**decl),\n                      folder.fold_block(body.clone()))\n         }\n-        ExprUnboxedFn(ref decl, ref body) => {\n-            ExprUnboxedFn(folder.fold_fn_decl(&**decl),\n+        ExprUnboxedFn(capture_clause, ref decl, ref body) => {\n+            ExprUnboxedFn(capture_clause,\n+                          folder.fold_fn_decl(&**decl),\n                           folder.fold_block(*body))\n         }\n         ExprBlock(ref blk) => ExprBlock(folder.fold_block(*blk)),"}, {"sha": "f0920603ad12e15a4b5debee8003ee95acb15e95", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -17,6 +17,7 @@ use ast::{Provided, Public, FnStyle};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n use ast::{BlockCheckMode, UnBox};\n+use ast::{CaptureByRef, CaptureByValue, CaptureClause};\n use ast::{Crate, CrateConfig, Decl, DeclItem};\n use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n@@ -1985,7 +1986,7 @@ impl<'a> Parser<'a> {\n                                     ExprBlock(blk));\n             },\n             token::BINOP(token::OR) |  token::OROR => {\n-                return self.parse_lambda_expr();\n+                return self.parse_lambda_expr(CaptureByValue);\n             },\n             // FIXME #13626: Should be able to stick in\n             // token::SELF_KEYWORD_NAME\n@@ -2036,6 +2037,9 @@ impl<'a> Parser<'a> {\n                 hi = self.last_span.hi;\n             },\n             _ => {\n+                if self.eat_keyword(keywords::Ref) {\n+                    return self.parse_lambda_expr(CaptureByRef);\n+                }\n                 if self.eat_keyword(keywords::Proc) {\n                     let decl = self.parse_proc_decl();\n                     let body = self.parse_expr();\n@@ -2696,7 +2700,8 @@ impl<'a> Parser<'a> {\n     }\n \n     // `|args| expr`\n-    pub fn parse_lambda_expr(&mut self) -> Gc<Expr> {\n+    pub fn parse_lambda_expr(&mut self, capture_clause: CaptureClause)\n+                             -> Gc<Expr> {\n         let lo = self.span.lo;\n         let (decl, is_unboxed) = self.parse_fn_block_decl();\n         let body = self.parse_expr();\n@@ -2710,9 +2715,13 @@ impl<'a> Parser<'a> {\n         });\n \n         if is_unboxed {\n-            self.mk_expr(lo, body.span.hi, ExprUnboxedFn(decl, fakeblock))\n+            self.mk_expr(lo,\n+                         body.span.hi,\n+                         ExprUnboxedFn(capture_clause, decl, fakeblock))\n         } else {\n-            self.mk_expr(lo, body.span.hi, ExprFnBlock(decl, fakeblock))\n+            self.mk_expr(lo,\n+                         body.span.hi,\n+                         ExprFnBlock(capture_clause, decl, fakeblock))\n         }\n     }\n "}, {"sha": "ed285e2aa443a58d809b13ef6e82706df800b46c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -1473,7 +1473,9 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n-            ast::ExprFnBlock(ref decl, ref body) => {\n+            ast::ExprFnBlock(capture_clause, ref decl, ref body) => {\n+                try!(self.print_capture_clause(capture_clause));\n+\n                 // in do/for blocks we don't want to show an empty\n                 // argument list, but at this point we don't know which\n                 // we are inside.\n@@ -1503,7 +1505,9 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprUnboxedFn(ref decl, ref body) => {\n+            ast::ExprUnboxedFn(capture_clause, ref decl, ref body) => {\n+                try!(self.print_capture_clause(capture_clause));\n+\n                 // in do/for blocks we don't want to show an empty\n                 // argument list, but at this point we don't know which\n                 // we are inside.\n@@ -2071,6 +2075,14 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(decl.output.span.lo)\n     }\n \n+    pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureClause)\n+                                -> IoResult<()> {\n+        match capture_clause {\n+            ast::CaptureByValue => Ok(()),\n+            ast::CaptureByRef => self.word_space(\"ref\"),\n+        }\n+    }\n+\n     pub fn print_proc_args(&mut self, decl: &ast::FnDecl) -> IoResult<()> {\n         try!(word(&mut self.s, \"proc\"));\n         try!(word(&mut self.s, \"(\"));"}, {"sha": "372cee9ad0988a858556ba46f3c5026196988194", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -787,15 +787,15 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n                 visitor.visit_arm(arm, env.clone())\n             }\n         }\n-        ExprFnBlock(ref function_declaration, ref body) => {\n+        ExprFnBlock(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n                              &**function_declaration,\n                              &**body,\n                              expression.span,\n                              expression.id,\n                              env.clone())\n         }\n-        ExprUnboxedFn(ref function_declaration, ref body) => {\n+        ExprUnboxedFn(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n                              &**function_declaration,\n                              &**body,"}, {"sha": "c88b44925d06ac02f2a74335108b3dcb9b6d31b7", "filename": "src/test/run-pass/capture-clauses-boxed-closures.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn each<T>(x: &[T], f: |&T|) {\n+    for val in x.iter() {\n+        f(val)\n+    }\n+}\n+\n+fn main() {\n+    let mut sum = 0u;\n+    let elems = [ 1u, 2, 3, 4, 5 ];\n+    each(elems, ref |val| sum += *val);\n+    assert_eq!(sum, 15);\n+}\n+"}, {"sha": "99e6d6e7a4ffa250bc4eb79ea3c5fd8086588e8b", "filename": "src/test/run-pass/capture-clauses-unboxed-closures.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d45d63d0d18f21f74c8a2a4e5367a785932f64e/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs?ref=9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test\n+//\n+// This is ignored because it depends on #16122.\n+\n+#![feature(overloaded_calls, unboxed_closures)]\n+\n+fn each<'a,T,F:|&mut: &'a T|>(x: &'a [T], mut f: F) {\n+    for val in x.iter() {\n+        f(val)\n+    }\n+}\n+\n+fn main() {\n+    let mut sum = 0u;\n+    let elems = [ 1u, 2, 3, 4, 5 ];\n+    each(elems, ref |&mut: val: &uint| sum += *val);\n+    assert_eq!(sum, 15);\n+}\n+"}]}