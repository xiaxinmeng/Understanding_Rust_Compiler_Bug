{"sha": "c2ca1a4b622baa8394ab19e76bef75afe680ad18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyY2ExYTRiNjIyYmFhODM5NGFiMTllNzZiZWY3NWFmZTY4MGFkMTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-13T10:34:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:30Z"}, "message": "Make all predicates higher-ranked, not just trait references.", "tree": {"sha": "36c99b122520b43781316f7f7572c5af94aae485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36c99b122520b43781316f7f7572c5af94aae485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2ca1a4b622baa8394ab19e76bef75afe680ad18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ca1a4b622baa8394ab19e76bef75afe680ad18", "html_url": "https://github.com/rust-lang/rust/commit/c2ca1a4b622baa8394ab19e76bef75afe680ad18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2ca1a4b622baa8394ab19e76bef75afe680ad18/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f34524fcbd9672e2fd6bb27e657da2c26051fdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f34524fcbd9672e2fd6bb27e657da2c26051fdf", "html_url": "https://github.com/rust-lang/rust/commit/4f34524fcbd9672e2fd6bb27e657da2c26051fdf"}], "stats": {"total": 469, "additions": 336, "deletions": 133}, "files": [{"sha": "f2a41c48d1203753408e4b8d5cc94b5835a0d75d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -21,7 +21,7 @@ pub use self::DefIdSource::*;\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, AsPredicate, Ty};\n \n use std::rc::Rc;\n use std::str;\n@@ -669,13 +669,13 @@ pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n                                 -> ty::Predicate<'tcx>\n {\n     match next(st) {\n-        't' => ty::Predicate::Trait(Rc::new(ty::Binder(parse_trait_ref(st, conv)))),\n-        'e' => ty::Predicate::Equate(parse_ty(st, |x,y| conv(x,y)),\n-                                     parse_ty(st, |x,y| conv(x,y))),\n-        'r' => ty::Predicate::RegionOutlives(parse_region(st, |x,y| conv(x,y)),\n-                                             parse_region(st, |x,y| conv(x,y))),\n-        'o' => ty::Predicate::TypeOutlives(parse_ty(st, |x,y| conv(x,y)),\n-                                           parse_region(st, |x,y| conv(x,y))),\n+        't' => Rc::new(ty::Binder(parse_trait_ref(st, conv))).as_predicate(),\n+        'e' => ty::Binder(ty::EquatePredicate(parse_ty(st, |x,y| conv(x,y)),\n+                                              parse_ty(st, |x,y| conv(x,y)))).as_predicate(),\n+        'r' => ty::Binder(ty::OutlivesPredicate(parse_region(st, |x,y| conv(x,y)),\n+                                                parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n+        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty(st, |x,y| conv(x,y)),\n+                                                parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }"}, {"sha": "5d7d85d4679d7c9d8ed6e46913a4467a36dd91e1", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -427,17 +427,17 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n             mywrite!(w, \"t\");\n             enc_trait_ref(w, cx, &trait_ref.0);\n         }\n-        ty::Predicate::Equate(a, b) => {\n+        ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n             mywrite!(w, \"e\");\n             enc_ty(w, cx, a);\n             enc_ty(w, cx, b);\n         }\n-        ty::Predicate::RegionOutlives(a, b) => {\n+        ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n             mywrite!(w, \"r\");\n             enc_region(w, cx, a);\n             enc_region(w, cx, b);\n         }\n-        ty::Predicate::TypeOutlives(a, b) => {\n+        ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n             mywrite!(w, \"o\");\n             enc_ty(w, cx, a);\n             enc_region(w, cx, b);"}, {"sha": "3a84890de4f4baa6b5b5928bb5955be2dc25a71b", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -81,7 +81,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            match self.infcx().leak_check(&skol_map, snapshot) {\n+            match leak_check(self.infcx(), &skol_map, snapshot) {\n                 Ok(()) => { }\n                 Err((skol_br, tainted_region)) => {\n                     if self.a_is_expected() {"}, {"sha": "29021c0cca6b9a8f3b0a993080dc6dd0ea112037", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -717,11 +717,40 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn leak_check(&self,\n                       skol_map: &SkolemizationMap,\n                       snapshot: &CombinedSnapshot)\n-                      -> Result<(),(ty::BoundRegion,ty::Region)>\n+                      -> ures<'tcx>\n     {\n         /*! See `higher_ranked::leak_check` */\n \n-        higher_ranked::leak_check(self, skol_map, snapshot)\n+        match higher_ranked::leak_check(self, skol_map, snapshot) {\n+            Ok(()) => Ok(()),\n+            Err((br, r)) => Err(ty::terr_regions_insufficiently_polymorphic(br, r))\n+        }\n+    }\n+\n+    pub fn equality_predicate(&self,\n+                              span: Span,\n+                              predicate: &ty::PolyEquatePredicate<'tcx>)\n+                              -> ures<'tcx> {\n+        self.try(|snapshot| {\n+            let (ty::EquatePredicate(a, b), skol_map) =\n+                self.skolemize_late_bound_regions(predicate, snapshot);\n+            let origin = EquatePredicate(span);\n+            let () = try!(mk_eqty(self, false, origin, a, b));\n+            self.leak_check(&skol_map, snapshot)\n+        })\n+    }\n+\n+    pub fn region_outlives_predicate(&self,\n+                                     span: Span,\n+                                     predicate: &ty::PolyRegionOutlivesPredicate)\n+                                     -> ures<'tcx> {\n+        self.try(|snapshot| {\n+            let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n+                self.skolemize_late_bound_regions(predicate, snapshot);\n+            let origin = RelateRegionParamBound(span);\n+            let () = mk_subr(self, origin, r_b, r_a); // `b : a` ==> `a <= b`\n+            self.leak_check(&skol_map, snapshot)\n+        })\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {"}, {"sha": "32d9056f7b778ec212c6e70db74b8407b7ed8ed7", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::infer::InferCtxt;\n use middle::mem_categorization::Typer;\n use middle::ty::{mod, Ty};\n-use middle::infer::{mod, InferCtxt};\n use std::collections::HashSet;\n use std::collections::hash_map::{Occupied, Vacant};\n use std::default::Default;\n@@ -329,30 +329,50 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             }\n         }\n \n-        ty::Predicate::Equate(a, b) => {\n-            let origin = infer::EquatePredicate(predicate.cause.span);\n-            match infer::mk_eqty(selcx.infcx(), false, origin, a, b) {\n-                Ok(()) => {\n-                    true\n-                }\n+        ty::Predicate::Equate(ref binder) => {\n+            match selcx.infcx().equality_predicate(predicate.cause.span, binder) {\n+                Ok(()) => { }\n                 Err(_) => {\n                     errors.push(\n                         FulfillmentError::new(\n                             predicate.clone(),\n                             CodeSelectionError(Unimplemented)));\n-                    true\n                 }\n             }\n+            true\n         }\n \n-        ty::Predicate::RegionOutlives(r_a, r_b) => {\n-            let origin = infer::RelateRegionParamBound(predicate.cause.span);\n-            let () = infer::mk_subr(selcx.infcx(), origin, r_b, r_a); // `b : a` ==> `a <= b`\n+        ty::Predicate::RegionOutlives(ref binder) => {\n+            match selcx.infcx().region_outlives_predicate(predicate.cause.span, binder) {\n+                Ok(()) => { }\n+                Err(_) => {\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            predicate.clone(),\n+                            CodeSelectionError(Unimplemented)));\n+                }\n+            }\n+\n             true\n         }\n \n-        ty::Predicate::TypeOutlives(t_a, r_b) => {\n-            register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+        ty::Predicate::TypeOutlives(ref binder) => {\n+            // For now, we just check that there are no higher-ranked\n+            // regions.  If there are, we will call this obligation an\n+            // error. Eventually we should be able to support some\n+            // cases here, I imagine (e.g., `for<'a> &'a int : 'a`).\n+            //\n+            // TODO This is overly conservative, but good enough for\n+            // now.\n+            if ty::count_late_bound_regions(selcx.tcx(), binder) != 0 {\n+                errors.push(\n+                    FulfillmentError::new(\n+                        predicate.clone(),\n+                        CodeSelectionError(Unimplemented)));\n+            } else {\n+                let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n+                register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+            }\n             true\n         }\n     }\n@@ -385,3 +405,4 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n }\n+"}, {"sha": "0bda04237b631b187b8b8506c95c5e1ff46ef86d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -28,7 +28,7 @@ use super::{util};\n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::ty::{mod, Ty, RegionEscape};\n+use middle::ty::{mod, AsPredicate, RegionEscape, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -288,8 +288,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.evaluate_obligation_recursively(previous_stack, &obligation)\n             }\n \n-            ty::Predicate::Equate(a, b) => {\n-                match infer::can_mk_eqty(self.infcx, a, b) {\n+            ty::Predicate::Equate(ref p) => {\n+                let result = self.infcx.probe(|| {\n+                    self.infcx.equality_predicate(obligation.cause.span, p)\n+                });\n+                match result {\n                     Ok(()) => EvaluatedToOk,\n                     Err(_) => EvaluatedToErr(Unimplemented),\n                 }\n@@ -1447,8 +1450,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation {\n                 cause: obligation.cause,\n                 recursion_depth: obligation.recursion_depth+1,\n-                trait_ref: ty::Predicate::TypeOutlives(obligation.self_ty(),\n-                                                       ty::ReStatic)\n+                trait_ref: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n+                                                            ty::ReStatic)).as_predicate(),\n             });\n         }\n "}, {"sha": "91247d8b73e41babf68b30ee463d01cb96524734", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 116, "deletions": 35, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -1689,23 +1689,60 @@ pub enum Predicate<'tcx> {\n     Trait(Rc<PolyTraitRef<'tcx>>),\n \n     /// where `T1 == T2`.\n-    Equate(/* T1 */ Ty<'tcx>, /* T2 */ Ty<'tcx>),\n+    Equate(PolyEquatePredicate<'tcx>),\n \n     /// where 'a : 'b\n-    RegionOutlives(/* 'a */ Region, /* 'b */ Region),\n+    RegionOutlives(PolyRegionOutlivesPredicate),\n \n     /// where T : 'a\n-    TypeOutlives(Ty<'tcx>, Region),\n+    TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n+pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n+pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n+pub type PolyRegionOutlivesPredicate = PolyOutlivesPredicate<ty::Region, ty::Region>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region>;\n+\n+pub trait AsPredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx>;\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for Rc<PolyTraitRef<'tcx>> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::Trait(self.clone())\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyEquatePredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::Equate(self.clone())\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyRegionOutlivesPredicate {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::RegionOutlives(self.clone())\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::TypeOutlives(self.clone())\n+    }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn has_escaping_regions(&self) -> bool {\n         match *self {\n             Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n-            Predicate::Equate(a, b) => (ty::type_has_escaping_regions(a) ||\n-                                        ty::type_has_escaping_regions(b)),\n-            Predicate::RegionOutlives(a, b) => a.escapes_depth(0) || b.escapes_depth(0),\n-            Predicate::TypeOutlives(a, b) => ty::type_has_escaping_regions(a) || b.escapes_depth(0),\n+            Predicate::Equate(ref p) => p.has_escaping_regions(),\n+            Predicate::RegionOutlives(ref p) => p.has_escaping_regions(),\n+            Predicate::TypeOutlives(ref p) => p.has_escaping_regions(),\n         }\n     }\n \n@@ -5208,17 +5245,20 @@ pub fn predicates<'tcx>(\n \n     for builtin_bound in bounds.builtin_bounds.iter() {\n         match traits::poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n-            Ok(trait_ref) => { vec.push(Predicate::Trait(trait_ref)); }\n+            Ok(trait_ref) => { vec.push(trait_ref.as_predicate()); }\n             Err(ErrorReported) => { }\n         }\n     }\n \n     for &region_bound in bounds.region_bounds.iter() {\n-        vec.push(Predicate::TypeOutlives(param_ty, region_bound));\n+        // account for the binder being introduced below; no need to shift `param_ty`\n+        // because, at present at least, it can only refer to early-bound regions\n+        let region_bound = ty_fold::shift_region(region_bound, 1);\n+        vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).as_predicate());\n     }\n \n     for bound_trait_ref in bounds.trait_bounds.iter() {\n-        vec.push(Predicate::Trait((*bound_trait_ref).clone()));\n+        vec.push(bound_trait_ref.as_predicate());\n     }\n \n     vec\n@@ -5595,19 +5635,27 @@ pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n     ty::required_region_bounds(tcx, open_ty, predicates)\n }\n \n-/// Given a type which must meet the builtin bounds and trait bounds, returns a set of lifetimes\n-/// which the type must outlive.\n+/// Given a set of predicates that apply to an object type, returns\n+/// the region bounds that the (erased) `Self` type must\n+/// outlive. Precisely *because* the `Self` type is erased, the\n+/// parameter `erased_self_ty` must be supplied to indicate what type\n+/// has been used to represent `Self` in the predicates\n+/// themselves. This should really be a unique type; `FreshTy(0)` is a\n+/// popular choice (see `object_region_bounds` above).\n ///\n-/// Requires that trait definitions have been processed.\n+/// Requires that trait definitions have been processed so that we can\n+/// elaborate predicates and walk supertraits.\n pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                    param_ty: Ty<'tcx>,\n+                                    erased_self_ty: Ty<'tcx>,\n                                     predicates: Vec<ty::Predicate<'tcx>>)\n                                     -> Vec<ty::Region>\n {\n-    debug!(\"required_region_bounds(param_ty={}, predicates={})\",\n-           param_ty.repr(tcx),\n+    debug!(\"required_region_bounds(erased_self_ty={}, predicates={})\",\n+           erased_self_ty.repr(tcx),\n            predicates.repr(tcx));\n \n+    assert!(!erased_self_ty.has_escaping_regions());\n+\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {\n             match predicate {\n@@ -5616,9 +5664,22 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n                 ty::Predicate::RegionOutlives(..) => {\n                     None\n                 }\n-                ty::Predicate::TypeOutlives(t, r) => {\n-                    if t == param_ty {\n-                        Some(r)\n+                ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n+                    // Search for a bound of the form `erased_self_ty\n+                    // : 'a`, but be wary of something like `for<'a>\n+                    // erased_self_ty : 'a` (we interpret a\n+                    // higher-ranked bound like that as 'static,\n+                    // though at present the code in `fulfill.rs`\n+                    // considers such bounds to be unsatisfiable, so\n+                    // it's kind of a moot point since you could never\n+                    // construct such an object, but this seems\n+                    // correct even if that code changes).\n+                    if t == erased_self_ty && !r.has_escaping_regions() {\n+                        if r.has_escaping_regions() {\n+                            Some(ty::ReStatic)\n+                        } else {\n+                            Some(r)\n+                        }\n                     } else {\n                         None\n                     }\n@@ -6100,16 +6161,20 @@ pub fn construct_parameter_environment<'tcx>(\n                 Predicate::Trait(..) | Predicate::Equate(..) | Predicate::TypeOutlives(..) => {\n                     // No region bounds here\n                 }\n-                Predicate::RegionOutlives(ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n-                    // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n-                    tcx.region_maps.relate_free_regions(fr_b, fr_a);\n-                }\n-                Predicate::RegionOutlives(r_a, r_b) => {\n-                    // All named regions are instantiated with free regions.\n-                    tcx.sess.bug(\n-                        format!(\"record_region_bounds: non free region: {} / {}\",\n-                                r_a.repr(tcx),\n-                                r_b.repr(tcx)).as_slice());\n+                Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n+                    match (r_a, r_b) {\n+                        (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n+                            // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n+                            tcx.region_maps.relate_free_regions(fr_b, fr_a);\n+                        }\n+                        _ => {\n+                            // All named regions are instantiated with free regions.\n+                            tcx.sess.bug(\n+                                format!(\"record_region_bounds: non free region: {} / {}\",\n+                                        r_a.repr(tcx),\n+                                        r_b.repr(tcx)).as_slice());\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -6313,6 +6378,16 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n         |br, _| ty::ReFree(ty::FreeRegion{scope: scope, bound_region: br})).0\n }\n \n+pub fn count_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    value: &Binder<T>)\n+    -> uint\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    let (_, skol_map) = replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic);\n+    skol_map.len()\n+}\n+\n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n pub fn erase_late_bound_regions<'tcx, T>(\n@@ -6454,9 +6529,9 @@ impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             Predicate::Trait(ref a) => a.repr(tcx),\n-            Predicate::Equate(a, b) => format!(\"Equate({},{})\", a.repr(tcx), b.repr(tcx)),\n-            Predicate::RegionOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n-            Predicate::TypeOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n+            Predicate::Equate(ref pair) => format!(\"Equate({})\", pair.repr(tcx)),\n+            Predicate::RegionOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n+            Predicate::TypeOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n         }\n     }\n }\n@@ -6586,9 +6661,15 @@ impl<'tcx,T:RegionEscape> RegionEscape for Binder<T> {\n     }\n }\n \n-impl<T:RegionEscape> Binder<T> {\n-    pub fn has_bound_regions(&self) -> bool {\n-        self.0.has_regions_escaping_depth(0)\n+impl<'tcx> RegionEscape for EquatePredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<T:RegionEscape,U:RegionEscape> RegionEscape for OutlivesPredicate<T,U> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n     }\n }\n "}, {"sha": "496a0badd82368532948f68e5cbb7801018c3dbe", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -409,15 +409,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref a) =>\n                 ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Equate(ref a, ref b) =>\n-                ty::Predicate::Equate(a.fold_with(folder),\n-                                        b.fold_with(folder)),\n-            ty::Predicate::RegionOutlives(ref a, ref b) =>\n-                ty::Predicate::RegionOutlives(a.fold_with(folder),\n-                                                b.fold_with(folder)),\n-            ty::Predicate::TypeOutlives(ref a, ref b) =>\n-                ty::Predicate::TypeOutlives(a.fold_with(folder),\n-                                              b.fold_with(folder)),\n+            ty::Predicate::Equate(ref binder) =>\n+                ty::Predicate::Equate(binder.fold_with(folder)),\n+            ty::Predicate::RegionOutlives(ref binder) =>\n+                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n+            ty::Predicate::TypeOutlives(ref binder) =>\n+                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n         }\n     }\n }\n@@ -501,6 +498,23 @@ impl<'tcx> TypeFoldable<'tcx> for traits::VtableParamData<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n+        ty::EquatePredicate(self.0.fold_with(folder),\n+                            self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : TypeFoldable<'tcx>,\n+          U : TypeFoldable<'tcx>,\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::OutlivesPredicate<T,U> {\n+        ty::OutlivesPredicate(self.0.fold_with(folder),\n+                              self.1.fold_with(folder))\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //"}, {"sha": "b0124977c9f1b9ff25a083591fbe11803b8eaf35", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -1350,3 +1350,56 @@ impl<'tcx, S, H, K, V> Repr<'tcx> for HashMap<K,V,H>\n                     .connect(\", \"))\n     }\n }\n+\n+impl<'tcx, T, U> Repr<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : Repr<'tcx> + TypeFoldable<'tcx>,\n+          U : Repr<'tcx> + TypeFoldable<'tcx>,\n+{\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"OutlivesPredicate({}, {})\",\n+                self.0.repr(tcx),\n+                self.1.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx, T, U> UserString<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : UserString<'tcx> + TypeFoldable<'tcx>,\n+          U : UserString<'tcx> + TypeFoldable<'tcx>,\n+{\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} : {}\",\n+                self.0.user_string(tcx),\n+                self.1.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"EquatePredicate({}, {})\",\n+                self.0.repr(tcx),\n+                self.1.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} == {}\",\n+                self.0.user_string(tcx),\n+                self.1.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        match *self {\n+            ty::Predicate::Trait(ref trait_ref) => {\n+                format!(\"{} : {}\",\n+                        trait_ref.self_ty().user_string(tcx),\n+                        trait_ref.user_string(tcx))\n+            }\n+            ty::Predicate::Equate(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(tcx),\n+        }\n+    }\n+}"}, {"sha": "4db795a1fda5561913c14bec5cac2870bd3a3808", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 34, "deletions": 48, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -315,36 +315,13 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match *error {\n         Overflow => {\n             // We could track the stack here more precisely if we wanted, I imagine.\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"overflow evaluating the trait `{}` for the type `{}`\",\n-                            trait_ref.user_string(fcx.tcx()),\n-                            trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n-                }\n-\n-                ty::Predicate::Equate(a, b) => {\n-                    let a = fcx.infcx().resolve_type_vars_if_possible(&a);\n-                    let b = fcx.infcx().resolve_type_vars_if_possible(&b);\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"overflow checking whether the types `{}` and `{}` are equal\",\n-                            a.user_string(fcx.tcx()),\n-                            b.user_string(fcx.tcx())).as_slice());\n-                }\n-\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n-                }\n-            }\n+            let predicate =\n+                fcx.infcx().resolve_type_vars_if_possible(&obligation.trait_ref);\n+            fcx.tcx().sess.span_err(\n+                obligation.cause.span,\n+                format!(\n+                    \"overflow evaluating the requirement `{}`\",\n+                    predicate.user_string(fcx.tcx())).as_slice());\n \n             let current_limit = fcx.tcx().sess.recursion_limit.get();\n             let suggested_limit = current_limit * 2;\n@@ -359,43 +336,52 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Unimplemented => {\n             match obligation.trait_ref {\n                 ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n+                    let trait_ref = fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n                     if !ty::type_is_error(trait_ref.self_ty()) {\n                         fcx.tcx().sess.span_err(\n                             obligation.cause.span,\n                             format!(\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref.user_string(fcx.tcx()),\n                                 trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n-                        note_obligation_cause(fcx, obligation);\n                     }\n                 }\n \n-                ty::Predicate::Equate(a, b) => {\n-                    let a = fcx.infcx().resolve_type_vars_if_possible(&a);\n-                    let b = fcx.infcx().resolve_type_vars_if_possible(&b);\n-                    let err = infer::can_mk_eqty(fcx.infcx(), a, b).unwrap_err();\n+                ty::Predicate::Equate(ref predicate) => {\n+                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n+                    let err = fcx.infcx().equality_predicate(obligation.cause.span,\n+                                                             &predicate).unwrap_err();\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(fcx.tcx()),\n+                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n+                }\n+\n+                ty::Predicate::RegionOutlives(ref predicate) => {\n+                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n+                    let err = fcx.infcx().region_outlives_predicate(obligation.cause.span,\n+                                                                    &predicate).unwrap_err();\n                     fcx.tcx().sess.span_err(\n                         obligation.cause.span,\n                         format!(\n-                            \"mismatched types: the types `{}` and `{}` are not equal ({})\",\n-                            a.user_string(fcx.tcx()),\n-                            b.user_string(fcx.tcx()),\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(fcx.tcx()),\n                             ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n                 }\n \n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    // these kinds of predicates turn into\n-                    // constraints, and hence errors show up in region\n-                    // inference.\n-                    fcx.tcx().sess.span_bug(\n+                ty::Predicate::TypeOutlives(ref predicate) => {\n+                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n+                    fcx.tcx().sess.span_err(\n                         obligation.cause.span,\n-                        format!(\"region predicate error {}\",\n-                                obligation.repr(fcx.tcx())).as_slice());\n+                        format!(\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate.user_string(fcx.tcx())).as_slice());\n                 }\n             }\n+\n+            note_obligation_cause(fcx, obligation);\n         }\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref ="}, {"sha": "485f0ca84304debebcd5e9ca1c73c4078ecbd410", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -42,10 +42,9 @@ use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n-use middle::ty::{ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{Polytype};\n-use middle::ty::{mod, Ty};\n-use middle::ty_fold::TypeFolder;\n+use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n+use middle::ty::{mod, Ty, Polytype};\n+use middle::ty_fold::{mod, TypeFolder};\n use middle::infer;\n use rscope::*;\n use {CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n@@ -1920,8 +1919,12 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         for region_param_def in result.regions.get_slice(space).iter() {\n             let region = region_param_def.to_early_bound_region();\n             for &bound_region in region_param_def.bounds.iter() {\n-                result.predicates.push(space, ty::Predicate::RegionOutlives(region,\n-                                                                            bound_region));\n+                // account for new binder introduced in the predicate below; no need\n+                // to shift `region` because it is never a late-bound region\n+                let bound_region = ty_fold::shift_region(bound_region, 1);\n+                result.predicates.push(\n+                    space,\n+                    ty::Binder(ty::OutlivesPredicate(region, bound_region)).as_predicate());\n             }\n         }\n     }"}, {"sha": "5a1a186c74c4eab99585f7ca6500d5aecb0f82ce", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ca1a4b622baa8394ab19e76bef75afe680ad18/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c2ca1a4b622baa8394ab19e76bef75afe680ad18", "patch": "@@ -105,8 +105,11 @@ pub trait Visitor<'v> {\n             None => ()\n         }\n     }\n+    fn visit_lifetime_bound(&mut self, lifetime: &'v Lifetime) {\n+        walk_lifetime_bound(self, lifetime)\n+    }\n     fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n-        self.visit_name(lifetime.span, lifetime.name)\n+        walk_lifetime_ref(self, lifetime)\n     }\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n@@ -214,10 +217,20 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               lifetime_def: &'v LifetimeDef) {\n     visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n     for bound in lifetime_def.bounds.iter() {\n-        visitor.visit_lifetime_ref(bound);\n+        visitor.visit_lifetime_bound(bound);\n     }\n }\n \n+pub fn walk_lifetime_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                               lifetime_ref: &'v Lifetime) {\n+    visitor.visit_lifetime_ref(lifetime_ref)\n+}\n+\n+pub fn walk_lifetime_ref<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             lifetime_ref: &'v Lifetime) {\n+    visitor.visit_name(lifetime_ref.span, lifetime_ref.name)\n+}\n+\n pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n@@ -550,7 +563,7 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_poly_trait_ref(typ);\n         }\n         RegionTyParamBound(ref lifetime) => {\n-            visitor.visit_lifetime_ref(lifetime);\n+            visitor.visit_lifetime_bound(lifetime);\n         }\n     }\n }"}]}