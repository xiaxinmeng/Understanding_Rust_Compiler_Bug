{"sha": "c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6", "node_id": "C_kwDOAAsO6NoAKGM4ZGY2ZDY5NzA3NDlhYmM4ZWUzYjNiNWY3OGQ0YzFhOWFkMzNiYjY", "commit": {"author": {"name": "Evan Typanski", "email": "evan.typanski@microfocus.com", "date": "2022-06-22T17:31:04Z"}, "committer": {"name": "Evan Typanski", "email": "evan.typanski@microfocus.com", "date": "2022-06-22T18:23:04Z"}, "message": "Prefer if let chain over macro", "tree": {"sha": "06324011d62ee48ed26f46c5a02dafffb71f3d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06324011d62ee48ed26f46c5a02dafffb71f3d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6", "html_url": "https://github.com/rust-lang/rust/commit/c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6/comments", "author": null, "committer": null, "parents": [{"sha": "93e41d3305c683a4ed19ff3001832f8c84090310", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e41d3305c683a4ed19ff3001832f8c84090310", "html_url": "https://github.com/rust-lang/rust/commit/93e41d3305c683a4ed19ff3001832f8c84090310"}], "stats": {"total": 36, "additions": 15, "deletions": 21}, "files": [{"sha": "3ffd9a07376daf0431dd9a8e685ff4df28764cb3", "filename": "clippy_lints/src/manual_rem_euclid.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs?ref=c8df6d6970749abc8ee3b3b5f78d4c1a9ad33bb6", "patch": "@@ -2,7 +2,6 @@ use clippy_utils::consts::{constant_full_int, FullInt};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{meets_msrv, msrvs, path_to_local};\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, Node, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -52,26 +51,22 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n             return;\n         }\n \n-        if_chain! {\n-            if let ExprKind::Binary(op1, ..) = expr.kind;\n-            if op1.node == BinOpKind::Rem;\n-            if let Some((const1, expr1)) = check_for_positive_int_constant(cx, expr, false);\n-            if let ExprKind::Binary(op2, ..) = expr1.kind;\n-            if op2.node == BinOpKind::Add;\n-            if let Some((const2, expr2)) = check_for_positive_int_constant(cx, expr1, true);\n-            if let ExprKind::Binary(op3, ..) = expr2.kind;\n-            if op3.node == BinOpKind::Rem;\n-            if let Some((const3, expr3)) = check_for_positive_int_constant(cx, expr2, false);\n-            if const1 == const2 && const2 == const3;\n+        if let ExprKind::Binary(op1, ..) = expr.kind\n+            && op1.node == BinOpKind::Rem\n+            && let Some((const1, expr1)) = check_for_positive_int_constant(cx, expr, false)\n+            && let ExprKind::Binary(op2, ..) = expr1.kind\n+            && op2.node == BinOpKind::Add\n+            && let Some((const2, expr2)) = check_for_positive_int_constant(cx, expr1, true)\n+            && let ExprKind::Binary(op3, ..) = expr2.kind\n+            && op3.node == BinOpKind::Rem\n+            && let Some((const3, expr3)) = check_for_positive_int_constant(cx, expr2, false)\n+            && const1 == const2 && const2 == const3\n             // Only apply if we see an explicit type annotation on the local.\n-            if let Some(hir_id) = path_to_local(expr3);\n-            let hir = cx.tcx.hir();\n-            if let Some(Node::Binding(_)) = hir.find(hir_id);\n-            let parent = hir.get_parent_node(hir_id);\n-            if let Some(Node::Local(local)) = hir.find(parent);\n-            if let Some(ty) = local.ty;\n-            if !matches!(ty.kind, TyKind::Infer);\n-            then {\n+            && let Some(hir_id) = path_to_local(expr3)\n+            && let Some(Node::Binding(_)) = cx.tcx.hir().find(hir_id)\n+            && let Some(Node::Local(local)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id))\n+            && let Some(ty) = local.ty\n+            && !matches!(ty.kind, TyKind::Infer) {\n                 let mut app = Applicability::MachineApplicable;\n                 let rem_of = snippet_with_applicability(cx, expr3.span, \"_\", &mut app);\n                 span_lint_and_sugg(\n@@ -83,7 +78,6 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n                     format!(\"{rem_of}.rem_euclid({const1})\"),\n                     app,\n                 );\n-            }\n         }\n     }\n "}]}