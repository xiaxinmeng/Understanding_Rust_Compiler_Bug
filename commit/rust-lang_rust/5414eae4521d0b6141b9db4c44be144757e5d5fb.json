{"sha": "5414eae4521d0b6141b9db4c44be144757e5d5fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MTRlYWU0NTIxZDBiNjE0MWI5ZGI0YzQ0YmUxNDQ3NTdlNWQ1ZmI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-14T14:39:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-14T14:39:19Z"}, "message": "Rollup merge of #74324 - flip1995:clippyup, r=Manishearth\n\nUpdate Clippy\n\n~~I'm not sure, if we can/should land this before beta is branched.~~ (Nvm, beta is already branched) The last Clippy update was 3 weeks ago: #73660\n\nThis includes, besides other minor things:\n\n- New lints\n- One lint deprecation\n- One lint was moved to pedantic\n- Some FP fixes\n- I think an ICE fix?\n\ncc @Mark-Simulacrum\n\nr? @Manishearth\n\n---\n\nWe probably should also think of some process when and how often we should sync Clippy to the rust repo, so that we don't end up with those huge updates. Maybe every 2 weeks? Or even every week? cc @rust-lang/clippy", "tree": {"sha": "d02268730c1ae866eb4a1ec31e144592b868be3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d02268730c1ae866eb4a1ec31e144592b868be3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5414eae4521d0b6141b9db4c44be144757e5d5fb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfDcOXCRBK7hj4Ov3rIwAAdHIIAFCqzO+368Ccoi5nFaV628/Q\nUG40i+jX8IkslR+o+Dr+QC0HUzdnWnBmK7D7uOLqC2uLPeWeZliqUEg+qhzii0hz\nWcclteLtd0ys93DBQfzvgf0h+DCNrmPqxmQeBHEa5imJONfKPp0OIIAmN+EnCtfK\nfKSXMV7z+QpGjeSe674GsJHIFM4YWKKUfD16hkye4q2immJNxTvuDX4rgMl8AcuT\nvxHyVqAuAvsowcKzuzK1V5fd0oQtxAWvFsLcdqnrLkvAagp1i2Gh/Pr4soRc3TiG\n1vRy7p+jB3twXmKg90pwkerFs30otb9KhmKZbiwss7U/J8C4+E8rhoFfYwUmzQc=\n=Ic6t\n-----END PGP SIGNATURE-----\n", "payload": "tree d02268730c1ae866eb4a1ec31e144592b868be3d\nparent 2fb307aca5b4ac317b09c7e91a8d4259fbebf17a\nparent f82ac4d44822ace21ea240115aca9b04cd1606a8\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594737559 -0700\ncommitter GitHub <noreply@github.com> 1594737559 -0700\n\nRollup merge of #74324 - flip1995:clippyup, r=Manishearth\n\nUpdate Clippy\n\n~~I'm not sure, if we can/should land this before beta is branched.~~ (Nvm, beta is already branched) The last Clippy update was 3 weeks ago: #73660\n\nThis includes, besides other minor things:\n\n- New lints\n- One lint deprecation\n- One lint was moved to pedantic\n- Some FP fixes\n- I think an ICE fix?\n\ncc @Mark-Simulacrum\n\nr? @Manishearth\n\n---\n\nWe probably should also think of some process when and how often we should sync Clippy to the rust repo, so that we don't end up with those huge updates. Maybe every 2 weeks? Or even every week? cc @rust-lang/clippy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5414eae4521d0b6141b9db4c44be144757e5d5fb", "html_url": "https://github.com/rust-lang/rust/commit/5414eae4521d0b6141b9db4c44be144757e5d5fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5414eae4521d0b6141b9db4c44be144757e5d5fb/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fb307aca5b4ac317b09c7e91a8d4259fbebf17a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb307aca5b4ac317b09c7e91a8d4259fbebf17a", "html_url": "https://github.com/rust-lang/rust/commit/2fb307aca5b4ac317b09c7e91a8d4259fbebf17a"}, {"sha": "f82ac4d44822ace21ea240115aca9b04cd1606a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f82ac4d44822ace21ea240115aca9b04cd1606a8", "html_url": "https://github.com/rust-lang/rust/commit/f82ac4d44822ace21ea240115aca9b04cd1606a8"}], "stats": {"total": 5399, "additions": 4316, "deletions": 1083}, "files": [{"sha": "98fd0df685fdb31711ea1c8234f9afea43e62c0a", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/new_lint.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -12,7 +12,7 @@ labels: L-lint\n \n - Kind: *See <https://github.com/rust-lang/rust-clippy/blob/master/README.md#clippy> for list of lint kinds*\n \n-*What benefit of this lint over old code?*\n+*What is the advantage of the recommended code over the original code*\n \n For example:\n - Remove bounce checking inserted by ..."}, {"sha": "fd0cd7a1890bd79c8630a52fcd17a39d729ed61f", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -240,7 +240,8 @@ jobs:\n         - 'Geal/nom'\n         - 'rust-lang/stdarch'\n         - 'serde-rs/serde'\n-        - 'chronotope/chrono'\n+        # FIXME: chrono currently cannot be compiled with `--all-targets`\n+        # - 'chronotope/chrono'\n         - 'hyperium/hyper'\n         - 'rust-random/rand'\n         - 'rust-lang/futures-rs'"}, {"sha": "5d08b44ba404f9294f0b45973e017e571c208058", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1352,6 +1352,7 @@ Released 2018-09-13\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n+[`blanket_clippy_restriction_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints\n [`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n@@ -1508,9 +1509,11 @@ Released 2018-09-13\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n [`map_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_flatten\n+[`map_identity`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_identity\n [`map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or\n [`match_as_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_as_ref\n [`match_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_bool\n+[`match_like_matches_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n [`match_on_vec_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_on_vec_items\n [`match_overlapping_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_overlapping_arm\n [`match_ref_pats`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_ref_pats\n@@ -1575,6 +1578,7 @@ Released 2018-09-13\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_if_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_if_let_else\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option\n@@ -1586,6 +1590,7 @@ Released 2018-09-13\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n+[`pattern_type_mismatch`]: https://rust-lang.github.io/rust-clippy/master/index.html#pattern_type_mismatch\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n [`print_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_literal\n@@ -1612,6 +1617,7 @@ Released 2018-09-13\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n [`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n+[`repeat_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#repeat_once\n [`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts\n [`rest_pat_in_fully_bound_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#rest_pat_in_fully_bound_structs\n [`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option"}, {"sha": "69a734e4ee4c2126a6bef72218d0b9a4b5e4aafc", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -245,7 +245,7 @@ this to work, you will need the fix of `git subtree` available\n [here][gitgitgadget-pr].\n \n [gitgitgadget-pr]: https://github.com/gitgitgadget/git/pull/493\n-[subtree]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#external-dependencies-subtree\n+[subtree]: https://rustc-dev-guide.rust-lang.org/contributing.html#external-dependencies-subtree\n [`rust-lang/rust`]: https://github.com/rust-lang/rust\n \n ## Issue and PR triage"}, {"sha": "ef01364b7d9655b97ee426fdcdd29ce7a6e4dcdf", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 76, "deletions": 39, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,8 +2,8 @@\n \n use crate::reexport::Name;\n use crate::utils::{\n-    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, without_block_comments,\n+    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_help,\n+    span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n@@ -17,7 +17,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Symbol, SymbolStr};\n use semver::Version;\n \n static UNIX_SYSTEMS: &[&str] = &[\n@@ -182,6 +182,29 @@ declare_clippy_lint! {\n     \"unknown_lints for scoped Clippy lints\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n+    ///\n+    /// **Why is this bad?** Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\n+    /// These lints should only be enabled on a lint-by-lint basis and with careful consideration.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// #![deny(clippy::restriction)]\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![deny(clippy::as_conversions)]\n+    /// ```\n+    pub BLANKET_CLIPPY_RESTRICTION_LINTS,\n+    style,\n+    \"enabling the complete restriction group\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n     /// with `#[rustfmt::skip]`.\n@@ -249,15 +272,17 @@ declare_lint_pass!(Attributes => [\n     DEPRECATED_SEMVER,\n     USELESS_ATTRIBUTE,\n     UNKNOWN_CLIPPY_LINTS,\n+    BLANKET_CLIPPY_RESTRICTION_LINTS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Attributes {\n     fn check_attribute(&mut self, cx: &LateContext<'tcx>, attr: &'tcx Attribute) {\n         if let Some(items) = &attr.meta_item_list() {\n             if let Some(ident) = attr.ident() {\n-                match &*ident.as_str() {\n+                let ident = &*ident.as_str();\n+                match ident {\n                     \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                        check_clippy_lint_names(cx, items);\n+                        check_clippy_lint_names(cx, ident, items);\n                     },\n                     _ => {},\n                 }\n@@ -363,38 +388,43 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n     }\n }\n \n-#[allow(clippy::single_match_else)]\n-fn check_clippy_lint_names(cx: &LateContext<'_>, items: &[NestedMetaItem]) {\n-    let lint_store = cx.lints();\n-    for lint in items {\n+fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMetaItem]) {\n+    fn extract_name(lint: &NestedMetaItem) -> Option<SymbolStr> {\n         if_chain! {\n             if let Some(meta_item) = lint.meta_item();\n             if meta_item.path.segments.len() > 1;\n             if let tool_name = meta_item.path.segments[0].ident;\n             if tool_name.as_str() == \"clippy\";\n-            let name = meta_item.path.segments.last().unwrap().ident.name;\n-            if let CheckLintNameResult::Tool(Err((None, _))) = lint_store.check_lint_name(\n-                &name.as_str(),\n-                Some(tool_name.name),\n-            );\n+            let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n             then {\n+                return Some(lint_name.as_str());\n+            }\n+        }\n+        None\n+    }\n+\n+    let lint_store = cx.lints();\n+    for lint in items {\n+        if let Some(lint_name) = extract_name(lint) {\n+            if let CheckLintNameResult::Tool(Err((None, _))) =\n+                lint_store.check_lint_name(&lint_name, Some(sym!(clippy)))\n+            {\n                 span_lint_and_then(\n                     cx,\n                     UNKNOWN_CLIPPY_LINTS,\n                     lint.span(),\n-                    &format!(\"unknown clippy lint: clippy::{}\", name),\n+                    &format!(\"unknown clippy lint: clippy::{}\", lint_name),\n                     |diag| {\n-                        let name_lower = name.as_str().to_lowercase();\n-                        let symbols = lint_store.get_lints().iter().map(\n-                            |l| Symbol::intern(&l.name_lower())\n-                        ).collect::<Vec<_>>();\n-                        let sugg = find_best_match_for_name(\n-                            symbols.iter(),\n-                            &format!(\"clippy::{}\", name_lower),\n-                            None,\n-                        );\n-                        if name.as_str().chars().any(char::is_uppercase)\n-                            && lint_store.find_lints(&format!(\"clippy::{}\", name_lower)).is_ok() {\n+                        let name_lower = lint_name.to_lowercase();\n+                        let symbols = lint_store\n+                            .get_lints()\n+                            .iter()\n+                            .map(|l| Symbol::intern(&l.name_lower()))\n+                            .collect::<Vec<_>>();\n+                        let sugg = find_best_match_for_name(symbols.iter(), &format!(\"clippy::{}\", name_lower), None);\n+                        if lint_name.chars().any(char::is_uppercase)\n+                            && lint_store.find_lints(&format!(\"clippy::{}\", name_lower)).is_ok()\n+                        {\n                             diag.span_suggestion(\n                                 lint.span(),\n                                 \"lowercase the lint name\",\n@@ -409,10 +439,19 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, items: &[NestedMetaItem]) {\n                                 Applicability::MachineApplicable,\n                             );\n                         }\n-                    }\n+                    },\n+                );\n+            } else if lint_name == \"restriction\" && ident != \"allow\" {\n+                span_lint_and_help(\n+                    cx,\n+                    BLANKET_CLIPPY_RESTRICTION_LINTS,\n+                    lint.span(),\n+                    \"restriction lints are not meant to be all enabled\",\n+                    None,\n+                    \"try enabling only the lints you really need\",\n                 );\n             }\n-        };\n+        }\n     }\n }\n \n@@ -442,15 +481,14 @@ fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n }\n \n fn is_relevant_block(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n-    if let Some(stmt) = block.stmts.first() {\n-        match &stmt.kind {\n+    block.stmts.first().map_or(\n+        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e)),\n+        |stmt| match &stmt.kind {\n             StmtKind::Local(_) => true,\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n             _ => false,\n-        }\n-    } else {\n-        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e))\n-    }\n+        },\n+    )\n }\n \n fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n@@ -460,11 +498,10 @@ fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.kind {\n-                if let Some(fun_id) = tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n-                } else {\n-                    true\n-                }\n+                tables\n+                    .qpath_res(qpath, path_expr.hir_id)\n+                    .opt_def_id()\n+                    .map_or(true, |fun_id| !match_def_path(cx, fun_id, &paths::BEGIN_PANIC))\n             } else {\n                 true\n             }"}, {"sha": "d337262dfa6e2384897d37267bb1ec5ef0cd784e", "filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -11,7 +11,7 @@ declare_clippy_lint! {\n     /// non-async-aware MutexGuard.\n     ///\n     /// **Why is this bad?** The Mutex types found in syd::sync and parking_lot\n-    /// are not designed to operator in an async context across await points.\n+    /// are not designed to operate in an async context across await points.\n     ///\n     /// There are two potential solutions. One is to use an asynx-aware Mutex\n     /// type. Many asynchronous foundation crates provide such a Mutex type. The"}, {"sha": "42bff564de03d471b49264bee9da3daaa691cb19", "filename": "src/tools/clippy/clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -115,7 +115,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n                 COLLAPSIBLE_IF,\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n-                \"try\",\n+                \"collapse nested if block\",\n                 snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability).into_owned(),\n                 applicability,\n             );\n@@ -142,7 +142,7 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n                 let rhs = Sugg::ast(cx, check_inner, \"..\");\n                 diag.span_suggestion(\n                     expr.span,\n-                    \"try\",\n+                    \"collapse nested if block\",\n                     format!(\n                         \"if {} {}\",\n                         lhs.and(&rhs),"}, {"sha": "25ccabc1c883e200811c69b2762d6c0f008a8349", "filename": "src/tools/clippy/clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -122,8 +122,5 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n }\n \n fn kind_is_cmp(kind: BinOpKind) -> bool {\n-    match kind {\n-        BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq => true,\n-        _ => false,\n-    }\n+    matches!(kind, BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq)\n }"}, {"sha": "818d8188a787a6608f3071810b539010fea3ffcb", "filename": "src/tools/clippy/clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -153,5 +153,13 @@ declare_deprecated_lint! {\n     ///\n     /// **Deprecation reason:** Associated-constants are now preferred.\n     pub REPLACE_CONSTS,\n-    \"associated-constants `MIN`/`MAX` of integers are prefer to `{min,max}_value()` and module constants\"\n+    \"associated-constants `MIN`/`MAX` of integers are prefered to `{min,max}_value()` and module constants\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** The regex! macro does not exist anymore.\n+    pub REGEX_MACRO,\n+    \"the regex! macro has been removed from the regex crate in 2018\"\n }"}, {"sha": "323cad7fa1a8c7dcfe62eb67e71c4af4dd36bfae", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -73,9 +73,10 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n     match method_name {\n         \"deref\" => {\n-            if cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n+            let impls_deref_trait = cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n                 implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n-            }) {\n+            });\n+            if impls_deref_trait {\n                 span_lint_and_sugg(\n                     cx,\n                     EXPLICIT_DEREF_METHODS,\n@@ -88,9 +89,10 @@ fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var\n             }\n         },\n         \"deref_mut\" => {\n-            if cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n+            let impls_deref_mut_trait = cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n                 implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n-            }) {\n+            });\n+            if impls_deref_mut_trait {\n                 span_lint_and_sugg(\n                     cx,\n                     EXPLICIT_DEREF_METHODS,"}, {"sha": "01eff28cb195a26b27589e6960871aff443d718d", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -214,20 +214,20 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n }\n \n fn is_valid_operator(op: BinOp) -> bool {\n-    match op.node {\n+    matches!(\n+        op.node,\n         BinOpKind::Sub\n-        | BinOpKind::Div\n-        | BinOpKind::Eq\n-        | BinOpKind::Lt\n-        | BinOpKind::Le\n-        | BinOpKind::Gt\n-        | BinOpKind::Ge\n-        | BinOpKind::Ne\n-        | BinOpKind::And\n-        | BinOpKind::Or\n-        | BinOpKind::BitXor\n-        | BinOpKind::BitAnd\n-        | BinOpKind::BitOr => true,\n-        _ => false,\n-    }\n+            | BinOpKind::Div\n+            | BinOpKind::Eq\n+            | BinOpKind::Lt\n+            | BinOpKind::Le\n+            | BinOpKind::Gt\n+            | BinOpKind::Ge\n+            | BinOpKind::Ne\n+            | BinOpKind::And\n+            | BinOpKind::Or\n+            | BinOpKind::BitXor\n+            | BinOpKind::BitAnd\n+            | BinOpKind::BitOr\n+    )\n }"}, {"sha": "ceb3c40d869a1ba4409fcd28b50060a2ab628149", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -105,10 +105,7 @@ fn is_argument(map: rustc_middle::hir::map::Map<'_>, id: HirId) -> bool {\n         _ => return false,\n     }\n \n-    match map.find(map.get_parent_node(id)) {\n-        Some(Node::Param(_)) => true,\n-        _ => false,\n-    }\n+    matches!(map.find(map.get_parent_node(id)), Some(Node::Param(_)))\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {"}, {"sha": "fb26b9fc27d259793ed799f6d6d4888aaec85d3d", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -175,10 +175,7 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n     match (&lhs.kind, &rhs.kind) {\n         (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n-        (l, r) => match (l, r) {\n-            (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n-            (_, _) => true,\n-        },\n+        (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n     }\n }\n "}, {"sha": "3087d6a940a867268b8aab2c823193400bed58d8", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 224, "deletions": 3, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,11 +1,11 @@\n use crate::consts::{\n     constant, constant_simple, Constant,\n-    Constant::{F32, F64},\n+    Constant::{Int, F32, F64},\n };\n-use crate::utils::{higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n+use crate::utils::{get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -293,6 +293,121 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n+fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some((value, _)) = constant(cx, cx.tables(), &args[1]) {\n+        if value == Int(2) {\n+            if let Some(parent) = get_parent_expr(cx, expr) {\n+                if let Some(grandparent) = get_parent_expr(cx, parent) {\n+                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, _, args, _) = grandparent.kind {\n+                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+                            return;\n+                        }\n+                    }\n+                }\n+\n+                if let ExprKind::Binary(\n+                    Spanned {\n+                        node: BinOpKind::Add, ..\n+                    },\n+                    ref lhs,\n+                    ref rhs,\n+                ) = parent.kind\n+                {\n+                    let other_addend = if lhs.hir_id == expr.hir_id { rhs } else { lhs };\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        SUBOPTIMAL_FLOPS,\n+                        parent.span,\n+                        \"square can be computed more efficiently\",\n+                        \"consider using\",\n+                        format!(\n+                            \"{}.mul_add({}, {})\",\n+                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, &other_addend, \"..\"),\n+                        ),\n+                        Applicability::MachineApplicable,\n+                    );\n+\n+                    return;\n+                }\n+            }\n+\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                \"square can be computed more efficiently\",\n+                \"consider using\",\n+                format!(\"{} * {}\", Sugg::hir(cx, &args[0], \"..\"), Sugg::hir(cx, &args[0], \"..\")),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n+    if let ExprKind::Binary(\n+        Spanned {\n+            node: BinOpKind::Add, ..\n+        },\n+        ref add_lhs,\n+        ref add_rhs,\n+    ) = args[0].kind\n+    {\n+        // check if expression of the form x * x + y * y\n+        if_chain! {\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n+            if are_exprs_equal(cx, lmul_lhs, lmul_rhs);\n+            if are_exprs_equal(cx, rmul_lhs, rmul_rhs);\n+            then {\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n+            }\n+        }\n+\n+        // check if expression of the form x.powi(2) + y.powi(2)\n+        if_chain! {\n+            if let ExprKind::MethodCall(\n+                PathSegment { ident: lmethod_name, .. },\n+                ref _lspan,\n+                ref largs,\n+                _\n+            ) = add_lhs.kind;\n+            if let ExprKind::MethodCall(\n+                PathSegment { ident: rmethod_name, .. },\n+                ref _rspan,\n+                ref rargs,\n+                _\n+            ) = add_rhs.kind;\n+            if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n+            if let Some((lvalue, _)) = constant(cx, cx.tables(), &largs[1]);\n+            if let Some((rvalue, _)) = constant(cx, cx.tables(), &rargs[1]);\n+            if Int(2) == lvalue && Int(2) == rvalue;\n+            then {\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\")));\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some(message) = detect_hypot(cx, args) {\n+        span_lint_and_sugg(\n+            cx,\n+            IMPRECISE_FLOPS,\n+            expr.span,\n+            \"hypotenuse can be computed more accurately\",\n+            \"consider using\",\n+            message,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n // TODO: Lint expressions of the form `x.exp() - y` where y > 1\n // and suggest usage of `x.exp_m1() - (y - 1)` instead\n fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n@@ -344,6 +459,14 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         rhs,\n     ) = &expr.kind\n     {\n+        if let Some(parent) = get_parent_expr(cx, expr) {\n+            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, _, args, _) = parent.kind {\n+                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+                    return;\n+                }\n+            }\n+        }\n+\n         let (recv, arg1, arg2) = if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, lhs) {\n             (inner_lhs, inner_rhs, rhs)\n         } else if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, rhs) {\n@@ -479,6 +602,100 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n }\n \n+fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, ref args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, ref args_b, _) = expr_b.kind;\n+        then {\n+            return method_name_a.as_str() == method_name_b.as_str() &&\n+                args_a.len() == args_b.len() &&\n+                (\n+                    [\"ln\", \"log2\", \"log10\"].contains(&&*method_name_a.as_str()) ||\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && are_exprs_equal(cx, &args_a[1], &args_b[1])\n+                );\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    // check if expression of the form x.logN() / y.logN()\n+    if_chain! {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Div, ..\n+            },\n+            lhs,\n+            rhs,\n+        ) = &expr.kind;\n+        if are_same_base_logs(cx, lhs, rhs);\n+        if let ExprKind::MethodCall(_, _, ref largs, _) = lhs.kind;\n+        if let ExprKind::MethodCall(_, _, ref rargs, _) = rhs.kind;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                \"log base can be expressed more clearly\",\n+                \"consider using\",\n+                format!(\"{}.log({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\"),),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Div, ..\n+            },\n+            div_lhs,\n+            div_rhs,\n+        ) = &expr.kind;\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Mul, ..\n+            },\n+            mul_lhs,\n+            mul_rhs,\n+        ) = &div_lhs.kind;\n+        if let Some((rvalue, _)) = constant(cx, cx.tables(), div_rhs);\n+        if let Some((lvalue, _)) = constant(cx, cx.tables(), mul_rhs);\n+        then {\n+            // TODO: also check for constant values near PI/180 or 180/PI\n+            if (F32(f32_consts::PI) == rvalue || F64(f64_consts::PI) == rvalue) &&\n+               (F32(180_f32) == lvalue || F64(180_f64) == lvalue)\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SUBOPTIMAL_FLOPS,\n+                    expr.span,\n+                    \"conversion to degrees can be done more accurately\",\n+                    \"consider using\",\n+                    format!(\"{}.to_degrees()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else if\n+                (F32(180_f32) == rvalue || F64(180_f64) == rvalue) &&\n+                (F32(f32_consts::PI) == lvalue || F64(f64_consts::PI) == lvalue)\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SUBOPTIMAL_FLOPS,\n+                    expr.span,\n+                    \"conversion to radians can be done more accurately\",\n+                    \"consider using\",\n+                    format!(\"{}.to_radians()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n@@ -489,13 +706,17 @@ impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n                     \"ln\" => check_ln1p(cx, expr, args),\n                     \"log\" => check_log_base(cx, expr, args),\n                     \"powf\" => check_powf(cx, expr, args),\n+                    \"powi\" => check_powi(cx, expr, args),\n+                    \"sqrt\" => check_hypot(cx, expr, args),\n                     _ => {},\n                 }\n             }\n         } else {\n             check_expm1(cx, expr);\n             check_mul_add(cx, expr);\n             check_custom_abs(cx, expr);\n+            check_log_division(cx, expr);\n+            check_radians(cx, expr);\n         }\n     }\n }"}, {"sha": "1bd16e6cce53a3a5fae6dab1fb18b936c1679682", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -305,18 +305,10 @@ fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n }\n \n fn is_block(expr: &Expr) -> bool {\n-    if let ExprKind::Block(..) = expr.kind {\n-        true\n-    } else {\n-        false\n-    }\n+    matches!(expr.kind, ExprKind::Block(..))\n }\n \n /// Check if the expression is an `if` or `if let`\n fn is_if(expr: &Expr) -> bool {\n-    if let ExprKind::If(..) = expr.kind {\n-        true\n-    } else {\n-        false\n-    }\n+    matches!(expr.kind, ExprKind::If(..))\n }"}, {"sha": "63133a4872a3e76dd698cc3354a490cd2f0fdf91", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -645,13 +645,7 @@ fn is_mutated_static(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> bool {\n     use hir::ExprKind::{Field, Index, Path};\n \n     match e.kind {\n-        Path(ref qpath) => {\n-            if let Res::Local(_) = qpath_res(cx, qpath, e.hir_id) {\n-                false\n-            } else {\n-                true\n-            }\n-        },\n+        Path(ref qpath) => !matches!(qpath_res(cx, qpath, e.hir_id), Res::Local(_)),\n         Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(cx, inner),\n         _ => false,\n     }"}, {"sha": "fbd2eeacc6ef553cf7146eade14619877280cab2", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -135,13 +135,10 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     }\n }\n \n-impl<'tcx> ArmVisitor<'_, 'tcx> {\n+impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n     fn same_mutex(&self, cx: &LateContext<'_>, op_mutex: &Expr<'_>) -> bool {\n-        if let Some(arm_mutex) = self.found_mutex {\n-            SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex)\n-        } else {\n-            false\n-        }\n+        self.found_mutex\n+            .map_or(false, |arm_mutex| SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex))\n     }\n }\n "}, {"sha": "1b09328ceabb004275f41c031f913d132154ec64", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -302,16 +302,12 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tables().expr_ty(expr));\n     match ty.kind {\n-        ty::Dynamic(ref tt, ..) => {\n-            if let Some(principal) = tt.principal() {\n-                cx.tcx\n-                    .associated_items(principal.def_id())\n-                    .in_definition_order()\n-                    .any(|item| is_is_empty(cx, &item))\n-            } else {\n-                false\n-            }\n-        },\n+        ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n+            cx.tcx\n+                .associated_items(principal.def_id())\n+                .in_definition_order()\n+                .any(|item| is_is_empty(cx, &item))\n+        }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::Array(..) | ty::Slice(..) | ty::Str => true,"}, {"sha": "fa560ffb980c82407d748018b6b12717c7572267", "filename": "src/tools/clippy/clippy_lints/src/let_and_return.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,6 +1,5 @@\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -9,7 +8,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use crate::utils::{in_macro, match_qpath, snippet_opt, span_lint_and_then};\n+use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_then};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `let`-bindings, which are subsequently\n@@ -97,22 +96,6 @@ struct BorrowVisitor<'a, 'tcx> {\n     borrows: bool,\n }\n \n-impl BorrowVisitor<'_, '_> {\n-    fn fn_def_id(&self, expr: &Expr<'_>) -> Option<DefId> {\n-        match &expr.kind {\n-            ExprKind::MethodCall(..) => self.cx.tables().type_dependent_def_id(expr.hir_id),\n-            ExprKind::Call(\n-                Expr {\n-                    kind: ExprKind::Path(qpath),\n-                    ..\n-                },\n-                ..,\n-            ) => self.cx.qpath_res(qpath, expr.hir_id).opt_def_id(),\n-            _ => None,\n-        }\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -121,7 +104,7 @@ impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n             return;\n         }\n \n-        if let Some(def_id) = self.fn_def_id(expr) {\n+        if let Some(def_id) = fn_def_id(self.cx, expr) {\n             self.borrows = self\n                 .cx\n                 .tcx"}, {"sha": "32e79317f82254119bf9b3075ef15f3b827f3ea7", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -229,6 +229,7 @@ mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n mod map_clone;\n+mod map_identity;\n mod map_unit_fn;\n mod match_on_vec_items;\n mod matches;\n@@ -263,22 +264,24 @@ mod non_copy_const;\n mod non_expressive_names;\n mod open_options;\n mod option_env_unwrap;\n+mod option_if_let_else;\n mod overflow_check_conditional;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n mod path_buf_push_overwrite;\n+mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n mod ptr_offset_with_cast;\n mod question_mark;\n mod ranges;\n mod redundant_clone;\n mod redundant_field_names;\n-mod redundant_pattern_matching;\n mod redundant_pub_crate;\n mod redundant_static_lifetimes;\n mod reference;\n mod regex;\n+mod repeat_once;\n mod returns;\n mod serde_api;\n mod shadow;\n@@ -459,7 +462,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_removed(\n         \"clippy::replace_consts\",\n-        \"associated-constants `MIN`/`MAX` of integers are prefer to `{min,max}_value()` and module constants\",\n+        \"associated-constants `MIN`/`MAX` of integers are prefered to `{min,max}_value()` and module constants\",\n+    );\n+    store.register_removed(\n+        \"clippy::regex_macro\",\n+        \"the regex! macro has been removed from the regex crate in 2018\",\n     );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n@@ -473,6 +480,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &assign_ops::ASSIGN_OP_PATTERN,\n         &assign_ops::MISREFACTORED_ASSIGN_OP,\n         &atomic_ordering::INVALID_ATOMIC_ORDERING,\n+        &attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n         &attrs::DEPRECATED_CFG_ATTR,\n         &attrs::DEPRECATED_SEMVER,\n         &attrs::EMPTY_LINE_AFTER_OUTER_ATTR,\n@@ -608,17 +616,20 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &map_clone::MAP_CLONE,\n+        &map_identity::MAP_IDENTITY,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n         &match_on_vec_items::MATCH_ON_VEC_ITEMS,\n         &matches::INFALLIBLE_DESTRUCTURING_MATCH,\n         &matches::MATCH_AS_REF,\n         &matches::MATCH_BOOL,\n+        &matches::MATCH_LIKE_MATCHES_MACRO,\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n         &matches::MATCH_SINGLE_BINDING,\n         &matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n         &matches::MATCH_WILD_ERR_ARM,\n+        &matches::REDUNDANT_PATTERN_MATCHING,\n         &matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n         &matches::SINGLE_MATCH,\n         &matches::SINGLE_MATCH_ELSE,\n@@ -726,6 +737,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &non_expressive_names::SIMILAR_NAMES,\n         &open_options::NONSENSICAL_OPEN_OPTIONS,\n         &option_env_unwrap::OPTION_ENV_UNWRAP,\n+        &option_if_let_else::OPTION_IF_LET_ELSE,\n         &overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n         &panic_unimplemented::PANIC,\n         &panic_unimplemented::PANIC_PARAMS,\n@@ -734,6 +746,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &panic_unimplemented::UNREACHABLE,\n         &partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n         &path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n+        &pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n         &precedence::PRECEDENCE,\n         &ptr::CMP_NULL,\n         &ptr::MUT_FROM_REF,\n@@ -746,14 +759,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ranges::REVERSED_EMPTY_RANGES,\n         &redundant_clone::REDUNDANT_CLONE,\n         &redundant_field_names::REDUNDANT_FIELD_NAMES,\n-        &redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n         &redundant_pub_crate::REDUNDANT_PUB_CRATE,\n         &redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n         &reference::DEREF_ADDROF,\n         &reference::REF_IN_DEREF,\n         &regex::INVALID_REGEX,\n-        &regex::REGEX_MACRO,\n         &regex::TRIVIAL_REGEX,\n+        &repeat_once::REPEAT_ONCE,\n         &returns::NEEDLESS_RETURN,\n         &returns::UNUSED_UNIT,\n         &serde_api::SERDE_API_MISUSE,\n@@ -946,7 +958,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box missing_doc::MissingDoc::new());\n     store.register_late_pass(|| box missing_inline::MissingInline);\n     store.register_late_pass(|| box if_let_some_result::OkIfLet);\n-    store.register_late_pass(|| box redundant_pattern_matching::RedundantPatternMatching);\n     store.register_late_pass(|| box partialeq_ne_impl::PartialEqNeImpl);\n     store.register_late_pass(|| box unused_io_amount::UnusedIoAmount);\n     let enum_variant_size_threshold = conf.enum_variant_size_threshold;\n@@ -990,7 +1001,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box checked_conversions::CheckedConversions);\n     store.register_late_pass(|| box integer_division::IntegerDivision);\n     store.register_late_pass(|| box inherent_to_string::InherentToString);\n-    store.register_late_pass(|| box trait_bounds::TraitBounds);\n+    let max_trait_bounds = conf.max_trait_bounds;\n+    store.register_late_pass(move || box trait_bounds::TraitBounds::new(max_trait_bounds));\n     store.register_late_pass(|| box comparison_chain::ComparisonChain);\n     store.register_late_pass(|| box mut_key::MutableKeyType);\n     store.register_late_pass(|| box modulo_arithmetic::ModuloArithmetic);\n@@ -1027,7 +1039,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let array_size_threshold = conf.array_size_threshold;\n     store.register_late_pass(move || box large_stack_arrays::LargeStackArrays::new(array_size_threshold));\n     store.register_late_pass(move || box large_const_arrays::LargeConstArrays::new(array_size_threshold));\n-    store.register_late_pass(move || box floating_point_arithmetic::FloatingPointArithmetic);\n+    store.register_late_pass(|| box floating_point_arithmetic::FloatingPointArithmetic);\n     store.register_early_pass(|| box as_conversions::AsConversions);\n     store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n     store.register_late_pass(|| box let_underscore::LetUnderscore);\n@@ -1043,6 +1055,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n     store.register_late_pass(|| box dereference::Dereferencing);\n+    store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n@@ -1057,6 +1070,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n     store.register_late_pass(|| box macro_use::MacroUseImports::default());\n+    store.register_late_pass(|| box map_identity::MapIdentity);\n+    store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n+    store.register_late_pass(|| box repeat_once::RepeatOnce);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1090,6 +1106,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&panic_unimplemented::TODO),\n         LintId::of(&panic_unimplemented::UNIMPLEMENTED),\n         LintId::of(&panic_unimplemented::UNREACHABLE),\n+        LintId::of(&pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n         LintId::of(&shadow::SHADOW_REUSE),\n         LintId::of(&shadow::SHADOW_SAME),\n         LintId::of(&strings::STRING_ADD),\n@@ -1146,6 +1163,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_continue::NEEDLESS_CONTINUE),\n         LintId::of(&needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(&non_expressive_names::SIMILAR_NAMES),\n+        LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n+        LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n@@ -1186,6 +1205,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&assign_ops::ASSIGN_OP_PATTERN),\n         LintId::of(&assign_ops::MISREFACTORED_ASSIGN_OP),\n         LintId::of(&atomic_ordering::INVALID_ATOMIC_ORDERING),\n+        LintId::of(&attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(&attrs::DEPRECATED_CFG_ATTR),\n         LintId::of(&attrs::DEPRECATED_SEMVER),\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n@@ -1273,13 +1293,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n+        LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_AS_REF),\n+        LintId::of(&matches::MATCH_LIKE_MATCHES_MACRO),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n         LintId::of(&matches::MATCH_SINGLE_BINDING),\n+        LintId::of(&matches::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n         LintId::of(&mem_discriminant::MEM_DISCRIMINANT_NON_ENUM),\n@@ -1364,18 +1387,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n         LintId::of(&question_mark::QUESTION_MARK),\n-        LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n-        LintId::of(&redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n         LintId::of(&regex::INVALID_REGEX),\n-        LintId::of(&regex::REGEX_MACRO),\n         LintId::of(&regex::TRIVIAL_REGEX),\n+        LintId::of(&repeat_once::REPEAT_ONCE),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n@@ -1437,6 +1458,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n         LintId::of(&assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n         LintId::of(&assign_ops::ASSIGN_OP_PATTERN),\n+        LintId::of(&attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n@@ -1470,8 +1492,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+        LintId::of(&matches::MATCH_LIKE_MATCHES_MACRO),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n+        LintId::of(&matches::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_DEFAULT),\n@@ -1508,9 +1532,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&question_mark::QUESTION_MARK),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n-        LintId::of(&redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n-        LintId::of(&regex::REGEX_MACRO),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n@@ -1550,6 +1572,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::WHILE_LET_LOOP),\n+        LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(&matches::MATCH_AS_REF),\n@@ -1580,10 +1603,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n         LintId::of(&precedence::PRECEDENCE),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n-        LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n+        LintId::of(&repeat_once::REPEAT_ONCE),\n         LintId::of(&swap::MANUAL_SWAP),\n         LintId::of(&temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(&transmute::CROSSPOINTER_TRANSMUTE),"}, {"sha": "168f9f953e4d899b70174f8db6d06b55610f1a09", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -129,10 +129,10 @@ fn check_fn_inner<'tcx>(\n     }\n \n     let mut bounds_lts = Vec::new();\n-    let types = generics.params.iter().filter(|param| match param.kind {\n-        GenericParamKind::Type { .. } => true,\n-        _ => false,\n-    });\n+    let types = generics\n+        .params\n+        .iter()\n+        .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n         for bound in typ.bounds {\n             let mut visitor = RefVisitor::new(cx);\n@@ -337,10 +337,10 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath<'_>, ty: &Ty<'_>) {\n         if let Some(ref last_path_segment) = last_path_segment(qpath).args {\n             if !last_path_segment.parenthesized\n-                && !last_path_segment.args.iter().any(|arg| match arg {\n-                    GenericArg::Lifetime(_) => true,\n-                    _ => false,\n-                })\n+                && !last_path_segment\n+                    .args\n+                    .iter()\n+                    .any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n             {\n                 let hir_id = ty.hir_id;\n                 match self.cx.qpath_res(qpath, hir_id) {"}, {"sha": "a36fdca5d5de6a5816d8ff369501fad9c651b3dd", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -264,10 +264,13 @@ impl LiteralDigitGrouping {\n \n         let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut num_lit.exponent {\n             (exponent, &[\"32\", \"64\"][..], 'f')\n-        } else if let Some(fraction) = &mut num_lit.fraction {\n-            (fraction, &[\"32\", \"64\"][..], 'f')\n         } else {\n-            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+            num_lit\n+                .fraction\n+                .as_mut()\n+                .map_or((&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i'), |fraction| {\n+                    (fraction, &[\"32\", \"64\"][..], 'f')\n+                })\n         };\n \n         let mut split = part.rsplit('_');"}, {"sha": "396bb6591090321e80c534f2903f68d88b4b3b69", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -686,13 +686,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => {\n-            if let Some(ref e) = *e {\n-                combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n-            } else {\n-                NeverLoopResult::AlwaysBreak\n-            }\n-        },\n+        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+        }),\n         ExprKind::InlineAsm(ref asm) => asm\n             .operands\n             .iter()\n@@ -1881,13 +1877,9 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.kind {\n-        ty::Array(_, n) => {\n-            if let Some(val) = n.try_eval_usize(cx.tcx, cx.param_env) {\n-                (0..=32).contains(&val)\n-            } else {\n-                false\n-            }\n-        },\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n         _ => false,\n     }\n }\n@@ -1899,11 +1891,7 @@ fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<\n         return None;\n     }\n     if let StmtKind::Local(ref local) = block.stmts[0].kind {\n-        if let Some(expr) = local.init {\n-            Some(expr)\n-        } else {\n-            None\n-        }\n+        local.init //.map(|expr| expr)\n     } else {\n         None\n     }\n@@ -2023,15 +2011,13 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n                 if let PatKind::Binding(.., ident, _) = local.pat.kind {\n                     self.name = Some(ident.name);\n \n-                    self.state = if let Some(ref init) = local.init {\n+                    self.state = local.init.as_ref().map_or(VarState::Declared, |init| {\n                         if is_integer_const(&self.cx, init, 0) {\n                             VarState::Warn\n                         } else {\n                             VarState::Declared\n                         }\n-                    } else {\n-                        VarState::Declared\n-                    }\n+                    })\n                 }\n             }\n         }\n@@ -2105,17 +2091,11 @@ fn var_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<HirId> {\n }\n \n fn is_loop(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Loop(..) => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Loop(..))\n }\n \n fn is_conditional(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Match(..) => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Match(..))\n }\n \n fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {"}, {"sha": "24ec78c884647951dcb82849f8ffff9f2bc24800", "filename": "src/tools/clippy/clippy_lints/src/map_identity.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,126 @@\n+use crate::utils::{\n+    is_adjusted, is_type_diagnostic_item, match_path, match_trait_method, match_var, paths, remove_blocks,\n+    span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n+    ///\n+    /// **Why is this bad?** It can be written more concisely without the call to `map`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n+    /// ```\n+    pub MAP_IDENTITY,\n+    complexity,\n+    \"using iterator.map(|x| x)\"\n+}\n+\n+declare_lint_pass!(MapIdentity => [MAP_IDENTITY]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let Some([caller, func]) = get_map_argument(cx, expr);\n+            if is_expr_identity_function(cx, func);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MAP_IDENTITY,\n+                    expr.span.trim_start(caller.span).unwrap(),\n+                    \"unnecessary map of the identity function\",\n+                    \"remove the call to `map`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns the arguments passed into map() if the expression is a method call to\n+/// map(). Otherwise, returns None.\n+fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if args.len() == 2 && method.ident.as_str() == \"map\";\n+        let caller_ty = cx.tables().expr_ty(&args[0]);\n+        if match_trait_method(cx, expr, &paths::ITERATOR)\n+            || is_type_diagnostic_item(cx, caller_ty, sym!(result_type))\n+            || is_type_diagnostic_item(cx, caller_ty, sym!(option_type));\n+        then {\n+            Some(args)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Checks if an expression represents the identity function\n+/// Only examines closures and `std::convert::identity`\n+fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n+        ExprKind::Path(QPath::Resolved(_, ref path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if a function's body represents the identity function\n+/// Looks for bodies of the form `|x| x`, `|x| return x`, `|x| { return x }` or `|x| {\n+/// return x; }`\n+fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n+    let params = func.params;\n+    let body = remove_blocks(&func.value);\n+\n+    // if there's less/more than one parameter, then it is not the identity function\n+    if params.len() != 1 {\n+        return false;\n+    }\n+\n+    match body.kind {\n+        ExprKind::Path(QPath::Resolved(None, _)) => match_expr_param(cx, body, params[0].pat),\n+        ExprKind::Ret(Some(ref ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n+        ExprKind::Block(ref block, _) => {\n+            if_chain! {\n+                if block.stmts.len() == 1;\n+                if let StmtKind::Semi(ref expr) | StmtKind::Expr(ref expr) = block.stmts[0].kind;\n+                if let ExprKind::Ret(Some(ref ret_val)) = expr.kind;\n+                then {\n+                    match_expr_param(cx, ret_val, params[0].pat)\n+                } else {\n+                    false\n+                }\n+            }\n+        },\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true iff an expression returns the same thing as a parameter's pattern\n+fn match_expr_param(cx: &LateContext<'_>, expr: &Expr<'_>, pat: &Pat<'_>) -> bool {\n+    if let PatKind::Binding(_, _, ident, _) = pat.kind {\n+        match_var(expr, ident.name) && !(cx.tables().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "bd474c208070cb516d9b5ff3305272cc91c8f69d", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 390, "deletions": 22, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -13,14 +13,14 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n-    QPath, RangeEnd,\n+    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, Local, MatchSource, Mutability, Node, Pat,\n+    PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n+use rustc_span::source_map::{Span, Spanned};\n use std::cmp::Ordering;\n use std::collections::Bound;\n \n@@ -409,6 +409,74 @@ declare_clippy_lint! {\n     \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Lint for redundant pattern matching over `Result` or\n+    /// `Option`\n+    ///\n+    /// **Why is this bad?** It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `match`  or `if let` expressions producing a\n+    /// `bool` that could be written using `matches!`\n+    ///\n+    /// **Why is this bad?** Readability and needless complexity.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Some(5);\n+    ///\n+    /// // Bad\n+    /// let a = match x {\n+    ///     Some(0) => true,\n+    ///     _ => false,\n+    /// };\n+    ///\n+    /// let a = if let Some(0) = x {\n+    ///     true\n+    /// } else {\n+    ///     false\n+    /// };\n+    ///\n+    /// // Good\n+    /// let a = matches!(x, Some(0));\n+    /// ```\n+    pub MATCH_LIKE_MATCHES_MACRO,\n+    style,\n+    \"a match that could be written with the matches! macro\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     infallible_destructuring_match_linted: bool,\n@@ -427,14 +495,20 @@ impl_lint_pass!(Matches => [\n     WILDCARD_IN_OR_PATTERNS,\n     MATCH_SINGLE_BINDING,\n     INFALLIBLE_DESTRUCTURING_MATCH,\n-    REST_PAT_IN_FULLY_BOUND_STRUCTS\n+    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    REDUNDANT_PATTERN_MATCHING,\n+    MATCH_LIKE_MATCHES_MACRO\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n+\n+        redundant_pattern_match::check(cx, expr);\n+        check_match_like_matches(cx, expr);\n+\n         if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n@@ -530,16 +604,22 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             // the lint noisy in unnecessary situations\n             return;\n         }\n-        let els = remove_blocks(&arms[1].body);\n-        let els = if is_unit_expr(els) {\n+        let els = arms[1].body;\n+        let els = if is_unit_expr(remove_blocks(els)) {\n             None\n-        } else if let ExprKind::Block(_, _) = els.kind {\n-            // matches with blocks that contain statements are prettier as `if let + else`\n-            Some(els)\n+        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n+            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n+                // single statement/expr \"else\" block, don't lint\n+                return;\n+            } else {\n+                // block with 2+ statements or 1 expr and 1+ statement\n+                Some(els)\n+            }\n         } else {\n-            // allow match arms with just expressions\n-            return;\n+            // not a block, don't lint\n+            return; \n         };\n+\n         let ty = cx.tables().expr_ty(ex);\n         if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n@@ -802,13 +882,8 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                     // Some simple checks for exhaustive patterns.\n                     // There is a room for improvements to detect more cases,\n                     // but it can be more expensive to do so.\n-                    let is_pattern_exhaustive = |pat: &&Pat<'_>| {\n-                        if let PatKind::Wild | PatKind::Binding(.., None) = pat.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    };\n+                    let is_pattern_exhaustive =\n+                        |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n                     if patterns.iter().all(is_pattern_exhaustive) {\n                         missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                     }\n@@ -989,6 +1064,79 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     }\n }\n \n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n+        match match_source {\n+            MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n+            MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n+            _ => return,\n+        }\n+    }\n+}\n+\n+/// Lint a `match` or desugared `if let` for replacement by `matches!`\n+fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n+    if_chain! {\n+        if arms.len() == 2;\n+        if cx.tables().expr_ty(expr).is_bool();\n+        if is_wild(&arms[1].pat);\n+        if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n+        if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n+        if first != second;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            let pat_and_guard = if let Some(Guard::If(g)) = arms[0].guard {\n+                format!(\"{} if {}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability), snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                format!(\"{}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability))\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if desugared { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if first { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            )\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if desugared => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n@@ -1179,10 +1327,7 @@ fn is_unit_expr(expr: &Expr<'_>) -> bool {\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(arm: &Arm<'_>) -> bool {\n-    match arm.pat.kind {\n-        PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n-        _ => false,\n-    }\n+    matches!(arm.pat.kind, PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE))\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n@@ -1293,6 +1438,229 @@ where\n     None\n }\n \n+mod redundant_pattern_match {\n+    use super::REDUNDANT_PATTERN_MATCHING;\n+    use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n+    use if_chain::if_chain;\n+    use rustc_ast::ast::LitKind;\n+    use rustc_errors::Applicability;\n+    use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n+    use rustc_lint::LateContext;\n+    use rustc_middle::ty;\n+    use rustc_mir::const_eval::is_const_fn;\n+    use rustc_span::source_map::Symbol;\n+\n+    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n+            match match_source {\n+                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n+                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n+                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n+                _ => {},\n+            }\n+        }\n+    }\n+\n+    fn find_sugg_for_if_let<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        op: &Expr<'_>,\n+        arms: &[Arm<'_>],\n+        keyword: &'static str,\n+    ) {\n+        fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n+            if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n+                return Some(\"is_ok()\");\n+            }\n+            if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n+                return Some(\"is_err()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n+                return Some(\"is_some()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n+                return Some(\"is_none()\");\n+            }\n+            None\n+        }\n+\n+        let hir_id = expr.hir_id;\n+        let good_method = match arms[0].pat.kind {\n+            PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_suggestion(cx, hir_id, path)\n+                } else {\n+                    None\n+                }\n+            },\n+            PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n+            _ => None,\n+        };\n+        let good_method = match good_method {\n+            Some(method) => method,\n+            None => return,\n+        };\n+\n+        // check that `while_let_on_iterator` lint does not trigger\n+        if_chain! {\n+            if keyword == \"while\";\n+            if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n+            if method_path.ident.name == sym!(next);\n+            if match_trait_method(cx, op, &paths::ITERATOR);\n+            then {\n+                return;\n+            }\n+        }\n+\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_PATTERN_MATCHING,\n+            arms[0].pat.span,\n+            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+            |diag| {\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                let expr_span = expr.span;\n+\n+                // while let ... = ... { ... }\n+                //                 ^^^\n+                let op_span = op.span.source_callsite();\n+\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^\n+                let span = expr_span.until(op_span.shrink_to_hi());\n+                diag.span_suggestion(\n+                    span,\n+                    \"try this\",\n+                    format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            },\n+        );\n+    }\n+\n+    fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+        if arms.len() == 2 {\n+            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+            let hir_id = expr.hir_id;\n+            let found_good_method = match node_pair {\n+                (\n+                    PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n+                    PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n+                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::RESULT_OK,\n+                            &paths::RESULT_ERR,\n+                            \"is_ok()\",\n+                            \"is_err()\",\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n+                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n+                    if patterns.len() == 1 =>\n+                {\n+                    if let PatKind::Wild = patterns[0].kind {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::OPTION_SOME,\n+                            &paths::OPTION_NONE,\n+                            \"is_some()\",\n+                            \"is_none()\",\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            };\n+\n+            if let Some(good_method) = found_good_method {\n+                span_lint_and_then(\n+                    cx,\n+                    REDUNDANT_PATTERN_MATCHING,\n+                    expr.span,\n+                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                    |diag| {\n+                        let span = expr.span.to(op.span);\n+                        diag.span_suggestion(\n+                            span,\n+                            \"try this\",\n+                            format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                            Applicability::MaybeIncorrect, // snippet\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn find_good_method_for_match<'a>(\n+        arms: &[Arm<'_>],\n+        path_left: &QPath<'_>,\n+        path_right: &QPath<'_>,\n+        expected_left: &[&str],\n+        expected_right: &[&str],\n+        should_be_left: &'a str,\n+        should_be_right: &'a str,\n+        can_suggest_left: impl Fn() -> bool,\n+        can_suggest_right: impl Fn() -> bool,\n+    ) -> Option<&'a str> {\n+        let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+            (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+        } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+            (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+        } else {\n+            return None;\n+        };\n+\n+        match body_node_pair {\n+            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+                (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n+                (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n+        if !in_constant(cx, hir_id) {\n+            return true;\n+        }\n+\n+        // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n+        cx.tcx\n+            .get_diagnostic_item(diag_item)\n+            .and_then(|def_id| {\n+                cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n+                    cx.tcx\n+                        .associated_items(*imp)\n+                        .in_definition_order()\n+                        .find_map(|item| match item.kind {\n+                            ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n+                            _ => None,\n+                        })\n+                })\n+            })\n+            .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n+    }\n+}\n+\n #[test]\n fn test_overlapping() {\n     use rustc_span::source_map::DUMMY_SP;"}, {"sha": "4c595029ff7bc32fd81c56a2e7c7c69af1943204", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1844,10 +1844,10 @@ fn lint_expect_fun_call(\n                         ty::Ref(ty::ReStatic, ..)\n                     )\n                 }),\n-            hir::ExprKind::Path(ref p) => match cx.qpath_res(p, arg.hir_id) {\n-                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _) => true,\n-                _ => false,\n-            },\n+            hir::ExprKind::Path(ref p) => matches!(\n+                cx.qpath_res(p, arg.hir_id),\n+                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n+            ),\n             _ => false,\n         }\n     }\n@@ -2028,13 +2028,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                     .tables()\n                     .expr_adjustments(arg)\n                     .iter()\n-                    .filter(|adj| {\n-                        if let ty::adjustment::Adjust::Deref(_) = adj.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    })\n+                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n                     .count();\n                 let derefs: String = iter::repeat('*').take(deref_count).collect();\n                 snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n@@ -2044,7 +2038,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n         }\n         span_lint_and_then(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\", |diag| {\n             if let Some((text, snip)) = snip {\n-                diag.span_suggestion(expr.span, text, snip, Applicability::Unspecified);\n+                diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n             }\n         });\n     }\n@@ -2460,13 +2454,9 @@ fn derefs_to_slice<'tcx>(\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym!(vec_type)),\n-            ty::Array(_, size) => {\n-                if let Some(size) = size.try_eval_usize(cx.tcx, cx.param_env) {\n-                    size < 32\n-                } else {\n-                    false\n-                }\n-            },\n+            ty::Array(_, size) => size\n+                .try_eval_usize(cx.tcx, cx.param_env)\n+                .map_or(false, |size| size < 32),\n             ty::Ref(_, inner, _) => may_slice(cx, inner),\n             _ => false,\n         }"}, {"sha": "75e123eb5939d971b7c7943485ea569894377ee1", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -77,13 +77,10 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             }\n             (true, true)\n         },\n-        hir::ExprKind::Block(ref block, _) => {\n-            if let Some(expr) = &block.expr {\n-                check_expression(cx, arg_id, &expr)\n-            } else {\n-                (false, false)\n-            }\n-        },\n+        hir::ExprKind::Block(ref block, _) => block\n+            .expr\n+            .as_ref()\n+            .map_or((false, false), |expr| check_expression(cx, arg_id, &expr)),\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;"}, {"sha": "c8aa98d348927e3f870d7e666df7d653f45b5dff", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MinMaxPass {\n     }\n }\n \n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n enum MinMax {\n     Min,\n     Max,\n@@ -86,16 +86,15 @@ fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Opt\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(cx, cx.tables(), &args[0]) {\n-        if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n-            // otherwise ignore\n-            Some((m, c, &args[1]))\n-        } else {\n-            None\n-        }\n-    } else if let Some(c) = constant_simple(cx, cx.tables(), &args[1]) {\n-        Some((m, c, &args[0]))\n-    } else {\n-        None\n-    }\n+    constant_simple(cx, cx.tables(), &args[0]).map_or_else(\n+        || constant_simple(cx, cx.tables(), &args[1]).map(|c| (m, c, &args[0])),\n+        |c| {\n+            if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n+                // otherwise ignore\n+                Some((m, c, &args[1]))\n+            } else {\n+                None\n+            }\n+        },\n+    )\n }"}, {"sha": "400f4b609af7f577833d183d1bf3486ef2224a88", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -3,11 +3,11 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt, StmtKind, Ty,\n-    TyKind, UnOp,\n+    self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n+    StmtKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n@@ -371,8 +371,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 if op.is_comparison() {\n                     check_nan(cx, left, expr);\n                     check_nan(cx, right, expr);\n-                    check_to_owned(cx, left, right);\n-                    check_to_owned(cx, right, left);\n+                    check_to_owned(cx, left, right, true);\n+                    check_to_owned(cx, right, left, false);\n                 }\n                 if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n                     if is_allowed(cx, left) || is_allowed(cx, right) {\n@@ -570,19 +570,38 @@ fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     matches!(&walk_ptrs_ty(cx.tables().expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n-fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n+fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n+    #[derive(Default)]\n+    struct EqImpl {\n+        ty_eq_other: bool,\n+        other_eq_ty: bool,\n+    }\n+\n+    impl EqImpl {\n+        fn is_implemented(&self) -> bool {\n+            self.ty_eq_other || self.other_eq_ty\n+        }\n+    }\n+\n+    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n+        cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n+            ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n+            other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n+        })\n+    }\n+\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.tables().expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.tables().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables().expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -593,28 +612,19 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n         _ => return,\n     };\n \n-    let other_ty = cx.tables().expr_ty_adjusted(other);\n-    let partial_eq_trait_id = match cx.tcx.lang_items().eq_trait() {\n-        Some(id) => id,\n-        None => return,\n-    };\n+    let other_ty = cx.tables().expr_ty(other);\n \n-    let deref_arg_impl_partial_eq_other = arg_ty.builtin_deref(true).map_or(false, |tam| {\n-        implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty.into()])\n-    });\n-    let arg_impl_partial_eq_deref_other = other_ty.builtin_deref(true).map_or(false, |tam| {\n-        implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty.into()])\n-    });\n-    let arg_impl_partial_eq_other = implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty.into()]);\n+    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n+    let with_deref = arg_ty\n+        .builtin_deref(true)\n+        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n+        .unwrap_or_default();\n \n-    if !deref_arg_impl_partial_eq_other && !arg_impl_partial_eq_deref_other && !arg_impl_partial_eq_other {\n+    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n         return;\n     }\n \n-    let other_gets_derefed = match other.kind {\n-        ExprKind::Unary(UnOp::UnDeref, _) => true,\n-        _ => false,\n-    };\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::UnDeref, _));\n \n     let lint_span = if other_gets_derefed {\n         expr.span.to(other.span)\n@@ -634,18 +644,34 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n                 return;\n             }\n \n-            let try_hint = if deref_arg_impl_partial_eq_other {\n-                // suggest deref on the left\n-                format!(\"*{}\", snip)\n+            let expr_snip;\n+            let eq_impl;\n+            if with_deref.is_implemented() {\n+                expr_snip = format!(\"*{}\", snip);\n+                eq_impl = with_deref;\n             } else {\n-                // suggest dropping the to_owned on the left\n-                snip.to_string()\n+                expr_snip = snip.to_string();\n+                eq_impl = without_deref;\n             };\n \n+            let span;\n+            let hint;\n+            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n+                span = expr.span;\n+                hint = expr_snip;\n+            } else {\n+                span = expr.span.to(other.span);\n+                if eq_impl.ty_eq_other {\n+                    hint = format!(\"{} == {}\", expr_snip, snippet(cx, other.span, \"..\"));\n+                } else {\n+                    hint = format!(\"{} == {}\", snippet(cx, other.span, \"..\"), expr_snip);\n+                }\n+            }\n+\n             diag.span_suggestion(\n-                lint_span,\n+                span,\n                 \"try\",\n-                try_hint,\n+                hint,\n                 Applicability::MachineApplicable, // snippet\n             );\n         },\n@@ -656,16 +682,10 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let Some(parent) = get_parent_expr(cx, expr) {\n-        match parent.kind {\n-            ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => {\n-                SpanlessEq::new(cx).eq_expr(rhs, expr)\n-            },\n-            _ => is_used(cx, parent),\n-        }\n-    } else {\n-        true\n-    }\n+    get_parent_expr(cx, expr).map_or(true, |parent| match parent.kind {\n+        ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n+        _ => is_used(cx, parent),\n+    })\n }\n \n /// Tests whether an expression is in a macro expansion (e.g., something\n@@ -674,12 +694,7 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n-\n-        if let ExpnKind::Macro(MacroKind::Attr, _) = data.kind {\n-            true\n-        } else {\n-            false\n-        }\n+        matches!(data.kind, ExpnKind::Macro(MacroKind::Attr, _))\n     } else {\n         false\n     }\n@@ -694,7 +709,7 @@ fn non_macro_local(cx: &LateContext<'_>, res: def::Res) -> bool {\n     }\n }\n \n-fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &Ty<'_>) {\n+fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>) {\n     if_chain! {\n         if let TyKind::Ptr(ref mut_ty) = ty.kind;\n         if let ExprKind::Lit(ref lit) = e.kind;"}, {"sha": "b84a1a3fe249449a81a574ea2be25118976bbd7e", "filename": "src/tools/clippy/clippy_lints/src/misc_early.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -641,28 +641,22 @@ fn check_unneeded_wildcard_pattern(cx: &EarlyContext<'_>, pat: &Pat) {\n             );\n         }\n \n-        #[allow(clippy::trivially_copy_pass_by_ref)]\n-        fn is_wild<P: std::ops::Deref<Target = Pat>>(pat: &&P) -> bool {\n-            if let PatKind::Wild = pat.kind {\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n         if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n             if let Some((left_index, left_pat)) = patterns[..rest_index]\n                 .iter()\n                 .rev()\n-                .take_while(is_wild)\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n                 .enumerate()\n                 .last()\n             {\n                 span_lint(cx, left_pat.span.until(patterns[rest_index].span), left_index == 0);\n             }\n \n-            if let Some((right_index, right_pat)) =\n-                patterns[rest_index + 1..].iter().take_while(is_wild).enumerate().last()\n+            if let Some((right_index, right_pat)) = patterns[rest_index + 1..]\n+                .iter()\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n+                .enumerate()\n+                .last()\n             {\n                 span_lint(\n                     cx,"}, {"sha": "9c9626735370180deccffb545cc5579933943f59", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -71,10 +71,11 @@ fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp\n fn is_executable(cx: &LateContext<'_>) -> bool {\n     use rustc_session::config::CrateType;\n \n-    cx.tcx.sess.crate_types().iter().any(|t: &CrateType| match t {\n-        CrateType::Executable => true,\n-        _ => false,\n-    })\n+    cx.tcx\n+        .sess\n+        .crate_types()\n+        .iter()\n+        .any(|t: &CrateType| matches!(t, CrateType::Executable))\n }\n \n declare_lint_pass!(MissingInline => [MISSING_INLINE_IN_PUBLIC_ITEMS]);"}, {"sha": "621ebdef2f0b17462cbabee5e277f369899cf47a", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -80,10 +80,12 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if impl_item.generics.params.iter().any(|gen| match gen.kind {\n-                            hir::GenericParamKind::Type { .. } => true,\n-                            _ => false,\n-                        }) {\n+                        if impl_item\n+                            .generics\n+                            .params\n+                            .iter()\n+                            .any(|gen| matches!(gen.kind, hir::GenericParamKind::Type { .. }))\n+                        {\n                             // when the result of `new()` depends on a type parameter we should not require\n                             // an\n                             // impl of `Default`"}, {"sha": "a3521c31a6be6b7f063703b911767113c7ed43b3", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -238,10 +238,10 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n \n             let ty = if needs_check_adjustment {\n                 let adjustments = cx.tables().expr_adjustments(dereferenced_expr);\n-                if let Some(i) = adjustments.iter().position(|adj| match adj.kind {\n-                    Adjust::Borrow(_) | Adjust::Deref(_) => true,\n-                    _ => false,\n-                }) {\n+                if let Some(i) = adjustments\n+                    .iter()\n+                    .position(|adj| matches!(adj.kind, Adjust::Borrow(_) | Adjust::Deref(_)))\n+                {\n                     if i == 0 {\n                         cx.tables().expr_ty(dereferenced_expr)\n                     } else {"}, {"sha": "8dbe58763bfb287648e369f0491dbe7cf206cd3f", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,267 @@\n+use crate::utils;\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{match_type, paths, span_lint_and_sugg};\n+use if_chain::if_chain;\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Lints usage of  `if let Some(v) = ... { y } else { x }` which is more\n+    /// idiomatically done with `Option::map_or` (if the else bit is a simple\n+    /// expression) or `Option::map_or_else` (if the else bit is a longer\n+    /// block).\n+    ///\n+    /// **Why is this bad?**\n+    /// Using the dedicated functions of the Option type is clearer and\n+    /// more concise than an if let expression.\n+    ///\n+    /// **Known problems:**\n+    /// This lint uses whether the block is just an expression or if it has\n+    /// more statements to decide whether to use `Option::map_or` or\n+    /// `Option::map_or_else`. If you have a single expression which calls\n+    /// an expensive function, then it would be more efficient to use\n+    /// `Option::map_or_else`, but this lint would suggest `Option::map_or`.\n+    ///\n+    /// Also, this lint uses a deliberately conservative metric for checking\n+    /// if the inside of either body contains breaks or continues which will\n+    /// cause it to not suggest a fix if either block contains a loop with\n+    /// continues or breaks contained within the loop.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// # fn do_complicated_function() -> u32 { 5 };\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     5\n+    /// };\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     let y = do_complicated_function();\n+    ///     y*y\n+    /// };\n+    /// ```\n+    ///\n+    /// should be\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// # fn do_complicated_function() -> u32 { 5 };\n+    /// let _ = optional.map_or(5, |foo| foo);\n+    /// let _ = optional.map_or_else(||{\n+    ///     let y = do_complicated_function();\n+    ///     y*y\n+    /// }, |foo| foo);\n+    /// ```\n+    pub OPTION_IF_LET_ELSE,\n+    pedantic,\n+    \"reimplementation of Option::map_or\"\n+}\n+\n+declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n+\n+/// Returns true iff the given expression is the result of calling `Result::ok`\n+fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+    if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n+        path.ident.name.to_ident_string() == \"ok\" && match_type(cx, &cx.tables().expr_ty(&receiver), &paths::RESULT)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// A struct containing information about occurences of the\n+/// `if let Some(..) = .. else` construct that this lint detects.\n+struct OptionIfLetElseOccurence {\n+    option: String,\n+    method_sugg: String,\n+    some_expr: String,\n+    none_expr: String,\n+    wrap_braces: bool,\n+}\n+\n+struct ReturnBreakContinueMacroVisitor {\n+    seen_return_break_continue: bool,\n+}\n+impl ReturnBreakContinueMacroVisitor {\n+    fn new() -> ReturnBreakContinueMacroVisitor {\n+        ReturnBreakContinueMacroVisitor {\n+            seen_return_break_continue: false,\n+        }\n+    }\n+}\n+impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if self.seen_return_break_continue {\n+            // No need to look farther if we've already seen one of them\n+            return;\n+        }\n+        match &ex.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n+                self.seen_return_break_continue = true;\n+            },\n+            // Something special could be done here to handle while or for loop\n+            // desugaring, as this will detect a break if there's a while loop\n+            // or a for loop inside the expression.\n+            _ => {\n+                if utils::in_macro(ex.span) {\n+                    self.seen_return_break_continue = true;\n+                } else {\n+                    rustc_hir::intravisit::walk_expr(self, ex);\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n+    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n+    recursive_visitor.visit_expr(expression);\n+    recursive_visitor.seen_return_break_continue\n+}\n+\n+/// Extracts the body of a given arm. If the arm contains only an expression,\n+/// then it returns the expression. Otherwise, it returns the entire block\n+fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n+    if let ExprKind::Block(\n+        Block {\n+            stmts: statements,\n+            expr: Some(expr),\n+            ..\n+        },\n+        _,\n+    ) = &arm.body.kind\n+    {\n+        if let [] = statements {\n+            Some(&expr)\n+        } else {\n+            Some(&arm.body)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If this is the else body of an if/else expression, then we need to wrap\n+/// it in curcly braces. Otherwise, we don't.\n+fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n+        if let Some(Expr {\n+            kind:\n+                ExprKind::Match(\n+                    _,\n+                    arms,\n+                    MatchSource::IfDesugar {\n+                        contains_else_clause: true,\n+                    }\n+                    | MatchSource::IfLetDesugar {\n+                        contains_else_clause: true,\n+                    },\n+                ),\n+            ..\n+        }) = parent.expr\n+        {\n+            expr.hir_id == arms[1].body.hir_id\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n+    format!(\n+        \"{}{}\",\n+        Sugg::hir(cx, cond_expr, \"..\").maybe_par(),\n+        if as_mut {\n+            \".as_mut()\"\n+        } else if as_ref {\n+            \".as_ref()\"\n+        } else {\n+            \"\"\n+        }\n+    )\n+}\n+\n+/// If this expression is the option if let/else construct we're detecting, then\n+/// this function returns an `OptionIfLetElseOccurence` struct with details if\n+/// this construct is found, or None if this construct is not found.\n+fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OptionIfLetElseOccurence> {\n+    if_chain! {\n+        if !utils::in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n+        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if arms.len() == 2;\n+        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n+        if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n+        if utils::match_qpath(struct_qpath, &paths::OPTION_SOME);\n+        if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n+        if !contains_return_break_continue_macro(arms[0].body);\n+        if !contains_return_break_continue_macro(arms[1].body);\n+        then {\n+            let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let some_body = extract_body_from_arm(&arms[0])?;\n+            let none_body = extract_body_from_arm(&arms[1])?;\n+            let method_sugg = match &none_body.kind {\n+                ExprKind::Block(..) => \"map_or_else\",\n+                _ => \"map_or\",\n+            };\n+            let capture_name = id.name.to_ident_string();\n+            let wrap_braces = should_wrap_in_braces(cx, expr);\n+            let (as_ref, as_mut) = match &cond_expr.kind {\n+                ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n+                ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n+                _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n+            };\n+            let cond_expr = match &cond_expr.kind {\n+                // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n+                ExprKind::Unary(UnOp::UnDeref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n+                _ => cond_expr,\n+            };\n+            Some(OptionIfLetElseOccurence {\n+                option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n+                method_sugg: method_sugg.to_string(),\n+                some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir(cx, some_body, \"..\")),\n+                none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir(cx, none_body, \"..\")),\n+                wrap_braces,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a> LateLintPass<'a> for OptionIfLetElse {\n+    fn check_expr(&mut self, cx: &LateContext<'a>, expr: &Expr<'_>) {\n+        if let Some(detection) = detect_option_if_let_else(cx, expr) {\n+            span_lint_and_sugg(\n+                cx,\n+                OPTION_IF_LET_ELSE,\n+                expr.span,\n+                format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n+                \"try\",\n+                format!(\n+                    \"{}{}.{}({}, {}){}\",\n+                    if detection.wrap_braces { \"{ \" } else { \"\" },\n+                    detection.option,\n+                    detection.method_sugg,\n+                    detection.none_expr,\n+                    detection.some_expr,\n+                    if detection.wrap_braces { \" }\" } else { \"\" },\n+                ),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}"}, {"sha": "a49dc87c0b47f5697b2d5c28bbc58714aad030b5", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,311 @@\n+use crate::utils::{last_path_segment, span_lint_and_help};\n+use rustc_hir::{\n+    intravisit, Body, Expr, ExprKind, FieldPat, FnDecl, HirId, LocalSource, MatchSource, Mutability, Pat, PatKind,\n+    QPath, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{AdtDef, FieldDef, Ty, TyKind, VariantDef};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for patterns that aren't exact representations of the types\n+    /// they are applied to.\n+    ///\n+    /// To satisfy this lint, you will have to adjust either the expression that is matched\n+    /// against or the pattern itself, as well as the bindings that are introduced by the\n+    /// adjusted patterns. For matching you will have to either dereference the expression\n+    /// with the `*` operator, or amend the patterns to explicitly match against `&<pattern>`\n+    /// or `&mut <pattern>` depending on the reference mutability. For the bindings you need\n+    /// to use the inverse. You can leave them as plain bindings if you wish for the value\n+    /// to be copied, but you must use `ref mut <variable>` or `ref <variable>` to construct\n+    /// a reference into the matched structure.\n+    ///\n+    /// If you are looking for a way to learn about ownership semantics in more detail, it\n+    /// is recommended to look at IDE options available to you to highlight types, lifetimes\n+    /// and reference semantics in your code. The available tooling would expose these things\n+    /// in a general way even outside of the various pattern matching mechanics. Of course\n+    /// this lint can still be used to highlight areas of interest and ensure a good understanding\n+    /// of ownership semantics.\n+    ///\n+    /// **Why is this bad?** It isn't bad in general. But in some contexts it can be desirable\n+    /// because it increases ownership hints in the code, and will guard against some changes\n+    /// in ownership.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// This example shows the basic adjustments necessary to satisfy the lint. Note how\n+    /// the matched expression is explicitly dereferenced with `*` and the `inner` variable\n+    /// is bound to a shared borrow via `ref inner`.\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// let value = &Some(Box::new(23));\n+    /// match value {\n+    ///     Some(inner) => println!(\"{}\", inner),\n+    ///     None => println!(\"none\"),\n+    /// }\n+    ///\n+    /// // Good\n+    /// let value = &Some(Box::new(23));\n+    /// match *value {\n+    ///     Some(ref inner) => println!(\"{}\", inner),\n+    ///     None => println!(\"none\"),\n+    /// }\n+    /// ```\n+    ///\n+    /// The following example demonstrates one of the advantages of the more verbose style.\n+    /// Note how the second version uses `ref mut a` to explicitly declare `a` a shared mutable\n+    /// borrow, while `b` is simply taken by value. This ensures that the loop body cannot\n+    /// accidentally modify the wrong part of the structure.\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// let mut values = vec![(2, 3), (3, 4)];\n+    /// for (a, b) in &mut values {\n+    ///     *a += *b;\n+    /// }\n+    ///\n+    /// // Good\n+    /// let mut values = vec![(2, 3), (3, 4)];\n+    /// for &mut (ref mut a, b) in &mut values {\n+    ///     *a += b;\n+    /// }\n+    /// ```\n+    pub PATTERN_TYPE_MISMATCH,\n+    restriction,\n+    \"type of pattern does not match the expression type\"\n+}\n+\n+declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if let StmtKind::Local(ref local) = stmt.kind {\n+            if let Some(init) = &local.init {\n+                if let Some(init_ty) = cx.tables().node_type_opt(init.hir_id) {\n+                    let pat = &local.pat;\n+                    if in_external_macro(cx.sess(), pat.span) {\n+                        return;\n+                    }\n+                    let deref_possible = match local.source {\n+                        LocalSource::Normal => DerefPossible::Possible,\n+                        _ => DerefPossible::Impossible,\n+                    };\n+                    apply_lint(cx, pat, init_ty, deref_possible);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Match(ref expr, arms, source) = expr.kind {\n+            match source {\n+                MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n+                    if let Some(expr_ty) = cx.tables().node_type_opt(expr.hir_id) {\n+                        'pattern_checks: for arm in arms {\n+                            let pat = &arm.pat;\n+                            if in_external_macro(cx.sess(), pat.span) {\n+                                continue 'pattern_checks;\n+                            }\n+                            if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n+                                break 'pattern_checks;\n+                            }\n+                        }\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        _: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let Some(fn_sig) = cx.tables().liberated_fn_sigs().get(hir_id) {\n+            for (param, ty) in body.params.iter().zip(fn_sig.inputs().iter()) {\n+                apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum DerefPossible {\n+    Possible,\n+    Impossible,\n+}\n+\n+fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, expr_ty: Ty<'tcx>, deref_possible: DerefPossible) -> bool {\n+    let maybe_mismatch = find_first_mismatch(cx, pat, expr_ty, Level::Top);\n+    if let Some((span, mutability, level)) = maybe_mismatch {\n+        span_lint_and_help(\n+            cx,\n+            PATTERN_TYPE_MISMATCH,\n+            span,\n+            \"type of pattern does not match the expression type\",\n+            None,\n+            &format!(\n+                \"{}explicitly match against a `{}` pattern and adjust the enclosed variable bindings\",\n+                match (deref_possible, level) {\n+                    (DerefPossible::Possible, Level::Top) => \"use `*` to dereference the match expression or \",\n+                    _ => \"\",\n+                },\n+                match mutability {\n+                    Mutability::Mut => \"&mut _\",\n+                    Mutability::Not => \"&_\",\n+                },\n+            ),\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+enum Level {\n+    Top,\n+    Lower,\n+}\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+fn find_first_mismatch<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'_>,\n+    ty: Ty<'tcx>,\n+    level: Level,\n+) -> Option<(Span, Mutability, Level)> {\n+    if let PatKind::Ref(ref sub_pat, _) = pat.kind {\n+        if let TyKind::Ref(_, sub_ty, _) = ty.kind {\n+            return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n+        }\n+    }\n+\n+    if let TyKind::Ref(_, _, mutability) = ty.kind {\n+        if is_non_ref_pattern(&pat.kind) {\n+            return Some((pat.span, mutability, level));\n+        }\n+    }\n+\n+    if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+            if let Some(variant) = get_variant(adt_def, qpath) {\n+                let field_defs = &variant.fields;\n+                return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n+            }\n+        }\n+    }\n+\n+    if let PatKind::TupleStruct(ref qpath, ref pats, _) = pat.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+            if let Some(variant) = get_variant(adt_def, qpath) {\n+                let field_defs = &variant.fields;\n+                let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n+                return find_first_mismatch_in_tuple(cx, pats, ty_iter);\n+            }\n+        }\n+    }\n+\n+    if let PatKind::Tuple(ref pats, _) = pat.kind {\n+        if let TyKind::Tuple(..) = ty.kind {\n+            return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n+        }\n+    }\n+\n+    if let PatKind::Or(sub_pats) = pat.kind {\n+        for pat in sub_pats {\n+            let maybe_mismatch = find_first_mismatch(cx, pat, ty, level);\n+            if let Some(mismatch) = maybe_mismatch {\n+                return Some(mismatch);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n+    if adt_def.is_struct() {\n+        if let Some(variant) = adt_def.variants.iter().next() {\n+            return Some(variant);\n+        }\n+    }\n+\n+    if adt_def.is_enum() {\n+        let pat_ident = last_path_segment(qpath).ident;\n+        for variant in &adt_def.variants {\n+            if variant.ident == pat_ident {\n+                return Some(variant);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn find_first_mismatch_in_tuple<'tcx, I>(\n+    cx: &LateContext<'tcx>,\n+    pats: &[&Pat<'_>],\n+    ty_iter_src: I,\n+) -> Option<(Span, Mutability, Level)>\n+where\n+    I: IntoIterator<Item = Ty<'tcx>>,\n+{\n+    let mut field_tys = ty_iter_src.into_iter();\n+    'fields: for pat in pats {\n+        let field_ty = if let Some(ty) = field_tys.next() {\n+            ty\n+        } else {\n+            break 'fields;\n+        };\n+\n+        let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n+        if let Some(mismatch) = maybe_mismatch {\n+            return Some(mismatch);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn find_first_mismatch_in_struct<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    field_pats: &[FieldPat<'_>],\n+    field_defs: &[FieldDef],\n+    substs_ref: SubstsRef<'tcx>,\n+) -> Option<(Span, Mutability, Level)> {\n+    for field_pat in field_pats {\n+        'definitions: for field_def in field_defs {\n+            if field_pat.ident == field_def.ident {\n+                let field_ty = field_def.ty(cx.tcx, substs_ref);\n+                let pat = &field_pat.pat;\n+                let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n+                if let Some(mismatch) = maybe_mismatch {\n+                    return Some(mismatch);\n+                }\n+                break 'definitions;\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn is_non_ref_pattern(pat_kind: &PatKind<'_>) -> bool {\n+    match pat_kind {\n+        PatKind::Struct(..) | PatKind::Tuple(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => true,\n+        PatKind::Or(sub_pats) => sub_pats.iter().any(|pat| is_non_ref_pattern(&pat.kind)),\n+        _ => false,\n+    }\n+}"}, {"sha": "4797771e7bdbb4aa9e95dba4f3a00c9f587cda42", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -148,17 +148,11 @@ fn is_arith_expr(expr: &Expr) -> bool {\n #[must_use]\n fn is_bit_op(op: BinOpKind) -> bool {\n     use rustc_ast::ast::BinOpKind::{BitAnd, BitOr, BitXor, Shl, Shr};\n-    match op {\n-        BitXor | BitAnd | BitOr | Shl | Shr => true,\n-        _ => false,\n-    }\n+    matches!(op, BitXor | BitAnd | BitOr | Shl | Shr)\n }\n \n #[must_use]\n fn is_arith_op(op: BinOpKind) -> bool {\n     use rustc_ast::ast::BinOpKind::{Add, Div, Mul, Rem, Sub};\n-    match op {\n-        Add | Sub | Mul | Div | Rem => true,\n-        _ => false,\n-    }\n+    matches!(op, Add | Sub | Mul | Div | Rem)\n }"}, {"sha": "dd608de5723e228defc9f1e9be5d91a2c0a445e6", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -52,6 +52,11 @@ declare_clippy_lint! {\n     /// exclusive ranges, because they essentially add an extra branch that\n     /// LLVM may fail to hoist out of the loop.\n     ///\n+    /// This will cause a warning that cannot be fixed if the consumer of the\n+    /// range only accepts a specific range type, instead of the generic\n+    /// `RangeBounds` trait\n+    /// ([#3307](https://github.com/rust-lang/rust-clippy/issues/3307)).\n+    ///\n     /// **Example:**\n     /// ```rust,ignore\n     /// for x..(y+1) { .. }\n@@ -72,7 +77,10 @@ declare_clippy_lint! {\n     /// **Why is this bad?** The code is more readable with an exclusive range\n     /// like `x..y`.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** This will cause a warning that cannot be fixed if\n+    /// the consumer of the range only accepts a specific range type, instead of\n+    /// the generic `RangeBounds` trait\n+    /// ([#3307](https://github.com/rust-lang/rust-clippy/issues/3307)).\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n@@ -83,7 +91,7 @@ declare_clippy_lint! {\n     /// for x..y { .. }\n     /// ```\n     pub RANGE_MINUS_ONE,\n-    complexity,\n+    pedantic,\n     \"`x..=(y-1)` reads better as `x..y`\"\n }\n "}, {"sha": "d8d16efb978a53727fe61bdd746c11d2c5a10708", "filename": "src/tools/clippy/clippy_lints/src/redundant_pattern_matching.rs", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/2fb307aca5b4ac317b09c7e91a8d4259fbebf17a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb307aca5b4ac317b09c7e91a8d4259fbebf17a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=2fb307aca5b4ac317b09c7e91a8d4259fbebf17a", "patch": "@@ -1,260 +0,0 @@\n-use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_mir::const_eval::is_const_fn;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Symbol;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Lint for redundant pattern matching over `Result` or\n-    /// `Option`\n-    ///\n-    /// **Why is this bad?** It's more concise and clear to just use the proper\n-    /// utility function\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n-    /// if let Err(_) = Err::<i32, i32>(42) {}\n-    /// if let None = None::<()> {}\n-    /// if let Some(_) = Some(42) {}\n-    /// match Ok::<i32, i32>(42) {\n-    ///     Ok(_) => true,\n-    ///     Err(_) => false,\n-    /// };\n-    /// ```\n-    ///\n-    /// The more idiomatic use would be:\n-    ///\n-    /// ```rust\n-    /// if Ok::<i32, i32>(42).is_ok() {}\n-    /// if Err::<i32, i32>(42).is_err() {}\n-    /// if None::<()>.is_none() {}\n-    /// if Some(42).is_some() {}\n-    /// Ok::<i32, i32>(42).is_ok();\n-    /// ```\n-    pub REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-declare_lint_pass!(RedundantPatternMatching => [REDUNDANT_PATTERN_MATCHING]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RedundantPatternMatching {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n-            match match_source {\n-                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n-                _ => return,\n-            }\n-        }\n-    }\n-}\n-\n-fn find_sugg_for_if_let<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    op: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    keyword: &'static str,\n-) {\n-    fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n-        if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n-            return Some(\"is_ok()\");\n-        }\n-        if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n-            return Some(\"is_err()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n-            return Some(\"is_some()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n-            return Some(\"is_none()\");\n-        }\n-        None\n-    }\n-\n-    let hir_id = expr.hir_id;\n-    let good_method = match arms[0].pat.kind {\n-        PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n-            if let PatKind::Wild = patterns[0].kind {\n-                find_suggestion(cx, hir_id, path)\n-            } else {\n-                None\n-            }\n-        },\n-        PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n-        _ => None,\n-    };\n-    let good_method = match good_method {\n-        Some(method) => method,\n-        None => return,\n-    };\n-\n-    // check that `while_let_on_iterator` lint does not trigger\n-    if_chain! {\n-        if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n-        if method_path.ident.name == sym!(next);\n-        if match_trait_method(cx, op, &paths::ITERATOR);\n-        then {\n-            return;\n-        }\n-    }\n-\n-    span_lint_and_then(\n-        cx,\n-        REDUNDANT_PATTERN_MATCHING,\n-        arms[0].pat.span,\n-        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-        |diag| {\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-            let expr_span = expr.span;\n-\n-            // while let ... = ... { ... }\n-            //                 ^^^\n-            let op_span = op.span.source_callsite();\n-\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^\n-            let span = expr_span.until(op_span.shrink_to_hi());\n-            diag.span_suggestion(\n-                span,\n-                \"try this\",\n-                format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        },\n-    );\n-}\n-\n-fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-    if arms.len() == 2 {\n-        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-        let hir_id = expr.hir_id;\n-        let found_good_method = match node_pair {\n-            (\n-                PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n-                PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n-            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::RESULT_OK,\n-                        &paths::RESULT_ERR,\n-                        \"is_ok()\",\n-                        \"is_err()\",\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n-            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n-                if patterns.len() == 1 =>\n-            {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::OPTION_SOME,\n-                        &paths::OPTION_NONE,\n-                        \"is_some()\",\n-                        \"is_none()\",\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(good_method) = found_good_method {\n-            span_lint_and_then(\n-                cx,\n-                REDUNDANT_PATTERN_MATCHING,\n-                expr.span,\n-                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                |diag| {\n-                    let span = expr.span.to(op.span);\n-                    diag.span_suggestion(\n-                        span,\n-                        \"try this\",\n-                        format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n-                        Applicability::MaybeIncorrect, // snippet\n-                    );\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-#[allow(clippy::too_many_arguments)]\n-fn find_good_method_for_match<'a>(\n-    arms: &[Arm<'_>],\n-    path_left: &QPath<'_>,\n-    path_right: &QPath<'_>,\n-    expected_left: &[&str],\n-    expected_right: &[&str],\n-    should_be_left: &'a str,\n-    should_be_right: &'a str,\n-    can_suggest_left: impl Fn() -> bool,\n-    can_suggest_right: impl Fn() -> bool,\n-) -> Option<&'a str> {\n-    let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n-        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-    } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n-        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-    } else {\n-        return None;\n-    };\n-\n-    match body_node_pair {\n-        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-            (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n-            (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n-fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n-    if !in_constant(cx, hir_id) {\n-        return true;\n-    }\n-\n-    // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n-    cx.tcx\n-        .get_diagnostic_item(diag_item)\n-        .and_then(|def_id| {\n-            cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n-                cx.tcx\n-                    .associated_items(*imp)\n-                    .in_definition_order()\n-                    .find_map(|item| match item.kind {\n-                        ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n-                        _ => None,\n-                    })\n-            })\n-        })\n-        .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n-}"}, {"sha": "f204a0ffb2c7b92aed6041cfc80dbbcaf39a7bb7", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,9 +1,9 @@\n use crate::consts::{constant, Constant};\n-use crate::utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_lint_and_help};\n+use crate::utils::{match_def_path, paths, span_lint, span_lint_and_help};\n use if_chain::if_chain;\n use rustc_ast::ast::{LitKind, StrStyle};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::{Block, BorrowKind, Crate, Expr, ExprKind, HirId};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{BytePos, Span};\n@@ -46,66 +46,15 @@ declare_clippy_lint! {\n     \"trivial regular expressions\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `regex!(_)` which (as of now) is\n-    /// usually slower than `Regex::new(_)` unless called in a loop (which is a bad\n-    /// idea anyway).\n-    ///\n-    /// **Why is this bad?** Performance, at least for now. The macro version is\n-    /// likely to catch up long-term, but for now the dynamic version is faster.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```ignore\n-    /// regex!(\"foo|bar\")\n-    /// ```\n-    pub REGEX_MACRO,\n-    style,\n-    \"use of `regex!(_)` instead of `Regex::new(_)`\"\n-}\n-\n #[derive(Clone, Default)]\n pub struct Regex {\n     spans: FxHashSet<Span>,\n     last: Option<HirId>,\n }\n \n-impl_lint_pass!(Regex => [INVALID_REGEX, REGEX_MACRO, TRIVIAL_REGEX]);\n+impl_lint_pass!(Regex => [INVALID_REGEX, TRIVIAL_REGEX]);\n \n impl<'tcx> LateLintPass<'tcx> for Regex {\n-    fn check_crate(&mut self, _: &LateContext<'tcx>, _: &'tcx Crate<'_>) {\n-        self.spans.clear();\n-    }\n-\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        if_chain! {\n-            if self.last.is_none();\n-            if let Some(ref expr) = block.expr;\n-            if match_type(cx, cx.tables().expr_ty(expr), &paths::REGEX);\n-            if let Some(span) = is_expn_of(expr.span, \"regex\");\n-            then {\n-                if !self.spans.contains(&span) {\n-                    span_lint(\n-                        cx,\n-                        REGEX_MACRO,\n-                        span,\n-                        \"`regex!(_)` found. \\\n-                        Please use `Regex::new(_)`, which is faster for now.\"\n-                    );\n-                    self.spans.insert(span);\n-                }\n-                self.last = Some(block.hir_id);\n-            }\n-        }\n-    }\n-\n-    fn check_block_post(&mut self, _: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        if self.last.map_or(false, |id| block.hir_id == id) {\n-            self.last = None;\n-        }\n-    }\n-\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref fun, ref args) = expr.kind;\n@@ -150,12 +99,7 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n     use regex_syntax::hir::Anchor::{EndText, StartText};\n     use regex_syntax::hir::HirKind::{Alternation, Anchor, Concat, Empty, Literal};\n \n-    let is_literal = |e: &[regex_syntax::hir::Hir]| {\n-        e.iter().all(|e| match *e.kind() {\n-            Literal(_) => true,\n-            _ => false,\n-        })\n-    };\n+    let is_literal = |e: &[regex_syntax::hir::Hir]| e.iter().all(|e| matches!(*e.kind(), Literal(_)));\n \n     match *s.kind() {\n         Empty | Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),"}, {"sha": "a3af369e41e5a1d72429f77735fb7dac41ac500c", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,82 @@\n+use crate::consts::{constant_context, Constant};\n+use crate::utils::{in_macro, is_type_diagnostic_item, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.repeat(1)` and suggest the following method for each types.\n+    /// - `.to_string()` for `str`\n+    /// - `.clone()` for `String`\n+    /// - `.to_vec()` for `slice`\n+    ///\n+    /// **Why is this bad?** For example, `String.repeat(1)` is equivalent to `.clone()`. If cloning the string is the intention behind this, `clone()` should be used.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").repeat(1);\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").clone();\n+    /// }\n+    /// ```\n+    pub REPEAT_ONCE,\n+    complexity,\n+    \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n+}\n+\n+declare_lint_pass!(RepeatOnce => [REPEAT_ONCE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if path.ident.name == sym!(repeat);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.tables()).expr(&args[1]);\n+            if !in_macro(args[0].span);\n+            then {\n+                let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+                if ty.is_str() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        REPEAT_ONCE,\n+                        expr.span,\n+                        \"calling `repeat(1)` on str\",\n+                        \"consider using `.to_string()` instead\",\n+                        format!(\"{}.to_string()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if ty.builtin_index().is_some() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        REPEAT_ONCE,\n+                        expr.span,\n+                        \"calling `repeat(1)` on slice\",\n+                        \"consider using `.to_vec()` instead\",\n+                        format!(\"{}.to_vec()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        REPEAT_ONCE,\n+                        expr.span,\n+                        \"calling `repeat(1)` on a string literal\",\n+                        \"consider using `.clone()` instead\",\n+                        format!(\"{}.clone()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "faef7e724dd056a8464957cfb91a5b4e6c53f157", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -259,15 +259,15 @@ fn is_unit_expr(expr: &ast::Expr) -> bool {\n \n fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n     let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        if let Some(rpos) = fn_source.rfind(\"->\") {\n-            #[allow(clippy::cast_possible_truncation)]\n-            (\n-                ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                Applicability::MachineApplicable,\n-            )\n-        } else {\n-            (ty.span, Applicability::MaybeIncorrect)\n-        }\n+        fn_source\n+            .rfind(\"->\")\n+            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n     } else {\n         (ty.span, Applicability::MaybeIncorrect)\n     };"}, {"sha": "194786c5c41451be22774b8db0ca7ba16350429b", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -165,14 +165,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables().node_type_opt(pat_id);\n-    if let Some(var_ty) = var_ty {\n-        match var_ty.kind {\n-            ty::Adt(..) => false,\n-            _ => true,\n-        }\n-    } else {\n-        false\n-    }\n+    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind, ty::Adt(..)))\n }\n \n fn check_pat<'tcx>("}, {"sha": "1aeff1baa362e24a2362263c07a946e412abde46", "filename": "src/tools/clippy/clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -25,13 +25,7 @@ declare_clippy_lint! {\n fn is_temporary(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n-        ExprKind::Path(qpath) => {\n-            if let Res::Def(DefKind::Const, ..) = cx.qpath_res(qpath, expr.hir_id) {\n-                true\n-            } else {\n-                false\n-            }\n-        },\n+        ExprKind::Path(qpath) => matches!(cx.qpath_res(qpath, expr.hir_id), Res::Def(DefKind::Const, ..)),\n         _ => false,\n     }\n }"}, {"sha": "0ef70311fb1cde5a80e9f21b20f21ed511d1093f", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,19 +1,19 @@\n use crate::utils::{in_macro, snippet, snippet_with_applicability, span_lint_and_help, SpanlessHash};\n+use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::{GenericBound, Generics, WherePredicate};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n-#[derive(Copy, Clone)]\n-pub struct TraitBounds;\n-\n declare_clippy_lint! {\n     /// **What it does:** This lint warns about unnecessary type repetitions in trait bounds\n     ///\n     /// **Why is this bad?** Repeating the type for every bound makes the code\n     /// less readable than combining the bounds\n     ///\n+    /// **Known problems:** None.\n+    ///\n     /// **Example:**\n     /// ```rust\n     /// pub fn foo<T>(t: T) where T: Copy, T: Clone {}\n@@ -29,6 +29,18 @@ declare_clippy_lint! {\n     \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n }\n \n+#[derive(Copy, Clone)]\n+pub struct TraitBounds {\n+    max_trait_bounds: u64,\n+}\n+\n+impl TraitBounds {\n+    #[must_use]\n+    pub fn new(max_trait_bounds: u64) -> Self {\n+        Self { max_trait_bounds }\n+    }\n+}\n+\n impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS]);\n \n impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n@@ -44,9 +56,14 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n         let mut map = FxHashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n         for bound in gen.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(ref p) = bound {\n+            if_chain! {\n+                if let WherePredicate::BoundPredicate(ref p) = bound;\n+                if p.bounds.len() as u64 <= self.max_trait_bounds;\n+                if !in_macro(p.span);\n                 let h = hash(&p.bounded_ty);\n-                if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>()) {\n+                if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>());\n+\n+                then {\n                     let mut hint_string = format!(\n                         \"consider combining the bounds: `{}:\",\n                         snippet(cx, p.bounded_ty.span, \"_\")"}, {"sha": "bca388ecdcc3846b4b317808547cbb054471ca42", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -775,11 +775,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n                     .iter()\n                     .filter(|arg| {\n                         if is_unit(cx.tables().expr_ty(arg)) && !is_unit_literal(arg) {\n-                            if let ExprKind::Match(.., MatchSource::TryDesugar) = &arg.kind {\n-                                false\n-                            } else {\n-                                true\n-                            }\n+                            !matches!(&arg.kind, ExprKind::Match(.., MatchSource::TryDesugar))\n                         } else {\n                             false\n                         }\n@@ -899,17 +895,11 @@ fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n }\n \n fn is_unit(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n-        ty::Tuple(slice) if slice.is_empty() => true,\n-        _ => false,\n-    }\n+    matches!(ty.kind, ty::Tuple(slice) if slice.is_empty())\n }\n \n fn is_unit_literal(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Tup(ref slice) if slice.is_empty() => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n }\n \n declare_clippy_lint! {\n@@ -1154,10 +1144,7 @@ fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n }\n \n fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    match typ.kind {\n-        ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => true,\n-        _ => false,\n-    }\n+    matches!(typ.kind, ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n }\n \n fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n@@ -1205,16 +1192,19 @@ fn span_lossless_lint(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     // has parens on the outside, they are no longer needed.\n     let mut applicability = Applicability::MachineApplicable;\n     let opt = snippet_opt(cx, op.span);\n-    let sugg = if let Some(ref snip) = opt {\n-        if should_strip_parens(op, snip) {\n-            &snip[1..snip.len() - 1]\n-        } else {\n-            snip.as_str()\n-        }\n-    } else {\n-        applicability = Applicability::HasPlaceholders;\n-        \"..\"\n-    };\n+    let sugg = opt.as_ref().map_or_else(\n+        || {\n+            applicability = Applicability::HasPlaceholders;\n+            \"..\"\n+        },\n+        |snip| {\n+            if should_strip_parens(op, snip) {\n+                &snip[1..snip.len() - 1]\n+            } else {\n+                snip.as_str()\n+            }\n+        },\n+    );\n \n     span_lint_and_sugg(\n         cx,\n@@ -1734,10 +1724,10 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n \n             TyKind::TraitObject(ref param_bounds, _) => {\n                 let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n-                    bound.bound_generic_params.iter().any(|gen| match gen.kind {\n-                        GenericParamKind::Lifetime { .. } => true,\n-                        _ => false,\n-                    })\n+                    bound\n+                        .bound_generic_params\n+                        .iter()\n+                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n                 });\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>"}, {"sha": "25d136e564d3ee8bd8e4633d3c33915ef502c91f", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -58,10 +58,10 @@ declare_lint_pass!(UnnamedAddress => [FN_ADDRESS_COMPARISONS, VTABLE_ADDRESS_COM\n impl LateLintPass<'_> for UnnamedAddress {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         fn is_comparison(binop: BinOpKind) -> bool {\n-            match binop {\n-                BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ne | BinOpKind::Ge | BinOpKind::Gt => true,\n-                _ => false,\n-            }\n+            matches!(\n+                binop,\n+                BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ne | BinOpKind::Ge | BinOpKind::Gt\n+            )\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n@@ -72,11 +72,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            if let ty::FnDef(..) = cx.tables().expr_ty(expr).kind {\n-                true\n-            } else {\n-                false\n-            }\n+            matches!(cx.tables().expr_ty(expr).kind, ty::FnDef(..))\n         }\n \n         if_chain! {"}, {"sha": "91c1789a2ffb1b592da5b6c06132962fa074aed1", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -5,24 +5,23 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, subst::GenericArgKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n     /// **What it does:**\n-    /// Detects when people use `Vec::sort_by` and pass in a function\n+    /// Detects uses of `Vec::sort_by` passing in a closure\n     /// which compares the two arguments, either directly or indirectly.\n     ///\n     /// **Why is this bad?**\n     /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n-    /// possible) than to use `Vec::sort_by` and and a more complicated\n+    /// possible) than to use `Vec::sort_by` and a more complicated\n     /// closure.\n     ///\n     /// **Known problems:**\n-    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't\n-    /// imported by a use statement in the current frame, then a `use`\n-    /// statement that imports it will need to be added (which this lint\n-    /// can't do).\n+    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n+    /// imported by a use statement, then it will need to be added manually.\n     ///\n     /// **Example:**\n     ///\n@@ -201,28 +200,41 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             };\n             let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n             let unstable = name == \"sort_unstable_by\";\n+\n             if_chain! {\n                 if let ExprKind::Path(QPath::Resolved(_, Path {\n                     segments: [PathSegment { ident: left_name, .. }], ..\n                 })) = &left_expr.kind;\n                 if left_name == left_ident;\n                 then {\n-                    Some(LintTrigger::Sort(SortDetection { vec_name, unstable }))\n-                }\n-                else {\n-                    Some(LintTrigger::SortByKey(SortByKeyDetection {\n-                        vec_name,\n-                        unstable,\n-                        closure_arg,\n-                        closure_body,\n-                        reverse\n-                    }))\n+                    return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }))\n+                } else {\n+                    if !key_returns_borrow(cx, left_expr) {\n+                        return Some(LintTrigger::SortByKey(SortByKeyDetection {\n+                            vec_name,\n+                            unstable,\n+                            closure_arg,\n+                            closure_body,\n+                            reverse\n+                        }))\n+                    }\n                 }\n             }\n-        } else {\n-            None\n         }\n     }\n+\n+    None\n+}\n+\n+fn key_returns_borrow(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let Some(def_id) = utils::fn_def_id(cx, expr) {\n+        let output = cx.tcx.fn_sig(def_id).output();\n+        let ty = output.skip_binder();\n+        return matches!(ty.kind, ty::Ref(..))\n+            || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+    }\n+\n+    false\n }\n \n impl LateLintPass<'_> for UnnecessarySortBy {"}, {"sha": "502bf0c427954b616a817d91512586ff1f968d68", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -72,8 +72,8 @@ impl EarlyLintPass for UnnestedOrPatterns {\n }\n \n fn lint_unnested_or_patterns(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if !cx.sess.opts.unstable_features.is_nightly_build() {\n-        // User cannot do `#![feature(or_patterns)]`, so bail.\n+    if !cx.sess.features_untracked().or_patterns {\n+        // Do not suggest nesting the patterns if the feature `or_patterns` is not enabled.\n         return;\n     }\n \n@@ -400,8 +400,8 @@ fn extend_with_matching(\n \n /// Are the patterns in `ps1` and `ps2` equal save for `ps1[idx]` compared to `ps2[idx]`?\n fn eq_pre_post(ps1: &[P<Pat>], ps2: &[P<Pat>], idx: usize) -> bool {\n-    ps1[idx].is_rest() == ps2[idx].is_rest() // Avoid `[x, ..] | [x, 0]` => `[x, .. | 0]`.\n-        && ps1.len() == ps2.len()\n+    ps1.len() == ps2.len()\n+        && ps1[idx].is_rest() == ps2[idx].is_rest() // Avoid `[x, ..] | [x, 0]` => `[x, .. | 0]`.\n         && over(&ps1[..idx], &ps2[..idx], |l, r| eq_pat(l, r))\n         && over(&ps1[idx + 1..], &ps2[idx + 1..], |l, r| eq_pat(l, r))\n }"}, {"sha": "776c6bc57ca6f857c4d86b699d99a4d5f2351f41", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -167,14 +167,11 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.kind;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n-                let should_check = if let Some(ref params) = *parameters {\n-                    !params.parenthesized && !params.args.iter().any(|arg| match arg {\n-                        GenericArg::Lifetime(_) => true,\n-                        _ => false,\n-                    })\n-                } else {\n-                    true\n-                };\n+                let should_check = parameters.as_ref().map_or(\n+                    true,\n+                    |params| !params.parenthesized\n+                        &&!params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n+                );\n \n                 if should_check {\n                     let visitor = &mut UseSelfVisitor {"}, {"sha": "58c1103da9f7dfed78e7039b107944057e7eecb9", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -387,10 +387,7 @@ pub fn eq_use_tree_kind(l: &UseTreeKind, r: &UseTreeKind) -> bool {\n }\n \n pub fn eq_defaultness(l: Defaultness, r: Defaultness) -> bool {\n-    match (l, r) {\n-        (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)) => true,\n-        _ => false,\n-    }\n+    matches!((l, r), (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)))\n }\n \n pub fn eq_vis(l: &Visibility, r: &Visibility) -> bool {"}, {"sha": "4bb4b087c5566773b5dfa9249c936a486b103f98", "filename": "src/tools/clippy/clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -65,42 +65,45 @@ pub fn get_attr<'a>(\n         };\n         let attr_segments = &attr.path.segments;\n         if attr_segments.len() == 2 && attr_segments[0].ident.to_string() == \"clippy\" {\n-            if let Some(deprecation_status) =\n-                BUILTIN_ATTRIBUTES\n-                    .iter()\n-                    .find_map(|(builtin_name, deprecation_status)| {\n-                        if *builtin_name == attr_segments[1].ident.to_string() {\n-                            Some(deprecation_status)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-            {\n-                let mut diag = sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n-                match *deprecation_status {\n-                    DeprecationStatus::Deprecated => {\n-                        diag.emit();\n-                        false\n-                    },\n-                    DeprecationStatus::Replaced(new_name) => {\n-                        diag.span_suggestion(\n-                            attr_segments[1].ident.span,\n-                            \"consider using\",\n-                            new_name.to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        diag.emit();\n+            BUILTIN_ATTRIBUTES\n+                .iter()\n+                .find_map(|(builtin_name, deprecation_status)| {\n+                    if *builtin_name == attr_segments[1].ident.to_string() {\n+                        Some(deprecation_status)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .map_or_else(\n+                    || {\n+                        sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n                         false\n                     },\n-                    DeprecationStatus::None => {\n-                        diag.cancel();\n-                        attr_segments[1].ident.to_string() == name\n+                    |deprecation_status| {\n+                        let mut diag =\n+                            sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n+                        match *deprecation_status {\n+                            DeprecationStatus::Deprecated => {\n+                                diag.emit();\n+                                false\n+                            },\n+                            DeprecationStatus::Replaced(new_name) => {\n+                                diag.span_suggestion(\n+                                    attr_segments[1].ident.span,\n+                                    \"consider using\",\n+                                    new_name.to_string(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                diag.emit();\n+                                false\n+                            },\n+                            DeprecationStatus::None => {\n+                                diag.cancel();\n+                                attr_segments[1].ident.to_string() == name\n+                            },\n+                        }\n                     },\n-                }\n-            } else {\n-                sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n-                false\n-            }\n+                )\n         } else {\n             false\n         }"}, {"sha": "de425211e38ef60b99011a5307377d6fb63c55cf", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -156,6 +156,8 @@ define_Conf! {\n     (array_size_threshold, \"array_size_threshold\": u64, 512_000),\n     /// Lint: VEC_BOX. The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n     (vec_box_size_threshold, \"vec_box_size_threshold\": u64, 4096),\n+    /// Lint: TYPE_REPETITION_IN_BOUNDS. The maximum number of bounds a trait can have to be linted\n+    (max_trait_bounds, \"max_trait_bounds\": u64, 3),\n     /// Lint: STRUCT_EXCESSIVE_BOOLS. The maximum number of bools a struct can have\n     (max_struct_bools, \"max_struct_bools\": u64, 3),\n     /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bools function parameters can have"}, {"sha": "34341594c1985ef41a7a48b84198fad986c59233", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -703,6 +703,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                     for segment in path.segments {\n                         segment.ident.name.hash(&mut self.s);\n+                        self.hash_generic_args(segment.generic_args().args);\n                     }\n                 },\n                 QPath::TypeRelative(ref ty, ref segment) => {\n@@ -711,13 +712,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 },\n             },\n             TyKind::OpaqueDef(_, arg_list) => {\n-                for arg in *arg_list {\n-                    match arg {\n-                        GenericArg::Lifetime(ref l) => self.hash_lifetime(l),\n-                        GenericArg::Type(ref ty) => self.hash_ty(&ty),\n-                        GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n-                    }\n-                }\n+                self.hash_generic_args(arg_list);\n             },\n             TyKind::TraitObject(_, lifetime) => {\n                 self.hash_lifetime(lifetime);\n@@ -735,4 +730,14 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         self.hash_expr(&self.cx.tcx.hir().body(body_id).value);\n         self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n+\n+    fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {\n+        for arg in arg_list {\n+            match arg {\n+                GenericArg::Lifetime(ref l) => self.hash_lifetime(l),\n+                GenericArg::Type(ref ty) => self.hash_ty(&ty),\n+                GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n+            }\n+        }\n+    }\n }"}, {"sha": "4b7a1c2b537f382c5a825eb631221bda07a005fc", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 37, "deletions": 51, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -102,11 +102,7 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n #[must_use]\n pub fn in_macro(span: Span) -> bool {\n     if span.from_expansion() {\n-        if let ExpnKind::Desugaring(..) = span.ctxt().outer_expn_data().kind {\n-            false\n-        } else {\n-            true\n-        }\n+        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n     } else {\n         false\n     }\n@@ -127,10 +123,7 @@ pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n \n /// Checks if given pattern is a wildcard (`_`)\n pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        _ => false,\n-    }\n+    matches!(pat.kind, PatKind::Wild)\n }\n \n /// Checks if type is struct, enum or union type with the given def path.\n@@ -153,11 +146,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n-    if let Some(trt_id) = trt_id {\n-        match_def_path(cx, trt_id, path)\n-    } else {\n-        false\n-    }\n+    trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n }\n \n /// Checks if an expression references a variable of the given name.\n@@ -600,21 +589,15 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n /// //  ^^^^^^^^^^\n /// ```\n pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    if let Some(first_char_pos) = first_char_in_first_line(cx, span) {\n-        span.with_lo(first_char_pos)\n-    } else {\n-        span\n-    }\n+    first_char_in_first_line(cx, span).map_or(span, |first_char_pos| span.with_lo(first_char_pos))\n }\n \n fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n     let line_span = line_span(cx, span);\n-    if let Some(snip) = snippet_opt(cx, line_span) {\n+    snippet_opt(cx, line_span).and_then(|snip| {\n         snip.find(|c: char| !c.is_whitespace())\n             .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n-    } else {\n-        None\n-    }\n+    })\n }\n \n /// Returns the indentation of the line of a span\n@@ -626,11 +609,7 @@ fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePo\n /// //          ^^ -- will return 4\n /// ```\n pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n-    if let Some(snip) = snippet_opt(cx, line_span(cx, span)) {\n-        snip.find(|c: char| !c.is_whitespace())\n-    } else {\n-        None\n-    }\n+    snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n }\n \n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n@@ -738,25 +717,21 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     let enclosing_node = map\n         .get_enclosing_scope(hir_id)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n-    if let Some(node) = enclosing_node {\n-        match node {\n-            Node::Block(block) => Some(block),\n-            Node::Item(&Item {\n-                kind: ItemKind::Fn(_, _, eid),\n-                ..\n-            })\n-            | Node::ImplItem(&ImplItem {\n-                kind: ImplItemKind::Fn(_, eid),\n-                ..\n-            }) => match cx.tcx.hir().body(eid).value.kind {\n-                ExprKind::Block(ref block, _) => Some(block),\n-                _ => None,\n-            },\n+    enclosing_node.and_then(|node| match node {\n+        Node::Block(block) => Some(block),\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(_, _, eid),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(_, eid),\n+            ..\n+        }) => match cx.tcx.hir().body(eid).value.kind {\n+            ExprKind::Block(ref block, _) => Some(block),\n             _ => None,\n-        }\n-    } else {\n-        None\n-    }\n+        },\n+        _ => None,\n+    })\n }\n \n /// Returns the base type for HIR references and pointers.\n@@ -1328,11 +1303,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         _ => None,\n     };\n \n-    if let Some(did) = did {\n-        must_use_attr(&cx.tcx.get_attrs(did)).is_some()\n-    } else {\n-        false\n-    }\n+    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n@@ -1385,6 +1356,21 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n     )\n }\n \n+/// Returns the `DefId` of the callee if the given expression is a function or method call.\n+pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n+    match &expr.kind {\n+        ExprKind::MethodCall(..) => cx.tables().type_dependent_def_id(expr.hir_id),\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(qpath),\n+                ..\n+            },\n+            ..,\n+        ) => cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id(),\n+        _ => None,\n+    }\n+}\n+\n pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n     lints.iter().any(|lint| {\n         matches!("}, {"sha": "87cb454f654bcfb9a2a8ad70c4cceac6ccbd3253", "filename": "src/tools/clippy/clippy_lints/src/utils/numeric_literal.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -51,7 +51,7 @@ impl<'a> NumericLiteral<'a> {\n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n         if lit_kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n             let (unsuffixed, suffix) = split_suffix(&src, lit_kind);\n-            let float = if let LitKind::Float(..) = lit_kind { true } else { false };\n+            let float = matches!(lit_kind, LitKind::Float(..));\n             Some(NumericLiteral::new(unsuffixed, suffix, float))\n         } else {\n             None\n@@ -200,12 +200,10 @@ impl<'a> NumericLiteral<'a> {\n \n fn split_suffix<'a>(src: &'a str, lit_kind: &LitKind) -> (&'a str, Option<&'a str>) {\n     debug_assert!(lit_kind.is_numeric());\n-    if let Some(suffix_length) = lit_suffix_length(lit_kind) {\n+    lit_suffix_length(lit_kind).map_or((src, None), |suffix_length| {\n         let (unsuffixed, suffix) = src.split_at(src.len() - suffix_length);\n         (unsuffixed, Some(suffix))\n-    } else {\n-        (src, None)\n-    }\n+    })\n }\n \n fn lit_suffix_length(lit_kind: &LitKind) -> Option<usize> {"}, {"sha": "4c3462802e9218535b8343bc10b1946a3c3adb87", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -98,7 +98,6 @@ pub const RANGE_TO_STD: [&str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n-pub const REGEX: [&str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];"}, {"sha": "0ac7714fbeb79cd9b3feb6d3665b437c72aabcd0", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -325,22 +325,22 @@ pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n /// parenthesis will always be added for a mix of these.\n pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     /// Returns `true` if the operator is a shift operator `<<` or `>>`.\n-    fn is_shift(op: &AssocOp) -> bool {\n-        matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n+    fn is_shift(op: AssocOp) -> bool {\n+        matches!(op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n     /// Returns `true` if the operator is a arithmetic operator\n     /// (i.e., `+`, `-`, `*`, `/`, `%`).\n-    fn is_arith(op: &AssocOp) -> bool {\n+    fn is_arith(op: AssocOp) -> bool {\n         matches!(\n-            *op,\n+            op,\n             AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus\n         )\n     }\n \n     /// Returns `true` if the operator `op` needs parenthesis with the operator\n     /// `other` in the direction `dir`.\n-    fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n+    fn needs_paren(op: AssocOp, other: AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence()\n             || (other.precedence() == op.precedence()\n                 && ((op != other && associativity(op) != dir)\n@@ -349,14 +349,14 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n             || is_shift(other) && is_arith(op)\n     }\n \n-    let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n-        needs_paren(&op, lop, Associativity::Left)\n+    let lhs_paren = if let Sugg::BinOp(lop, _) = *lhs {\n+        needs_paren(op, lop, Associativity::Left)\n     } else {\n         false\n     };\n \n-    let rhs_paren = if let Sugg::BinOp(ref rop, _) = *rhs {\n-        needs_paren(&op, rop, Associativity::Right)\n+    let rhs_paren = if let Sugg::BinOp(rop, _) = *rhs {\n+        needs_paren(op, rop, Associativity::Right)\n     } else {\n         false\n     };\n@@ -424,13 +424,13 @@ enum Associativity {\n /// they are considered\n /// associative.\n #[must_use]\n-fn associativity(op: &AssocOp) -> Associativity {\n+fn associativity(op: AssocOp) -> Associativity {\n     use rustc_ast::util::parser::AssocOp::{\n         Add, As, Assign, AssignOp, BitAnd, BitOr, BitXor, Colon, Divide, DotDot, DotDotEq, Equal, Greater,\n         GreaterEqual, LAnd, LOr, Less, LessEqual, Modulus, Multiply, NotEqual, ShiftLeft, ShiftRight, Subtract,\n     };\n \n-    match *op {\n+    match op {\n         Assign | AssignOp(_) => Associativity::Right,\n         Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As | Colon => Associativity::Both,\n         Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft | ShiftRight\n@@ -492,20 +492,20 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n /// before it on its line.\n fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().source_map().lookup_char_pos(span.lo());\n-    if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n-        if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n-            // We can mix char and byte positions here because we only consider `[ \\t]`.\n-            if lo.col == CharPos(pos) {\n-                Some(line[..pos].into())\n+    lo.file\n+        .get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */)\n+        .and_then(|line| {\n+            if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n+                // We can mix char and byte positions here because we only consider `[ \\t]`.\n+                if lo.col == CharPos(pos) {\n+                    Some(line[..pos].into())\n+                } else {\n+                    None\n+                }\n             } else {\n                 None\n             }\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n+        })\n }\n \n /// Convenience extension trait for `DiagnosticBuilder`."}, {"sha": "063f94582b9d14cc38f138d8914e8ce178aaae66", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -23,7 +23,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// println!(\"\");\n+    ///\n+    /// // Good\n+    /// println!();\n     /// ```\n     pub PRINTLN_EMPTY_STRING,\n     style,\n@@ -32,8 +36,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `print!()` with a format\n-    /// string that\n-    /// ends in a newline.\n+    /// string that ends in a newline.\n     ///\n     /// **Why is this bad?** You should use `println!()` instead, which appends the\n     /// newline.\n@@ -125,7 +128,12 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n+    ///\n+    /// // Bad\n     /// writeln!(buf, \"\");\n+    ///\n+    /// // Good\n+    /// writeln!(buf);\n     /// ```\n     pub WRITELN_EMPTY_STRING,\n     style,\n@@ -147,7 +155,12 @@ declare_clippy_lint! {\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n     /// # let name = \"World\";\n+    ///\n+    /// // Bad\n     /// write!(buf, \"Hello {}!\\n\", name);\n+    ///\n+    /// // Good\n+    /// writeln!(buf, \"Hello {}!\", name);\n     /// ```\n     pub WRITE_WITH_NEWLINE,\n     style,\n@@ -168,7 +181,12 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n+    ///\n+    /// // Bad\n     /// writeln!(buf, \"{}\", \"foo\");\n+    ///\n+    /// // Good\n+    /// writeln!(buf, \"foo\");\n     /// ```\n     pub WRITE_LITERAL,\n     style,\n@@ -279,13 +297,13 @@ impl EarlyLintPass for Write {\n             if let (Some(fmt_str), expr) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = match expr {\n-                        Some(expr) => snippet_with_applicability(cx, expr.span, \"v\", &mut applicability),\n-                        None => {\n+                    let suggestion = expr.map_or_else(\n+                        || {\n                             applicability = Applicability::HasPlaceholders;\n                             Cow::Borrowed(\"v\")\n                         },\n-                    };\n+                        |e| snippet_with_applicability(cx, e.span, \"v\", &mut Applicability::MachineApplicable),\n+                    );\n \n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "47315fa64cd8019cba3c508de3d960a6c50ebcc0", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -382,13 +382,8 @@ pub fn main() {\n \n         let should_describe_lints = || {\n             let args: Vec<_> = env::args().collect();\n-            args.windows(2).any(|args| {\n-                args[1] == \"help\"\n-                    && match args[0].as_str() {\n-                        \"-W\" | \"-A\" | \"-D\" | \"-F\" => true,\n-                        _ => false,\n-                    }\n-            })\n+            args.windows(2)\n+                .any(|args| args[1] == \"help\" && matches!(args[0].as_str(), \"-W\" | \"-A\" | \"-D\" | \"-F\"))\n         };\n \n         if !wrapper_mode && should_describe_lints() {"}, {"sha": "b89a87128626bc927db31c27665d220c452c52fd", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -80,6 +80,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"blacklisted_name\",\n     },\n+    Lint {\n+        name: \"blanket_clippy_restriction_lints\",\n+        group: \"style\",\n+        desc: \"enabling the complete restriction group\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n     Lint {\n         name: \"blocks_in_if_conditions\",\n         group: \"style\",\n@@ -1144,6 +1151,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"map_identity\",\n+        group: \"complexity\",\n+        desc: \"using iterator.map(|x| x)\",\n+        deprecation: None,\n+        module: \"map_identity\",\n+    },\n     Lint {\n         name: \"map_unwrap_or\",\n         group: \"pedantic\",\n@@ -1165,6 +1179,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"matches\",\n     },\n+    Lint {\n+        name: \"match_like_matches_macro\",\n+        group: \"style\",\n+        desc: \"a match that could be written with the matches! macro\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n     Lint {\n         name: \"match_on_vec_items\",\n         group: \"pedantic\",\n@@ -1606,6 +1627,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"option_env_unwrap\",\n     },\n+    Lint {\n+        name: \"option_if_let_else\",\n+        group: \"pedantic\",\n+        desc: \"reimplementation of Option::map_or\",\n+        deprecation: None,\n+        module: \"option_if_let_else\",\n+    },\n     Lint {\n         name: \"option_map_or_none\",\n         group: \"style\",\n@@ -1683,6 +1711,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"path_buf_push_overwrite\",\n     },\n+    Lint {\n+        name: \"pattern_type_mismatch\",\n+        group: \"restriction\",\n+        desc: \"type of pattern does not match the expression type\",\n+        deprecation: None,\n+        module: \"pattern_type_mismatch\",\n+    },\n     Lint {\n         name: \"possible_missing_comma\",\n         group: \"correctness\",\n@@ -1755,7 +1790,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     },\n     Lint {\n         name: \"range_minus_one\",\n-        group: \"complexity\",\n+        group: \"pedantic\",\n         desc: \"`x..=(y-1)` reads better as `x..y`\",\n         deprecation: None,\n         module: \"ranges\",\n@@ -1828,7 +1863,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"use the proper utility function avoiding an `if let`\",\n         deprecation: None,\n-        module: \"redundant_pattern_matching\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"redundant_pub_crate\",\n@@ -1852,11 +1887,11 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         module: \"reference\",\n     },\n     Lint {\n-        name: \"regex_macro\",\n-        group: \"style\",\n-        desc: \"use of `regex!(_)` instead of `Regex::new(_)`\",\n+        name: \"repeat_once\",\n+        group: \"complexity\",\n+        desc: \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \",\n         deprecation: None,\n-        module: \"regex\",\n+        module: \"repeat_once\",\n     },\n     Lint {\n         name: \"rest_pat_in_fully_bound_structs\","}, {"sha": "26a47d237065a9f0c16cc3db6638a014b9ae86b7", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -12,19 +12,11 @@ use std::path::{Path, PathBuf};\n mod cargo;\n \n fn host_lib() -> PathBuf {\n-    if let Some(path) = option_env!(\"HOST_LIBS\") {\n-        PathBuf::from(path)\n-    } else {\n-        cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\"))\n-    }\n+    option_env!(\"HOST_LIBS\").map_or(cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\")), PathBuf::from)\n }\n \n fn clippy_driver_path() -> PathBuf {\n-    if let Some(path) = option_env!(\"CLIPPY_DRIVER_PATH\") {\n-        PathBuf::from(path)\n-    } else {\n-        cargo::TARGET_LIB.join(\"clippy-driver\")\n-    }\n+    option_env!(\"CLIPPY_DRIVER_PATH\").map_or(cargo::TARGET_LIB.join(\"clippy-driver\"), PathBuf::from)\n }\n \n // When we'll want to use `extern crate ..` for a dependency that is used"}, {"sha": "7e96aa36feb45635355b372e0ac6bb9ba3a11bcb", "filename": "src/tools/clippy/tests/ui-cargo/multiple_crate_versions/fail/Cargo.lock", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.lock?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,109 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n+dependencies = [\n+ \"winapi 0.3.9\",\n+]\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n+\n+[[package]]\n+name = \"ctrlc\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"653abc99aa905f693d89df4797fadc08085baee379db92be9f2496cefe8a6f2c\"\n+dependencies = [\n+ \"kernel32-sys\",\n+ \"nix\",\n+ \"winapi 0.2.8\",\n+]\n+\n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+dependencies = [\n+ \"winapi 0.2.8\",\n+ \"winapi-build\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.71\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9457b06509d27052635f90d6466700c65095fdf75409b3fbdd903e988b886f49\"\n+\n+[[package]]\n+name = \"multiple_crate_versions\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ansi_term\",\n+ \"ctrlc\",\n+]\n+\n+[[package]]\n+name = \"nix\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a2c5afeb0198ec7be8569d666644b574345aad2e95a53baf3a532da3e0f3fb32\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"void\",\n+]\n+\n+[[package]]\n+name = \"void\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\"\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "f3113e093650221171de886a7701689239b55516", "filename": "src/tools/clippy/tests/ui-cargo/multiple_crate_versions/fail/src/main.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,4 +1,4 @@\n-error: multiple versions for dependency `winapi`: 0.2.8, 0.3.8\n+error: multiple versions for dependency `winapi`: 0.2.8, 0.3.9\n    |\n    = note: `-D clippy::multiple-crate-versions` implied by `-D warnings`\n "}, {"sha": "6fbba01416a8d5a27ed47c0b8ae60206ccc1f5fe", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "908d063729f45c4bcdb0a41dc6fb18bfc73c470d", "filename": "src/tools/clippy/tests/ui/attrs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,5 +1,11 @@\n #![warn(clippy::inline_always, clippy::deprecated_semver)]\n #![allow(clippy::assertions_on_constants)]\n+// Test that the whole restriction group is not enabled\n+#![warn(clippy::restriction)]\n+#![deny(clippy::restriction)]\n+#![forbid(clippy::restriction)]\n+#![allow(clippy::missing_docs_in_private_items, clippy::panic, clippy::unreachable)]\n+\n #[inline(always)]\n fn test_attr_lint() {\n     assert!(true)"}, {"sha": "ef4b89eaa6dee41522557104579adbdca5031133", "filename": "src/tools/clippy/tests/ui/attrs.stderr", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,24 +1,49 @@\n error: you have declared `#[inline(always)]` on `test_attr_lint`. This is usually a bad idea\n-  --> $DIR/attrs.rs:3:1\n+  --> $DIR/attrs.rs:9:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::inline-always` implied by `-D warnings`\n \n error: the since field must contain a semver-compliant version\n-  --> $DIR/attrs.rs:23:14\n+  --> $DIR/attrs.rs:29:14\n    |\n LL | #[deprecated(since = \"forever\")]\n    |              ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::deprecated-semver` implied by `-D warnings`\n \n error: the since field must contain a semver-compliant version\n-  --> $DIR/attrs.rs:26:14\n+  --> $DIR/attrs.rs:32:14\n    |\n LL | #[deprecated(since = \"1\")]\n    |              ^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: restriction lints are not meant to be all enabled\n+  --> $DIR/attrs.rs:4:9\n+   |\n+LL | #![warn(clippy::restriction)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::blanket-clippy-restriction-lints` implied by `-D warnings`\n+   = help: try enabling only the lints you really need\n+\n+error: restriction lints are not meant to be all enabled\n+  --> $DIR/attrs.rs:5:9\n+   |\n+LL | #![deny(clippy::restriction)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try enabling only the lints you really need\n+\n+error: restriction lints are not meant to be all enabled\n+  --> $DIR/attrs.rs:6:11\n+   |\n+LL | #![forbid(clippy::restriction)]\n+   |           ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try enabling only the lints you really need\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "1f0ca101757ec849a7d51ef30db43894f7dc742f", "filename": "src/tools/clippy/tests/ui/clone_on_copy.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+\n+#![allow(\n+    unused,\n+    clippy::redundant_clone,\n+    clippy::deref_addrof,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation\n+)]\n+\n+use std::cell::RefCell;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+\n+fn is_ascii(ch: char) -> bool {\n+    ch.is_ascii()\n+}\n+\n+fn clone_on_copy() {\n+    42;\n+\n+    vec![1].clone(); // ok, not a Copy type\n+    Some(vec![1]).clone(); // ok, not a Copy type\n+    *(&42);\n+\n+    let rc = RefCell::new(0);\n+    *rc.borrow();\n+\n+    // Issue #4348\n+    let mut x = 43;\n+    let _ = &x.clone(); // ok, getting a ref\n+    'a'.clone().make_ascii_uppercase(); // ok, clone and then mutate\n+    is_ascii('z');\n+\n+    // Issue #5436\n+    let mut vec = Vec::new();\n+    vec.push(42);\n+}"}, {"sha": "ca39a654b4fce21c6fe1e57a81377152ae8beba0", "filename": "src/tools/clippy/tests/ui/clone_on_copy.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+\n+#![allow(\n+    unused,\n+    clippy::redundant_clone,\n+    clippy::deref_addrof,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation\n+)]\n+\n+use std::cell::RefCell;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+\n+fn is_ascii(ch: char) -> bool {\n+    ch.is_ascii()\n+}\n+\n+fn clone_on_copy() {\n+    42.clone();\n+\n+    vec![1].clone(); // ok, not a Copy type\n+    Some(vec![1]).clone(); // ok, not a Copy type\n+    (&42).clone();\n+\n+    let rc = RefCell::new(0);\n+    rc.borrow().clone();\n+\n+    // Issue #4348\n+    let mut x = 43;\n+    let _ = &x.clone(); // ok, getting a ref\n+    'a'.clone().make_ascii_uppercase(); // ok, clone and then mutate\n+    is_ascii('z'.clone());\n+\n+    // Issue #5436\n+    let mut vec = Vec::new();\n+    vec.push(42.clone());\n+}"}, {"sha": "ec2faf4ab40d2c94b0370006f0633940d8c62d5b", "filename": "src/tools/clippy/tests/ui/clone_on_copy.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,34 @@\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:22:5\n+   |\n+LL |     42.clone();\n+   |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n+   |\n+   = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:26:5\n+   |\n+LL |     (&42).clone();\n+   |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:29:5\n+   |\n+LL |     rc.borrow().clone();\n+   |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:35:14\n+   |\n+LL |     is_ascii('z'.clone());\n+   |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:39:14\n+   |\n+LL |     vec.push(42.clone());\n+   |              ^^^^^^^^^^ help: try removing the `clone` call: `42`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "3305ac9bf8b6cb40ec93bc7fadea0ad83b920d4e", "filename": "src/tools/clippy/tests/ui/cmp_owned/asymmetric_partial_eq.fixed", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == owned {}\n+        if borrowed == owned {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed {}\n+        if owned == borrowed {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == \"Hi\" {}\n+        if borrowed == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "88bc2f51dd6629a8b923f4a1a874ad424764c80f", "filename": "src/tools/clippy/tests/ui/cmp_owned/asymmetric_partial_eq.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed.to_owned() == owned {}\n+        if owned == borrowed.to_owned() {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed.to_owned() {}\n+        if borrowed.to_owned() == owned {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if \"Hi\" == borrowed.to_string() {}\n+        if borrowed.to_string() == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "43bf8851fc620d700fe9adcc457f8d88466c2780", "filename": "src/tools/clippy/tests/ui/cmp_owned/asymmetric_partial_eq.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,46 @@\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:42:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+   |\n+   = note: `-D clippy::cmp-owned` implied by `-D warnings`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:43:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |            ---------^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == owned`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:61:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |                     ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:62:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^---------\n+   |            |\n+   |            help: try: `owned == borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:88:20\n+   |\n+LL |         if \"Hi\" == borrowed.to_string() {}\n+   |            --------^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == \"Hi\"`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:89:12\n+   |\n+LL |         if borrowed.to_string() == \"Hi\" {}\n+   |            ^^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "3d1c458879e58818efd38abb03c8935e23b852de", "filename": "src/tools/clippy/tests/ui/collapsible_else_if.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -10,7 +10,7 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::collapsible-if` implied by `-D warnings`\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if y == \"world\" {\n LL |         println!(\"world!\")\n@@ -28,7 +28,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world!\")\n@@ -48,7 +48,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if y == \"world\" {\n LL |         println!(\"world\")\n@@ -71,7 +71,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world\")\n@@ -94,7 +94,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world\")\n@@ -117,7 +117,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if x == \"hello\" {\n LL |         println!(\"world\")\n@@ -140,7 +140,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world\")"}, {"sha": "f56dd65b9dd26c77144b24d0763ac472b739c238", "filename": "src/tools/clippy/tests/ui/collapsible_if.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -9,7 +9,7 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::collapsible-if` implied by `-D warnings`\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && y == \"world\" {\n LL |         println!(\"Hello world!\");\n@@ -26,7 +26,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if (x == \"hello\" || x == \"world\") && (y == \"world\" || y == \"hello\") {\n LL |         println!(\"Hello world!\");\n@@ -43,7 +43,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && x == \"world\" && (y == \"world\" || y == \"hello\") {\n LL |         println!(\"Hello world!\");\n@@ -60,7 +60,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if (x == \"hello\" || x == \"world\") && y == \"world\" && y == \"hello\" {\n LL |         println!(\"Hello world!\");\n@@ -77,7 +77,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && x == \"world\" && y == \"world\" && y == \"hello\" {\n LL |         println!(\"Hello world!\");\n@@ -94,7 +94,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if 42 == 1337 && 'a' != 'A' {\n LL |         println!(\"world!\")\n@@ -111,7 +111,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && y == \"world\" { // Collapsible\n LL |         println!(\"Hello world!\");"}, {"sha": "3eefb232780f1a9931a6040307eb67edbefeca4d", "filename": "src/tools/clippy/tests/ui/deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -7,5 +7,6 @@\n #[warn(clippy::invalid_ref)]\n #[warn(clippy::into_iter_on_array)]\n #[warn(clippy::unused_label)]\n+#[warn(clippy::regex_macro)]\n \n fn main() {}"}, {"sha": "a80e2bf31feb6b37a7869bba98cef5e84b5ccdae", "filename": "src/tools/clippy/tests/ui/deprecated.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -54,11 +54,17 @@ error: lint `clippy::unused_label` has been removed: `this lint has been uplifte\n LL | #[warn(clippy::unused_label)]\n    |        ^^^^^^^^^^^^^^^^^^^^\n \n+error: lint `clippy::regex_macro` has been removed: `the regex! macro has been removed from the regex crate in 2018`\n+  --> $DIR/deprecated.rs:10:8\n+   |\n+LL | #[warn(clippy::regex_macro)]\n+   |        ^^^^^^^^^^^^^^^^^^^\n+\n error: lint `clippy::str_to_string` has been removed: `using `str::to_string` is common even today and specialization will likely happen soon`\n   --> $DIR/deprecated.rs:1:8\n    |\n LL | #[warn(clippy::str_to_string)]\n    |        ^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "88d3b0e74900152d33938bf332da60dd9035f31c", "filename": "src/tools/clippy/tests/ui/find_map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -19,6 +19,7 @@ fn main() {\n \n     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s| s.parse().unwrap());\n \n+    #[allow(clippy::match_like_matches_macro)]\n     let _: Option<Flavor> = desserts_of_the_week\n         .iter()\n         .find(|dessert| match *dessert {"}, {"sha": "f279850fef8af91a0c520197efb7571f4e22b5e6", "filename": "src/tools/clippy/tests/ui/find_map.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -8,7 +8,7 @@ LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s\n    = help: this is more succinctly expressed by calling `.find_map(..)` instead\n \n error: called `find(p).map(q)` on an `Iterator`\n-  --> $DIR/find_map.rs:22:29\n+  --> $DIR/find_map.rs:23:29\n    |\n LL |       let _: Option<Flavor> = desserts_of_the_week\n    |  _____________________________^"}, {"sha": "bbe411b3f48843bc0487d14a326e6e0df0ebb663", "filename": "src/tools/clippy/tests/ui/floating_point_hypot.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+#![warn(clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 4f32;\n+    let _ = x.hypot(y);\n+    let _ = (x + 1f32).hypot(y);\n+    let _ = x.hypot(y);\n+    // Cases where the lint shouldn't be applied\n+    // TODO: linting this adds some complexity, but could be done\n+    let _ = x.mul_add(x, y * y).sqrt();\n+    let _ = (x * 4f32 + y * y).sqrt();\n+}"}, {"sha": "586fd170ea14565dc41018f640c1c27da3672e3b", "filename": "src/tools/clippy/tests/ui/floating_point_hypot.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+#![warn(clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 4f32;\n+    let _ = (x * x + y * y).sqrt();\n+    let _ = ((x + 1f32) * (x + 1f32) + y * y).sqrt();\n+    let _ = (x.powi(2) + y.powi(2)).sqrt();\n+    // Cases where the lint shouldn't be applied\n+    // TODO: linting this adds some complexity, but could be done\n+    let _ = x.mul_add(x, y * y).sqrt();\n+    let _ = (x * 4f32 + y * y).sqrt();\n+}"}, {"sha": "42069d9ee9efbad760b05431f0262688149eda5f", "filename": "src/tools/clippy/tests/ui/floating_point_hypot.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,22 @@\n+error: hypotenuse can be computed more accurately\n+  --> $DIR/floating_point_hypot.rs:7:13\n+   |\n+LL |     let _ = (x * x + y * y).sqrt();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.hypot(y)`\n+   |\n+   = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n+\n+error: hypotenuse can be computed more accurately\n+  --> $DIR/floating_point_hypot.rs:8:13\n+   |\n+LL |     let _ = ((x + 1f32) * (x + 1f32) + y * y).sqrt();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x + 1f32).hypot(y)`\n+\n+error: hypotenuse can be computed more accurately\n+  --> $DIR/floating_point_hypot.rs:9:13\n+   |\n+LL |     let _ = (x.powi(2) + y.powi(2)).sqrt();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.hypot(y)`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7dc7ee94affc0d06c7ca21e0ad7df80a8d9903d9", "filename": "src/tools/clippy/tests/ui/floating_point_log.fixed", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -25,11 +25,11 @@ fn check_ln1p() {\n     let _ = 2.0f32.ln_1p();\n     let _ = x.ln_1p();\n     let _ = (x / 2.0).ln_1p();\n-    let _ = x.powi(2).ln_1p();\n-    let _ = (x.powi(2) / 2.0).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n+    let _ = (x.powi(3) / 2.0).ln_1p();\n     let _ = ((std::f32::consts::E - 1.0)).ln_1p();\n     let _ = x.ln_1p();\n-    let _ = x.powi(2).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n     let _ = (x + 2.0).ln_1p();\n     let _ = (x / 2.0).ln_1p();\n     // Cases where the lint shouldn't be applied\n@@ -43,9 +43,9 @@ fn check_ln1p() {\n     let _ = 2.0f64.ln_1p();\n     let _ = x.ln_1p();\n     let _ = (x / 2.0).ln_1p();\n-    let _ = x.powi(2).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n     let _ = x.ln_1p();\n-    let _ = x.powi(2).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n     let _ = (x + 2.0).ln_1p();\n     let _ = (x / 2.0).ln_1p();\n     // Cases where the lint shouldn't be applied"}, {"sha": "01181484e7dee290c0973d60a38a93bd71062905", "filename": "src/tools/clippy/tests/ui/floating_point_log.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -25,11 +25,11 @@ fn check_ln1p() {\n     let _ = (1f32 + 2.0).ln();\n     let _ = (1.0 + x).ln();\n     let _ = (1.0 + x / 2.0).ln();\n-    let _ = (1.0 + x.powi(2)).ln();\n-    let _ = (1.0 + x.powi(2) / 2.0).ln();\n+    let _ = (1.0 + x.powi(3)).ln();\n+    let _ = (1.0 + x.powi(3) / 2.0).ln();\n     let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n     let _ = (x + 1.0).ln();\n-    let _ = (x.powi(2) + 1.0).ln();\n+    let _ = (x.powi(3) + 1.0).ln();\n     let _ = (x + 2.0 + 1.0).ln();\n     let _ = (x / 2.0 + 1.0).ln();\n     // Cases where the lint shouldn't be applied\n@@ -43,9 +43,9 @@ fn check_ln1p() {\n     let _ = (1f64 + 2.0).ln();\n     let _ = (1.0 + x).ln();\n     let _ = (1.0 + x / 2.0).ln();\n-    let _ = (1.0 + x.powi(2)).ln();\n+    let _ = (1.0 + x.powi(3)).ln();\n     let _ = (x + 1.0).ln();\n-    let _ = (x.powi(2) + 1.0).ln();\n+    let _ = (x.powi(3) + 1.0).ln();\n     let _ = (x + 2.0 + 1.0).ln();\n     let _ = (x / 2.0 + 1.0).ln();\n     // Cases where the lint shouldn't be applied"}, {"sha": "900dc2b79336a8bd1e67a642c54a6eb1c74966fa", "filename": "src/tools/clippy/tests/ui/floating_point_log.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -77,14 +77,14 @@ LL |     let _ = (1.0 + x / 2.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:28:13\n    |\n-LL |     let _ = (1.0 + x.powi(2)).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (1.0 + x.powi(3)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:29:13\n    |\n-LL |     let _ = (1.0 + x.powi(2) / 2.0).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x.powi(2) / 2.0).ln_1p()`\n+LL |     let _ = (1.0 + x.powi(3) / 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x.powi(3) / 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:30:13\n@@ -101,8 +101,8 @@ LL |     let _ = (x + 1.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:32:13\n    |\n-LL |     let _ = (x.powi(2) + 1.0).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (x.powi(3) + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:33:13\n@@ -143,8 +143,8 @@ LL |     let _ = (1.0 + x / 2.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:46:13\n    |\n-LL |     let _ = (1.0 + x.powi(2)).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (1.0 + x.powi(3)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:47:13\n@@ -155,8 +155,8 @@ LL |     let _ = (x + 1.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:48:13\n    |\n-LL |     let _ = (x.powi(2) + 1.0).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (x.powi(3) + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:49:13"}, {"sha": "13962a272d4552b6ccce46a9ff908890e0add9cf", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 5f32;\n+    let _ = x.log(y);\n+    let _ = x.log(y);\n+    let _ = x.log(y);\n+    let _ = x.log(y);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.ln() / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.ln();\n+    let _ = x.log(5f32) / y.log(7f32);\n+}"}, {"sha": "26bc20d5370b1f0a6f678d1b7d54b6fe447487d8", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 5f32;\n+    let _ = x.ln() / y.ln();\n+    let _ = x.log2() / y.log2();\n+    let _ = x.log10() / y.log10();\n+    let _ = x.log(5f32) / y.log(5f32);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.ln() / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.ln();\n+    let _ = x.log(5f32) / y.log(7f32);\n+}"}, {"sha": "78354c2f62d432eaf0e9c7a9cd6670bfc3bbc4cf", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,28 @@\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:7:13\n+   |\n+LL |     let _ = x.ln() / y.ln();\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:8:13\n+   |\n+LL |     let _ = x.log2() / y.log2();\n+   |             ^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:9:13\n+   |\n+LL |     let _ = x.log10() / y.log10();\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:10:13\n+   |\n+LL |     let _ = x.log(5f32) / y.log(5f32);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "911700bab0040e2e4a33439c537b73cbbeb69721", "filename": "src/tools/clippy/tests/ui/floating_point_mul_add.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -18,4 +18,9 @@ fn main() {\n \n     let _ = a.mul_add(b, c).mul_add(a.mul_add(b, c), a.mul_add(b, c)) + c;\n     let _ = 1234.567_f64.mul_add(45.67834_f64, 0.0004_f64);\n+\n+    let _ = a.mul_add(a, b).sqrt();\n+\n+    // Cases where the lint shouldn't be applied\n+    let _ = (a * a + b * b).sqrt();\n }"}, {"sha": "d202385fc8ae76a0ee0f169852b1d410b3a76f77", "filename": "src/tools/clippy/tests/ui/floating_point_mul_add.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -18,4 +18,9 @@ fn main() {\n \n     let _ = a.mul_add(b, c) * a.mul_add(b, c) + a.mul_add(b, c) + c;\n     let _ = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n+\n+    let _ = (a * a + b).sqrt();\n+\n+    // Cases where the lint shouldn't be applied\n+    let _ = (a * a + b * b).sqrt();\n }"}, {"sha": "ac8d0c0cae068cf87162396380ce510e075d3477", "filename": "src/tools/clippy/tests/ui/floating_point_mul_add.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -54,5 +54,11 @@ error: multiply and add expressions can be calculated more efficiently and accur\n LL |     let _ = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1234.567_f64.mul_add(45.67834_f64, 0.0004_f64)`\n \n-error: aborting due to 9 previous errors\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:22:13\n+   |\n+LL |     let _ = (a * a + b).sqrt();\n+   |             ^^^^^^^^^^^ help: consider using: `a.mul_add(a, b)`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "b0641a100cdc810b4a3c7d3d045928970dfe1272", "filename": "src/tools/clippy/tests/ui/floating_point_powf.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let _ = (-3.1f32).exp();\n     let _ = x.sqrt();\n     let _ = x.cbrt();\n-    let _ = x.powi(2);\n+    let _ = x.powi(3);\n     let _ = x.powi(-2);\n     let _ = x.powi(16_777_215);\n     let _ = x.powi(-16_777_215);\n@@ -30,7 +30,7 @@ fn main() {\n     let _ = (-3.1f64).exp();\n     let _ = x.sqrt();\n     let _ = x.cbrt();\n-    let _ = x.powi(2);\n+    let _ = x.powi(3);\n     let _ = x.powi(-2);\n     let _ = x.powi(-2_147_483_648);\n     let _ = x.powi(2_147_483_647);"}, {"sha": "a0a2c973900f4b7ba943f29a7bb90dcecaf6a8ce", "filename": "src/tools/clippy/tests/ui/floating_point_powf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let _ = std::f32::consts::E.powf(-3.1);\n     let _ = x.powf(1.0 / 2.0);\n     let _ = x.powf(1.0 / 3.0);\n-    let _ = x.powf(2.0);\n+    let _ = x.powf(3.0);\n     let _ = x.powf(-2.0);\n     let _ = x.powf(16_777_215.0);\n     let _ = x.powf(-16_777_215.0);\n@@ -30,7 +30,7 @@ fn main() {\n     let _ = std::f64::consts::E.powf(-3.1);\n     let _ = x.powf(1.0 / 2.0);\n     let _ = x.powf(1.0 / 3.0);\n-    let _ = x.powf(2.0);\n+    let _ = x.powf(3.0);\n     let _ = x.powf(-2.0);\n     let _ = x.powf(-2_147_483_648.0);\n     let _ = x.powf(2_147_483_647.0);"}, {"sha": "2422eb911e90a7041dedbecccf2fa2677a12710d", "filename": "src/tools/clippy/tests/ui/floating_point_powf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -53,8 +53,8 @@ LL |     let _ = x.powf(1.0 / 3.0);\n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:14:13\n    |\n-LL |     let _ = x.powf(2.0);\n-   |             ^^^^^^^^^^^ help: consider using: `x.powi(2)`\n+LL |     let _ = x.powf(3.0);\n+   |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:15:13\n@@ -125,8 +125,8 @@ LL |     let _ = x.powf(1.0 / 3.0);\n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:33:13\n    |\n-LL |     let _ = x.powf(2.0);\n-   |             ^^^^^^^^^^^ help: consider using: `x.powi(2)`\n+LL |     let _ = x.powf(3.0);\n+   |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:34:13"}, {"sha": "56762400593b54fc3806cd7636594698fdf9962a", "filename": "src/tools/clippy/tests/ui/floating_point_powi.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let one = 1;\n+    let x = 3f32;\n+    let _ = x * x;\n+    let _ = x * x;\n+\n+    let y = 4f32;\n+    let _ = x.mul_add(x, y);\n+    let _ = y.mul_add(y, x);\n+    let _ = x.mul_add(x, y).sqrt();\n+    let _ = y.mul_add(y, x).sqrt();\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powi(3);\n+    let _ = x.powi(one + 1);\n+    let _ = (x.powi(2) + y.powi(2)).sqrt();\n+}"}, {"sha": "1f800e4628dcae43fa277f5cbabc5897b9b67008", "filename": "src/tools/clippy/tests/ui/floating_point_powi.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let one = 1;\n+    let x = 3f32;\n+    let _ = x.powi(2);\n+    let _ = x.powi(1 + 1);\n+\n+    let y = 4f32;\n+    let _ = x.powi(2) + y;\n+    let _ = x + y.powi(2);\n+    let _ = (x.powi(2) + y).sqrt();\n+    let _ = (x + y.powi(2)).sqrt();\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powi(3);\n+    let _ = x.powi(one + 1);\n+    let _ = (x.powi(2) + y.powi(2)).sqrt();\n+}"}, {"sha": "d5a5f1bcca1015cb948a125e4c2b09c873b2de0c", "filename": "src/tools/clippy/tests/ui/floating_point_powi.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,40 @@\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:7:13\n+   |\n+LL |     let _ = x.powi(2);\n+   |             ^^^^^^^^^ help: consider using: `x * x`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:8:13\n+   |\n+LL |     let _ = x.powi(1 + 1);\n+   |             ^^^^^^^^^^^^^ help: consider using: `x * x`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:11:13\n+   |\n+LL |     let _ = x.powi(2) + y;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:12:13\n+   |\n+LL |     let _ = x + y.powi(2);\n+   |             ^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:13:13\n+   |\n+LL |     let _ = (x.powi(2) + y).sqrt();\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:14:13\n+   |\n+LL |     let _ = (x + y.powi(2)).sqrt();\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "92480c5db8be446f807d15087515ecab6482fdc3", "filename": "src/tools/clippy/tests/ui/floating_point_rad.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let _ = x.to_degrees();\n+    let _ = x.to_radians();\n+    // Cases where the lint shouldn't be applied\n+    let _ = x * 90f32 / std::f32::consts::PI;\n+    let _ = x * std::f32::consts::PI / 90f32;\n+    let _ = x * 180f32 / std::f32::consts::E;\n+    let _ = x * std::f32::consts::E / 180f32;\n+}"}, {"sha": "062e7c3fdc17afe8d7c1aa4d9a53aa00bff0ae3c", "filename": "src/tools/clippy/tests/ui/floating_point_rad.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let _ = x * 180f32 / std::f32::consts::PI;\n+    let _ = x * std::f32::consts::PI / 180f32;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x * 90f32 / std::f32::consts::PI;\n+    let _ = x * std::f32::consts::PI / 90f32;\n+    let _ = x * 180f32 / std::f32::consts::E;\n+    let _ = x * std::f32::consts::E / 180f32;\n+}"}, {"sha": "a6ffdca64eefea7b563eec7a75c4002f87083be1", "filename": "src/tools/clippy/tests/ui/floating_point_rad.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,16 @@\n+error: conversion to degrees can be done more accurately\n+  --> $DIR/floating_point_rad.rs:6:13\n+   |\n+LL |     let _ = x * 180f32 / std::f32::consts::PI;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.to_degrees()`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: conversion to radians can be done more accurately\n+  --> $DIR/floating_point_rad.rs:7:13\n+   |\n+LL |     let _ = x * std::f32::consts::PI / 180f32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.to_radians()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4171d80f48a3f51826fe8c59870e75ebdd2e488b", "filename": "src/tools/clippy/tests/ui/map_flatten.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,6 +2,7 @@\n \n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::map_identity)]\n \n fn main() {\n     let _: Vec<_> = vec![5_i8; 6].into_iter().flat_map(|x| 0..x).collect();"}, {"sha": "16a0fd090ad04533e0fc1fde345d8c11ea930b5d", "filename": "src/tools/clippy/tests/ui/map_flatten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,6 +2,7 @@\n \n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::map_identity)]\n \n fn main() {\n     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();"}, {"sha": "00bc41c15e9b8d892ee6eb4ee30d3a5ad62a81eb", "filename": "src/tools/clippy/tests/ui/map_flatten.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,13 +1,13 @@\n error: called `map(..).flatten()` on an `Iterator`. This is more succinctly expressed by calling `.flat_map(..)`\n-  --> $DIR/map_flatten.rs:7:21\n+  --> $DIR/map_flatten.rs:8:21\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `vec![5_i8; 6].into_iter().flat_map(|x| 0..x)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n error: called `map(..).flatten()` on an `Option`. This is more succinctly expressed by calling `.and_then(..)`\n-  --> $DIR/map_flatten.rs:8:24\n+  --> $DIR/map_flatten.rs:9:24\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `(Some(Some(1))).and_then(|x| x)`"}, {"sha": "4a1452b25f343923c71059722e6d0fe3d32dcc6f", "filename": "src/tools/clippy/tests/ui/map_identity.fixed", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,23 @@\n+// run-rustfix\n+#![warn(clippy::map_identity)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    let x: [u16; 3] = [1, 2, 3];\n+    // should lint\n+    let _: Vec<_> = x.iter().map(not_identity).collect();\n+    let _: Vec<_> = x.iter().collect();\n+    let _: Option<u8> = Some(3);\n+    let _: Result<i8, f32> = Ok(-3);\n+    // should not lint\n+    let _: Vec<_> = x.iter().map(|x| 2 * x).collect();\n+    let _: Vec<_> = x.iter().map(not_identity).map(|x| return x - 4).collect();\n+    let _: Option<u8> = None.map(|x: u8| x - 1);\n+    let _: Result<i8, f32> = Err(2.3).map(|x: i8| {\n+        return x + 3;\n+    });\n+}\n+\n+fn not_identity(x: &u16) -> u16 {\n+    *x\n+}"}, {"sha": "65c7e6e1ea554a7db9d691ce237337a450e2c3ed", "filename": "src/tools/clippy/tests/ui/map_identity.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,25 @@\n+// run-rustfix\n+#![warn(clippy::map_identity)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    let x: [u16; 3] = [1, 2, 3];\n+    // should lint\n+    let _: Vec<_> = x.iter().map(not_identity).map(|x| return x).collect();\n+    let _: Vec<_> = x.iter().map(std::convert::identity).map(|y| y).collect();\n+    let _: Option<u8> = Some(3).map(|x| x);\n+    let _: Result<i8, f32> = Ok(-3).map(|x| {\n+        return x;\n+    });\n+    // should not lint\n+    let _: Vec<_> = x.iter().map(|x| 2 * x).collect();\n+    let _: Vec<_> = x.iter().map(not_identity).map(|x| return x - 4).collect();\n+    let _: Option<u8> = None.map(|x: u8| x - 1);\n+    let _: Result<i8, f32> = Err(2.3).map(|x: i8| {\n+        return x + 3;\n+    });\n+}\n+\n+fn not_identity(x: &u16) -> u16 {\n+    *x\n+}"}, {"sha": "e4a0320cbda55721fffd017087d3db81a0868937", "filename": "src/tools/clippy/tests/ui/map_identity.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,37 @@\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:8:47\n+   |\n+LL |     let _: Vec<_> = x.iter().map(not_identity).map(|x| return x).collect();\n+   |                                               ^^^^^^^^^^^^^^^^^^ help: remove the call to `map`\n+   |\n+   = note: `-D clippy::map-identity` implied by `-D warnings`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:9:57\n+   |\n+LL |     let _: Vec<_> = x.iter().map(std::convert::identity).map(|y| y).collect();\n+   |                                                         ^^^^^^^^^^^ help: remove the call to `map`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:9:29\n+   |\n+LL |     let _: Vec<_> = x.iter().map(std::convert::identity).map(|y| y).collect();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the call to `map`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:10:32\n+   |\n+LL |     let _: Option<u8> = Some(3).map(|x| x);\n+   |                                ^^^^^^^^^^^ help: remove the call to `map`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:11:36\n+   |\n+LL |       let _: Result<i8, f32> = Ok(-3).map(|x| {\n+   |  ____________________________________^\n+LL | |         return x;\n+LL | |     });\n+   | |______^ help: remove the call to `map`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "f3e19092480ad12483c9d6a91ddd36abaaa2ff8e", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+#![allow(unreachable_patterns)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = matches!(x, Some(0));\n+\n+    // Lint\n+    let _w = matches!(x, Some(_));\n+\n+    // Turn into is_none\n+    let _z = x.is_none();\n+\n+    // Lint\n+    let _zz = !matches!(x, Some(r) if r == 0);\n+\n+    // Lint\n+    let _zzz = matches!(x, Some(5));\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        _ => false,\n+    };\n+\n+    // No lint\n+    let _ab = match x {\n+        Some(0) => false,\n+        _ => true,\n+        None => false,\n+    };\n+}"}, {"sha": "fbae7c18b92392f2bf494a59d3efcb684983962a", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,48 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+#![allow(unreachable_patterns)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = match x {\n+        Some(0) => true,\n+        _ => false,\n+    };\n+\n+    // Lint\n+    let _w = match x {\n+        Some(_) => true,\n+        _ => false,\n+    };\n+\n+    // Turn into is_none\n+    let _z = match x {\n+        Some(_) => false,\n+        None => true,\n+    };\n+\n+    // Lint\n+    let _zz = match x {\n+        Some(r) if r == 0 => false,\n+        _ => true,\n+    };\n+\n+    // Lint\n+    let _zzz = if let Some(5) = x { true } else { false };\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        _ => false,\n+    };\n+\n+    // No lint\n+    let _ab = match x {\n+        Some(0) => false,\n+        _ => true,\n+        None => false,\n+    };\n+}"}, {"sha": "4668f8565a656f54740ecb3eb0a21f2a63f12386", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,52 @@\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:10:14\n+   |\n+LL |       let _y = match x {\n+   |  ______________^\n+LL | |         Some(0) => true,\n+LL | |         _ => false,\n+LL | |     };\n+   | |_____^ help: try this: `matches!(x, Some(0))`\n+   |\n+   = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:16:14\n+   |\n+LL |       let _w = match x {\n+   |  ______________^\n+LL | |         Some(_) => true,\n+LL | |         _ => false,\n+LL | |     };\n+   | |_____^ help: try this: `matches!(x, Some(_))`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/match_expr_like_matches_macro.rs:22:14\n+   |\n+LL |       let _z = match x {\n+   |  ______________^\n+LL | |         Some(_) => false,\n+LL | |         None => true,\n+LL | |     };\n+   | |_____^ help: try this: `x.is_none()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:28:15\n+   |\n+LL |       let _zz = match x {\n+   |  _______________^\n+LL | |         Some(r) if r == 0 => false,\n+LL | |         _ => true,\n+LL | |     };\n+   | |_____^ help: try this: `!matches!(x, Some(r) if r == 0)`\n+\n+error: if let .. else expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:34:16\n+   |\n+LL |     let _zzz = if let Some(5) = x { true } else { false };\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `matches!(x, Some(5))`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "2d392c593b3e7e58cc2d160067f48eb43b1f7a1c", "filename": "src/tools/clippy/tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -4,7 +4,7 @@\n \n use std::cmp::Ordering;\n \n-#[allow(clippy::unnested_or_patterns)]\n+#[allow(clippy::unnested_or_patterns, clippy::match_like_matches_macro)]\n #[warn(clippy::neg_cmp_op_on_partial_ord)]\n fn main() {\n     let a_value = 1.0;"}, {"sha": "695a460cc4edfda0a16871c1aa0b3f1498359271", "filename": "src/tools/clippy/tests/ui/option_if_let_else.fixed", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,74 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    string.map_or((false, \"hello\"), |x| (true, x))\n+}\n+\n+fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n+    if string.is_none() {\n+        None\n+    } else { string.map_or(Some((false, \"\")), |x| Some((true, x))) }\n+}\n+\n+fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {\n+    let _ = string.map_or(0, |s| s.len());\n+    let _ = num.as_ref().map_or(&0, |s| s);\n+    let _ = num.as_mut().map_or(&mut 0, |s| {\n+        *s += 1;\n+        s\n+    });\n+    let _ = num.as_ref().map_or(&0, |s| s);\n+    let _ = num.map_or(0, |mut s| {\n+        s += 1;\n+        s\n+    });\n+    let _ = num.as_mut().map_or(&mut 0, |s| {\n+        *s += 1;\n+        s\n+    });\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    arg.map_or(13, |x| {\n+        let y = x * x;\n+        y * y\n+    })\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = arg.map_or_else(|| {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    }, |x| x * x * x * x);\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = optional.map_or(5, |x| x + 2);\n+    let _ = bad1(None);\n+    let _ = else_if_option(None);\n+    unop_bad(&None, None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "dee80d26bd976d93fda3f72fd0ce3a4cd65c3307", "filename": "src/tools/clippy/tests/ui/option_if_let_else.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,92 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    if let Some(x) = string {\n+        (true, x)\n+    } else {\n+        (false, \"hello\")\n+    }\n+}\n+\n+fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n+    if string.is_none() {\n+        None\n+    } else if let Some(x) = string {\n+        Some((true, x))\n+    } else {\n+        Some((false, \"\"))\n+    }\n+}\n+\n+fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {\n+    let _ = if let Some(s) = *string { s.len() } else { 0 };\n+    let _ = if let Some(s) = &num { s } else { &0 };\n+    let _ = if let Some(s) = &mut num {\n+        *s += 1;\n+        s\n+    } else {\n+        &mut 0\n+    };\n+    let _ = if let Some(ref s) = num { s } else { &0 };\n+    let _ = if let Some(mut s) = num {\n+        s += 1;\n+        s\n+    } else {\n+        0\n+    };\n+    let _ = if let Some(ref mut s) = num {\n+        *s += 1;\n+        s\n+    } else {\n+        &mut 0\n+    };\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    if let Some(x) = arg {\n+        let y = x * x;\n+        y * y\n+    } else {\n+        13\n+    }\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = if let Some(x) = arg {\n+        x * x * x * x\n+    } else {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    };\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+    let _ = bad1(None);\n+    let _ = else_if_option(None);\n+    unop_bad(&None, None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "7005850efaf833b47f693ae04a7e9cd37722e476", "filename": "src/tools/clippy/tests/ui/option_if_let_else.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,151 @@\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:5:5\n+   |\n+LL | /     if let Some(x) = string {\n+LL | |         (true, x)\n+LL | |     } else {\n+LL | |         (false, \"hello\")\n+LL | |     }\n+   | |_____^ help: try: `string.map_or((false, \"hello\"), |x| (true, x))`\n+   |\n+   = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:15:12\n+   |\n+LL |       } else if let Some(x) = string {\n+   |  ____________^\n+LL | |         Some((true, x))\n+LL | |     } else {\n+LL | |         Some((false, \"\"))\n+LL | |     }\n+   | |_____^ help: try: `{ string.map_or(Some((false, \"\")), |x| Some((true, x))) }`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:23:13\n+   |\n+LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:24:13\n+   |\n+LL |     let _ = if let Some(s) = &num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:25:13\n+   |\n+LL |       let _ = if let Some(s) = &mut num {\n+   |  _____________^\n+LL | |         *s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         &mut 0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.as_mut().map_or(&mut 0, |s| {\n+LL |         *s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:31:13\n+   |\n+LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:32:13\n+   |\n+LL |       let _ = if let Some(mut s) = num {\n+   |  _____________^\n+LL | |         s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.map_or(0, |mut s| {\n+LL |         s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:38:13\n+   |\n+LL |       let _ = if let Some(ref mut s) = num {\n+   |  _____________^\n+LL | |         *s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         &mut 0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.as_mut().map_or(&mut 0, |s| {\n+LL |         *s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:47:5\n+   |\n+LL | /     if let Some(x) = arg {\n+LL | |         let y = x * x;\n+LL | |         y * y\n+LL | |     } else {\n+LL | |         13\n+LL | |     }\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     arg.map_or(13, |x| {\n+LL |         let y = x * x;\n+LL |         y * y\n+LL |     })\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:56:13\n+   |\n+LL |       let _ = if let Some(x) = arg {\n+   |  _____________^\n+LL | |         x * x * x * x\n+LL | |     } else {\n+LL | |         let mut y = 1;\n+...  |\n+LL | |         y\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = arg.map_or_else(|| {\n+LL |         let mut y = 1;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y\n+LL |     }, |x| x * x * x * x);\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:85:13\n+   |\n+LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "9b4f2f1f57934dbd8332c2932bfed5f30836626a", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/mutability.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,40 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn should_lint() {\n+    let value = &Some(23);\n+    match value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+\n+    let value = &mut Some(23);\n+    match value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn should_not_lint() {\n+    let value = &Some(23);\n+    match value {\n+        &Some(_) => (),\n+        _ => (),\n+    }\n+    match *value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+\n+    let value = &mut Some(23);\n+    match value {\n+        &mut Some(_) => (),\n+        _ => (),\n+    }\n+    match *value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "3421d568365cc98b01afd8189aa6e3d7206752aa", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/mutability.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,19 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/mutability.rs:9:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/mutability.rs:15:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&mut _` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "065ea9fb9b5a4c823ddf37d111f8b466dd1a5025", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_alternatives.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,24 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn alternatives() {\n+    enum Value<'a> {\n+        Unused,\n+        A(&'a Option<i32>),\n+        B,\n+    }\n+    let ref_value = &Value::A(&Some(23));\n+\n+    // not ok\n+    if let Value::B | Value::A(_) = ref_value {}\n+    if let &Value::B | &Value::A(Some(_)) = ref_value {}\n+    if let Value::B | Value::A(Some(_)) = *ref_value {}\n+\n+    // ok\n+    if let &Value::B | &Value::A(_) = ref_value {}\n+    if let Value::B | Value::A(_) = *ref_value {}\n+    if let &Value::B | &Value::A(&Some(_)) = ref_value {}\n+    if let Value::B | Value::A(&Some(_)) = *ref_value {}\n+}"}, {"sha": "d285c93782c67962664f2a0e048d428307b8b3f7", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_alternatives.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,27 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:15:12\n+   |\n+LL |     if let Value::B | Value::A(_) = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:16:34\n+   |\n+LL |     if let &Value::B | &Value::A(Some(_)) = ref_value {}\n+   |                                  ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:17:32\n+   |\n+LL |     if let Value::B | Value::A(Some(_)) = *ref_value {}\n+   |                                ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "417b1c107c55b8ce8c4ae160175c0e511ca3fcab", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_structs.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,45 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn struct_types() {\n+    struct Struct<'a> {\n+        ref_inner: &'a Option<i32>,\n+    }\n+    let ref_value = &Struct { ref_inner: &Some(42) };\n+\n+    // not ok\n+    let Struct { .. } = ref_value;\n+    if let &Struct { ref_inner: Some(_) } = ref_value {}\n+    if let Struct { ref_inner: Some(_) } = *ref_value {}\n+\n+    // ok\n+    let &Struct { .. } = ref_value;\n+    let Struct { .. } = *ref_value;\n+    if let &Struct { ref_inner: &Some(_) } = ref_value {}\n+    if let Struct { ref_inner: &Some(_) } = *ref_value {}\n+}\n+\n+fn struct_enum_variants() {\n+    enum StructEnum<'a> {\n+        Empty,\n+        Var { inner_ref: &'a Option<i32> },\n+    }\n+    let ref_value = &StructEnum::Var { inner_ref: &Some(42) };\n+\n+    // not ok\n+    if let StructEnum::Var { .. } = ref_value {}\n+    if let StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+    if let &StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+    if let StructEnum::Var { inner_ref: Some(_) } = *ref_value {}\n+    if let StructEnum::Empty = ref_value {}\n+\n+    // ok\n+    if let &StructEnum::Var { .. } = ref_value {}\n+    if let StructEnum::Var { .. } = *ref_value {}\n+    if let &StructEnum::Var { inner_ref: &Some(_) } = ref_value {}\n+    if let StructEnum::Var { inner_ref: &Some(_) } = *ref_value {}\n+    if let &StructEnum::Empty = ref_value {}\n+    if let StructEnum::Empty = *ref_value {}\n+}"}, {"sha": "d428e85b0c91403be6c9356fe3a383eb1a61d2ea", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_structs.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,67 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:13:9\n+   |\n+LL |     let Struct { .. } = ref_value;\n+   |         ^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:14:33\n+   |\n+LL |     if let &Struct { ref_inner: Some(_) } = ref_value {}\n+   |                                 ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:15:32\n+   |\n+LL |     if let Struct { ref_inner: Some(_) } = *ref_value {}\n+   |                                ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:32:12\n+   |\n+LL |     if let StructEnum::Var { .. } = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:33:12\n+   |\n+LL |     if let StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:34:42\n+   |\n+LL |     if let &StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+   |                                          ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:35:41\n+   |\n+LL |     if let StructEnum::Var { inner_ref: Some(_) } = *ref_value {}\n+   |                                         ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:36:12\n+   |\n+LL |     if let StructEnum::Empty = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "19504a051d8b12927f9365decd04f09f2b005d31", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_tuples.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,57 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn tuple_types() {\n+    struct TupleStruct<'a>(&'a Option<i32>);\n+    let ref_value = &TupleStruct(&Some(42));\n+\n+    // not ok\n+    let TupleStruct(_) = ref_value;\n+    if let &TupleStruct(Some(_)) = ref_value {}\n+    if let TupleStruct(Some(_)) = *ref_value {}\n+\n+    // ok\n+    let &TupleStruct(_) = ref_value;\n+    let TupleStruct(_) = *ref_value;\n+    if let &TupleStruct(&Some(_)) = ref_value {}\n+    if let TupleStruct(&Some(_)) = *ref_value {}\n+}\n+\n+fn tuple_enum_variants() {\n+    enum TupleEnum<'a> {\n+        Empty,\n+        Var(&'a Option<i32>),\n+    }\n+    let ref_value = &TupleEnum::Var(&Some(42));\n+\n+    // not ok\n+    if let TupleEnum::Var(_) = ref_value {}\n+    if let &TupleEnum::Var(Some(_)) = ref_value {}\n+    if let TupleEnum::Var(Some(_)) = *ref_value {}\n+    if let TupleEnum::Empty = ref_value {}\n+\n+    // ok\n+    if let &TupleEnum::Var(_) = ref_value {}\n+    if let TupleEnum::Var(_) = *ref_value {}\n+    if let &TupleEnum::Var(&Some(_)) = ref_value {}\n+    if let TupleEnum::Var(&Some(_)) = *ref_value {}\n+    if let &TupleEnum::Empty = ref_value {}\n+    if let TupleEnum::Empty = *ref_value {}\n+}\n+\n+fn plain_tuples() {\n+    let ref_value = &(&Some(23), &Some(42));\n+\n+    // not ok\n+    let (_a, _b) = ref_value;\n+    if let &(_a, Some(_)) = ref_value {}\n+    if let (_a, Some(_)) = *ref_value {}\n+\n+    // ok\n+    let &(_a, _b) = ref_value;\n+    let (_a, _b) = *ref_value;\n+    if let &(_a, &Some(_)) = ref_value {}\n+    if let (_a, &Some(_)) = *ref_value {}\n+}"}, {"sha": "edd0074d00d3b52228a370642907526e70d1c26c", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_tuples.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,83 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:11:9\n+   |\n+LL |     let TupleStruct(_) = ref_value;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:12:25\n+   |\n+LL |     if let &TupleStruct(Some(_)) = ref_value {}\n+   |                         ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:13:24\n+   |\n+LL |     if let TupleStruct(Some(_)) = *ref_value {}\n+   |                        ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:30:12\n+   |\n+LL |     if let TupleEnum::Var(_) = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:31:28\n+   |\n+LL |     if let &TupleEnum::Var(Some(_)) = ref_value {}\n+   |                            ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:32:27\n+   |\n+LL |     if let TupleEnum::Var(Some(_)) = *ref_value {}\n+   |                           ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:33:12\n+   |\n+LL |     if let TupleEnum::Empty = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:48:9\n+   |\n+LL |     let (_a, _b) = ref_value;\n+   |         ^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:49:18\n+   |\n+LL |     if let &(_a, Some(_)) = ref_value {}\n+   |                  ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:50:17\n+   |\n+LL |     if let (_a, Some(_)) = *ref_value {}\n+   |                 ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "e89917c41e8c1a72a50451d1b628a0dfaef4fe78", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/syntax.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,146 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn syntax_match() {\n+    let ref_value = &Some(&Some(42));\n+\n+    // not ok\n+    match ref_value {\n+        Some(_) => (),\n+        None => (),\n+    }\n+\n+    // ok\n+    match ref_value {\n+        &Some(_) => (),\n+        &None => (),\n+    }\n+    match *ref_value {\n+        Some(_) => (),\n+        None => (),\n+    }\n+}\n+\n+fn syntax_if_let() {\n+    let ref_value = &Some(42);\n+\n+    // not ok\n+    if let Some(_) = ref_value {}\n+\n+    // ok\n+    if let &Some(_) = ref_value {}\n+    if let Some(_) = *ref_value {}\n+}\n+\n+fn syntax_while_let() {\n+    let ref_value = &Some(42);\n+\n+    // not ok\n+    while let Some(_) = ref_value {\n+        break;\n+    }\n+\n+    // ok\n+    while let &Some(_) = ref_value {\n+        break;\n+    }\n+    while let Some(_) = *ref_value {\n+        break;\n+    }\n+}\n+\n+fn syntax_for() {\n+    let ref_value = &Some(23);\n+    let slice = &[(2, 3), (4, 2)];\n+\n+    // not ok\n+    for (_a, _b) in slice.iter() {}\n+\n+    // ok\n+    for &(_a, _b) in slice.iter() {}\n+}\n+\n+fn syntax_let() {\n+    let ref_value = &(2, 3);\n+\n+    // not ok\n+    let (_n, _m) = ref_value;\n+\n+    // ok\n+    let &(_n, _m) = ref_value;\n+    let (_n, _m) = *ref_value;\n+}\n+\n+fn syntax_fn() {\n+    // not ok\n+    fn foo((_a, _b): &(i32, i32)) {}\n+\n+    // ok\n+    fn foo_ok_1(&(_a, _b): &(i32, i32)) {}\n+}\n+\n+fn syntax_closure() {\n+    fn foo<F>(f: F)\n+    where\n+        F: FnOnce(&(i32, i32)),\n+    {\n+    }\n+\n+    // not ok\n+    foo(|(_a, _b)| ());\n+\n+    // ok\n+    foo(|&(_a, _b)| ());\n+}\n+\n+fn macro_with_expression() {\n+    macro_rules! matching_macro {\n+        ($e:expr) => {\n+            $e\n+        };\n+    }\n+    let value = &Some(23);\n+\n+    // not ok\n+    matching_macro!(match value {\n+        Some(_) => (),\n+        _ => (),\n+    });\n+\n+    // ok\n+    matching_macro!(match value {\n+        &Some(_) => (),\n+        _ => (),\n+    });\n+    matching_macro!(match *value {\n+        Some(_) => (),\n+        _ => (),\n+    });\n+}\n+\n+fn macro_expansion() {\n+    macro_rules! matching_macro {\n+        ($e:expr) => {\n+            // not ok\n+            match $e {\n+                Some(_) => (),\n+                _ => (),\n+            }\n+\n+            // ok\n+            match $e {\n+                &Some(_) => (),\n+                _ => (),\n+            }\n+            match *$e {\n+                Some(_) => (),\n+                _ => (),\n+            }\n+        };\n+    }\n+\n+    let value = &Some(23);\n+    matching_macro!(value);\n+}"}, {"sha": "5a5186bd4fcb3389cbca59b4e09fd7554e7f5330", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/syntax.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,79 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:11:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:30:12\n+   |\n+LL |     if let Some(_) = ref_value {}\n+   |            ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:41:15\n+   |\n+LL |     while let Some(_) = ref_value {\n+   |               ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:59:9\n+   |\n+LL |     for (_a, _b) in slice.iter() {}\n+   |         ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:69:9\n+   |\n+LL |     let (_n, _m) = ref_value;\n+   |         ^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:78:12\n+   |\n+LL |     fn foo((_a, _b): &(i32, i32)) {}\n+   |            ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:92:10\n+   |\n+LL |     foo(|(_a, _b)| ());\n+   |          ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:108:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:128:17\n+   |\n+LL |                 Some(_) => (),\n+   |                 ^^^^^^^\n+...\n+LL |     matching_macro!(value);\n+   |     ----------------------- in this macro invocation\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "19b253b0fe2c6b94c1c43c9cfd4e736b438967b5", "filename": "src/tools/clippy/tests/ui/range_plus_minus_one.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -7,6 +7,7 @@ fn f() -> usize {\n }\n \n #[warn(clippy::range_plus_one)]\n+#[warn(clippy::range_minus_one)]\n fn main() {\n     for _ in 0..2 {}\n     for _ in 0..=2 {}"}, {"sha": "7d034117547caf87990d1c824b99b872471eefe8", "filename": "src/tools/clippy/tests/ui/range_plus_minus_one.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -7,6 +7,7 @@ fn f() -> usize {\n }\n \n #[warn(clippy::range_plus_one)]\n+#[warn(clippy::range_minus_one)]\n fn main() {\n     for _ in 0..2 {}\n     for _ in 0..=2 {}"}, {"sha": "fb4f1658597a585de8f220e9255e0f5c57388ad5", "filename": "src/tools/clippy/tests/ui/range_plus_minus_one.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,57 +1,57 @@\n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:14:14\n+  --> $DIR/range_plus_minus_one.rs:15:14\n    |\n LL |     for _ in 0..3 + 1 {}\n    |              ^^^^^^^^ help: use: `0..=3`\n    |\n    = note: `-D clippy::range-plus-one` implied by `-D warnings`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:17:14\n+  --> $DIR/range_plus_minus_one.rs:18:14\n    |\n LL |     for _ in 0..1 + 5 {}\n    |              ^^^^^^^^ help: use: `0..=5`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:20:14\n+  --> $DIR/range_plus_minus_one.rs:21:14\n    |\n LL |     for _ in 1..1 + 1 {}\n    |              ^^^^^^^^ help: use: `1..=1`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:26:14\n+  --> $DIR/range_plus_minus_one.rs:27:14\n    |\n LL |     for _ in 0..(1 + f()) {}\n    |              ^^^^^^^^^^^^ help: use: `0..=f()`\n \n error: an exclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:30:13\n+  --> $DIR/range_plus_minus_one.rs:31:13\n    |\n LL |     let _ = ..=11 - 1;\n    |             ^^^^^^^^^ help: use: `..11`\n    |\n    = note: `-D clippy::range-minus-one` implied by `-D warnings`\n \n error: an exclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:31:13\n+  --> $DIR/range_plus_minus_one.rs:32:13\n    |\n LL |     let _ = ..=(11 - 1);\n    |             ^^^^^^^^^^^ help: use: `..11`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:32:13\n+  --> $DIR/range_plus_minus_one.rs:33:13\n    |\n LL |     let _ = (1..11 + 1);\n    |             ^^^^^^^^^^^ help: use: `(1..=11)`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:33:13\n+  --> $DIR/range_plus_minus_one.rs:34:13\n    |\n LL |     let _ = (f() + 1)..(f() + 1);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: use: `((f() + 1)..=f())`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:37:14\n+  --> $DIR/range_plus_minus_one.rs:38:14\n    |\n LL |     for _ in 1..ONE + ONE {}\n    |              ^^^^^^^^^^^^ help: use: `1..=ONE`"}, {"sha": "ce8582d2b221cd21c891bfd38af0d20bfd073ec4", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.fixed", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if Ok::<i32, i32>(42).is_ok() {}"}, {"sha": "a3a9aa40e3b9c8ec7fd2b7a708c34bf5d93377ab", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if let Ok(_) = Ok::<i32, i32>(42) {}"}, {"sha": "25d1476062e7f599e7fe37dfddab9c1ce80bc1c0", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.stderr", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,73 +1,73 @@\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:8:12\n+  --> $DIR/redundant_pattern_matching.rs:14:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:10:12\n+  --> $DIR/redundant_pattern_matching.rs:16:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:12:12\n+  --> $DIR/redundant_pattern_matching.rs:18:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:14:12\n+  --> $DIR/redundant_pattern_matching.rs:20:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:16:12\n+  --> $DIR/redundant_pattern_matching.rs:22:12\n    |\n LL |     if let Some(_) = Some(42) {\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:22:15\n+  --> $DIR/redundant_pattern_matching.rs:28:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:24:15\n+  --> $DIR/redundant_pattern_matching.rs:30:15\n    |\n LL |     while let None = Some(42) {}\n    |     ----------^^^^----------- help: try this: `while Some(42).is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:26:15\n+  --> $DIR/redundant_pattern_matching.rs:32:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:28:15\n+  --> $DIR/redundant_pattern_matching.rs:34:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:30:15\n+  --> $DIR/redundant_pattern_matching.rs:36:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:33:15\n+  --> $DIR/redundant_pattern_matching.rs:39:15\n    |\n LL |     while let Some(_) = v.pop() {\n    |     ----------^^^^^^^---------- help: try this: `while v.pop().is_some()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:49:5\n+  --> $DIR/redundant_pattern_matching.rs:55:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -76,7 +76,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:54:5\n+  --> $DIR/redundant_pattern_matching.rs:60:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -85,7 +85,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:59:5\n+  --> $DIR/redundant_pattern_matching.rs:65:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -94,7 +94,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:64:5\n+  --> $DIR/redundant_pattern_matching.rs:70:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -103,7 +103,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:69:5\n+  --> $DIR/redundant_pattern_matching.rs:75:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -112,7 +112,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:74:5\n+  --> $DIR/redundant_pattern_matching.rs:80:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,\n@@ -121,7 +121,7 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:79:13\n+  --> $DIR/redundant_pattern_matching.rs:85:13\n    |\n LL |       let _ = match None::<()> {\n    |  _____________^\n@@ -131,61 +131,61 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:84:20\n+  --> $DIR/redundant_pattern_matching.rs:90:20\n    |\n LL |     let _ = if let Ok(_) = Ok::<usize, ()>(4) { true } else { false };\n    |             -------^^^^^--------------------- help: try this: `if Ok::<usize, ()>(4).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:87:20\n+  --> $DIR/redundant_pattern_matching.rs:93:20\n    |\n LL |     let x = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:93:20\n+  --> $DIR/redundant_pattern_matching.rs:99:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:95:19\n+  --> $DIR/redundant_pattern_matching.rs:101:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:97:19\n+  --> $DIR/redundant_pattern_matching.rs:103:19\n    |\n LL |     } else if let Ok(_) = gen_res() {\n    |            -------^^^^^------------ help: try this: `if gen_res().is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:99:19\n+  --> $DIR/redundant_pattern_matching.rs:105:19\n    |\n LL |     } else if let Err(_) = gen_res() {\n    |            -------^^^^^^------------ help: try this: `if gen_res().is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:132:19\n+  --> $DIR/redundant_pattern_matching.rs:138:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n    |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:133:16\n+  --> $DIR/redundant_pattern_matching.rs:139:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n    |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:139:12\n+  --> $DIR/redundant_pattern_matching.rs:145:12\n    |\n LL |     if let Some(_) = m!() {}\n    |     -------^^^^^^^------- help: try this: `if m!().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:140:15\n+  --> $DIR/redundant_pattern_matching.rs:146:15\n    |\n LL |     while let Some(_) = m!() {}\n    |     ----------^^^^^^^------- help: try this: `while m!().is_some()`"}, {"sha": "de3fe00d5fa689b81591706e9acd4693f1073053", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_const_result.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}, {"sha": "b77969d53d92df3def12d657c545d7c62e5ee39d", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_const_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}, {"sha": "9767e5bf76a85ca7953b01ee53068b67925b282a", "filename": "src/tools/clippy/tests/ui/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,5 +1,5 @@\n #![allow(unused)]\n-#![warn(clippy::invalid_regex, clippy::trivial_regex, clippy::regex_macro)]\n+#![warn(clippy::invalid_regex, clippy::trivial_regex)]\n \n extern crate regex;\n "}, {"sha": "a637c22fbcd266211e9247df2ac21c2b14b3dd56", "filename": "src/tools/clippy/tests/ui/repeat_once.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::repeat_once)]\n+#[allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n+fn main() {\n+    const N: usize = 1;\n+    let s = \"str\";\n+    let string = \"String\".to_string();\n+    let slice = [1; 5];\n+\n+    let a = [1; 5].to_vec();\n+    let b = slice.to_vec();\n+    let c = \"hello\".to_string();\n+    let d = \"hi\".to_string();\n+    let e = s.to_string();\n+    let f = string.clone();\n+}"}, {"sha": "d99ca1b5b55d4200df4831fa22074cc3f2ce39cb", "filename": "src/tools/clippy/tests/ui/repeat_once.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::repeat_once)]\n+#[allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n+fn main() {\n+    const N: usize = 1;\n+    let s = \"str\";\n+    let string = \"String\".to_string();\n+    let slice = [1; 5];\n+\n+    let a = [1; 5].repeat(1);\n+    let b = slice.repeat(1);\n+    let c = \"hello\".repeat(N);\n+    let d = \"hi\".repeat(1);\n+    let e = s.repeat(1);\n+    let f = string.repeat(1);\n+}"}, {"sha": "915eea3bfc6b8fbec2a4c74c55b4126602aaccab", "filename": "src/tools/clippy/tests/ui/repeat_once.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,40 @@\n+error: calling `repeat(1)` on slice\n+  --> $DIR/repeat_once.rs:10:13\n+   |\n+LL |     let a = [1; 5].repeat(1);\n+   |             ^^^^^^^^^^^^^^^^ help: consider using `.to_vec()` instead: `[1; 5].to_vec()`\n+   |\n+   = note: `-D clippy::repeat-once` implied by `-D warnings`\n+\n+error: calling `repeat(1)` on slice\n+  --> $DIR/repeat_once.rs:11:13\n+   |\n+LL |     let b = slice.repeat(1);\n+   |             ^^^^^^^^^^^^^^^ help: consider using `.to_vec()` instead: `slice.to_vec()`\n+\n+error: calling `repeat(1)` on str\n+  --> $DIR/repeat_once.rs:12:13\n+   |\n+LL |     let c = \"hello\".repeat(N);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using `.to_string()` instead: `\"hello\".to_string()`\n+\n+error: calling `repeat(1)` on str\n+  --> $DIR/repeat_once.rs:13:13\n+   |\n+LL |     let d = \"hi\".repeat(1);\n+   |             ^^^^^^^^^^^^^^ help: consider using `.to_string()` instead: `\"hi\".to_string()`\n+\n+error: calling `repeat(1)` on str\n+  --> $DIR/repeat_once.rs:14:13\n+   |\n+LL |     let e = s.repeat(1);\n+   |             ^^^^^^^^^^^ help: consider using `.to_string()` instead: `s.to_string()`\n+\n+error: calling `repeat(1)` on a string literal\n+  --> $DIR/repeat_once.rs:15:13\n+   |\n+LL |     let f = string.repeat(1);\n+   |             ^^^^^^^^^^^^^^^^ help: consider using `.clone()` instead: `string.clone()`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "b624a41a29b2da10375b212d321afbabac572c6a", "filename": "src/tools/clippy/tests/ui/single_match_else.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,4 +1,6 @@\n #![warn(clippy::single_match_else)]\n+#![allow(clippy::needless_return)]\n+#![allow(clippy::no_effect)]\n \n enum ExprNode {\n     ExprAddrOf,\n@@ -30,6 +32,55 @@ macro_rules! unwrap_addr {\n     };\n }\n \n+#[rustfmt::skip]\n fn main() {\n     unwrap_addr!(ExprNode::Unicorns);\n+\n+    //\n+    // don't lint single exprs/statements\n+    //\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => return,\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return\n+        },\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return;\n+        },\n+    }\n+\n+    //\n+    // lint multiple exprs/statements \"else\" blocks\n+    //\n+\n+    // lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            println!(\"else block\");\n+            return\n+        },\n+    }\n+\n+    // lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            println!(\"else block\");\n+            return;\n+        },\n+    }\n }"}, {"sha": "3a07c2ec5426278848e9b2e5e3910ea03a01ba31", "filename": "src/tools/clippy/tests/ui/single_match_else.stderr", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,5 +1,5 @@\n error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:12:5\n+  --> $DIR/single_match_else.rs:14:5\n    |\n LL | /     match ExprNode::Butterflies {\n LL | |         ExprNode::ExprAddrOf => Some(&NODE),\n@@ -19,5 +19,45 @@ LL |         None\n LL |     }\n    |\n \n-error: aborting due to previous error\n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:70:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL |         println!(\"else block\");\n+LL |         return\n+LL |     }\n+   |\n+\n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:79:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL |         println!(\"else block\");\n+LL |         return;\n+LL |     }\n+   |\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "766190f209977fcec1a70bd9f5ae9a4ec467c603", "filename": "src/tools/clippy/tests/ui/type_repetition_in_bounds.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,4 +1,6 @@\n-#[deny(clippy::type_repetition_in_bounds)]\n+#![deny(clippy::type_repetition_in_bounds)]\n+\n+use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n \n pub fn foo<T>(_t: T)\n where\n@@ -16,4 +18,55 @@ where\n     unimplemented!();\n }\n \n+// Threshold test (see #4380)\n+trait LintBounds\n+where\n+    Self: Clone,\n+    Self: Copy + Default + Ord,\n+    Self: Add<Output = Self> + AddAssign + Sub<Output = Self> + SubAssign,\n+    Self: Mul<Output = Self> + MulAssign + Div<Output = Self> + DivAssign,\n+{\n+}\n+\n+trait LotsOfBounds\n+where\n+    Self: Clone + Copy + Default + Ord,\n+    Self: Add<Output = Self> + AddAssign + Sub<Output = Self> + SubAssign,\n+    Self: Mul<Output = Self> + MulAssign + Div<Output = Self> + DivAssign,\n+{\n+}\n+\n+// Generic distinction (see #4323)\n+mod issue4323 {\n+    pub struct Foo<A>(A);\n+    pub struct Bar<A, B> {\n+        a: Foo<A>,\n+        b: Foo<B>,\n+    }\n+\n+    impl<A, B> Unpin for Bar<A, B>\n+    where\n+        Foo<A>: Unpin,\n+        Foo<B>: Unpin,\n+    {\n+    }\n+}\n+\n+// Extern macros shouldn't lint (see #4326)\n+extern crate serde;\n+mod issue4326 {\n+    use serde::{Deserialize, Serialize};\n+\n+    trait Foo {}\n+    impl Foo for String {}\n+\n+    #[derive(Debug, Serialize, Deserialize)]\n+    struct Bar<S>\n+    where\n+        S: Foo,\n+    {\n+        foo: S,\n+    }\n+}\n+\n fn main() {}"}, {"sha": "148c19c7d0701dc2910de718d175a03122d26e03", "filename": "src/tools/clippy/tests/ui/type_repetition_in_bounds.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,15 +1,23 @@\n error: this type has already been used as a bound predicate\n-  --> $DIR/type_repetition_in_bounds.rs:6:5\n+  --> $DIR/type_repetition_in_bounds.rs:8:5\n    |\n LL |     T: Clone,\n    |     ^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/type_repetition_in_bounds.rs:1:8\n+  --> $DIR/type_repetition_in_bounds.rs:1:9\n    |\n-LL | #[deny(clippy::type_repetition_in_bounds)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(clippy::type_repetition_in_bounds)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider combining the bounds: `T: Copy + Clone`\n \n-error: aborting due to previous error\n+error: this type has already been used as a bound predicate\n+  --> $DIR/type_repetition_in_bounds.rs:25:5\n+   |\n+LL |     Self: Copy + Default + Ord,\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider combining the bounds: `Self: Clone + Copy + Default + Ord`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "2c9d4d39e6c7d9e7d18c8c7daf59fbe075b18b32", "filename": "src/tools/clippy/tests/ui/unnecessary_clone.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -13,31 +13,6 @@ impl SomeTrait for SomeImpl {}\n \n fn main() {}\n \n-fn is_ascii(ch: char) -> bool {\n-    ch.is_ascii()\n-}\n-\n-fn clone_on_copy() {\n-    42.clone();\n-\n-    vec![1].clone(); // ok, not a Copy type\n-    Some(vec![1]).clone(); // ok, not a Copy type\n-    (&42).clone();\n-\n-    let rc = RefCell::new(0);\n-    rc.borrow().clone();\n-\n-    // Issue #4348\n-    let mut x = 43;\n-    let _ = &x.clone(); // ok, getting a ref\n-    'a'.clone().make_ascii_uppercase(); // ok, clone and then mutate\n-    is_ascii('z'.clone());\n-\n-    // Issue #5436\n-    let mut vec = Vec::new();\n-    vec.push(42.clone());\n-}\n-\n fn clone_on_ref_ptr() {\n     let rc = Rc::new(true);\n     let arc = Arc::new(true);"}, {"sha": "113fab6900954c891b2610517dd728148aa3994b", "filename": "src/tools/clippy/tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 14, "deletions": 44, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -1,81 +1,51 @@\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:21:5\n-   |\n-LL |     42.clone();\n-   |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n-   |\n-   = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:25:5\n-   |\n-LL |     (&42).clone();\n-   |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:28:5\n-   |\n-LL |     rc.borrow().clone();\n-   |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:34:14\n-   |\n-LL |     is_ascii('z'.clone());\n-   |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:38:14\n-   |\n-LL |     vec.push(42.clone());\n-   |              ^^^^^^^^^^ help: try removing the `clone` call: `42`\n-\n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:48:5\n+  --> $DIR/unnecessary_clone.rs:23:5\n    |\n LL |     rc.clone();\n    |     ^^^^^^^^^^ help: try this: `Rc::<bool>::clone(&rc)`\n    |\n    = note: `-D clippy::clone-on-ref-ptr` implied by `-D warnings`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:51:5\n+  --> $DIR/unnecessary_clone.rs:26:5\n    |\n LL |     arc.clone();\n    |     ^^^^^^^^^^^ help: try this: `Arc::<bool>::clone(&arc)`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:54:5\n+  --> $DIR/unnecessary_clone.rs:29:5\n    |\n LL |     rcweak.clone();\n    |     ^^^^^^^^^^^^^^ help: try this: `Weak::<bool>::clone(&rcweak)`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:57:5\n+  --> $DIR/unnecessary_clone.rs:32:5\n    |\n LL |     arc_weak.clone();\n    |     ^^^^^^^^^^^^^^^^ help: try this: `Weak::<bool>::clone(&arc_weak)`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:61:33\n+  --> $DIR/unnecessary_clone.rs:36:33\n    |\n LL |     let _: Arc<dyn SomeTrait> = x.clone();\n    |                                 ^^^^^^^^^ help: try this: `Arc::<SomeImpl>::clone(&x)`\n \n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:65:5\n+  --> $DIR/unnecessary_clone.rs:40:5\n    |\n LL |     t.clone();\n    |     ^^^^^^^^^ help: try removing the `clone` call: `t`\n+   |\n+   = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:67:5\n+  --> $DIR/unnecessary_clone.rs:42:5\n    |\n LL |     Some(t).clone();\n    |     ^^^^^^^^^^^^^^^ help: try removing the `clone` call: `Some(t)`\n \n error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n-  --> $DIR/unnecessary_clone.rs:73:22\n+  --> $DIR/unnecessary_clone.rs:48:22\n    |\n LL |     let z: &Vec<_> = y.clone();\n    |                      ^^^^^^^^^\n@@ -91,13 +61,13 @@ LL |     let z: &Vec<_> = <&std::vec::Vec<i32>>::clone(y);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:109:20\n+  --> $DIR/unnecessary_clone.rs:84:20\n    |\n LL |         let _: E = a.clone();\n    |                    ^^^^^^^^^ help: try dereferencing it: `*****a`\n \n error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n-  --> $DIR/unnecessary_clone.rs:114:22\n+  --> $DIR/unnecessary_clone.rs:89:22\n    |\n LL |         let _ = &mut encoded.clone();\n    |                      ^^^^^^^^^^^^^^^\n@@ -112,7 +82,7 @@ LL |         let _ = &mut <&[u8]>::clone(encoded);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n-  --> $DIR/unnecessary_clone.rs:115:18\n+  --> $DIR/unnecessary_clone.rs:90:18\n    |\n LL |         let _ = &encoded.clone();\n    |                  ^^^^^^^^^^^^^^^\n@@ -126,5 +96,5 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |         let _ = &<&[u8]>::clone(encoded);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "c017d1cf9a468bc03ddc55829e277442dfe87734", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.fixed", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,11 +2,11 @@\n \n use std::cmp::Reverse;\n \n-fn id(x: isize) -> isize {\n-    x\n-}\n+fn unnecessary_sort_by() {\n+    fn id(x: isize) -> isize {\n+        x\n+    }\n \n-fn main() {\n     let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n     // Forward examples\n     vec.sort();\n@@ -24,3 +24,41 @@ fn main() {\n     vec.sort_by(|_, b| b.cmp(c));\n     vec.sort_unstable_by(|a, _| a.cmp(c));\n }\n+\n+// Should not be linted to avoid hitting https://github.com/rust-lang/rust/issues/34162\n+mod issue_5754 {\n+    struct Test(String);\n+\n+    #[derive(PartialOrd, Ord, PartialEq, Eq)]\n+    struct Wrapper<'a>(&'a str);\n+\n+    impl Test {\n+        fn name(&self) -> &str {\n+            &self.0\n+        }\n+\n+        fn wrapped(&self) -> Wrapper<'_> {\n+            Wrapper(&self.0)\n+        }\n+    }\n+\n+    pub fn test() {\n+        let mut args: Vec<Test> = vec![];\n+\n+        // Forward\n+        args.sort_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        args.sort_unstable_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_unstable_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        // Reverse\n+        args.sort_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+        args.sort_unstable_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_unstable_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+    }\n+}\n+\n+fn main() {\n+    unnecessary_sort_by();\n+    issue_5754::test();\n+}"}, {"sha": "1929c72b2f2cd3737194c2c52eba6aaa309b3380", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -2,11 +2,11 @@\n \n use std::cmp::Reverse;\n \n-fn id(x: isize) -> isize {\n-    x\n-}\n+fn unnecessary_sort_by() {\n+    fn id(x: isize) -> isize {\n+        x\n+    }\n \n-fn main() {\n     let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n     // Forward examples\n     vec.sort_by(|a, b| a.cmp(b));\n@@ -24,3 +24,41 @@ fn main() {\n     vec.sort_by(|_, b| b.cmp(c));\n     vec.sort_unstable_by(|a, _| a.cmp(c));\n }\n+\n+// Should not be linted to avoid hitting https://github.com/rust-lang/rust/issues/34162\n+mod issue_5754 {\n+    struct Test(String);\n+\n+    #[derive(PartialOrd, Ord, PartialEq, Eq)]\n+    struct Wrapper<'a>(&'a str);\n+\n+    impl Test {\n+        fn name(&self) -> &str {\n+            &self.0\n+        }\n+\n+        fn wrapped(&self) -> Wrapper<'_> {\n+            Wrapper(&self.0)\n+        }\n+    }\n+\n+    pub fn test() {\n+        let mut args: Vec<Test> = vec![];\n+\n+        // Forward\n+        args.sort_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        args.sort_unstable_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_unstable_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        // Reverse\n+        args.sort_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+        args.sort_unstable_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_unstable_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+    }\n+}\n+\n+fn main() {\n+    unnecessary_sort_by();\n+    issue_5754::test();\n+}"}, {"sha": "6bd35057bfad12f8ef301d808fc12e38db203a4c", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns3.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5414eae4521d0b6141b9db4c44be144757e5d5fb/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns3.rs?ref=5414eae4521d0b6141b9db4c44be144757e5d5fb", "patch": "@@ -0,0 +1,6 @@\n+#![warn(clippy::unnested_or_patterns)]\n+\n+// Test that `unnested_or_patterns` does not trigger without enabling `or_patterns`\n+fn main() {\n+    if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}\n+}"}]}