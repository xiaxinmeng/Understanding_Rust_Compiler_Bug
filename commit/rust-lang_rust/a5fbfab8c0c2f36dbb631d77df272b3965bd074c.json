{"sha": "a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZmJmYWI4YzBjMmYzNmRiYjYzMWQ3N2RmMjcyYjM5NjViZDA3NGM=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-10T00:13:34Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-10T13:56:48Z"}, "message": "Refactor path resolution and use Symbols instead of &str\n\nCo-authored-by: Joshua Nelson <joshua@yottadb.com>", "tree": {"sha": "d1e460743189061d9e265b4f0f9a060a1b8dfd2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1e460743189061d9e265b4f0f9a060a1b8dfd2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "html_url": "https://github.com/rust-lang/rust/commit/a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5fbfab8c0c2f36dbb631d77df272b3965bd074c/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3858c0fdddfffb4252c9b53be6373b7f3727922f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3858c0fdddfffb4252c9b53be6373b7f3727922f", "html_url": "https://github.com/rust-lang/rust/commit/3858c0fdddfffb4252c9b53be6373b7f3727922f"}], "stats": {"total": 251, "additions": 136, "deletions": 115}, "files": [{"sha": "1e07f8e2eac2455da53ffb99b76c65f86ee5fb91", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a5fbfab8c0c2f36dbb631d77df272b3965bd074c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fbfab8c0c2f36dbb631d77df272b3965bd074c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "patch": "@@ -12,6 +12,7 @@ use std::{slice, vec};\n use rustc_ast::attr;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n+use rustc_ast::{FloatTy, IntTy, UintTy};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -1279,6 +1280,28 @@ impl GetDefId for Type {\n }\n \n impl PrimitiveType {\n+    pub fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n+        match prim {\n+            hir::PrimTy::Int(IntTy::Isize) => PrimitiveType::Isize,\n+            hir::PrimTy::Int(IntTy::I8) => PrimitiveType::I8,\n+            hir::PrimTy::Int(IntTy::I16) => PrimitiveType::I16,\n+            hir::PrimTy::Int(IntTy::I32) => PrimitiveType::I32,\n+            hir::PrimTy::Int(IntTy::I64) => PrimitiveType::I64,\n+            hir::PrimTy::Int(IntTy::I128) => PrimitiveType::I128,\n+            hir::PrimTy::Uint(UintTy::Usize) => PrimitiveType::Usize,\n+            hir::PrimTy::Uint(UintTy::U8) => PrimitiveType::U8,\n+            hir::PrimTy::Uint(UintTy::U16) => PrimitiveType::U16,\n+            hir::PrimTy::Uint(UintTy::U32) => PrimitiveType::U32,\n+            hir::PrimTy::Uint(UintTy::U64) => PrimitiveType::U64,\n+            hir::PrimTy::Uint(UintTy::U128) => PrimitiveType::U128,\n+            hir::PrimTy::Float(FloatTy::F32) => PrimitiveType::F32,\n+            hir::PrimTy::Float(FloatTy::F64) => PrimitiveType::F64,\n+            hir::PrimTy::Str => PrimitiveType::Str,\n+            hir::PrimTy::Bool => PrimitiveType::Bool,\n+            hir::PrimTy::Char => PrimitiveType::Char,\n+        }\n+    }\n+\n     pub fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n         match s {\n             sym::isize => Some(PrimitiveType::Isize),"}, {"sha": "5f3048e986bf88b44e756cf0d0b3e71987a6deba", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 113, "deletions": 115, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/a5fbfab8c0c2f36dbb631d77df272b3965bd074c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fbfab8c0c2f36dbb631d77df272b3965bd074c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "patch": "@@ -16,6 +16,7 @@ use rustc_session::lint::{\n     Lint,\n };\n use rustc_span::hygiene::MacroKind;\n+use rustc_span::symbol::sym;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -234,6 +235,52 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    fn resolve_primitive_associated_item(\n+        &self,\n+        prim_ty: hir::PrimTy,\n+        prim: Res,\n+        ns: Namespace,\n+        module_id: DefId,\n+        item_name: Symbol,\n+        item_str: &'path str,\n+    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n+        let cx = self.cx;\n+\n+        PrimitiveType::from_hir(prim_ty)\n+            .impls(cx.tcx)\n+            .into_iter()\n+            .find_map(|&impl_| {\n+                cx.tcx\n+                    .associated_items(impl_)\n+                    .find_by_name_and_namespace(\n+                        cx.tcx,\n+                        Ident::with_dummy_span(item_name),\n+                        ns,\n+                        impl_,\n+                    )\n+                    .map(|item| match item.kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    })\n+                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", prim_ty.name(), out, item_str))))\n+            })\n+            .ok_or_else(|| {\n+                debug!(\n+                    \"returning primitive error for {}::{} in {} namespace\",\n+                    prim_ty.name(),\n+                    item_name,\n+                    ns.descr()\n+                );\n+                ResolutionFailure::NotResolved {\n+                    module_id,\n+                    partial_res: Some(prim),\n+                    unresolved: item_str.into(),\n+                }\n+                .into()\n+            })\n+    }\n+\n     /// Resolves a string as a macro.\n     fn macro_resolve(\n         &self,\n@@ -275,6 +322,20 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n+    fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n+        let result = self.cx.enter_resolver(|resolver| {\n+            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+        });\n+        debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n+        match result.map(|(_, res)| res) {\n+            Ok(Res::Err) | Err(()) => is_bool_value(path_str, ns).map(|(_, res)| res),\n+\n+            // resolver doesn't know about true and false so we'll have to resolve them\n+            // manually as bool\n+            Ok(res) => Some(res.map_id(|_| panic!(\"unexpected node_id\"))),\n+        }\n+    }\n+\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n@@ -287,32 +348,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n-        let result = cx.enter_resolver(|resolver| {\n-            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n-        });\n-        debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-        let result = match result.map(|(_, res)| res) {\n-            Ok(Res::Err) | Err(()) => {\n-                // resolver doesn't know about true and false so we'll have to resolve them\n-                // manually as bool\n-                if let Some((_, res)) = is_bool_value(path_str, ns) { Ok(res) } else { Err(()) }\n-            }\n-            Ok(res) => Ok(res.map_id(|_| panic!(\"unexpected node_id\"))),\n-        };\n-\n-        if let Ok(res) = result {\n+        if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => {\n-                    if ns != ValueNS {\n-                        return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n-                    }\n+                    assert_eq!(ns, ValueNS);\n                     // Fall through: In case this is a trait item, skip the\n                     // early return and try looking for the trait.\n                 }\n                 Res::Def(DefKind::AssocTy, _) => {\n-                    if ns != TypeNS {\n-                        return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n-                    }\n+                    assert_eq!(ns, TypeNS);\n                     // Fall through: In case this is a trait item, skip the\n                     // early return and try looking for the trait.\n                 }\n@@ -362,70 +406,29 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             })?;\n \n-        if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n-            let impls =\n-                primitive_impl(cx, &path).ok_or_else(|| ResolutionFailure::NotResolved {\n+        let ty_res = if let Some(ty_res) = is_primitive(&path_root, TypeNS)\n+            .map(|(_, res)| res)\n+            .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n+        {\n+            ty_res\n+        } else {\n+            // FIXME: this is duplicated on the end of this function.\n+            return if ns == Namespace::ValueNS {\n+                self.variant_field(path_str, current_item, module_id)\n+            } else {\n+                Err(ResolutionFailure::NotResolved {\n                     module_id,\n-                    partial_res: Some(prim),\n-                    unresolved: item_str.into(),\n-                })?;\n-            for &impl_ in impls {\n-                let link = cx\n-                    .tcx\n-                    .associated_items(impl_)\n-                    .find_by_name_and_namespace(\n-                        cx.tcx,\n-                        Ident::with_dummy_span(item_name),\n-                        ns,\n-                        impl_,\n-                    )\n-                    .map(|item| match item.kind {\n-                        ty::AssocKind::Fn => \"method\",\n-                        ty::AssocKind::Const => \"associatedconstant\",\n-                        ty::AssocKind::Type => \"associatedtype\",\n-                    })\n-                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_str))));\n-                if let Some(link) = link {\n-                    return Ok(link);\n+                    partial_res: None,\n+                    unresolved: path_root.into(),\n                 }\n-            }\n-            debug!(\n-                \"returning primitive error for {}::{} in {} namespace\",\n-                path,\n-                item_name,\n-                ns.descr()\n-            );\n-            return Err(ResolutionFailure::NotResolved {\n-                module_id,\n-                partial_res: Some(prim),\n-                unresolved: item_str.into(),\n-            }\n-            .into());\n-        }\n-\n-        let ty_res = cx\n-            .enter_resolver(|resolver| {\n-                // only types can have associated items\n-                resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n-            })\n-            .map(|(_, res)| res);\n-        let ty_res = match ty_res {\n-            Err(()) | Ok(Res::Err) => {\n-                return if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id)\n-                } else {\n-                    Err(ResolutionFailure::NotResolved {\n-                        module_id,\n-                        partial_res: None,\n-                        unresolved: path_root.into(),\n-                    }\n-                    .into())\n-                };\n-            }\n-            Ok(res) => res,\n+                .into())\n+            };\n         };\n-        let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+\n         let res = match ty_res {\n+            Res::PrimTy(prim) => Some(self.resolve_primitive_associated_item(\n+                prim, ty_res, ns, module_id, item_name, item_str,\n+            )),\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias, did) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name belongs to `impl SomeItem`\n@@ -465,7 +468,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     Some(if extra_fragment.is_some() {\n                         Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n                     } else {\n-                        // HACK(jynelson): `clean` expects the type, not the associated item.\n+                        // HACK(jynelson): `clean` expects the type, not the associated item\n                         // but the disambiguator logic expects the associated item.\n                         // Store the kind in a side channel so that only the disambiguator logic looks at it.\n                         self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n@@ -511,13 +514,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         _ => None,\n                     }\n                 } else {\n-                    // We already know this isn't in ValueNS, so no need to check variant_field\n-                    return Err(ResolutionFailure::NotResolved {\n-                        module_id,\n-                        partial_res: Some(ty_res),\n-                        unresolved: item_str.into(),\n-                    }\n-                    .into());\n+                    None\n                 }\n             }\n             Res::Def(DefKind::Trait, did) => cx\n@@ -1089,7 +1086,7 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                     res = prim;\n-                    fragment = Some(path.to_owned());\n+                    fragment = Some((*path.as_str()).to_owned());\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n@@ -1956,44 +1953,45 @@ fn handle_variant(\n     )\n }\n \n-const PRIMITIVES: &[(&str, Res)] = &[\n-    (\"u8\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U8))),\n-    (\"u16\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U16))),\n-    (\"u32\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U32))),\n-    (\"u64\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U64))),\n-    (\"u128\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U128))),\n-    (\"usize\", Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::Usize))),\n-    (\"i8\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I8))),\n-    (\"i16\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I16))),\n-    (\"i32\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I32))),\n-    (\"i64\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I64))),\n-    (\"i128\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I128))),\n-    (\"isize\", Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::Isize))),\n-    (\"f32\", Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F32))),\n-    (\"f64\", Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F64))),\n-    (\"str\", Res::PrimTy(hir::PrimTy::Str)),\n-    (\"bool\", Res::PrimTy(hir::PrimTy::Bool)),\n-    (\"char\", Res::PrimTy(hir::PrimTy::Char)),\n+// FIXME: At this point, this is basically a copy of the PrimitiveTypeTable\n+const PRIMITIVES: &[(Symbol, Res)] = &[\n+    (sym::u8, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U8))),\n+    (sym::u16, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U16))),\n+    (sym::u32, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U32))),\n+    (sym::u64, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U64))),\n+    (sym::u128, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U128))),\n+    (sym::usize, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::Usize))),\n+    (sym::i8, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I8))),\n+    (sym::i16, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I16))),\n+    (sym::i32, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I32))),\n+    (sym::i64, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I64))),\n+    (sym::i128, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I128))),\n+    (sym::isize, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::Isize))),\n+    (sym::f32, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F32))),\n+    (sym::f64, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F64))),\n+    (sym::str, Res::PrimTy(hir::PrimTy::Str)),\n+    (sym::bool, Res::PrimTy(hir::PrimTy::Bool)),\n+    (sym::char, Res::PrimTy(hir::PrimTy::Char)),\n ];\n \n-fn is_primitive(path_str: &str, ns: Namespace) -> Option<(&'static str, Res)> {\n+fn is_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     is_bool_value(path_str, ns).or_else(|| {\n-        if ns == TypeNS { PRIMITIVES.iter().find(|x| x.0 == path_str).copied() } else { None }\n+        if ns == TypeNS {\n+            PRIMITIVES.iter().find(|x| x.0.as_str() == path_str).copied()\n+        } else {\n+            None\n+        }\n     })\n }\n \n-fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(&'static str, Res)> {\n+fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     if ns == TypeNS && (path_str == \"true\" || path_str == \"false\") {\n-        Some((\"bool\", Res::PrimTy(hir::PrimTy::Bool)))\n+        Some((sym::bool, Res::PrimTy(hir::PrimTy::Bool)))\n     } else {\n         None\n     }\n }\n \n-fn primitive_impl(cx: &DocContext<'_>, path_str: &str) -> Option<&'static SmallVec<[DefId; 4]>> {\n-    Some(PrimitiveType::from_symbol(Symbol::intern(path_str))?.impls(cx.tcx))\n-}\n-\n fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<'static>> {\n     let mut stripped_segments = vec![];\n     let mut path = path_str.chars().peekable();"}]}