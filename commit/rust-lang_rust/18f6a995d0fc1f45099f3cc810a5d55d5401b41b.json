{"sha": "18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZjZhOTk1ZDBmYzFmNDUwOTlmM2NjODEwYTVkNTVkNTQwMWI0MWI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-05T14:10:33Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-05T16:23:09Z"}, "message": "Add expansion infrastructure for derive macros", "tree": {"sha": "808cb0f025b488f59935007802d1bb85f1cf0044", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/808cb0f025b488f59935007802d1bb85f1cf0044"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "html_url": "https://github.com/rust-lang/rust/commit/18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c0bd068da39e74c66104206e27c270454e3562e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0bd068da39e74c66104206e27c270454e3562e", "html_url": "https://github.com/rust-lang/rust/commit/4c0bd068da39e74c66104206e27c270454e3562e"}], "stats": {"total": 398, "additions": 319, "deletions": 79}, "files": [{"sha": "78a4540827a19a88affe28312d30bc9d21dd90b4", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -105,7 +105,10 @@ impl HasSource for TypeAlias {\n impl HasSource for MacroDef {\n     type Ast = ast::MacroCall;\n     fn source(self, db: &impl DefDatabase) -> InFile<ast::MacroCall> {\n-        InFile { file_id: self.id.ast_id.file_id, value: self.id.ast_id.to_node(db) }\n+        InFile {\n+            file_id: self.id.ast_id.expect(\"MacroDef without ast_id\").file_id,\n+            value: self.id.ast_id.expect(\"MacroDef without ast_id\").to_node(db),\n+        }\n     }\n }\n impl HasSource for ImplBlock {"}, {"sha": "0d3ecbc77d7a58f777adb0d29ce1905ea554dbac", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -152,9 +152,9 @@ impl FromSource for MacroDef {\n \n         let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n         let module = Module::from_definition(db, InFile::new(src.file_id, module_src))?;\n-        let krate = module.krate().crate_id();\n+        let krate = Some(module.krate().crate_id());\n \n-        let ast_id = AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value));\n+        let ast_id = Some(AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value)));\n \n         let id: MacroDefId = MacroDefId { krate, ast_id, kind };\n         Some(MacroDef { id })"}, {"sha": "42c3925135dc390f54866c2d38cc96e700b8b974", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -20,7 +20,8 @@ use hir_def::{\n     AssocItemId, DefWithBodyId,\n };\n use hir_expand::{\n-    hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroFileKind,\n+    hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n+    MacroFileKind,\n };\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -456,7 +457,7 @@ impl SourceAnalyzer {\n             db.ast_id_map(macro_call.file_id).ast_id(macro_call.value),\n         );\n         Some(Expansion {\n-            macro_call_id: def.as_call_id(db, ast_id),\n+            macro_call_id: def.as_call_id(db, MacroCallKind::FnLike(ast_id)),\n             macro_file_kind: to_macro_file_kind(macro_call.value),\n         })\n     }"}, {"sha": "2f8f02d821c83ea84728fa536f38ed67deec1ddf", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -61,7 +61,9 @@ impl Attrs {\n                 AdtId::UnionId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n             },\n             AttrDefId::TraitId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n-            AttrDefId::MacroDefId(it) => attrs_from_ast(it.ast_id, db),\n+            AttrDefId::MacroDefId(it) => {\n+                it.ast_id.map_or_else(Default::default, |ast_id| attrs_from_ast(ast_id, db))\n+            }\n             AttrDefId::ImplId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n             AttrDefId::ConstId(it) => attrs_from_loc(it.lookup(db), db),\n             AttrDefId::StaticId(it) => attrs_from_loc(it.lookup(db), db),"}, {"sha": "7b385f3fd8233380a767d31d0c5a302baecaa260", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -6,7 +6,9 @@ pub mod scope;\n use std::{ops::Index, sync::Arc};\n \n use either::Either;\n-use hir_expand::{hygiene::Hygiene, AstId, HirFileId, InFile, MacroDefId, MacroFileKind};\n+use hir_expand::{\n+    hygiene::Hygiene, AstId, HirFileId, InFile, MacroCallKind, MacroDefId, MacroFileKind,\n+};\n use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n@@ -46,7 +48,7 @@ impl Expander {\n \n         if let Some(path) = macro_call.path().and_then(|path| self.parse_path(path)) {\n             if let Some(def) = self.resolve_path_as_macro(db, &path) {\n-                let call_id = def.as_call_id(db, ast_id);\n+                let call_id = def.as_call_id(db, MacroCallKind::FnLike(ast_id));\n                 let file_id = call_id.as_file(MacroFileKind::Expr);\n                 if let Some(node) = db.parse_or_expand(file_id) {\n                     if let Some(expr) = ast::Expr::cast(node) {"}, {"sha": "61727bd26088ade362b5c0f6c055081219cce9a7", "filename": "crates/ra_hir_def/src/docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -60,7 +60,7 @@ impl Documentation {\n                 docs_from_ast(&src.value[it.local_id])\n             }\n             AttrDefId::TraitId(it) => docs_from_ast(&it.source(db).value),\n-            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id.to_node(db)),\n+            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id?.to_node(db)),\n             AttrDefId::ConstId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n             AttrDefId::StaticId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n             AttrDefId::FunctionId(it) => docs_from_ast(&it.lookup(db).source(db).value),"}, {"sha": "08693cb13a14a588ef004cb7bf0134f386f9f5f4", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -4,9 +4,10 @@\n //! resolves imports and expands macros.\n \n use hir_expand::{\n+    builtin_derive::find_builtin_derive,\n     builtin_macro::find_builtin_macro,\n     name::{self, AsName, Name},\n-    HirFileId, MacroCallId, MacroDefId, MacroDefKind, MacroFileKind,\n+    HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind, MacroFileKind,\n };\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n@@ -58,6 +59,7 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n+        unexpanded_attribute_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n         poison_macros: FxHashSet::default(),\n@@ -102,6 +104,7 @@ struct DefCollector<'a, DB> {\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n     unresolved_imports: Vec<(LocalModuleId, LocalImportId, raw::ImportData)>,\n     unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n+    unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, Path)>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n@@ -470,6 +473,8 @@ where\n \n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        let mut attribute_macros =\n+            std::mem::replace(&mut self.unexpanded_attribute_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|(module_id, ast_id, path)| {\n@@ -482,7 +487,19 @@ where\n             );\n \n             if let Some(def) = resolved_res.resolved_def.take_macros() {\n-                let call_id = def.as_call_id(self.db, *ast_id);\n+                let call_id = def.as_call_id(self.db, MacroCallKind::FnLike(*ast_id));\n+                resolved.push((*module_id, call_id, def));\n+                res = ReachedFixedPoint::No;\n+                return false;\n+            }\n+\n+            true\n+        });\n+        attribute_macros.retain(|(module_id, ast_id, path)| {\n+            let resolved_res = self.resolve_attribute_macro(path);\n+\n+            if let Some(def) = resolved_res {\n+                let call_id = def.as_call_id(self.db, MacroCallKind::Attr(*ast_id));\n                 resolved.push((*module_id, call_id, def));\n                 res = ReachedFixedPoint::No;\n                 return false;\n@@ -492,6 +509,7 @@ where\n         });\n \n         self.unexpanded_macros = macros;\n+        self.unexpanded_attribute_macros = attribute_macros;\n \n         for (module_id, macro_call_id, macro_def_id) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, macro_def_id);\n@@ -500,6 +518,20 @@ where\n         res\n     }\n \n+    fn resolve_attribute_macro(&self, path: &Path) -> Option<MacroDefId> {\n+        // FIXME this is currently super hacky, just enough to support the\n+        // built-in derives\n+        if let Some(name) = path.as_ident() {\n+            // FIXME this should actually be handled with the normal name\n+            // resolution; the std lib defines built-in stubs for the derives,\n+            // but these are new-style `macro`s, which we don't support yet\n+            if let Some(def_id) = find_builtin_derive(name) {\n+                return Some(def_id);\n+            }\n+        }\n+        None\n+    }\n+\n     fn collect_macro_expansion(\n         &mut self,\n         module_id: LocalModuleId,\n@@ -587,7 +619,9 @@ where\n                         .def_collector\n                         .unresolved_imports\n                         .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n-                    raw::RawItemKind::Def(def) => self.define_def(&self.raw_items[def]),\n+                    raw::RawItemKind::Def(def) => {\n+                        self.define_def(&self.raw_items[def], &item.attrs)\n+                    }\n                     raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n                     raw::RawItemKind::Impl(imp) => {\n                         let module = ModuleId {\n@@ -682,10 +716,16 @@ where\n         res\n     }\n \n-    fn define_def(&mut self, def: &raw::DefData) {\n+    fn define_def(&mut self, def: &raw::DefData, attrs: &Attrs) {\n         let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n \n+        // FIXME: check attrs to see if this is an attribute macro invocation;\n+        // in which case we don't add the invocation, just a single attribute\n+        // macro invocation\n+\n+        self.collect_derives(attrs, def);\n+\n         let name = def.name.clone();\n         let def: PerNs = match def.kind {\n             raw::DefKind::Function(ast_id) => {\n@@ -736,6 +776,23 @@ where\n         self.def_collector.update(self.module_id, None, &[(name, resolution)])\n     }\n \n+    fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {\n+        for derive_subtree in attrs.by_key(\"derive\").tt_values() {\n+            // for #[derive(Copy, Clone)], `derive_subtree` is the `(Copy, Clone)` subtree\n+            for tt in &derive_subtree.token_trees {\n+                let ident = match &tt {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => ident,\n+                    tt::TokenTree::Leaf(tt::Leaf::Punct(_)) => continue, // , is ok\n+                    _ => continue, // anything else would be an error (which we currently ignore)\n+                };\n+                let path = Path::from_tt_ident(ident);\n+\n+                let ast_id = AstId::new(self.file_id, def.kind.ast_id());\n+                self.def_collector.unexpanded_attribute_macros.push((self.module_id, ast_id, path));\n+            }\n+        }\n+    }\n+\n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n         let ast_id = AstId::new(self.file_id, mac.ast_id);\n \n@@ -759,8 +816,8 @@ where\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n                 let macro_id = MacroDefId {\n-                    ast_id,\n-                    krate: self.def_collector.def_map.krate,\n+                    ast_id: Some(ast_id),\n+                    krate: Some(self.def_collector.def_map.krate),\n                     kind: MacroDefKind::Declarative,\n                 };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n@@ -773,7 +830,8 @@ where\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n-            let macro_call_id = macro_def.as_call_id(self.def_collector.db, ast_id);\n+            let macro_call_id =\n+                macro_def.as_call_id(self.def_collector.db, MacroCallKind::FnLike(ast_id));\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_def);\n             return;\n@@ -829,6 +887,7 @@ mod tests {\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n+            unexpanded_attribute_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             macro_stack_monitor: monitor,\n             poison_macros: FxHashSet::default(),"}, {"sha": "a2821e1c3cbba141ee57344ee7334155a8c0b8be", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -184,6 +184,21 @@ pub(super) enum DefKind {\n     TypeAlias(FileAstId<ast::TypeAliasDef>),\n }\n \n+impl DefKind {\n+    pub fn ast_id(&self) -> FileAstId<ast::ModuleItem> {\n+        match self {\n+            DefKind::Function(it) => it.upcast(),\n+            DefKind::Struct(it) => it.upcast(),\n+            DefKind::Union(it) => it.upcast(),\n+            DefKind::Enum(it) => it.upcast(),\n+            DefKind::Const(it) => it.upcast(),\n+            DefKind::Static(it) => it.upcast(),\n+            DefKind::Trait(it) => it.upcast(),\n+            DefKind::TypeAlias(it) => it.upcast(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(super) struct Macro(RawId);\n impl_arena_id!(Macro);"}, {"sha": "cfa4ecb1afd3f4ca63afe9dbbe8549229756b353", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -600,3 +600,27 @@ fn macro_dollar_crate_is_correct_in_indirect_deps() {\n         \u22eebar: t v\n     \"###);\n }\n+\n+#[test]\n+fn expand_derive() {\n+    let map = compute_crate_def_map(\n+        \"\n+        //- /main.rs\n+        #[derive(Clone)]\n+        struct Foo;\n+        \",\n+    );\n+    assert_eq!(map.modules[map.root].impls.len(), 1);\n+}\n+\n+#[test]\n+fn expand_multiple_derive() {\n+    let map = compute_crate_def_map(\n+        \"\n+        //- /main.rs\n+        #[derive(Copy, Clone)]\n+        struct Foo;\n+        \",\n+    );\n+    assert_eq!(map.modules[map.root].impls.len(), 2);\n+}"}, {"sha": "e547b2f03cc0658aa6807eafadc4c069c469dc86", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -199,6 +199,11 @@ impl Path {\n         name_ref.as_name().into()\n     }\n \n+    /// Converts an `tt::Ident` into a single-identifier `Path`.\n+    pub(crate) fn from_tt_ident(ident: &tt::Ident) -> Path {\n+        ident.as_name().into()\n+    }\n+\n     /// `true` is this path is a single identifier, like `foo`\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1"}, {"sha": "a764bdf24e57f42ef3287928e1155caf6286eb96", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -39,6 +39,16 @@ impl<N: AstNode> Hash for FileAstId<N> {\n     }\n }\n \n+impl<N: AstNode> FileAstId<N> {\n+    // Can't make this a From implementation because of coherence\n+    pub fn upcast<M: AstNode>(self) -> FileAstId<M>\n+    where\n+        M: From<N>,\n+    {\n+        FileAstId { raw: self.raw, _ty: PhantomData }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n struct ErasedFileAstId(RawId);\n impl_arena_id!(ErasedFileAstId);\n@@ -53,7 +63,7 @@ impl AstIdMap {\n     pub(crate) fn from_source(node: &SyntaxNode) -> AstIdMap {\n         assert!(node.parent().is_none());\n         let mut res = AstIdMap { arena: Arena::default() };\n-        // By walking the tree in bread-first order we make sure that parents\n+        // By walking the tree in breadth-first order we make sure that parents\n         // get lower ids then children. That is, adding a new child does not\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching."}, {"sha": "0a70c63c0040b8c0100185d0558c45e49c33ca04", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -0,0 +1,64 @@\n+//! Builtin derives.\n+use crate::db::AstDatabase;\n+use crate::{name, MacroCallId, MacroDefId, MacroDefKind};\n+\n+use crate::quote;\n+\n+macro_rules! register_builtin {\n+    ( $(($name:ident, $kind: ident) => $expand:ident),* ) => {\n+        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+        pub enum BuiltinDeriveExpander {\n+            $($kind),*\n+        }\n+\n+        impl BuiltinDeriveExpander {\n+            pub fn expand(\n+                &self,\n+                db: &dyn AstDatabase,\n+                id: MacroCallId,\n+                tt: &tt::Subtree,\n+            ) -> Result<tt::Subtree, mbe::ExpandError> {\n+                let expander = match *self {\n+                    $( BuiltinDeriveExpander::$kind => $expand, )*\n+                };\n+                expander(db, id, tt)\n+            }\n+        }\n+\n+        pub fn find_builtin_derive(ident: &name::Name) -> Option<MacroDefId> {\n+            let kind = match ident {\n+                 $( id if id == &name::$name => BuiltinDeriveExpander::$kind, )*\n+                 _ => return None,\n+            };\n+\n+            Some(MacroDefId { krate: None, ast_id: None, kind: MacroDefKind::BuiltInDerive(kind) })\n+        }\n+    };\n+}\n+\n+register_builtin! {\n+    (COPY_TRAIT, Copy) => copy_expand,\n+    (CLONE_TRAIT, Clone) => clone_expand\n+}\n+\n+fn copy_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let expanded = quote! {\n+        impl Copy for Foo {}\n+    };\n+    Ok(expanded)\n+}\n+\n+fn clone_expand(\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let expanded = quote! {\n+        impl Clone for Foo {}\n+    };\n+    Ok(expanded)\n+}"}, {"sha": "35f99b2bc4cfca408ed3dbb006c89128ed90d4c3", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -39,7 +39,7 @@ macro_rules! register_builtin {\n                  _ => return None,\n             };\n \n-            Some(MacroDefId { krate, ast_id, kind: MacroDefKind::BuiltIn(kind) })\n+            Some(MacroDefId { krate: Some(krate), ast_id: Some(ast_id), kind: MacroDefKind::BuiltIn(kind) })\n         }\n     };\n }\n@@ -82,10 +82,9 @@ fn line_expand(\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n \n-    let arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n-    let arg_start = arg.syntax().text_range().start();\n+    let arg = loc.kind.arg(db).ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+    let arg_start = arg.text_range().start();\n \n     let file = id.as_file(MacroFileKind::Expr);\n     let line_num = to_line_number(db, file, arg_start);\n@@ -103,11 +102,10 @@ fn stringify_expand(\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n \n     let macro_content = {\n-        let arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n-        let macro_args = arg.syntax().clone();\n+        let arg = loc.kind.arg(db).ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+        let macro_args = arg.clone();\n         let text = macro_args.text();\n         let without_parens = TextUnit::of_char('(')..text.len() - TextUnit::of_char(')');\n         text.slice(without_parens).to_string()\n@@ -148,7 +146,10 @@ fn column_expand(\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n+    let macro_call = match loc.kind {\n+        crate::MacroCallKind::FnLike(ast_id) => ast_id.to_node(db),\n+        _ => panic!(\"column macro called as attr\"),\n+    };\n \n     let _arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n     let col_start = macro_call.syntax().text_range().start();\n@@ -164,15 +165,10 @@ fn column_expand(\n }\n \n fn file_expand(\n-    db: &dyn AstDatabase,\n-    id: MacroCallId,\n+    _db: &dyn AstDatabase,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n-    let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n-\n-    let _ = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n-\n     // FIXME: RA purposefully lacks knowledge of absolute file names\n     // so just return \"\".\n     let file_name = \"\";\n@@ -207,7 +203,7 @@ fn compile_error_expand(\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{test_db::TestDB, MacroCallLoc};\n+    use crate::{test_db::TestDB, MacroCallKind, MacroCallLoc};\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n \n     fn expand_builtin_macro(s: &str, expander: BuiltinFnLikeExpander) -> String {\n@@ -220,14 +216,17 @@ mod tests {\n \n         // the first one should be a macro_rules\n         let def = MacroDefId {\n-            krate: CrateId(0),\n-            ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0])),\n+            krate: Some(CrateId(0)),\n+            ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n             kind: MacroDefKind::BuiltIn(expander),\n         };\n \n         let loc = MacroCallLoc {\n             def,\n-            ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[1])),\n+            kind: MacroCallKind::FnLike(AstId::new(\n+                file_id.into(),\n+                ast_id_map.ast_id(&macro_calls[1]),\n+            )),\n         };\n \n         let id = db.intern_macro(loc);"}, {"sha": "99dabf3fbb541afcb31be264667be3b8188c3cf7", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -9,14 +9,15 @@ use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, BuiltinFnLikeExpander, HirFileId, HirFileIdRepr, MacroCallId,\n-    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, MacroFileKind,\n+    ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, HirFileId, HirFileIdRepr,\n+    MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, MacroFileKind,\n };\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum TokenExpander {\n     MacroRules(mbe::MacroRules),\n     Builtin(BuiltinFnLikeExpander),\n+    BuiltinDerive(BuiltinDeriveExpander),\n }\n \n impl TokenExpander {\n@@ -29,20 +30,23 @@ impl TokenExpander {\n         match self {\n             TokenExpander::MacroRules(it) => it.expand(tt),\n             TokenExpander::Builtin(it) => it.expand(db, id, tt),\n+            TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt),\n         }\n     }\n \n     pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n         match self {\n             TokenExpander::MacroRules(it) => it.map_id_down(id),\n             TokenExpander::Builtin(..) => id,\n+            TokenExpander::BuiltinDerive(..) => id,\n         }\n     }\n \n     pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, mbe::Origin) {\n         match self {\n             TokenExpander::MacroRules(it) => it.map_id_up(id),\n             TokenExpander::Builtin(..) => (id, mbe::Origin::Def),\n+            TokenExpander::BuiltinDerive(..) => (id, mbe::Origin::Def),\n         }\n     }\n }\n@@ -76,7 +80,7 @@ pub(crate) fn macro_def(\n ) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n     match id.kind {\n         MacroDefKind::Declarative => {\n-            let macro_call = id.ast_id.to_node(db);\n+            let macro_call = id.ast_id?.to_node(db);\n             let arg = macro_call.token_tree()?;\n             let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n                 log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n@@ -91,6 +95,10 @@ pub(crate) fn macro_def(\n         MacroDefKind::BuiltIn(expander) => {\n             Some(Arc::new((TokenExpander::Builtin(expander.clone()), mbe::TokenMap::default())))\n         }\n+        MacroDefKind::BuiltInDerive(expander) => Some(Arc::new((\n+            TokenExpander::BuiltinDerive(expander.clone()),\n+            mbe::TokenMap::default(),\n+        ))),\n     }\n }\n \n@@ -99,9 +107,8 @@ pub(crate) fn macro_arg(\n     id: MacroCallId,\n ) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n     let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, tmap) = mbe::ast_to_token_tree(&arg)?;\n+    let arg = loc.kind.arg(db)?;\n+    let (tt, tmap) = mbe::syntax_node_to_token_tree(&arg)?;\n     Some(Arc::new((tt, tmap)))\n }\n "}, {"sha": "2e8a533f70499c86190dcab3ae2fdd645fd250ec", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -25,8 +25,9 @@ impl Hygiene {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n                 match loc.def.kind {\n-                    MacroDefKind::Declarative => Some(loc.def.krate),\n+                    MacroDefKind::Declarative => loc.def.krate,\n                     MacroDefKind::BuiltIn(_) => None,\n+                    MacroDefKind::BuiltInDerive(_) => None,\n                 }\n             }\n         };"}, {"sha": "59c69b91bb23e5a66c36ca41406a65b89e0ce3f4", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -9,6 +9,7 @@ pub mod ast_id_map;\n pub mod name;\n pub mod hygiene;\n pub mod diagnostics;\n+pub mod builtin_derive;\n pub mod builtin_macro;\n pub mod quote;\n \n@@ -23,6 +24,7 @@ use ra_syntax::{\n };\n \n use crate::ast_id_map::FileAstId;\n+use crate::builtin_derive::BuiltinDeriveExpander;\n use crate::builtin_macro::BuiltinFnLikeExpander;\n \n #[cfg(test)]\n@@ -69,7 +71,7 @@ impl HirFileId {\n             HirFileIdRepr::FileId(file_id) => file_id,\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                loc.ast_id.file_id.original_file(db)\n+                loc.kind.file_id().original_file(db)\n             }\n         }\n     }\n@@ -81,17 +83,17 @@ impl HirFileId {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n \n-                let arg_tt = loc.ast_id.to_node(db).token_tree()?;\n-                let def_tt = loc.def.ast_id.to_node(db).token_tree()?;\n+                let arg_tt = loc.kind.arg(db)?;\n+                let def_tt = loc.def.ast_id?.to_node(db).token_tree()?;\n \n                 let macro_def = db.macro_def(loc.def)?;\n                 let (parse, exp_map) = db.parse_macro(macro_file)?;\n                 let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n \n                 Some(ExpansionInfo {\n                     expanded: InFile::new(self, parse.syntax_node()),\n-                    arg: InFile::new(loc.ast_id.file_id, arg_tt),\n-                    def: InFile::new(loc.ast_id.file_id, def_tt),\n+                    arg: InFile::new(loc.kind.file_id(), arg_tt),\n+                    def: InFile::new(loc.def.ast_id?.file_id, def_tt),\n                     macro_arg,\n                     macro_def,\n                     exp_map,\n@@ -129,31 +131,59 @@ impl salsa::InternKey for MacroCallId {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroDefId {\n-    pub krate: CrateId,\n-    pub ast_id: AstId<ast::MacroCall>,\n+    // FIXME: krate and ast_id are currently optional because we don't have a\n+    // definition location for built-in derives. There is one, though: the\n+    // standard library defines them. The problem is that it uses the new\n+    // `macro` syntax for this, which we don't support yet. As soon as we do\n+    // (which will probably require touching this code), we can instead use\n+    // that (and also remove the hacks for resolving built-in derives).\n+    pub krate: Option<CrateId>,\n+    pub ast_id: Option<AstId<ast::MacroCall>>,\n     pub kind: MacroDefKind,\n }\n \n impl MacroDefId {\n-    pub fn as_call_id(\n-        self,\n-        db: &dyn db::AstDatabase,\n-        ast_id: AstId<ast::MacroCall>,\n-    ) -> MacroCallId {\n-        db.intern_macro(MacroCallLoc { def: self, ast_id })\n+    pub fn as_call_id(self, db: &dyn db::AstDatabase, kind: MacroCallKind) -> MacroCallId {\n+        db.intern_macro(MacroCallLoc { def: self, kind })\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum MacroDefKind {\n     Declarative,\n     BuiltIn(BuiltinFnLikeExpander),\n+    // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n+    BuiltInDerive(BuiltinDeriveExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n     pub(crate) def: MacroDefId,\n-    pub(crate) ast_id: AstId<ast::MacroCall>,\n+    pub(crate) kind: MacroCallKind,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum MacroCallKind {\n+    FnLike(AstId<ast::MacroCall>),\n+    Attr(AstId<ast::ModuleItem>),\n+}\n+\n+impl MacroCallKind {\n+    pub fn file_id(&self) -> HirFileId {\n+        match self {\n+            MacroCallKind::FnLike(ast_id) => ast_id.file_id,\n+            MacroCallKind::Attr(ast_id) => ast_id.file_id,\n+        }\n+    }\n+\n+    pub fn arg(&self, db: &dyn db::AstDatabase) -> Option<SyntaxNode> {\n+        match self {\n+            MacroCallKind::FnLike(ast_id) => {\n+                Some(ast_id.to_node(db).token_tree()?.syntax().clone())\n+            }\n+            MacroCallKind::Attr(ast_id) => Some(ast_id.to_node(db).syntax().clone()),\n+        }\n+    }\n }\n \n impl MacroCallId {\n@@ -167,7 +197,7 @@ impl MacroCallId {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ExpansionInfo {\n     expanded: InFile<SyntaxNode>,\n-    arg: InFile<ast::TokenTree>,\n+    arg: InFile<SyntaxNode>,\n     def: InFile<ast::TokenTree>,\n \n     macro_def: Arc<(db::TokenExpander, mbe::TokenMap)>,\n@@ -178,8 +208,7 @@ pub struct ExpansionInfo {\n impl ExpansionInfo {\n     pub fn map_token_down(&self, token: InFile<&SyntaxToken>) -> Option<InFile<SyntaxToken>> {\n         assert_eq!(token.file_id, self.arg.file_id);\n-        let range =\n-            token.value.text_range().checked_sub(self.arg.value.syntax().text_range().start())?;\n+        let range = token.value.text_range().checked_sub(self.arg.value.text_range().start())?;\n         let token_id = self.macro_arg.1.token_by_range(range)?;\n         let token_id = self.macro_def.0.map_id_down(token_id);\n \n@@ -195,16 +224,15 @@ impl ExpansionInfo {\n \n         let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n         let (token_map, tt) = match origin {\n-            mbe::Origin::Call => (&self.macro_arg.1, &self.arg),\n-            mbe::Origin::Def => (&self.macro_def.1, &self.def),\n+            mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n+            mbe::Origin::Def => {\n+                (&self.macro_def.1, self.def.as_ref().map(|tt| tt.syntax().clone()))\n+            }\n         };\n \n         let range = token_map.range_by_token(token_id)?;\n-        let token = algo::find_covering_element(\n-            tt.value.syntax(),\n-            range + tt.value.syntax().text_range().start(),\n-        )\n-        .into_token()?;\n+        let token = algo::find_covering_element(&tt.value, range + tt.value.text_range().start())\n+            .into_token()?;\n         Some(tt.with_value(token))\n     }\n }"}, {"sha": "86709b5cf2628ef1c7efb624b1b23c099ec367de", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -83,6 +83,12 @@ impl AsName for ast::Name {\n     }\n }\n \n+impl AsName for tt::Ident {\n+    fn as_name(&self) -> Name {\n+        Name::resolve(&self.text)\n+    }\n+}\n+\n impl AsName for ast::FieldKind {\n     fn as_name(&self) -> Name {\n         match self {\n@@ -153,3 +159,7 @@ pub const COLUMN_MACRO: Name = Name::new_inline_ascii(6, b\"column\");\n pub const COMPILE_ERROR_MACRO: Name = Name::new_inline_ascii(13, b\"compile_error\");\n pub const LINE_MACRO: Name = Name::new_inline_ascii(4, b\"line\");\n pub const STRINGIFY_MACRO: Name = Name::new_inline_ascii(9, b\"stringify\");\n+\n+// Builtin derives\n+pub const COPY_TRAIT: Name = Name::new_inline_ascii(4, b\"Copy\");\n+pub const CLONE_TRAIT: Name = Name::new_inline_ascii(5, b\"Clone\");"}, {"sha": "0fbcb2f66407c6f76c5d46bf7969ad991d0f859a", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f6a995d0fc1f45099f3cc810a5d55d5401b41b/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=18f6a995d0fc1f45099f3cc810a5d55d5401b41b", "patch": "@@ -2,7 +2,7 @@\n \n use ra_parser::{FragmentKind, ParseError, TreeSink};\n use ra_syntax::{\n-    ast, AstNode, AstToken, NodeOrToken, Parse, SmolStr, SyntaxKind, SyntaxKind::*, SyntaxNode,\n+    ast, AstToken, NodeOrToken, Parse, SmolStr, SyntaxKind, SyntaxKind::*, SyntaxNode,\n     SyntaxTreeBuilder, TextRange, TextUnit, T,\n };\n use std::iter::successors;\n@@ -20,7 +20,7 @@ pub struct TokenMap {\n \n /// Convert the syntax tree (what user has written) to a `TokenTree` (what macro\n /// will consume).\n-pub fn ast_to_token_tree(ast: &ast::TokenTree) -> Option<(tt::Subtree, TokenMap)> {\n+pub fn ast_to_token_tree(ast: &impl ast::AstNode) -> Option<(tt::Subtree, TokenMap)> {\n     syntax_node_to_token_tree(ast.syntax())\n }\n \n@@ -208,13 +208,8 @@ impl Convertor {\n                     } else if token.kind().is_trivia() {\n                         continue;\n                     } else if token.kind().is_punct() {\n-                        assert!(\n-                            token.text().len() == 1,\n-                            \"Input ast::token punct must be single char.\"\n-                        );\n-                        let char = token.text().chars().next().unwrap();\n-\n-                        let spacing = match child_iter.peek() {\n+                        // we need to pull apart joined punctuation tokens\n+                        let last_spacing = match child_iter.peek() {\n                             Some(NodeOrToken::Token(token)) => {\n                                 if token.kind().is_punct() {\n                                     tt::Spacing::Joint\n@@ -224,8 +219,12 @@ impl Convertor {\n                             }\n                             _ => tt::Spacing::Alone,\n                         };\n-\n-                        token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n+                        let spacing_iter = std::iter::repeat(tt::Spacing::Joint)\n+                            .take(token.text().len() - 1)\n+                            .chain(std::iter::once(last_spacing));\n+                        for (char, spacing) in token.text().chars().zip(spacing_iter) {\n+                            token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n+                        }\n                     } else {\n                         let child: tt::TokenTree =\n                             if token.kind() == T![true] || token.kind() == T![false] {\n@@ -389,7 +388,10 @@ mod tests {\n     use super::*;\n     use crate::tests::{create_rules, expand};\n     use ra_parser::TokenSource;\n-    use ra_syntax::algo::{insert_children, InsertPosition};\n+    use ra_syntax::{\n+        algo::{insert_children, InsertPosition},\n+        ast::AstNode,\n+    };\n \n     #[test]\n     fn convert_tt_token_source() {\n@@ -491,4 +493,12 @@ mod tests {\n \n         assert_eq!(tt.delimiter, tt::Delimiter::Brace);\n     }\n+\n+    #[test]\n+    fn test_token_tree_multi_char_punct() {\n+        let source_file = ast::SourceFile::parse(\"struct Foo { a: x::Y }\").ok().unwrap();\n+        let struct_def = source_file.syntax().descendants().find_map(ast::StructDef::cast).unwrap();\n+        let tt = ast_to_token_tree(&struct_def).unwrap().0;\n+        token_tree_to_syntax_node(&tt, FragmentKind::Item).unwrap();\n+    }\n }"}]}