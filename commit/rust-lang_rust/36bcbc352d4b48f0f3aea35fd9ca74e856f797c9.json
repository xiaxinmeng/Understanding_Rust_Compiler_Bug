{"sha": "36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YmNiYzM1MmQ0YjQ4ZjBmM2FlYTM1ZmQ5Y2E3NGU4NTZmNzk3Yzk=", "commit": {"author": {"name": "Marcel Hellwig", "email": "git@cookiesoft.de", "date": "2019-02-25T06:09:16Z"}, "committer": {"name": "Marcel Hellwig", "email": "git@cookiesoft.de", "date": "2019-02-25T06:09:16Z"}, "message": "Add FromStr impl for NonZero types", "tree": {"sha": "bfd1a10e6d28281158933d51f8c7cb2d1b48b504", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfd1a10e6d28281158933d51f8c7cb2d1b48b504"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRSHIJXMGpVuikiTwqoW3QnLdkKoAUCXHOGmwAKCRCoW3QnLdkK\noIxoAQD2vV9ic5tDhXgh+uJ2awDLf7ATXmevwC+8Ro4CCWbhqAEAuxi1FhdhsVNO\nZj1hy4agfJCBXBggQjZicQuLZhsyVwA=\n=Ers+\n-----END PGP SIGNATURE-----", "payload": "tree bfd1a10e6d28281158933d51f8c7cb2d1b48b504\nparent 082c86175fcf72c355e6a889956fbea59e65bcdb\nauthor Marcel Hellwig <git@cookiesoft.de> 1551074956 +0100\ncommitter Marcel Hellwig <git@cookiesoft.de> 1551074956 +0100\n\nAdd FromStr impl for NonZero types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "html_url": "https://github.com/rust-lang/rust/commit/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9/comments", "author": {"login": "hellow554", "id": 921462, "node_id": "MDQ6VXNlcjkyMTQ2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/921462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hellow554", "html_url": "https://github.com/hellow554", "followers_url": "https://api.github.com/users/hellow554/followers", "following_url": "https://api.github.com/users/hellow554/following{/other_user}", "gists_url": "https://api.github.com/users/hellow554/gists{/gist_id}", "starred_url": "https://api.github.com/users/hellow554/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hellow554/subscriptions", "organizations_url": "https://api.github.com/users/hellow554/orgs", "repos_url": "https://api.github.com/users/hellow554/repos", "events_url": "https://api.github.com/users/hellow554/events{/privacy}", "received_events_url": "https://api.github.com/users/hellow554/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hellow554", "id": 921462, "node_id": "MDQ6VXNlcjkyMTQ2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/921462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hellow554", "html_url": "https://github.com/hellow554", "followers_url": "https://api.github.com/users/hellow554/followers", "following_url": "https://api.github.com/users/hellow554/following{/other_user}", "gists_url": "https://api.github.com/users/hellow554/gists{/gist_id}", "starred_url": "https://api.github.com/users/hellow554/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hellow554/subscriptions", "organizations_url": "https://api.github.com/users/hellow554/orgs", "repos_url": "https://api.github.com/users/hellow554/repos", "events_url": "https://api.github.com/users/hellow554/events{/privacy}", "received_events_url": "https://api.github.com/users/hellow554/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082c86175fcf72c355e6a889956fbea59e65bcdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/082c86175fcf72c355e6a889956fbea59e65bcdb", "html_url": "https://github.com/rust-lang/rust/commit/082c86175fcf72c355e6a889956fbea59e65bcdb"}], "stats": {"total": 123, "additions": 123, "deletions": 0}, "files": [{"sha": "1479b891fa2b68a74dc610d2066d81482e06c968", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "patch": "@@ -112,6 +112,112 @@ nonzero_integers! {\n     #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n }\n \n+/// An error which can be returned when parsing a non-zero integer.\n+///\n+/// # Potential causes\n+///\n+/// Among other causes, `ParseNonZeroIntError` can be thrown because of leading or trailing\n+/// whitespace in the string e.g., when it is obtained from the standard input.\n+/// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n+///\n+/// [`str.trim()`]: ../../std/primitive.str.html#method.trim\n+#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ParseNonZeroIntError {\n+    kind: NonZeroIntErrorKind,\n+}\n+\n+/// Enum to store the various types of errors that can cause parsing a non-zero integer to fail.\n+#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[non_exhaustive]\n+pub enum NonZeroIntErrorKind {\n+    /// Value being parsed is empty.\n+    ///\n+    /// Among other causes, this variant will be constructed when parsing an empty string.\n+    Empty,\n+    /// Contains an invalid digit.\n+    ///\n+    /// Among other causes, this variant will be constructed when parsing a string that\n+    /// contains a letter.\n+    InvalidDigit,\n+    /// Integer is too large to store in target integer type.\n+    Overflow,\n+    /// Integer is too small to store in target integer type.\n+    Underflow,\n+    /// Integer contains the value `0` which is forbidden for a non-zero integer\n+    Zero,\n+}\n+\n+#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n+impl From<ParseIntError> for ParseNonZeroIntError {\n+    fn from(p: ParseIntError) -> Self {\n+        use self::IntErrorKind as IK;\n+        use self::NonZeroIntErrorKind as NK;\n+        ParseNonZeroIntError {\n+            kind: match p.kind {\n+                IK::Empty => NK::Empty,\n+                IK::InvalidDigit => NK::InvalidDigit,\n+                IK::Overflow => NK::Overflow,\n+                IK::Underflow => NK::Underflow,\n+            },\n+        }\n+    }\n+}\n+\n+impl ParseNonZeroIntError {\n+    /// Outputs the detailed cause of parsing an integer failing.\n+    #[unstable(feature = \"int_error_matching\",\n+               reason = \"it can be useful to match errors when making error messages \\\n+                         for integer parsing\",\n+               issue = \"22639\")]\n+    pub fn kind(&self) -> &NonZeroIntErrorKind {\n+        &self.kind\n+    }\n+\n+    #[unstable(feature = \"int_error_internals\",\n+               reason = \"available through Error trait and this method should \\\n+                         not be exposed publicly\",\n+               issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            NonZeroIntErrorKind::Empty => \"cannot parse integer from empty string\",\n+            NonZeroIntErrorKind::InvalidDigit => \"invalid digit found in string\",\n+            NonZeroIntErrorKind::Overflow => \"number too large to fit in target type\",\n+            NonZeroIntErrorKind::Underflow => \"number too small to fit in target type\",\n+            NonZeroIntErrorKind::Zero => \"number is 0\",\n+        }\n+    }\n+\n+}\n+\n+#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n+impl fmt::Display for ParseNonZeroIntError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.__description().fmt(f)\n+    }\n+}\n+\n+\n+macro_rules! from_str_radix_nzint_impl {\n+    ($($t:ty)*) => {$(\n+        #[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n+        impl FromStr for $t {\n+            type Err = ParseNonZeroIntError;\n+            fn from_str(src: &str) -> Result<Self, Self::Err> {\n+                Self::new(from_str_radix(src, 10)?)\n+                    .ok_or(ParseNonZeroIntError {\n+                        kind: NonZeroIntErrorKind::Zero\n+                    })\n+            }\n+        }\n+    )*}\n+}\n+\n+from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\n+                             NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n+\n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n /// Operations like `+` on `u32` values is intended to never overflow,"}, {"sha": "6e2d4588edc71eb415a8a6752c63eb4ab236af54", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "patch": "@@ -126,3 +126,20 @@ fn test_from_signed_nonzero() {\n     let num: i32 = nz.into();\n     assert_eq!(num, 1i32);\n }\n+\n+#[test]\n+fn test_from_str() {\n+    assert_eq!(FromStr::from_str(\"123\"), Ok(NonZeroU8::new(123).unwrap()));\n+    assert_eq!(\n+        FromStr::from_str(\"0\"),\n+        Err(ParseNonZeroIntError {\n+            kind: NonZeroIntErrorKind::Zero\n+        })\n+    );\n+    assert_eq!(\n+        FromStr::from_str(\"-1\", \n+        Err(ParseNonZeroIntError {\n+            kind: NonZeroIntErrorKind::Underflow\n+        })\n+    );\n+}"}]}