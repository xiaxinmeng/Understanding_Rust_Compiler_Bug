{"sha": "b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZTIxZGJiNWNhYmRhYWFkYzQ3YTRkOGUzZjU5OTc5ZGNhZDI4NzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-07T06:24:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-07T06:24:55Z"}, "message": "Auto merge of #68499 - ssomers:btree_search_tidying, r=Mark-Simulacrum\n\nBtreeMap range_search spruced up\n\n#39457 created a lower level entry point for `range_search` to operate on, but it's really not hard to move it up a level of abstraction, making it somewhat shorter and reusing existing unsafe code (`new_edge` is unsafe although it is currently not tagged as such).\n\nBenchmark added. Comparison says there's no real difference:\n```\n>cargo benchcmp old3.txt new3.txt --threshold 5\n name                                           old3.txt ns/iter  new3.txt ns/iter  diff ns/iter   diff %  speedup\n btree::map::find_seq_100                       19                21                           2   10.53%   x 0.90\n btree::map::range_excluded_unbounded           3,117             2,838                     -279   -8.95%   x 1.10\n btree::map::range_included_unbounded           1,768             1,871                      103    5.83%   x 0.94\n btree::set::intersection_10k_neg_vs_10k_pos    35                37                           2    5.71%   x 0.95\n btree::set::intersection_staggered_100_vs_10k  2,488             2,314                     -174   -6.99%   x 1.08\n btree::set::is_subset_10k_vs_100               3                 2                           -1  -33.33%   x 1.50\n```\n\nr? @Mark-Simulacrum", "tree": {"sha": "8117b44e9ade3aef93e22ec6c53ba3b0756fa0fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8117b44e9ade3aef93e22ec6c53ba3b0756fa0fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "html_url": "https://github.com/rust-lang/rust/commit/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8fd4624474a68bd26694eff3536b9f3a127b2d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8fd4624474a68bd26694eff3536b9f3a127b2d3", "html_url": "https://github.com/rust-lang/rust/commit/f8fd4624474a68bd26694eff3536b9f3a127b2d3"}, {"sha": "ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "html_url": "https://github.com/rust-lang/rust/commit/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68"}], "stats": {"total": 143, "additions": 101, "deletions": 42}, "files": [{"sha": "83cdebf0e3f4a7d89e5c6b7e30aac80d55b65185", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n+use std::ops::Bound::{Excluded, Unbounded};\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -200,3 +201,58 @@ pub fn first_and_last_100(b: &mut Bencher) {\n pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n+\n+#[bench]\n+pub fn range_excluded_excluded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            for last in first + 1..size {\n+                black_box(map.range((Excluded(first), Excluded(last))));\n+            }\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_excluded_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            black_box(map.range((Excluded(first), Unbounded)));\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_included_included(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            for last in first..size {\n+                black_box(map.range(first..=last));\n+            }\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_included_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            black_box(map.range(first..));\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| map.range(..));\n+}"}, {"sha": "0b3f603686dc6e1e3f3ed996adf4568394a9e52b", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "patch": "@@ -1861,65 +1861,51 @@ where\n     let mut max_node = root2;\n     let mut min_found = false;\n     let mut max_found = false;\n-    let mut diverged = false;\n \n     loop {\n-        let min_edge = match (min_found, range.start_bound()) {\n-            (false, Included(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+        let front = match (min_found, range.start_bound()) {\n+            (false, Included(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => 0,\n-            (true, Included(_)) => min_node.len(),\n-            (true, Excluded(_)) => 0,\n+            (true, Included(_)) => min_node.last_edge(),\n+            (true, Excluded(_)) => min_node.first_edge(),\n+            (_, Unbounded) => min_node.first_edge(),\n         };\n \n-        let max_edge = match (max_found, range.end_bound()) {\n-            (false, Included(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+        let back = match (max_found, range.end_bound()) {\n+            (false, Included(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => max_node.len(),\n-            (true, Included(_)) => 0,\n-            (true, Excluded(_)) => max_node.len(),\n+            (true, Included(_)) => max_node.first_edge(),\n+            (true, Excluded(_)) => max_node.last_edge(),\n+            (_, Unbounded) => max_node.last_edge(),\n         };\n \n-        if !diverged {\n-            if max_edge < min_edge {\n-                panic!(\"Ord is ill-defined in BTreeMap range\")\n-            }\n-            if min_edge != max_edge {\n-                diverged = true;\n-            }\n+        if front.partial_cmp(&back) == Some(Ordering::Greater) {\n+            panic!(\"Ord is ill-defined in BTreeMap range\");\n         }\n-\n-        // Safety guarantee: `min_edge` is always in range for `min_node`, because\n-        // `min_edge` is unconditionally calculated for each iteration's value of `min_node`,\n-        // either (if not found) as the edge index returned by `search_linear`,\n-        // or (if found) as the KV index returned by `search_linear`, possibly + 1.\n-        // Likewise for `max_node` versus `max_edge`.\n-        let front = unsafe { Handle::new_edge(min_node, min_edge) };\n-        let back = unsafe { Handle::new_edge(max_node, max_edge) };\n         match (front.force(), back.force()) {\n             (Leaf(f), Leaf(b)) => {\n                 return (f, b);"}, {"sha": "abf926186e82c1d3a12e16e874623d3890c7ddce", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "patch": "@@ -31,6 +31,7 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n+use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull, Unique};\n@@ -832,6 +833,14 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     }\n }\n \n+impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n+    for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n+{\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        if self.node.node == other.node.node { Some(self.idx.cmp(&other.idx)) } else { None }\n+    }\n+}\n+\n impl<BorrowType, K, V, NodeType, HandleType>\n     Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {"}, {"sha": "2ba5cebbdee74f788da20f6f88b1092df21a24b3", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "patch": "@@ -10,6 +10,10 @@ pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n+/// Looks up a given key in a (sub)tree headed by the given node, recursively.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the possible leaf edge where the key\n+/// belongs.\n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     key: &Q,\n@@ -32,6 +36,10 @@ where\n     }\n }\n \n+/// Looks up a given key in a given node, without recursion.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the edge where the key might be found.\n+/// If the node is a leaf, a `GoDown` edge is not an actual edge but a possible edge.\n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n@@ -50,8 +58,8 @@ where\n /// or could exist, and whether it exists in the node itself. If it doesn't\n /// exist in the node itself, it may exist in the subtree with that index\n /// (if the node has subtrees). If the key doesn't exist in node or subtree,\n-/// the returned index is the position or subtree to insert at.\n-pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n+/// the returned index is the position or subtree where the key belongs.\n+fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n ) -> (usize, bool)"}]}