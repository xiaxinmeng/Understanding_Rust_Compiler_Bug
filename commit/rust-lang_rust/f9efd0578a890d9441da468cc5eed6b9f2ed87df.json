{"sha": "f9efd0578a890d9441da468cc5eed6b9f2ed87df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZWZkMDU3OGE4OTBkOTQ0MWRhNDY4Y2M1ZWVkNmI5ZjJlZDg3ZGY=", "commit": {"author": {"name": "Niv Kaminer", "email": "nivkner@zoho.com", "date": "2018-08-14T16:06:51Z"}, "committer": {"name": "Niv Kaminer", "email": "nivkner@zoho.com", "date": "2018-08-22T22:37:03Z"}, "message": "move pin module to liballoc and reexport that", "tree": {"sha": "b0e768a76e3bf18c2b6b58d0120aa97a7a418f43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0e768a76e3bf18c2b6b58d0120aa97a7a418f43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9efd0578a890d9441da468cc5eed6b9f2ed87df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9efd0578a890d9441da468cc5eed6b9f2ed87df", "html_url": "https://github.com/rust-lang/rust/commit/f9efd0578a890d9441da468cc5eed6b9f2ed87df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9efd0578a890d9441da468cc5eed6b9f2ed87df/comments", "author": {"login": "nivkner", "id": 22821514, "node_id": "MDQ6VXNlcjIyODIxNTE0", "avatar_url": "https://avatars.githubusercontent.com/u/22821514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nivkner", "html_url": "https://github.com/nivkner", "followers_url": "https://api.github.com/users/nivkner/followers", "following_url": "https://api.github.com/users/nivkner/following{/other_user}", "gists_url": "https://api.github.com/users/nivkner/gists{/gist_id}", "starred_url": "https://api.github.com/users/nivkner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nivkner/subscriptions", "organizations_url": "https://api.github.com/users/nivkner/orgs", "repos_url": "https://api.github.com/users/nivkner/repos", "events_url": "https://api.github.com/users/nivkner/events{/privacy}", "received_events_url": "https://api.github.com/users/nivkner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nivkner", "id": 22821514, "node_id": "MDQ6VXNlcjIyODIxNTE0", "avatar_url": "https://avatars.githubusercontent.com/u/22821514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nivkner", "html_url": "https://github.com/nivkner", "followers_url": "https://api.github.com/users/nivkner/followers", "following_url": "https://api.github.com/users/nivkner/following{/other_user}", "gists_url": "https://api.github.com/users/nivkner/gists{/gist_id}", "starred_url": "https://api.github.com/users/nivkner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nivkner/subscriptions", "organizations_url": "https://api.github.com/users/nivkner/orgs", "repos_url": "https://api.github.com/users/nivkner/repos", "events_url": "https://api.github.com/users/nivkner/events{/privacy}", "received_events_url": "https://api.github.com/users/nivkner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1103885feb415f82ad36f04f54d229173077a84", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1103885feb415f82ad36f04f54d229173077a84", "html_url": "https://github.com/rust-lang/rust/commit/c1103885feb415f82ad36f04f54d229173077a84"}], "stats": {"total": 181, "additions": 81, "deletions": 100}, "files": [{"sha": "0ecf4ac0a69486b6b4aac5a552a2b1ad4becc51d", "filename": "src/liballoc/pin.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f9efd0578a890d9441da468cc5eed6b9f2ed87df/src%2Fliballoc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9efd0578a890d9441da468cc5eed6b9f2ed87df/src%2Fliballoc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fpin.rs?ref=f9efd0578a890d9441da468cc5eed6b9f2ed87df", "patch": "@@ -10,17 +10,93 @@\n \n //! Types which pin data to its location in memory\n //!\n-//! see the [standard library module] for more information\n+//! It is sometimes useful to have objects that are guaranteed to not move,\n+//! in the sense that their placement in memory in consistent, and can thus be relied upon.\n //!\n-//! [standard library module]: ../../std/pin/index.html\n+//! A prime example of such a scenario would be building self-referencial structs,\n+//! since moving an object with pointers to itself will invalidate them,\n+//! which could cause undefined behavior.\n+//!\n+//! In order to prevent objects from moving, they must be *pinned*,\n+//! by wrapping the data in special pointer types, such as [`PinMut`] and [`PinBox`].\n+//! These restrict access to the underlying data to only be immutable by implementing [`Deref`],\n+//! unless the type implements the [`Unpin`] trait,\n+//! which indicates that it doesn't need these restrictions and can be safely mutated,\n+//! by implementing [`DerefMut`].\n+//!\n+//! This is done because, while modifying an object can be done in-place,\n+//! it might also relocate a buffer when its at full capacity,\n+//! or it might replace one object with another without logically \"moving\" them with [`swap`].\n+//!\n+//! [`PinMut`]: struct.PinMut.html\n+//! [`PinBox`]: struct.PinBox.html\n+//! [`Unpin`]: ../../core/marker/trait.Unpin.html\n+//! [`DerefMut`]: ../../core/ops/trait.DerefMut.html\n+//! [`Deref`]: ../../core/ops/trait.Deref.html\n+//! [`swap`]: ../../core/mem/fn.swap.html\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! #![feature(pin)]\n+//!\n+//! use std::pin::PinBox;\n+//! use std::marker::Pinned;\n+//! use std::ptr::NonNull;\n+//!\n+//! // This is a self referencial struct since the slice field points to the data field.\n+//! // We cannot inform the compiler about that with a normal reference,\n+//! // since this pattern cannot be described with the usual borrowing rules.\n+//! // Instead we use a raw pointer, though one which is known to not be null,\n+//! // since we know it's pointing at the string.\n+//! struct Unmovable {\n+//!     data: String,\n+//!     slice: NonNull<String>,\n+//!     _pin: Pinned,\n+//! }\n+//!\n+//! impl Unmovable {\n+//!     // To ensure the data doesn't move when the function returns,\n+//!     // we place it in the heap where it will stay for the lifetime of the object,\n+//!     // and the only way to access it would be through a pointer to it.\n+//!     fn new(data: String) -> PinBox<Self> {\n+//!         let res = Unmovable {\n+//!             data,\n+//!             // we only create the pointer once the data is in place\n+//!             // otherwise it will have already moved before we even started\n+//!             slice: NonNull::dangling(),\n+//!             _pin: Pinned,\n+//!         };\n+//!         let mut boxed = PinBox::new(res);\n+//!\n+//!         let slice = NonNull::from(&boxed.data);\n+//!         // we know this is safe because modifying a field doesn't move the whole struct\n+//!         unsafe { PinBox::get_mut(&mut boxed).slice = slice };\n+//!         boxed\n+//!     }\n+//! }\n+//!\n+//! let unmoved = Unmovable::new(\"hello\".to_string());\n+//! // The pointer should point to the correct location,\n+//! // so long as the struct hasn't moved.\n+//! // Meanwhile, we are free to move the pointer around.\n+//! let mut still_unmoved = unmoved;\n+//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n+//!\n+//! // Now the only way to access to data (safely) is immutably,\n+//! // so this will fail to compile:\n+//! // still_unmoved.data.push_str(\" world\");\n+//!\n+//! ```\n \n #![unstable(feature = \"pin\", issue = \"49150\")]\n \n+pub use core::pin::*;\n+\n use core::convert::From;\n use core::fmt;\n use core::future::{Future, FutureObj, LocalFutureObj, UnsafeFutureObj};\n use core::marker::{Unpin, Unsize};\n-use core::pin::PinMut;\n use core::ops::{CoerceUnsized, Deref, DerefMut};\n use core::task::{Context, Poll};\n "}, {"sha": "c60ebafd46c17e09d527d0a6396be70634817e55", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9efd0578a890d9441da468cc5eed6b9f2ed87df/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9efd0578a890d9441da468cc5eed6b9f2ed87df/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f9efd0578a890d9441da468cc5eed6b9f2ed87df", "patch": "@@ -434,6 +434,8 @@ pub use alloc_crate::borrow;\n pub use alloc_crate::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::format;\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+pub use alloc_crate::pin;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::slice;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -466,7 +468,6 @@ pub mod num;\n pub mod os;\n pub mod panic;\n pub mod path;\n-pub mod pin;\n pub mod process;\n pub mod sync;\n pub mod time;"}, {"sha": "0b78414e4bf0bde71c98d50080b2b7670d3808d4", "filename": "src/libstd/pin.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c1103885feb415f82ad36f04f54d229173077a84/src%2Flibstd%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1103885feb415f82ad36f04f54d229173077a84/src%2Flibstd%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpin.rs?ref=c1103885feb415f82ad36f04f54d229173077a84", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Types which pin data to its location in memory\n-//!\n-//! It is sometimes useful to have objects that are guaranteed to not move,\n-//! in the sense that their placement in memory in consistent, and can thus be relied upon.\n-//!\n-//! A prime example of such a scenario would be building self-referencial structs,\n-//! since moving an object with pointers to itself will invalidate them,\n-//! which could cause undefined behavior.\n-//!\n-//! In order to prevent objects from moving, they must be *pinned*,\n-//! by wrapping the data in special pointer types, such as [`PinMut`] and [`PinBox`].\n-//! These restrict access to the underlying data to only be immutable by implementing [`Deref`],\n-//! unless the type implements the [`Unpin`] trait,\n-//! which indicates that it doesn't need these restrictions and can be safely mutated,\n-//! by implementing [`DerefMut`].\n-//!\n-//! This is done because, while modifying an object can be done in-place,\n-//! it might also relocate a buffer when its at full capacity,\n-//! or it might replace one object with another without logically \"moving\" them with [`swap`].\n-//!\n-//! [`PinMut`]: struct.PinMut.html\n-//! [`PinBox`]: struct.PinBox.html\n-//! [`Unpin`]: ../marker/trait.Unpin.html\n-//! [`DerefMut`]: ../ops/trait.DerefMut.html\n-//! [`Deref`]: ../ops/trait.Deref.html\n-//! [`swap`]: ../mem/fn.swap.html\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! #![feature(pin)]\n-//!\n-//! use std::pin::PinBox;\n-//! use std::marker::Pinned;\n-//! use std::ptr::NonNull;\n-//!\n-//! // This is a self referencial struct since the slice field points to the data field.\n-//! // We cannot inform the compiler about that with a normal reference,\n-//! // since this pattern cannot be described with the usual borrowing rules.\n-//! // Instead we use a raw pointer, though one which is known to not be null,\n-//! // since we know it's pointing at the string.\n-//! struct Unmovable {\n-//!     data: String,\n-//!     slice: NonNull<String>,\n-//!     _pin: Pinned,\n-//! }\n-//!\n-//! impl Unmovable {\n-//!     // To ensure the data doesn't move when the function returns,\n-//!     // we place it in the heap where it will stay for the lifetime of the object,\n-//!     // and the only way to access it would be through a pointer to it.\n-//!     fn new(data: String) -> PinBox<Self> {\n-//!         let res = Unmovable {\n-//!             data,\n-//!             // we only create the pointer once the data is in place\n-//!             // otherwise it will have already moved before we even started\n-//!             slice: NonNull::dangling(),\n-//!             _pin: Pinned,\n-//!         };\n-//!         let mut boxed = PinBox::new(res);\n-//!\n-//!         let slice = NonNull::from(&boxed.data);\n-//!         // we know this is safe because modifying a field doesn't move the whole struct\n-//!         unsafe { PinBox::get_mut(&mut boxed).slice = slice };\n-//!         boxed\n-//!     }\n-//! }\n-//!\n-//! let unmoved = Unmovable::new(\"hello\".to_string());\n-//! // The pointer should point to the correct location,\n-//! // so long as the struct hasn't moved.\n-//! // Meanwhile, we are free to move the pointer around.\n-//! let mut still_unmoved = unmoved;\n-//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n-//!\n-//! // Now the only way to access to data (safely) is immutably,\n-//! // so this will fail to compile:\n-//! // still_unmoved.data.push_str(\" world\");\n-//!\n-//! ```\n-\n-#![unstable(feature = \"pin\", issue = \"49150\")]\n-\n-pub use core::pin::*;\n-\n-pub use alloc_crate::pin::*;"}]}