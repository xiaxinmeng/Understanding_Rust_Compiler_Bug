{"sha": "39167b97d8a62adadecc9b67caac65ec556768cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MTY3Yjk3ZDhhNjJhZGFkZWNjOWI2N2NhYWM2NWVjNTU2NzY4Y2Y=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-14T09:07:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-14T09:07:15Z"}, "message": "Merge #7260\n\n7260: Render Fn* trait objects and impl types as rust does r=matklad a=Veykril\n\nAlso fixes raw ptr impl types being rendered ambiguously with multiple predicates.\r\nThis moves out the `FamousDefs::Fixture` into its own file as well, cause I figured it is big enough to get its own file at this point + we also get highlighting this way when editing it.\r\n\r\nFixes #3012\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "f3a1c700b36ddc26bb9d189de3d03c84a93e9251", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3a1c700b36ddc26bb9d189de3d03c84a93e9251"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39167b97d8a62adadecc9b67caac65ec556768cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgAAnDCRBK7hj4Ov3rIwAAdHIIAFzkTPvfRotRzuVvAZNk9UJ1\nTTme738FzPl8j1MOfQrMaOv9ijqIFWBQHmDBb8pUdTkc8w76FcVBs7xb3IxO2NBE\n3UferQS/IOV/kKpP9PPbpZf73KZD4545YOFMwfzhvyxFXtX96K6mdf4oiohV7YOl\nk9/uIqC7RKNQkkIdY/d85r42JofvzTSNbakKQ6FIx6py0Am9l3uYFZswdKyPcdGB\npnRnwZboBA101MkYEZTrwkCOPGQgKRFItQ9bQLb/RYjTrwGyQ8g6neMQdil7RKyY\nbxjjNINjcsklCge0n7mrFNtCpbmzvxc5y3qQvLjVQbP+aCPwkHNbeyvPWrLg/4o=\n=R/Lo\n-----END PGP SIGNATURE-----\n", "payload": "tree f3a1c700b36ddc26bb9d189de3d03c84a93e9251\nparent 6835f2e37c8331ef54d4839a31df195d7dbbeee8\nparent 3d6480bc3103f7238b1b0e020518e8aa72af3156\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610615235 +0000\ncommitter GitHub <noreply@github.com> 1610615235 +0000\n\nMerge #7260\n\n7260: Render Fn* trait objects and impl types as rust does r=matklad a=Veykril\n\nAlso fixes raw ptr impl types being rendered ambiguously with multiple predicates.\r\nThis moves out the `FamousDefs::Fixture` into its own file as well, cause I figured it is big enough to get its own file at this point + we also get highlighting this way when editing it.\r\n\r\nFixes #3012\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39167b97d8a62adadecc9b67caac65ec556768cf", "html_url": "https://github.com/rust-lang/rust/commit/39167b97d8a62adadecc9b67caac65ec556768cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39167b97d8a62adadecc9b67caac65ec556768cf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6835f2e37c8331ef54d4839a31df195d7dbbeee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6835f2e37c8331ef54d4839a31df195d7dbbeee8", "html_url": "https://github.com/rust-lang/rust/commit/6835f2e37c8331ef54d4839a31df195d7dbbeee8"}, {"sha": "3d6480bc3103f7238b1b0e020518e8aa72af3156", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6480bc3103f7238b1b0e020518e8aa72af3156", "html_url": "https://github.com/rust-lang/rust/commit/3d6480bc3103f7238b1b0e020518e8aa72af3156"}], "stats": {"total": 371, "additions": 253, "deletions": 118}, "files": [{"sha": "d2f1b401481578f37912554314e42b04234a9dd4", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=39167b97d8a62adadecc9b67caac65ec556768cf", "patch": "@@ -1,14 +1,15 @@\n //! FIXME: write short doc here\n \n-use std::fmt;\n+use std::{borrow::Cow, fmt};\n \n use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDefId, FnSig, GenericPredicate,\n-    Lifetime, Obligation, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n+use arrayvec::ArrayVec;\n use hir_def::{\n-    find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n-    Lookup, ModuleId,\n+    db::DefDatabase, find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId,\n+    AssocContainerId, HasModule, Lookup, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n \n@@ -257,25 +258,45 @@ impl HirDisplay for ApplicationTy {\n                 t.hir_fmt(f)?;\n                 write!(f, \"; _]\")?;\n             }\n-            TypeCtor::RawPtr(m) => {\n+            TypeCtor::RawPtr(m) | TypeCtor::Ref(m) => {\n                 let t = self.parameters.as_single();\n+                let ty_display =\n+                    t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                write!(f, \"*{}\", m.as_keyword_for_ptr())?;\n-                if matches!(t, Ty::Dyn(predicates) if predicates.len() > 1) {\n-                    write!(f, \"(\")?;\n-                    t.hir_fmt(f)?;\n-                    write!(f, \")\")?;\n+                if matches!(self.ctor, TypeCtor::RawPtr(_)) {\n+                    write!(f, \"*{}\", m.as_keyword_for_ptr())?;\n                 } else {\n-                    t.hir_fmt(f)?;\n+                    write!(f, \"&{}\", m.as_keyword_for_ref())?;\n+                }\n+\n+                let datas;\n+                let predicates = match t {\n+                    Ty::Dyn(predicates) if predicates.len() > 1 => {\n+                        Cow::Borrowed(predicates.as_ref())\n+                    }\n+                    &Ty::Opaque(OpaqueTy {\n+                        opaque_ty_id: OpaqueTyId::ReturnTypeImplTrait(func, idx),\n+                        ref parameters,\n+                    }) => {\n+                        datas =\n+                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data = (*datas)\n+                            .as_ref()\n+                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        let bounds = data.subst(parameters);\n+                        Cow::Owned(bounds.value)\n+                    }\n+                    _ => Cow::Borrowed(&[][..]),\n+                };\n+\n+                if let [GenericPredicate::Implemented(trait_ref), _] = predicates.as_ref() {\n+                    let trait_ = trait_ref.trait_;\n+                    if fn_traits(f.db.upcast(), trait_).any(|it| it == trait_) {\n+                        return write!(f, \"{}\", ty_display);\n+                    }\n                 }\n-            }\n-            TypeCtor::Ref(m) => {\n-                let t = self.parameters.as_single();\n-                let ty_display =\n-                    t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                write!(f, \"&{}\", m.as_keyword_for_ref())?;\n-                if matches!(t, Ty::Dyn(predicates) if predicates.len() > 1) {\n+                if predicates.len() > 1 {\n                     write!(f, \"(\")?;\n                     write!(f, \"{}\", ty_display)?;\n                     write!(f, \")\")?;\n@@ -595,6 +616,17 @@ impl HirDisplay for FnSig {\n     }\n }\n \n+fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = TraitId> {\n+    let krate = trait_.lookup(db).container.module(db).krate;\n+    let fn_traits = [\n+        db.lang_item(krate, \"fn\".into()),\n+        db.lang_item(krate, \"fn_mut\".into()),\n+        db.lang_item(krate, \"fn_once\".into()),\n+    ];\n+    // FIXME: Replace ArrayVec when into_iter is a thing on arrays\n+    ArrayVec::from(fn_traits).into_iter().flatten().flat_map(|it| it.as_trait())\n+}\n+\n pub fn write_bounds_like_dyn_trait(\n     predicates: &[GenericPredicate],\n     f: &mut HirFormatter,\n@@ -607,10 +639,15 @@ pub fn write_bounds_like_dyn_trait(\n     // predicate for that trait).\n     let mut first = true;\n     let mut angle_open = false;\n+    let mut is_fn_trait = false;\n     for p in predicates.iter() {\n         match p {\n             GenericPredicate::Implemented(trait_ref) => {\n-                if angle_open {\n+                let trait_ = trait_ref.trait_;\n+                if !is_fn_trait {\n+                    is_fn_trait = fn_traits(f.db.upcast(), trait_).any(|it| it == trait_);\n+                }\n+                if !is_fn_trait && angle_open {\n                     write!(f, \">\")?;\n                     angle_open = false;\n                 }\n@@ -620,14 +657,27 @@ pub fn write_bounds_like_dyn_trait(\n                 // We assume that the self type is $0 (i.e. the\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n-                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name)?;\n-                if trait_ref.substs.len() > 1 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                    // there might be assoc type bindings, so we leave the angle brackets open\n-                    angle_open = true;\n+                write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+                if let [_, params @ ..] = &*trait_ref.substs.0 {\n+                    if is_fn_trait {\n+                        if let Some(args) = params.first().and_then(|it| it.as_tuple()) {\n+                            write!(f, \"(\")?;\n+                            f.write_joined(&*args.0, \", \")?;\n+                            write!(f, \")\")?;\n+                        }\n+                    } else if !params.is_empty() {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(params, \", \")?;\n+                        // there might be assoc type bindings, so we leave the angle brackets open\n+                        angle_open = true;\n+                    }\n                 }\n             }\n+            GenericPredicate::Projection(projection_pred) if is_fn_trait => {\n+                is_fn_trait = false;\n+                write!(f, \" -> \")?;\n+                projection_pred.ty.hir_fmt(f)?;\n+            }\n             GenericPredicate::Projection(projection_pred) => {\n                 // in types in actual Rust, these will always come\n                 // after the corresponding Implemented predicate"}, {"sha": "3d29021aaf115129266eedc9c5ac65960e373e40", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=39167b97d8a62adadecc9b67caac65ec556768cf", "patch": "@@ -39,3 +39,18 @@ fn main() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn render_raw_ptr_impl_ty() {\n+    check_types_source_code(\n+        r#\"\n+trait Sized {}\n+trait Unpin {}\n+fn foo() -> *const (impl Unpin + Sized) { loop {} }\n+fn main() {\n+    let foo = foo();\n+    foo;\n+}   //^ *const (impl Unpin + Sized)\n+\"#,\n+    );\n+}"}, {"sha": "e5a3f95a6c1de1999dbdcd3dbcffd4d23f8f18b2", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=39167b97d8a62adadecc9b67caac65ec556768cf", "patch": "@@ -3038,16 +3038,16 @@ fn infer_box_fn_arg() {\n             406..417 '&self.inner': &*mut T\n             407..411 'self': &Box<T>\n             407..417 'self.inner': *mut T\n-            478..575 '{     ...(&s) }': FnOnce::Output<dyn FnOnce<(&Option<i32>,)>, (&Option<i32>,)>\n+            478..575 '{     ...(&s) }': FnOnce::Output<dyn FnOnce(&Option<i32>), (&Option<i32>,)>\n             488..489 's': Option<i32>\n             492..504 'Option::None': Option<i32>\n-            514..515 'f': Box<dyn FnOnce<(&Option<i32>,)>>\n+            514..515 'f': Box<dyn FnOnce(&Option<i32>)>\n             549..562 'box (|ps| {})': Box<|{unknown}| -> ()>\n             554..561 '|ps| {}': |{unknown}| -> ()\n             555..557 'ps': {unknown}\n             559..561 '{}': ()\n-            568..569 'f': Box<dyn FnOnce<(&Option<i32>,)>>\n-            568..573 'f(&s)': FnOnce::Output<dyn FnOnce<(&Option<i32>,)>, (&Option<i32>,)>\n+            568..569 'f': Box<dyn FnOnce(&Option<i32>)>\n+            568..573 'f(&s)': FnOnce::Output<dyn FnOnce(&Option<i32>), (&Option<i32>,)>\n             570..572 '&s': &Option<i32>\n             571..572 's': Option<i32>\n         \"#]],"}, {"sha": "a2039fcc73cd6fd08b6dd1da737f3765475125d4", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=39167b97d8a62adadecc9b67caac65ec556768cf", "patch": "@@ -1398,6 +1398,43 @@ fn main() {\n     Foo::bar(&Foo);\n            //^^^^ self\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn fn_hints() {\n+        check(\n+            r#\"\n+trait Sized {}\n+\n+fn foo() -> impl Fn() { loop {} }\n+fn foo1() -> impl Fn(f64) { loop {} }\n+fn foo2() -> impl Fn(f64, f64) { loop {} }\n+fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n+fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n+fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n+fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n+fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo();\n+     // ^^^ impl Fn()\n+    let foo = foo1();\n+     // ^^^ impl Fn(f64)\n+    let foo = foo2();\n+     // ^^^ impl Fn(f64, f64)\n+    let foo = foo3();\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo4();\n+     // ^^^ &dyn Fn(f64, f64) -> u32\n+    let foo = foo5();\n+     // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n+    let foo = foo6();\n+     // ^^^ impl Fn(f64, f64) -> u32 + Sized\n+    let foo = foo7();\n+     // ^^^ *const (impl Fn(f64, f64) -> u32 + Sized)\n+}\n \"#,\n         )\n     }"}, {"sha": "c6763ae369e57e41957e1ef6a967f4f4be247d05", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 88, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=39167b97d8a62adadecc9b67caac65ec556768cf", "patch": "@@ -38,94 +38,7 @@ pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Option<Cr\n \n #[allow(non_snake_case)]\n impl FamousDefs<'_, '_> {\n-    pub const FIXTURE: &'static str = r#\"//- /libcore.rs crate:core\n-pub mod convert {\n-    pub trait From<T> {\n-        fn from(t: T) -> Self;\n-    }\n-}\n-\n-pub mod default {\n-    pub trait Default {\n-       fn default() -> Self;\n-    }\n-}\n-\n-pub mod iter {\n-    pub use self::traits::{collect::IntoIterator, iterator::Iterator};\n-    mod traits {\n-        pub(crate) mod iterator {\n-            use crate::option::Option;\n-            pub trait Iterator {\n-                type Item;\n-                fn next(&mut self) -> Option<Self::Item>;\n-                fn by_ref(&mut self) -> &mut Self {\n-                    self\n-                }\n-                fn take(self, n: usize) -> crate::iter::Take<Self> {\n-                    crate::iter::Take { inner: self }\n-                }\n-            }\n-\n-            impl<I: Iterator> Iterator for &mut I {\n-                type Item = I::Item;\n-                fn next(&mut self) -> Option<I::Item> {\n-                    (**self).next()\n-                }\n-            }\n-        }\n-        pub(crate) mod collect {\n-            pub trait IntoIterator {\n-                type Item;\n-            }\n-        }\n-    }\n-\n-    pub use self::sources::*;\n-    pub(crate) mod sources {\n-        use super::Iterator;\n-        use crate::option::Option::{self, *};\n-        pub struct Repeat<A> {\n-            element: A,\n-        }\n-\n-        pub fn repeat<T>(elt: T) -> Repeat<T> {\n-            Repeat { element: elt }\n-        }\n-\n-        impl<A> Iterator for Repeat<A> {\n-            type Item = A;\n-\n-            fn next(&mut self) -> Option<A> {\n-                None\n-            }\n-        }\n-    }\n-\n-    pub use self::adapters::*;\n-    pub(crate) mod adapters {\n-        use super::Iterator;\n-        use crate::option::Option::{self, *};\n-        pub struct Take<I> { pub(crate) inner: I }\n-        impl<I> Iterator for Take<I> where I: Iterator {\n-            type Item = <I as Iterator>::Item;\n-            fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-pub mod option {\n-    pub enum Option<T> { None, Some(T)}\n-}\n-\n-pub mod prelude {\n-    pub use crate::{convert::From, iter::{IntoIterator, Iterator}, option::Option::{self, *}, default::Default};\n-}\n-#[prelude_import]\n-pub use prelude::*;\n-\"#;\n+    pub const FIXTURE: &'static str = include_str!(\"helpers/famous_defs_fixture.rs\");\n \n     pub fn core(&self) -> Option<Crate> {\n         self.find_crate(\"core\")"}, {"sha": "5e88de64dbfd99fc3ad3748967f1281a06a973ff", "filename": "crates/ide_db/src/helpers/famous_defs_fixture.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs_fixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39167b97d8a62adadecc9b67caac65ec556768cf/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs_fixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs_fixture.rs?ref=39167b97d8a62adadecc9b67caac65ec556768cf", "patch": "@@ -0,0 +1,120 @@\n+//- /libcore.rs crate:core\n+//! Signatures of traits, types and functions from the core lib for use in tests.\n+pub mod convert {\n+    pub trait From<T> {\n+        fn from(t: T) -> Self;\n+    }\n+}\n+\n+pub mod default {\n+    pub trait Default {\n+        fn default() -> Self;\n+    }\n+}\n+\n+pub mod iter {\n+    pub use self::traits::{collect::IntoIterator, iterator::Iterator};\n+    mod traits {\n+        pub(crate) mod iterator {\n+            use crate::option::Option;\n+            pub trait Iterator {\n+                type Item;\n+                fn next(&mut self) -> Option<Self::Item>;\n+                fn by_ref(&mut self) -> &mut Self {\n+                    self\n+                }\n+                fn take(self, n: usize) -> crate::iter::Take<Self> {\n+                    crate::iter::Take { inner: self }\n+                }\n+            }\n+\n+            impl<I: Iterator> Iterator for &mut I {\n+                type Item = I::Item;\n+                fn next(&mut self) -> Option<I::Item> {\n+                    (**self).next()\n+                }\n+            }\n+        }\n+        pub(crate) mod collect {\n+            pub trait IntoIterator {\n+                type Item;\n+            }\n+        }\n+    }\n+\n+    pub use self::sources::*;\n+    pub(crate) mod sources {\n+        use super::Iterator;\n+        use crate::option::Option::{self, *};\n+        pub struct Repeat<A> {\n+            element: A,\n+        }\n+\n+        pub fn repeat<T>(elt: T) -> Repeat<T> {\n+            Repeat { element: elt }\n+        }\n+\n+        impl<A> Iterator for Repeat<A> {\n+            type Item = A;\n+\n+            fn next(&mut self) -> Option<A> {\n+                None\n+            }\n+        }\n+    }\n+\n+    pub use self::adapters::*;\n+    pub(crate) mod adapters {\n+        use super::Iterator;\n+        use crate::option::Option::{self, *};\n+        pub struct Take<I> {\n+            pub(crate) inner: I,\n+        }\n+        impl<I> Iterator for Take<I>\n+        where\n+            I: Iterator,\n+        {\n+            type Item = <I as Iterator>::Item;\n+            fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+pub mod ops {\n+    #[lang = \"fn\"]\n+    pub trait Fn<Args>: FnMut<Args> {\n+        extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+    }\n+\n+    #[lang = \"fn_mut\"]\n+    pub trait FnMut<Args>: FnOnce<Args> {\n+        extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+    }\n+    #[lang = \"fn_once\"]\n+    pub trait FnOnce<Args> {\n+        #[lang = \"fn_once_output\"]\n+        type Output;\n+        extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+    }\n+}\n+\n+pub mod option {\n+    pub enum Option<T> {\n+        None,\n+        Some(T),\n+    }\n+}\n+\n+pub mod prelude {\n+    pub use crate::{\n+        convert::From,\n+        default::Default,\n+        iter::{IntoIterator, Iterator},\n+        ops::{Fn, FnMut, FnOnce},\n+        option::Option::{self, *},\n+    };\n+}\n+#[prelude_import]\n+pub use prelude::*;"}, {"sha": "6abad189adfadb1d4df6013606aaedfa9bf41c25", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39167b97d8a62adadecc9b67caac65ec556768cf/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39167b97d8a62adadecc9b67caac65ec556768cf/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=39167b97d8a62adadecc9b67caac65ec556768cf", "patch": "@@ -324,7 +324,7 @@ impl TidyDocs {\n         }\n \n         fn is_exclude_file(d: &Path) -> bool {\n-            let file_names = [\"tests.rs\"];\n+            let file_names = [\"tests.rs\", \"famous_defs_fixture.rs\"];\n \n             d.file_name()\n                 .unwrap_or_default()"}]}