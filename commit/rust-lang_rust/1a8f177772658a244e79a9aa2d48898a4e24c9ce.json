{"sha": "1a8f177772658a244e79a9aa2d48898a4e24c9ce", "node_id": "C_kwDOAAsO6NoAKDFhOGYxNzc3NzI2NThhMjQ0ZTc5YTlhYTJkNDg4OThhNGUyNGM5Y2U", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-10T15:21:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-11T05:04:52Z"}, "message": "rustc_hir: Less error-prone methods for accessing `PartialRes` resolution", "tree": {"sha": "aa829f9272204646daf41265ed1a19a6bdd9bdbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa829f9272204646daf41265ed1a19a6bdd9bdbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a8f177772658a244e79a9aa2d48898a4e24c9ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8f177772658a244e79a9aa2d48898a4e24c9ce", "html_url": "https://github.com/rust-lang/rust/commit/1a8f177772658a244e79a9aa2d48898a4e24c9ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a8f177772658a244e79a9aa2d48898a4e24c9ce/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "518263d889818d16a09a8260f212f8ff4bf345f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/518263d889818d16a09a8260f212f8ff4bf345f1", "html_url": "https://github.com/rust-lang/rust/commit/518263d889818d16a09a8260f212f8ff4bf345f1"}], "stats": {"total": 165, "additions": 75, "deletions": 90}, "files": [{"sha": "54c83fb760460c62dc2bcfabce2345bc6b7abbab", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -205,13 +205,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         let static_def_id = self\n                             .resolver\n                             .get_partial_res(sym.id)\n-                            .filter(|res| res.unresolved_segments() == 0)\n-                            .and_then(|res| {\n-                                if let Res::Def(DefKind::Static(_), def_id) = res.base_res() {\n-                                    Some(def_id)\n-                                } else {\n-                                    None\n-                                }\n+                            .and_then(|res| res.full_res())\n+                            .and_then(|res| match res {\n+                                Res::Def(DefKind::Static(_), def_id) => Some(def_id),\n+                                _ => None,\n                             });\n \n                         if let Some(def_id) = static_def_id {"}, {"sha": "c55b4906302004c9d4c42998d5b2935cc164ba78", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -1044,9 +1044,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         if let ExprKind::Path(qself, path) = &expr.kind {\n             // Does the path resolve to something disallowed in a tuple struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n-                if partial_res.unresolved_segments() == 0\n-                    && !partial_res.base_res().expected_in_tuple_struct_pat()\n-                {\n+                if let Some(res) = partial_res.full_res() && !res.expected_in_tuple_struct_pat() {\n                     return None;\n                 }\n             }\n@@ -1066,9 +1064,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         if let ExprKind::Path(qself, path) = &expr.kind {\n             // Does the path resolve to something disallowed in a unit struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n-                if partial_res.unresolved_segments() == 0\n-                    && !partial_res.base_res().expected_in_unit_struct_pat()\n-                {\n+                if let Some(res) = partial_res.full_res() && !res.expected_in_unit_struct_pat() {\n                     return None;\n                 }\n             }"}, {"sha": "687d810ed4e31e99d156971aa05e085e2583f189", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -947,7 +947,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 AssocItemKind::MacCall(..) => unimplemented!(),\n             },\n-            trait_item_def_id: self.resolver.get_partial_res(i.id).map(|r| r.base_res().def_id()),\n+            trait_item_def_id: self\n+                .resolver\n+                .get_partial_res(i.id)\n+                .map(|r| r.expect_full_res().def_id()),\n         }\n     }\n \n@@ -1349,9 +1352,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 match self\n                     .resolver\n                     .get_partial_res(bound_pred.bounded_ty.id)\n-                    .map(|d| (d.base_res(), d.unresolved_segments()))\n+                    .and_then(|r| r.full_res())\n                 {\n-                    Some((Res::Def(DefKind::TyParam, def_id), 0))\n+                    Some(Res::Def(DefKind::TyParam, def_id))\n                         if bound_pred.bound_generic_params.is_empty() =>\n                     {\n                         generics"}, {"sha": "ce5893efa926d4651383bd38f07267020f84f23b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -175,12 +175,7 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n                 return None;\n             }\n \n-            let partial_res = self.partial_res_map.get(&expr.id)?;\n-            if partial_res.unresolved_segments() != 0 {\n-                return None;\n-            }\n-\n-            if let Res::Def(DefKind::Fn, def_id) = partial_res.base_res() {\n+            if let Res::Def(DefKind::Fn, def_id) = self.partial_res_map.get(&expr.id)?.full_res()? {\n                 // We only support cross-crate argument rewriting. Uses\n                 // within the same crate should be updated to use the new\n                 // const generics style.\n@@ -753,12 +748,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn expect_full_res(&mut self, id: NodeId) -> Res<NodeId> {\n-        self.resolver.get_partial_res(id).map_or(Res::Err, |pr| {\n-            if pr.unresolved_segments() != 0 {\n-                panic!(\"path not fully resolved: {:?}\", pr);\n-            }\n-            pr.base_res()\n-        })\n+        self.resolver.get_partial_res(id).map_or(Res::Err, |pr| pr.expect_full_res())\n     }\n \n     fn expect_full_res_from_use(&mut self, id: NodeId) -> impl Iterator<Item = Res<NodeId>> {\n@@ -1138,8 +1128,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // type and value namespaces. If we resolved the path in the value namespace, we\n                     // transform it into a generic const argument.\n                     TyKind::Path(ref qself, ref path) => {\n-                        if let Some(partial_res) = self.resolver.get_partial_res(ty.id) {\n-                            let res = partial_res.base_res();\n+                        if let Some(res) = self\n+                            .resolver\n+                            .get_partial_res(ty.id)\n+                            .and_then(|partial_res| partial_res.full_res())\n+                        {\n                             if !res.matches_ns(Namespace::TypeNS) {\n                                 debug!(\n                                     \"lower_generic_arg: Lowering type argument as const argument: {:?}\",\n@@ -1206,8 +1199,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // by `ty_path`.\n         if qself.is_none()\n             && let Some(partial_res) = self.resolver.get_partial_res(t.id)\n-            && partial_res.unresolved_segments() == 0\n-            && let Res::Def(DefKind::Trait | DefKind::TraitAlias, _) = partial_res.base_res()\n+            && let Some(Res::Def(DefKind::Trait | DefKind::TraitAlias, _)) = partial_res.full_res()\n         {\n             let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n                 let poly_trait_ref = this.ast_arena.ptr.alloc(PolyTraitRef {"}, {"sha": "1af1633b5244badd53899e8002d189de5a4bfda3", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ident: Ident,\n         lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n     ) -> hir::PatKind<'hir> {\n-        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.expect_full_res()) {\n             // `None` can occur in body-less function signatures\n             res @ (None | Some(Res::Local(_))) => {\n                 let canonical_id = match res {"}, {"sha": "888776cccac2d0c752f7f68717a94c2825664f8a", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -29,11 +29,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let partial_res =\n             self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n+        let base_res = partial_res.base_res();\n+        let unresolved_segments = partial_res.unresolved_segments();\n \n         let path_span_lo = p.span.shrink_to_lo();\n-        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n+        let proj_start = p.segments.len() - unresolved_segments;\n         let path = self.arena.alloc(hir::Path {\n-            res: self.lower_res(partial_res.base_res()),\n+            res: self.lower_res(base_res),\n             segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n                 |(i, segment)| {\n                     let param_mode = match (qself_position, param_mode) {\n@@ -46,7 +48,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         _ => param_mode,\n                     };\n \n-                    let parenthesized_generic_args = match partial_res.base_res() {\n+                    let parenthesized_generic_args = match base_res {\n                         // `a::b::Trait(Args)`\n                         Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n                             ParenthesizedGenericArgs::Ok\n@@ -83,7 +85,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // Simple case, either no projections, or only fully-qualified.\n         // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if partial_res.unresolved_segments() == 0 {\n+        if unresolved_segments == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n "}, {"sha": "4ef4aad902c68ebc824b0a37d8e21ffecd19adcb", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -464,6 +464,16 @@ impl PartialRes {\n     pub fn unresolved_segments(&self) -> usize {\n         self.unresolved_segments\n     }\n+\n+    #[inline]\n+    pub fn full_res(&self) -> Option<Res<NodeId>> {\n+        (self.unresolved_segments == 0).then_some(self.base_res)\n+    }\n+\n+    #[inline]\n+    pub fn expect_full_res(&self) -> Res<NodeId> {\n+        self.full_res().expect(\"unexpected unresolved segments\")\n+    }\n }\n \n /// Different kinds of symbols can coexist even if they share the same textual name."}, {"sha": "a17793ecd99bd795f57e15ee5befe3404e210e4c", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     }\n                     PathResult::Module(..) => Err(VisResolutionError::ModuleOnly(path.span)),\n                     PathResult::NonModule(partial_res) => {\n-                        expected_found_error(partial_res.base_res())\n+                        expected_found_error(partial_res.expect_full_res())\n                     }\n                     PathResult::Failed { span, label, suggestion, .. } => {\n                         Err(VisResolutionError::FailedToResolve(span, label, suggestion))"}, {"sha": "4ccc9db1bb64e27c4ddc4e7d130fbb159a4acf48", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -642,8 +642,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 // Check whether we should interpret this as a bare trait object.\n                 if qself.is_none()\n                     && let Some(partial_res) = self.r.partial_res_map.get(&ty.id)\n-                    && partial_res.unresolved_segments() == 0\n-                    && let Res::Def(DefKind::Trait | DefKind::TraitAlias, _) = partial_res.base_res()\n+                    && let Some(Res::Def(DefKind::Trait | DefKind::TraitAlias, _)) = partial_res.full_res()\n                 {\n                     // This path is actually a bare trait object.  In case of a bare `Fn`-trait\n                     // object with anonymous lifetimes, we need this rib to correctly place the\n@@ -1930,7 +1929,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 match ty.kind {\n                     TyKind::ImplicitSelf => true,\n                     TyKind::Path(None, _) => {\n-                        let path_res = self.r.partial_res_map[&ty.id].base_res();\n+                        let path_res = self.r.partial_res_map[&ty.id].expect_full_res();\n                         if let Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } = path_res {\n                             return true;\n                         }\n@@ -1971,7 +1970,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     None\n                 }\n             })\n-            .map(|res| res.base_res())\n+            .map(|res| res.expect_full_res())\n             .filter(|res| {\n                 // Permit the types that unambiguously always\n                 // result in the same type constructor being used\n@@ -2531,7 +2530,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 Finalize::new(trait_ref.ref_id, trait_ref.path.span),\n             );\n             self.diagnostic_metadata.currently_processing_impl_trait = None;\n-            if let Some(def_id) = res.base_res().opt_def_id() {\n+            if let Some(def_id) = res.expect_full_res().opt_def_id() {\n                 new_id = Some(def_id);\n                 new_val = Some((self.r.expect_module(def_id), trait_ref.clone()));\n             }\n@@ -2860,7 +2859,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn is_base_res_local(&self, nid: NodeId) -> bool {\n-        matches!(self.r.partial_res_map.get(&nid).map(|res| res.base_res()), Some(Res::Local(..)))\n+        matches!(\n+            self.r.partial_res_map.get(&nid).map(|res| res.expect_full_res()),\n+            Some(Res::Local(..))\n+        )\n     }\n \n     /// Checks that all of the arms in an or-pattern have exactly the\n@@ -3347,12 +3349,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             source.defer_to_typeck(),\n             finalize,\n         ) {\n-            Ok(Some(partial_res)) if partial_res.unresolved_segments() == 0 => {\n-                if source.is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err\n-                {\n+            Ok(Some(partial_res)) if let Some(res) = partial_res.full_res() => {\n+                if source.is_expected(res) || res == Res::Err {\n                     partial_res\n                 } else {\n-                    report_errors(self, Some(partial_res.base_res()))\n+                    report_errors(self, Some(res))\n                 }\n             }\n \n@@ -3560,20 +3561,21 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         };\n \n         if path.len() > 1\n-            && result.base_res() != Res::Err\n+            && let Some(res) = result.full_res()\n+            && res != Res::Err\n             && path[0].ident.name != kw::PathRoot\n             && path[0].ident.name != kw::DollarCrate\n         {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n-                    PathResult::NonModule(path_res) => path_res.base_res(),\n+                    PathResult::NonModule(path_res) => path_res.expect_full_res(),\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         module.res().unwrap()\n                     }\n                     _ => return Ok(Some(result)),\n                 }\n             };\n-            if result.base_res() == unqualified_result {\n+            if res == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n                 self.r.lint_buffer.buffer_lint(\n                     lint,"}, {"sha": "13cd7987e923d62de35706f6037b76325fcf681c", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -968,11 +968,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             let Some(partial_res) = self.r.partial_res_map.get(&bounded_ty.id) else {\n                 return false;\n             };\n-            if !(matches!(\n-                partial_res.base_res(),\n-                hir::def::Res::Def(hir::def::DefKind::AssocTy, _)\n-            ) && partial_res.unresolved_segments() == 0)\n-            {\n+            if !matches!(\n+                partial_res.full_res(),\n+                Some(hir::def::Res::Def(hir::def::DefKind::AssocTy, _))\n+            ) {\n                 return false;\n             }\n             (ty, position, path)\n@@ -986,11 +985,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             let Some(partial_res) = self.r.partial_res_map.get(&peeled_ty.id) else {\n                 return false;\n             };\n-            if !(matches!(\n-                partial_res.base_res(),\n-                hir::def::Res::Def(hir::def::DefKind::TyParam, _)\n-            ) && partial_res.unresolved_segments() == 0)\n-            {\n+            if !matches!(\n+                partial_res.full_res(),\n+                Some(hir::def::Res::Def(hir::def::DefKind::TyParam, _))\n+            ) {\n                 return false;\n             }\n             if let (\n@@ -1518,20 +1516,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.r.partial_res_map.get(&node_id) {\n-                    match resolution.base_res() {\n-                        Res::Def(DefKind::Struct | DefKind::Union, did)\n-                            if resolution.unresolved_segments() == 0 =>\n-                        {\n-                            if let Some(field_names) = self.r.field_names.get(&did) {\n-                                if field_names\n-                                    .iter()\n-                                    .any(|&field_name| ident.name == field_name.node)\n-                                {\n-                                    return Some(AssocSuggestion::Field);\n-                                }\n+                    if let Some(Res::Def(DefKind::Struct | DefKind::Union, did)) =\n+                        resolution.full_res()\n+                    {\n+                        if let Some(field_names) = self.r.field_names.get(&did) {\n+                            if field_names.iter().any(|&field_name| ident.name == field_name.node) {\n+                                return Some(AssocSuggestion::Field);\n                             }\n                         }\n-                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "bf94172612343531232b8edf5efe413596683f61", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -1882,12 +1882,10 @@ impl<'a> Resolver<'a> {\n \n         match self.maybe_resolve_path(&segments, Some(ns), &parent_scope) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n-            PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n-                Some(path_res.base_res())\n+            PathResult::NonModule(path_res) => path_res.full_res(),\n+            PathResult::Module(ModuleOrUniformRoot::ExternPrelude) | PathResult::Failed { .. } => {\n+                None\n             }\n-            PathResult::Module(ModuleOrUniformRoot::ExternPrelude)\n-            | PathResult::NonModule(..)\n-            | PathResult::Failed { .. } => None,\n             PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n         }\n     }\n@@ -1938,12 +1936,8 @@ impl<'a> Resolver<'a> {\n                 return None;\n             }\n \n-            let partial_res = self.partial_res_map.get(&expr.id)?;\n-            if partial_res.unresolved_segments() != 0 {\n-                return None;\n-            }\n-\n-            if let Res::Def(def::DefKind::Fn, def_id) = partial_res.base_res() {\n+            let res = self.partial_res_map.get(&expr.id)?.full_res()?;\n+            if let Res::Def(def::DefKind::Fn, def_id) = res {\n                 // We only support cross-crate argument rewriting. Uses\n                 // within the same crate should be updated to use the new\n                 // const generics style."}, {"sha": "f6f0b3c11391b2024df4f80de372a8abd2e51ef9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f177772658a244e79a9aa2d48898a4e24c9ce/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=1a8f177772658a244e79a9aa2d48898a4e24c9ce", "patch": "@@ -590,9 +590,7 @@ impl<'a> Resolver<'a> {\n \n         let res = if path.len() > 1 {\n             let res = match self.maybe_resolve_path(&path, Some(MacroNS), parent_scope) {\n-                PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n-                    Ok(path_res.base_res())\n-                }\n+                PathResult::NonModule(path_res) if let Some(res) = path_res.full_res() => Ok(res),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n                 PathResult::NonModule(..)\n                 | PathResult::Indeterminate\n@@ -692,9 +690,8 @@ impl<'a> Resolver<'a> {\n                 Some(Finalize::new(ast::CRATE_NODE_ID, path_span)),\n                 None,\n             ) {\n-                PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n-                    let res = path_res.base_res();\n-                    check_consistency(self, &path, path_span, kind, initial_res, res);\n+                PathResult::NonModule(path_res) if let Some(res) = path_res.full_res() => {\n+                    check_consistency(self, &path, path_span, kind, initial_res, res)\n                 }\n                 path_res @ PathResult::NonModule(..) | path_res @ PathResult::Failed { .. } => {\n                     let (span, label) = if let PathResult::Failed { span, label, .. } = path_res {"}]}