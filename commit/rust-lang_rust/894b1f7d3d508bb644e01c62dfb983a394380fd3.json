{"sha": "894b1f7d3d508bb644e01c62dfb983a394380fd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NGIxZjdkM2Q1MDhiYjY0NGUwMWM2MmRmYjk4M2EzOTQzODBmZDM=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-11-13T14:49:17Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-11-13T14:49:17Z"}, "message": "extract closures into a separate trait", "tree": {"sha": "49f46cd578a2ed0ead9cf8ffdc02a27ccfb9c65b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49f46cd578a2ed0ead9cf8ffdc02a27ccfb9c65b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/894b1f7d3d508bb644e01c62dfb983a394380fd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/894b1f7d3d508bb644e01c62dfb983a394380fd3", "html_url": "https://github.com/rust-lang/rust/commit/894b1f7d3d508bb644e01c62dfb983a394380fd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/894b1f7d3d508bb644e01c62dfb983a394380fd3/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c4df6bb343e89c382ae2301505013132af77319", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4df6bb343e89c382ae2301505013132af77319", "html_url": "https://github.com/rust-lang/rust/commit/2c4df6bb343e89c382ae2301505013132af77319"}], "stats": {"total": 470, "additions": 292, "deletions": 178}, "files": [{"sha": "301ede66006de64970547151f0429ef5cc6f54f7", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=894b1f7d3d508bb644e01c62dfb983a394380fd3", "patch": "@@ -1,12 +1,13 @@\n use crate::astconv::{\n-    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n+    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    GenericArgCountResult, GenericArgPosition,\n };\n use crate::errors::AssocTypeBindingNotAllowed;\n use rustc_ast::ast::ParamKindOrd;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{GenericArg, GenericArgs};\n+use rustc_hir::GenericArg;\n use rustc_middle::ty::{\n     self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, Ty, TyCtxt,\n };\n@@ -90,20 +91,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///   instantiate a `GenericArg`.\n     /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n     ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'b>(\n+    pub fn create_substs_for_generic_args<'a>(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n         arg_count: GenericArgCountResult,\n-        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n-        mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n-        mut inferred_kind: impl FnMut(\n-            Option<&[subst::GenericArg<'tcx>]>,\n-            &GenericParamDef,\n-            bool,\n-        ) -> subst::GenericArg<'tcx>,\n+        ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n     ) -> SubstsRef<'tcx> {\n         // Collect the segments of the path; we need to substitute arguments\n         // for parameters throughout the entire path (wherever there are\n@@ -142,7 +137,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             substs.push(\n                                 self_ty\n                                     .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| inferred_kind(None, param, true)),\n+                                    .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n                             );\n                             params.next();\n                         }\n@@ -151,7 +146,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n \n             // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = args_for_def_id(def_id);\n+            let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n \n             let mut args =\n                 generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n@@ -173,7 +168,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n                             | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n                             | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n-                                substs.push(provided_kind(param, arg));\n+                                substs.push(ctx.provided_kind(param, arg));\n                                 args.next();\n                                 params.next();\n                             }\n@@ -184,7 +179,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             ) => {\n                                 // We expected a lifetime argument, but got a type or const\n                                 // argument. That means we're inferring the lifetimes.\n-                                substs.push(inferred_kind(None, param, infer_args));\n+                                substs.push(ctx.inferred_kind(None, param, infer_args));\n                                 force_infer_lt = Some(arg);\n                                 params.next();\n                             }\n@@ -302,7 +297,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     (None, Some(&param)) => {\n                         // If there are fewer arguments than parameters, it means\n                         // we're inferring the remaining arguments.\n-                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n+                        substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n                         params.next();\n                     }\n "}, {"sha": "89c5adfa14c670a0c9e1749af59203518186de4f", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 143, "deletions": 81, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=894b1f7d3d508bb644e01c62dfb983a394380fd3", "patch": "@@ -165,6 +165,23 @@ pub struct GenericArgCountResult {\n     pub correct: Result<(), GenericArgCountMismatch>,\n }\n \n+pub trait CreateSubstsForGenericArgsCtxt<'a, 'tcx> {\n+    fn args_for_def_id(&mut self, def_id: DefId) -> (Option<&'a GenericArgs<'a>>, bool);\n+\n+    fn provided_kind(\n+        &mut self,\n+        param: &ty::GenericParamDef,\n+        arg: &GenericArg<'_>,\n+    ) -> subst::GenericArg<'tcx>;\n+\n+    fn inferred_kind(\n+        &mut self,\n+        substs: Option<&[subst::GenericArg<'tcx>]>,\n+        param: &ty::GenericParamDef,\n+        infer_args: bool,\n+    ) -> subst::GenericArg<'tcx>;\n+}\n+\n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(\n         &self,\n@@ -321,81 +338,102 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         let is_object = self_ty.map_or(false, |ty| ty == self.tcx().types.trait_object_dummy_self);\n-        let default_needs_object_self = |param: &ty::GenericParamDef| {\n-            if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default {\n-                    let default_ty = tcx.at(span).type_of(param.def_id);\n-                    let self_param = tcx.types.self_param;\n-                    if default_ty.walk().any(|arg| arg == self_param.into()) {\n-                        // There is no suitable inference default for a type parameter\n-                        // that references self, in an object type.\n-                        return true;\n+\n+        struct SubstsForAstPathCtxt<'a, 'tcx> {\n+            astconv: &'a (dyn AstConv<'tcx> + 'a),\n+            def_id: DefId,\n+            generic_args: &'a GenericArgs<'a>,\n+            span: Span,\n+            missing_type_params: Vec<String>,\n+            inferred_params: Vec<Span>,\n+            infer_args: bool,\n+            is_object: bool,\n+        }\n+\n+        impl<'tcx, 'a> SubstsForAstPathCtxt<'tcx, 'a> {\n+            fn default_needs_object_self(&mut self, param: &ty::GenericParamDef) -> bool {\n+                let tcx = self.astconv.tcx();\n+                if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n+                    if self.is_object && has_default {\n+                        let default_ty = tcx.at(self.span).type_of(param.def_id);\n+                        let self_param = tcx.types.self_param;\n+                        if default_ty.walk().any(|arg| arg == self_param.into()) {\n+                            // There is no suitable inference default for a type parameter\n+                            // that references self, in an object type.\n+                            return true;\n+                        }\n                     }\n                 }\n-            }\n \n-            false\n-        };\n+                false\n+            }\n+        }\n \n-        let mut missing_type_params = vec![];\n-        let mut inferred_params = vec![];\n-        let substs = Self::create_substs_for_generic_args(\n-            tcx,\n-            def_id,\n-            parent_substs,\n-            self_ty.is_some(),\n-            self_ty,\n-            arg_count.clone(),\n-            // Provide the generic args, and whether types should be inferred.\n-            |did| {\n-                if did == def_id {\n-                    (Some(generic_args), infer_args)\n+        impl<'a, 'tcx> CreateSubstsForGenericArgsCtxt<'a, 'tcx> for SubstsForAstPathCtxt<'a, 'tcx> {\n+            fn args_for_def_id(&mut self, did: DefId) -> (Option<&'a GenericArgs<'a>>, bool) {\n+                if did == self.def_id {\n+                    (Some(self.generic_args), self.infer_args)\n                 } else {\n                     // The last component of this tuple is unimportant.\n                     (None, false)\n                 }\n-            },\n-            // Provide substitutions for parameters for which (valid) arguments have been provided.\n-            |param, arg| match (&param.kind, arg) {\n-                (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                    self.ast_region_to_region(&lt, Some(param)).into()\n-                }\n-                (GenericParamDefKind::Type { has_default, .. }, GenericArg::Type(ty)) => {\n-                    if *has_default {\n-                        tcx.check_optional_stability(\n-                            param.def_id,\n-                            Some(arg.id()),\n-                            arg.span(),\n-                            |_, _| {\n-                                // Default generic parameters may not be marked\n-                                // with stability attributes, i.e. when the\n-                                // default parameter was defined at the same time\n-                                // as the rest of the type. As such, we ignore missing\n-                                // stability attributes.\n+            }\n+\n+            fn provided_kind(\n+                &mut self,\n+                param: &ty::GenericParamDef,\n+                arg: &GenericArg<'_>,\n+            ) -> subst::GenericArg<'tcx> {\n+                let tcx = self.astconv.tcx();\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        self.astconv.ast_region_to_region(&lt, Some(param)).into()\n+                    }\n+                    (&GenericParamDefKind::Type { has_default, .. }, GenericArg::Type(ty)) => {\n+                        if has_default {\n+                            tcx.check_optional_stability(\n+                                param.def_id,\n+                                Some(arg.id()),\n+                                arg.span(),\n+                                |_, _| {\n+                                    // Default generic parameters may not be marked\n+                                    // with stability attributes, i.e. when the\n+                                    // default parameter was defined at the same time\n+                                    // as the rest of the type. As such, we ignore missing\n+                                    // stability attributes.\n+                                },\n+                            )\n+                        }\n+                        if let (hir::TyKind::Infer, false) =\n+                            (&ty.kind, self.astconv.allow_ty_infer())\n+                        {\n+                            self.inferred_params.push(ty.span);\n+                            tcx.ty_error().into()\n+                        } else {\n+                            self.astconv.ast_ty_to_ty(&ty).into()\n+                        }\n+                    }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        ty::Const::from_opt_const_arg_anon_const(\n+                            tcx,\n+                            ty::WithOptConstParam {\n+                                did: tcx.hir().local_def_id(ct.value.hir_id),\n+                                const_param_did: Some(param.def_id),\n                             },\n                         )\n+                        .into()\n                     }\n-                    if let (hir::TyKind::Infer, false) = (&ty.kind, self.allow_ty_infer()) {\n-                        inferred_params.push(ty.span);\n-                        tcx.ty_error().into()\n-                    } else {\n-                        self.ast_ty_to_ty(&ty).into()\n-                    }\n-                }\n-                (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    ty::Const::from_opt_const_arg_anon_const(\n-                        tcx,\n-                        ty::WithOptConstParam {\n-                            did: tcx.hir().local_def_id(ct.value.hir_id),\n-                            const_param_did: Some(param.def_id),\n-                        },\n-                    )\n-                    .into()\n+                    _ => unreachable!(),\n                 }\n-                _ => unreachable!(),\n-            },\n-            // Provide substitutions for parameters for which arguments are inferred.\n-            |substs, param, infer_args| {\n+            }\n+\n+            fn inferred_kind(\n+                &mut self,\n+                substs: Option<&[subst::GenericArg<'tcx>]>,\n+                param: &ty::GenericParamDef,\n+                infer_args: bool,\n+            ) -> subst::GenericArg<'tcx> {\n+                let tcx = self.astconv.tcx();\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n                     GenericParamDefKind::Type { has_default, .. } => {\n@@ -407,48 +445,72 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             // other type parameters may reference `Self` in their\n                             // defaults. This will lead to an ICE if we are not\n                             // careful!\n-                            if default_needs_object_self(param) {\n-                                missing_type_params.push(param.name.to_string());\n+                            if self.default_needs_object_self(param) {\n+                                self.missing_type_params.push(param.name.to_string());\n                                 tcx.ty_error().into()\n                             } else {\n                                 // This is a default type parameter.\n-                                self.normalize_ty(\n-                                    span,\n-                                    tcx.at(span).type_of(param.def_id).subst_spanned(\n-                                        tcx,\n-                                        substs.unwrap(),\n-                                        Some(span),\n-                                    ),\n-                                )\n-                                .into()\n+                                self.astconv\n+                                    .normalize_ty(\n+                                        self.span,\n+                                        tcx.at(self.span).type_of(param.def_id).subst_spanned(\n+                                            tcx,\n+                                            substs.unwrap(),\n+                                            Some(self.span),\n+                                        ),\n+                                    )\n+                                    .into()\n                             }\n                         } else if infer_args {\n                             // No type parameters were provided, we can infer all.\n-                            let param =\n-                                if !default_needs_object_self(param) { Some(param) } else { None };\n-                            self.ty_infer(param, span).into()\n+                            let param = if !self.default_needs_object_self(param) {\n+                                Some(param)\n+                            } else {\n+                                None\n+                            };\n+                            self.astconv.ty_infer(param, self.span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n                             tcx.ty_error().into()\n                         }\n                     }\n                     GenericParamDefKind::Const => {\n-                        let ty = tcx.at(span).type_of(param.def_id);\n+                        let ty = tcx.at(self.span).type_of(param.def_id);\n                         // FIXME(const_generics:defaults)\n                         if infer_args {\n                             // No const parameters were provided, we can infer all.\n-                            self.ct_infer(ty, Some(param), span).into()\n+                            self.astconv.ct_infer(ty, Some(param), self.span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n                             tcx.const_error(ty).into()\n                         }\n                     }\n                 }\n-            },\n+            }\n+        }\n+\n+        let mut substs_ctx = SubstsForAstPathCtxt {\n+            astconv: self,\n+            def_id,\n+            span,\n+            generic_args,\n+            missing_type_params: vec![],\n+            inferred_params: vec![],\n+            infer_args,\n+            is_object,\n+        };\n+        let substs = Self::create_substs_for_generic_args(\n+            tcx,\n+            def_id,\n+            parent_substs,\n+            self_ty.is_some(),\n+            self_ty,\n+            arg_count.clone(),\n+            &mut substs_ctx,\n         );\n \n         self.complain_about_missing_type_params(\n-            missing_type_params,\n+            substs_ctx.missing_type_params,\n             def_id,\n             span,\n             generic_args.args.is_empty(),"}, {"sha": "300ee8f85f8dd39c327a913de1016b87646ad197", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 90, "deletions": 57, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=894b1f7d3d508bb644e01c62dfb983a394380fd3", "patch": "@@ -1,5 +1,6 @@\n use crate::astconv::{\n-    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n+    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    GenericArgCountResult, PathSeg,\n };\n use crate::check::callee::{self, DeferredCallResolution};\n use crate::check::method::{self, MethodCallee, SelfSource};\n@@ -1298,76 +1299,108 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n \n-        let substs = self_ctor_substs.unwrap_or_else(|| {\n-            AstConv::create_substs_for_generic_args(\n-                tcx,\n-                def_id,\n-                &[][..],\n-                has_self,\n-                self_ty,\n-                arg_count,\n-                // Provide the generic args, and whether types should be inferred.\n-                |def_id| {\n-                    if let Some(&PathSeg(_, index)) =\n-                        path_segs.iter().find(|&PathSeg(did, _)| *did == def_id)\n-                    {\n-                        // If we've encountered an `impl Trait`-related error, we're just\n-                        // going to infer the arguments for better error messages.\n-                        if !infer_args_for_err.contains(&index) {\n-                            // Check whether the user has provided generic arguments.\n-                            if let Some(ref data) = segments[index].args {\n-                                return (Some(data), segments[index].infer_args);\n-                            }\n+        struct CreateCtorSubstsContext<'a, 'tcx> {\n+            fcx: &'a FnCtxt<'a, 'tcx>,\n+            span: Span,\n+            path_segs: &'a [PathSeg],\n+            infer_args_for_err: &'a FxHashSet<usize>,\n+            segments: &'a [hir::PathSegment<'a>],\n+        }\n+        impl<'tcx, 'a> CreateSubstsForGenericArgsCtxt<'a, 'tcx> for CreateCtorSubstsContext<'a, 'tcx> {\n+            fn args_for_def_id(\n+                &mut self,\n+                def_id: DefId,\n+            ) -> (Option<&'a hir::GenericArgs<'a>>, bool) {\n+                if let Some(&PathSeg(_, index)) =\n+                    self.path_segs.iter().find(|&PathSeg(did, _)| *did == def_id)\n+                {\n+                    // If we've encountered an `impl Trait`-related error, we're just\n+                    // going to infer the arguments for better error messages.\n+                    if !self.infer_args_for_err.contains(&index) {\n+                        // Check whether the user has provided generic arguments.\n+                        if let Some(ref data) = self.segments[index].args {\n+                            return (Some(data), self.segments[index].infer_args);\n                         }\n-                        return (None, segments[index].infer_args);\n                     }\n+                    return (None, self.segments[index].infer_args);\n+                }\n \n-                    (None, true)\n-                },\n-                // Provide substitutions for parameters for which (valid) arguments have been provided.\n-                |param, arg| match (&param.kind, arg) {\n+                (None, true)\n+            }\n+\n+            fn provided_kind(\n+                &mut self,\n+                param: &ty::GenericParamDef,\n+                arg: &GenericArg<'_>,\n+            ) -> subst::GenericArg<'tcx> {\n+                match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        AstConv::ast_region_to_region(self, lt, Some(param)).into()\n+                        AstConv::ast_region_to_region(self.fcx, lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.to_ty(ty).into()\n+                        self.fcx.to_ty(ty).into()\n                     }\n                     (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                        self.const_arg_to_const(&ct.value, param.def_id).into()\n+                        self.fcx.const_arg_to_const(&ct.value, param.def_id).into()\n                     }\n                     _ => unreachable!(),\n-                },\n-                // Provide substitutions for parameters for which arguments are inferred.\n-                |substs, param, infer_args| {\n-                    match param.kind {\n-                        GenericParamDefKind::Lifetime => {\n-                            self.re_infer(Some(param), span).unwrap().into()\n-                        }\n-                        GenericParamDefKind::Type { has_default, .. } => {\n-                            if !infer_args && has_default {\n-                                // If we have a default, then we it doesn't matter that we're not\n-                                // inferring the type arguments: we provide the default where any\n-                                // is missing.\n-                                let default = tcx.type_of(param.def_id);\n-                                self.normalize_ty(\n-                                    span,\n-                                    default.subst_spanned(tcx, substs.unwrap(), Some(span)),\n+                }\n+            }\n+\n+            fn inferred_kind(\n+                &mut self,\n+                substs: Option<&[subst::GenericArg<'tcx>]>,\n+                param: &ty::GenericParamDef,\n+                infer_args: bool,\n+            ) -> subst::GenericArg<'tcx> {\n+                let tcx = self.fcx.tcx();\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        self.fcx.re_infer(Some(param), self.span).unwrap().into()\n+                    }\n+                    GenericParamDefKind::Type { has_default, .. } => {\n+                        if !infer_args && has_default {\n+                            // If we have a default, then we it doesn't matter that we're not\n+                            // inferring the type arguments: we provide the default where any\n+                            // is missing.\n+                            let default = tcx.type_of(param.def_id);\n+                            self.fcx\n+                                .normalize_ty(\n+                                    self.span,\n+                                    default.subst_spanned(tcx, substs.unwrap(), Some(self.span)),\n                                 )\n                                 .into()\n-                            } else {\n-                                // If no type arguments were provided, we have to infer them.\n-                                // This case also occurs as a result of some malformed input, e.g.\n-                                // a lifetime argument being given instead of a type parameter.\n-                                // Using inference instead of `Error` gives better error messages.\n-                                self.var_for_def(span, param)\n-                            }\n-                        }\n-                        GenericParamDefKind::Const => {\n-                            // FIXME(const_generics:defaults)\n-                            // No const parameters were provided, we have to infer them.\n-                            self.var_for_def(span, param)\n+                        } else {\n+                            // If no type arguments were provided, we have to infer them.\n+                            // This case also occurs as a result of some malformed input, e.g.\n+                            // a lifetime argument being given instead of a type parameter.\n+                            // Using inference instead of `Error` gives better error messages.\n+                            self.fcx.var_for_def(self.span, param)\n                         }\n                     }\n+                    GenericParamDefKind::Const => {\n+                        // FIXME(const_generics:defaults)\n+                        // No const parameters were provided, we have to infer them.\n+                        self.fcx.var_for_def(self.span, param)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let substs = self_ctor_substs.unwrap_or_else(|| {\n+            AstConv::create_substs_for_generic_args(\n+                tcx,\n+                def_id,\n+                &[][..],\n+                has_self,\n+                self_ty,\n+                arg_count,\n+                &mut CreateCtorSubstsContext {\n+                    fcx: self,\n+                    span,\n+                    path_segs: &path_segs,\n+                    infer_args_for_err: &infer_args_for_err,\n+                    segments,\n                 },\n             )\n         });"}, {"sha": "fb048abc0e9cd9f74645669761a9dc7318c92894", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894b1f7d3d508bb644e01c62dfb983a394380fd3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=894b1f7d3d508bb644e01c62dfb983a394380fd3", "patch": "@@ -1,6 +1,6 @@\n use super::{probe, MethodCallee};\n \n-use crate::astconv::AstConv;\n+use crate::astconv::{AstConv, CreateSubstsForGenericArgsCtxt};\n use crate::check::{callee, FnCtxt};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n@@ -10,7 +10,7 @@ use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::subst::{self, Subst, SubstsRef};\n use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n@@ -307,36 +307,60 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // parameters from the type and those from the method.\n         assert_eq!(generics.parent_count, parent_substs.len());\n \n+        struct MethodSubstsCtxt<'a, 'tcx> {\n+            cfcx: &'a ConfirmContext<'a, 'tcx>,\n+            pick: &'a probe::Pick<'tcx>,\n+            seg: &'a hir::PathSegment<'a>,\n+        }\n+        impl<'a, 'tcx> CreateSubstsForGenericArgsCtxt<'a, 'tcx> for MethodSubstsCtxt<'a, 'tcx> {\n+            fn args_for_def_id(\n+                &mut self,\n+                def_id: DefId,\n+            ) -> (Option<&'a hir::GenericArgs<'a>>, bool) {\n+                if def_id == self.pick.item.def_id {\n+                    if let Some(ref data) = self.seg.args {\n+                        return (Some(data), false);\n+                    }\n+                }\n+                (None, false)\n+            }\n+\n+            fn provided_kind(\n+                &mut self,\n+                param: &ty::GenericParamDef,\n+                arg: &GenericArg<'_>,\n+            ) -> subst::GenericArg<'tcx> {\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        AstConv::ast_region_to_region(self.cfcx.fcx, lt, Some(param)).into()\n+                    }\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n+                        self.cfcx.to_ty(ty).into()\n+                    }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        self.cfcx.const_arg_to_const(&ct.value, param.def_id).into()\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+\n+            fn inferred_kind(\n+                &mut self,\n+                _substs: Option<&[subst::GenericArg<'tcx>]>,\n+                param: &ty::GenericParamDef,\n+                _infer_args: bool,\n+            ) -> subst::GenericArg<'tcx> {\n+                self.cfcx.var_for_def(self.cfcx.span, param)\n+            }\n+        }\n         AstConv::create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,\n             false,\n             None,\n             arg_count_correct,\n-            // Provide the generic args, and whether types should be inferred.\n-            |def_id| {\n-                // The last component of the returned tuple here is unimportant.\n-                if def_id == pick.item.def_id {\n-                    if let Some(ref data) = seg.args {\n-                        return (Some(data), false);\n-                    }\n-                }\n-                (None, false)\n-            },\n-            // Provide substitutions for parameters for which (valid) arguments have been provided.\n-            |param, arg| match (&param.kind, arg) {\n-                (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                    AstConv::ast_region_to_region(self.fcx, lt, Some(param)).into()\n-                }\n-                (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => self.to_ty(ty).into(),\n-                (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    self.const_arg_to_const(&ct.value, param.def_id).into()\n-                }\n-                _ => unreachable!(),\n-            },\n-            // Provide substitutions for parameters for which arguments are inferred.\n-            |_, param, _| self.var_for_def(self.span, param),\n+            &mut MethodSubstsCtxt { cfcx: self, pick, seg },\n         )\n     }\n "}]}