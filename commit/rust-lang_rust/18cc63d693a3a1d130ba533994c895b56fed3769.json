{"sha": "18cc63d693a3a1d130ba533994c895b56fed3769", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Y2M2M2Q2OTNhM2ExZDEzMGJhNTMzOTk0Yzg5NWI1NmZlZDM3Njk=", "commit": {"author": {"name": "Julian Wollersberger", "email": "24991778+Julian-Wollersberger@users.noreply.github.com", "date": "2020-05-13T07:52:01Z"}, "committer": {"name": "Julian Wollersberger", "email": "24991778+Julian-Wollersberger@users.noreply.github.com", "date": "2020-05-13T07:52:01Z"}, "message": "Unified `validate_{byte,str,raw_str,raw_byte_str}_escape` methods into one method `validate_literal_escape` with a mode argument.\nThis enables simplifying the `match` in `cook_lexer_literal()`\nand it eliminates 90 lines of repetition :)", "tree": {"sha": "f98e9b155f0c9469db3cd14c629a348aaa3be813", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f98e9b155f0c9469db3cd14c629a348aaa3be813"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18cc63d693a3a1d130ba533994c895b56fed3769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18cc63d693a3a1d130ba533994c895b56fed3769", "html_url": "https://github.com/rust-lang/rust/commit/18cc63d693a3a1d130ba533994c895b56fed3769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18cc63d693a3a1d130ba533994c895b56fed3769/comments", "author": {"login": "Julian-Wollersberger", "id": 24991778, "node_id": "MDQ6VXNlcjI0OTkxNzc4", "avatar_url": "https://avatars.githubusercontent.com/u/24991778?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Julian-Wollersberger", "html_url": "https://github.com/Julian-Wollersberger", "followers_url": "https://api.github.com/users/Julian-Wollersberger/followers", "following_url": "https://api.github.com/users/Julian-Wollersberger/following{/other_user}", "gists_url": "https://api.github.com/users/Julian-Wollersberger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Julian-Wollersberger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Julian-Wollersberger/subscriptions", "organizations_url": "https://api.github.com/users/Julian-Wollersberger/orgs", "repos_url": "https://api.github.com/users/Julian-Wollersberger/repos", "events_url": "https://api.github.com/users/Julian-Wollersberger/events{/privacy}", "received_events_url": "https://api.github.com/users/Julian-Wollersberger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Julian-Wollersberger", "id": 24991778, "node_id": "MDQ6VXNlcjI0OTkxNzc4", "avatar_url": "https://avatars.githubusercontent.com/u/24991778?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Julian-Wollersberger", "html_url": "https://github.com/Julian-Wollersberger", "followers_url": "https://api.github.com/users/Julian-Wollersberger/followers", "following_url": "https://api.github.com/users/Julian-Wollersberger/following{/other_user}", "gists_url": "https://api.github.com/users/Julian-Wollersberger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Julian-Wollersberger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Julian-Wollersberger/subscriptions", "organizations_url": "https://api.github.com/users/Julian-Wollersberger/orgs", "repos_url": "https://api.github.com/users/Julian-Wollersberger/repos", "events_url": "https://api.github.com/users/Julian-Wollersberger/events{/privacy}", "received_events_url": "https://api.github.com/users/Julian-Wollersberger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1be5d1eabb957c8b0bd0f4564a5f7c8bef1826bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1be5d1eabb957c8b0bd0f4564a5f7c8bef1826bb", "html_url": "https://github.com/rust-lang/rust/commit/1be5d1eabb957c8b0bd0f4564a5f7c8bef1826bb"}], "stats": {"total": 152, "additions": 30, "deletions": 122}, "files": [{"sha": "1d67d6de4daa58beb6788722b82ebbfabec0cb76", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 30, "deletions": 122, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/18cc63d693a3a1d130ba533994c895b56fed3769/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cc63d693a3a1d130ba533994c895b56fed3769/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=18cc63d693a3a1d130ba533994c895b56fed3769", "patch": "@@ -15,6 +15,7 @@ mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n \n+use rustc_lexer::unescape::Mode;\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -326,38 +327,27 @@ impl<'a> StringReader<'a> {\n         suffix_start: BytePos,\n         kind: rustc_lexer::LiteralKind,\n     ) -> (token::LitKind, Symbol) {\n-        match kind {\n+        // prefix means `\"` or `br\"` or `r###\"`, ...\n+        let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start, suffix_start, \"unterminated character literal\").raise()\n                 }\n-                let content_start = start + BytePos(1);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_char_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Char, id)\n+                (token::Char, Mode::Char, 1, 1) // ' '\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start + BytePos(1), suffix_start, \"unterminated byte constant\")\n                         .raise()\n                 }\n-                let content_start = start + BytePos(2);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_byte_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Byte, id)\n+                (token::Byte, Mode::Byte, 2, 1) // b' '\n             }\n             rustc_lexer::LiteralKind::Str { terminated } => {\n                 if !terminated {\n                     self.fatal_span_(start, suffix_start, \"unterminated double quote string\")\n                         .raise()\n                 }\n-                let content_start = start + BytePos(1);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::Str, id)\n+                (token::Str, Mode::Str, 1, 1) // \" \"\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n@@ -368,42 +358,28 @@ impl<'a> StringReader<'a> {\n                     )\n                     .raise()\n                 }\n-                let content_start = start + BytePos(2);\n-                let content_end = suffix_start - BytePos(1);\n-                self.validate_byte_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::ByteStr, id)\n+                (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n             }\n             rustc_lexer::LiteralKind::RawStr(unvalidated_raw_str) => {\n                 let valid_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n                 let n_hashes = valid_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n-\n-                let content_start = start + BytePos(2 + n);\n-                let content_end = suffix_start - BytePos(1 + n);\n-                self.validate_raw_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::StrRaw(n_hashes), id)\n+                (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n             }\n             rustc_lexer::LiteralKind::RawByteStr(unvalidated_raw_str) => {\n                 let validated_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n                 let n_hashes = validated_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n-\n-                let content_start = start + BytePos(3 + n);\n-                let content_end = suffix_start - BytePos(1 + n);\n-                self.validate_raw_byte_str_escape(content_start, content_end);\n-                let id = self.symbol_from_to(content_start, content_end);\n-                (token::ByteStrRaw(n_hashes), id)\n+                (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n-                if empty_int {\n+                return if empty_int {\n                     self.err_span_(start, suffix_start, \"no valid digits found for number\");\n                     (token::Integer, sym::integer(0))\n                 } else {\n                     self.validate_int_literal(base, start, suffix_start);\n                     (token::Integer, self.symbol_from_to(start, suffix_start))\n-                }\n+                };\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n@@ -431,9 +407,14 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let id = self.symbol_from_to(start, suffix_start);\n-                (token::Float, id)\n+                return (token::Float, id);\n             }\n-        }\n+        };\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = suffix_start - BytePos(postfix_len);\n+        let id = self.symbol_from_to(content_start, content_end);\n+        self.validate_literal_escape(mode, content_start, content_end);\n+        return (lit_kind, id);\n     }\n \n     #[inline]\n@@ -555,96 +536,23 @@ impl<'a> StringReader<'a> {\n         .raise();\n     }\n \n-    fn validate_char_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        if let Err((off, err)) = unescape::unescape_char(lit) {\n-            emit_unescape_error(\n-                &self.sess.span_diagnostic,\n-                lit,\n-                self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                unescape::Mode::Char,\n-                0..off,\n-                err,\n-            )\n-        }\n-    }\n-\n-    fn validate_byte_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        if let Err((off, err)) = unescape::unescape_byte(lit) {\n-            emit_unescape_error(\n-                &self.sess.span_diagnostic,\n-                lit,\n-                self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                unescape::Mode::Byte,\n-                0..off,\n-                err,\n-            )\n-        }\n-    }\n-\n-    fn validate_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n+    fn validate_literal_escape(&self, mode: Mode, content_start: BytePos, content_end: BytePos) {\n+        let lit_content = self.str_from_to(content_start, content_end);\n+        unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n+            // Here we only check for errors. The actual unescaping is done later.\n+            if let Err(err) = result {\n+                let span_with_quotes =\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1));\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::Str,\n+                    lit_content,\n+                    span_with_quotes,\n+                    mode,\n                     range,\n                     err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_raw_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::Str,\n-                    range,\n-                    err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::ByteStr,\n-                    range,\n-                    err,\n-                )\n-            }\n-        })\n-    }\n-\n-    fn validate_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        let lit = self.str_from_to(content_start, content_end);\n-        unescape::unescape_byte_str(lit, &mut |range, c| {\n-            if let Err(err) = c {\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit,\n-                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                    unescape::Mode::ByteStr,\n-                    range,\n-                    err,\n-                )\n+                );\n             }\n-        })\n+        });\n     }\n \n     fn validate_int_literal(&self, base: Base, content_start: BytePos, content_end: BytePos) {"}]}