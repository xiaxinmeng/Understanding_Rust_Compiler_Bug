{"sha": "9bb55dc8642d811d66a7599812009cc063577e00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYjU1ZGM4NjQyZDgxMWQ2NmE3NTk5ODEyMDA5Y2MwNjM1NzdlMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-30T23:04:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-30T23:04:16Z"}, "message": "Auto merge of #76325 - lzutao:split-core-str, r=Amanieu\n\nSplit core/str/mod.rs to smaller files\n\nNote for reviewer:\n* I split to multiple commits for easier reviewing, but I could git squash them all to one if requested.\n* Recommend pulling this change locally and using advanced git diff viewer or this command:\n  ```bash\n  git show --reverse --color-moved=dimmed-zebra --color-moved-ws=ignore-all-space master..\n  ```\n\n---\n\nI split `core/str/mod.rs` to these modules:\n\n* `converts`: Contains helper functions to convert from bytes to str.\n* `error`: For error structs like Utf8Error.\n* `iter`: For iterators of many str methods.\n* `traits`: For indexing operations and build in traits on str.\n* `validations`: For functions validating utf8 --- This name is awkward, maybe utf8.rs is better.", "tree": {"sha": "3716d9e69711ab1223a55e60177f087abb8a2c35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3716d9e69711ab1223a55e60177f087abb8a2c35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bb55dc8642d811d66a7599812009cc063577e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb55dc8642d811d66a7599812009cc063577e00", "html_url": "https://github.com/rust-lang/rust/commit/9bb55dc8642d811d66a7599812009cc063577e00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bb55dc8642d811d66a7599812009cc063577e00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef663a8a48ea6b98b43cbfaefd99316b36b16825", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef663a8a48ea6b98b43cbfaefd99316b36b16825", "html_url": "https://github.com/rust-lang/rust/commit/ef663a8a48ea6b98b43cbfaefd99316b36b16825"}, {"sha": "dce7248a39e7f8907cb9c5cfe719f6f63da1fa1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dce7248a39e7f8907cb9c5cfe719f6f63da1fa1f", "html_url": "https://github.com/rust-lang/rust/commit/dce7248a39e7f8907cb9c5cfe719f6f63da1fa1f"}], "stats": {"total": 4952, "additions": 2507, "deletions": 2445}, "files": [{"sha": "de2a93f735032758a93454ce3ab690aef2dd9f1e", "filename": "library/core/src/str/converts.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=9bb55dc8642d811d66a7599812009cc063577e00", "patch": "@@ -0,0 +1,192 @@\n+//! Ways to create a `str` from bytes slice.\n+\n+use crate::mem;\n+\n+use super::validations::run_utf8_validation;\n+use super::Utf8Error;\n+\n+/// Converts a slice of bytes to a string slice.\n+///\n+/// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n+/// ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n+/// the two. Not all byte slices are valid string slices, however: [`&str`] requires\n+/// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n+/// UTF-8, and then does the conversion.\n+///\n+/// [`&str`]: str\n+/// [byteslice]: ../../std/primitive.slice.html\n+///\n+/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n+/// incur the overhead of the validity check, there is an unsafe version of\n+/// this function, [`from_utf8_unchecked`], which has the same\n+/// behavior but skips the check.\n+///\n+/// If you need a `String` instead of a `&str`, consider\n+/// [`String::from_utf8`][string].\n+///\n+/// [string]: ../../std/string/struct.String.html#method.from_utf8\n+///\n+/// Because you can stack-allocate a `[u8; N]`, and you can take a\n+/// [`&[u8]`][byteslice] of it, this function is one way to have a\n+/// stack-allocated string. There is an example of this in the\n+/// examples section below.\n+///\n+/// [byteslice]: ../../std/primitive.slice.html\n+///\n+/// # Errors\n+///\n+/// Returns `Err` if the slice is not UTF-8 with a description as to why the\n+/// provided slice is not UTF-8.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+///\n+/// Incorrect bytes:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some invalid bytes, in a vector\n+/// let sparkle_heart = vec![0, 159, 146, 150];\n+///\n+/// assert!(str::from_utf8(&sparkle_heart).is_err());\n+/// ```\n+///\n+/// See the docs for [`Utf8Error`] for more details on the kinds of\n+/// errors that can be returned.\n+///\n+/// A \"stack allocated string\":\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a stack-allocated array\n+/// let sparkle_heart = [240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n+    run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n+    Ok(unsafe { from_utf8_unchecked(v) })\n+}\n+\n+/// Converts a mutable slice of bytes to a mutable string slice.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // \"Hello, Rust!\" as a mutable vector\n+/// let mut hellorust = vec![72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33];\n+///\n+/// // As we know these bytes are valid, we can use `unwrap()`\n+/// let outstr = str::from_utf8_mut(&mut hellorust).unwrap();\n+///\n+/// assert_eq!(\"Hello, Rust!\", outstr);\n+/// ```\n+///\n+/// Incorrect bytes:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // Some invalid bytes in a mutable vector\n+/// let mut invalid = vec![128, 223];\n+///\n+/// assert!(str::from_utf8_mut(&mut invalid).is_err());\n+/// ```\n+/// See the docs for [`Utf8Error`] for more details on the kinds of\n+/// errors that can be returned.\n+#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n+pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n+    run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n+    Ok(unsafe { from_utf8_unchecked_mut(v) })\n+}\n+\n+/// Converts a slice of bytes to a string slice without checking\n+/// that the string contains valid UTF-8.\n+///\n+/// See the safe version, [`from_utf8`], for more information.\n+///\n+/// # Safety\n+///\n+/// This function is unsafe because it does not check that the bytes passed to\n+/// it are valid UTF-8. If this constraint is violated, undefined behavior\n+/// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n+///\n+/// [`&str`]: str\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// let sparkle_heart = unsafe {\n+///     str::from_utf8_unchecked(&sparkle_heart)\n+/// };\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked\", issue = \"75196\")]\n+#[allow_internal_unstable(const_fn_transmute)]\n+pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n+    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n+    // Also relies on `&str` and `&[u8]` having the same layout.\n+    unsafe { mem::transmute(v) }\n+}\n+\n+/// Converts a slice of bytes to a string slice without checking\n+/// that the string contains valid UTF-8; mutable version.\n+///\n+/// See the immutable version, [`from_utf8_unchecked()`] for more information.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// let mut heart = vec![240, 159, 146, 150];\n+/// let heart = unsafe { str::from_utf8_unchecked_mut(&mut heart) };\n+///\n+/// assert_eq!(\"\ud83d\udc96\", heart);\n+/// ```\n+#[inline]\n+#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n+pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*mut str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for writes.\n+    unsafe { &mut *(v as *mut [u8] as *mut str) }\n+}"}, {"sha": "427f720d68cdb8cc2a79debfdcefc16c2d2c35e0", "filename": "library/core/src/str/error.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs?ref=9bb55dc8642d811d66a7599812009cc063577e00", "patch": "@@ -0,0 +1,129 @@\n+//! Defines utf8 error type.\n+\n+use crate::fmt;\n+\n+/// Errors which can occur when attempting to interpret a sequence of [`u8`]\n+/// as a string.\n+///\n+/// As such, the `from_utf8` family of functions and methods for both [`String`]s\n+/// and [`&str`]s make use of this error, for example.\n+///\n+/// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n+/// [`&str`]: super::from_utf8\n+///\n+/// # Examples\n+///\n+/// This error type\u2019s methods can be used to create functionality\n+/// similar to `String::from_utf8_lossy` without allocating heap memory:\n+///\n+/// ```\n+/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n+///     loop {\n+///         match std::str::from_utf8(input) {\n+///             Ok(valid) => {\n+///                 push(valid);\n+///                 break\n+///             }\n+///             Err(error) => {\n+///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n+///                 unsafe {\n+///                     push(std::str::from_utf8_unchecked(valid))\n+///                 }\n+///                 push(\"\\u{FFFD}\");\n+///\n+///                 if let Some(invalid_sequence_length) = error.error_len() {\n+///                     input = &after_valid[invalid_sequence_length..]\n+///                 } else {\n+///                     break\n+///                 }\n+///             }\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[derive(Copy, Eq, PartialEq, Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Utf8Error {\n+    pub(super) valid_up_to: usize,\n+    pub(super) error_len: Option<u8>,\n+}\n+\n+impl Utf8Error {\n+    /// Returns the index in the given string up to which valid UTF-8 was\n+    /// verified.\n+    ///\n+    /// It is the maximum index such that `from_utf8(&input[..index])`\n+    /// would return `Ok(_)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::str;\n+    ///\n+    /// // some invalid bytes, in a vector\n+    /// let sparkle_heart = vec![0, 159, 146, 150];\n+    ///\n+    /// // std::str::from_utf8 returns a Utf8Error\n+    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n+    ///\n+    /// // the second byte is invalid here\n+    /// assert_eq!(1, error.valid_up_to());\n+    /// ```\n+    #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n+    pub fn valid_up_to(&self) -> usize {\n+        self.valid_up_to\n+    }\n+\n+    /// Provides more information about the failure:\n+    ///\n+    /// * `None`: the end of the input was reached unexpectedly.\n+    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n+    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n+    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n+    ///\n+    /// * `Some(len)`: an unexpected byte was encountered.\n+    ///   The length provided is that of the invalid byte sequence\n+    ///   that starts at the index given by `valid_up_to()`.\n+    ///   Decoding should resume after that sequence\n+    ///   (after inserting a [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD]) in case of\n+    ///   lossy decoding.\n+    ///\n+    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n+    #[stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")]\n+    pub fn error_len(&self) -> Option<usize> {\n+        self.error_len.map(|len| len as usize)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for Utf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let Some(error_len) = self.error_len {\n+            write!(\n+                f,\n+                \"invalid utf-8 sequence of {} bytes from index {}\",\n+                error_len, self.valid_up_to\n+            )\n+        } else {\n+            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n+        }\n+    }\n+}\n+\n+/// An error returned when parsing a `bool` using [`from_str`] fails\n+///\n+/// [`from_str`]: super::FromStr::from_str\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseBoolError {\n+    pub(super) _priv: (),\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseBoolError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"provided string was not `true` or `false`\".fmt(f)\n+    }\n+}"}, {"sha": "27a67e2b22f236a9d0c4197a3fded47cb1a5ca74", "filename": "library/core/src/str/iter.rs", "status": "added", "additions": 1255, "deletions": 0, "changes": 1255, "blob_url": "https://github.com/rust-lang/rust/blob/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=9bb55dc8642d811d66a7599812009cc063577e00", "patch": "@@ -0,0 +1,1255 @@\n+//! Iterators for `str` methods.\n+\n+use crate::char;\n+use crate::fmt::{self, Write};\n+use crate::iter::TrustedRandomAccess;\n+use crate::iter::{Chain, FlatMap, Flatten};\n+use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen};\n+use crate::ops::Try;\n+use crate::option;\n+use crate::slice::{self, Split as SliceSplit};\n+\n+use super::from_utf8_unchecked;\n+use super::pattern::Pattern;\n+use super::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n+use super::validations::{next_code_point, next_code_point_reverse, utf8_is_cont_byte};\n+use super::LinesAnyMap;\n+use super::{BytesIsNotEmpty, UnsafeBytesToStr};\n+use super::{CharEscapeDebugContinue, CharEscapeDefault, CharEscapeUnicode};\n+use super::{IsAsciiWhitespace, IsNotEmpty, IsWhitespace};\n+\n+/// An iterator over the [`char`]s of a string slice.\n+///\n+///\n+/// This struct is created by the [`chars`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`char`]: prim@char\n+/// [`chars`]: str::chars\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chars<'a> {\n+    pub(super) iter: slice::Iter<'a, u8>,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for Chars<'a> {\n+    type Item = char;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        next_code_point(&mut self.iter).map(|ch| {\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n+            unsafe { char::from_u32_unchecked(ch) }\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        // length in `char` is equal to the number of non-continuation bytes\n+        let bytes_len = self.iter.len();\n+        let mut cont_bytes = 0;\n+        for &byte in self.iter {\n+            cont_bytes += utf8_is_cont_byte(byte) as usize;\n+        }\n+        bytes_len - cont_bytes\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.iter.len();\n+        // `(len + 3)` can't overflow, because we know that the `slice::Iter`\n+        // belongs to a slice in memory which has a maximum length of\n+        // `isize::MAX` (that's well below `usize::MAX`).\n+        ((len + 3) / 4, Some(len))\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"chars_debug_impl\", since = \"1.38.0\")]\n+impl fmt::Debug for Chars<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Chars(\")?;\n+        f.debug_list().entries(self.clone()).finish()?;\n+        write!(f, \")\")?;\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Chars<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<char> {\n+        next_code_point_reverse(&mut self.iter).map(|ch| {\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n+            unsafe { char::from_u32_unchecked(ch) }\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for Chars<'_> {}\n+\n+impl<'a> Chars<'a> {\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// This has the same lifetime as the original slice, and so the\n+    /// iterator can continue to be used while this exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut chars = \"abc\".chars();\n+    ///\n+    /// assert_eq!(chars.as_str(), \"abc\");\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"bc\");\n+    /// chars.next();\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"\");\n+    /// ```\n+    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n+    #[inline]\n+    pub fn as_str(&self) -> &'a str {\n+        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n+        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n+    }\n+}\n+\n+/// An iterator over the [`char`]s of a string slice, and their positions.\n+///\n+/// This struct is created by the [`char_indices`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`char`]: prim@char\n+/// [`char_indices`]: str::char_indices\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct CharIndices<'a> {\n+    pub(super) front_offset: usize,\n+    pub(super) iter: Chars<'a>,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for CharIndices<'a> {\n+    type Item = (usize, char);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, char)> {\n+        let pre_len = self.iter.iter.len();\n+        match self.iter.next() {\n+            None => None,\n+            Some(ch) => {\n+                let index = self.front_offset;\n+                let len = self.iter.iter.len();\n+                self.front_offset += pre_len - len;\n+                Some((index, ch))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(usize, char)> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for CharIndices<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, char)> {\n+        self.iter.next_back().map(|ch| {\n+            let index = self.front_offset + self.iter.iter.len();\n+            (index, ch)\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for CharIndices<'_> {}\n+\n+impl<'a> CharIndices<'a> {\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// This has the same lifetime as the original slice, and so the\n+    /// iterator can continue to be used while this exists.\n+    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n+    #[inline]\n+    pub fn as_str(&self) -> &'a str {\n+        self.iter.as_str()\n+    }\n+}\n+\n+/// An iterator over the bytes of a string slice.\n+///\n+/// This struct is created by the [`bytes`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`bytes`]: str::bytes\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone, Debug)]\n+pub struct Bytes<'a>(pub(super) Copied<slice::Iter<'a, u8>>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for Bytes<'_> {\n+    type Item = u8;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.0.count()\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.0.last()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.0.nth(n)\n+    }\n+\n+    #[inline]\n+    fn all<F>(&mut self, f: F) -> bool\n+    where\n+        F: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.all(f)\n+    }\n+\n+    #[inline]\n+    fn any<F>(&mut self, f: F) -> bool\n+    where\n+        F: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.any(f)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.0.find(predicate)\n+    }\n+\n+    #[inline]\n+    fn position<P>(&mut self, predicate: P) -> Option<usize>\n+    where\n+        P: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.position(predicate)\n+    }\n+\n+    #[inline]\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize>\n+    where\n+        P: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.rposition(predicate)\n+    }\n+\n+    #[inline]\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> u8 {\n+        // SAFETY: the caller must uphold the safety contract\n+        // for `Iterator::__iterator_get_unchecked`.\n+        unsafe { self.0.__iterator_get_unchecked(idx) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for Bytes<'_> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.0.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.0.nth_back(n)\n+    }\n+\n+    #[inline]\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.0.rfind(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for Bytes<'_> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for Bytes<'_> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl TrustedLen for Bytes<'_> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl TrustedRandomAccess for Bytes<'_> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// This macro generates a Clone impl for string pattern API\n+/// wrapper types of the form X<'a, P>\n+macro_rules! derive_pattern_clone {\n+    (clone $t:ident with |$s:ident| $e:expr) => {\n+        impl<'a, P> Clone for $t<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n+        {\n+            fn clone(&self) -> Self {\n+                let $s = self;\n+                $e\n+            }\n+        }\n+    };\n+}\n+\n+/// This macro generates two public iterator structs\n+/// wrapping a private internal one that makes use of the `Pattern` API.\n+///\n+/// For all patterns `P: Pattern<'a>` the following items will be\n+/// generated (generics omitted):\n+///\n+/// struct $forward_iterator($internal_iterator);\n+/// struct $reverse_iterator($internal_iterator);\n+///\n+/// impl Iterator for $forward_iterator\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// impl DoubleEndedIterator for $forward_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl Iterator for $reverse_iterator\n+///       where P::Searcher: ReverseSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl DoubleEndedIterator for $reverse_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// The internal one is defined outside the macro, and has almost the same\n+/// semantic as a DoubleEndedIterator by delegating to `pattern::Searcher` and\n+/// `pattern::ReverseSearcher` for both forward and reverse iteration.\n+///\n+/// \"Almost\", because a `Searcher` and a `ReverseSearcher` for a given\n+/// `Pattern` might not return the same elements, so actually implementing\n+/// `DoubleEndedIterator` for it would be incorrect.\n+/// (See the docs in `str::pattern` for more details)\n+///\n+/// However, the internal struct still represents a single ended iterator from\n+/// either end, and depending on pattern is also a valid double ended iterator,\n+/// so the two wrapper structs implement `Iterator`\n+/// and `DoubleEndedIterator` depending on the concrete pattern type, leading\n+/// to the complex impls seen above.\n+macro_rules! generate_pattern_iterators {\n+    {\n+        // Forward iterator\n+        forward:\n+            $(#[$forward_iterator_attribute:meta])*\n+            struct $forward_iterator:ident;\n+\n+        // Reverse iterator\n+        reverse:\n+            $(#[$reverse_iterator_attribute:meta])*\n+            struct $reverse_iterator:ident;\n+\n+        // Stability of all generated items\n+        stability:\n+            $(#[$common_stability_attribute:meta])*\n+\n+        // Internal almost-iterator that is being delegated to\n+        internal:\n+            $internal_iterator:ident yielding ($iterty:ty);\n+\n+        // Kind of delegation - either single ended or double ended\n+        delegate $($t:tt)*\n+    } => {\n+        $(#[$forward_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $forward_iterator<'a, P: Pattern<'a>>(pub(super) $internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> fmt::Debug for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: fmt::Debug>,\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                f.debug_tuple(stringify!($forward_iterator))\n+                    .field(&self.0)\n+                    .finish()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> Clone for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n+        {\n+            fn clone(&self) -> Self {\n+                $forward_iterator(self.0.clone())\n+            }\n+        }\n+\n+        $(#[$reverse_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $reverse_iterator<'a, P: Pattern<'a>>(pub(super) $internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> fmt::Debug for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: fmt::Debug>,\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                f.debug_tuple(stringify!($reverse_iterator))\n+                    .field(&self.0)\n+                    .finish()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> Iterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+        {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> Clone for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n+        {\n+            fn clone(&self) -> Self {\n+                $reverse_iterator(self.0.clone())\n+            }\n+        }\n+\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n+        impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n+\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n+        impl<'a, P> FusedIterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+        {}\n+\n+        generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n+                                                $forward_iterator,\n+                                                $reverse_iterator, $iterty);\n+    };\n+    {\n+        double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> DoubleEndedIterator for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> DoubleEndedIterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+    };\n+    {\n+        single ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {}\n+}\n+\n+derive_pattern_clone! {\n+    clone SplitInternal\n+    with |s| SplitInternal { matcher: s.matcher.clone(), ..*s }\n+}\n+\n+pub(super) struct SplitInternal<'a, P: Pattern<'a>> {\n+    pub(super) start: usize,\n+    pub(super) end: usize,\n+    pub(super) matcher: P::Searcher,\n+    pub(super) allow_trailing_empty: bool,\n+    pub(super) finished: bool,\n+}\n+\n+impl<'a, P> fmt::Debug for SplitInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInternal\")\n+            .field(\"start\", &self.start)\n+            .field(\"end\", &self.end)\n+            .field(\"matcher\", &self.matcher)\n+            .field(\"allow_trailing_empty\", &self.allow_trailing_empty)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n+    #[inline]\n+    fn get_end(&mut self) -> Option<&'a str> {\n+        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n+            self.finished = true;\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n+            unsafe {\n+                let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n+                Some(string)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n+            Some((a, b)) => unsafe {\n+                let elt = haystack.get_unchecked(self.start..a);\n+                self.start = b;\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_inclusive(&mut self) -> Option<&'a str> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.start is either the start of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(self.start..b);\n+                self.start = b;\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => {\n+                    if self.finished {\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n+            Some((a, b)) => unsafe {\n+                let elt = haystack.get_unchecked(b..self.end);\n+                self.end = a;\n+                Some(elt)\n+            },\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.get_unchecked(self.start..self.end))\n+            },\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_back_inclusive(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back_inclusive() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => {\n+                    if self.finished {\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(b..self.end);\n+                self.end = b;\n+                Some(elt)\n+            },\n+            // SAFETY: self.start is either the start of the original string,\n+            // or start of a substring that represents the part of the string that hasn't\n+            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n+            // self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.get_unchecked(self.start..self.end))\n+            },\n+        }\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`split`].\n+        ///\n+        /// [`split`]: str::split\n+        struct Split;\n+    reverse:\n+        /// Created with the method [`rsplit`].\n+        ///\n+        /// [`rsplit`]: str::rsplit\n+        struct RSplit;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`split_terminator`].\n+        ///\n+        /// [`split_terminator`]: str::split_terminator\n+        struct SplitTerminator;\n+    reverse:\n+        /// Created with the method [`rsplit_terminator`].\n+        ///\n+        /// [`rsplit_terminator`]: str::rsplit_terminator\n+        struct RSplitTerminator;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+derive_pattern_clone! {\n+    clone SplitNInternal\n+    with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n+}\n+\n+pub(super) struct SplitNInternal<'a, P: Pattern<'a>> {\n+    pub(super) iter: SplitInternal<'a, P>,\n+    /// The number of splits remaining\n+    pub(super) count: usize,\n+}\n+\n+impl<'a, P> fmt::Debug for SplitNInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitNInternal\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"count\", &self.count)\n+            .finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        match self.count {\n+            0 => None,\n+            1 => {\n+                self.count = 0;\n+                self.iter.get_end()\n+            }\n+            _ => {\n+                self.count -= 1;\n+                self.iter.next()\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        match self.count {\n+            0 => None,\n+            1 => {\n+                self.count = 0;\n+                self.iter.get_end()\n+            }\n+            _ => {\n+                self.count -= 1;\n+                self.iter.next_back()\n+            }\n+        }\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`splitn`].\n+        ///\n+        /// [`splitn`]: str::splitn\n+        struct SplitN;\n+    reverse:\n+        /// Created with the method [`rsplitn`].\n+        ///\n+        /// [`rsplitn`]: str::rsplitn\n+        struct RSplitN;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitNInternal yielding (&'a str);\n+    delegate single ended;\n+}\n+\n+derive_pattern_clone! {\n+    clone MatchIndicesInternal\n+    with |s| MatchIndicesInternal(s.0.clone())\n+}\n+\n+pub(super) struct MatchIndicesInternal<'a, P: Pattern<'a>>(pub(super) P::Searcher);\n+\n+impl<'a, P> fmt::Debug for MatchIndicesInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MatchIndicesInternal\").field(&self.0).finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, &'a str)> {\n+        self.0\n+            .next_match()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, &'a str)>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        self.0\n+            .next_match_back()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`match_indices`].\n+        ///\n+        /// [`match_indices`]: str::match_indices\n+        struct MatchIndices;\n+    reverse:\n+        /// Created with the method [`rmatch_indices`].\n+        ///\n+        /// [`rmatch_indices`]: str::rmatch_indices\n+        struct RMatchIndices;\n+    stability:\n+        #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    internal:\n+        MatchIndicesInternal yielding ((usize, &'a str));\n+    delegate double ended;\n+}\n+\n+derive_pattern_clone! {\n+    clone MatchesInternal\n+    with |s| MatchesInternal(s.0.clone())\n+}\n+\n+pub(super) struct MatchesInternal<'a, P: Pattern<'a>>(pub(super) P::Searcher);\n+\n+impl<'a, P> fmt::Debug for MatchesInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MatchesInternal\").field(&self.0).finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+        self.0.next_match().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().get_unchecked(a..b)\n+        })\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+        self.0.next_match_back().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().get_unchecked(a..b)\n+        })\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`matches`].\n+        ///\n+        /// [`matches`]: str::matches\n+        struct Matches;\n+    reverse:\n+        /// Created with the method [`rmatches`].\n+        ///\n+        /// [`rmatches`]: str::rmatches\n+        struct RMatches;\n+    stability:\n+        #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    internal:\n+        MatchesInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+/// An iterator over the lines of a string, as string slices.\n+///\n+/// This struct is created with the [`lines`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`lines`]: str::lines\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone, Debug)]\n+pub struct Lines<'a>(pub(super) Map<SplitTerminator<'a, char>, LinesAnyMap>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for Lines<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Lines<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for Lines<'_> {}\n+\n+/// Created with the method [`lines_any`].\n+///\n+/// [`lines_any`]: str::lines_any\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n+#[derive(Clone, Debug)]\n+#[allow(deprecated)]\n+pub struct LinesAny<'a>(pub(super) Lines<'a>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n+impl<'a> Iterator for LinesAny<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n+impl<'a> DoubleEndedIterator for LinesAny<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+#[allow(deprecated)]\n+impl FusedIterator for LinesAny<'_> {}\n+\n+/// An iterator over the non-whitespace substrings of a string,\n+/// separated by any amount of whitespace.\n+///\n+/// This struct is created by the [`split_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_whitespace`]: str::split_whitespace\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitWhitespace<'a> {\n+    pub(super) inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n+}\n+\n+/// An iterator over the non-ASCII-whitespace substrings of a string,\n+/// separated by any amount of ASCII whitespace.\n+///\n+/// This struct is created by the [`split_ascii_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_ascii_whitespace`]: str::split_ascii_whitespace\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitAsciiWhitespace<'a> {\n+    pub(super) inner:\n+        Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n+}\n+\n+/// An iterator over the substrings of a string,\n+/// terminated by a substring matching to a predicate function\n+/// Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_inclusive`]: str::split_inclusive\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+pub struct SplitInclusive<'a, P: Pattern<'a>>(pub(super) SplitInternal<'a, P>);\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> Iterator for SplitWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for SplitWhitespace<'_> {}\n+\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+impl FusedIterator for SplitAsciiWhitespace<'_> {}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\").field(\"0\", &self.0).finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n+    fn clone(&self) -> Self {\n+        SplitInclusive(self.0.clone())\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n+    for SplitInclusive<'a, P>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n+\n+/// An iterator of [`u16`] over the string encoded as UTF-16.\n+///\n+/// This struct is created by the [`encode_utf16`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`encode_utf16`]: str::encode_utf16\n+#[derive(Clone)]\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub struct EncodeUtf16<'a> {\n+    pub(super) chars: Chars<'a>,\n+    pub(super) extra: u16,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl fmt::Debug for EncodeUtf16<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"EncodeUtf16 { .. }\")\n+    }\n+}\n+\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+impl<'a> Iterator for EncodeUtf16<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0; 2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(&mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n+            }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EncodeUtf16<'_> {}\n+\n+/// The return type of [`str::escape_debug`].\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDebug<'a> {\n+    pub(super) inner: Chain<\n+        Flatten<option::IntoIter<char::EscapeDebug>>,\n+        FlatMap<Chars<'a>, char::EscapeDebug, CharEscapeDebugContinue>,\n+    >,\n+}\n+\n+/// The return type of [`str::escape_default`].\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDefault<'a> {\n+    pub(super) inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n+}\n+\n+/// The return type of [`str::escape_unicode`].\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeUnicode<'a> {\n+    pub(super) inner: FlatMap<Chars<'a>, char::EscapeUnicode, CharEscapeUnicode>,\n+}\n+\n+macro_rules! escape_types_impls {\n+    ($( $Name: ident ),+) => {$(\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> fmt::Display for $Name<'a> {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                self.clone().try_for_each(|c| f.write_char(c))\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> Iterator for $Name<'a> {\n+            type Item = char;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<char> { self.inner.next() }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+            #[inline]\n+            fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+                Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+            {\n+                self.inner.try_fold(init, fold)\n+            }\n+\n+            #[inline]\n+            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n+            {\n+                self.inner.fold(init, fold)\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> FusedIterator for $Name<'a> {}\n+    )+}\n+}\n+\n+escape_types_impls!(EscapeDebug, EscapeDefault, EscapeUnicode);"}, {"sha": "720a35bbc8f2cf662039b774395ee78709ab022d", "filename": "library/core/src/str/lossy.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs?ref=9bb55dc8642d811d66a7599812009cc063577e00", "patch": "@@ -1,7 +1,9 @@\n use crate::char;\n use crate::fmt::{self, Write};\n use crate::mem;\n-use crate::str as core_str;\n+\n+use super::from_utf8_unchecked;\n+use super::validations::utf8_char_width;\n \n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n@@ -66,14 +68,14 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n             if byte < 128 {\n             } else {\n-                let w = core_str::utf8_char_width(byte);\n+                let w = utf8_char_width(byte);\n \n                 macro_rules! error {\n                     () => {{\n                         // SAFETY: We have checked up to `i` that source is valid UTF-8.\n                         unsafe {\n                             let r = Utf8LossyChunk {\n-                                valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n+                                valid: from_utf8_unchecked(&self.source[0..i_]),\n                                 broken: &self.source[i_..i],\n                             };\n                             self.source = &self.source[i..];\n@@ -133,7 +135,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n         let r = Utf8LossyChunk {\n             // SAFETY: We have checked that the entire source is valid UTF-8.\n-            valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n+            valid: unsafe { from_utf8_unchecked(self.source) },\n             broken: &[],\n         };\n         self.source = &[];"}, {"sha": "3e18a4e70627dfcb3d395f2303ce52c8664277d1", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 53, "deletions": 2441, "changes": 2494, "blob_url": "https://github.com/rust-lang/rust/blob/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=9bb55dc8642d811d66a7599812009cc063577e00", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! String manipulation.\n //!\n //! For more details, see the [`std::str`] module.\n@@ -8,2210 +6,76 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod converts;\n+mod error;\n+mod iter;\n+mod traits;\n+mod validations;\n+\n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n \n use crate::char;\n-use crate::fmt::{self, Write};\n-use crate::iter::TrustedRandomAccess;\n-use crate::iter::{Chain, FlatMap, Flatten};\n-use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen};\n use crate::mem;\n-use crate::ops::Try;\n-use crate::option;\n-use crate::slice::{self, SliceIndex, Split as SliceSplit};\n+use crate::slice::{self, SliceIndex};\n \n pub mod pattern;\n \n #[unstable(feature = \"str_internals\", issue = \"none\")]\n #[allow(missing_docs)]\n pub mod lossy;\n \n-/// Parse a value from a string\n-///\n-/// `FromStr`'s [`from_str`] method is often used implicitly, through\n-/// [`str`]'s [`parse`] method. See [`parse`]'s documentation for examples.\n-///\n-/// [`from_str`]: FromStr::from_str\n-/// [`parse`]: str::parse\n-///\n-/// `FromStr` does not have a lifetime parameter, and so you can only parse types\n-/// that do not contain a lifetime parameter themselves. In other words, you can\n-/// parse an `i32` with `FromStr`, but not a `&i32`. You can parse a struct that\n-/// contains an `i32`, but not one that contains an `&i32`.\n-///\n-/// # Examples\n-///\n-/// Basic implementation of `FromStr` on an example `Point` type:\n-///\n-/// ```\n-/// use std::str::FromStr;\n-/// use std::num::ParseIntError;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct Point {\n-///     x: i32,\n-///     y: i32\n-/// }\n-///\n-/// impl FromStr for Point {\n-///     type Err = ParseIntError;\n-///\n-///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n-///         let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\n-///                                  .split(',')\n-///                                  .collect();\n-///\n-///         let x_fromstr = coords[0].parse::<i32>()?;\n-///         let y_fromstr = coords[1].parse::<i32>()?;\n-///\n-///         Ok(Point { x: x_fromstr, y: y_fromstr })\n-///     }\n-/// }\n-///\n-/// let p = Point::from_str(\"(1,2)\");\n-/// assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait FromStr: Sized {\n-    /// The associated error which can be returned from parsing.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Err;\n-\n-    /// Parses a string `s` to return a value of this type.\n-    ///\n-    /// If parsing succeeds, return the value inside [`Ok`], otherwise\n-    /// when the string is ill-formatted return an error specific to the\n-    /// inside [`Err`]. The error type is specific to implementation of the trait.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n-    ///\n-    /// [ithirtytwo]: ../../std/primitive.i32.html\n-    ///\n-    /// ```\n-    /// use std::str::FromStr;\n-    ///\n-    /// let s = \"5\";\n-    /// let x = i32::from_str(s).unwrap();\n-    ///\n-    /// assert_eq!(5, x);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_str(s: &str) -> Result<Self, Self::Err>;\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromStr for bool {\n-    type Err = ParseBoolError;\n+pub use converts::{from_utf8, from_utf8_unchecked};\n \n-    /// Parse a `bool` from a string.\n-    ///\n-    /// Yields a `Result<bool, ParseBoolError>`, because `s` may or may not\n-    /// actually be parseable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::str::FromStr;\n-    ///\n-    /// assert_eq!(FromStr::from_str(\"true\"), Ok(true));\n-    /// assert_eq!(FromStr::from_str(\"false\"), Ok(false));\n-    /// assert!(<bool as FromStr>::from_str(\"not even a boolean\").is_err());\n-    /// ```\n-    ///\n-    /// Note, in many cases, the `.parse()` method on `str` is more proper.\n-    ///\n-    /// ```\n-    /// assert_eq!(\"true\".parse(), Ok(true));\n-    /// assert_eq!(\"false\".parse(), Ok(false));\n-    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n-    /// ```\n-    #[inline]\n-    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n-        match s {\n-            \"true\" => Ok(true),\n-            \"false\" => Ok(false),\n-            _ => Err(ParseBoolError { _priv: () }),\n-        }\n-    }\n-}\n-\n-/// An error returned when parsing a `bool` using [`from_str`] fails\n-///\n-/// [`from_str`]: FromStr::from_str\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseBoolError {\n-    _priv: (),\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ParseBoolError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        \"provided string was not `true` or `false`\".fmt(f)\n-    }\n-}\n-\n-/*\n-Section: Creating a string\n-*/\n-\n-/// Errors which can occur when attempting to interpret a sequence of [`u8`]\n-/// as a string.\n-///\n-/// As such, the `from_utf8` family of functions and methods for both [`String`]s\n-/// and [`&str`]s make use of this error, for example.\n-///\n-/// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n-/// [`&str`]: from_utf8\n-///\n-/// # Examples\n-///\n-/// This error type\u2019s methods can be used to create functionality\n-/// similar to `String::from_utf8_lossy` without allocating heap memory:\n-///\n-/// ```\n-/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n-///     loop {\n-///         match std::str::from_utf8(input) {\n-///             Ok(valid) => {\n-///                 push(valid);\n-///                 break\n-///             }\n-///             Err(error) => {\n-///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n-///                 unsafe {\n-///                     push(std::str::from_utf8_unchecked(valid))\n-///                 }\n-///                 push(\"\\u{FFFD}\");\n-///\n-///                 if let Some(invalid_sequence_length) = error.error_len() {\n-///                     input = &after_valid[invalid_sequence_length..]\n-///                 } else {\n-///                     break\n-///                 }\n-///             }\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[derive(Copy, Eq, PartialEq, Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Utf8Error {\n-    valid_up_to: usize,\n-    error_len: Option<u8>,\n-}\n-\n-impl Utf8Error {\n-    /// Returns the index in the given string up to which valid UTF-8 was\n-    /// verified.\n-    ///\n-    /// It is the maximum index such that `from_utf8(&input[..index])`\n-    /// would return `Ok(_)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::str;\n-    ///\n-    /// // some invalid bytes, in a vector\n-    /// let sparkle_heart = vec![0, 159, 146, 150];\n-    ///\n-    /// // std::str::from_utf8 returns a Utf8Error\n-    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n-    ///\n-    /// // the second byte is invalid here\n-    /// assert_eq!(1, error.valid_up_to());\n-    /// ```\n-    #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n-    pub fn valid_up_to(&self) -> usize {\n-        self.valid_up_to\n-    }\n-\n-    /// Provides more information about the failure:\n-    ///\n-    /// * `None`: the end of the input was reached unexpectedly.\n-    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n-    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n-    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n-    ///\n-    /// * `Some(len)`: an unexpected byte was encountered.\n-    ///   The length provided is that of the invalid byte sequence\n-    ///   that starts at the index given by `valid_up_to()`.\n-    ///   Decoding should resume after that sequence\n-    ///   (after inserting a [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD]) in case of\n-    ///   lossy decoding.\n-    ///\n-    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n-    #[stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")]\n-    pub fn error_len(&self) -> Option<usize> {\n-        self.error_len.map(|len| len as usize)\n-    }\n-}\n-\n-/// Converts a slice of bytes to a string slice.\n-///\n-/// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n-/// ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n-/// the two. Not all byte slices are valid string slices, however: [`&str`] requires\n-/// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n-/// UTF-8, and then does the conversion.\n-///\n-/// [`&str`]: str\n-/// [byteslice]: ../../std/primitive.slice.html\n-///\n-/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n-/// incur the overhead of the validity check, there is an unsafe version of\n-/// this function, [`from_utf8_unchecked`], which has the same\n-/// behavior but skips the check.\n-///\n-/// If you need a `String` instead of a `&str`, consider\n-/// [`String::from_utf8`][string].\n-///\n-/// [string]: ../../std/string/struct.String.html#method.from_utf8\n-///\n-/// Because you can stack-allocate a `[u8; N]`, and you can take a\n-/// [`&[u8]`][byteslice] of it, this function is one way to have a\n-/// stack-allocated string. There is an example of this in the\n-/// examples section below.\n-///\n-/// [byteslice]: ../../std/primitive.slice.html\n-///\n-/// # Errors\n-///\n-/// Returns `Err` if the slice is not UTF-8 with a description as to why the\n-/// provided slice is not UTF-8.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some bytes, in a vector\n-/// let sparkle_heart = vec![240, 159, 146, 150];\n-///\n-/// // We know these bytes are valid, so just use `unwrap()`.\n-/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n-///\n-/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n-/// ```\n-///\n-/// Incorrect bytes:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some invalid bytes, in a vector\n-/// let sparkle_heart = vec![0, 159, 146, 150];\n-///\n-/// assert!(str::from_utf8(&sparkle_heart).is_err());\n-/// ```\n-///\n-/// See the docs for [`Utf8Error`] for more details on the kinds of\n-/// errors that can be returned.\n-///\n-/// A \"stack allocated string\":\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some bytes, in a stack-allocated array\n-/// let sparkle_heart = [240, 159, 146, 150];\n-///\n-/// // We know these bytes are valid, so just use `unwrap()`.\n-/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n-///\n-/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n-    run_utf8_validation(v)?;\n-    // SAFETY: Just ran validation.\n-    Ok(unsafe { from_utf8_unchecked(v) })\n-}\n-\n-/// Converts a mutable slice of bytes to a mutable string slice.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // \"Hello, Rust!\" as a mutable vector\n-/// let mut hellorust = vec![72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33];\n-///\n-/// // As we know these bytes are valid, we can use `unwrap()`\n-/// let outstr = str::from_utf8_mut(&mut hellorust).unwrap();\n-///\n-/// assert_eq!(\"Hello, Rust!\", outstr);\n-/// ```\n-///\n-/// Incorrect bytes:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // Some invalid bytes in a mutable vector\n-/// let mut invalid = vec![128, 223];\n-///\n-/// assert!(str::from_utf8_mut(&mut invalid).is_err());\n-/// ```\n-/// See the docs for [`Utf8Error`] for more details on the kinds of\n-/// errors that can be returned.\n-#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n-    run_utf8_validation(v)?;\n-    // SAFETY: Just ran validation.\n-    Ok(unsafe { from_utf8_unchecked_mut(v) })\n-}\n-\n-/// Converts a slice of bytes to a string slice without checking\n-/// that the string contains valid UTF-8.\n-///\n-/// See the safe version, [`from_utf8`], for more information.\n-///\n-/// # Safety\n-///\n-/// This function is unsafe because it does not check that the bytes passed to\n-/// it are valid UTF-8. If this constraint is violated, undefined behavior\n-/// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n-///\n-/// [`&str`]: str\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some bytes, in a vector\n-/// let sparkle_heart = vec![240, 159, 146, 150];\n-///\n-/// let sparkle_heart = unsafe {\n-///     str::from_utf8_unchecked(&sparkle_heart)\n-/// };\n-///\n-/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked\", issue = \"75196\")]\n-#[allow(unused_attributes)]\n-#[allow_internal_unstable(const_fn_transmute)]\n-pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n-    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n-    // Also relies on `&str` and `&[u8]` having the same layout.\n-    unsafe { mem::transmute(v) }\n-}\n-\n-/// Converts a slice of bytes to a string slice without checking\n-/// that the string contains valid UTF-8; mutable version.\n-///\n-/// See the immutable version, [`from_utf8_unchecked()`] for more information.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// let mut heart = vec![240, 159, 146, 150];\n-/// let heart = unsafe { str::from_utf8_unchecked_mut(&mut heart) };\n-///\n-/// assert_eq!(\"\ud83d\udc96\", heart);\n-/// ```\n-#[inline]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n-    // SAFETY: the caller must guarantee that the bytes `v`\n-    // are valid UTF-8, thus the cast to `*mut str` is safe.\n-    // Also, the pointer dereference is safe because that pointer\n-    // comes from a reference which is guaranteed to be valid for writes.\n-    unsafe { &mut *(v as *mut [u8] as *mut str) }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for Utf8Error {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some(error_len) = self.error_len {\n-            write!(\n-                f,\n-                \"invalid utf-8 sequence of {} bytes from index {}\",\n-                error_len, self.valid_up_to\n-            )\n-        } else {\n-            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n-        }\n-    }\n-}\n-\n-/*\n-Section: Iterators\n-*/\n-\n-/// An iterator over the [`char`]s of a string slice.\n-///\n-///\n-/// This struct is created by the [`chars`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`char`]: prim@char\n-/// [`chars`]: str::chars\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Chars<'a> {\n-    iter: slice::Iter<'a, u8>,\n-}\n-\n-/// Returns the initial codepoint accumulator for the first byte.\n-/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-/// for width 3, and 3 bits for width 4.\n-#[inline]\n-fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n-    (byte & (0x7F >> width)) as u32\n-}\n-\n-/// Returns the value of `ch` updated with continuation byte `byte`.\n-#[inline]\n-fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n-    (ch << 6) | (byte & CONT_MASK) as u32\n-}\n-\n-/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n-/// bits `10`).\n-#[inline]\n-fn utf8_is_cont_byte(byte: u8) -> bool {\n-    (byte & !CONT_MASK) == TAG_CONT_U8\n-}\n-\n-#[inline]\n-fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n-    match opt {\n-        Some(&byte) => byte,\n-        None => 0,\n-    }\n-}\n-\n-/// Reads the next code point out of a byte iterator (assuming a\n-/// UTF-8-like encoding).\n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[inline]\n-pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n-    // Decode UTF-8\n-    let x = *bytes.next()?;\n-    if x < 128 {\n-        return Some(x as u32);\n-    }\n-\n-    // Multibyte case follows\n-    // Decode from a byte combination out of: [[[x y] z] w]\n-    // NOTE: Performance is sensitive to the exact formulation here\n-    let init = utf8_first_byte(x, 2);\n-    let y = unwrap_or_0(bytes.next());\n-    let mut ch = utf8_acc_cont_byte(init, y);\n-    if x >= 0xE0 {\n-        // [[x y z] w] case\n-        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n-        let z = unwrap_or_0(bytes.next());\n-        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n-        ch = init << 12 | y_z;\n-        if x >= 0xF0 {\n-            // [x y z w] case\n-            // use only the lower 3 bits of `init`\n-            let w = unwrap_or_0(bytes.next());\n-            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n-        }\n-    }\n-\n-    Some(ch)\n-}\n-\n-/// Reads the last code point out of a byte iterator (assuming a\n-/// UTF-8-like encoding).\n-#[inline]\n-fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n-where\n-    I: DoubleEndedIterator<Item = &'a u8>,\n-{\n-    // Decode UTF-8\n-    let w = match *bytes.next_back()? {\n-        next_byte if next_byte < 128 => return Some(next_byte as u32),\n-        back_byte => back_byte,\n-    };\n-\n-    // Multibyte case follows\n-    // Decode from a byte combination out of: [x [y [z w]]]\n-    let mut ch;\n-    let z = unwrap_or_0(bytes.next_back());\n-    ch = utf8_first_byte(z, 2);\n-    if utf8_is_cont_byte(z) {\n-        let y = unwrap_or_0(bytes.next_back());\n-        ch = utf8_first_byte(y, 3);\n-        if utf8_is_cont_byte(y) {\n-            let x = unwrap_or_0(bytes.next_back());\n-            ch = utf8_first_byte(x, 4);\n-            ch = utf8_acc_cont_byte(ch, y);\n-        }\n-        ch = utf8_acc_cont_byte(ch, z);\n-    }\n-    ch = utf8_acc_cont_byte(ch, w);\n-\n-    Some(ch)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Chars<'a> {\n-    type Item = char;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        next_code_point(&mut self.iter).map(|ch| {\n-            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n-            unsafe { char::from_u32_unchecked(ch) }\n-        })\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        // length in `char` is equal to the number of non-continuation bytes\n-        let bytes_len = self.iter.len();\n-        let mut cont_bytes = 0;\n-        for &byte in self.iter {\n-            cont_bytes += utf8_is_cont_byte(byte) as usize;\n-        }\n-        bytes_len - cont_bytes\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.iter.len();\n-        // `(len + 3)` can't overflow, because we know that the `slice::Iter`\n-        // belongs to a slice in memory which has a maximum length of\n-        // `isize::MAX` (that's well below `usize::MAX`).\n-        ((len + 3) / 4, Some(len))\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<char> {\n-        // No need to go through the entire string.\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"chars_debug_impl\", since = \"1.38.0\")]\n-impl fmt::Debug for Chars<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Chars(\")?;\n-        f.debug_list().entries(self.clone()).finish()?;\n-        write!(f, \")\")?;\n-        Ok(())\n-    }\n-}\n+pub use converts::{from_utf8_mut, from_utf8_unchecked_mut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for Chars<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<char> {\n-        next_code_point_reverse(&mut self.iter).map(|ch| {\n-            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n-            unsafe { char::from_u32_unchecked(ch) }\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for Chars<'_> {}\n-\n-impl<'a> Chars<'a> {\n-    /// Views the underlying data as a subslice of the original data.\n-    ///\n-    /// This has the same lifetime as the original slice, and so the\n-    /// iterator can continue to be used while this exists.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut chars = \"abc\".chars();\n-    ///\n-    /// assert_eq!(chars.as_str(), \"abc\");\n-    /// chars.next();\n-    /// assert_eq!(chars.as_str(), \"bc\");\n-    /// chars.next();\n-    /// chars.next();\n-    /// assert_eq!(chars.as_str(), \"\");\n-    /// ```\n-    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n-    #[inline]\n-    pub fn as_str(&self) -> &'a str {\n-        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n-        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n-    }\n-}\n+pub use error::{ParseBoolError, Utf8Error};\n \n-/// An iterator over the [`char`]s of a string slice, and their positions.\n-///\n-/// This struct is created by the [`char_indices`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`char`]: prim@char\n-/// [`char_indices`]: str::char_indices\n-#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct CharIndices<'a> {\n-    front_offset: usize,\n-    iter: Chars<'a>,\n-}\n+pub use traits::FromStr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for CharIndices<'a> {\n-    type Item = (usize, char);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, char)> {\n-        let pre_len = self.iter.iter.len();\n-        match self.iter.next() {\n-            None => None,\n-            Some(ch) => {\n-                let index = self.front_offset;\n-                let len = self.iter.iter.len();\n-                self.front_offset += pre_len - len;\n-                Some((index, ch))\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<(usize, char)> {\n-        // No need to go through the entire string.\n-        self.next_back()\n-    }\n-}\n+pub use iter::{Bytes, CharIndices, Chars, Lines, SplitWhitespace};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for CharIndices<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, char)> {\n-        self.iter.next_back().map(|ch| {\n-            let index = self.front_offset + self.iter.iter.len();\n-            (index, ch)\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for CharIndices<'_> {}\n-\n-impl<'a> CharIndices<'a> {\n-    /// Views the underlying data as a subslice of the original data.\n-    ///\n-    /// This has the same lifetime as the original slice, and so the\n-    /// iterator can continue to be used while this exists.\n-    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n-    #[inline]\n-    pub fn as_str(&self) -> &'a str {\n-        self.iter.as_str()\n-    }\n-}\n-\n-/// An iterator over the bytes of a string slice.\n-///\n-/// This struct is created by the [`bytes`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`bytes`]: str::bytes\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone, Debug)]\n-pub struct Bytes<'a>(Copied<slice::Iter<'a, u8>>);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for Bytes<'_> {\n-    type Item = u8;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u8> {\n-        self.0.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.0.count()\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<Self::Item> {\n-        self.0.last()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        self.0.nth(n)\n-    }\n-\n-    #[inline]\n-    fn all<F>(&mut self, f: F) -> bool\n-    where\n-        F: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.all(f)\n-    }\n-\n-    #[inline]\n-    fn any<F>(&mut self, f: F) -> bool\n-    where\n-        F: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.any(f)\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.0.find(predicate)\n-    }\n-\n-    #[inline]\n-    fn position<P>(&mut self, predicate: P) -> Option<usize>\n-    where\n-        P: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.position(predicate)\n-    }\n-\n-    #[inline]\n-    fn rposition<P>(&mut self, predicate: P) -> Option<usize>\n-    where\n-        P: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.rposition(predicate)\n-    }\n-\n-    #[inline]\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> u8 {\n-        // SAFETY: the caller must uphold the safety contract\n-        // for `Iterator::__iterator_get_unchecked`.\n-        unsafe { self.0.__iterator_get_unchecked(idx) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl DoubleEndedIterator for Bytes<'_> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<u8> {\n-        self.0.next_back()\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        self.0.nth_back(n)\n-    }\n-\n-    #[inline]\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.0.rfind(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExactSizeIterator for Bytes<'_> {\n-    #[inline]\n-    fn len(&self) -> usize {\n-        self.0.len()\n-    }\n-\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for Bytes<'_> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl TrustedLen for Bytes<'_> {}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl TrustedRandomAccess for Bytes<'_> {\n-    fn may_have_side_effect() -> bool {\n-        false\n-    }\n-}\n-\n-/// This macro generates a Clone impl for string pattern API\n-/// wrapper types of the form X<'a, P>\n-macro_rules! derive_pattern_clone {\n-    (clone $t:ident with |$s:ident| $e:expr) => {\n-        impl<'a, P> Clone for $t<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: Clone>,\n-        {\n-            fn clone(&self) -> Self {\n-                let $s = self;\n-                $e\n-            }\n-        }\n-    };\n-}\n-\n-/// This macro generates two public iterator structs\n-/// wrapping a private internal one that makes use of the `Pattern` API.\n-///\n-/// For all patterns `P: Pattern<'a>` the following items will be\n-/// generated (generics omitted):\n-///\n-/// struct $forward_iterator($internal_iterator);\n-/// struct $reverse_iterator($internal_iterator);\n-///\n-/// impl Iterator for $forward_iterator\n-/// { /* internal ends up calling Searcher::next_match() */ }\n-///\n-/// impl DoubleEndedIterator for $forward_iterator\n-///       where P::Searcher: DoubleEndedSearcher\n-/// { /* internal ends up calling Searcher::next_match_back() */ }\n-///\n-/// impl Iterator for $reverse_iterator\n-///       where P::Searcher: ReverseSearcher\n-/// { /* internal ends up calling Searcher::next_match_back() */ }\n-///\n-/// impl DoubleEndedIterator for $reverse_iterator\n-///       where P::Searcher: DoubleEndedSearcher\n-/// { /* internal ends up calling Searcher::next_match() */ }\n-///\n-/// The internal one is defined outside the macro, and has almost the same\n-/// semantic as a DoubleEndedIterator by delegating to `pattern::Searcher` and\n-/// `pattern::ReverseSearcher` for both forward and reverse iteration.\n-///\n-/// \"Almost\", because a `Searcher` and a `ReverseSearcher` for a given\n-/// `Pattern` might not return the same elements, so actually implementing\n-/// `DoubleEndedIterator` for it would be incorrect.\n-/// (See the docs in `str::pattern` for more details)\n-///\n-/// However, the internal struct still represents a single ended iterator from\n-/// either end, and depending on pattern is also a valid double ended iterator,\n-/// so the two wrapper structs implement `Iterator`\n-/// and `DoubleEndedIterator` depending on the concrete pattern type, leading\n-/// to the complex impls seen above.\n-macro_rules! generate_pattern_iterators {\n-    {\n-        // Forward iterator\n-        forward:\n-            $(#[$forward_iterator_attribute:meta])*\n-            struct $forward_iterator:ident;\n-\n-        // Reverse iterator\n-        reverse:\n-            $(#[$reverse_iterator_attribute:meta])*\n-            struct $reverse_iterator:ident;\n-\n-        // Stability of all generated items\n-        stability:\n-            $(#[$common_stability_attribute:meta])*\n-\n-        // Internal almost-iterator that is being delegated to\n-        internal:\n-            $internal_iterator:ident yielding ($iterty:ty);\n-\n-        // Kind of delegation - either single ended or double ended\n-        delegate $($t:tt)*\n-    } => {\n-        $(#[$forward_iterator_attribute])*\n-        $(#[$common_stability_attribute])*\n-        pub struct $forward_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> fmt::Debug for $forward_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: fmt::Debug>,\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_tuple(stringify!($forward_iterator))\n-                    .field(&self.0)\n-                    .finish()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n-            type Item = $iterty;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$iterty> {\n-                self.0.next()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> Clone for $forward_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: Clone>,\n-        {\n-            fn clone(&self) -> Self {\n-                $forward_iterator(self.0.clone())\n-            }\n-        }\n-\n-        $(#[$reverse_iterator_attribute])*\n-        $(#[$common_stability_attribute])*\n-        pub struct $reverse_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> fmt::Debug for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: fmt::Debug>,\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_tuple(stringify!($reverse_iterator))\n-                    .field(&self.0)\n-                    .finish()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> Iterator for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n-        {\n-            type Item = $iterty;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$iterty> {\n-                self.0.next_back()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> Clone for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: Clone>,\n-        {\n-            fn clone(&self) -> Self {\n-                $reverse_iterator(self.0.clone())\n-            }\n-        }\n-\n-        #[stable(feature = \"fused\", since = \"1.26.0\")]\n-        impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n-\n-        #[stable(feature = \"fused\", since = \"1.26.0\")]\n-        impl<'a, P> FusedIterator for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n-        {}\n-\n-        generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n-                                                $forward_iterator,\n-                                                $reverse_iterator, $iterty);\n-    };\n-    {\n-        double ended; with $(#[$common_stability_attribute:meta])*,\n-                           $forward_iterator:ident,\n-                           $reverse_iterator:ident, $iterty:ty\n-    } => {\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> DoubleEndedIterator for $forward_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n-        {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$iterty> {\n-                self.0.next_back()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> DoubleEndedIterator for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n-        {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$iterty> {\n-                self.0.next()\n-            }\n-        }\n-    };\n-    {\n-        single ended; with $(#[$common_stability_attribute:meta])*,\n-                           $forward_iterator:ident,\n-                           $reverse_iterator:ident, $iterty:ty\n-    } => {}\n-}\n-\n-derive_pattern_clone! {\n-    clone SplitInternal\n-    with |s| SplitInternal { matcher: s.matcher.clone(), ..*s }\n-}\n-\n-struct SplitInternal<'a, P: Pattern<'a>> {\n-    start: usize,\n-    end: usize,\n-    matcher: P::Searcher,\n-    allow_trailing_empty: bool,\n-    finished: bool,\n-}\n-\n-impl<'a, P> fmt::Debug for SplitInternal<'a, P>\n-where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SplitInternal\")\n-            .field(\"start\", &self.start)\n-            .field(\"end\", &self.end)\n-            .field(\"matcher\", &self.matcher)\n-            .field(\"allow_trailing_empty\", &self.allow_trailing_empty)\n-            .field(\"finished\", &self.finished)\n-            .finish()\n-    }\n-}\n-\n-impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n-    #[inline]\n-    fn get_end(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n-            self.finished = true;\n-            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n-            unsafe {\n-                let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n-                Some(string)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match() {\n-            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n-            Some((a, b)) => unsafe {\n-                let elt = haystack.get_unchecked(self.start..a);\n-                self.start = b;\n-                Some(elt)\n-            },\n-            None => self.get_end(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_inclusive(&mut self) -> Option<&'a str> {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match() {\n-            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n-            // and self.start is either the start of the original string,\n-            // or `b` was assigned to it, so it also lies on unicode boundary.\n-            Some((_, b)) => unsafe {\n-                let elt = haystack.get_unchecked(self.start..b);\n-                self.start = b;\n-                Some(elt)\n-            },\n-            None => self.get_end(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        if !self.allow_trailing_empty {\n-            self.allow_trailing_empty = true;\n-            match self.next_back() {\n-                Some(elt) if !elt.is_empty() => return Some(elt),\n-                _ => {\n-                    if self.finished {\n-                        return None;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match_back() {\n-            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n-            Some((a, b)) => unsafe {\n-                let elt = haystack.get_unchecked(b..self.end);\n-                self.end = a;\n-                Some(elt)\n-            },\n-            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n-            None => unsafe {\n-                self.finished = true;\n-                Some(haystack.get_unchecked(self.start..self.end))\n-            },\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_back_inclusive(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        if !self.allow_trailing_empty {\n-            self.allow_trailing_empty = true;\n-            match self.next_back_inclusive() {\n-                Some(elt) if !elt.is_empty() => return Some(elt),\n-                _ => {\n-                    if self.finished {\n-                        return None;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match_back() {\n-            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n-            // and self.end is either the end of the original string,\n-            // or `b` was assigned to it, so it also lies on unicode boundary.\n-            Some((_, b)) => unsafe {\n-                let elt = haystack.get_unchecked(b..self.end);\n-                self.end = b;\n-                Some(elt)\n-            },\n-            // SAFETY: self.start is either the start of the original string,\n-            // or start of a substring that represents the part of the string that hasn't\n-            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n-            // self.end is either the end of the original string,\n-            // or `b` was assigned to it, so it also lies on unicode boundary.\n-            None => unsafe {\n-                self.finished = true;\n-                Some(haystack.get_unchecked(self.start..self.end))\n-            },\n-        }\n-    }\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`split`].\n-        ///\n-        /// [`split`]: str::split\n-        struct Split;\n-    reverse:\n-        /// Created with the method [`rsplit`].\n-        ///\n-        /// [`rsplit`]: str::rsplit\n-        struct RSplit;\n-    stability:\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    internal:\n-        SplitInternal yielding (&'a str);\n-    delegate double ended;\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`split_terminator`].\n-        ///\n-        /// [`split_terminator`]: str::split_terminator\n-        struct SplitTerminator;\n-    reverse:\n-        /// Created with the method [`rsplit_terminator`].\n-        ///\n-        /// [`rsplit_terminator`]: str::rsplit_terminator\n-        struct RSplitTerminator;\n-    stability:\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    internal:\n-        SplitInternal yielding (&'a str);\n-    delegate double ended;\n-}\n-\n-derive_pattern_clone! {\n-    clone SplitNInternal\n-    with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n-}\n-\n-struct SplitNInternal<'a, P: Pattern<'a>> {\n-    iter: SplitInternal<'a, P>,\n-    /// The number of splits remaining\n-    count: usize,\n-}\n-\n-impl<'a, P> fmt::Debug for SplitNInternal<'a, P>\n-where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SplitNInternal\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"count\", &self.count)\n-            .finish()\n-    }\n-}\n-\n-impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        match self.count {\n-            0 => None,\n-            1 => {\n-                self.count = 0;\n-                self.iter.get_end()\n-            }\n-            _ => {\n-                self.count -= 1;\n-                self.iter.next()\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        match self.count {\n-            0 => None,\n-            1 => {\n-                self.count = 0;\n-                self.iter.get_end()\n-            }\n-            _ => {\n-                self.count -= 1;\n-                self.iter.next_back()\n-            }\n-        }\n-    }\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`splitn`].\n-        ///\n-        /// [`splitn`]: str::splitn\n-        struct SplitN;\n-    reverse:\n-        /// Created with the method [`rsplitn`].\n-        ///\n-        /// [`rsplitn`]: str::rsplitn\n-        struct RSplitN;\n-    stability:\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    internal:\n-        SplitNInternal yielding (&'a str);\n-    delegate single ended;\n-}\n-\n-derive_pattern_clone! {\n-    clone MatchIndicesInternal\n-    with |s| MatchIndicesInternal(s.0.clone())\n-}\n-\n-struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);\n-\n-impl<'a, P> fmt::Debug for MatchIndicesInternal<'a, P>\n-where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MatchIndicesInternal\").field(&self.0).finish()\n-    }\n-}\n-\n-impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, &'a str)> {\n-        self.0\n-            .next_match()\n-            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, &'a str)>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        self.0\n-            .next_match_back()\n-            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n-    }\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`match_indices`].\n-        ///\n-        /// [`match_indices`]: str::match_indices\n-        struct MatchIndices;\n-    reverse:\n-        /// Created with the method [`rmatch_indices`].\n-        ///\n-        /// [`rmatch_indices`]: str::rmatch_indices\n-        struct RMatchIndices;\n-    stability:\n-        #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    internal:\n-        MatchIndicesInternal yielding ((usize, &'a str));\n-    delegate double ended;\n-}\n-\n-derive_pattern_clone! {\n-    clone MatchesInternal\n-    with |s| MatchesInternal(s.0.clone())\n-}\n-\n-struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);\n-\n-impl<'a, P> fmt::Debug for MatchesInternal<'a, P>\n-where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MatchesInternal\").field(&self.0).finish()\n-    }\n-}\n-\n-impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-        self.0.next_match().map(|(a, b)| unsafe {\n-            // Indices are known to be on utf8 boundaries\n-            self.0.haystack().get_unchecked(a..b)\n-        })\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-        self.0.next_match_back().map(|(a, b)| unsafe {\n-            // Indices are known to be on utf8 boundaries\n-            self.0.haystack().get_unchecked(a..b)\n-        })\n-    }\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`matches`].\n-        ///\n-        /// [`matches`]: str::matches\n-        struct Matches;\n-    reverse:\n-        /// Created with the method [`rmatches`].\n-        ///\n-        /// [`rmatches`]: str::rmatches\n-        struct RMatches;\n-    stability:\n-        #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    internal:\n-        MatchesInternal yielding (&'a str);\n-    delegate double ended;\n-}\n-\n-/// An iterator over the lines of a string, as string slices.\n-///\n-/// This struct is created with the [`lines`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`lines`]: str::lines\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone, Debug)]\n-pub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Lines<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a str> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for Lines<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for Lines<'_> {}\n-\n-/// Created with the method [`lines_any`].\n-///\n-/// [`lines_any`]: str::lines_any\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n-#[derive(Clone, Debug)]\n #[allow(deprecated)]\n-pub struct LinesAny<'a>(Lines<'a>);\n-\n-impl_fn_for_zst! {\n-    /// A nameable, cloneable fn type\n-    #[derive(Clone)]\n-    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n-        let l = line.len();\n-        if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n-        else { line }\n-    };\n-}\n+pub use iter::LinesAny;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a> Iterator for LinesAny<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n-}\n+pub use iter::{RSplit, RSplitTerminator, Split, SplitTerminator};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a> DoubleEndedIterator for LinesAny<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-#[allow(deprecated)]\n-impl FusedIterator for LinesAny<'_> {}\n-\n-/*\n-Section: UTF-8 validation\n-*/\n-\n-// use truncation to fit u64 into usize\n-const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n-\n-/// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n-#[inline]\n-fn contains_nonascii(x: usize) -> bool {\n-    (x & NONASCII_MASK) != 0\n-}\n-\n-/// Walks through `v` checking that it's a valid UTF-8 sequence,\n-/// returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n-#[inline(always)]\n-fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n-    let mut index = 0;\n-    let len = v.len();\n-\n-    let usize_bytes = mem::size_of::<usize>();\n-    let ascii_block_size = 2 * usize_bytes;\n-    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n-    let align = v.as_ptr().align_offset(usize_bytes);\n-\n-    while index < len {\n-        let old_offset = index;\n-        macro_rules! err {\n-            ($error_len: expr) => {\n-                return Err(Utf8Error { valid_up_to: old_offset, error_len: $error_len });\n-            };\n-        }\n-\n-        macro_rules! next {\n-            () => {{\n-                index += 1;\n-                // we needed data, but there was none: error!\n-                if index >= len {\n-                    err!(None)\n-                }\n-                v[index]\n-            }};\n-        }\n-\n-        let first = v[index];\n-        if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as usize];\n-            // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n-            //        first  C2 80        last DF BF\n-            // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n-            //        first  E0 A0 80     last EF BF BF\n-            //   excluding surrogates codepoints  \\u{d800} to  \\u{dfff}\n-            //               ED A0 80 to       ED BF BF\n-            // 4-byte encoding is for codepoints \\u{1000}0 to \\u{10ff}ff\n-            //        first  F0 90 80 80  last F4 8F BF BF\n-            //\n-            // Use the UTF-8 syntax from the RFC\n-            //\n-            // https://tools.ietf.org/html/rfc3629\n-            // UTF8-1      = %x00-7F\n-            // UTF8-2      = %xC2-DF UTF8-tail\n-            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n-            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n-            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n-            //               %xF4 %x80-8F 2( UTF8-tail )\n-            match w {\n-                2 => {\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(1))\n-                    }\n-                }\n-                3 => {\n-                    match (first, next!()) {\n-                        (0xE0, 0xA0..=0xBF)\n-                        | (0xE1..=0xEC, 0x80..=0xBF)\n-                        | (0xED, 0x80..=0x9F)\n-                        | (0xEE..=0xEF, 0x80..=0xBF) => {}\n-                        _ => err!(Some(1)),\n-                    }\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(2))\n-                    }\n-                }\n-                4 => {\n-                    match (first, next!()) {\n-                        (0xF0, 0x90..=0xBF) | (0xF1..=0xF3, 0x80..=0xBF) | (0xF4, 0x80..=0x8F) => {}\n-                        _ => err!(Some(1)),\n-                    }\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(2))\n-                    }\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(3))\n-                    }\n-                }\n-                _ => err!(Some(1)),\n-            }\n-            index += 1;\n-        } else {\n-            // Ascii case, try to skip forward quickly.\n-            // When the pointer is aligned, read 2 words of data per iteration\n-            // until we find a word containing a non-ascii byte.\n-            if align != usize::MAX && align.wrapping_sub(index) % usize_bytes == 0 {\n-                let ptr = v.as_ptr();\n-                while index < blocks_end {\n-                    // SAFETY: since `align - index` and `ascii_block_size` are\n-                    // multiples of `usize_bytes`, `block = ptr.add(index)` is\n-                    // always aligned with a `usize` so it's safe to dereference\n-                    // both `block` and `block.offset(1)`.\n-                    unsafe {\n-                        let block = ptr.add(index) as *const usize;\n-                        // break if there is a nonascii byte\n-                        let zu = contains_nonascii(*block);\n-                        let zv = contains_nonascii(*block.offset(1));\n-                        if zu | zv {\n-                            break;\n-                        }\n-                    }\n-                    index += ascii_block_size;\n-                }\n-                // step from the point where the wordwise loop stopped\n-                while index < len && v[index] < 128 {\n-                    index += 1;\n-                }\n-            } else {\n-                index += 1;\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-// https://tools.ietf.org/html/rfc3629\n-static UTF8_CHAR_WIDTH: [u8; 256] = [\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x1F\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x3F\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x5F\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x7F\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-    0, // 0x9F\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-    0, // 0xBF\n-    0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-    2, // 0xDF\n-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, // 0xEF\n-    4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0xFF\n-];\n-\n-/// Given a first byte, determines how many bytes are in this UTF-8 character.\n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[inline]\n-pub fn utf8_char_width(b: u8) -> usize {\n-    UTF8_CHAR_WIDTH[b as usize] as usize\n-}\n-\n-/// Mask of the value bits of a continuation byte.\n-const CONT_MASK: u8 = 0b0011_1111;\n-/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte.\n-const TAG_CONT_U8: u8 = 0b1000_0000;\n+pub use iter::{RSplitN, SplitN};\n \n-/*\n-Section: Trait implementations\n-*/\n-\n-mod traits {\n-    use crate::cmp::Ordering;\n-    use crate::ops;\n-    use crate::ptr;\n-    use crate::slice::SliceIndex;\n-\n-    /// Implements ordering of strings.\n-    ///\n-    /// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n-    /// points based on their positions in the code charts. This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n-    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n-    /// the `str` type.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Ord for str {\n-        #[inline]\n-        fn cmp(&self, other: &str) -> Ordering {\n-            self.as_bytes().cmp(other.as_bytes())\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl PartialEq for str {\n-        #[inline]\n-        fn eq(&self, other: &str) -> bool {\n-            self.as_bytes() == other.as_bytes()\n-        }\n-        #[inline]\n-        fn ne(&self, other: &str) -> bool {\n-            !(*self).eq(other)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Eq for str {}\n-\n-    /// Implements comparison operations on strings.\n-    ///\n-    /// Strings are compared lexicographically by their byte values. This compares Unicode code\n-    /// points based on their positions in the code charts. This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n-    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n-    /// the `str` type.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl PartialOrd for str {\n-        #[inline]\n-        fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<I> ops::Index<I> for str\n-    where\n-        I: SliceIndex<str>,\n-    {\n-        type Output = I::Output;\n-\n-        #[inline]\n-        fn index(&self, index: I) -> &I::Output {\n-            index.index(self)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<I> ops::IndexMut<I> for str\n-    where\n-        I: SliceIndex<str>,\n-    {\n-        #[inline]\n-        fn index_mut(&mut self, index: I) -> &mut I::Output {\n-            index.index_mut(self)\n-        }\n-    }\n+#[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+pub use iter::{Matches, RMatches};\n \n-    #[inline(never)]\n-    #[cold]\n-    #[track_caller]\n-    fn str_index_overflow_fail() -> ! {\n-        panic!(\"attempted to index str up to maximum usize\");\n-    }\n+#[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+pub use iter::{MatchIndices, RMatchIndices};\n \n-    /// Implements substring slicing with syntax `&self[..]` or `&mut self[..]`.\n-    ///\n-    /// Returns a slice of the whole string, i.e., returns `&self` or `&mut\n-    /// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n-    /// other indexing operations, this can never panic.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeFull {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            Some(slice)\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            Some(slice)\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            slice\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            slice\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            slice\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            slice\n-        }\n-    }\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub use iter::EncodeUtf16;\n \n-    /// Implements substring slicing with syntax `&self[begin .. end]` or `&mut\n-    /// self[begin .. end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`, `end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` or `end` does not point to the starting byte offset of\n-    /// a character (as defined by `is_char_boundary`), if `begin > end`, or if\n-    /// `end > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(&s[0 .. 1], \"L\");\n-    ///\n-    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // &s[2 ..3];\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // &s[1 .. 8];\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // &s[3 .. 100];\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::Range<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.start <= self.end\n-                && slice.is_char_boundary(self.start)\n-                && slice.is_char_boundary(self.end)\n-            {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                // We also checked char boundaries, so this is valid UTF-8.\n-                Some(unsafe { &*self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.start <= self.end\n-                && slice.is_char_boundary(self.start)\n-                && slice.is_char_boundary(self.end)\n-            {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                // We know the pointer is unique because we got it from `slice`.\n-                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            let slice = slice as *const [u8];\n-            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n-            // which satisfies all the conditions for `add`.\n-            let ptr = unsafe { slice.as_ptr().add(self.start) };\n-            let len = self.end - self.start;\n-            ptr::slice_from_raw_parts(ptr, len) as *const str\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            let slice = slice as *mut [u8];\n-            // SAFETY: see comments for `get_unchecked`.\n-            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n-            let len = self.end - self.start;\n-            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            let (start, end) = (self.start, self.end);\n-            match self.get(slice) {\n-                Some(s) => s,\n-                None => super::slice_error_fail(slice, start, end),\n-            }\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            // cannot reuse `get` as above, because of NLL trouble\n-            if self.start <= self.end\n-                && slice.is_char_boundary(self.start)\n-                && slice.is_char_boundary(self.end)\n-            {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                unsafe { &mut *self.get_unchecked_mut(slice) }\n-            } else {\n-                super::slice_error_fail(slice, self.start, self.end)\n-            }\n-        }\n-    }\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+pub use iter::{EscapeDebug, EscapeDefault, EscapeUnicode};\n \n-    /// Implements substring slicing with syntax `&self[.. end]` or `&mut\n-    /// self[.. end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range [`0`, `end`).\n-    /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `end` does not point to the starting byte offset of a\n-    /// character (as defined by `is_char_boundary`), or if `end > len`.\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &*self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            let slice = slice as *const [u8];\n-            let ptr = slice.as_ptr();\n-            ptr::slice_from_raw_parts(ptr, self.end) as *const str\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            let slice = slice as *mut [u8];\n-            let ptr = slice.as_mut_ptr();\n-            ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            let end = self.end;\n-            match self.get(slice) {\n-                Some(s) => s,\n-                None => super::slice_error_fail(slice, 0, end),\n-            }\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                unsafe { &mut *self.get_unchecked_mut(slice) }\n-            } else {\n-                super::slice_error_fail(slice, 0, self.end)\n-            }\n-        }\n-    }\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+pub use iter::SplitAsciiWhitespace;\n \n-    /// Implements substring slicing with syntax `&self[begin ..]` or `&mut\n-    /// self[begin ..]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range [`begin`,\n-    /// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n-    /// len]`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` does not point to the starting byte offset of\n-    /// a character (as defined by `is_char_boundary`), or if `begin > len`.\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &*self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            let slice = slice as *const [u8];\n-            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n-            // which satisfies all the conditions for `add`.\n-            let ptr = unsafe { slice.as_ptr().add(self.start) };\n-            let len = slice.len() - self.start;\n-            ptr::slice_from_raw_parts(ptr, len) as *const str\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            let slice = slice as *mut [u8];\n-            // SAFETY: identical to `get_unchecked`.\n-            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n-            let len = slice.len() - self.start;\n-            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            let (start, end) = (self.start, slice.len());\n-            match self.get(slice) {\n-                Some(s) => s,\n-                None => super::slice_error_fail(slice, start, end),\n-            }\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                unsafe { &mut *self.get_unchecked_mut(slice) }\n-            } else {\n-                super::slice_error_fail(slice, self.start, slice.len())\n-            }\n-        }\n-    }\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+use iter::SplitInclusive;\n \n-    /// Implements substring slicing with syntax `&self[begin ..= end]` or `&mut\n-    /// self[begin ..= end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`, `end`]. Equivalent to `&self [begin .. end + 1]` or `&mut\n-    /// self[begin .. end + 1]`, except if `end` has the maximum value for\n-    /// `usize`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` does not point to the starting byte offset of\n-    /// a character (as defined by `is_char_boundary`), if `end` does not point\n-    /// to the ending byte offset of a character (`end + 1` is either a starting\n-    /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if *self.end() == usize::MAX {\n-                None\n-            } else {\n-                (*self.start()..self.end() + 1).get(slice)\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if *self.end() == usize::MAX {\n-                None\n-            } else {\n-                (*self.start()..self.end() + 1).get_mut(slice)\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-            unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-            unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            if *self.end() == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (*self.start()..self.end() + 1).index(slice)\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if *self.end() == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (*self.start()..self.end() + 1).index_mut(slice)\n-        }\n-    }\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+pub use validations::next_code_point;\n \n-    /// Implements substring slicing with syntax `&self[..= end]` or `&mut\n-    /// self[..= end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range [0, `end`].\n-    /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n-    /// value for `usize`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `end` does not point to the ending byte offset of a character\n-    /// (`end + 1` is either a starting byte offset as defined by\n-    /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-            unsafe { (..self.end + 1).get_unchecked(slice) }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-            unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            if self.end == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (..self.end + 1).index(slice)\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if self.end == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (..self.end + 1).index_mut(slice)\n-        }\n-    }\n-}\n+use iter::MatchIndicesInternal;\n+use iter::SplitInternal;\n+use iter::{MatchesInternal, SplitNInternal};\n \n-// truncate `&str` to length at most equal to `max`\n-// return `true` if it were truncated, and the new str.\n-fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n-    if max >= s.len() {\n-        (false, s)\n-    } else {\n-        while !s.is_char_boundary(max) {\n-            max -= 1;\n-        }\n-        (true, &s[..max])\n-    }\n-}\n+use validations::truncate_to_char_boundary;\n \n #[inline(never)]\n #[cold]\n@@ -4549,22 +2413,6 @@ impl str {\n     }\n }\n \n-impl_fn_for_zst! {\n-    #[derive(Clone)]\n-    struct CharEscapeDebugContinue impl Fn = |c: char| -> char::EscapeDebug {\n-        c.escape_debug_ext(false)\n-    };\n-\n-    #[derive(Clone)]\n-    struct CharEscapeUnicode impl Fn = |c: char| -> char::EscapeUnicode {\n-        c.escape_unicode()\n-    };\n-    #[derive(Clone)]\n-    struct CharEscapeDefault impl Fn = |c: char| -> char::EscapeDefault {\n-        c.escape_default()\n-    };\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<[u8]> for str {\n     #[inline]\n@@ -4590,45 +2438,29 @@ impl Default for &mut str {\n     }\n }\n \n-/// An iterator over the non-whitespace substrings of a string,\n-/// separated by any amount of whitespace.\n-///\n-/// This struct is created by the [`split_whitespace`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_whitespace`]: str::split_whitespace\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-#[derive(Clone, Debug)]\n-pub struct SplitWhitespace<'a> {\n-    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n-}\n+impl_fn_for_zst! {\n+    /// A nameable, cloneable fn type\n+    #[derive(Clone)]\n+    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n+        let l = line.len();\n+        if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n+        else { line }\n+    };\n \n-/// An iterator over the non-ASCII-whitespace substrings of a string,\n-/// separated by any amount of ASCII whitespace.\n-///\n-/// This struct is created by the [`split_ascii_whitespace`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_ascii_whitespace`]: str::split_ascii_whitespace\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct SplitAsciiWhitespace<'a> {\n-    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n-}\n+    #[derive(Clone)]\n+    struct CharEscapeDebugContinue impl Fn = |c: char| -> char::EscapeDebug {\n+        c.escape_debug_ext(false)\n+    };\n \n-/// An iterator over the substrings of a string,\n-/// terminated by a substring matching to a predicate function\n-/// Unlike `Split`, it contains the matched part as a terminator\n-/// of the subslice.\n-///\n-/// This struct is created by the [`split_inclusive`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_inclusive`]: str::split_inclusive\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-pub struct SplitInclusive<'a, P: Pattern<'a>>(SplitInternal<'a, P>);\n+    #[derive(Clone)]\n+    struct CharEscapeUnicode impl Fn = |c: char| -> char::EscapeUnicode {\n+        c.escape_unicode()\n+    };\n+    #[derive(Clone)]\n+    struct CharEscapeDefault impl Fn = |c: char| -> char::EscapeDefault {\n+        c.escape_default()\n+    };\n \n-impl_fn_for_zst! {\n     #[derive(Clone)]\n     struct IsWhitespace impl Fn = |c: char| -> bool {\n         c.is_whitespace()\n@@ -4655,223 +2487,3 @@ impl_fn_for_zst! {\n         unsafe { from_utf8_unchecked(bytes) }\n     };\n }\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> Iterator for SplitWhitespace<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.inner.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a str> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for SplitWhitespace<'_> {}\n-\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.inner.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a str> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-impl FusedIterator for SplitAsciiWhitespace<'_> {}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next_inclusive()\n-    }\n-}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SplitInclusive\").field(\"0\", &self.0).finish()\n-    }\n-}\n-\n-// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n-    fn clone(&self) -> Self {\n-        SplitInclusive(self.0.clone())\n-    }\n-}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n-    for SplitInclusive<'a, P>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back_inclusive()\n-    }\n-}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n-\n-/// An iterator of [`u16`] over the string encoded as UTF-16.\n-///\n-/// This struct is created by the [`encode_utf16`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`encode_utf16`]: str::encode_utf16\n-#[derive(Clone)]\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-pub struct EncodeUtf16<'a> {\n-    chars: Chars<'a>,\n-    extra: u16,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl fmt::Debug for EncodeUtf16<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.pad(\"EncodeUtf16 { .. }\")\n-    }\n-}\n-\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-impl<'a> Iterator for EncodeUtf16<'a> {\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0; 2];\n-        self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(&mut buf).len();\n-            if n == 2 {\n-                self.extra = buf[1];\n-            }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for EncodeUtf16<'_> {}\n-\n-/// The return type of [`str::escape_debug`].\n-#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct EscapeDebug<'a> {\n-    inner: Chain<\n-        Flatten<option::IntoIter<char::EscapeDebug>>,\n-        FlatMap<Chars<'a>, char::EscapeDebug, CharEscapeDebugContinue>,\n-    >,\n-}\n-\n-/// The return type of [`str::escape_default`].\n-#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct EscapeDefault<'a> {\n-    inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n-}\n-\n-/// The return type of [`str::escape_unicode`].\n-#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct EscapeUnicode<'a> {\n-    inner: FlatMap<Chars<'a>, char::EscapeUnicode, CharEscapeUnicode>,\n-}\n-\n-macro_rules! escape_types_impls {\n-    ($( $Name: ident ),+) => {$(\n-        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-        impl<'a> fmt::Display for $Name<'a> {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                self.clone().try_for_each(|c| f.write_char(c))\n-            }\n-        }\n-\n-        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-        impl<'a> Iterator for $Name<'a> {\n-            type Item = char;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<char> { self.inner.next() }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-            #[inline]\n-            fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-                Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-            {\n-                self.inner.try_fold(init, fold)\n-            }\n-\n-            #[inline]\n-            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                self.inner.fold(init, fold)\n-            }\n-        }\n-\n-        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-        impl<'a> FusedIterator for $Name<'a> {}\n-    )+}\n-}\n-\n-escape_types_impls!(EscapeDebug, EscapeDefault, EscapeUnicode);"}, {"sha": "4f8aa246e52322fbfd6992bb57c21a7e33f7af0a", "filename": "library/core/src/str/traits.rs", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=9bb55dc8642d811d66a7599812009cc063577e00", "patch": "@@ -0,0 +1,597 @@\n+//! Trait implementations for `str`.\n+\n+use crate::cmp::Ordering;\n+use crate::ops;\n+use crate::ptr;\n+use crate::slice::SliceIndex;\n+\n+use super::ParseBoolError;\n+\n+/// Implements ordering of strings.\n+///\n+/// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n+/// points based on their positions in the code charts. This is not necessarily the same as\n+/// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n+/// culturally-accepted standards requires locale-specific data that is outside the scope of\n+/// the `str` type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Ord for str {\n+    #[inline]\n+    fn cmp(&self, other: &str) -> Ordering {\n+        self.as_bytes().cmp(other.as_bytes())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialEq for str {\n+    #[inline]\n+    fn eq(&self, other: &str) -> bool {\n+        self.as_bytes() == other.as_bytes()\n+    }\n+    #[inline]\n+    fn ne(&self, other: &str) -> bool {\n+        !(*self).eq(other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Eq for str {}\n+\n+/// Implements comparison operations on strings.\n+///\n+/// Strings are compared lexicographically by their byte values. This compares Unicode code\n+/// points based on their positions in the code charts. This is not necessarily the same as\n+/// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n+/// culturally-accepted standards requires locale-specific data that is outside the scope of\n+/// the `str` type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialOrd for str {\n+    #[inline]\n+    fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ops::Index<I> for str\n+where\n+    I: SliceIndex<str>,\n+{\n+    type Output = I::Output;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ops::IndexMut<I> for str\n+where\n+    I: SliceIndex<str>,\n+{\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut I::Output {\n+        index.index_mut(self)\n+    }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+fn str_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index str up to maximum usize\");\n+}\n+\n+/// Implements substring slicing with syntax `&self[..]` or `&mut self[..]`.\n+///\n+/// Returns a slice of the whole string, i.e., returns `&self` or `&mut\n+/// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n+/// other indexing operations, this can never panic.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeFull {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        Some(slice)\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        Some(slice)\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        slice\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        slice\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        slice\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        slice\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[begin .. end]` or `&mut\n+/// self[begin .. end]`.\n+///\n+/// Returns a slice of the given string from the byte range\n+/// [`begin`, `end`).\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// # Panics\n+///\n+/// Panics if `begin` or `end` does not point to the starting byte offset of\n+/// a character (as defined by `is_char_boundary`), if `begin > end`, or if\n+/// `end > len`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+/// assert_eq!(&s[0 .. 1], \"L\");\n+///\n+/// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+///\n+/// // these will panic:\n+/// // byte 2 lies within `\u00f6`:\n+/// // &s[2 ..3];\n+///\n+/// // byte 8 lies within `\u8001`\n+/// // &s[1 .. 8];\n+///\n+/// // byte 100 is outside the string\n+/// // &s[3 .. 100];\n+/// ```\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::Range<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if self.start <= self.end\n+            && slice.is_char_boundary(self.start)\n+            && slice.is_char_boundary(self.end)\n+        {\n+            // SAFETY: just checked that `start` and `end` are on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            // We also checked char boundaries, so this is valid UTF-8.\n+            Some(unsafe { &*self.get_unchecked(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if self.start <= self.end\n+            && slice.is_char_boundary(self.start)\n+            && slice.is_char_boundary(self.end)\n+        {\n+            // SAFETY: just checked that `start` and `end` are on a char boundary.\n+            // We know the pointer is unique because we got it from `slice`.\n+            Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        let slice = slice as *const [u8];\n+        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+        // which satisfies all the conditions for `add`.\n+        let ptr = unsafe { slice.as_ptr().add(self.start) };\n+        let len = self.end - self.start;\n+        ptr::slice_from_raw_parts(ptr, len) as *const str\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        let slice = slice as *mut [u8];\n+        // SAFETY: see comments for `get_unchecked`.\n+        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n+        let len = self.end - self.start;\n+        ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        let (start, end) = (self.start, self.end);\n+        match self.get(slice) {\n+            Some(s) => s,\n+            None => super::slice_error_fail(slice, start, end),\n+        }\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        // cannot reuse `get` as above, because of NLL trouble\n+        if self.start <= self.end\n+            && slice.is_char_boundary(self.start)\n+            && slice.is_char_boundary(self.end)\n+        {\n+            // SAFETY: just checked that `start` and `end` are on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            unsafe { &mut *self.get_unchecked_mut(slice) }\n+        } else {\n+            super::slice_error_fail(slice, self.start, self.end)\n+        }\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[.. end]` or `&mut\n+/// self[.. end]`.\n+///\n+/// Returns a slice of the given string from the byte range [`0`, `end`).\n+/// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// # Panics\n+///\n+/// Panics if `end` does not point to the starting byte offset of a\n+/// character (as defined by `is_char_boundary`), or if `end > len`.\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if slice.is_char_boundary(self.end) {\n+            // SAFETY: just checked that `end` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &*self.get_unchecked(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if slice.is_char_boundary(self.end) {\n+            // SAFETY: just checked that `end` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        let slice = slice as *const [u8];\n+        let ptr = slice.as_ptr();\n+        ptr::slice_from_raw_parts(ptr, self.end) as *const str\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        let slice = slice as *mut [u8];\n+        let ptr = slice.as_mut_ptr();\n+        ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        let end = self.end;\n+        match self.get(slice) {\n+            Some(s) => s,\n+            None => super::slice_error_fail(slice, 0, end),\n+        }\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if slice.is_char_boundary(self.end) {\n+            // SAFETY: just checked that `end` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            unsafe { &mut *self.get_unchecked_mut(slice) }\n+        } else {\n+            super::slice_error_fail(slice, 0, self.end)\n+        }\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[begin ..]` or `&mut\n+/// self[begin ..]`.\n+///\n+/// Returns a slice of the given string from the byte range [`begin`,\n+/// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n+/// len]`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// # Panics\n+///\n+/// Panics if `begin` does not point to the starting byte offset of\n+/// a character (as defined by `is_char_boundary`), or if `begin > len`.\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if slice.is_char_boundary(self.start) {\n+            // SAFETY: just checked that `start` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &*self.get_unchecked(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if slice.is_char_boundary(self.start) {\n+            // SAFETY: just checked that `start` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        let slice = slice as *const [u8];\n+        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+        // which satisfies all the conditions for `add`.\n+        let ptr = unsafe { slice.as_ptr().add(self.start) };\n+        let len = slice.len() - self.start;\n+        ptr::slice_from_raw_parts(ptr, len) as *const str\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        let slice = slice as *mut [u8];\n+        // SAFETY: identical to `get_unchecked`.\n+        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n+        let len = slice.len() - self.start;\n+        ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        let (start, end) = (self.start, slice.len());\n+        match self.get(slice) {\n+            Some(s) => s,\n+            None => super::slice_error_fail(slice, start, end),\n+        }\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if slice.is_char_boundary(self.start) {\n+            // SAFETY: just checked that `start` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            unsafe { &mut *self.get_unchecked_mut(slice) }\n+        } else {\n+            super::slice_error_fail(slice, self.start, slice.len())\n+        }\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[begin ..= end]` or `&mut\n+/// self[begin ..= end]`.\n+///\n+/// Returns a slice of the given string from the byte range\n+/// [`begin`, `end`]. Equivalent to `&self [begin .. end + 1]` or `&mut\n+/// self[begin .. end + 1]`, except if `end` has the maximum value for\n+/// `usize`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// # Panics\n+///\n+/// Panics if `begin` does not point to the starting byte offset of\n+/// a character (as defined by `is_char_boundary`), if `end` does not point\n+/// to the ending byte offset of a character (`end + 1` is either a starting\n+/// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if *self.end() == usize::MAX {\n+            None\n+        } else {\n+            (*self.start()..self.end() + 1).get_mut(slice)\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        if *self.end() == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (*self.start()..self.end() + 1).index(slice)\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if *self.end() == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (*self.start()..self.end() + 1).index_mut(slice)\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[..= end]` or `&mut\n+/// self[..= end]`.\n+///\n+/// Returns a slice of the given string from the byte range [0, `end`].\n+/// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n+/// value for `usize`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// # Panics\n+///\n+/// Panics if `end` does not point to the ending byte offset of a character\n+/// (`end + 1` is either a starting byte offset as defined by\n+/// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { (..self.end + 1).get_unchecked(slice) }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        if self.end == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (..self.end + 1).index(slice)\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if self.end == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (..self.end + 1).index_mut(slice)\n+    }\n+}\n+\n+/// Parse a value from a string\n+///\n+/// `FromStr`'s [`from_str`] method is often used implicitly, through\n+/// [`str`]'s [`parse`] method. See [`parse`]'s documentation for examples.\n+///\n+/// [`from_str`]: FromStr::from_str\n+/// [`parse`]: str::parse\n+///\n+/// `FromStr` does not have a lifetime parameter, and so you can only parse types\n+/// that do not contain a lifetime parameter themselves. In other words, you can\n+/// parse an `i32` with `FromStr`, but not a `&i32`. You can parse a struct that\n+/// contains an `i32`, but not one that contains an `&i32`.\n+///\n+/// # Examples\n+///\n+/// Basic implementation of `FromStr` on an example `Point` type:\n+///\n+/// ```\n+/// use std::str::FromStr;\n+/// use std::num::ParseIntError;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32\n+/// }\n+///\n+/// impl FromStr for Point {\n+///     type Err = ParseIntError;\n+///\n+///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n+///         let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\n+///                                  .split(',')\n+///                                  .collect();\n+///\n+///         let x_fromstr = coords[0].parse::<i32>()?;\n+///         let y_fromstr = coords[1].parse::<i32>()?;\n+///\n+///         Ok(Point { x: x_fromstr, y: y_fromstr })\n+///     }\n+/// }\n+///\n+/// let p = Point::from_str(\"(1,2)\");\n+/// assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait FromStr: Sized {\n+    /// The associated error which can be returned from parsing.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Err;\n+\n+    /// Parses a string `s` to return a value of this type.\n+    ///\n+    /// If parsing succeeds, return the value inside [`Ok`], otherwise\n+    /// when the string is ill-formatted return an error specific to the\n+    /// inside [`Err`]. The error type is specific to implementation of the trait.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n+    ///\n+    /// [ithirtytwo]: ../../std/primitive.i32.html\n+    ///\n+    /// ```\n+    /// use std::str::FromStr;\n+    ///\n+    /// let s = \"5\";\n+    /// let x = i32::from_str(s).unwrap();\n+    ///\n+    /// assert_eq!(5, x);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_str(s: &str) -> Result<Self, Self::Err>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl FromStr for bool {\n+    type Err = ParseBoolError;\n+\n+    /// Parse a `bool` from a string.\n+    ///\n+    /// Yields a `Result<bool, ParseBoolError>`, because `s` may or may not\n+    /// actually be parseable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::str::FromStr;\n+    ///\n+    /// assert_eq!(FromStr::from_str(\"true\"), Ok(true));\n+    /// assert_eq!(FromStr::from_str(\"false\"), Ok(false));\n+    /// assert!(<bool as FromStr>::from_str(\"not even a boolean\").is_err());\n+    /// ```\n+    ///\n+    /// Note, in many cases, the `.parse()` method on `str` is more proper.\n+    ///\n+    /// ```\n+    /// assert_eq!(\"true\".parse(), Ok(true));\n+    /// assert_eq!(\"false\".parse(), Ok(false));\n+    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n+    /// ```\n+    #[inline]\n+    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n+        match s {\n+            \"true\" => Ok(true),\n+            \"false\" => Ok(false),\n+            _ => Err(ParseBoolError { _priv: () }),\n+        }\n+    }\n+}"}, {"sha": "10cf1e172e6e403b29dc85003119aea9b3c6c6b6", "filename": "library/core/src/str/validations.rs", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb55dc8642d811d66a7599812009cc063577e00/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=9bb55dc8642d811d66a7599812009cc063577e00", "patch": "@@ -0,0 +1,275 @@\n+//! Operations related to UTF-8 validation.\n+\n+use crate::mem;\n+\n+use super::Utf8Error;\n+\n+/// Returns the initial codepoint accumulator for the first byte.\n+/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+/// for width 3, and 3 bits for width 4.\n+#[inline]\n+fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n+    (byte & (0x7F >> width)) as u32\n+}\n+\n+/// Returns the value of `ch` updated with continuation byte `byte`.\n+#[inline]\n+fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n+    (ch << 6) | (byte & CONT_MASK) as u32\n+}\n+\n+/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n+/// bits `10`).\n+#[inline]\n+pub(super) fn utf8_is_cont_byte(byte: u8) -> bool {\n+    (byte & !CONT_MASK) == TAG_CONT_U8\n+}\n+\n+#[inline]\n+fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n+    match opt {\n+        Some(&byte) => byte,\n+        None => 0,\n+    }\n+}\n+\n+/// Reads the next code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[inline]\n+pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n+    // Decode UTF-8\n+    let x = *bytes.next()?;\n+    if x < 128 {\n+        return Some(x as u32);\n+    }\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [[[x y] z] w]\n+    // NOTE: Performance is sensitive to the exact formulation here\n+    let init = utf8_first_byte(x, 2);\n+    let y = unwrap_or_0(bytes.next());\n+    let mut ch = utf8_acc_cont_byte(init, y);\n+    if x >= 0xE0 {\n+        // [[x y z] w] case\n+        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n+        let z = unwrap_or_0(bytes.next());\n+        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n+        ch = init << 12 | y_z;\n+        if x >= 0xF0 {\n+            // [x y z w] case\n+            // use only the lower 3 bits of `init`\n+            let w = unwrap_or_0(bytes.next());\n+            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n+        }\n+    }\n+\n+    Some(ch)\n+}\n+\n+/// Reads the last code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[inline]\n+pub(super) fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n+where\n+    I: DoubleEndedIterator<Item = &'a u8>,\n+{\n+    // Decode UTF-8\n+    let w = match *bytes.next_back()? {\n+        next_byte if next_byte < 128 => return Some(next_byte as u32),\n+        back_byte => back_byte,\n+    };\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [x [y [z w]]]\n+    let mut ch;\n+    let z = unwrap_or_0(bytes.next_back());\n+    ch = utf8_first_byte(z, 2);\n+    if utf8_is_cont_byte(z) {\n+        let y = unwrap_or_0(bytes.next_back());\n+        ch = utf8_first_byte(y, 3);\n+        if utf8_is_cont_byte(y) {\n+            let x = unwrap_or_0(bytes.next_back());\n+            ch = utf8_first_byte(x, 4);\n+            ch = utf8_acc_cont_byte(ch, y);\n+        }\n+        ch = utf8_acc_cont_byte(ch, z);\n+    }\n+    ch = utf8_acc_cont_byte(ch, w);\n+\n+    Some(ch)\n+}\n+\n+// use truncation to fit u64 into usize\n+const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n+\n+/// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n+#[inline]\n+fn contains_nonascii(x: usize) -> bool {\n+    (x & NONASCII_MASK) != 0\n+}\n+\n+/// Walks through `v` checking that it's a valid UTF-8 sequence,\n+/// returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n+#[inline(always)]\n+pub(super) fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n+    let mut index = 0;\n+    let len = v.len();\n+\n+    let usize_bytes = mem::size_of::<usize>();\n+    let ascii_block_size = 2 * usize_bytes;\n+    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n+    let align = v.as_ptr().align_offset(usize_bytes);\n+\n+    while index < len {\n+        let old_offset = index;\n+        macro_rules! err {\n+            ($error_len: expr) => {\n+                return Err(Utf8Error { valid_up_to: old_offset, error_len: $error_len });\n+            };\n+        }\n+\n+        macro_rules! next {\n+            () => {{\n+                index += 1;\n+                // we needed data, but there was none: error!\n+                if index >= len {\n+                    err!(None)\n+                }\n+                v[index]\n+            }};\n+        }\n+\n+        let first = v[index];\n+        if first >= 128 {\n+            let w = UTF8_CHAR_WIDTH[first as usize];\n+            // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n+            //        first  C2 80        last DF BF\n+            // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n+            //        first  E0 A0 80     last EF BF BF\n+            //   excluding surrogates codepoints  \\u{d800} to  \\u{dfff}\n+            //               ED A0 80 to       ED BF BF\n+            // 4-byte encoding is for codepoints \\u{1000}0 to \\u{10ff}ff\n+            //        first  F0 90 80 80  last F4 8F BF BF\n+            //\n+            // Use the UTF-8 syntax from the RFC\n+            //\n+            // https://tools.ietf.org/html/rfc3629\n+            // UTF8-1      = %x00-7F\n+            // UTF8-2      = %xC2-DF UTF8-tail\n+            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n+            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n+            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n+            //               %xF4 %x80-8F 2( UTF8-tail )\n+            match w {\n+                2 => {\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(1))\n+                    }\n+                }\n+                3 => {\n+                    match (first, next!()) {\n+                        (0xE0, 0xA0..=0xBF)\n+                        | (0xE1..=0xEC, 0x80..=0xBF)\n+                        | (0xED, 0x80..=0x9F)\n+                        | (0xEE..=0xEF, 0x80..=0xBF) => {}\n+                        _ => err!(Some(1)),\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n+                    }\n+                }\n+                4 => {\n+                    match (first, next!()) {\n+                        (0xF0, 0x90..=0xBF) | (0xF1..=0xF3, 0x80..=0xBF) | (0xF4, 0x80..=0x8F) => {}\n+                        _ => err!(Some(1)),\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(3))\n+                    }\n+                }\n+                _ => err!(Some(1)),\n+            }\n+            index += 1;\n+        } else {\n+            // Ascii case, try to skip forward quickly.\n+            // When the pointer is aligned, read 2 words of data per iteration\n+            // until we find a word containing a non-ascii byte.\n+            if align != usize::MAX && align.wrapping_sub(index) % usize_bytes == 0 {\n+                let ptr = v.as_ptr();\n+                while index < blocks_end {\n+                    // SAFETY: since `align - index` and `ascii_block_size` are\n+                    // multiples of `usize_bytes`, `block = ptr.add(index)` is\n+                    // always aligned with a `usize` so it's safe to dereference\n+                    // both `block` and `block.offset(1)`.\n+                    unsafe {\n+                        let block = ptr.add(index) as *const usize;\n+                        // break if there is a nonascii byte\n+                        let zu = contains_nonascii(*block);\n+                        let zv = contains_nonascii(*block.offset(1));\n+                        if zu | zv {\n+                            break;\n+                        }\n+                    }\n+                    index += ascii_block_size;\n+                }\n+                // step from the point where the wordwise loop stopped\n+                while index < len && v[index] < 128 {\n+                    index += 1;\n+                }\n+            } else {\n+                index += 1;\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+// https://tools.ietf.org/html/rfc3629\n+static UTF8_CHAR_WIDTH: [u8; 256] = [\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x1F\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x3F\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x5F\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x7F\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, // 0x9F\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, // 0xBF\n+    0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, // 0xDF\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, // 0xEF\n+    4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0xFF\n+];\n+\n+/// Given a first byte, determines how many bytes are in this UTF-8 character.\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[inline]\n+pub fn utf8_char_width(b: u8) -> usize {\n+    UTF8_CHAR_WIDTH[b as usize] as usize\n+}\n+\n+/// Mask of the value bits of a continuation byte.\n+const CONT_MASK: u8 = 0b0011_1111;\n+/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte.\n+const TAG_CONT_U8: u8 = 0b1000_0000;\n+\n+// truncate `&str` to length at most equal to `max`\n+// return `true` if it were truncated, and the new str.\n+pub(super) fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n+    if max >= s.len() {\n+        (false, s)\n+    } else {\n+        while !s.is_char_boundary(max) {\n+            max -= 1;\n+        }\n+        (true, &s[..max])\n+    }\n+}"}]}