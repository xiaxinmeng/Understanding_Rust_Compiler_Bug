{"sha": "d59413c895e7b49ed2ad01be35871e417a57a43c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1OTQxM2M4OTVlN2I0OWVkMmFkMDFiZTM1ODcxZTQxN2E1N2E0M2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T14:21:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T21:00:05Z"}, "message": "yet another db api", "tree": {"sha": "b0615655a8344c8d079be8c7b1b1e05445c43d7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0615655a8344c8d079be8c7b1b1e05445c43d7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d59413c895e7b49ed2ad01be35871e417a57a43c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d59413c895e7b49ed2ad01be35871e417a57a43c", "html_url": "https://github.com/rust-lang/rust/commit/d59413c895e7b49ed2ad01be35871e417a57a43c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d59413c895e7b49ed2ad01be35871e417a57a43c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d7b1e442d1449a48e0b73b3db6ea270520ea039", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7b1e442d1449a48e0b73b3db6ea270520ea039", "html_url": "https://github.com/rust-lang/rust/commit/0d7b1e442d1449a48e0b73b3db6ea270520ea039"}], "stats": {"total": 532, "additions": 274, "deletions": 258}, "files": [{"sha": "1b4ee5cf31d25ad88b807d1624525ef13cb564b2", "filename": "crates/libanalysis/src/db/imp.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs?ref=d59413c895e7b49ed2ad01be35871e417a57a43c", "patch": "@@ -0,0 +1,155 @@\n+use std::{\n+    sync::Arc,\n+    any::Any,\n+    hash::{Hash, Hasher},\n+    collections::hash_map::{DefaultHasher, HashMap},\n+    iter,\n+};\n+use salsa;\n+use {FileId, imp::FileResolverImp};\n+use super::{State, Query, QueryCtx};\n+\n+pub(super) type Data = Arc<Any + Send + Sync + 'static>;\n+\n+#[derive(Debug)]\n+pub(super) struct Db {\n+    names: Arc<HashMap<salsa::QueryTypeId, &'static str>>,\n+    pub(super) imp: salsa::Db<State, Data>,\n+}\n+\n+impl Db {\n+    pub(super) fn new(mut reg: QueryRegistry) -> Db {\n+        let config = reg.config.take().unwrap();\n+        Db {\n+            names: Arc::new(reg.names),\n+            imp: salsa::Db::new(config, State::default())\n+        }\n+    }\n+    pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n+        let names = self.names.clone();\n+        let mut invalidations = salsa::Invalidations::new();\n+        invalidations.invalidate(FILE_TEXT, changed_files.iter().map(hash).map(salsa::InputFingerprint));\n+        if resolver_changed {\n+            invalidations.invalidate(FILE_SET, iter::once(salsa::InputFingerprint(hash(&()))));\n+        } else {\n+            invalidations.invalidate(FILE_SET, iter::empty());\n+        }\n+        let imp = self.imp.with_ground_data(\n+            new_state,\n+            invalidations,\n+        );\n+        Db { names, imp }\n+    }\n+    pub(super) fn extract_trace(&self, ctx: &salsa::QueryCtx<State, Data>) -> Vec<&'static str> {\n+        ctx.trace().into_iter().map(|it| self.names[&it]).collect()\n+    }\n+}\n+\n+pub(crate) trait EvalQuery {\n+    type Params;\n+    type Output;\n+    fn query_type(&self) -> salsa::QueryTypeId;\n+    fn f(&self) -> salsa::QueryFn<State, Data>;\n+    fn get(&self, &QueryCtx, Self::Params) -> Arc<Self::Output>;\n+}\n+\n+impl<T, R> EvalQuery for Query<T, R>\n+where\n+    T: Hash + Send + Sync + 'static,\n+    R: Hash + Send + Sync + 'static,\n+{\n+    type Params = T;\n+    type Output = R;\n+    fn query_type(&self) -> salsa::QueryTypeId {\n+        salsa::QueryTypeId(self.0)\n+    }\n+    fn f(&self) -> salsa::QueryFn<State, Data> {\n+        let f = self.1;\n+        Box::new(move |ctx, data| {\n+            let ctx = QueryCtx { imp: ctx };\n+            let data: &T = data.downcast_ref().unwrap();\n+            let res = f(ctx, data);\n+            let h = hash(&res);\n+            (Arc::new(res), salsa::OutputFingerprint(h))\n+        })\n+    }\n+    fn get(&self, ctx: &QueryCtx, params: Self::Params) -> Arc<Self::Output> {\n+        let query_id = salsa::QueryId(\n+            self.query_type(),\n+            salsa::InputFingerprint(hash(&params)),\n+        );\n+        let res = ctx.imp.get(query_id, Arc::new(params));\n+        res.downcast().unwrap()\n+    }\n+}\n+\n+pub(super) struct QueryRegistry {\n+    config: Option<salsa::QueryConfig<State, Data>>,\n+    names: HashMap<salsa::QueryTypeId, &'static str>,\n+}\n+\n+impl QueryRegistry {\n+    pub(super) fn new() -> QueryRegistry {\n+        let mut config = salsa::QueryConfig::<State, Data>::new();\n+        config = config.with_ground_query(\n+            FILE_TEXT, Box::new(|state, params| {\n+                let file_id: &FileId = params.downcast_ref().unwrap();\n+                let res = state.file_map[file_id].clone();\n+                let fingerprint = salsa::OutputFingerprint(hash(&res));\n+                (res, fingerprint)\n+            })\n+        );\n+        config = config.with_ground_query(\n+            FILE_SET, Box::new(|state, _params| {\n+                let file_ids: Vec<FileId> = state.file_map.keys().cloned().collect();\n+                let hash = hash(&file_ids);\n+                let file_resolver = state.file_resolver.clone();\n+                let res = (file_ids, file_resolver);\n+                let fingerprint = salsa::OutputFingerprint(hash);\n+                (Arc::new(res), fingerprint)\n+            })\n+        );\n+        let mut names = HashMap::new();\n+        names.insert(FILE_TEXT, \"FILE_TEXT\");\n+        names.insert(FILE_SET, \"FILE_SET\");\n+        QueryRegistry { config: Some(config), names }\n+    }\n+    pub(super) fn add<Q: EvalQuery>(&mut self, q: Q, name: &'static str) {\n+        let id = q.query_type();\n+        let prev = self.names.insert(id, name);\n+        assert!(prev.is_none(), \"duplicate query: {:?}\", id);\n+        let config = self.config.take().unwrap();\n+        let config = config.with_query(id, q.f());\n+        self.config= Some(config);\n+    }\n+    pub(super) fn finish(mut self) -> salsa::QueryConfig<State, Data> {\n+        self.config.take().unwrap()\n+    }\n+}\n+\n+fn hash<T: Hash>(x: &T) -> u64 {\n+    let mut hasher = DefaultHasher::new();\n+    x.hash(&mut hasher);\n+    hasher.finish()\n+}\n+\n+const FILE_TEXT: salsa::QueryTypeId = salsa::QueryTypeId(0);\n+pub(super) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n+    let query_id = salsa::QueryId(\n+        FILE_TEXT,\n+        salsa::InputFingerprint(hash(&file_id)),\n+    );\n+    let res = ctx.imp.get(query_id, Arc::new(file_id));\n+    res.downcast().unwrap()\n+}\n+\n+const FILE_SET: salsa::QueryTypeId = salsa::QueryTypeId(1);\n+pub(super) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n+    let query_id = salsa::QueryId(\n+        FILE_SET,\n+        salsa::InputFingerprint(hash(&())),\n+    );\n+    let res = ctx.imp.get(query_id, Arc::new(()));\n+    res.downcast().unwrap()\n+}\n+"}, {"sha": "a775b5f75a3d26fe3798029d3df645cacf2a5ce8", "filename": "crates/libanalysis/src/db/mod.rs", "status": "modified", "additions": 59, "deletions": 155, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs?ref=d59413c895e7b49ed2ad01be35871e417a57a43c", "patch": "@@ -1,195 +1,99 @@\n-mod queries;\n+mod imp;\n \n use std::{\n-    hash::{Hash},\n     sync::Arc,\n-    fmt::Debug,\n-    any::Any,\n-    iter,\n };\n use im;\n use salsa;\n-use {\n-    FileId,\n-    imp::{FileResolverImp},\n-};\n-\n+use {FileId, imp::FileResolverImp};\n \n-#[derive(Clone, Default)]\n+#[derive(Debug, Default, Clone)]\n pub(crate) struct State {\n-    pub(crate) resolver: FileResolverImp,\n-    pub(crate) file_map: im::HashMap<FileId, Arc<str>>,\n-}\n-\n-type Data = Arc<Any + Send + Sync + 'static>;\n-\n-pub(crate) struct QueryCtx<'a> {\n-    inner: &'a salsa::QueryCtx<State, Data>\n+    pub(crate) file_map: im::HashMap<FileId, Arc<String>>,\n+    pub(crate) file_resolver: FileResolverImp\n }\n \n+#[derive(Debug)]\n pub(crate) struct Db {\n-    inner: salsa::Db<State, Data>\n+    imp: imp::Db,\n }\n \n-struct GroundQuery<T, R> {\n-    id: u16,\n-    f: fn(&State, &T) -> R,\n-    h: fn(&R) -> u64,\n+#[derive(Clone, Copy)]\n+pub(crate) struct QueryCtx<'a> {\n+    imp: &'a salsa::QueryCtx<State, imp::Data>,\n }\n \n-pub(crate) struct Query<T, R> {\n-    pub(crate) id: u16,\n-    pub(crate) f: fn(QueryCtx, &T) -> R,\n+pub(crate) struct Query<T, R>(pub(crate) u16, pub(crate) fn(QueryCtx, &T) -> R);\n+\n+pub(crate) struct QueryRegistry {\n+    imp: imp::QueryRegistry,\n }\n \n impl Db {\n     pub(crate) fn new() -> Db {\n-        let state = Default::default();\n-        Db { inner: salsa::Db::new(query_config(), state) }\n+        let reg = QueryRegistry::new();\n+        Db { imp: imp::Db::new(reg.imp) }\n     }\n     pub(crate) fn state(&self) -> &State {\n-        self.inner.ground_data()\n+        self.imp.imp.ground_data()\n     }\n-    pub(crate) fn with_state(\n-        &self,\n-        new_state: State,\n-        updated_files: &[FileId],\n-        file_set_changed: bool,\n-    ) -> Db {\n-        let mut inv = salsa::Invalidations::new();\n-        if file_set_changed {\n-            inv.invalidate(\n-                salsa::QueryTypeId(queries::FILE_SET.id),\n-                iter::once(salsa::InputFingerprint(hash(&()))),\n-            );\n-        } else {\n-            inv.invalidate(\n-                salsa::QueryTypeId(queries::FILE_SET.id),\n-                iter::empty(),\n-            );\n-        }\n-        inv.invalidate(\n-            salsa::QueryTypeId(queries::FILE_TEXT.id),\n-            updated_files.iter().map(hash).map(salsa::InputFingerprint),\n-        );\n-        Db { inner: self.inner.with_ground_data(new_state, inv) }\n+    pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n+        Db { imp: self.imp.with_changes(new_state, changed_files, resolver_changed) }\n     }\n-    pub(crate) fn get<T, R>(&self, q: Query<T, R>, params: T) -> (Arc<R>, Vec<u16>)\n-    where\n-        T: Hash + Send + Sync + 'static,\n-        R: Send + Sync + 'static,\n-    {\n-        let query_id = salsa::QueryId(\n-            salsa::QueryTypeId(q.id),\n-            salsa::InputFingerprint(hash(&params)),\n-        );\n-        let params = Arc::new(params);\n-        let (res, events) = self.inner.get(query_id, params);\n-        let res = res.downcast().unwrap();\n-        let events = events.into_iter().map(|it| it.0).collect();\n-        (res, events)\n+    pub(crate) fn make_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> R {\n+        let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n+        f(ctx)\n+    }\n+    pub(crate) fn trace_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> (R, Vec<&'static str>) {\n+        let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n+        let res = f(ctx);\n+        let trace = self.imp.extract_trace(ctx.imp);\n+        (res, trace)\n     }\n-\n }\n \n impl<'a> QueryCtx<'a> {\n-    fn get_g<T, R>(&self, q: GroundQuery<T, R>, params: T) -> Arc<R>\n-    where\n-        T: Hash + Send + Sync + 'static,\n-        R: Send + Sync + 'static,\n-     {\n-        let query_id = salsa::QueryId(\n-            salsa::QueryTypeId(q.id),\n-            salsa::InputFingerprint(hash(&params)),\n-        );\n-        let res = self.inner.get(query_id, Arc::new(params));\n-        res.downcast().unwrap()\n-    }\n-    pub(crate) fn get<T, R>(&self, q: Query<T, R>, params: T) -> Arc<R>\n-    where\n-        T: Hash + Send + Sync + 'static,\n-        R: Send + Sync + 'static,\n-     {\n-        let query_id = salsa::QueryId(\n-            salsa::QueryTypeId(q.id),\n-            salsa::InputFingerprint(hash(&params)),\n-        );\n-        let res = self.inner.get(query_id, Arc::new(params));\n-        res.downcast().unwrap()\n+    pub(crate) fn get<Q: imp::EvalQuery>(&self, q: Q, params: Q::Params) -> Arc<Q::Output> {\n+        q.get(self, params)\n     }\n }\n \n-fn query_config() -> salsa::QueryConfig<State, Data> {\n-    let mut res = salsa::QueryConfig::new();\n-    let queries: Vec<BoxedGroundQuery> = vec![\n-        queries::FILE_TEXT.into(),\n-        queries::FILE_SET.into(),\n-    ];\n-    for q in queries {\n-        res = res.with_ground_query(q.query_type, q.f)\n-    }\n-    let mut queries: Vec<BoxedQuery> = vec![\n-        queries::FILE_SYNTAX.into(),\n-    ];\n-    ::module_map_db::queries(&mut queries);\n-    for q in queries {\n-        res = res.with_query(q.query_type, q.f);\n-    }\n-    res\n+pub(crate) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n+    imp::file_text(ctx, file_id)\n }\n \n-struct BoxedGroundQuery {\n-    query_type: salsa::QueryTypeId,\n-    f: Box<Fn(&State, &Data) -> (Data, salsa::OutputFingerprint) + Send + Sync + 'static>,\n+pub(crate) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n+    imp::file_set(ctx)\n }\n+pub(crate) use self::queries::file_syntax;\n \n-impl<T, R> From<GroundQuery<T, R>> for BoxedGroundQuery\n-where\n-    T: Send + Sync + 'static,\n-    R: Send + Sync + 'static,\n-{\n-    fn from(q: GroundQuery<T, R>) -> BoxedGroundQuery\n-    {\n-        BoxedGroundQuery {\n-            query_type: salsa::QueryTypeId(q.id),\n-            f: Box::new(move |state, data| {\n-                let data: &T = data.downcast_ref().unwrap();\n-                let res = (q.f)(state, data);\n-                let h = (q.h)(&res);\n-                (Arc::new(res), salsa::OutputFingerprint(h))\n-            })\n-        }\n-    }\n-}\n+mod queries {\n+    use libsyntax2::File;\n+    use {FileId};\n+    use super::{Query, QueryCtx, QueryRegistry, file_text};\n \n-pub(crate) struct BoxedQuery {\n-    query_type: salsa::QueryTypeId,\n-    f: Box<Fn(&salsa::QueryCtx<State, Data>, &Data) -> (Data, salsa::OutputFingerprint) + Send + Sync + 'static>,\n-}\n+    pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n+        reg.add(FILE_SYNTAX, \"FILE_SYNTAX\")\n+    }\n \n-impl<T, R> From<Query<T, R>> for BoxedQuery\n-where\n-    T: Hash + Send + Sync + 'static,\n-    R: Hash + Send + Sync + 'static,\n-{\n-    fn from(q: Query<T, R>) -> BoxedQuery\n-    {\n-        BoxedQuery {\n-            query_type: salsa::QueryTypeId(q.id),\n-            f: Box::new(move |ctx, data| {\n-                let ctx = QueryCtx { inner: ctx };\n-                let data: &T = data.downcast_ref().unwrap();\n-                let res = (q.f)(ctx, data);\n-                let h = hash(&res);\n-                (Arc::new(res), salsa::OutputFingerprint(h))\n-            })\n-        }\n+    pub(crate) fn file_syntax(ctx: QueryCtx, file_id: FileId) -> File {\n+        (&*ctx.get(FILE_SYNTAX, file_id)).clone()\n     }\n+\n+    pub(super) const FILE_SYNTAX: Query<FileId, File> = Query(16, |ctx, file_id: &FileId| {\n+        let text = file_text(ctx, *file_id);\n+        File::parse(&*text)\n+    });\n }\n \n-fn hash<T: ::std::hash::Hash>(x: &T) -> u64 {\n-    use std::hash::Hasher;\n-    let mut hasher = ::std::collections::hash_map::DefaultHasher::new();\n-    ::std::hash::Hash::hash(x, &mut hasher);\n-    hasher.finish()\n+impl QueryRegistry {\n+    fn new() -> QueryRegistry {\n+        let mut reg = QueryRegistry { imp: imp::QueryRegistry::new() };\n+        queries::register_queries(&mut reg);\n+        ::module_map_db::register_queries(&mut reg);\n+        reg\n+    }\n+    pub(crate) fn add<Q: imp::EvalQuery>(&mut self, q: Q, name: &'static str) {\n+        self.imp.add(q, name)\n+    }\n }"}, {"sha": "2d4aac6e93e2222d74d14119a33e3df8ad564d0d", "filename": "crates/libanalysis/src/db/queries.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0d7b1e442d1449a48e0b73b3db6ea270520ea039/crates%2Flibanalysis%2Fsrc%2Fdb%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7b1e442d1449a48e0b73b3db6ea270520ea039/crates%2Flibanalysis%2Fsrc%2Fdb%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fqueries.rs?ref=0d7b1e442d1449a48e0b73b3db6ea270520ea039", "patch": "@@ -1,43 +0,0 @@\n-use std::sync::Arc;\n-use libsyntax2::{File};\n-use {\n-    FileId, FileResolverImp,\n-    db::{Query, GroundQuery, QueryCtx, hash},\n-};\n-\n-\n-impl<'a> QueryCtx<'a> {\n-    pub(crate) fn file_set(&self) -> Arc<(Vec<FileId>, FileResolverImp)> {\n-        self.get_g(FILE_SET, ())\n-    }\n-    pub(crate) fn file_text(&self, file_id: FileId) -> Arc<str> {\n-        Arc::clone(&*self.get_g(FILE_TEXT, file_id))\n-    }\n-    pub(crate) fn file_syntax(&self, file_id: FileId) -> File {\n-        (&*self.get(FILE_SYNTAX, file_id)).clone()\n-    }\n-}\n-\n-pub(super) const FILE_TEXT: GroundQuery<FileId, Arc<str>> = GroundQuery {\n-    id: 10,\n-    f: |state, id| state.file_map[&id].clone(),\n-    h: hash,\n-};\n-\n-pub(super) const FILE_SET: GroundQuery<(), (Vec<FileId>, FileResolverImp)> = GroundQuery {\n-    id: 11,\n-    f: |state, &()| {\n-        let files = state.file_map.keys().cloned().collect();\n-        let resolver = state.resolver.clone();\n-        (files, resolver)\n-    },\n-    h: |(files, _)| hash(files),\n-};\n-\n-pub(super) const FILE_SYNTAX: Query<FileId, File> = Query {\n-    id: 20,\n-    f: |ctx, file_id: &FileId| {\n-        let text = ctx.file_text(*file_id);\n-        File::parse(&*text)\n-    }\n-};"}, {"sha": "5560e4a34a6543138ef354ffd5c5e51c633b42b1", "filename": "crates/libanalysis/src/module_map_db/mod.rs", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs?ref=d59413c895e7b49ed2ad01be35871e417a57a43c", "patch": "@@ -4,15 +4,16 @@ use std::sync::Arc;\n use {\n     FileId,\n     db::{\n-        BoxedQuery, Query, QueryCtx\n+        Query, QueryRegistry, QueryCtx,\n+        file_syntax, file_set\n     },\n     module_map::resolve_submodule,\n };\n \n-pub(crate) fn queries(acc: &mut Vec<BoxedQuery>) {\n-    acc.push(MODULE_DESCR.into());\n-    acc.push(RESOLVE_SUBMODULE.into());\n-    acc.push(PARENT_MODULE.into());\n+pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n+    reg.add(MODULE_DESCR, \"MODULE_DESCR\");\n+    reg.add(RESOLVE_SUBMODULE, \"RESOLVE_SUBMODULE\");\n+    reg.add(PARENT_MODULE, \"PARENT_MODULE\");\n }\n \n impl<'a> QueryCtx<'a> {\n@@ -24,41 +25,32 @@ impl<'a> QueryCtx<'a> {\n     }\n }\n \n-pub(crate) const MODULE_DESCR: Query<FileId, descr::ModuleDescr> = Query {\n-    id: 30,\n-    f: |ctx, &file_id| {\n-        let file = ctx.file_syntax(file_id);\n-        descr::ModuleDescr::new(file.ast())\n-    }\n-};\n-\n-pub(crate) const RESOLVE_SUBMODULE: Query<(FileId, descr::Submodule), Vec<FileId>> = Query {\n-    id: 31,\n-    f: |ctx, params| {\n-        let files = ctx.file_set();\n-        resolve_submodule(params.0, &params.1.name, &files.1).0\n-    }\n-};\n-\n-pub(crate) const PARENT_MODULE: Query<FileId, Vec<FileId>> = Query {\n-    id: 40,\n-    f: |ctx, file_id| {\n-        let files = ctx.file_set();\n-        let res = files.0.iter()\n-            .map(|&parent_id| (parent_id, ctx.module_descr(parent_id)))\n-            .filter(|(parent_id, descr)| {\n-                descr.submodules.iter()\n-                    .any(|subm| {\n-                        ctx.resolve_submodule(*parent_id, subm.clone())\n-                            .iter()\n-                            .any(|it| it == file_id)\n-                    })\n-            })\n-            .map(|(id, _)| id)\n-            .collect();\n-        res\n-    }\n-};\n+const MODULE_DESCR: Query<FileId, descr::ModuleDescr> = Query(30, |ctx, &file_id| {\n+    let file = file_syntax(ctx, file_id);\n+    descr::ModuleDescr::new(file.ast())\n+});\n+\n+const RESOLVE_SUBMODULE: Query<(FileId, descr::Submodule), Vec<FileId>> = Query(31, |ctx, params| {\n+    let files = file_set(ctx);\n+    resolve_submodule(params.0, &params.1.name, &files.1).0\n+});\n+\n+const PARENT_MODULE: Query<FileId, Vec<FileId>> = Query(40, |ctx, file_id| {\n+    let files = file_set(ctx);\n+    let res = files.0.iter()\n+        .map(|&parent_id| (parent_id, ctx.module_descr(parent_id)))\n+        .filter(|(parent_id, descr)| {\n+            descr.submodules.iter()\n+                .any(|subm| {\n+                    ctx.resolve_submodule(*parent_id, subm.clone())\n+                        .iter()\n+                        .any(|it| it == file_id)\n+                })\n+        })\n+        .map(|(id, _)| id)\n+        .collect();\n+    res\n+});\n \n #[cfg(test)]\n mod tests {\n@@ -107,34 +99,36 @@ mod tests {\n             self.next_file_id += 1;\n             self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n             let mut new_state = self.db.state().clone();\n-            new_state.file_map.insert(file_id, text.to_string().into_boxed_str().into());\n-            new_state.resolver = FileResolverImp::new(\n+            new_state.file_map.insert(file_id, Arc::new(text.to_string()));\n+            new_state.file_resolver = FileResolverImp::new(\n                 Arc::new(FileMap(self.fm.clone()))\n             );\n-            self.db = self.db.with_state(new_state, &[file_id], true);\n+            self.db = self.db.with_changes(new_state, &[file_id], true);\n             file_id\n         }\n         fn remove_file(&mut self, file_id: FileId) {\n             self.fm.remove(&file_id);\n             let mut new_state = self.db.state().clone();\n             new_state.file_map.remove(&file_id);\n-            new_state.resolver = FileResolverImp::new(\n+            new_state.file_resolver = FileResolverImp::new(\n                 Arc::new(FileMap(self.fm.clone()))\n             );\n-            self.db = self.db.with_state(new_state, &[file_id], true);\n+            self.db = self.db.with_changes(new_state, &[file_id], true);\n         }\n         fn change_file(&mut self, file_id: FileId, new_text: &str) {\n             let mut new_state = self.db.state().clone();\n-            new_state.file_map.insert(file_id, new_text.to_string().into_boxed_str().into());\n-            self.db = self.db.with_state(new_state, &[file_id], false);\n+            new_state.file_map.insert(file_id, Arc::new(new_text.to_string()));\n+            self.db = self.db.with_changes(new_state, &[file_id], false);\n         }\n         fn check_parent_modules(\n             &self,\n             file_id: FileId,\n             expected: &[FileId],\n-            queries: &[(u16, u64)]\n+            queries: &[(&'static str, u64)]\n         ) {\n-            let (actual, events) = self.db.get(PARENT_MODULE, file_id);\n+            let (actual, events) = self.db.trace_query(|ctx| {\n+                ctx.get(PARENT_MODULE, file_id)\n+            });\n             assert_eq!(actual.as_slice(), expected);\n             let mut counts = HashMap::new();\n             events.into_iter()\n@@ -156,25 +150,25 @@ mod tests {\n     fn test_parent_module() {\n         let mut f = Fixture::new();\n         let foo = f.add_file(\"/foo.rs\", \"\");\n-        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 1)]);\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n         let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 1)]);\n-        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 0)]);\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 0)]);\n \n         f.change_file(lib, \"\");\n-        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 1)]);\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n         f.change_file(lib, \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 1)]);\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n \n         f.change_file(lib, \"mod bar;\");\n-        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 1)]);\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n         f.change_file(lib, \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 1)]);\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n \n         f.remove_file(lib);\n-        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 0)]);\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 0)]);\n     }\n }"}, {"sha": "35deed37417c5ba2559669cd575f02589dfdcd7b", "filename": "crates/salsa/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Fsalsa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Fsalsa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Fsrc%2Flib.rs?ref=d59413c895e7b49ed2ad01be35871e417a57a43c", "patch": "@@ -8,8 +8,8 @@ use std::{\n };\n use parking_lot::Mutex;\n \n-type GroundQueryFn<T, D> = Box<Fn(&T, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n-type QueryFn<T, D> = Box<Fn(&QueryCtx<T, D>, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n+pub type GroundQueryFn<T, D> = Box<Fn(&T, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n+pub type QueryFn<T, D> = Box<Fn(&QueryCtx<T, D>, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n \n #[derive(Debug)]\n pub struct Db<T, D> {\n@@ -118,6 +118,9 @@ where\n         self.record_dep(query_id, output_fingerprint);\n         res\n     }\n+    pub fn trace(&self) -> Vec<QueryTypeId> {\n+        ::std::mem::replace(&mut *self.executed.borrow_mut(), Vec::new())\n+    }\n \n     fn get_inner(\n         &self,\n@@ -261,12 +264,15 @@ where\n             query_config: Arc::clone(&self.query_config)\n         }\n     }\n+    pub fn query_ctx(&self) -> QueryCtx<T, D> {\n+        QueryCtx::new(self)\n+    }\n     pub fn get(\n         &self,\n         query_id: QueryId,\n         params: D,\n     ) -> (D, Vec<QueryTypeId>) {\n-        let ctx = QueryCtx::new(self);\n+        let ctx = self.query_ctx();\n         let res = ctx.get(query_id, params.into());\n         let executed = ::std::mem::replace(&mut *ctx.executed.borrow_mut(), Vec::new());\n         (res, executed)"}]}