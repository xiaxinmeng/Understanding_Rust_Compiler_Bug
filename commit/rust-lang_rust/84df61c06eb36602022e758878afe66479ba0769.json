{"sha": "84df61c06eb36602022e758878afe66479ba0769", "node_id": "C_kwDOAAsO6NoAKDg0ZGY2MWMwNmViMzY2MDIwMjJlNzU4ODc4YWZlNjY0NzliYTA3Njk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-14T14:46:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-14T14:46:26Z"}, "message": "Auto merge of #9167 - aldhsu:fix-trait-duplication-false-pos, r=flip1995\n\nFixes [`trait_duplication_in_bounds`] false positives\n\nFixes #9076 #9151 #8757.\nPartially fixes #8771.\n\nchangelog: [`trait_duplication_in_bounds`]: Reduce number of false positives.", "tree": {"sha": "a27f76ca61d8ba7e733a31346a53d2d298780eea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a27f76ca61d8ba7e733a31346a53d2d298780eea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84df61c06eb36602022e758878afe66479ba0769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84df61c06eb36602022e758878afe66479ba0769", "html_url": "https://github.com/rust-lang/rust/commit/84df61c06eb36602022e758878afe66479ba0769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84df61c06eb36602022e758878afe66479ba0769/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d5d191f6af4d4697e9b983b655aa7dd96fd966f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d5d191f6af4d4697e9b983b655aa7dd96fd966f", "html_url": "https://github.com/rust-lang/rust/commit/4d5d191f6af4d4697e9b983b655aa7dd96fd966f"}, {"sha": "8bae517c2d540dcf62bff12ba7404a23a4233d99", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bae517c2d540dcf62bff12ba7404a23a4233d99", "html_url": "https://github.com/rust-lang/rust/commit/8bae517c2d540dcf62bff12ba7404a23a4233d99"}], "stats": {"total": 815, "additions": 481, "deletions": 334}, "files": [{"sha": "0434720f79b578f8d447f100901ad51a3938c0a7", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/84df61c06eb36602022e758878afe66479ba0769/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84df61c06eb36602022e758878afe66479ba0769/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=84df61c06eb36602022e758878afe66479ba0769", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::{SpanlessEq, SpanlessHash};\n use core::hash::{Hash, Hasher};\n use if_chain::if_chain;\n use itertools::Itertools;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n@@ -103,7 +103,6 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     fn check_generics(&mut self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n         self.check_type_repetition(cx, gen);\n         check_trait_bound_duplication(cx, gen);\n-        check_bounds_or_where_duplication(cx, gen);\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n@@ -234,35 +233,61 @@ impl TraitBounds {\n }\n \n fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-    if gen.span.from_expansion() || gen.params.is_empty() || gen.predicates.is_empty() {\n+    if gen.span.from_expansion() {\n         return;\n     }\n \n-    let mut map = FxHashMap::<_, Vec<_>>::default();\n-    for predicate in gen.predicates {\n+    // Explanation:\n+    // fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+    // where T: Clone + Default, { unimplemented!(); }\n+    //       ^^^^^^^^^^^^^^^^^^\n+    //       |\n+    // collects each of these where clauses into a set keyed by generic name and comparable trait\n+    // eg. (T, Clone)\n+    let where_predicates = gen\n+        .predicates\n+        .iter()\n+        .filter_map(|pred| {\n+            if_chain! {\n+                if pred.in_where_clause();\n+                if let WherePredicate::BoundPredicate(bound_predicate) = pred;\n+                if let TyKind::Path(QPath::Resolved(_, path)) =  bound_predicate.bounded_ty.kind;\n+                then {\n+                    return Some(\n+                        rollup_traits(cx, bound_predicate.bounds, \"these where clauses contain repeated elements\")\n+                        .into_keys().map(|trait_ref| (path.res, trait_ref)))\n+                }\n+            }\n+            None\n+        })\n+        .flatten()\n+        .collect::<FxHashSet<_>>();\n+\n+    // Explanation:\n+    // fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z) ...\n+    //            ^^^^^^^^^^^^^^^^^^  ^^^^^^^\n+    //            |\n+    // compare trait bounds keyed by generic name and comparable trait to collected where\n+    // predicates eg. (T, Clone)\n+    for predicate in gen.predicates.iter().filter(|pred| !pred.in_where_clause()) {\n         if_chain! {\n-            if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n+            if let WherePredicate::BoundPredicate(bound_predicate) = predicate;\n             if bound_predicate.origin != PredicateOrigin::ImplTrait;\n             if !bound_predicate.span.from_expansion();\n-            if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n-            if let Some(segment) = segments.first();\n+            if let TyKind::Path(QPath::Resolved(_, path)) =  bound_predicate.bounded_ty.kind;\n             then {\n-                for (res_where, _, span_where) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n-                    let trait_resolutions_direct = map.entry(segment.ident).or_default();\n-                    if let Some((_, span_direct)) = trait_resolutions_direct\n-                                                .iter()\n-                                                .find(|(res_direct, _)| *res_direct == res_where) {\n+                let traits = rollup_traits(cx, bound_predicate.bounds, \"these bounds contain repeated elements\");\n+                for (trait_ref, span) in traits {\n+                    let key = (path.res, trait_ref);\n+                    if where_predicates.contains(&key) {\n                         span_lint_and_help(\n                             cx,\n                             TRAIT_DUPLICATION_IN_BOUNDS,\n-                            *span_direct,\n+                            span,\n                             \"this trait bound is already specified in the where clause\",\n                             None,\n                             \"consider removing this trait bound\",\n-                        );\n-                    }\n-                    else {\n-                        trait_resolutions_direct.push((res_where, span_where));\n+                            );\n                     }\n                 }\n             }\n@@ -273,23 +298,6 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n #[derive(PartialEq, Eq, Hash, Debug)]\n struct ComparableTraitRef(Res, Vec<Res>);\n \n-fn check_bounds_or_where_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-    if gen.span.from_expansion() {\n-        return;\n-    }\n-\n-    for predicate in gen.predicates {\n-        if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate {\n-            let msg = if predicate.in_where_clause() {\n-                \"these where clauses contain repeated elements\"\n-            } else {\n-                \"these bounds contain repeated elements\"\n-            };\n-            rollup_traits(cx, bound_predicate.bounds, msg);\n-        }\n-    }\n-}\n-\n fn get_trait_info_from_bound<'a>(bound: &'a GenericBound<'_>) -> Option<(Res, &'a [PathSegment<'a>], Span)> {\n     if let GenericBound::Trait(t, tbm) = bound {\n         let trait_path = t.trait_ref.path;\n@@ -331,7 +339,7 @@ fn into_comparable_trait_ref(trait_ref: &TraitRef<'_>) -> ComparableTraitRef {\n     )\n }\n \n-fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) {\n+fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) -> FxHashMap<ComparableTraitRef, Span> {\n     let mut map = FxHashMap::default();\n     let mut repeated_res = false;\n \n@@ -373,4 +381,6 @@ fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) {\n             );\n         }\n     }\n+\n+    map\n }"}, {"sha": "610f1f14563da053c8f032fce0354feef8ae6899", "filename": "tests/compile-test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84df61c06eb36602022e758878afe66479ba0769/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84df61c06eb36602022e758878afe66479ba0769/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=84df61c06eb36602022e758878afe66479ba0769", "patch": "@@ -394,7 +394,6 @@ const RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS: &[&str] = &[\n     \"single_component_path_imports_nested_first.rs\",\n     \"string_add.rs\",\n     \"toplevel_ref_arg_non_rustfix.rs\",\n-    \"trait_duplication_in_bounds.rs\",\n     \"unit_arg.rs\",\n     \"unnecessary_clone.rs\",\n     \"unnecessary_lazy_eval_unfixable.rs\","}, {"sha": "b4e6bf0ea1c2bb9d99fbf6fb035d227ac7253e91", "filename": "tests/ui/trait_duplication_in_bounds.fixed", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.fixed?ref=84df61c06eb36602022e758878afe66479ba0769", "patch": "@@ -0,0 +1,112 @@\n+// run-rustfix\n+#![deny(clippy::trait_duplication_in_bounds)]\n+#![allow(unused)]\n+\n+fn bad_foo<T: Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+    unimplemented!();\n+}\n+\n+fn bad_bar<T, U>(arg0: T, arg1: U)\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_bar<T: Clone + Copy, U: Clone + Copy>(arg0: T, arg1: U) {\n+    unimplemented!();\n+}\n+\n+fn good_foo<T, U>(arg0: T, arg1: U)\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n+    unimplemented!();\n+}\n+\n+trait GoodSelfTraitBound: Clone + Copy {\n+    fn f();\n+}\n+\n+trait GoodSelfWhereClause {\n+    fn f()\n+    where\n+        Self: Clone + Copy;\n+}\n+\n+trait BadSelfTraitBound: Clone {\n+    fn f();\n+}\n+\n+trait BadSelfWhereClause {\n+    fn f()\n+    where\n+        Self: Clone;\n+}\n+\n+trait GoodTraitBound<T: Clone + Copy, U: Clone + Copy> {\n+    fn f();\n+}\n+\n+trait GoodWhereClause<T, U> {\n+    fn f()\n+    where\n+        T: Clone + Copy,\n+        U: Clone + Copy;\n+}\n+\n+trait BadTraitBound<T: Clone + Copy, U: Clone + Copy> {\n+    fn f();\n+}\n+\n+trait BadWhereClause<T, U> {\n+    fn f()\n+    where\n+        T: Clone + Copy,\n+        U: Clone + Copy;\n+}\n+\n+struct GoodStructBound<T: Clone + Copy, U: Clone + Copy> {\n+    t: T,\n+    u: U,\n+}\n+\n+impl<T: Clone + Copy, U: Clone + Copy> GoodTraitBound<T, U> for GoodStructBound<T, U> {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+struct GoodStructWhereClause;\n+\n+impl<T, U> GoodTraitBound<T, U> for GoodStructWhereClause\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+fn no_error_separate_arg_bounds(program: impl AsRef<()>, dir: impl AsRef<()>, args: &[impl AsRef<()>]) {}\n+\n+trait GenericTrait<T> {}\n+\n+fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n+    unimplemented!();\n+}\n+\n+fn bad_generic<T: GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+    unimplemented!();\n+}\n+\n+mod foo {\n+    pub trait Clone {}\n+}\n+\n+fn qualified_path<T: Clone + foo::Clone>(arg0: T) {\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "7f2e96a22e6648eb27aaf1178eec55ff2c86cab5", "filename": "tests/ui/trait_duplication_in_bounds.rs", "status": "modified", "additions": 59, "deletions": 159, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=84df61c06eb36602022e758878afe66479ba0769", "patch": "@@ -1,212 +1,112 @@\n+// run-rustfix\n #![deny(clippy::trait_duplication_in_bounds)]\n #![allow(unused)]\n \n-use std::collections::BTreeMap;\n-use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+    unimplemented!();\n+}\n \n-fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+fn bad_bar<T, U>(arg0: T, arg1: U)\n where\n-    T: Clone,\n-    T: Default,\n+    T: Clone + Clone + Clone + Copy,\n+    U: Clone + Copy,\n {\n     unimplemented!();\n }\n \n-fn good_bar<T: Clone + Default>(arg: T) {\n+fn good_bar<T: Clone + Copy, U: Clone + Copy>(arg0: T, arg1: U) {\n     unimplemented!();\n }\n \n-fn good_foo<T>(arg: T)\n+fn good_foo<T, U>(arg0: T, arg1: U)\n where\n-    T: Clone + Default,\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n {\n     unimplemented!();\n }\n \n-fn good_foobar<T: Default>(arg: T)\n-where\n-    T: Clone,\n-{\n-    unimplemented!();\n+trait GoodSelfTraitBound: Clone + Copy {\n+    fn f();\n }\n \n-trait T: Default {\n+trait GoodSelfWhereClause {\n     fn f()\n     where\n-        Self: Default;\n+        Self: Clone + Copy;\n }\n \n-trait U: Default {\n+trait BadSelfTraitBound: Clone + Clone + Clone {\n+    fn f();\n+}\n+\n+trait BadSelfWhereClause {\n     fn f()\n     where\n-        Self: Clone;\n+        Self: Clone + Clone + Clone;\n+}\n+\n+trait GoodTraitBound<T: Clone + Copy, U: Clone + Copy> {\n+    fn f();\n }\n \n-trait ZZ: Default {\n-    fn g();\n-    fn h();\n+trait GoodWhereClause<T, U> {\n     fn f()\n     where\n-        Self: Default + Clone;\n+        T: Clone + Copy,\n+        U: Clone + Copy;\n }\n \n-trait BadTrait: Default + Clone {\n+trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n+    fn f();\n+}\n+\n+trait BadWhereClause<T, U> {\n     fn f()\n     where\n-        Self: Default + Clone;\n-    fn g()\n-    where\n-        Self: Default;\n-    fn h()\n-    where\n-        Self: Copy;\n+        T: Clone + Clone + Clone + Copy,\n+        U: Clone + Copy;\n }\n \n-#[derive(Default, Clone)]\n-struct Life;\n+struct GoodStructBound<T: Clone + Copy, U: Clone + Copy> {\n+    t: T,\n+    u: U,\n+}\n \n-impl T for Life {\n+impl<T: Clone + Copy, U: Clone + Copy> GoodTraitBound<T, U> for GoodStructBound<T, U> {\n     // this should not warn\n     fn f() {}\n }\n \n-impl U for Life {\n+struct GoodStructWhereClause;\n+\n+impl<T, U> GoodTraitBound<T, U> for GoodStructWhereClause\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n     // this should not warn\n     fn f() {}\n }\n \n-// should not warn\n-trait Iter: Iterator {\n-    fn into_group_btreemap<K, V>(self) -> BTreeMap<K, Vec<V>>\n-    where\n-        Self: Iterator<Item = (K, V)> + Sized,\n-        K: Ord + Eq,\n-    {\n-        unimplemented!();\n-    }\n-}\n+fn no_error_separate_arg_bounds(program: impl AsRef<()>, dir: impl AsRef<()>, args: &[impl AsRef<()>]) {}\n \n-struct Foo;\n+trait GenericTrait<T> {}\n \n-trait FooIter: Iterator<Item = Foo> {\n-    fn bar()\n-    where\n-        Self: Iterator<Item = Foo>,\n-    {\n-    }\n+fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n+    unimplemented!();\n }\n \n-// This should not lint\n-fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n-\n-mod repeated_where_clauses_or_trait_bounds {\n-    fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n-        unimplemented!();\n-    }\n-\n-    fn bad_bar<T, U>(arg0: T, arg1: U)\n-    where\n-        T: Clone + Clone + Clone + Copy,\n-        U: Clone + Copy,\n-    {\n-        unimplemented!();\n-    }\n-\n-    fn good_bar<T: Clone + Copy, U: Clone + Copy>(arg0: T, arg1: U) {\n-        unimplemented!();\n-    }\n-\n-    fn good_foo<T, U>(arg0: T, arg1: U)\n-    where\n-        T: Clone + Copy,\n-        U: Clone + Copy,\n-    {\n-        unimplemented!();\n-    }\n-\n-    trait GoodSelfTraitBound: Clone + Copy {\n-        fn f();\n-    }\n-\n-    trait GoodSelfWhereClause {\n-        fn f()\n-        where\n-            Self: Clone + Copy;\n-    }\n-\n-    trait BadSelfTraitBound: Clone + Clone + Clone {\n-        fn f();\n-    }\n-\n-    trait BadSelfWhereClause {\n-        fn f()\n-        where\n-            Self: Clone + Clone + Clone;\n-    }\n-\n-    trait GoodTraitBound<T: Clone + Copy, U: Clone + Copy> {\n-        fn f();\n-    }\n-\n-    trait GoodWhereClause<T, U> {\n-        fn f()\n-        where\n-            T: Clone + Copy,\n-            U: Clone + Copy;\n-    }\n-\n-    trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n-        fn f();\n-    }\n-\n-    trait BadWhereClause<T, U> {\n-        fn f()\n-        where\n-            T: Clone + Clone + Clone + Copy,\n-            U: Clone + Copy;\n-    }\n-\n-    struct GoodStructBound<T: Clone + Copy, U: Clone + Copy> {\n-        t: T,\n-        u: U,\n-    }\n-\n-    impl<T: Clone + Copy, U: Clone + Copy> GoodTraitBound<T, U> for GoodStructBound<T, U> {\n-        // this should not warn\n-        fn f() {}\n-    }\n-\n-    struct GoodStructWhereClause;\n-\n-    impl<T, U> GoodTraitBound<T, U> for GoodStructWhereClause\n-    where\n-        T: Clone + Copy,\n-        U: Clone + Copy,\n-    {\n-        // this should not warn\n-        fn f() {}\n-    }\n-\n-    fn no_error_separate_arg_bounds(program: impl AsRef<()>, dir: impl AsRef<()>, args: &[impl AsRef<()>]) {}\n-\n-    trait GenericTrait<T> {}\n-\n-    // This should not warn but currently does see #8757\n-    fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n-        unimplemented!();\n-    }\n-\n-    fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n-        unimplemented!();\n-    }\n+fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+    unimplemented!();\n+}\n \n-    mod foo {\n-        pub trait Clone {}\n-    }\n+mod foo {\n+    pub trait Clone {}\n+}\n \n-    fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n-        unimplemented!();\n-    }\n+fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n+    unimplemented!();\n }\n \n fn main() {}"}, {"sha": "86c593811a74f77b2eae2c3bde518d81ab14ced5", "filename": "tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 27, "deletions": 138, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=84df61c06eb36602022e758878afe66479ba0769", "patch": "@@ -1,167 +1,56 @@\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:7:15\n+error: these bounds contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:5:15\n    |\n-LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n-   |               ^^^^^\n+LL | fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n    |\n note: the lint level is defined here\n-  --> $DIR/trait_duplication_in_bounds.rs:1:9\n+  --> $DIR/trait_duplication_in_bounds.rs:2:9\n    |\n LL | #![deny(clippy::trait_duplication_in_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:7:23\n-   |\n-LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n-   |                       ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:36:15\n-   |\n-LL |         Self: Default;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:50:15\n-   |\n-LL |         Self: Default + Clone;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:56:15\n-   |\n-LL |         Self: Default + Clone;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:56:25\n-   |\n-LL |         Self: Default + Clone;\n-   |                         ^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:59:15\n-   |\n-LL |         Self: Default;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:94:15\n-   |\n-LL |         Self: Iterator<Item = Foo>,\n-   |               ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:103:19\n-   |\n-LL |     fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n-   |                   ^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:103:19\n-   |\n-LL |     fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:109:12\n-   |\n-LL |         T: Clone + Clone + Clone + Copy,\n-   |            ^^^^^\n-   |\n-   = help: consider removing this trait bound\n \n error: these where clauses contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:109:12\n+  --> $DIR/trait_duplication_in_bounds.rs:11:8\n    |\n-LL |         T: Clone + Clone + Clone + Copy,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+LL |     T: Clone + Clone + Clone + Copy,\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:137:30\n+  --> $DIR/trait_duplication_in_bounds.rs:39:26\n    |\n-LL |     trait BadSelfTraitBound: Clone + Clone + Clone {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n+LL | trait BadSelfTraitBound: Clone + Clone + Clone {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n \n error: these where clauses contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:144:19\n-   |\n-LL |             Self: Clone + Clone + Clone;\n-   |                   ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:158:28\n+  --> $DIR/trait_duplication_in_bounds.rs:46:15\n    |\n-LL |     trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n-   |                            ^^^^^\n-   |\n-   = help: consider removing this trait bound\n+LL |         Self: Clone + Clone + Clone;\n+   |               ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:158:28\n+  --> $DIR/trait_duplication_in_bounds.rs:60:24\n    |\n-LL |     trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+LL | trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n \n error: these where clauses contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:165:16\n-   |\n-LL |             T: Clone + Clone + Clone + Copy,\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:195:24\n-   |\n-LL |     fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n-   |                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:199:23\n+  --> $DIR/trait_duplication_in_bounds.rs:67:12\n    |\n-LL |     fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n-   |                       ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n+LL |         T: Clone + Clone + Clone + Copy,\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:199:23\n-   |\n-LL |     fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `GenericTrait<u32> + GenericTrait<u64>`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:207:26\n-   |\n-LL |     fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n-   |                          ^^^^^^^^^^^^^^^^^\n+  --> $DIR/trait_duplication_in_bounds.rs:100:19\n    |\n-   = help: consider removing this trait bound\n+LL | fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `GenericTrait<u32> + GenericTrait<u64>`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:207:26\n+  --> $DIR/trait_duplication_in_bounds.rs:108:22\n    |\n-LL |     fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + foo::Clone`\n+LL | fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + foo::Clone`\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "5630a0345adb1278492d6f44e2c3b8923df9fbaa", "filename": "tests/ui/trait_duplication_in_bounds_unfixable.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds_unfixable.rs?ref=84df61c06eb36602022e758878afe66479ba0769", "patch": "@@ -0,0 +1,166 @@\n+#![deny(clippy::trait_duplication_in_bounds)]\n+\n+use std::collections::BTreeMap;\n+use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+\n+fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+where\n+    T: Clone,\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_bar<T: Clone + Default>(arg: T) {\n+    unimplemented!();\n+}\n+\n+fn good_foo<T>(arg: T)\n+where\n+    T: Clone + Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_foobar<T: Default>(arg: T)\n+where\n+    T: Clone,\n+{\n+    unimplemented!();\n+}\n+\n+trait T: Default {\n+    fn f()\n+    where\n+        Self: Default;\n+}\n+\n+trait U: Default {\n+    fn f()\n+    where\n+        Self: Clone;\n+}\n+\n+trait ZZ: Default {\n+    fn g();\n+    fn h();\n+    fn f()\n+    where\n+        Self: Default + Clone;\n+}\n+\n+trait BadTrait: Default + Clone {\n+    fn f()\n+    where\n+        Self: Default + Clone;\n+    fn g()\n+    where\n+        Self: Default;\n+    fn h()\n+    where\n+        Self: Copy;\n+}\n+\n+#[derive(Default, Clone)]\n+struct Life;\n+\n+impl T for Life {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+impl U for Life {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+// should not warn\n+trait Iter: Iterator {\n+    fn into_group_btreemap<K, V>(self) -> BTreeMap<K, Vec<V>>\n+    where\n+        Self: Iterator<Item = (K, V)> + Sized,\n+        K: Ord + Eq,\n+    {\n+        unimplemented!();\n+    }\n+}\n+\n+struct Foo;\n+\n+trait FooIter: Iterator<Item = Foo> {\n+    fn bar()\n+    where\n+        Self: Iterator<Item = Foo>,\n+    {\n+    }\n+}\n+\n+// The below should not lint and exist to guard against false positives\n+fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+\n+pub mod one {\n+    #[derive(Clone, Debug)]\n+    struct MultiProductIter<I>\n+    where\n+        I: Iterator + Clone,\n+        I::Item: Clone,\n+    {\n+        _marker: I,\n+    }\n+\n+    pub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n+    where\n+        I: Iterator + Clone,\n+        I::Item: Clone;\n+\n+    pub fn multi_cartesian_product<H>(_: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n+    where\n+        H: Iterator,\n+        H::Item: IntoIterator,\n+        <H::Item as IntoIterator>::IntoIter: Clone,\n+        <H::Item as IntoIterator>::Item: Clone,\n+    {\n+        todo!()\n+    }\n+}\n+\n+pub mod two {\n+    use std::iter::Peekable;\n+\n+    pub struct MergeBy<I, J, F>\n+    where\n+        I: Iterator,\n+        J: Iterator<Item = I::Item>,\n+    {\n+        _i: Peekable<I>,\n+        _j: Peekable<J>,\n+        _f: F,\n+    }\n+\n+    impl<I, J, F> Clone for MergeBy<I, J, F>\n+    where\n+        I: Iterator,\n+        J: Iterator<Item = I::Item>,\n+        std::iter::Peekable<I>: Clone,\n+        std::iter::Peekable<J>: Clone,\n+        F: Clone,\n+    {\n+        fn clone(&self) -> Self {\n+            Self {\n+                _i: self._i.clone(),\n+                _j: self._j.clone(),\n+                _f: self._f.clone(),\n+            }\n+        }\n+    }\n+}\n+\n+pub trait Trait {}\n+\n+pub fn f(_a: impl Trait, _b: impl Trait) {}\n+\n+pub trait ImplTrait<T> {}\n+\n+impl<A, B> ImplTrait<(A, B)> for Foo where Foo: ImplTrait<A> + ImplTrait<B> {}\n+\n+fn main() {}"}, {"sha": "aa44114eb6c5ffe1ee6a53cbb90e066751ba3fee", "filename": "tests/ui/trait_duplication_in_bounds_unfixable.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84df61c06eb36602022e758878afe66479ba0769/tests%2Fui%2Ftrait_duplication_in_bounds_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds_unfixable.stderr?ref=84df61c06eb36602022e758878afe66479ba0769", "patch": "@@ -0,0 +1,71 @@\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:6:23\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |                       ^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:1:9\n+   |\n+LL | #![deny(clippy::trait_duplication_in_bounds)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:6:15\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |               ^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:35:15\n+   |\n+LL |         Self: Default;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:49:15\n+   |\n+LL |         Self: Default + Clone;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:55:15\n+   |\n+LL |         Self: Default + Clone;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:55:25\n+   |\n+LL |         Self: Default + Clone;\n+   |                         ^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:58:15\n+   |\n+LL |         Self: Default;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:93:15\n+   |\n+LL |         Self: Iterator<Item = Foo>,\n+   |               ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 8 previous errors\n+"}]}