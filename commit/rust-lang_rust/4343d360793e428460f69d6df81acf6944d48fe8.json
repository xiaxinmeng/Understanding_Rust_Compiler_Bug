{"sha": "4343d360793e428460f69d6df81acf6944d48fe8", "node_id": "C_kwDOAAsO6NoAKDQzNDNkMzYwNzkzZTQyODQ2MGY2OWQ2ZGY4MWFjZjY5NDRkNDhmZTg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-16T18:24:43Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-17T21:27:13Z"}, "message": "Move some bounds computation out of astconv into its own file", "tree": {"sha": "c758a7138b9c6e1ead102e44928d0120e7ce8876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c758a7138b9c6e1ead102e44928d0120e7ce8876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4343d360793e428460f69d6df81acf6944d48fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4343d360793e428460f69d6df81acf6944d48fe8", "html_url": "https://github.com/rust-lang/rust/commit/4343d360793e428460f69d6df81acf6944d48fe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4343d360793e428460f69d6df81acf6944d48fe8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6594c75449fcf53474fb47182f1326b230cbcbe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6594c75449fcf53474fb47182f1326b230cbcbe8", "html_url": "https://github.com/rust-lang/rust/commit/6594c75449fcf53474fb47182f1326b230cbcbe8"}], "stats": {"total": 1152, "additions": 585, "deletions": 567}, "files": [{"sha": "e4eb0e6abd435a5e8f1f8f83bee1748b51e0a52f", "filename": "compiler/rustc_hir_analysis/src/astconv/bounds.rs", "status": "added", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/rust-lang/rust/blob/4343d360793e428460f69d6df81acf6944d48fe8/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4343d360793e428460f69d6df81acf6944d48fe8/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fbounds.rs?ref=4343d360793e428460f69d6df81acf6944d48fe8", "patch": "@@ -0,0 +1,583 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_lint_defs::Applicability;\n+use rustc_middle::ty::{self as ty, Ty, TypeVisitableExt};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{ErrorGuaranteed, Span};\n+use rustc_trait_selection::traits;\n+\n+use crate::astconv::{AstConv, ConvertedBinding, ConvertedBindingKind};\n+use crate::bounds::Bounds;\n+use crate::errors::{MultipleRelaxedDefaultBounds, ValueOfAssociatedStructAlreadySpecified};\n+\n+use super::OnlySelfBounds;\n+\n+impl<'tcx> dyn AstConv<'tcx> + '_ {\n+    /// Sets `implicitly_sized` to true on `Bounds` if necessary\n+    pub(crate) fn add_implicitly_sized(\n+        &self,\n+        bounds: &mut Bounds<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n+        self_ty_where_predicates: Option<(LocalDefId, &'tcx [hir::WherePredicate<'tcx>])>,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+\n+        // Try to find an unbound in bounds.\n+        let mut unbound = None;\n+        let mut search_bounds = |ast_bounds: &'tcx [hir::GenericBound<'tcx>]| {\n+            for ab in ast_bounds {\n+                if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n+                    if unbound.is_none() {\n+                        unbound = Some(&ptr.trait_ref);\n+                    } else {\n+                        tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n+                    }\n+                }\n+            }\n+        };\n+        search_bounds(ast_bounds);\n+        if let Some((self_ty, where_clause)) = self_ty_where_predicates {\n+            for clause in where_clause {\n+                if let hir::WherePredicate::BoundPredicate(pred) = clause {\n+                    if pred.is_param_bound(self_ty.to_def_id()) {\n+                        search_bounds(pred.bounds);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let sized_def_id = tcx.lang_items().sized_trait();\n+        match (&sized_def_id, unbound) {\n+            (Some(sized_def_id), Some(tpb))\n+                if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n+            {\n+                // There was in fact a `?Sized` bound, return without doing anything\n+                return;\n+            }\n+            (_, Some(_)) => {\n+                // There was a `?Trait` bound, but it was not `?Sized`; warn.\n+                tcx.sess.span_warn(\n+                    span,\n+                    \"default bound relaxed for a type parameter, but \\\n+                        this does nothing because the given bound is not \\\n+                        a default; only `?Sized` is supported\",\n+                );\n+                // Otherwise, add implicitly sized if `Sized` is available.\n+            }\n+            _ => {\n+                // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n+            }\n+        }\n+        if sized_def_id.is_none() {\n+            // No lang item for `Sized`, so we can't add it as a bound.\n+            return;\n+        }\n+        bounds.push_sized(tcx, self_ty, span);\n+    }\n+\n+    /// This helper takes a *converted* parameter type (`param_ty`)\n+    /// and an *unconverted* list of bounds:\n+    ///\n+    /// ```text\n+    /// fn foo<T: Debug>\n+    ///        ^  ^^^^^ `ast_bounds` parameter, in HIR form\n+    ///        |\n+    ///        `param_ty`, in ty form\n+    /// ```\n+    ///\n+    /// It adds these `ast_bounds` into the `bounds` structure.\n+    ///\n+    /// **A note on binders:** there is an implied binder around\n+    /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n+    /// for more details.\n+    #[instrument(level = \"debug\", skip(self, ast_bounds, bounds))]\n+    pub(crate) fn add_bounds<'hir, I: Iterator<Item = &'hir hir::GenericBound<'hir>>>(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: I,\n+        bounds: &mut Bounds<'tcx>,\n+        bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+        only_self_bounds: OnlySelfBounds,\n+    ) {\n+        for ast_bound in ast_bounds {\n+            match ast_bound {\n+                hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n+                    let (constness, polarity) = match modifier {\n+                        hir::TraitBoundModifier::MaybeConst => {\n+                            (ty::BoundConstness::ConstIfConst, ty::ImplPolarity::Positive)\n+                        }\n+                        hir::TraitBoundModifier::None => {\n+                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Positive)\n+                        }\n+                        hir::TraitBoundModifier::Negative => {\n+                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Negative)\n+                        }\n+                        hir::TraitBoundModifier::Maybe => continue,\n+                    };\n+                    let _ = self.instantiate_poly_trait_ref(\n+                        &poly_trait_ref.trait_ref,\n+                        poly_trait_ref.span,\n+                        constness,\n+                        polarity,\n+                        param_ty,\n+                        bounds,\n+                        false,\n+                        only_self_bounds,\n+                    );\n+                }\n+                &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+                    self.instantiate_lang_item_trait_ref(\n+                        lang_item,\n+                        span,\n+                        hir_id,\n+                        args,\n+                        param_ty,\n+                        bounds,\n+                        only_self_bounds,\n+                    );\n+                }\n+                hir::GenericBound::Outlives(lifetime) => {\n+                    let region = self.ast_region_to_region(lifetime, None);\n+                    bounds.push_region_bound(\n+                        self.tcx(),\n+                        ty::Binder::bind_with_vars(\n+                            ty::OutlivesPredicate(param_ty, region),\n+                            bound_vars,\n+                        ),\n+                        lifetime.ident.span,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Translates a list of bounds from the HIR into the `Bounds` data structure.\n+    /// The self-type for the bounds is given by `param_ty`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// fn foo<T: Bar + Baz>() { }\n+    /// //     ^  ^^^^^^^^^ ast_bounds\n+    /// //     param_ty\n+    /// ```\n+    ///\n+    /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be\n+    /// considered `Sized` unless there is an explicit `?Sized` bound. This would be true in the\n+    /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n+    ///\n+    /// `span` should be the declaration size of the parameter.\n+    pub(crate) fn compute_bounds(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound<'_>],\n+        only_self_bounds: OnlySelfBounds,\n+    ) -> Bounds<'tcx> {\n+        let mut bounds = Bounds::default();\n+        self.add_bounds(\n+            param_ty,\n+            ast_bounds.iter(),\n+            &mut bounds,\n+            ty::List::empty(),\n+            only_self_bounds,\n+        );\n+        debug!(?bounds);\n+\n+        bounds\n+    }\n+\n+    /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n+    /// named `assoc_name` into ty::Bounds. Ignore the rest.\n+    pub(crate) fn compute_bounds_that_match_assoc_item(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound<'_>],\n+        assoc_name: Ident,\n+    ) -> Bounds<'tcx> {\n+        let mut result = Vec::new();\n+\n+        for ast_bound in ast_bounds {\n+            if let Some(trait_ref) = ast_bound.trait_ref()\n+                && let Some(trait_did) = trait_ref.trait_def_id()\n+                && self.tcx().trait_may_define_assoc_item(trait_did, assoc_name)\n+            {\n+                result.push(ast_bound.clone());\n+            }\n+        }\n+\n+        let mut bounds = Bounds::default();\n+        self.add_bounds(\n+            param_ty,\n+            result.iter(),\n+            &mut bounds,\n+            ty::List::empty(),\n+            OnlySelfBounds(true),\n+        );\n+        debug!(?bounds);\n+\n+        bounds\n+    }\n+\n+    /// Given an HIR binding like `Item = Foo` or `Item: Foo`, pushes the corresponding predicates\n+    /// onto `bounds`.\n+    ///\n+    /// **A note on binders:** given something like `T: for<'a> Iterator<Item = &'a u32>`, the\n+    /// `trait_ref` here will be `for<'a> T: Iterator`. The `binding` data however is from *inside*\n+    /// the binder (e.g., `&'a u32`) and hence may reference bound regions.\n+    #[instrument(level = \"debug\", skip(self, bounds, speculative, dup_bindings, path_span))]\n+    pub(super) fn add_predicates_for_ast_type_binding(\n+        &self,\n+        hir_ref_id: hir::HirId,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        binding: &ConvertedBinding<'_, 'tcx>,\n+        bounds: &mut Bounds<'tcx>,\n+        speculative: bool,\n+        dup_bindings: &mut FxHashMap<DefId, Span>,\n+        path_span: Span,\n+        constness: ty::BoundConstness,\n+        only_self_bounds: OnlySelfBounds,\n+        polarity: ty::ImplPolarity,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        // Given something like `U: SomeTrait<T = X>`, we want to produce a\n+        // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n+        // subtle in the event that `T` is defined in a supertrait of\n+        // `SomeTrait`, because in that case we need to upcast.\n+        //\n+        // That is, consider this case:\n+        //\n+        // ```\n+        // trait SubTrait: SuperTrait<i32> { }\n+        // trait SuperTrait<A> { type T; }\n+        //\n+        // ... B: SubTrait<T = foo> ...\n+        // ```\n+        //\n+        // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n+\n+        let tcx = self.tcx();\n+\n+        let return_type_notation =\n+            binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation;\n+\n+        let candidate = if return_type_notation {\n+            if self.trait_defines_associated_item_named(\n+                trait_ref.def_id(),\n+                ty::AssocKind::Fn,\n+                binding.item_name,\n+            ) {\n+                trait_ref\n+            } else {\n+                self.one_bound_for_assoc_method(\n+                    traits::supertraits(tcx, trait_ref),\n+                    trait_ref.print_only_trait_path(),\n+                    binding.item_name,\n+                    path_span,\n+                )?\n+            }\n+        } else if self.trait_defines_associated_item_named(\n+            trait_ref.def_id(),\n+            ty::AssocKind::Type,\n+            binding.item_name,\n+        ) {\n+            // Simple case: X is defined in the current trait.\n+            trait_ref\n+        } else {\n+            // Otherwise, we have to walk through the supertraits to find\n+            // those that do.\n+            self.one_bound_for_assoc_type(\n+                || traits::supertraits(tcx, trait_ref),\n+                trait_ref.skip_binder().print_only_trait_name(),\n+                binding.item_name,\n+                path_span,\n+                match binding.kind {\n+                    ConvertedBindingKind::Equality(term) => Some(term),\n+                    _ => None,\n+                },\n+            )?\n+        };\n+\n+        let (assoc_ident, def_scope) =\n+            tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n+\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n+        // of calling `filter_by_name_and_kind`.\n+        let find_item_of_kind = |kind| {\n+            tcx.associated_items(candidate.def_id())\n+                .filter_by_name_unhygienic(assoc_ident.name)\n+                .find(|i| i.kind == kind && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident)\n+        };\n+        let assoc_item = if return_type_notation {\n+            find_item_of_kind(ty::AssocKind::Fn)\n+        } else {\n+            find_item_of_kind(ty::AssocKind::Type)\n+                .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n+        }\n+        .expect(\"missing associated type\");\n+\n+        if !assoc_item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n+            tcx.sess\n+                .struct_span_err(\n+                    binding.span,\n+                    format!(\"{} `{}` is private\", assoc_item.kind, binding.item_name),\n+                )\n+                .span_label(binding.span, format!(\"private {}\", assoc_item.kind))\n+                .emit();\n+        }\n+        tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);\n+\n+        if !speculative {\n+            dup_bindings\n+                .entry(assoc_item.def_id)\n+                .and_modify(|prev_span| {\n+                    tcx.sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n+                        span: binding.span,\n+                        prev_span: *prev_span,\n+                        item_name: binding.item_name,\n+                        def_path: tcx.def_path_str(assoc_item.container_id(tcx)),\n+                    });\n+                })\n+                .or_insert(binding.span);\n+        }\n+\n+        let projection_ty = if return_type_notation {\n+            let mut emitted_bad_param_err = false;\n+            // If we have an method return type bound, then we need to substitute\n+            // the method's early bound params with suitable late-bound params.\n+            let mut num_bound_vars = candidate.bound_vars().len();\n+            let substs =\n+                candidate.skip_binder().substs.extend_to(tcx, assoc_item.def_id, |param, _| {\n+                    let subst = match param.kind {\n+                        ty::GenericParamDefKind::Lifetime => ty::Region::new_late_bound(\n+                            tcx,\n+                            ty::INNERMOST,\n+                            ty::BoundRegion {\n+                                var: ty::BoundVar::from_usize(num_bound_vars),\n+                                kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n+                            },\n+                        )\n+                        .into(),\n+                        ty::GenericParamDefKind::Type { .. } => {\n+                            if !emitted_bad_param_err {\n+                                tcx.sess.emit_err(\n+                                    crate::errors::ReturnTypeNotationIllegalParam::Type {\n+                                        span: path_span,\n+                                        param_span: tcx.def_span(param.def_id),\n+                                    },\n+                                );\n+                                emitted_bad_param_err = true;\n+                            }\n+                            tcx.mk_bound(\n+                                ty::INNERMOST,\n+                                ty::BoundTy {\n+                                    var: ty::BoundVar::from_usize(num_bound_vars),\n+                                    kind: ty::BoundTyKind::Param(param.def_id, param.name),\n+                                },\n+                            )\n+                            .into()\n+                        }\n+                        ty::GenericParamDefKind::Const { .. } => {\n+                            if !emitted_bad_param_err {\n+                                tcx.sess.emit_err(\n+                                    crate::errors::ReturnTypeNotationIllegalParam::Const {\n+                                        span: path_span,\n+                                        param_span: tcx.def_span(param.def_id),\n+                                    },\n+                                );\n+                                emitted_bad_param_err = true;\n+                            }\n+                            let ty = tcx\n+                                .type_of(param.def_id)\n+                                .no_bound_vars()\n+                                .expect(\"ct params cannot have early bound vars\");\n+                            tcx.mk_const(\n+                                ty::ConstKind::Bound(\n+                                    ty::INNERMOST,\n+                                    ty::BoundVar::from_usize(num_bound_vars),\n+                                ),\n+                                ty,\n+                            )\n+                            .into()\n+                        }\n+                    };\n+                    num_bound_vars += 1;\n+                    subst\n+                });\n+\n+            // Next, we need to check that the return-type notation is being used on\n+            // an RPITIT (return-position impl trait in trait) or AFIT (async fn in trait).\n+            let output = tcx.fn_sig(assoc_item.def_id).skip_binder().output();\n+            let output = if let ty::Alias(ty::Projection, alias_ty) = *output.skip_binder().kind()\n+                && tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n+            {\n+                alias_ty\n+            } else {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationOnNonRpitit {\n+                        span: binding.span,\n+                        ty: tcx.liberate_late_bound_regions(assoc_item.def_id, output),\n+                        fn_span: tcx.hir().span_if_local(assoc_item.def_id),\n+                        note: (),\n+                    },\n+                ));\n+            };\n+\n+            // Finally, move the fn return type's bound vars over to account for the early bound\n+            // params (and trait ref's late bound params). This logic is very similar to\n+            // `Predicate::subst_supertrait`, and it's no coincidence why.\n+            let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n+            let subst_output = ty::EarlyBinder::bind(shifted_output).subst(tcx, substs);\n+\n+            let bound_vars = tcx.late_bound_vars(binding.hir_id);\n+            ty::Binder::bind_with_vars(subst_output, bound_vars)\n+        } else {\n+            // Include substitutions for generic parameters of associated types\n+            candidate.map_bound(|trait_ref| {\n+                let ident = Ident::new(assoc_item.name, binding.item_name.span);\n+                let item_segment = hir::PathSegment {\n+                    ident,\n+                    hir_id: binding.hir_id,\n+                    res: Res::Err,\n+                    args: Some(binding.gen_args),\n+                    infer_args: false,\n+                };\n+\n+                let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n+                    path_span,\n+                    assoc_item.def_id,\n+                    &item_segment,\n+                    trait_ref.substs,\n+                );\n+\n+                debug!(?substs_trait_ref_and_assoc_item);\n+\n+                tcx.mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n+            })\n+        };\n+\n+        if !speculative {\n+            // Find any late-bound regions declared in `ty` that are not\n+            // declared in the trait-ref or assoc_item. These are not well-formed.\n+            //\n+            // Example:\n+            //\n+            //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n+            //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n+            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n+                let late_bound_in_trait_ref =\n+                    tcx.collect_constrained_late_bound_regions(&projection_ty);\n+                let late_bound_in_ty =\n+                    tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n+                debug!(?late_bound_in_trait_ref);\n+                debug!(?late_bound_in_ty);\n+\n+                // FIXME: point at the type params that don't have appropriate lifetimes:\n+                // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n+                //                         ----  ----     ^^^^^^^\n+                self.validate_late_bound_regions(\n+                    late_bound_in_trait_ref,\n+                    late_bound_in_ty,\n+                    |br_name| {\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            binding.span,\n+                            E0582,\n+                            \"binding for associated type `{}` references {}, \\\n+                             which does not appear in the trait input types\",\n+                            binding.item_name,\n+                            br_name\n+                        )\n+                    },\n+                );\n+            }\n+        }\n+\n+        match binding.kind {\n+            ConvertedBindingKind::Equality(..) if return_type_notation => {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationEqualityBound { span: binding.span },\n+                ));\n+            }\n+            ConvertedBindingKind::Equality(mut term) => {\n+                // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n+                // the \"projection predicate\" for:\n+                //\n+                // `<T as Iterator>::Item = u32`\n+                let assoc_item_def_id = projection_ty.skip_binder().def_id;\n+                let def_kind = tcx.def_kind(assoc_item_def_id);\n+                match (def_kind, term.unpack()) {\n+                    (hir::def::DefKind::AssocTy, ty::TermKind::Ty(_))\n+                    | (hir::def::DefKind::AssocConst, ty::TermKind::Const(_)) => (),\n+                    (_, _) => {\n+                        let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n+                        let expected = tcx.def_descr(assoc_item_def_id);\n+                        let mut err = tcx.sess.struct_span_err(\n+                            binding.span,\n+                            format!(\"expected {expected} bound, found {got}\"),\n+                        );\n+                        err.span_note(\n+                            tcx.def_span(assoc_item_def_id),\n+                            format!(\"{expected} defined here\"),\n+                        );\n+\n+                        if let hir::def::DefKind::AssocConst = def_kind\n+                          && let Some(t) = term.ty() && (t.is_enum() || t.references_error())\n+                          && tcx.features().associated_const_equality {\n+                            err.span_suggestion(\n+                                binding.span,\n+                                \"if equating a const, try wrapping with braces\",\n+                                format!(\"{} = {{ const }}\", binding.item_name),\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                        let reported = err.emit();\n+                        term = match def_kind {\n+                            hir::def::DefKind::AssocTy => tcx.ty_error(reported).into(),\n+                            hir::def::DefKind::AssocConst => tcx\n+                                .const_error(\n+                                    tcx.type_of(assoc_item_def_id)\n+                                        .subst(tcx, projection_ty.skip_binder().substs),\n+                                    reported,\n+                                )\n+                                .into(),\n+                            _ => unreachable!(),\n+                        };\n+                    }\n+                }\n+                bounds.push_projection_bound(\n+                    tcx,\n+                    projection_ty\n+                        .map_bound(|projection_ty| ty::ProjectionPredicate { projection_ty, term }),\n+                    binding.span,\n+                );\n+            }\n+            ConvertedBindingKind::Constraint(ast_bounds) => {\n+                // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n+                //\n+                // `<T as Iterator>::Item: Debug`\n+                //\n+                // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n+                // parameter to have a skipped binder.\n+                //\n+                // NOTE: If `only_self_bounds` is true, do NOT expand this associated\n+                // type bound into a trait predicate, since we only want to add predicates\n+                // for the `Self` type.\n+                if !only_self_bounds.0 {\n+                    let param_ty = tcx.mk_alias(ty::Projection, projection_ty.skip_binder());\n+                    self.add_bounds(\n+                        param_ty,\n+                        ast_bounds.iter(),\n+                        bounds,\n+                        projection_ty.bound_vars(),\n+                        only_self_bounds,\n+                    );\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "d6645b784c4392dc7b0314a83c1c81c0f47f6a09", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 567, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/4343d360793e428460f69d6df81acf6944d48fe8/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4343d360793e428460f69d6df81acf6944d48fe8/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=4343d360793e428460f69d6df81acf6944d48fe8", "patch": "@@ -2,6 +2,7 @@\n //! The main routine here is `ast_ty_to_ty()`; each use is parameterized by an\n //! instance of `AstConv`.\n \n+mod bounds;\n mod errors;\n pub mod generics;\n mod lint;\n@@ -11,8 +12,7 @@ use crate::astconv::generics::{check_generic_arg_count, create_substs_for_generi\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n-    AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n-    TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n+    AmbiguousLifetimeBound, TraitObjectDeclaredWithNoTraits, TypeofReservedKeywordUsed,\n };\n use crate::middle::resolve_bound_vars as rbv;\n use crate::require_c_abi_if_c_variadic;\n@@ -885,571 +885,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .is_some()\n     }\n \n-    /// Sets `implicitly_sized` to true on `Bounds` if necessary\n-    pub(crate) fn add_implicitly_sized(\n-        &self,\n-        bounds: &mut Bounds<'tcx>,\n-        self_ty: Ty<'tcx>,\n-        ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n-        self_ty_where_predicates: Option<(LocalDefId, &'tcx [hir::WherePredicate<'tcx>])>,\n-        span: Span,\n-    ) {\n-        let tcx = self.tcx();\n-\n-        // Try to find an unbound in bounds.\n-        let mut unbound = None;\n-        let mut search_bounds = |ast_bounds: &'tcx [hir::GenericBound<'tcx>]| {\n-            for ab in ast_bounds {\n-                if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n-                    if unbound.is_none() {\n-                        unbound = Some(&ptr.trait_ref);\n-                    } else {\n-                        tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n-                    }\n-                }\n-            }\n-        };\n-        search_bounds(ast_bounds);\n-        if let Some((self_ty, where_clause)) = self_ty_where_predicates {\n-            for clause in where_clause {\n-                if let hir::WherePredicate::BoundPredicate(pred) = clause {\n-                    if pred.is_param_bound(self_ty.to_def_id()) {\n-                        search_bounds(pred.bounds);\n-                    }\n-                }\n-            }\n-        }\n-\n-        let sized_def_id = tcx.lang_items().sized_trait();\n-        match (&sized_def_id, unbound) {\n-            (Some(sized_def_id), Some(tpb))\n-                if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n-            {\n-                // There was in fact a `?Sized` bound, return without doing anything\n-                return;\n-            }\n-            (_, Some(_)) => {\n-                // There was a `?Trait` bound, but it was not `?Sized`; warn.\n-                tcx.sess.span_warn(\n-                    span,\n-                    \"default bound relaxed for a type parameter, but \\\n-                        this does nothing because the given bound is not \\\n-                        a default; only `?Sized` is supported\",\n-                );\n-                // Otherwise, add implicitly sized if `Sized` is available.\n-            }\n-            _ => {\n-                // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n-            }\n-        }\n-        if sized_def_id.is_none() {\n-            // No lang item for `Sized`, so we can't add it as a bound.\n-            return;\n-        }\n-        bounds.push_sized(tcx, self_ty, span);\n-    }\n-\n-    /// This helper takes a *converted* parameter type (`param_ty`)\n-    /// and an *unconverted* list of bounds:\n-    ///\n-    /// ```text\n-    /// fn foo<T: Debug>\n-    ///        ^  ^^^^^ `ast_bounds` parameter, in HIR form\n-    ///        |\n-    ///        `param_ty`, in ty form\n-    /// ```\n-    ///\n-    /// It adds these `ast_bounds` into the `bounds` structure.\n-    ///\n-    /// **A note on binders:** there is an implied binder around\n-    /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n-    /// for more details.\n-    #[instrument(level = \"debug\", skip(self, ast_bounds, bounds))]\n-    pub(crate) fn add_bounds<'hir, I: Iterator<Item = &'hir hir::GenericBound<'hir>>>(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: I,\n-        bounds: &mut Bounds<'tcx>,\n-        bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n-        only_self_bounds: OnlySelfBounds,\n-    ) {\n-        for ast_bound in ast_bounds {\n-            match ast_bound {\n-                hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n-                    let (constness, polarity) = match modifier {\n-                        hir::TraitBoundModifier::MaybeConst => {\n-                            (ty::BoundConstness::ConstIfConst, ty::ImplPolarity::Positive)\n-                        }\n-                        hir::TraitBoundModifier::None => {\n-                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Positive)\n-                        }\n-                        hir::TraitBoundModifier::Negative => {\n-                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Negative)\n-                        }\n-                        hir::TraitBoundModifier::Maybe => continue,\n-                    };\n-                    let _ = self.instantiate_poly_trait_ref(\n-                        &poly_trait_ref.trait_ref,\n-                        poly_trait_ref.span,\n-                        constness,\n-                        polarity,\n-                        param_ty,\n-                        bounds,\n-                        false,\n-                        only_self_bounds,\n-                    );\n-                }\n-                &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n-                    self.instantiate_lang_item_trait_ref(\n-                        lang_item,\n-                        span,\n-                        hir_id,\n-                        args,\n-                        param_ty,\n-                        bounds,\n-                        only_self_bounds,\n-                    );\n-                }\n-                hir::GenericBound::Outlives(lifetime) => {\n-                    let region = self.ast_region_to_region(lifetime, None);\n-                    bounds.push_region_bound(\n-                        self.tcx(),\n-                        ty::Binder::bind_with_vars(\n-                            ty::OutlivesPredicate(param_ty, region),\n-                            bound_vars,\n-                        ),\n-                        lifetime.ident.span,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Translates a list of bounds from the HIR into the `Bounds` data structure.\n-    /// The self-type for the bounds is given by `param_ty`.\n-    ///\n-    /// Example:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// fn foo<T: Bar + Baz>() { }\n-    /// //     ^  ^^^^^^^^^ ast_bounds\n-    /// //     param_ty\n-    /// ```\n-    ///\n-    /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be\n-    /// considered `Sized` unless there is an explicit `?Sized` bound. This would be true in the\n-    /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n-    ///\n-    /// `span` should be the declaration size of the parameter.\n-    pub(crate) fn compute_bounds(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n-        only_self_bounds: OnlySelfBounds,\n-    ) -> Bounds<'tcx> {\n-        let mut bounds = Bounds::default();\n-        self.add_bounds(\n-            param_ty,\n-            ast_bounds.iter(),\n-            &mut bounds,\n-            ty::List::empty(),\n-            only_self_bounds,\n-        );\n-        debug!(?bounds);\n-\n-        bounds\n-    }\n-\n-    /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n-    /// named `assoc_name` into ty::Bounds. Ignore the rest.\n-    pub(crate) fn compute_bounds_that_match_assoc_item(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n-        assoc_name: Ident,\n-    ) -> Bounds<'tcx> {\n-        let mut result = Vec::new();\n-\n-        for ast_bound in ast_bounds {\n-            if let Some(trait_ref) = ast_bound.trait_ref()\n-                && let Some(trait_did) = trait_ref.trait_def_id()\n-                && self.tcx().trait_may_define_assoc_item(trait_did, assoc_name)\n-            {\n-                result.push(ast_bound.clone());\n-            }\n-        }\n-\n-        let mut bounds = Bounds::default();\n-        self.add_bounds(\n-            param_ty,\n-            result.iter(),\n-            &mut bounds,\n-            ty::List::empty(),\n-            OnlySelfBounds(true),\n-        );\n-        debug!(?bounds);\n-\n-        bounds\n-    }\n-\n-    /// Given an HIR binding like `Item = Foo` or `Item: Foo`, pushes the corresponding predicates\n-    /// onto `bounds`.\n-    ///\n-    /// **A note on binders:** given something like `T: for<'a> Iterator<Item = &'a u32>`, the\n-    /// `trait_ref` here will be `for<'a> T: Iterator`. The `binding` data however is from *inside*\n-    /// the binder (e.g., `&'a u32`) and hence may reference bound regions.\n-    #[instrument(level = \"debug\", skip(self, bounds, speculative, dup_bindings, path_span))]\n-    fn add_predicates_for_ast_type_binding(\n-        &self,\n-        hir_ref_id: hir::HirId,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        binding: &ConvertedBinding<'_, 'tcx>,\n-        bounds: &mut Bounds<'tcx>,\n-        speculative: bool,\n-        dup_bindings: &mut FxHashMap<DefId, Span>,\n-        path_span: Span,\n-        constness: ty::BoundConstness,\n-        only_self_bounds: OnlySelfBounds,\n-        polarity: ty::ImplPolarity,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        // Given something like `U: SomeTrait<T = X>`, we want to produce a\n-        // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n-        // subtle in the event that `T` is defined in a supertrait of\n-        // `SomeTrait`, because in that case we need to upcast.\n-        //\n-        // That is, consider this case:\n-        //\n-        // ```\n-        // trait SubTrait: SuperTrait<i32> { }\n-        // trait SuperTrait<A> { type T; }\n-        //\n-        // ... B: SubTrait<T = foo> ...\n-        // ```\n-        //\n-        // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n-\n-        let tcx = self.tcx();\n-\n-        let return_type_notation =\n-            binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation;\n-\n-        let candidate = if return_type_notation {\n-            if self.trait_defines_associated_item_named(\n-                trait_ref.def_id(),\n-                ty::AssocKind::Fn,\n-                binding.item_name,\n-            ) {\n-                trait_ref\n-            } else {\n-                self.one_bound_for_assoc_method(\n-                    traits::supertraits(tcx, trait_ref),\n-                    trait_ref.print_only_trait_path(),\n-                    binding.item_name,\n-                    path_span,\n-                )?\n-            }\n-        } else if self.trait_defines_associated_item_named(\n-            trait_ref.def_id(),\n-            ty::AssocKind::Type,\n-            binding.item_name,\n-        ) {\n-            // Simple case: X is defined in the current trait.\n-            trait_ref\n-        } else {\n-            // Otherwise, we have to walk through the supertraits to find\n-            // those that do.\n-            self.one_bound_for_assoc_type(\n-                || traits::supertraits(tcx, trait_ref),\n-                trait_ref.skip_binder().print_only_trait_name(),\n-                binding.item_name,\n-                path_span,\n-                match binding.kind {\n-                    ConvertedBindingKind::Equality(term) => Some(term),\n-                    _ => None,\n-                },\n-            )?\n-        };\n-\n-        let (assoc_ident, def_scope) =\n-            tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n-\n-        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n-        // of calling `filter_by_name_and_kind`.\n-        let find_item_of_kind = |kind| {\n-            tcx.associated_items(candidate.def_id())\n-                .filter_by_name_unhygienic(assoc_ident.name)\n-                .find(|i| i.kind == kind && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident)\n-        };\n-        let assoc_item = if return_type_notation {\n-            find_item_of_kind(ty::AssocKind::Fn)\n-        } else {\n-            find_item_of_kind(ty::AssocKind::Type)\n-                .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n-        }\n-        .expect(\"missing associated type\");\n-\n-        if !assoc_item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n-            tcx.sess\n-                .struct_span_err(\n-                    binding.span,\n-                    format!(\"{} `{}` is private\", assoc_item.kind, binding.item_name),\n-                )\n-                .span_label(binding.span, format!(\"private {}\", assoc_item.kind))\n-                .emit();\n-        }\n-        tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);\n-\n-        if !speculative {\n-            dup_bindings\n-                .entry(assoc_item.def_id)\n-                .and_modify(|prev_span| {\n-                    tcx.sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n-                        span: binding.span,\n-                        prev_span: *prev_span,\n-                        item_name: binding.item_name,\n-                        def_path: tcx.def_path_str(assoc_item.container_id(tcx)),\n-                    });\n-                })\n-                .or_insert(binding.span);\n-        }\n-\n-        let projection_ty = if return_type_notation {\n-            let mut emitted_bad_param_err = false;\n-            // If we have an method return type bound, then we need to substitute\n-            // the method's early bound params with suitable late-bound params.\n-            let mut num_bound_vars = candidate.bound_vars().len();\n-            let substs =\n-                candidate.skip_binder().substs.extend_to(tcx, assoc_item.def_id, |param, _| {\n-                    let subst = match param.kind {\n-                        GenericParamDefKind::Lifetime => ty::Region::new_late_bound(\n-                            tcx,\n-                            ty::INNERMOST,\n-                            ty::BoundRegion {\n-                                var: ty::BoundVar::from_usize(num_bound_vars),\n-                                kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n-                            },\n-                        )\n-                        .into(),\n-                        GenericParamDefKind::Type { .. } => {\n-                            if !emitted_bad_param_err {\n-                                tcx.sess.emit_err(\n-                                    crate::errors::ReturnTypeNotationIllegalParam::Type {\n-                                        span: path_span,\n-                                        param_span: tcx.def_span(param.def_id),\n-                                    },\n-                                );\n-                                emitted_bad_param_err = true;\n-                            }\n-                            tcx.mk_bound(\n-                                ty::INNERMOST,\n-                                ty::BoundTy {\n-                                    var: ty::BoundVar::from_usize(num_bound_vars),\n-                                    kind: ty::BoundTyKind::Param(param.def_id, param.name),\n-                                },\n-                            )\n-                            .into()\n-                        }\n-                        GenericParamDefKind::Const { .. } => {\n-                            if !emitted_bad_param_err {\n-                                tcx.sess.emit_err(\n-                                    crate::errors::ReturnTypeNotationIllegalParam::Const {\n-                                        span: path_span,\n-                                        param_span: tcx.def_span(param.def_id),\n-                                    },\n-                                );\n-                                emitted_bad_param_err = true;\n-                            }\n-                            let ty = tcx\n-                                .type_of(param.def_id)\n-                                .no_bound_vars()\n-                                .expect(\"ct params cannot have early bound vars\");\n-                            tcx.mk_const(\n-                                ty::ConstKind::Bound(\n-                                    ty::INNERMOST,\n-                                    ty::BoundVar::from_usize(num_bound_vars),\n-                                ),\n-                                ty,\n-                            )\n-                            .into()\n-                        }\n-                    };\n-                    num_bound_vars += 1;\n-                    subst\n-                });\n-\n-            // Next, we need to check that the return-type notation is being used on\n-            // an RPITIT (return-position impl trait in trait) or AFIT (async fn in trait).\n-            let output = tcx.fn_sig(assoc_item.def_id).skip_binder().output();\n-            let output = if let ty::Alias(ty::Projection, alias_ty) = *output.skip_binder().kind()\n-                && tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n-            {\n-                alias_ty\n-            } else {\n-                return Err(self.tcx().sess.emit_err(\n-                    crate::errors::ReturnTypeNotationOnNonRpitit {\n-                        span: binding.span,\n-                        ty: tcx.liberate_late_bound_regions(assoc_item.def_id, output),\n-                        fn_span: tcx.hir().span_if_local(assoc_item.def_id),\n-                        note: (),\n-                    },\n-                ));\n-            };\n-\n-            // Finally, move the fn return type's bound vars over to account for the early bound\n-            // params (and trait ref's late bound params). This logic is very similar to\n-            // `Predicate::subst_supertrait`, and it's no coincidence why.\n-            let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n-            let subst_output = ty::EarlyBinder::bind(shifted_output).subst(tcx, substs);\n-\n-            let bound_vars = tcx.late_bound_vars(binding.hir_id);\n-            ty::Binder::bind_with_vars(subst_output, bound_vars)\n-        } else {\n-            // Include substitutions for generic parameters of associated types\n-            candidate.map_bound(|trait_ref| {\n-                let ident = Ident::new(assoc_item.name, binding.item_name.span);\n-                let item_segment = hir::PathSegment {\n-                    ident,\n-                    hir_id: binding.hir_id,\n-                    res: Res::Err,\n-                    args: Some(binding.gen_args),\n-                    infer_args: false,\n-                };\n-\n-                let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n-                    path_span,\n-                    assoc_item.def_id,\n-                    &item_segment,\n-                    trait_ref.substs,\n-                );\n-\n-                debug!(?substs_trait_ref_and_assoc_item);\n-\n-                tcx.mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n-            })\n-        };\n-\n-        if !speculative {\n-            // Find any late-bound regions declared in `ty` that are not\n-            // declared in the trait-ref or assoc_item. These are not well-formed.\n-            //\n-            // Example:\n-            //\n-            //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n-            //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n-            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n-                let late_bound_in_trait_ref =\n-                    tcx.collect_constrained_late_bound_regions(&projection_ty);\n-                let late_bound_in_ty =\n-                    tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n-                debug!(?late_bound_in_trait_ref);\n-                debug!(?late_bound_in_ty);\n-\n-                // FIXME: point at the type params that don't have appropriate lifetimes:\n-                // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n-                //                         ----  ----     ^^^^^^^\n-                self.validate_late_bound_regions(\n-                    late_bound_in_trait_ref,\n-                    late_bound_in_ty,\n-                    |br_name| {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            binding.span,\n-                            E0582,\n-                            \"binding for associated type `{}` references {}, \\\n-                             which does not appear in the trait input types\",\n-                            binding.item_name,\n-                            br_name\n-                        )\n-                    },\n-                );\n-            }\n-        }\n-\n-        match binding.kind {\n-            ConvertedBindingKind::Equality(..) if return_type_notation => {\n-                return Err(self.tcx().sess.emit_err(\n-                    crate::errors::ReturnTypeNotationEqualityBound { span: binding.span },\n-                ));\n-            }\n-            ConvertedBindingKind::Equality(mut term) => {\n-                // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n-                // the \"projection predicate\" for:\n-                //\n-                // `<T as Iterator>::Item = u32`\n-                let assoc_item_def_id = projection_ty.skip_binder().def_id;\n-                let def_kind = tcx.def_kind(assoc_item_def_id);\n-                match (def_kind, term.unpack()) {\n-                    (hir::def::DefKind::AssocTy, ty::TermKind::Ty(_))\n-                    | (hir::def::DefKind::AssocConst, ty::TermKind::Const(_)) => (),\n-                    (_, _) => {\n-                        let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n-                        let expected = tcx.def_descr(assoc_item_def_id);\n-                        let mut err = tcx.sess.struct_span_err(\n-                            binding.span,\n-                            format!(\"expected {expected} bound, found {got}\"),\n-                        );\n-                        err.span_note(\n-                            tcx.def_span(assoc_item_def_id),\n-                            format!(\"{expected} defined here\"),\n-                        );\n-\n-                        if let hir::def::DefKind::AssocConst = def_kind\n-                          && let Some(t) = term.ty() && (t.is_enum() || t.references_error())\n-                          && tcx.features().associated_const_equality {\n-                            err.span_suggestion(\n-                                binding.span,\n-                                \"if equating a const, try wrapping with braces\",\n-                                format!(\"{} = {{ const }}\", binding.item_name),\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        }\n-                        let reported = err.emit();\n-                        term = match def_kind {\n-                            hir::def::DefKind::AssocTy => tcx.ty_error(reported).into(),\n-                            hir::def::DefKind::AssocConst => tcx\n-                                .const_error(\n-                                    tcx.type_of(assoc_item_def_id)\n-                                        .subst(tcx, projection_ty.skip_binder().substs),\n-                                    reported,\n-                                )\n-                                .into(),\n-                            _ => unreachable!(),\n-                        };\n-                    }\n-                }\n-                bounds.push_projection_bound(\n-                    tcx,\n-                    projection_ty\n-                        .map_bound(|projection_ty| ty::ProjectionPredicate { projection_ty, term }),\n-                    binding.span,\n-                );\n-            }\n-            ConvertedBindingKind::Constraint(ast_bounds) => {\n-                // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n-                //\n-                // `<T as Iterator>::Item: Debug`\n-                //\n-                // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n-                // parameter to have a skipped binder.\n-                //\n-                // NOTE: If `only_self_bounds` is true, do NOT expand this associated\n-                // type bound into a trait predicate, since we only want to add predicates\n-                // for the `Self` type.\n-                if !only_self_bounds.0 {\n-                    let param_ty = tcx.mk_alias(ty::Projection, projection_ty.skip_binder());\n-                    self.add_bounds(\n-                        param_ty,\n-                        ast_bounds.iter(),\n-                        bounds,\n-                        projection_ty.bound_vars(),\n-                        only_self_bounds,\n-                    );\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     fn ast_path_to_ty(\n         &self,\n         span: Span,"}]}