{"sha": "5b72e52e472ca06f42700a322dc2cac4c38e05f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNzJlNTJlNDcyY2EwNmY0MjcwMGEzMjJkYzJjYWM0YzM4ZTA1ZjE=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-05-24T20:44:42Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-05-24T21:39:22Z"}, "message": "Access parse/attrs.rs with an impl.", "tree": {"sha": "e72b6b15740c5c166e5c2ed9f4ef417a1ae7d93f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e72b6b15740c5c166e5c2ed9f4ef417a1ae7d93f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b72e52e472ca06f42700a322dc2cac4c38e05f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b72e52e472ca06f42700a322dc2cac4c38e05f1", "html_url": "https://github.com/rust-lang/rust/commit/5b72e52e472ca06f42700a322dc2cac4c38e05f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b72e52e472ca06f42700a322dc2cac4c38e05f1/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09652c8f5f0f12913396898afd4fb382ae90a448", "url": "https://api.github.com/repos/rust-lang/rust/commits/09652c8f5f0f12913396898afd4fb382ae90a448", "html_url": "https://github.com/rust-lang/rust/commit/09652c8f5f0f12913396898afd4fb382ae90a448"}], "stats": {"total": 249, "additions": 131, "deletions": 118}, "files": [{"sha": "c6535bd1a4d3c5052274ccec85df457cbcdacb10", "filename": "src/librustsyntax/parse.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse.rs?ref=5b72e52e472ca06f42700a322dc2cac4c38e05f1", "patch": "@@ -13,6 +13,7 @@ export parse_item_from_source_str;\n export parse_from_source_str;\n \n import parser::parser;\n+import attr::parser_attr;\n import common::parser_common;\n import ast::node_id;\n import util::interner;\n@@ -44,7 +45,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n     let p = new_parser_from_file(sess, cfg, input, parser::CRATE_FILE);\n     let lo = p.span.lo;\n     let prefix = path::dirname(p.reader.filemap.name);\n-    let leading_attrs = attr::parse_inner_attrs_and_next(p);\n+    let leading_attrs = p.parse_inner_attrs_and_next();\n     let crate_attrs = leading_attrs.inner;\n     let first_cdir_attr = leading_attrs.next;\n     let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);"}, {"sha": "6615938b9ad9b08ec310a95e961a5aa98778fb0c", "filename": "src/librustsyntax/parse/attr.rs", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fattr.rs?ref=5b72e52e472ca06f42700a322dc2cac4c38e05f1", "patch": "@@ -3,116 +3,130 @@ import ast_util::spanned;\n import common::{parser_common, seq_sep};\n \n export attr_or_ext;\n-export parse_outer_attributes;\n-export parse_outer_attrs_or_ext;\n-export parse_inner_attrs_and_next;\n-export parse_optional_meta;\n+export parser_attr;\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n type attr_or_ext = option<either<[ast::attribute], @ast::expr>>;\n \n-fn parse_outer_attrs_or_ext(\n-    p: parser,\n-    first_item_attrs: [ast::attribute]) -> attr_or_ext {\n-    let expect_item_next = vec::is_not_empty(first_item_attrs);\n-    if p.token == token::POUND {\n-        let lo = p.span.lo;\n-        if p.look_ahead(1u) == token::LBRACKET {\n-            p.bump();\n-            let first_attr = parse_attribute_naked(p, ast::attr_outer, lo);\n-            ret some(left([first_attr] + parse_outer_attributes(p)));\n-        } else if !(p.look_ahead(1u) == token::LT\n-                    || p.look_ahead(1u) == token::LBRACKET\n-                    || expect_item_next) {\n-            p.bump();\n-            ret some(right(p.parse_syntax_ext_naked(lo)));\n+impl parser_attr for parser {\n+\n+    fn parse_outer_attrs_or_ext(first_item_attrs: [ast::attribute])\n+        -> attr_or_ext\n+    {\n+        let expect_item_next = vec::is_not_empty(first_item_attrs);\n+        if self.token == token::POUND {\n+            let lo = self.span.lo;\n+            if self.look_ahead(1u) == token::LBRACKET {\n+                self.bump();\n+                let first_attr =\n+                    self.parse_attribute_naked(ast::attr_outer, lo);\n+                ret some(left([first_attr] + self.parse_outer_attributes()));\n+            } else if !(self.look_ahead(1u) == token::LT\n+                        || self.look_ahead(1u) == token::LBRACKET\n+                        || expect_item_next) {\n+                self.bump();\n+                ret some(right(self.parse_syntax_ext_naked(lo)));\n+            } else { ret none; }\n         } else { ret none; }\n-    } else { ret none; }\n-}\n+    }\n \n-// Parse attributes that appear before an item\n-fn parse_outer_attributes(p: parser) -> [ast::attribute] {\n-    let mut attrs: [ast::attribute] = [];\n-    while p.token == token::POUND && p.look_ahead(1u) == token::LBRACKET {\n-        attrs += [parse_attribute(p, ast::attr_outer)];\n+    // Parse attributes that appear before an item\n+    fn parse_outer_attributes() -> [ast::attribute] {\n+        let mut attrs: [ast::attribute] = [];\n+        while self.token == token::POUND\n+            && self.look_ahead(1u) == token::LBRACKET {\n+            attrs += [self.parse_attribute(ast::attr_outer)];\n+        }\n+        ret attrs;\n     }\n-    ret attrs;\n-}\n \n-fn parse_attribute(p: parser, style: ast::attr_style) -> ast::attribute {\n-    let lo = p.span.lo;\n-    p.expect(token::POUND);\n-    ret parse_attribute_naked(p, style, lo);\n-}\n+    fn parse_attribute(style: ast::attr_style) -> ast::attribute {\n+        let lo = self.span.lo;\n+        self.expect(token::POUND);\n+        ret self.parse_attribute_naked(style, lo);\n+    }\n \n-fn parse_attribute_naked(p: parser, style: ast::attr_style, lo: uint) ->\n-   ast::attribute {\n-    p.expect(token::LBRACKET);\n-    let meta_item = parse_meta_item(p);\n-    p.expect(token::RBRACKET);\n-    let mut hi = p.span.hi;\n-    ret spanned(lo, hi, {style: style, value: *meta_item});\n-}\n+    fn parse_attribute_naked(style: ast::attr_style, lo: uint) ->\n+        ast::attribute {\n+        self.expect(token::LBRACKET);\n+        let meta_item = self.parse_meta_item();\n+        self.expect(token::RBRACKET);\n+        let mut hi = self.span.hi;\n+        ret spanned(lo, hi, {style: style, value: *meta_item});\n+    }\n \n-// Parse attributes that appear after the opening of an item, each terminated\n-// by a semicolon. In addition to a vector of inner attributes, this function\n-// also returns a vector that may contain the first outer attribute of the\n-// next item (since we can't know whether the attribute is an inner attribute\n-// of the containing item or an outer attribute of the first contained item\n-// until we see the semi).\n-fn parse_inner_attrs_and_next(p: parser) ->\n-   {inner: [ast::attribute], next: [ast::attribute]} {\n-    let mut inner_attrs: [ast::attribute] = [];\n-    let mut next_outer_attrs: [ast::attribute] = [];\n-    while p.token == token::POUND {\n-        if p.look_ahead(1u) != token::LBRACKET {\n-            // This is an extension\n-            break;\n+    // Parse attributes that appear after the opening of an item, each\n+    // terminated by a semicolon. In addition to a vector of inner attributes,\n+    // this function also returns a vector that may contain the first outer\n+    // attribute of the next item (since we can't know whether the attribute\n+    // is an inner attribute of the containing item or an outer attribute of\n+    // the first contained item until we see the semi).\n+    fn parse_inner_attrs_and_next() ->\n+        {inner: [ast::attribute], next: [ast::attribute]} {\n+        let mut inner_attrs: [ast::attribute] = [];\n+        let mut next_outer_attrs: [ast::attribute] = [];\n+        while self.token == token::POUND {\n+            if self.look_ahead(1u) != token::LBRACKET {\n+                // This is an extension\n+                break;\n+            }\n+            let attr = self.parse_attribute(ast::attr_inner);\n+            if self.token == token::SEMI {\n+                self.bump();\n+                inner_attrs += [attr];\n+            } else {\n+                // It's not really an inner attribute\n+                let outer_attr =\n+                    spanned(attr.span.lo, attr.span.hi,\n+                            {style: ast::attr_outer, value: attr.node.value});\n+                next_outer_attrs += [outer_attr];\n+                break;\n+            }\n         }\n-        let attr = parse_attribute(p, ast::attr_inner);\n-        if p.token == token::SEMI {\n-            p.bump();\n-            inner_attrs += [attr];\n-        } else {\n-            // It's not really an inner attribute\n-            let outer_attr =\n-                spanned(attr.span.lo, attr.span.hi,\n-                        {style: ast::attr_outer, value: attr.node.value});\n-            next_outer_attrs += [outer_attr];\n-            break;\n+        ret {inner: inner_attrs, next: next_outer_attrs};\n+    }\n+\n+    fn parse_meta_item() -> @ast::meta_item {\n+        let lo = self.span.lo;\n+        let ident = self.parse_ident();\n+        alt self.token {\n+          token::EQ {\n+            self.bump();\n+            let lit = self.parse_lit();\n+            let mut hi = self.span.hi;\n+            ret @spanned(lo, hi, ast::meta_name_value(ident, lit));\n+          }\n+          token::LPAREN {\n+            let inner_items = self.parse_meta_seq();\n+            let mut hi = self.span.hi;\n+            ret @spanned(lo, hi, ast::meta_list(ident, inner_items));\n+          }\n+          _ {\n+            let mut hi = self.span.hi;\n+            ret @spanned(lo, hi, ast::meta_word(ident));\n+          }\n         }\n     }\n-    ret {inner: inner_attrs, next: next_outer_attrs};\n-}\n \n-fn parse_meta_item(p: parser) -> @ast::meta_item {\n-    let lo = p.span.lo;\n-    let ident = p.parse_ident();\n-    alt p.token {\n-      token::EQ {\n-        p.bump();\n-        let lit = p.parse_lit();\n-        let mut hi = p.span.hi;\n-        ret @spanned(lo, hi, ast::meta_name_value(ident, lit));\n-      }\n-      token::LPAREN {\n-        let inner_items = parse_meta_seq(p);\n-        let mut hi = p.span.hi;\n-        ret @spanned(lo, hi, ast::meta_list(ident, inner_items));\n-      }\n-      _ {\n-        let mut hi = p.span.hi;\n-        ret @spanned(lo, hi, ast::meta_word(ident));\n-      }\n+    fn parse_meta_seq() -> [@ast::meta_item] {\n+        ret self.parse_seq(token::LPAREN, token::RPAREN,\n+                           seq_sep(token::COMMA),\n+                           {|p| p.parse_meta_item()}).node;\n     }\n-}\n \n-fn parse_meta_seq(p: parser) -> [@ast::meta_item] {\n-    ret p.parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n-                    {|p| parse_meta_item(p)}).node;\n+    fn parse_optional_meta() -> [@ast::meta_item] {\n+        alt self.token { token::LPAREN { ret self.parse_meta_seq(); }\n+                         _ { ret []; } }\n+    }\n }\n \n-fn parse_optional_meta(p: parser) -> [@ast::meta_item] {\n-    alt p.token { token::LPAREN { ret parse_meta_seq(p); } _ { ret []; } }\n-}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "98d75499878816c9cb2bdefc227d61c0f7984d5e", "filename": "src/librustsyntax/parse/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Feval.rs?ref=5b72e52e472ca06f42700a322dc2cac4c38e05f1", "patch": "@@ -1,5 +1,5 @@\n import parser::{parser, SOURCE_FILE};\n-import attr::parse_inner_attrs_and_next;\n+import attr::parser_attr;\n \n export eval_crate_directives_to_mod;\n \n@@ -65,7 +65,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n     if file_exists(modpath) {\n         #debug(\"found companion mod\");\n         let p0 = new_parser_from_file(cx.sess, cx.cfg, modpath, SOURCE_FILE);\n-        let inner_attrs = parse_inner_attrs_and_next(p0);\n+        let inner_attrs = p0.parse_inner_attrs_and_next();\n         let first_item_outer_attrs = inner_attrs.next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         cx.sess.chpos = p0.reader.chpos;\n@@ -97,7 +97,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n             } else { prefix + path::path_sep() + file_path };\n         let p0 =\n             new_parser_from_file(cx.sess, cx.cfg, full_path, SOURCE_FILE);\n-        let inner_attrs = parse_inner_attrs_and_next(p0);\n+        let inner_attrs = p0.parse_inner_attrs_and_next();\n         let mod_attrs = attrs + inner_attrs.inner;\n         let first_item_outer_attrs = inner_attrs.next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);"}, {"sha": "4f502d037cb204ea68018882ea4a7c692485697a", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=5b72e52e472ca06f42700a322dc2cac4c38e05f1", "patch": "@@ -8,10 +8,7 @@ import ast_util::{spanned, mk_sp, ident_to_path, operator_prec};\n import ast::*;\n import lexer::reader;\n import prec::{as_prec, token_to_binop};\n-import attr::{parse_outer_attrs_or_ext,\n-              parse_inner_attrs_and_next,\n-              parse_outer_attributes,\n-              parse_optional_meta};\n+import attr::parser_attr;\n import common::*;\n import dvec::{dvec, extensions};\n \n@@ -168,7 +165,7 @@ class parser {\n \n     fn parse_ty_methods() -> [ty_method] {\n         (self.parse_seq(token::LBRACE, token::RBRACE, seq_sep_none()) { |p|\n-            let attrs = parse_outer_attributes(p);\n+            let attrs = p.parse_outer_attributes();\n             let flo = p.span.lo;\n             let pur = p.parse_fn_purity();\n             let ident = p.parse_method_name();\n@@ -1529,7 +1526,7 @@ class parser {\n             ret @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else {\n             let mut item_attrs;\n-            alt parse_outer_attrs_or_ext(self, first_item_attrs) {\n+            alt self.parse_outer_attrs_or_ext(first_item_attrs) {\n               none { item_attrs = []; }\n               some(left(attrs)) { item_attrs = attrs; }\n               some(right(ext)) {\n@@ -1575,7 +1572,7 @@ class parser {\n         fn maybe_parse_inner_attrs_and_next(p: parser, parse_attrs: bool) ->\n             {inner: [attribute], next: [attribute]} {\n             if parse_attrs {\n-                parse_inner_attrs_and_next(p)\n+                p.parse_inner_attrs_and_next()\n             } else {\n                 {inner: [], next: []}\n             }\n@@ -1832,7 +1829,7 @@ class parser {\n     }\n \n     fn parse_method(pr: visibility) -> @method {\n-        let attrs = parse_outer_attributes(self);\n+        let attrs = self.parse_outer_attributes();\n         let lo = self.span.lo, pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n         let tps = self.parse_ty_params();\n@@ -2072,7 +2069,7 @@ class parser {\n         let mut items: [@item] = [];\n         let mut first = true;\n         while self.token != term {\n-            let mut attrs = parse_outer_attributes(self);\n+            let mut attrs = self.parse_outer_attributes();\n             if first { attrs = attrs_remaining + attrs; first = false; }\n             #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n             let vis = self.parse_visibility(private);\n@@ -2107,7 +2104,7 @@ class parser {\n     fn parse_item_mod() -> item_info {\n         let id = self.parse_ident();\n         self.expect(token::LBRACE);\n-        let inner_attrs = parse_inner_attrs_and_next(self);\n+        let inner_attrs = self.parse_inner_attrs_and_next();\n         let m = self.parse_mod_items(token::RBRACE, inner_attrs.next);\n         self.expect(token::RBRACE);\n         (id, item_mod(m), some(inner_attrs.inner))\n@@ -2152,7 +2149,7 @@ class parser {\n         let mut items: [@native_item] = [];\n         let mut initial_attrs = attrs_remaining;\n         while self.token != token::RBRACE {\n-            let attrs = initial_attrs + parse_outer_attributes(self);\n+            let attrs = initial_attrs + self.parse_outer_attributes();\n             initial_attrs = [];\n             items += [self.parse_native_item(attrs)];\n         }\n@@ -2164,7 +2161,7 @@ class parser {\n         self.expect_keyword(\"mod\");\n         let id = self.parse_ident();\n         self.expect(token::LBRACE);\n-        let more_attrs = parse_inner_attrs_and_next(self);\n+        let more_attrs = self.parse_inner_attrs_and_next();\n         let m = self.parse_native_mod_items(more_attrs.next);\n         self.expect(token::RBRACE);\n         (id, item_native_mod(m), some(more_attrs.inner))\n@@ -2221,7 +2218,7 @@ class parser {\n         let mut all_nullary = true, have_disr = false;\n \n         while self.token != token::RBRACE {\n-            let variant_attrs = parse_outer_attributes(self);\n+            let variant_attrs = self.parse_outer_attributes();\n             let vlo = self.span.lo;\n             let vis = self.parse_visibility(default_vis);\n             let ident = self.parse_value_ident();\n@@ -2331,7 +2328,7 @@ class parser {\n \n     fn parse_use() -> view_item_ {\n         let ident = self.parse_ident();\n-        let metadata = parse_optional_meta(self);\n+        let metadata = self.parse_optional_meta();\n         ret view_item_use(ident, metadata, self.get_id());\n     }\n \n@@ -2439,20 +2436,20 @@ class parser {\n     fn parse_view(+first_item_attrs: [attribute],\n                   only_imports: bool) -> {attrs_remaining: [attribute],\n                                           view_items: [@view_item]} {\n-        let mut attrs = first_item_attrs + parse_outer_attributes(self);\n+        let mut attrs = first_item_attrs + self.parse_outer_attributes();\n         let mut items = [];\n         while if only_imports { self.is_keyword(\"import\") }\n         else { self.is_view_item() } {\n             items += [self.parse_view_item(attrs)];\n-            attrs = parse_outer_attributes(self);\n+            attrs = self.parse_outer_attributes();\n         }\n         {attrs_remaining: attrs, view_items: items}\n     }\n \n     // Parses a source module as a crate\n     fn parse_crate_mod(_cfg: crate_cfg) -> @crate {\n         let lo = self.span.lo;\n-        let crate_attrs = parse_inner_attrs_and_next(self);\n+        let crate_attrs = self.parse_inner_attrs_and_next();\n         let first_item_outer_attrs = crate_attrs.next;\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n         ret @spanned(lo, self.span.lo,\n@@ -2481,7 +2478,7 @@ class parser {\n         crate_directive {\n \n         // Collect the next attributes\n-        let outer_attrs = first_outer_attr + parse_outer_attributes(self);\n+        let outer_attrs = first_outer_attr + self.parse_outer_attributes();\n         // In a crate file outer attributes are only going to apply to mods\n         let expect_mod = vec::len(outer_attrs) > 0u;\n \n@@ -2499,7 +2496,7 @@ class parser {\n               // mod x = \"foo_dir\" { ...directives... }\n               token::LBRACE {\n                 self.bump();\n-                let inner_attrs = parse_inner_attrs_and_next(self);\n+                let inner_attrs = self.parse_inner_attrs_and_next();\n                 let mod_attrs = outer_attrs + inner_attrs.inner;\n                 let next_outer_attr = inner_attrs.next;\n                 let cdirs = self.parse_crate_directives(token::RBRACE,"}, {"sha": "a16c90b4c083aa48ae2c99c8c10c7cd529b7a717", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b72e52e472ca06f42700a322dc2cac4c38e05f1/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=5b72e52e472ca06f42700a322dc2cac4c38e05f1", "patch": "@@ -23,6 +23,7 @@ mod test {\n     fn parse_attributes(source: str) -> [ast::attribute] {\n         import syntax::parse;\n         import parse::parser;\n+        import parse::attr::parser_attr;\n         import syntax::codemap;\n         import syntax::diagnostic;\n \n@@ -38,7 +39,7 @@ mod test {\n         let parser = parse::new_parser_from_source_str(\n             parse_sess, [], \"-\", codemap::fss_none, @source);\n \n-        parse::attr::parse_outer_attributes(parser)\n+        parser.parse_outer_attributes()\n     }\n }\n "}]}