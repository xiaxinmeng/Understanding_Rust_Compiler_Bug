{"sha": "4bd4838c15f75c693840d33b9c48ad7d6a310791", "node_id": "C_kwDOAAsO6NoAKDRiZDQ4MzhjMTVmNzVjNjkzODQwZDMzYjljNDhhZDdkNmEzMTA3OTE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-05T09:08:00Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-08T15:27:09Z"}, "message": "Implement strict comment parsing for ui tests", "tree": {"sha": "5deb17e62902343632fe3273ebb0b497f3ce1586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5deb17e62902343632fe3273ebb0b497f3ce1586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd4838c15f75c693840d33b9c48ad7d6a310791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd4838c15f75c693840d33b9c48ad7d6a310791", "html_url": "https://github.com/rust-lang/rust/commit/4bd4838c15f75c693840d33b9c48ad7d6a310791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd4838c15f75c693840d33b9c48ad7d6a310791/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde87d18239b8d9afa9c6bf1051bf5573dbf326e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde87d18239b8d9afa9c6bf1051bf5573dbf326e", "html_url": "https://github.com/rust-lang/rust/commit/cde87d18239b8d9afa9c6bf1051bf5573dbf326e"}], "stats": {"total": 267, "additions": 235, "deletions": 32}, "files": [{"sha": "be51535d59bf326c80c2f0ac64297d4ec4afc428", "filename": "miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4838c15f75c693840d33b9c48ad7d6a310791/miri", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4838c15f75c693840d33b9c48ad7d6a310791/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=4bd4838c15f75c693840d33b9c48ad7d6a310791", "patch": "@@ -181,8 +181,8 @@ test|test-debug|bless|bless-debug)\n     esac\n     # Then test, and let caller control flags.\n     # Only in root project and ui_test as `cargo-miri` has no tests.\n-    $CARGO test $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml \"$@\"\n     $CARGO test $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/ui_test/Cargo.toml \"$@\"\n+    $CARGO test $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml \"$@\"\n     ;;\n run|run-debug)\n     # Scan for \"--target\" to overwrite the \"MIRI_TEST_TARGET\" env var so"}, {"sha": "d4ee3efd1404f2e08d770ea441e92b851ec2fa31", "filename": "ui_test/src/comments.rs", "status": "modified", "additions": 209, "deletions": 31, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4838c15f75c693840d33b9c48ad7d6a310791/ui_test%2Fsrc%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4838c15f75c693840d33b9c48ad7d6a310791/ui_test%2Fsrc%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fcomments.rs?ref=4bd4838c15f75c693840d33b9c48ad7d6a310791", "patch": "@@ -64,6 +64,43 @@ impl Condition {\n     }\n }\n \n+macro_rules! checked {\n+    ($path:expr, $l:expr) => {\n+        let path = $path;\n+        let l = $l;\n+        #[allow(unused_macros)]\n+        macro_rules! exit {\n+            ($fmt:expr $$(,$args:expr)*) => {{\n+                eprint!(\"{}:{l}: \", path.display());\n+                eprintln!($fmt, $$($args,)*);\n+                #[cfg(not(test))]\n+                std::process::exit(1);\n+                #[cfg(test)]\n+                panic!();\n+            }};\n+        }\n+        #[allow(unused_macros)]\n+        macro_rules! check {\n+            ($cond:expr, $fmt:expr $$(,$args:expr)*) => {{\n+                if !$cond {\n+                    exit!($fmt $$(,$args)*);\n+                }\n+            }};\n+        }\n+        #[allow(unused_macros)]\n+        macro_rules! unwrap {\n+            ($cond:expr, $fmt:expr $$(,$args:expr)*) => {{\n+                match $cond {\n+                    Some(val) => val,\n+                    None => {\n+                        exit!($fmt $$(,$args)*);\n+                    }\n+                }\n+            }};\n+        }\n+    };\n+}\n+\n impl Comments {\n     pub(crate) fn parse_file(path: &Path) -> Self {\n         let content = std::fs::read_to_string(path).unwrap();\n@@ -72,14 +109,45 @@ impl Comments {\n \n     /// Parse comments in `content`.\n     /// `path` is only used to emit diagnostics if parsing fails.\n-    pub(crate) fn parse(path: &Path, content: &str) -> Self {\n+    ///\n+    /// This function will only parse `//@` and `//~` style comments\n+    /// and ignore all others\n+    fn parse_checked(path: &Path, content: &str) -> Self {\n         let mut this = Self::default();\n-        let error_pattern_regex =\n-            Regex::new(r\"//(\\[(?P<revision>[^\\]]+)\\])?~(?P<offset>\\||[\\^]+)? *(?P<level>ERROR|HELP|WARN|NOTE)?:?(?P<text>.*)\")\n-                .unwrap();\n \n         // The line that a `|` will refer to\n         let mut fallthrough_to = None;\n+        for (l, line) in content.lines().enumerate() {\n+            let l = l + 1; // enumerate starts at 0, but line numbers start at 1\n+            if let Some((_, command)) = line.split_once(\"//@\") {\n+                let command = command.trim();\n+                if let Some((command, args)) = command.split_once(':') {\n+                    this.parse_command_with_args(command, args, path, l);\n+                } else if let Some((command, _comments)) = command.split_once(' ') {\n+                    this.parse_command(command, path, l)\n+                } else {\n+                    this.parse_command(command, path, l)\n+                }\n+            } else if let Some((_, pattern)) = line.split_once(\"//~\") {\n+                this.parse_pattern(pattern, &mut fallthrough_to, path, l)\n+            } else if let Some((_, pattern)) = line.split_once(\"//[\") {\n+                this.parse_revisioned_pattern(pattern, &mut fallthrough_to, path, l)\n+            } else {\n+                fallthrough_to = None;\n+            }\n+        }\n+        this\n+    }\n+\n+    /// Parse comments in `content`.\n+    /// `path` is only used to emit diagnostics if parsing fails.\n+    pub(crate) fn parse(path: &Path, content: &str) -> Self {\n+        let mut this = Self::parse_checked(path, content);\n+        if content.contains(\"//@\") {\n+            // Migration mode: if new syntax is used, ignore all old syntax\n+            return this;\n+        }\n+\n         for (l, line) in content.lines().enumerate() {\n             let l = l + 1; // enumerate starts at 0, but line numbers start at 1\n             if let Some(revisions) = line.strip_prefix(\"// revisions:\") {\n@@ -140,36 +208,146 @@ impl Comments {\n                 );\n                 this.error_pattern = Some((s.trim().to_string(), l));\n             }\n-            if let Some(captures) = error_pattern_regex.captures(line) {\n-                // FIXME: check that the error happens on the marked line\n-                let matched = captures[\"text\"].trim().to_string();\n+        }\n+        this\n+    }\n \n-                let revision = captures.name(\"revision\").map(|rev| rev.as_str().to_string());\n+    fn parse_command_with_args(&mut self, command: &str, args: &str, path: &Path, l: usize) {\n+        checked!(path, l);\n+        match command {\n+            \"revisions\" => {\n+                check!(self.revisions.is_none(), \"cannot specifiy revisions twice\");\n+                self.revisions = Some(args.split_whitespace().map(|s| s.to_string()).collect());\n+            }\n+            \"compile-flags\" => {\n+                self.compile_flags.extend(args.split_whitespace().map(|s| s.to_string()));\n+            }\n+            \"rustc-env\" =>\n+                for env in args.split_whitespace() {\n+                    let (k, v) = unwrap!(\n+                        env.split_once('='),\n+                        \"environment variables must be key/value pairs separated by a `=`\"\n+                    );\n+                    self.env_vars.push((k.to_string(), v.to_string()));\n+                },\n+            \"normalize-stderr-test\" => {\n+                let (from, to) =\n+                    unwrap!(args.split_once(\"->\"), \"normalize-stderr-test needs a `->`\");\n+                let from = from.trim().trim_matches('\"');\n+                let to = to.trim().trim_matches('\"');\n+                let from = unwrap!(Regex::new(from).ok(), \"invalid regex\");\n+                self.normalize_stderr.push((from, to.to_string()));\n+            }\n+            \"error-pattern\" => {\n+                check!(\n+                    self.error_pattern.is_none(),\n+                    \"cannot specifiy error_pattern twice, previous: {:?}\",\n+                    self.error_pattern\n+                );\n+                self.error_pattern = Some((args.trim().to_string(), l));\n+            }\n+            _ => exit!(\"unknown command {command} with args {args}\"),\n+        }\n+    }\n \n-                let level = captures.name(\"level\").map(|rev| rev.as_str().parse().unwrap());\n+    fn parse_command(&mut self, command: &str, path: &Path, l: usize) {\n+        checked!(path, l);\n \n-                let match_line = match captures.name(\"offset\").map(|rev| rev.as_str()) {\n-                    Some(\"|\") => fallthrough_to.expect(\"`//~|` pattern without preceding line\"),\n-                    Some(pat) => {\n-                        debug_assert!(pat.chars().all(|c| c == '^'));\n-                        l - pat.len()\n-                    }\n-                    None => l,\n-                };\n-\n-                fallthrough_to = Some(match_line);\n-\n-                this.error_matches.push(ErrorMatch {\n-                    matched,\n-                    revision,\n-                    level,\n-                    definition_line: l,\n-                    line: match_line,\n-                });\n-            } else {\n-                fallthrough_to = None;\n-            }\n+        if let Some(s) = command.strip_prefix(\"ignore-\") {\n+            self.ignore.push(Condition::parse(s));\n+            return;\n         }\n-        this\n+\n+        if let Some(s) = command.strip_prefix(\"only-\") {\n+            self.only.push(Condition::parse(s));\n+            return;\n+        }\n+\n+        if command.starts_with(\"stderr-per-bitwidth\") {\n+            check!(!self.stderr_per_bitwidth, \"cannot specifiy stderr-per-bitwidth twice\");\n+            self.stderr_per_bitwidth = true;\n+            return;\n+        }\n+\n+        exit!(\"unknown command {command}\");\n+    }\n+\n+    fn parse_pattern(\n+        &mut self,\n+        pattern: &str,\n+        fallthrough_to: &mut Option<usize>,\n+        path: &Path,\n+        l: usize,\n+    ) {\n+        self.parse_pattern_inner(pattern, fallthrough_to, None, path, l)\n+    }\n+\n+    fn parse_revisioned_pattern(\n+        &mut self,\n+        pattern: &str,\n+        fallthrough_to: &mut Option<usize>,\n+        path: &Path,\n+        l: usize,\n+    ) {\n+        checked!(path, l);\n+        let (revision, pattern) =\n+            unwrap!(pattern.split_once(']'), \"`//[` without corresponding `]`\");\n+        if pattern.starts_with('~') {\n+            self.parse_pattern_inner(\n+                &pattern[1..],\n+                fallthrough_to,\n+                Some(revision.to_owned()),\n+                path,\n+                l,\n+            )\n+        } else {\n+            exit!(\"revisioned pattern must have `~` following the `]`\");\n+        }\n+    }\n+\n+    // parse something like (?P<offset>\\||[\\^]+)? *(?P<level>ERROR|HELP|WARN|NOTE)?:?(?P<text>.*)\n+    fn parse_pattern_inner(\n+        &mut self,\n+        pattern: &str,\n+        fallthrough_to: &mut Option<usize>,\n+        revision: Option<String>,\n+        path: &Path,\n+        l: usize,\n+    ) {\n+        checked!(path, l);\n+        // FIXME: check that the error happens on the marked line\n+\n+        let (match_line, pattern) = match unwrap!(pattern.chars().next(), \"no pattern specified\") {\n+            '|' =>\n+                (*unwrap!(fallthrough_to, \"`//~|` pattern without preceding line\"), &pattern[1..]),\n+            '^' => {\n+                let offset = pattern.chars().take_while(|&c| c == '^').count();\n+                (l - offset, &pattern[offset..])\n+            }\n+            _ => (l, pattern),\n+        };\n+\n+        let (level, pattern) = match pattern.trim_start().split_once(|c| matches!(c, ':' | ' ')) {\n+            None => (None, pattern),\n+            Some((level, pattern_without_level)) =>\n+                match level.parse().ok() {\n+                    Some(level) => (Some(level), pattern_without_level),\n+                    None => (None, pattern),\n+                },\n+        };\n+\n+        let matched = pattern.trim().to_string();\n+\n+        check!(!matched.is_empty(), \"no pattern specified\");\n+\n+        *fallthrough_to = Some(match_line);\n+\n+        self.error_matches.push(ErrorMatch {\n+            matched,\n+            revision,\n+            level,\n+            definition_line: l,\n+            line: match_line,\n+        });\n     }\n }"}, {"sha": "dc69a5d4d600c9b2c0572a84fa6c6cdccad5b092", "filename": "ui_test/src/comments/tests.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4838c15f75c693840d33b9c48ad7d6a310791/ui_test%2Fsrc%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4838c15f75c693840d33b9c48ad7d6a310791/ui_test%2Fsrc%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fcomments%2Ftests.rs?ref=4bd4838c15f75c693840d33b9c48ad7d6a310791", "patch": "@@ -20,3 +20,28 @@ fn main() {\n         \"encountered a dangling reference (address $HEX is unallocated)\"\n     );\n }\n+\n+#[test]\n+fn parse_slash_slash_at() {\n+    let s = r\"\n+//@  error-pattern:  foomp\n+use std::mem;\n+\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    println!(\"parsed comments: {:#?}\", comments);\n+    assert_eq!(comments.error_pattern, Some((\"foomp\".to_string(), 2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn parse_slash_slash_at_fail() {\n+    let s = r\"\n+//@  error-pattern  foomp\n+use std::mem;\n+\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    println!(\"parsed comments: {:#?}\", comments);\n+    assert_eq!(comments.error_pattern, Some((\"foomp\".to_string(), 2)));\n+}"}]}