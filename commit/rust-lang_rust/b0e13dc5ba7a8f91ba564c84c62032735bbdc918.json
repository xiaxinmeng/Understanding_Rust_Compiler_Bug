{"sha": "b0e13dc5ba7a8f91ba564c84c62032735bbdc918", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZTEzZGM1YmE3YThmOTFiYTU2NGM4NGM2MjAzMjczNWJiZGM5MTg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-28T03:40:58Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-10T06:04:40Z"}, "message": "Treat `extern crate`s more like imports (pure refactoring).", "tree": {"sha": "21dc428093fe83b2ad0f7a29b2b281e22aa2b4be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21dc428093fe83b2ad0f7a29b2b281e22aa2b4be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0e13dc5ba7a8f91ba564c84c62032735bbdc918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e13dc5ba7a8f91ba564c84c62032735bbdc918", "html_url": "https://github.com/rust-lang/rust/commit/b0e13dc5ba7a8f91ba564c84c62032735bbdc918", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0e13dc5ba7a8f91ba564c84c62032735bbdc918/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8021ede6011a3fc4f74079b8f8f45df252e6f53a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8021ede6011a3fc4f74079b8f8f45df252e6f53a", "html_url": "https://github.com/rust-lang/rust/commit/8021ede6011a3fc4f74079b8f8f45df252e6f53a"}], "stats": {"total": 91, "additions": 52, "deletions": 39}, "files": [{"sha": "ca6e72dd4f44d691bbdffcc6c84b3f07d2f76cbe", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0e13dc5ba7a8f91ba564c84c62032735bbdc918/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e13dc5ba7a8f91ba564c84c62032735bbdc918/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b0e13dc5ba7a8f91ba564c84c62032735bbdc918", "patch": "@@ -14,6 +14,7 @@\n //! any imports resolved.\n \n use macros::{InvocationData, LegacyScope};\n+use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n@@ -237,11 +238,22 @@ impl<'b> Resolver<'b> {\n                         index: CRATE_DEF_INDEX,\n                     };\n                     let module = self.arenas.alloc_module(ModuleS {\n-                        extern_crate_id: Some(item.id),\n                         populated: Cell::new(false),\n                         ..ModuleS::new(Some(parent), ModuleKind::Def(Def::Mod(def_id), name))\n                     });\n-                    self.define(parent, name, TypeNS, (module, sp, vis));\n+                    let binding = (module, sp, ty::Visibility::Public).to_name_binding();\n+                    let binding = self.arenas.alloc_name_binding(binding);\n+                    let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                        id: item.id,\n+                        parent: parent,\n+                        imported_module: Cell::new(Some(module)),\n+                        subclass: ImportDirectiveSubclass::ExternCrate,\n+                        span: item.span,\n+                        module_path: Vec::new(),\n+                        vis: Cell::new(vis),\n+                    });\n+                    let imported_binding = self.import(binding, directive);\n+                    self.define(parent, name, TypeNS, imported_binding);\n                     self.populate_module_if_necessary(module);\n                     module\n                 } else {"}, {"sha": "4de272bc3a04505837f2a57235d4d4a2f0147a23", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b0e13dc5ba7a8f91ba564c84c62032735bbdc918/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e13dc5ba7a8f91ba564c84c62032735bbdc918/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b0e13dc5ba7a8f91ba564c84c62032735bbdc918", "patch": "@@ -76,7 +76,7 @@ use std::fmt;\n use std::mem::replace;\n use std::rc::Rc;\n \n-use resolve_imports::{ImportDirective, NameResolution};\n+use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution};\n use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -796,10 +796,6 @@ pub struct ModuleS<'a> {\n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n \n-    // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n-    // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n-    extern_crate_id: Option<NodeId>,\n-\n     resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n     no_implicit_prelude: bool,\n@@ -824,7 +820,6 @@ impl<'a> ModuleS<'a> {\n             parent: parent,\n             kind: kind,\n             normal_ancestor_id: None,\n-            extern_crate_id: None,\n             resolutions: RefCell::new(FxHashMap()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n@@ -953,7 +948,14 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_extern_crate(&self) -> bool {\n-        self.module().ok().and_then(|module| module.extern_crate_id).is_some()\n+        match self.kind {\n+            NameBindingKind::Import {\n+                directive: &ImportDirective {\n+                    subclass: ImportDirectiveSubclass::ExternCrate, ..\n+                }, ..\n+            } => true,\n+            _ => false,\n+        }\n     }\n \n     fn is_import(&self) -> bool {\n@@ -3233,7 +3235,7 @@ impl<'a> Resolver<'a> {\n             in_module.for_each_child(|name, ns, name_binding| {\n \n                 // avoid imports entirely\n-                if name_binding.is_import() { return; }\n+                if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n \n                 // collect results based on the filter function\n                 if name == lookup_name && ns == namespace {\n@@ -3269,21 +3271,11 @@ impl<'a> Resolver<'a> {\n                 // collect submodules to explore\n                 if let Ok(module) = name_binding.module() {\n                     // form the path\n-                    let path_segments = match module.kind {\n-                        _ if module.parent.is_none() => path_segments.clone(),\n-                        ModuleKind::Def(_, name) => {\n-                            let mut paths = path_segments.clone();\n-                            let ident = Ident::with_empty_ctxt(name);\n-                            let params = PathParameters::none();\n-                            let segm = PathSegment {\n-                                identifier: ident,\n-                                parameters: params,\n-                            };\n-                            paths.push(segm);\n-                            paths\n-                        }\n-                        _ => bug!(),\n-                    };\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(PathSegment {\n+                        identifier: Ident::with_empty_ctxt(name),\n+                        parameters: PathParameters::none(),\n+                    });\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n@@ -3369,7 +3361,10 @@ impl<'a> Resolver<'a> {\n             if !reported_spans.insert(span) { continue }\n             if binding.is_extern_crate() {\n                 // Warn when using an inaccessible extern crate.\n-                let node_id = binding.module().unwrap().extern_crate_id.unwrap();\n+                let node_id = match binding.kind {\n+                    NameBindingKind::Import { directive, .. } => directive.id,\n+                    _ => unreachable!(),\n+                };\n                 let msg = format!(\"extern crate `{}` is private\", name);\n                 self.session.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE, node_id, span, msg);\n             } else {\n@@ -3415,7 +3410,7 @@ impl<'a> Resolver<'a> {\n             _ => \"enum\",\n         };\n \n-        let (participle, noun) = match old_binding.is_import() || old_binding.is_extern_crate() {\n+        let (participle, noun) = match old_binding.is_import() {\n             true => (\"imported\", \"import\"),\n             false => (\"defined\", \"definition\"),\n         };\n@@ -3424,7 +3419,7 @@ impl<'a> Resolver<'a> {\n         let msg = {\n             let kind = match (ns, old_binding.module()) {\n                 (ValueNS, _) => \"a value\",\n-                (TypeNS, Ok(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n+                (TypeNS, _) if old_binding.is_extern_crate() => \"an extern crate\",\n                 (TypeNS, Ok(module)) if module.is_normal() => \"a module\",\n                 (TypeNS, Ok(module)) if module.is_trait() => \"a trait\",\n                 (TypeNS, _) => \"a type\",\n@@ -3439,7 +3434,7 @@ impl<'a> Resolver<'a> {\n                 e.span_label(span, &format!(\"`{}` was already imported\", name));\n                 e\n             },\n-            (true, _) | (_, true) if binding.is_import() || old_binding.is_import() => {\n+            (true, _) | (_, true) if binding.is_import() && old_binding.is_import() => {\n                 let mut e = struct_span_err!(self.session, span, E0254, \"{}\", msg);\n                 e.span_label(span, &\"already imported\");\n                 e"}, {"sha": "91a7dc4249ac5fde408bd42716f4c6951e24672a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0e13dc5ba7a8f91ba564c84c62032735bbdc918/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e13dc5ba7a8f91ba564c84c62032735bbdc918/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b0e13dc5ba7a8f91ba564c84c62032735bbdc918", "patch": "@@ -51,6 +51,7 @@ pub enum ImportDirectiveSubclass<'a> {\n         max_vis: Cell<ty::Visibility>, // The visibility of the greatest reexport.\n         // n.b. `max_vis` is only used in `finalize_import` to check for reexport errors.\n     },\n+    ExternCrate,\n }\n \n impl<'a> ImportDirectiveSubclass<'a> {\n@@ -68,12 +69,12 @@ impl<'a> ImportDirectiveSubclass<'a> {\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n-    parent: Module<'a>,\n-    module_path: Vec<Ident>,\n-    imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n-    subclass: ImportDirectiveSubclass<'a>,\n-    span: Span,\n-    vis: Cell<ty::Visibility>,\n+    pub parent: Module<'a>,\n+    pub module_path: Vec<Ident>,\n+    pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n+    pub subclass: ImportDirectiveSubclass<'a>,\n+    pub span: Span,\n+    pub vis: Cell<ty::Visibility>,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -169,7 +170,8 @@ impl<'a> Resolver<'a> {\n         let new_import_semantics = self.new_import_semantics;\n         let is_disallowed_private_import = |binding: &NameBinding| {\n             !new_import_semantics && !allow_private_imports && // disallowed\n-            binding.vis != ty::Visibility::Public && binding.is_import() // non-`pub` import\n+            binding.vis != ty::Visibility::Public && binding.is_import() && // non-`pub` import\n+            !binding.is_extern_crate() // not an `extern crate`\n         };\n \n         if let Some(span) = record_used {\n@@ -237,7 +239,7 @@ impl<'a> Resolver<'a> {\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n-                    GlobImport { .. } => unreachable!(),\n+                    _ => unreachable!(),\n                 };\n                 match self.resolve_name_in_module(module, name, ns, true, None) {\n                     Failed(_) => {}\n@@ -280,13 +282,14 @@ impl<'a> Resolver<'a> {\n             // which are not relevant to import resolution.\n             GlobImport { is_prelude: true, .. } => {}\n             GlobImport { .. } => self.current_module.globs.borrow_mut().push(directive),\n+            _ => unreachable!(),\n         }\n     }\n \n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n-    fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-              -> NameBinding<'a> {\n+    pub fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+                  -> NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n             directive.vis.get()\n@@ -529,6 +532,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 self.resolve_glob_import(directive);\n                 return Success(());\n             }\n+            _ => unreachable!(),\n         };\n \n         let mut indeterminate = false;\n@@ -616,6 +620,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 return Success(());\n             }\n+            _ => unreachable!(),\n         };\n \n         for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n@@ -831,5 +836,6 @@ fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> St\n     match *subclass {\n         SingleImport { source, .. } => source.to_string(),\n         GlobImport { .. } => \"*\".to_string(),\n+        ExternCrate => \"<extern crate>\".to_string(),\n     }\n }"}]}