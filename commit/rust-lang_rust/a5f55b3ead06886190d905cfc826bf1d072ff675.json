{"sha": "a5f55b3ead06886190d905cfc826bf1d072ff675", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZjU1YjNlYWQwNjg4NjE5MGQ5MDVjZmM4MjZiZjFkMDcyZmY2NzU=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-07-29T20:34:08Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-01T22:17:19Z"}, "message": "minor tweaks - unboxed the coroutine so that it is no longer a ~ pointer inside the task struct, and also added an assert to verify that send is never called inside scheduler context as it is undefined (BROKEN) if that happens", "tree": {"sha": "53ad775357b36c7634033971067ef38be31ffa38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53ad775357b36c7634033971067ef38be31ffa38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5f55b3ead06886190d905cfc826bf1d072ff675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5f55b3ead06886190d905cfc826bf1d072ff675", "html_url": "https://github.com/rust-lang/rust/commit/a5f55b3ead06886190d905cfc826bf1d072ff675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5f55b3ead06886190d905cfc826bf1d072ff675/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "997719c13d449821691fcae927d3b94960b5bc03", "url": "https://api.github.com/repos/rust-lang/rust/commits/997719c13d449821691fcae927d3b94960b5bc03", "html_url": "https://github.com/rust-lang/rust/commit/997719c13d449821691fcae927d3b94960b5bc03"}], "stats": {"total": 104, "additions": 72, "deletions": 32}, "files": [{"sha": "bb106edad949a44fc559f296a25df4da67680ca5", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -24,6 +24,7 @@ use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n use cell::Cell;\n use clone::Clone;\n+use rt::{context, SchedulerContext};\n \n /// A combined refcount / BlockedTask-as-uint pointer.\n ///\n@@ -90,6 +91,9 @@ impl<T> ChanOne<T> {\n     }\n \n     pub fn try_send(self, val: T) -> bool {\n+\n+        rtassert!(context() != SchedulerContext);\n+\n         let mut this = self;\n         let mut recvr_active = true;\n         let packet = this.packet();"}, {"sha": "449df8cddea42bd76b208880ab5f37edf368b5fb", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -571,7 +571,7 @@ mod test {\n     #[cfg(test)]\n     fn socket_name(addr: IpAddr) {\n         do run_in_newsched_task {\n-            do spawntask_immediately {\n+            do spawntask {\n                 let listener = TcpListener::bind(addr);\n \n                 assert!(listener.is_some());\n@@ -590,13 +590,13 @@ mod test {\n     #[cfg(test)]\n     fn peer_name(addr: IpAddr) {\n         do run_in_newsched_task {\n-            do spawntask_immediately {\n+            do spawntask {\n                 let mut listener = TcpListener::bind(addr);\n \n                 listener.accept();\n             }\n \n-            do spawntask_immediately {\n+            do spawntask {\n                 let stream = TcpStream::connect(addr);\n \n                 assert!(stream.is_some());"}, {"sha": "c04abfa899b1a484be767af6cd7e1062c7895871", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -267,7 +267,7 @@ mod test {\n     #[cfg(test)]\n     fn socket_name(addr: IpAddr) {\n         do run_in_newsched_task {\n-            do spawntask_immediately {\n+            do spawntask {\n                 let server = UdpSocket::bind(addr);\n \n                 assert!(server.is_some());"}, {"sha": "71e60a6a923ce9a95addf43fac9df325e7da4217", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -120,9 +120,7 @@ impl Local for IoFactoryObject {\n \n #[cfg(test)]\n mod test {\n-//    use unstable::run_in_bare_thread;\n     use rt::test::*;\n-//    use rt::sched::Scheduler;\n     use super::*;\n     use rt::task::Task;\n     use rt::local_ptr;"}, {"sha": "73c30e5779ca82658569691fbe3179357b817889", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -70,7 +70,7 @@ use ptr::RawPtr;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n-use rt::task::{Task, SchedTask, GreenTask};\n+use rt::task::{Task, SchedTask, GreenTask, Sched};\n use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n use rt::uv::uvio::UvEventLoop;\n@@ -244,6 +244,8 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     let nscheds = util::default_sched_threads();\n \n+    let main = Cell::new(main);\n+\n     // The shared list of sleeping schedulers. Schedulers wake each other\n     // occassionally to do new work.\n     let sleepers = SleeperList::new();\n@@ -268,12 +270,19 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     // If we need a main-thread task then create a main thread scheduler\n     // that will reject any task that isn't pinned to it\n-    let mut main_sched = if use_main_sched {\n+    let main_sched = if use_main_sched {\n+\n+        // Create a friend handle.\n+        let mut friend_sched = scheds.pop();\n+        let friend_handle = friend_sched.make_handle();\n+        scheds.push(friend_sched);\n+\n         let main_loop = ~UvEventLoop::new();\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n                                                      work_queue.clone(),\n                                                      sleepers.clone(),\n-                                                     false);\n+                                                     false,\n+                                                     Some(friend_handle));\n         let main_handle = main_sched.make_handle();\n         handles.push(main_handle);\n         Some(main_sched)\n@@ -312,15 +321,16 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     let mut threads = ~[];\n \n+    let on_exit = Cell::new(on_exit);\n+\n     if !use_main_sched {\n \n         // In the case where we do not use a main_thread scheduler we\n         // run the main task in one of our threads.\n-        \n-        let main_cell = Cell::new(main);\n+\n         let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                            main_cell.take());\n-        main_task.death.on_exit = Some(on_exit);\n+                                            main.take());\n+        main_task.death.on_exit = Some(on_exit.take());\n         let main_task_cell = Cell::new(main_task);\n \n         let sched = scheds.pop();\n@@ -347,16 +357,18 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     }\n \n     // If we do have a main thread scheduler, run it now.\n-    \n+\n     if use_main_sched {\n+\n+        let mut main_sched = main_sched.get();\n+\n         let home = Sched(main_sched.make_handle());\n-        let mut main_task = ~Task::new_root_homed(&mut scheds[0].stack_pool, \n-                                                  home, main);\n-        main_task.death.on_exit = Some(on_exit);\n-        let main_task_cell = Cell::new(main_task);\n-        sched.bootstrap(main_task);\n+        let mut main_task = ~Task::new_root_homed(&mut scheds[0].stack_pool,\n+                                                  home, main.take());\n+        main_task.death.on_exit = Some(on_exit.take());\n+        main_sched.bootstrap(main_task);\n     }\n-        \n+\n     // Wait for schedulers\n     foreach thread in threads.consume_iter() {\n         thread.join();"}, {"sha": "816c963ad188623047a573c88739f6558b0406c9", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -10,7 +10,6 @@\n \n use either::{Left, Right};\n use option::{Option, Some, None};\n-use sys;\n use cast::{transmute, transmute_mut_region, transmute_mut_unsafe};\n use clone::Clone;\n use unstable::raw;\n@@ -334,7 +333,7 @@ impl Scheduler {\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n-                this.resume_task_immediately(task);\n+                this.schedule_task_sched_context(task);\n                 return None;\n             }\n             Some(Wake) => {\n@@ -432,7 +431,6 @@ impl Scheduler {\n                     }\n                     AnySched => {\n                         task.give_home(AnySched);\n-//                        this.enqueue_task(task);\n                         this.send_to_friend(task);\n                         return Some(this);\n                     }\n@@ -491,6 +489,36 @@ impl Scheduler {\n         }\n     }\n \n+    // BAD BAD BAD BAD BAD\n+    // Do something instead of just copy-pasting this.\n+    pub fn schedule_task_sched_context(~self, task: ~Task) -> Option<~Scheduler> {\n+\n+        // is the task home?\n+        let is_home = task.is_home_no_tls(&self);\n+\n+        // does the task have a home?\n+        let homed = task.homed();\n+\n+        let mut this = self;\n+\n+        if is_home || (!homed && this.run_anything) {\n+            // here we know we are home, execute now OR we know we\n+            // aren't homed, and that this sched doesn't care\n+            rtdebug!(\"task: %u is on ok sched, executing\", to_uint(task));\n+            this.resume_task_immediately(task);\n+            return None;\n+        } else if !homed && !this.run_anything {\n+            // the task isn't homed, but it can't be run here\n+            this.enqueue_task(task);\n+            return Some(this);\n+        } else {\n+            // task isn't home, so don't run it here, send it home\n+            Scheduler::send_task_home(task);\n+            return Some(this);\n+        }\n+    }\n+\n+\n     // The primary function for changing contexts. In the current\n     // design the scheduler is just a slightly modified GreenTask, so\n     // all context swaps are from Task to Task. The only difference"}, {"sha": "13fdaded84b840dfa2e957b09bb10479bd96e9ed", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -45,9 +45,9 @@ pub struct Task {\n     taskgroup: Option<Taskgroup>,\n     death: Death,\n     destroyed: bool,\n-    coroutine: Option<~Coroutine>,\n     // FIXME(#6874/#7599) use StringRef to save on allocations\n     name: Option<~str>,\n+    coroutine: Option<Coroutine>,\n     sched: Option<~Scheduler>,\n     task_type: TaskType\n }\n@@ -128,7 +128,7 @@ impl Task {\n             taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n-            coroutine: Some(~Coroutine::empty()),\n+            coroutine: Some(Coroutine::empty()),\n             sched: None,\n             task_type: SchedTask\n         }\n@@ -157,8 +157,8 @@ impl Task {\n             taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n-            coroutine: Some(~Coroutine::new(stack_pool, start)),\n             name: None,\n+            coroutine: Some(Coroutine::new(stack_pool, start)),\n             sched: None,\n             task_type: GreenTask(Some(~home))\n         }\n@@ -178,8 +178,8 @@ impl Task {\n             // FIXME(#7544) make watching optional\n             death: self.death.new_child(),\n             destroyed: false,\n-            coroutine: Some(~Coroutine::new(stack_pool, start)),\n             name: None,\n+            coroutine: Some(Coroutine::new(stack_pool, start)),\n             sched: None,\n             task_type: GreenTask(Some(~home))\n         }\n@@ -375,9 +375,9 @@ impl Coroutine {\n     }\n \n     /// Destroy coroutine and try to reuse stack segment.\n-    pub fn recycle(~self, stack_pool: &mut StackPool) {\n+    pub fn recycle(self, stack_pool: &mut StackPool) {\n         match self {\n-            ~Coroutine { current_stack_segment, _ } => {\n+            Coroutine { current_stack_segment, _ } => {\n                 stack_pool.give_segment(current_stack_segment);\n             }\n         }"}, {"sha": "e93333661cfb5ed4eac08e02de02932a8d8d71fe", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5f55b3ead06886190d905cfc826bf1d072ff675/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=a5f55b3ead06886190d905cfc826bf1d072ff675", "patch": "@@ -790,10 +790,8 @@ impl Drop for UvTimer {\n impl RtioTimer for UvTimer {\n     fn sleep(&self, msecs: u64) {\n         let scheduler = Local::take::<Scheduler>();\n-        assert!(scheduler.in_task_context());\n-        do scheduler.deschedule_running_task_and_then |sched, task| {\n+        do scheduler.deschedule_running_task_and_then |_sched, task| {\n             rtdebug!(\"sleep: entered scheduler context\");\n-            assert!(!sched.in_task_context());\n             let task_cell = Cell::new(task);\n             let mut watcher = **self;\n             do watcher.start(msecs, 0) |_, status| {"}]}