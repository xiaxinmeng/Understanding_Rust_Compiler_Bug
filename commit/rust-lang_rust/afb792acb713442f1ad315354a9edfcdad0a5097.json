{"sha": "afb792acb713442f1ad315354a9edfcdad0a5097", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYjc5MmFjYjcxMzQ0MmYxYWQzMTUzNTRhOWVkZmNkYWQwYTUwOTc=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-23T18:16:46Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-23T18:16:46Z"}, "message": "Merge #1316\n\n1316: Simplify code model r=matklad a=matklad\n\n* remove references from types which are now id-based\r\n* remove api/impl separation, as the impl is a tiny fraction of API anyway \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "68f43512c9c1b3610f11bbebd8dda2d349194a9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f43512c9c1b3610f11bbebd8dda2d349194a9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afb792acb713442f1ad315354a9edfcdad0a5097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afb792acb713442f1ad315354a9edfcdad0a5097", "html_url": "https://github.com/rust-lang/rust/commit/afb792acb713442f1ad315354a9edfcdad0a5097", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afb792acb713442f1ad315354a9edfcdad0a5097/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "1dc9adc6e27d603f05f794adda91bca8b6dec8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc9adc6e27d603f05f794adda91bca8b6dec8ac", "html_url": "https://github.com/rust-lang/rust/commit/1dc9adc6e27d603f05f794adda91bca8b6dec8ac"}, {"sha": "ef3169a33a5204c940cc9e0486954b4b35dc3d4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3169a33a5204c940cc9e0486954b4b35dc3d4d", "html_url": "https://github.com/rust-lang/rust/commit/ef3169a33a5204c940cc9e0486954b4b35dc3d4d"}], "stats": {"total": 579, "additions": 244, "deletions": 335}, "files": [{"sha": "49030ce67644d20847cf9f4195b7aac354b6c93b", "filename": "crates/ra_hir/src/code_model.rs", "status": "renamed", "additions": 240, "deletions": 121, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=afb792acb713442f1ad315354a9edfcdad0a5097", "patch": "@@ -1,15 +1,15 @@\n use std::sync::Arc;\n \n-use ra_db::{CrateId, SourceRootId, Edition};\n-use ra_syntax::{ast::self, TreeArc};\n+use ra_db::{CrateId, SourceRootId, Edition, FileId};\n+use ra_syntax::{ast::{self, NameOwner, TypeAscriptionOwner}, TreeArc};\n \n use crate::{\n-    Name, Ty, HirFileId, Either,\n+    Name, AsName, AstId, Ty, HirFileId, Either,\n     HirDatabase, DefDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n     expr::{Body, BodySourceMap, validation::ExprValidator},\n-    ty::{ TraitRef, InferenceResult},\n+    ty::{TraitRef, InferenceResult},\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::HasGenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n@@ -18,6 +18,7 @@ use crate::{\n     resolve::Resolver,\n     diagnostics::{DiagnosticSink},\n     traits::{TraitItem, TraitData},\n+    type_ref::Mutability,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -35,19 +36,28 @@ pub struct CrateDependency {\n }\n \n impl Crate {\n-    pub fn crate_id(&self) -> CrateId {\n+    pub fn crate_id(self) -> CrateId {\n         self.crate_id\n     }\n \n-    pub fn dependencies(&self, db: &impl DefDatabase) -> Vec<CrateDependency> {\n-        self.dependencies_impl(db)\n+    pub fn dependencies(self, db: &impl DefDatabase) -> Vec<CrateDependency> {\n+        db.crate_graph()\n+            .dependencies(self.crate_id)\n+            .map(|dep| {\n+                let krate = Crate { crate_id: dep.crate_id() };\n+                let name = dep.as_name();\n+                CrateDependency { krate, name }\n+            })\n+            .collect()\n     }\n \n-    pub fn root_module(&self, db: &impl DefDatabase) -> Option<Module> {\n-        self.root_module_impl(db)\n+    pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n+        let module_id = db.crate_def_map(self).root();\n+        let module = Module { krate: self, module_id };\n+        Some(module)\n     }\n \n-    pub fn edition(&self, db: &impl DefDatabase) -> Edition {\n+    pub fn edition(self, db: &impl DefDatabase) -> Edition {\n         let crate_graph = db.crate_graph();\n         crate_graph.edition(self.crate_id)\n     }\n@@ -98,29 +108,66 @@ pub enum ModuleSource {\n     Module(TreeArc<ast::Module>),\n }\n \n+impl ModuleSource {\n+    pub(crate) fn new(\n+        db: &impl DefDatabase,\n+        file_id: Option<FileId>,\n+        decl_id: Option<AstId<ast::Module>>,\n+    ) -> ModuleSource {\n+        match (file_id, decl_id) {\n+            (Some(file_id), _) => {\n+                let source_file = db.parse(file_id);\n+                ModuleSource::SourceFile(source_file)\n+            }\n+            (None, Some(item_id)) => {\n+                let module = item_id.to_node(db);\n+                assert!(module.item_list().is_some(), \"expected inline module\");\n+                ModuleSource::Module(module.to_owned())\n+            }\n+            (None, None) => panic!(),\n+        }\n+    }\n+}\n+\n impl Module {\n     /// Name of this module.\n-    pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        self.name_impl(db)\n+    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let parent = def_map[self.module_id].parent?;\n+        def_map[parent].children.iter().find_map(|(name, module_id)| {\n+            if *module_id == self.module_id {\n+                Some(name.clone())\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(&self, db: &impl DefDatabase) -> (HirFileId, ModuleSource) {\n-        self.definition_source_impl(db)\n+    pub fn definition_source(self, db: &impl DefDatabase) -> (HirFileId, ModuleSource) {\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl_id = def_map[self.module_id].declaration;\n+        let file_id = def_map[self.module_id].definition;\n+        let module_source = ModuleSource::new(db, file_id, decl_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n+        (file_id, module_source)\n     }\n \n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n     /// `None` for the crate root.\n     pub fn declaration_source(\n-        &self,\n+        self,\n         db: &impl HirDatabase,\n     ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n-        self.declaration_source_impl(db)\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl = def_map[self.module_id].declaration?;\n+        let ast = decl.to_node(db);\n+        Some((decl.file_id(), ast))\n     }\n \n     /// Returns the syntax of the last path segment corresponding to this import\n     pub fn import_source(\n-        &self,\n+        self,\n         db: &impl HirDatabase,\n         import: ImportId,\n     ) -> Either<TreeArc<ast::UseTree>, TreeArc<ast::ExternCrateItem>> {\n@@ -130,33 +177,44 @@ impl Module {\n     }\n \n     /// Returns the crate this module is part of.\n-    pub fn krate(&self, _db: &impl DefDatabase) -> Option<Crate> {\n+    pub fn krate(self, _db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.krate)\n     }\n \n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n     /// might be missing `krate`. This can happen if a module's file is not included\n     /// in the module tree of any target in `Cargo.toml`.\n-    pub fn crate_root(&self, db: &impl DefDatabase) -> Module {\n-        self.crate_root_impl(db)\n+    pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n+        let def_map = db.crate_def_map(self.krate);\n+        self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        self.child_impl(db, name)\n+    pub fn child(self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let child_id = def_map[self.module_id].children.get(name)?;\n+        Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n-    pub fn children(&self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n-        self.children_impl(db)\n+    pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let children = def_map[self.module_id]\n+            .children\n+            .iter()\n+            .map(|(_, module_id)| self.with_module_id(*module_id))\n+            .collect::<Vec<_>>();\n+        children.into_iter()\n     }\n \n     /// Finds a parent module.\n-    pub fn parent(&self, db: &impl DefDatabase) -> Option<Module> {\n-        self.parent_impl(db)\n+    pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let parent_id = def_map[self.module_id].parent?;\n+        Some(self.with_module_id(parent_id))\n     }\n \n-    pub fn path_to_root(&self, db: &impl HirDatabase) -> Vec<Module> {\n+    pub fn path_to_root(self, db: &impl HirDatabase) -> Vec<Module> {\n         let mut res = vec![self.clone()];\n         let mut curr = self.clone();\n         while let Some(next) = curr.parent(db) {\n@@ -167,11 +225,11 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(&self, db: &impl HirDatabase) -> ModuleScope {\n+    pub fn scope(self, db: &impl HirDatabase) -> ModuleScope {\n         db.crate_def_map(self.krate)[self.module_id].scope.clone()\n     }\n \n-    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         db.crate_def_map(self.krate).add_diagnostics(db, self.module_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n@@ -191,7 +249,7 @@ impl Module {\n         }\n     }\n \n-    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let def_map = db.crate_def_map(self.krate);\n         Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n@@ -216,6 +274,10 @@ impl Module {\n             .map(|(impl_id, _)| ImplBlock::from_id(self, impl_id))\n             .collect()\n     }\n+\n+    fn with_module_id(&self, module_id: CrateModuleId) -> Module {\n+        Module { module_id, krate: self.krate }\n+    }\n }\n \n impl Docs for Module {\n@@ -269,49 +331,49 @@ pub struct Struct {\n }\n \n impl Struct {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.struct_data(*self).name.clone()\n+    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+        db.struct_data(self).name.clone()\n     }\n \n-    pub fn fields(&self, db: &impl HirDatabase) -> Vec<StructField> {\n-        db.struct_data(*self)\n+    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+        db.struct_data(self)\n             .variant_data\n             .fields()\n             .into_iter()\n             .flat_map(|it| it.iter())\n-            .map(|(id, _)| StructField { parent: (*self).into(), id })\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n             .collect()\n     }\n \n-    pub fn field(&self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        db.struct_data(*self)\n+    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        db.struct_data(self)\n             .variant_data\n             .fields()\n             .into_iter()\n             .flat_map(|it| it.iter())\n             .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: (*self).into(), id })\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n     }\n \n-    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def((*self).into(), Namespace::Types)\n+    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n+        db.type_for_def(self.into(), Namespace::Types)\n     }\n \n-    pub fn constructor_ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def((*self).into(), Namespace::Values)\n+    pub fn constructor_ty(self, db: &impl HirDatabase) -> Ty {\n+        db.type_for_def(self.into(), Namespace::Values)\n     }\n \n     // FIXME move to a more general type\n     /// Builds a resolver for type references inside this struct.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self.module(db).resolver(db);\n         // ...and add generic params, if present\n@@ -333,21 +395,21 @@ pub struct Union {\n }\n \n impl Union {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n+    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n         db.struct_data(Struct { id: self.id }).name.clone()\n     }\n \n-    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.id.module(db)\n     }\n \n     // FIXME move to a more general type\n     /// Builds a resolver for type references inside this union.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self.module(db).resolver(db);\n         // ...and add generic params, if present\n@@ -369,41 +431,37 @@ pub struct Enum {\n }\n \n impl Enum {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::EnumDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::EnumDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.enum_data(*self).name.clone()\n+    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+        db.enum_data(self).name.clone()\n     }\n \n-    pub fn variants(&self, db: &impl DefDatabase) -> Vec<EnumVariant> {\n-        db.enum_data(*self)\n-            .variants\n-            .iter()\n-            .map(|(id, _)| EnumVariant { parent: *self, id })\n-            .collect()\n+    pub fn variants(self, db: &impl DefDatabase) -> Vec<EnumVariant> {\n+        db.enum_data(self).variants.iter().map(|(id, _)| EnumVariant { parent: self, id }).collect()\n     }\n \n-    pub fn variant(&self, db: &impl DefDatabase, name: &Name) -> Option<EnumVariant> {\n-        db.enum_data(*self)\n+    pub fn variant(self, db: &impl DefDatabase, name: &Name) -> Option<EnumVariant> {\n+        db.enum_data(self)\n             .variants\n             .iter()\n             .find(|(_id, data)| data.name.as_ref() == Some(name))\n-            .map(|(id, _)| EnumVariant { parent: *self, id })\n+            .map(|(id, _)| EnumVariant { parent: self, id })\n     }\n \n-    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def((*self).into(), Namespace::Types)\n+    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n+        db.type_for_def(self.into(), Namespace::Types)\n     }\n \n     // FIXME: move to a more general type\n     /// Builds a resolver for type references inside this struct.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self.module(db).resolver(db);\n         // ...and add generic params, if present\n@@ -476,16 +534,16 @@ pub enum DefWithBody {\n impl_froms!(DefWithBody: Function, Const, Static);\n \n impl DefWithBody {\n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(*self)\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self)\n     }\n \n-    pub fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(*self)\n+    pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n+        db.body_hir(self)\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(*self).1\n+    pub fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+        db.body_with_source_map(self).1\n     }\n \n     /// Builds a resolver for code inside this item.\n@@ -515,6 +573,44 @@ pub struct FnSignature {\n }\n \n impl FnSignature {\n+    pub(crate) fn fn_signature_query(db: &impl DefDatabase, func: Function) -> Arc<FnSignature> {\n+        let (_, node) = func.source(db);\n+        let name = node.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n+                    TypeRef::from_ast(type_ref)\n+                } else {\n+                    let self_type = TypeRef::Path(Name::self_type().into());\n+                    match self_param.kind() {\n+                        ast::SelfParamKind::Owned => self_type,\n+                        ast::SelfParamKind::Ref => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                        }\n+                        ast::SelfParamKind::MutRef => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                        }\n+                    }\n+                };\n+                params.push(self_type);\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                params.push(type_ref);\n+            }\n+        }\n+        let ret_type = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n+            TypeRef::from_ast(type_ref)\n+        } else {\n+            TypeRef::unit()\n+        };\n+\n+        let sig = FnSignature { name, params, ret_type, has_self_param };\n+        Arc::new(sig)\n+    }\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n@@ -535,50 +631,50 @@ impl FnSignature {\n }\n \n impl Function {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::FnDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::FnDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+    pub fn name(self, db: &impl HirDatabase) -> Name {\n         self.signature(db).name.clone()\n     }\n \n-    pub(crate) fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map((*self).into()).1\n+    pub(crate) fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+        db.body_with_source_map(self.into()).1\n     }\n \n-    pub fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir((*self).into())\n+    pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n+        db.body_hir(self.into())\n     }\n \n-    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def((*self).into(), Namespace::Values)\n+    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n+        db.type_for_def(self.into(), Namespace::Values)\n     }\n \n-    pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n-        db.fn_signature(*self)\n+    pub fn signature(self, db: &impl HirDatabase) -> Arc<FnSignature> {\n+        db.fn_signature(self)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer((*self).into())\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self.into())\n     }\n \n     /// The containing impl block, if this is a method.\n-    pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n+    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, (*self).into())\n+        ImplBlock::containing(module_impls, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n-    pub fn parent_trait(&self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait((*self).into())\n+    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n+        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n     }\n \n-    pub fn container(&self, db: &impl DefDatabase) -> Option<Container> {\n+    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n         if let Some(impl_block) = self.impl_block(db) {\n             Some(impl_block.into())\n         } else if let Some(trait_) = self.parent_trait(db) {\n@@ -590,7 +686,7 @@ impl Function {\n \n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self.container(db).map_or_else(|| self.module(db).resolver(db), |c| c.resolver(db));\n         // ...and add generic params, if present\n@@ -599,10 +695,10 @@ impl Function {\n         r\n     }\n \n-    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         let infer = self.infer(db);\n-        infer.add_diagnostics(db, *self, sink);\n-        let mut validator = ExprValidator::new(*self, infer, sink);\n+        infer.add_diagnostics(db, self, sink);\n+        let mut validator = ExprValidator::new(self, infer, sink);\n         validator.validate_body(db);\n     }\n }\n@@ -619,31 +715,31 @@ pub struct Const {\n }\n \n impl Const {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::ConstDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::ConstDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn signature(&self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n-        db.const_signature(*self)\n+    pub fn signature(self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n+        db.const_signature(self)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer((*self).into())\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self.into())\n     }\n \n     /// The containing impl block, if this is a method.\n-    pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n+    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, (*self).into())\n+        ImplBlock::containing(module_impls, self.into())\n     }\n \n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self\n             .impl_block(db)\n@@ -674,6 +770,29 @@ impl ConstSignature {\n     pub fn type_ref(&self) -> &TypeRef {\n         &self.type_ref\n     }\n+\n+    pub(crate) fn const_signature_query(\n+        db: &impl DefDatabase,\n+        konst: Const,\n+    ) -> Arc<ConstSignature> {\n+        let (_, node) = konst.source(db);\n+        const_signature_for(&*node)\n+    }\n+\n+    pub(crate) fn static_signature_query(\n+        db: &impl DefDatabase,\n+        konst: Static,\n+    ) -> Arc<ConstSignature> {\n+        let (_, node) = konst.source(db);\n+        const_signature_for(&*node)\n+    }\n+}\n+\n+fn const_signature_for<N: NameOwner + TypeAscriptionOwner>(node: &N) -> Arc<ConstSignature> {\n+    let name = node.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n+    let type_ref = TypeRef::from_ast_opt(node.ascribed_type());\n+    let sig = ConstSignature { name, type_ref };\n+    Arc::new(sig)\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -682,26 +801,26 @@ pub struct Static {\n }\n \n impl Static {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StaticDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::StaticDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n-    pub fn signature(&self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n-        db.static_signature(*self)\n+    pub fn signature(self, db: &impl HirDatabase) -> Arc<ConstSignature> {\n+        db.static_signature(self)\n     }\n \n     /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         self.module(db).resolver(db)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer((*self).into())\n+    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self.into())\n     }\n }\n \n@@ -717,11 +836,11 @@ pub struct Trait {\n }\n \n impl Trait {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TraitDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TraitDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n@@ -745,7 +864,7 @@ impl Trait {\n         self.trait_data(db).is_auto()\n     }\n \n-    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let r = self.module(db).resolver(db);\n         // add generic params, if present\n         let p = self.generic_params(db);\n@@ -766,26 +885,26 @@ pub struct TypeAlias {\n }\n \n impl TypeAlias {\n-    pub fn source(&self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TypeAliasDef>) {\n+    pub fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<ast::TypeAliasDef>) {\n         self.id.source(db)\n     }\n \n-    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n     /// The containing impl block, if this is a method.\n-    pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n+    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, (*self).into())\n+        ImplBlock::containing(module_impls, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n-    pub fn parent_trait(&self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait((*self).into())\n+    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n+        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n     }\n \n-    pub fn container(&self, db: &impl DefDatabase) -> Option<Container> {\n+    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n         if let Some(impl_block) = self.impl_block(db) {\n             Some(impl_block.into())\n         } else if let Some(trait_) = self.parent_trait(db) {\n@@ -800,7 +919,7 @@ impl TypeAlias {\n     }\n \n     /// Builds a resolver for the type references in this type alias.\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self\n             .impl_block(db)\n@@ -826,7 +945,7 @@ pub enum Container {\n impl_froms!(Container: Trait, ImplBlock);\n \n impl Container {\n-    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n+    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         match self {\n             Container::Trait(trait_) => trait_.resolver(db),\n             Container::ImplBlock(impl_block) => impl_block.resolver(db),", "previous_filename": "crates/ra_hir/src/code_model_api.rs"}, {"sha": "24df9a1138fbd67ffc67b83509989e05eeefa163", "filename": "crates/ra_hir/src/code_model_impl.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs?ref=1dc9adc6e27d603f05f794adda91bca8b6dec8ac", "patch": "@@ -1,4 +0,0 @@\n-mod krate; // `crate` is invalid ident :(\n-mod konst; // `const` is invalid ident :(\n-mod module;\n-pub(crate) mod function;"}, {"sha": "f8bd0f7847728258ace86b6987292bed4e4a8e70", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=1dc9adc6e27d603f05f794adda91bca8b6dec8ac", "patch": "@@ -1,50 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n-\n-use crate::{\n-    Name, AsName, Function, FnSignature,\n-    type_ref::{TypeRef, Mutability},\n-    DefDatabase,\n-};\n-\n-impl FnSignature {\n-    pub(crate) fn fn_signature_query(db: &impl DefDatabase, func: Function) -> Arc<FnSignature> {\n-        let (_, node) = func.source(db);\n-        let name = node.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n-        let mut params = Vec::new();\n-        let mut has_self_param = false;\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(type_ref)\n-                } else {\n-                    let self_type = TypeRef::Path(Name::self_type().into());\n-                    match self_param.kind() {\n-                        ast::SelfParamKind::Owned => self_type,\n-                        ast::SelfParamKind::Ref => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                        }\n-                        ast::SelfParamKind::MutRef => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                        }\n-                    }\n-                };\n-                params.push(self_type);\n-                has_self_param = true;\n-            }\n-            for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n-                params.push(type_ref);\n-            }\n-        }\n-        let ret_type = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(type_ref)\n-        } else {\n-            TypeRef::unit()\n-        };\n-\n-        let sig = FnSignature { name, params, ret_type, has_self_param };\n-        Arc::new(sig)\n-    }\n-}"}, {"sha": "db4e5ce5cd146a99f826b63b9626ab7bddaa867c", "filename": "crates/ra_hir/src/code_model_impl/konst.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkonst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkonst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkonst.rs?ref=1dc9adc6e27d603f05f794adda91bca8b6dec8ac", "patch": "@@ -1,34 +0,0 @@\n-use std::sync::Arc;\r\n-\r\n-use ra_syntax::ast::{NameOwner, TypeAscriptionOwner};\r\n-\r\n-use crate::{\r\n-    Name, AsName, Const, ConstSignature, Static,\r\n-    type_ref::{TypeRef},\r\n-    DefDatabase,\r\n-};\r\n-\r\n-fn const_signature_for<N: NameOwner + TypeAscriptionOwner>(node: &N) -> Arc<ConstSignature> {\r\n-    let name = node.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\r\n-    let type_ref = TypeRef::from_ast_opt(node.ascribed_type());\r\n-    let sig = ConstSignature { name, type_ref };\r\n-    Arc::new(sig)\r\n-}\r\n-\r\n-impl ConstSignature {\r\n-    pub(crate) fn const_signature_query(\r\n-        db: &impl DefDatabase,\r\n-        konst: Const,\r\n-    ) -> Arc<ConstSignature> {\r\n-        let (_, node) = konst.source(db);\r\n-        const_signature_for(&*node)\r\n-    }\r\n-\r\n-    pub(crate) fn static_signature_query(\r\n-        db: &impl DefDatabase,\r\n-        konst: Static,\r\n-    ) -> Arc<ConstSignature> {\r\n-        let (_, node) = konst.source(db);\r\n-        const_signature_for(&*node)\r\n-    }\r\n-}\r"}, {"sha": "914414fc3e0eaa5f7167f3887e6d3f708d7dd343", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=1dc9adc6e27d603f05f794adda91bca8b6dec8ac", "patch": "@@ -1,22 +0,0 @@\n-use crate::{\n-    Crate, CrateDependency, AsName, Module, DefDatabase,\n-};\n-\n-impl Crate {\n-    pub(crate) fn dependencies_impl(&self, db: &impl DefDatabase) -> Vec<CrateDependency> {\n-        let crate_graph = db.crate_graph();\n-        crate_graph\n-            .dependencies(self.crate_id)\n-            .map(|dep| {\n-                let krate = Crate { crate_id: dep.crate_id() };\n-                let name = dep.as_name();\n-                CrateDependency { krate, name }\n-            })\n-            .collect()\n-    }\n-    pub(crate) fn root_module_impl(&self, db: &impl DefDatabase) -> Option<Module> {\n-        let module_id = db.crate_def_map(*self).root();\n-        let module = Module { krate: *self, module_id };\n-        Some(module)\n-    }\n-}"}, {"sha": "5c2ea73ce60748a5fda6e779f227e3e995da934d", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc9adc6e27d603f05f794adda91bca8b6dec8ac/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=1dc9adc6e27d603f05f794adda91bca8b6dec8ac", "patch": "@@ -1,99 +0,0 @@\n-use ra_db::FileId;\n-use ra_syntax::{ast, TreeArc};\n-\n-use crate::{\n-    Module, ModuleSource, Name, AstId,\n-    nameres::CrateModuleId,\n-    HirDatabase, DefDatabase,\n-    HirFileId,\n-};\n-\n-impl ModuleSource {\n-    pub(crate) fn new(\n-        db: &impl DefDatabase,\n-        file_id: Option<FileId>,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> ModuleSource {\n-        match (file_id, decl_id) {\n-            (Some(file_id), _) => {\n-                let source_file = db.parse(file_id);\n-                ModuleSource::SourceFile(source_file)\n-            }\n-            (None, Some(item_id)) => {\n-                let module = item_id.to_node(db);\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module.to_owned())\n-            }\n-            (None, None) => panic!(),\n-        }\n-    }\n-}\n-\n-impl Module {\n-    fn with_module_id(&self, module_id: CrateModuleId) -> Module {\n-        Module { module_id, krate: self.krate }\n-    }\n-\n-    pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Option<Name> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent = def_map[self.module_id].parent?;\n-        def_map[parent].children.iter().find_map(|(name, module_id)| {\n-            if *module_id == self.module_id {\n-                Some(name.clone())\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    pub(crate) fn definition_source_impl(\n-        &self,\n-        db: &impl DefDatabase,\n-    ) -> (HirFileId, ModuleSource) {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl_id = def_map[self.module_id].declaration;\n-        let file_id = def_map[self.module_id].definition;\n-        let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n-        (file_id, module_source)\n-    }\n-\n-    pub(crate) fn declaration_source_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl = def_map[self.module_id].declaration?;\n-        let ast = decl.to_node(db);\n-        Some((decl.file_id(), ast))\n-    }\n-\n-    pub(crate) fn crate_root_impl(&self, db: &impl DefDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.krate);\n-        self.with_module_id(def_map.root())\n-    }\n-\n-    /// Finds a child module with the specified name.\n-    pub(crate) fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let child_id = def_map[self.module_id].children.get(name)?;\n-        Some(self.with_module_id(*child_id))\n-    }\n-\n-    /// Iterates over all child modules.\n-    pub(crate) fn children_impl(&self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let children = def_map[self.module_id]\n-            .children\n-            .iter()\n-            .map(|(_, module_id)| self.with_module_id(*module_id))\n-            .collect::<Vec<_>>();\n-        children.into_iter()\n-    }\n-\n-    pub(crate) fn parent_impl(&self, db: &impl DefDatabase) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent_id = def_map[self.module_id].parent?;\n-        Some(self.with_module_id(parent_id))\n-    }\n-}"}, {"sha": "637f6ab83521f6323b4044e954873c73c02af45f", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=afb792acb713442f1ad315354a9edfcdad0a5097", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     resolve::Resolver,\n     ty::Ty,\n     generics::HasGenericParams,\n-    code_model_api::{Module, ModuleSource}\n+    code_model::{Module, ModuleSource}\n };\n \n #[derive(Debug, Default, PartialEq, Eq)]"}, {"sha": "fe2d4adeeebe04177ba726b89b51e97252c17af9", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=afb792acb713442f1ad315354a9edfcdad0a5097", "patch": "@@ -42,8 +42,7 @@ mod docs;\n mod resolve;\n pub mod diagnostics;\n \n-mod code_model_api;\n-mod code_model_impl;\n+mod code_model;\n \n #[cfg(test)]\n mod marks;\n@@ -73,7 +72,7 @@ pub use self::{\n     source_binder::{SourceAnalyzer, PathResolution, ScopeEntryWithSyntax,MacroByExampleDef},\n };\n \n-pub use self::code_model_api::{\n+pub use self::code_model::{\n     Crate, CrateDependency,\n     DefWithBody,\n     Module, ModuleDef, ModuleSource,"}, {"sha": "fedfe2feeb854ccc4abafc54c0a7dabb7224ebed", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb792acb713442f1ad315354a9edfcdad0a5097/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=afb792acb713442f1ad315354a9edfcdad0a5097", "patch": "@@ -5,7 +5,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     ModuleDef, Trait,\n-    code_model_api::Crate,\n+    code_model::Crate,\n     MacroDefId,\n     db::HirDatabase,\n     name::{Name, KnownName},"}]}