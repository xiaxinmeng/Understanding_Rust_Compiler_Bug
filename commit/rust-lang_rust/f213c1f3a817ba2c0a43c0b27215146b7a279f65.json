{"sha": "f213c1f3a817ba2c0a43c0b27215146b7a279f65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMTNjMWYzYTgxN2JhMmMwYTQzYzBiMjcyMTUxNDZiN2EyNzlmNjU=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T19:46:13Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T19:48:31Z"}, "message": "Represent kinds as a bitfield of capabilities.", "tree": {"sha": "00aa34cef849c4e2d6fe00bce9b25b4b03060362", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00aa34cef849c4e2d6fe00bce9b25b4b03060362"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f213c1f3a817ba2c0a43c0b27215146b7a279f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f213c1f3a817ba2c0a43c0b27215146b7a279f65", "html_url": "https://github.com/rust-lang/rust/commit/f213c1f3a817ba2c0a43c0b27215146b7a279f65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f213c1f3a817ba2c0a43c0b27215146b7a279f65/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d7f3bd1ca622e6ddc03f4592eb8a451fbf850ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d7f3bd1ca622e6ddc03f4592eb8a451fbf850ab", "html_url": "https://github.com/rust-lang/rust/commit/8d7f3bd1ca622e6ddc03f4592eb8a451fbf850ab"}], "stats": {"total": 114, "additions": 58, "deletions": 56}, "files": [{"sha": "e7c318b7da51257c4793b4a38cc7512724203118", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f213c1f3a817ba2c0a43c0b27215146b7a279f65/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213c1f3a817ba2c0a43c0b27215146b7a279f65/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=f213c1f3a817ba2c0a43c0b27215146b7a279f65", "patch": "@@ -1,7 +1,7 @@\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n-import ty::{kind, kind_copyable, kind_sendable, kind_noncopyable};\n+import ty::{kind, kind_sendable, kind_copyable, kind_noncopyable };\n import driver::session::session;\n import std::map::hashmap;\n import util::ppaux::{ty_to_str, tys_to_str};\n@@ -24,11 +24,10 @@ import freevars::freevar_entry;\n // types.\n \n fn kind_to_str(k: kind) -> str {\n-    alt k {\n-      kind_sendable { \"sendable\" }\n-      kind_copyable { \"copyable\" }\n-      kind_noncopyable { \"noncopyable\" }\n-    }\n+    if k == kind_sendable() { \"sendable\" }\n+    else if k == kind_copyable() { \"copyable\" }\n+    else if k == kind_noncopyable() { \"noncopyable\" }\n+    else { fail \"unknown kind\" }\n }\n \n type rval_map = std::map::hashmap<node_id, ()>;"}, {"sha": "998dc9d59511fb43af756689f852b6b7dbdba168", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f213c1f3a817ba2c0a43c0b27215146b7a279f65/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f213c1f3a817ba2c0a43c0b27215146b7a279f65/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=f213c1f3a817ba2c0a43c0b27215146b7a279f65", "patch": "@@ -421,13 +421,13 @@ impl of vid for region_vid {\n }\n \n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n-    let mut kind = kind_noncopyable;\n+    let mut kind = kind_noncopyable();\n     for vec::each(*bounds) {|bound|\n         alt bound {\n           bound_copy {\n-            if kind != kind_sendable { kind = kind_copyable; }\n+            if kind != kind_sendable() { kind = kind_copyable(); }\n           }\n-          bound_send { kind = kind_sendable; }\n+          bound_send { kind = kind_sendable(); }\n           _ {}\n         }\n     }\n@@ -1260,43 +1260,46 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     ret needs_unwind_cleanup;\n }\n \n-enum kind { kind_sendable, kind_copyable, kind_noncopyable, }\n+enum kind { kind_(u32) }\n+\n+const KIND_MASK_COPY : u32 = 0b00000000000000000000000000000001u32;\n+const KIND_MASK_SEND : u32 = 0b00000000000000000000000000000010u32;\n+\n+fn kind_noncopyable() -> kind {\n+    kind_(0u32)\n+}\n+\n+fn kind_copyable() -> kind {\n+    kind_(KIND_MASK_COPY)\n+}\n+\n+fn kind_sendable() -> kind {\n+    kind_(KIND_MASK_COPY | KIND_MASK_SEND)\n+}\n \n // Using these query functons is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n // future.\n pure fn kind_can_be_copied(k: kind) -> bool {\n-    ret alt k {\n-      kind_sendable { true }\n-      kind_copyable { true }\n-      kind_noncopyable { false }\n-    };\n+    *k & KIND_MASK_COPY != 0u32\n }\n \n pure fn kind_can_be_sent(k: kind) -> bool {\n-    ret alt k {\n-      kind_sendable { true }\n-      kind_copyable { false }\n-      kind_noncopyable { false }\n-    };\n+    *k & KIND_MASK_SEND != 0u32\n }\n \n fn proto_kind(p: proto) -> kind {\n     alt p {\n-      ast::proto_any { kind_noncopyable }\n-      ast::proto_block { kind_noncopyable }\n-      ast::proto_box { kind_copyable }\n-      ast::proto_uniq { kind_sendable }\n-      ast::proto_bare { kind_sendable }\n+      ast::proto_any { kind_noncopyable() }\n+      ast::proto_block { kind_noncopyable() }\n+      ast::proto_box { kind_copyable() }\n+      ast::proto_uniq { kind_sendable() }\n+      ast::proto_bare { kind_sendable() }\n     }\n }\n \n fn kind_lteq(a: kind, b: kind) -> bool {\n-    alt a {\n-      kind_noncopyable { true }\n-      kind_copyable { b != kind_noncopyable }\n-      kind_sendable { b == kind_sendable }\n-    }\n+    *a & *b == *a\n }\n \n fn lower_kind(a: kind, b: kind) -> kind {\n@@ -1306,12 +1309,12 @@ fn lower_kind(a: kind, b: kind) -> kind {\n #[test]\n fn test_kinds() {\n     // The kind \"lattice\" is nocopy <= copy <= send\n-    assert kind_lteq(kind_sendable, kind_sendable);\n-    assert kind_lteq(kind_copyable, kind_sendable);\n-    assert kind_lteq(kind_copyable, kind_copyable);\n-    assert kind_lteq(kind_noncopyable, kind_sendable);\n-    assert kind_lteq(kind_noncopyable, kind_copyable);\n-    assert kind_lteq(kind_noncopyable, kind_noncopyable);\n+    assert kind_lteq(kind_sendable(), kind_sendable());\n+    assert kind_lteq(kind_copyable(), kind_sendable());\n+    assert kind_lteq(kind_copyable(), kind_copyable());\n+    assert kind_lteq(kind_noncopyable(), kind_sendable());\n+    assert kind_lteq(kind_noncopyable(), kind_copyable());\n+    assert kind_lteq(kind_noncopyable(), kind_noncopyable());\n }\n \n fn type_kind(cx: ctxt, ty: t) -> kind {\n@@ -1321,44 +1324,44 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     }\n \n     // Insert a default in case we loop back on self recursively.\n-    cx.kind_cache.insert(ty, kind_sendable);\n+    cx.kind_cache.insert(ty, kind_sendable());\n \n     let result = alt get(ty).struct {\n       // Scalar and unique types are sendable\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_ptr(_) | ty_str { kind_sendable }\n-      ty_type { kind_copyable }\n+      ty_ptr(_) | ty_str { kind_sendable() }\n+      ty_type { kind_copyable() }\n       ty_fn(f) { proto_kind(f.proto) }\n \n       // Closures have kind determined by capture mode\n-      ty_opaque_closure_ptr(ck_block) { kind_noncopyable }\n-      ty_opaque_closure_ptr(ck_box) { kind_copyable }\n-      ty_opaque_closure_ptr(ck_uniq) { kind_sendable }\n+      ty_opaque_closure_ptr(ck_block) { kind_noncopyable() }\n+      ty_opaque_closure_ptr(ck_box) { kind_copyable() }\n+      ty_opaque_closure_ptr(ck_uniq) { kind_sendable() }\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n-      ty_box(_) | ty_iface(_, _) | ty_opaque_box { kind_copyable }\n-      ty_rptr(_, _) { kind_copyable }\n+      ty_box(_) | ty_iface(_, _) | ty_opaque_box { kind_copyable() }\n+      ty_rptr(_, _) { kind_copyable() }\n \n       // Unique boxes and vecs have the kind of their contained type.\n       ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n \n       // Slice and refcounted evecs are copyable; uniques and interiors\n       // depend on the their contained type.\n       ty_evec(_, vstore_box) |\n-      ty_evec(_, vstore_slice(_)) { kind_copyable }\n+      ty_evec(_, vstore_slice(_)) { kind_copyable() }\n       ty_evec(tm, vstore_uniq) |\n       ty_evec(tm, vstore_fixed(_)) { type_kind(cx, tm.ty)  }\n \n       // All estrs are copyable; uniques and interiors are sendable.\n       ty_estr(vstore_box) |\n-      ty_estr(vstore_slice(_)) { kind_copyable }\n+      ty_estr(vstore_slice(_)) { kind_copyable() }\n       ty_estr(vstore_uniq) |\n-      ty_estr(vstore_fixed(_)) { kind_sendable  }\n+      ty_estr(vstore_fixed(_)) { kind_sendable()  }\n \n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n-        let mut lowest = kind_sendable;\n+        let mut lowest = kind_sendable();\n         for flds.each {|f|\n             lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n         }\n@@ -1368,7 +1371,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // sendable, but I'm just treating them like records (#1726)\n       ty_class(did, substs) {\n           // also factor out this code, copied from the records case\n-          let mut lowest = kind_sendable;\n+          let mut lowest = kind_sendable();\n           let flds = class_items_as_fields(cx, did, substs);\n           for flds.each {|f|\n             lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n@@ -1377,34 +1380,34 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n-        let mut lowest = kind_sendable;\n+        let mut lowest = kind_sendable();\n         for tys.each {|ty| lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n       // Enums lower to the lowest of their variants.\n       ty_enum(did, substs) {\n-        let mut lowest = kind_sendable;\n+        let mut lowest = kind_sendable();\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 0u {\n-            lowest = kind_noncopyable;\n+            lowest = kind_noncopyable();\n         } else {\n             for vec::each(*variants) {|variant|\n                 for variant.args.each {|aty|\n                     // Perform any type parameter substitutions.\n                     let arg_ty = subst(cx, substs, aty);\n                     lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n-                    if lowest == kind_noncopyable { break; }\n+                    if lowest == kind_noncopyable() { break; }\n                 }\n             }\n         }\n         lowest\n       }\n-      ty_res(did, inner, tps) { kind_noncopyable }\n+      ty_res(did, inner, tps) { kind_noncopyable() }\n       ty_param(_, did) {\n           param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n-      ty_self { kind_noncopyable }\n+      ty_self { kind_noncopyable() }\n \n       ty_var(_) { cx.sess.bug(\"Asked to compute kind of a type variable\"); }\n     };\n@@ -1605,7 +1608,7 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n           }\n           _ { false }\n         }\n-    }) && type_kind(cx, ty) != kind_noncopyable;\n+    }) && type_kind(cx, ty) != kind_noncopyable();\n }\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {"}]}