{"sha": "f69351e9957d44711d0decabccfb925bc998de70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2OTM1MWU5OTU3ZDQ0NzExZDBkZWNhYmNjZmI5MjViYzk5OGRlNzA=", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2019-03-09T11:24:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-09T11:24:43Z"}, "message": "Rollup merge of #3852 - phansch:refactor_assign_ops, r=flip1995\n\nRefactor: Cleanup one part of assign_ops lint\n\nRemoves a lot of indentation and separates lint emission from lint\nlogic. Only touches the `hir::ExprKind::AssignOp` part of the lint.", "tree": {"sha": "30e8e78b449b9b59f3b7cea433c603be29b1849c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30e8e78b449b9b59f3b7cea433c603be29b1849c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f69351e9957d44711d0decabccfb925bc998de70", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcg6J7CRBK7hj4Ov3rIwAAdHIIAGgD6RSJncCqb9r1WGTaGa0q\nmqC0O817y0KaFw0P9bVQXHrBLupbhF+LbTjQdWTvg6h2DLb2ME03ektrw7r5gu66\nqNZScASJOEr0/XRh4cyoPNixsD79/VIOdTFxJ5MA2X/N3SBM3ddzNzvO8JkA+Ulg\n5npMMiOBfTeMS124hozd2R1bNamxv4m0DqRMkreSUpgggW+fALhTRnUM1S5ghLot\nWNgjd94vn7Ha2Q97g8jH5L2BY7jHFS2GM0l/0/l6ddBAHGuQP4E1xYUV24hdohil\nz0ivy0QHjzLo1Nkff55Pw4No8I8eKqChyvXI7dIJVHh5Tt2+rT2V842BSBeEWto=\n=ZOpR\n-----END PGP SIGNATURE-----\n", "payload": "tree 30e8e78b449b9b59f3b7cea433c603be29b1849c\nparent 1902384d153407ff04d2048812c8b9eb9f754f74\nparent 9494f22f06f29ed1c47314b10ed62cfc1d4aff80\nauthor Philipp Krones <hello@philkrones.com> 1552130683 +0100\ncommitter GitHub <noreply@github.com> 1552130683 +0100\n\nRollup merge of #3852 - phansch:refactor_assign_ops, r=flip1995\n\nRefactor: Cleanup one part of assign_ops lint\n\nRemoves a lot of indentation and separates lint emission from lint\nlogic. Only touches the `hir::ExprKind::AssignOp` part of the lint.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f69351e9957d44711d0decabccfb925bc998de70", "html_url": "https://github.com/rust-lang/rust/commit/f69351e9957d44711d0decabccfb925bc998de70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f69351e9957d44711d0decabccfb925bc998de70/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1902384d153407ff04d2048812c8b9eb9f754f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/1902384d153407ff04d2048812c8b9eb9f754f74", "html_url": "https://github.com/rust-lang/rust/commit/1902384d153407ff04d2048812c8b9eb9f754f74"}, {"sha": "9494f22f06f29ed1c47314b10ed62cfc1d4aff80", "url": "https://api.github.com/repos/rust-lang/rust/commits/9494f22f06f29ed1c47314b10ed62cfc1d4aff80", "html_url": "https://github.com/rust-lang/rust/commit/9494f22f06f29ed1c47314b10ed62cfc1d4aff80"}], "stats": {"total": 98, "additions": 52, "deletions": 46}, "files": [{"sha": "9e0b87bc37775b538446d7d180fe840293195250", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f69351e9957d44711d0decabccfb925bc998de70/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f69351e9957d44711d0decabccfb925bc998de70/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=f69351e9957d44711d0decabccfb925bc998de70", "patch": "@@ -70,52 +70,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n         match &expr.node {\n             hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 if let hir::ExprKind::Binary(binop, l, r) = &rhs.node {\n-                    if op.node == binop.node {\n-                        let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n-                            span_lint_and_then(\n-                                cx,\n-                                MISREFACTORED_ASSIGN_OP,\n-                                expr.span,\n-                                \"variable appears on both sides of an assignment operation\",\n-                                |db| {\n-                                    if let (Some(snip_a), Some(snip_r)) =\n-                                        (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span))\n-                                    {\n-                                        let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n-                                        let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                                        let long =\n-                                            format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            &format!(\n-                                                \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n-                                                snip_a,\n-                                                snip_a,\n-                                                op.node.as_str(),\n-                                                snip_r,\n-                                                long\n-                                            ),\n-                                            format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                        db.span_suggestion(\n-                                            expr.span,\n-                                            \"or\",\n-                                            long,\n-                                            Applicability::MachineApplicable, // snippet\n-                                        );\n-                                    }\n-                                },\n-                            );\n-                        };\n-                        // lhs op= l op r\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n-                            lint(lhs, r);\n-                        }\n-                        // lhs op= l commutative_op r\n-                        if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n-                            lint(lhs, l);\n-                        }\n+                    if op.node != binop.node {\n+                        return;\n+                    }\n+                    // lhs op= l op r\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n+                    }\n+                    // lhs op= l commutative_op r\n+                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n             },\n@@ -231,6 +195,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     }\n }\n \n+fn lint_misrefactored_assign_op(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr,\n+    op: hir::BinOp,\n+    rhs: &hir::Expr,\n+    assignee: &hir::Expr,\n+    rhs_other: &hir::Expr,\n+) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |db| {\n+            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n+                db.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"Did you mean {} = {} {} {} or {}? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.node.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                    Applicability::MachineApplicable,\n+                );\n+                db.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n fn is_commutative(op: hir::BinOpKind) -> bool {\n     use rustc::hir::BinOpKind::*;\n     match op {"}]}