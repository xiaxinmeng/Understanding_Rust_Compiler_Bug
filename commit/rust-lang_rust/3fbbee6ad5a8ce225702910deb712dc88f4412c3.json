{"sha": "3fbbee6ad5a8ce225702910deb712dc88f4412c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYmJlZTZhZDVhOGNlMjI1NzAyOTEwZGViNzEyZGM4OGY0NDEyYzM=", "commit": {"author": {"name": "Michael Pankov", "email": "work@michaelpankov.com", "date": "2015-10-07T22:03:52Z"}, "committer": {"name": "Michael Pankov", "email": "work@michaelpankov.com", "date": "2015-10-07T22:03:52Z"}, "message": "rustfmt hash submodule", "tree": {"sha": "e406be37b8f3cc93589cfaacf00ef4dc121622b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e406be37b8f3cc93589cfaacf00ef4dc121622b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fbbee6ad5a8ce225702910deb712dc88f4412c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbbee6ad5a8ce225702910deb712dc88f4412c3", "html_url": "https://github.com/rust-lang/rust/commit/3fbbee6ad5a8ce225702910deb712dc88f4412c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fbbee6ad5a8ce225702910deb712dc88f4412c3/comments", "author": {"login": "mkpankov", "id": 393741, "node_id": "MDQ6VXNlcjM5Mzc0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/393741?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mkpankov", "html_url": "https://github.com/mkpankov", "followers_url": "https://api.github.com/users/mkpankov/followers", "following_url": "https://api.github.com/users/mkpankov/following{/other_user}", "gists_url": "https://api.github.com/users/mkpankov/gists{/gist_id}", "starred_url": "https://api.github.com/users/mkpankov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mkpankov/subscriptions", "organizations_url": "https://api.github.com/users/mkpankov/orgs", "repos_url": "https://api.github.com/users/mkpankov/repos", "events_url": "https://api.github.com/users/mkpankov/events{/privacy}", "received_events_url": "https://api.github.com/users/mkpankov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mkpankov", "id": 393741, "node_id": "MDQ6VXNlcjM5Mzc0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/393741?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mkpankov", "html_url": "https://github.com/mkpankov", "followers_url": "https://api.github.com/users/mkpankov/followers", "following_url": "https://api.github.com/users/mkpankov/following{/other_user}", "gists_url": "https://api.github.com/users/mkpankov/gists{/gist_id}", "starred_url": "https://api.github.com/users/mkpankov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mkpankov/subscriptions", "organizations_url": "https://api.github.com/users/mkpankov/orgs", "repos_url": "https://api.github.com/users/mkpankov/repos", "events_url": "https://api.github.com/users/mkpankov/events{/privacy}", "received_events_url": "https://api.github.com/users/mkpankov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17033a62b420fcf353150998bbdb62629efdf956", "url": "https://api.github.com/repos/rust-lang/rust/commits/17033a62b420fcf353150998bbdb62629efdf956", "html_url": "https://github.com/rust-lang/rust/commit/17033a62b420fcf353150998bbdb62629efdf956"}], "stats": {"total": 42, "additions": 27, "deletions": 15}, "files": [{"sha": "4e038f455e1bea1bc5b17d851fbfea1f7bfdaaa1", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3fbbee6ad5a8ce225702910deb712dc88f4412c3/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbbee6ad5a8ce225702910deb712dc88f4412c3/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=3fbbee6ad5a8ce225702910deb712dc88f4412c3", "patch": "@@ -100,7 +100,9 @@ pub trait Hash {\n \n     /// Feeds a slice of this type into the state provided.\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized {\n+    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n+        where Self: Sized\n+    {\n         for piece in data {\n             piece.hash(state);\n         }\n@@ -121,7 +123,9 @@ pub trait Hasher {\n     /// Write a single `u8` into this hasher\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n+    fn write_u8(&mut self, i: u8) {\n+        self.write(&[i])\n+    }\n     /// Write a single `u16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -145,32 +149,41 @@ pub trait Hasher {\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_usize(&mut self, i: usize) {\n         let bytes = unsafe {\n-            ::slice::from_raw_parts(&i as *const usize as *const u8,\n-                                    mem::size_of::<usize>())\n+            ::slice::from_raw_parts(&i as *const usize as *const u8, mem::size_of::<usize>())\n         };\n         self.write(bytes);\n     }\n \n     /// Write a single `i8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n+    fn write_i8(&mut self, i: i8) {\n+        self.write_u8(i as u8)\n+    }\n     /// Write a single `i16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n+    fn write_i16(&mut self, i: i16) {\n+        self.write_u16(i as u16)\n+    }\n     /// Write a single `i32` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n+    fn write_i32(&mut self, i: i32) {\n+        self.write_u32(i as u32)\n+    }\n     /// Write a single `i64` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n+    fn write_i64(&mut self, i: i64) {\n+        self.write_u64(i as u64)\n+    }\n     /// Write a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n+    fn write_isize(&mut self, i: isize) {\n+        self.write_usize(i as usize)\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////////"}, {"sha": "722d77a8a11efeccdc26f0eecfdf8eb905a1f999", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fbbee6ad5a8ce225702910deb712dc88f4412c3/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbbee6ad5a8ce225702910deb712dc88f4412c3/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=3fbbee6ad5a8ce225702910deb712dc88f4412c3", "patch": "@@ -37,12 +37,12 @@ pub struct SipHasher {\n     // and simd implementations of SipHash will use vectors\n     // of v02 and v13. By placing them in this order in the struct,\n     // the compiler can pick up on just a few simd optimizations by itself.\n-    v0: u64,      // hash state\n+    v0: u64, // hash state\n     v2: u64,\n     v1: u64,\n     v3: u64,\n     tail: u64, // unprocessed bytes le\n-    ntail: usize,  // how many bytes in tail are valid\n+    ntail: usize, // how many bytes in tail are valid\n }\n \n // sadly, these macro definitions can't appear later,\n@@ -80,8 +80,7 @@ macro_rules! u8to64_le {\n unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n     debug_assert!(i + 8 <= buf.len());\n     let mut data = 0u64;\n-    ptr::copy_nonoverlapping(buf.get_unchecked(i),\n-                             &mut data as *mut _ as *mut u8, 8);\n+    ptr::copy_nonoverlapping(buf.get_unchecked(i), &mut data as *mut _ as *mut u8, 8);\n     data.to_le()\n }\n \n@@ -152,12 +151,12 @@ impl Hasher for SipHasher {\n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n             if length < needed {\n-                self.tail |= u8to64_le!(msg, 0, length) << 8*self.ntail;\n+                self.tail |= u8to64_le!(msg, 0, length) << 8 * self.ntail;\n                 self.ntail += length;\n                 return\n             }\n \n-            let m = self.tail | u8to64_le!(msg, 0, needed) << 8*self.ntail;\n+            let m = self.tail | u8to64_le!(msg, 0, needed) << 8 * self.ntail;\n \n             self.v3 ^= m;\n             compress!(self.v0, self.v1, self.v2, self.v3);"}]}