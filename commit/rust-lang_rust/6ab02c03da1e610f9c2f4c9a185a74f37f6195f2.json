{"sha": "6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYjAyYzAzZGExZTYxMGY5YzJmNGM5YTE4NWE3NGYzN2Y2MTk1ZjI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-28T00:47:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T21:52:05Z"}, "message": "core::rt: Convert some uv functions to extension methods", "tree": {"sha": "6005725b7c5e654e350d6b6af964f5b003cd8c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6005725b7c5e654e350d6b6af964f5b003cd8c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "html_url": "https://github.com/rust-lang/rust/commit/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd183db15af50f06b5e2803b03f87061adad9f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd183db15af50f06b5e2803b03f87061adad9f5", "html_url": "https://github.com/rust-lang/rust/commit/cfd183db15af50f06b5e2803b03f87061adad9f5"}], "stats": {"total": 275, "additions": 127, "deletions": 148}, "files": [{"sha": "7d5a4f00204d8b2421f2790b994f7d3fd1a1ca68", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 90, "deletions": 103, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "patch": "@@ -77,9 +77,7 @@ pub trait Request { }\n /// handle.  Watchers are generally created, then `start`ed, `stop`ed\n /// and `close`ed, but due to their complex life cycle may not be\n /// entirely memory safe if used in unanticipated patterns.\n-pub trait Watcher {\n-    fn event_loop(&self) -> Loop;\n-}\n+pub trait Watcher { }\n \n pub type NullCallback = ~fn();\n impl Callback for NullCallback { }\n@@ -123,12 +121,7 @@ impl NativeHandle<*uvll::uv_loop_t> for Loop {\n }\n \n pub struct IdleWatcher(*uvll::uv_idle_t);\n-\n-impl Watcher for IdleWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n+impl Watcher for IdleWatcher { }\n \n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n impl Callback for IdleCallback { }\n@@ -146,14 +139,14 @@ pub impl IdleWatcher {\n \n     fn start(&mut self, cb: IdleCallback) {\n \n-        set_watcher_callback(self, cb);\n+        self.set_callback(cb);\n         unsafe {\n             assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n         };\n \n         extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n             let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let cb: &IdleCallback = borrow_callback_from_watcher(&idle_watcher);\n+            let cb: &IdleCallback = idle_watcher.borrow_callback();\n             let status = status_to_maybe_uv_error(handle, status);\n             (*cb)(idle_watcher, status);\n         }\n@@ -167,9 +160,11 @@ pub impl IdleWatcher {\n         unsafe { uvll::close(self.native_handle(), close_cb) };\n \n         extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n-            drop_watcher_callback::<uvll::uv_idle_t, IdleWatcher, IdleCallback>(&mut idle_watcher);\n-            unsafe { uvll::idle_delete(handle) };\n+            unsafe {\n+                let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+                idle_watcher.drop_callback::<IdleCallback>();\n+                uvll::idle_delete(handle);\n+            }\n         }\n     }\n }\n@@ -224,7 +219,7 @@ fn error_smoke_test() {\n \n pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n     unsafe {\n-        let loop_ = loop_from_watcher(watcher);\n+        let loop_ = watcher.event_loop();\n         UvError(uvll::last_error(loop_.native_handle()))\n     }\n }\n@@ -288,111 +283,103 @@ pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError>\n     }\n }\n \n-/// Get the uv event loop from a Watcher\n-pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &W) -> Loop {\n-\n-    let handle = watcher.native_handle();\n-    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n-    NativeHandle::from_native_handle(loop_)\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>,\n }\n \n-/// Set the custom data on a handle to a callback Note: This is only\n-/// suitable for watchers that make just one type of callback.  For\n-/// others use WatcherData\n-pub fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W, cb: CB) {\n-\n-    drop_watcher_callback::<H, W, CB>(watcher);\n-    // XXX: Boxing the callback so it fits into a\n-    // pointer. Unfortunate extra allocation\n-    let boxed_cb = ~cb;\n-    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n-    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n+pub trait WatcherInterop {\n+    fn event_loop(&self) -> Loop;\n+    fn set_callback<CB: Callback>(&mut self, cb: CB);\n+    fn drop_callback<CB: Callback>(&mut self);\n+    fn borrow_callback<CB: Callback>(&self) -> &CB;\n+    fn install_watcher_data(&mut self);\n+    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n+    fn drop_watcher_data(&mut self);\n }\n \n-/// Delete a callback from a handle's custom data\n-pub fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        if handle_data.is_not_null() {\n-            // Take ownership of the callback and drop it\n-            let _cb = transmute::<*c_void, ~CB>(handle_data);\n-            // Make sure the pointer is zeroed\n-            uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n+    /// Get the uv event loop from a Watcher\n+    pub fn event_loop(&self) -> Loop {\n+        unsafe {\n+            let handle = self.native_handle();\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            NativeHandle::from_native_handle(loop_)\n         }\n     }\n-}\n \n-/// Take a pointer to the callback installed as custom data\n-pub fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n-                                CB: Callback>(watcher: &W) -> &CB {\n+    /// Set the custom data on a handle to a callback Note: This is only\n+    /// suitable for watchers that make just one type of callback.  For\n+    /// others use WatcherData\n+    pub fn set_callback<CB: Callback>(&mut self, cb: CB) {\n+        unsafe {\n+            self.drop_callback::<CB>();\n \n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n-        return &**cb;\n+            // XXX: Boxing the callback so it fits into a\n+            // pointer. Unfortunate extra allocation\n+            let boxed_cb = ~cb;\n+            let data = transmute::<~CB, *c_void>(boxed_cb);\n+            uvll::set_data_for_uv_handle(self.native_handle(), data);\n+        }\n     }\n-}\n \n-/// Take ownership of the callback installed as custom data\n-pub fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) -> CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        uvll::set_data_for_uv_handle(handle, null::<()>());\n-        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n-        let cb = match cb { ~cb => cb };\n-        return cb;\n+    /// Delete a callback from a handle's custom data\n+    pub fn drop_callback<CB: Callback>(&mut self) {\n+        unsafe {\n+            let handle = self.native_handle();\n+            let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+            if handle_data.is_not_null() {\n+                // Take ownership of the callback and drop it\n+                let _cb = transmute::<*c_void, ~CB>(handle_data);\n+                // Make sure the pointer is zeroed\n+                uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+            }\n+        }\n     }\n-}\n-\n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>,\n-}\n \n-pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = ~WatcherData {\n-            read_cb: None,\n-            write_cb: None,\n-            connect_cb: None,\n-            close_cb: None,\n-            alloc_cb: None,\n-        };\n-        let data = transmute::<~WatcherData, *c_void>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n+    /// Take a pointer to the callback installed as custom data\n+    pub fn borrow_callback<CB: Callback>(&self) -> &CB {\n+        unsafe {\n+            let handle = self.native_handle();\n+            let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+            assert!(handle_data.is_not_null());\n+            let cb = transmute::<&*c_void, &~CB>(&handle_data);\n+            return &**cb;\n+        }\n     }\n-}\n \n-pub fn get_watcher_data<'r, H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &'r mut W) -> &'r mut WatcherData {\n+    pub fn install_watcher_data(&mut self) {\n+        unsafe {\n+            let data = ~WatcherData {\n+                read_cb: None,\n+                write_cb: None,\n+                connect_cb: None,\n+                close_cb: None,\n+                alloc_cb: None,\n+            };\n+            let data = transmute::<~WatcherData, *c_void>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), data);\n+        }\n+    }\n \n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-        return &mut **data;\n+    pub fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+            return &mut **data;\n+        }\n     }\n-}\n \n-pub fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let _data = transmute::<*c_void, ~WatcherData>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+    pub fn drop_watcher_data(&mut self) {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let _data = transmute::<*c_void, ~WatcherData>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+        }\n     }\n }\n "}, {"sha": "1209609347aec34a5945eb900d1395206fa61ced", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "patch": "@@ -10,14 +10,11 @@\n \n use prelude::*;\n use libc::{size_t, ssize_t, c_int, c_void};\n-use cast::transmute_mut_region;\n use util::ignore;\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCallback,\n-            loop_from_watcher, status_to_maybe_uv_error,\n-            install_watcher_data, get_watcher_data, drop_watcher_data,\n-            vec_to_uv_buf, vec_from_uv_buf, slice_to_uv_buf};\n+            status_to_maybe_uv_error, vec_to_uv_buf, vec_from_uv_buf, slice_to_uv_buf};\n use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::uv::last_uv_error;\n \n@@ -49,12 +46,7 @@ fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n // uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n-\n-impl Watcher for StreamWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n+impl Watcher for StreamWatcher { }\n \n pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n impl Callback for ReadCallback { }\n@@ -66,17 +58,18 @@ impl Callback for AllocCallback { }\n pub impl StreamWatcher {\n \n     fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        // XXX: Borrowchk problems\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        data.alloc_cb = Some(alloc);\n-        data.read_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            data.alloc_cb = Some(alloc);\n+            data.read_cb = Some(cb);\n+        }\n \n         let handle = self.native_handle();\n         unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let alloc_cb = data.alloc_cb.get_ref();\n             return (*alloc_cb)(suggested_size as uint);\n         }\n@@ -85,7 +78,7 @@ pub impl StreamWatcher {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let cb = data.read_cb.get_ref();\n             let status = status_to_maybe_uv_error(stream, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n@@ -101,25 +94,26 @@ pub impl StreamWatcher {\n     }\n \n     fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.write_cb.is_none());\n-        data.write_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.write_cb.is_none());\n+            data.write_cb = Some(cb);\n+        }\n \n         let req = WriteRequest::new();\n         let bufs = [buf];\n         unsafe {\n             assert!(0 == uvll::write(req.native_handle(),\n-                                          self.native_handle(),\n-                                          bufs, write_cb));\n+                                     self.native_handle(),\n+                                     bufs, write_cb));\n         }\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = {\n-                let data = get_watcher_data(&mut stream_watcher);\n+                let data = stream_watcher.get_watcher_data();\n                 let cb = data.write_cb.swap_unwrap();\n                 cb\n             };\n@@ -139,7 +133,7 @@ pub impl StreamWatcher {\n     fn close(self, cb: NullCallback) {\n         {\n             let mut this = self;\n-            let data = get_watcher_data(&mut this);\n+            let data = this.get_watcher_data();\n             assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }\n@@ -149,9 +143,10 @@ pub impl StreamWatcher {\n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             {\n-                get_watcher_data(&mut stream_watcher).close_cb.swap_unwrap()();\n+                let mut data = stream_watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n             }\n-            drop_watcher_data(&mut stream_watcher);\n+            stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }\n     }\n@@ -168,12 +163,7 @@ impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n }\n \n pub struct TcpWatcher(*uvll::uv_tcp_t);\n-\n-impl Watcher for TcpWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n+impl Watcher for TcpWatcher { }\n \n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n impl Callback for ConnectionCallback { }\n@@ -184,8 +174,8 @@ pub impl TcpWatcher {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n             assert!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n-            let mut watcher = NativeHandle::from_native_handle(handle);\n-            install_watcher_data(&mut watcher);\n+            let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n             return watcher;\n         }\n     }\n@@ -210,8 +200,8 @@ pub impl TcpWatcher {\n \n     fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n         unsafe {\n-            assert!(get_watcher_data(self).connect_cb.is_none());\n-            get_watcher_data(self).connect_cb = Some(cb);\n+            assert!(self.get_watcher_data().connect_cb.is_none());\n+            self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n             match address {\n@@ -232,7 +222,7 @@ pub impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb: ConnectionCallback = {\n-                    let data = get_watcher_data(&mut stream_watcher);\n+                    let data = stream_watcher.get_watcher_data();\n                     data.connect_cb.swap_unwrap()\n                 };\n                 let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n@@ -242,10 +232,11 @@ pub impl TcpWatcher {\n     }\n \n     fn listen(&mut self, cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.connect_cb.is_none());\n-        data.connect_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n \n         unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n@@ -257,7 +248,7 @@ pub impl TcpWatcher {\n         extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = get_watcher_data(&mut stream_watcher).connect_cb.swap_unwrap();\n+            let cb = stream_watcher.get_watcher_data().connect_cb.swap_unwrap();\n             let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n             cb(stream_watcher, status);\n         }"}, {"sha": "af3bac5b65430f12f93968b5bc89f30e10e2c3f1", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "patch": "@@ -192,9 +192,10 @@ impl RtioTcpListener for UvTcpListener {\n             do server_tcp_watcher.listen |server_stream_watcher, status| {\n                 let maybe_stream = if status.is_none() {\n                     let mut server_stream_watcher = server_stream_watcher;\n-                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                    let client_tcp_watcher = TcpWatcher::new(&mut loop_).as_stream();\n-                    // XXX: Needs to be surfaced in interface\n+                    let mut loop_ = server_stream_watcher.event_loop();\n+                    let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                    let client_tcp_watcher = client_tcp_watcher.as_stream();\n+                    // XXX: Need's to be surfaced in interface\n                     server_stream_watcher.accept(client_tcp_watcher);\n                     Ok(~UvTcpStream { watcher: client_tcp_watcher })\n                 } else {"}]}