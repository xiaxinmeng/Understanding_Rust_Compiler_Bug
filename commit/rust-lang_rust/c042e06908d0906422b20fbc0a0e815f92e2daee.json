{"sha": "c042e06908d0906422b20fbc0a0e815f92e2daee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNDJlMDY5MDhkMDkwNjQyMmIyMGZiYzBhMGU4MTVmOTJlMmRhZWU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T22:45:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T23:11:17Z"}, "message": "De-export vec. Part of #3583.", "tree": {"sha": "d5614344940c9d7c9f91ebf756bb1163a3d78c11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5614344940c9d7c9f91ebf756bb1163a3d78c11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c042e06908d0906422b20fbc0a0e815f92e2daee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c042e06908d0906422b20fbc0a0e815f92e2daee", "html_url": "https://github.com/rust-lang/rust/commit/c042e06908d0906422b20fbc0a0e815f92e2daee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c042e06908d0906422b20fbc0a0e815f92e2daee/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c3fede84ffc8c20e232a3e777c037371c1da403", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c3fede84ffc8c20e232a3e777c037371c1da403", "html_url": "https://github.com/rust-lang/rust/commit/4c3fede84ffc8c20e232a3e777c037371c1da403"}], "stats": {"total": 378, "additions": 139, "deletions": 239}, "files": [{"sha": "da50ff77c52a63a51f3afcf4d0672c0a3e4aafff", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c042e06908d0906422b20fbc0a0e815f92e2daee/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c042e06908d0906422b20fbc0a0e815f92e2daee/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c042e06908d0906422b20fbc0a0e815f92e2daee", "patch": "@@ -170,7 +170,6 @@ mod f32;\n mod f64;\n mod str;\n mod ptr;\n-#[legacy_exports]\n mod vec;\n mod at_vec;\n mod bool;"}, {"sha": "3fdf97cf3501ccd429fe94d20af8e570b2ae9463", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 139, "deletions": 238, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/c042e06908d0906422b20fbc0a0e815f92e2daee/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c042e06908d0906422b20fbc0a0e815f92e2daee/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c042e06908d0906422b20fbc0a0e815f92e2daee", "patch": "@@ -9,125 +9,30 @@ use option::{Some, None};\n use ptr::addr_of;\n use libc::size_t;\n \n-export append;\n-export append_one;\n-export consume, consume_mut;\n-export init_op;\n-export is_empty;\n-export is_not_empty;\n-export same_length;\n-export reserve;\n-export reserve_at_least;\n-export capacity;\n-export len;\n-export from_fn;\n-export from_elem;\n-export from_slice;\n-export with_capacity;\n-export build, build_sized, build_sized_opt;\n-export to_mut;\n-export from_mut;\n-export head;\n-export tail;\n-export tailn;\n-export init;\n-export last;\n-export last_opt;\n-export slice;\n-export view, mut_view, const_view;\n-export split;\n-export splitn;\n-export rsplit;\n-export rsplitn;\n-export shift;\n-export unshift;\n-export pop;\n-export swap_remove;\n-export push, push_all, push_all_move;\n-export grow;\n-export grow_fn;\n-export grow_set;\n-export truncate;\n-export dedup;\n-export map;\n-export mapi;\n-export map2;\n-export map_consume;\n-export flat_map;\n-export filter_map;\n-export filter;\n-export concat;\n-export connect;\n-export foldl;\n-export foldr;\n-export any;\n-export any2;\n-export all;\n-export alli;\n-export all2;\n-export contains;\n-export count;\n-export find;\n-export find_between;\n-export rfind;\n-export rfind_between;\n-export position_elem;\n-export position;\n-export position_between;\n-export rposition;\n-export rposition_between;\n-export unzip;\n-export zip, zip_slice;\n-export swap;\n-export reverse;\n-export reversed;\n-export each, each_mut, each_const, eachi, rev_each, rev_eachi;\n-export each2;\n-export permute;\n-export windowed;\n-export as_imm_buf;\n-export as_mut_buf;\n-export as_const_buf;\n-export raw;\n-export bytes;\n-export extensions;\n-export ConstVector;\n-export CopyableVector;\n-export ImmutableVector;\n-export ImmutableEqVector;\n-export ImmutableCopyableVector;\n-export MutableVector;\n-export MutableCopyableVector;\n-export IterTraitExtensions;\n-export vec_concat;\n-export traits;\n-\n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn vec_reserve_shared(++t: *sys::TypeDesc,\n                           ++v: **raw::VecRepr,\n                           ++n: libc::size_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n     fn move_val_init<T>(&dst: T, -src: T);\n }\n \n /// Returns true if a vector contains no elements\n-pure fn is_empty<T>(v: &[const T]) -> bool {\n+pub pure fn is_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n }\n \n /// Returns true if a vector contains some elements\n-pure fn is_not_empty<T>(v: &[const T]) -> bool {\n+pub pure fn is_not_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len > 0u)\n }\n \n /// Returns true if two vectors have the same length\n-pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n+pub pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n     len(xs) == len(ys)\n }\n \n@@ -142,7 +47,7 @@ pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n-fn reserve<T>(+v: &mut ~[T], +n: uint) {\n+pub fn reserve<T>(+v: &mut ~[T], +n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     if capacity(v) < n {\n         unsafe {\n@@ -168,13 +73,13 @@ fn reserve<T>(+v: &mut ~[T], +n: uint) {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n-fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n+pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n     reserve(v, uint::next_power_of_two(n));\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pure fn capacity<T>(v: &const ~[T]) -> uint {\n+pub pure fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n@@ -183,7 +88,7 @@ pure fn capacity<T>(v: &const ~[T]) -> uint {\n \n /// Returns the length of a vector\n #[inline(always)]\n-pure fn len<T>(v: &[const T]) -> uint {\n+pub pure fn len<T>(v: &[const T]) -> uint {\n     as_const_buf(v, |_p, len| len)\n }\n \n@@ -193,7 +98,7 @@ pure fn len<T>(v: &[const T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n+pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         do as_mut_buf(v) |p, _len| {\n@@ -214,16 +119,16 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: Copy>(n_elts: uint, +t: T) -> ~[T] {\n+pub pure fn from_elem<T: Copy>(n_elts: uint, +t: T) -> ~[T] {\n     from_fn(n_elts, |_i| copy t)\n }\n \n /// Creates a new unique vector with the same contents as the slice\n-pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n+pub pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n     from_fn(t.len(), |i| t[i])\n }\n \n-pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n+pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n     unsafe { reserve(&mut vec, capacity); }\n     return move vec;\n@@ -242,7 +147,7 @@ pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized<A>(size: uint,\n+pub pure fn build_sized<A>(size: uint,\n                        builder: fn(push: pure fn(+v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n     builder(|+x| unsafe { vec.push(move x) });\n@@ -260,7 +165,7 @@ pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+pub pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n@@ -277,47 +182,47 @@ pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> ~[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A>(size: Option<uint>,\n+pub pure fn build_sized_opt<A>(size: Option<uint>,\n                            builder: fn(push: pure fn(+v: A))) -> ~[A] {\n     build_sized(size.get_default(4), builder)\n }\n \n /// Produces a mut vector from an immutable vector.\n-pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n+pub pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n     unsafe { ::cast::transmute(move v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n-pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n+pub pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n     unsafe { ::cast::transmute(move v) }\n }\n \n // Accessors\n \n /// Returns the first element of a vector\n-pure fn head<T: Copy>(v: &[const T]) -> T { v[0] }\n+pub pure fn head<T: Copy>(v: &[const T]) -> T { v[0] }\n \n /// Returns a vector containing all but the first element of a slice\n-pure fn tail<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn tail<T: Copy>(v: &[const T]) -> ~[T] {\n     return slice(v, 1u, len(v));\n }\n \n /**\n  * Returns a vector containing all but the first `n` \\\n  * elements of a slice\n  */\n-pure fn tailn<T: Copy>(v: &[const T], n: uint) -> ~[T] {\n+pub pure fn tailn<T: Copy>(v: &[const T], n: uint) -> ~[T] {\n     slice(v, n, len(v))\n }\n \n /// Returns a vector containing all but the last element of a slice\n-pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pure fn last<T: Copy>(v: &[const T]) -> T {\n+pub pure fn last<T: Copy>(v: &[const T]) -> T {\n     if len(v) == 0u { fail ~\"last_unsafe: empty vector\" }\n     v[len(v) - 1u]\n }\n@@ -326,13 +231,13 @@ pure fn last<T: Copy>(v: &[const T]) -> T {\n  * Returns `Some(x)` where `x` is the last element of the slice `v`,\n  * or `none` if the vector is empty.\n  */\n-pure fn last_opt<T: Copy>(v: &[const T]) -> Option<T> {\n+pub pure fn last_opt<T: Copy>(v: &[const T]) -> Option<T> {\n     if len(v) == 0u { return None; }\n     Some(v[len(v) - 1u])\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n+pub pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let mut result = ~[];\n@@ -343,7 +248,7 @@ pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n }\n \n /// Return a slice that points into another slice.\n-pure fn view<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n+pub pure fn view<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n@@ -356,7 +261,7 @@ pure fn view<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n }\n \n /// Return a slice that points into another slice.\n-pure fn mut_view<T>(v: &r/[mut T], start: uint, end: uint) -> &r/[mut T] {\n+pub pure fn mut_view<T>(v: &r/[mut T], start: uint, end: uint) -> &r/[mut T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_mut_buf(v) |p, _len| {\n@@ -369,7 +274,7 @@ pure fn mut_view<T>(v: &r/[mut T], start: uint, end: uint) -> &r/[mut T] {\n }\n \n /// Return a slice that points into another slice.\n-pure fn const_view<T>(v: &r/[const T], start: uint,\n+pub pure fn const_view<T>(v: &r/[const T], start: uint,\n                       end: uint) -> &r/[const T] {\n     assert (start <= end);\n     assert (end <= len(v));\n@@ -383,7 +288,7 @@ pure fn const_view<T>(v: &r/[const T], start: uint,\n }\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n-fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -406,7 +311,7 @@ fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Split the vector `v` by applying each element against the predicate `f` up\n  * to `n` times.\n  */\n-fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -432,7 +337,7 @@ fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f`.\n  */\n-fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -456,7 +361,7 @@ fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f` up to `n times.\n  */\n-fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -482,7 +387,7 @@ fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n // Mutators\n \n /// Removes the first element from a vector and return it\n-fn shift<T>(v: &mut ~[T]) -> T {\n+pub fn shift<T>(v: &mut ~[T]) -> T {\n     let ln = v.len();\n     assert (ln > 0);\n \n@@ -507,13 +412,13 @@ fn shift<T>(v: &mut ~[T]) -> T {\n }\n \n /// Prepend an element to the vector\n-fn unshift<T>(v: &mut ~[T], +x: T) {\n+pub fn unshift<T>(v: &mut ~[T], +x: T) {\n     let mut vv = ~[move x];\n     *v <-> vv;\n     v.push_all_move(vv);\n }\n \n-fn consume<T>(+v: ~[T], f: fn(uint, +v: T)) unsafe {\n+pub fn consume<T>(+v: ~[T], f: fn(uint, +v: T)) unsafe {\n     let mut v = move v; // FIXME(#3488)\n \n     do as_imm_buf(v) |p, ln| {\n@@ -526,12 +431,12 @@ fn consume<T>(+v: ~[T], f: fn(uint, +v: T)) unsafe {\n     raw::set_len(&mut v, 0);\n }\n \n-fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +v: T)) {\n+pub fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +v: T)) {\n     consume(vec::from_mut(v), f)\n }\n \n /// Remove the last element from a vector and return it\n-fn pop<T>(v: &mut ~[T]) -> T {\n+pub fn pop<T>(v: &mut ~[T]) -> T {\n     let ln = v.len();\n     if ln == 0 {\n         fail ~\"sorry, cannot vec::pop an empty vector\"\n@@ -550,7 +455,7 @@ fn pop<T>(v: &mut ~[T]) -> T {\n  *\n  * Fails if index >= length.\n  */\n-fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n+pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n     let ln = v.len();\n     if index >= ln {\n         fail fmt!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n@@ -563,7 +468,7 @@ fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n \n /// Append an element to a vector\n #[inline(always)]\n-fn push<T>(v: &mut ~[T], +initval: T) {\n+pub fn push<T>(v: &mut ~[T], +initval: T) {\n     unsafe {\n         let repr: **raw::VecRepr = ::cast::transmute(copy v);\n         let fill = (**repr).unboxed.fill;\n@@ -594,7 +499,7 @@ fn push_slow<T>(+v: &mut ~[T], +initval: T) {\n }\n \n #[inline(always)]\n-fn push_all<T: Copy>(+v: &mut ~[T], rhs: &[const T]) {\n+pub fn push_all<T: Copy>(+v: &mut ~[T], rhs: &[const T]) {\n     reserve(v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n@@ -603,7 +508,7 @@ fn push_all<T: Copy>(+v: &mut ~[T], rhs: &[const T]) {\n }\n \n #[inline(always)]\n-fn push_all_move<T>(v: &mut ~[T], +rhs: ~[T]) {\n+pub fn push_all_move<T>(v: &mut ~[T], +rhs: ~[T]) {\n     let mut rhs = move rhs; // FIXME(#3488)\n     reserve(v, v.len() + rhs.len());\n     unsafe {\n@@ -618,7 +523,7 @@ fn push_all_move<T>(v: &mut ~[T], +rhs: ~[T]) {\n }\n \n /// Shorten a vector, dropping excess elements.\n-fn truncate<T>(v: &mut ~[T], newlen: uint) {\n+pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     do as_imm_buf(*v) |p, oldlen| {\n         assert(newlen <= oldlen);\n         unsafe {\n@@ -635,7 +540,7 @@ fn truncate<T>(v: &mut ~[T], newlen: uint) {\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n  */\n-fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n+pub fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n     if v.len() < 1 { return; }\n     let mut last_written = 0, next_to_read = 1;\n     do as_const_buf(*v) |p, ln| {\n@@ -668,7 +573,7 @@ fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n \n // Appending\n #[inline(always)]\n-pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v <- lhs;\n     unsafe {\n         v.push_all(rhs);\n@@ -677,7 +582,7 @@ pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n }\n \n #[inline(always)]\n-pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n+pub pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n     let mut v <- lhs;\n     unsafe { v.push(move x); }\n     move v\n@@ -697,7 +602,7 @@ pure fn append_mut<T: Copy>(+lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n  * * n - The number of elements to add\n  * * initval - The value for the new elements\n  */\n-fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n+pub fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n     reserve_at_least(v, v.len() + n);\n     let mut i: uint = 0u;\n \n@@ -720,7 +625,7 @@ fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n  * * init_op - A function to call to retreive each appended element's\n  *             value\n  */\n-fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n+pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n     reserve_at_least(v, v.len() + n);\n     let mut i: uint = 0u;\n     while i < n {\n@@ -737,7 +642,7 @@ fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n  * of the vector, expands the vector by replicating `initval` to fill the\n  * intervening space.\n  */\n-fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, +val: T) {\n+pub fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, +val: T) {\n     let l = v.len();\n     if index >= l { grow(v, index - l + 1u, initval); }\n     v[index] = move val;\n@@ -746,7 +651,7 @@ fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, +val: T) {\n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n+pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n         unsafe {\n@@ -756,7 +661,7 @@ pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n     move result\n }\n \n-fn map_consume<T, U>(+v: ~[T], f: fn(+v: T) -> U) -> ~[U] {\n+pub fn map_consume<T, U>(+v: ~[T], f: fn(+v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n     do consume(move v) |_i, x| {\n         result.push(f(move x));\n@@ -765,7 +670,7 @@ fn map_consume<T, U>(+v: ~[T], f: fn(+v: T) -> U) -> ~[U] {\n }\n \n /// Apply a function to each element of a vector and return the results\n-pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n+pub pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n     let mut i = 0;\n     do map(v) |e| {\n         i += 1;\n@@ -777,14 +682,14 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n+pub pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n     move result\n }\n \n /// Apply a function to each pair of elements and return the results\n-pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n+pub pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n                                   f: fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n@@ -803,7 +708,7 @@ pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n  * If function `f` returns `none` then that element is excluded from\n  * the resulting vector.\n  */\n-pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n+pub pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| {\n@@ -822,7 +727,7 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pure fn filter<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n+pub pure fn filter<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         if f(elem) { unsafe { result.push(*elem); } }\n@@ -835,14 +740,14 @@ pure fn filter<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n  *\n  * Flattens a vector of vectors of T into a single vector of T.\n  */\n-pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n+pub pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { r.push_all(*inner); } }\n     move r\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n+pub pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n@@ -853,7 +758,7 @@ pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n }\n \n /// Reduce a vector from left to right\n-pure fn foldl<T: Copy, U>(+z: T, v: &[U], p: fn(+t: T, u: &U) -> T) -> T {\n+pub pure fn foldl<T: Copy, U>(+z: T, v: &[U], p: fn(+t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     for each(v) |elt| {\n         // it should be possible to move accum in, but the liveness analysis\n@@ -864,7 +769,7 @@ pure fn foldl<T: Copy, U>(+z: T, v: &[U], p: fn(+t: T, u: &U) -> T) -> T {\n }\n \n /// Reduce a vector from right to left\n-pure fn foldr<T, U: Copy>(v: &[T], +z: U, p: fn(t: &T, +u: U) -> U) -> U {\n+pub pure fn foldr<T, U: Copy>(v: &[T], +z: U, p: fn(t: &T, +u: U) -> U) -> U {\n     let mut accum = z;\n     for rev_each(v) |elt| {\n         accum = p(elt, accum);\n@@ -877,7 +782,7 @@ pure fn foldr<T, U: Copy>(v: &[T], +z: U, p: fn(t: &T, +u: U) -> U) -> U {\n  *\n  * If the vector contains no elements then false is returned.\n  */\n-pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+pub pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if f(elem) { return true; } }\n     return false;\n }\n@@ -887,7 +792,7 @@ pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n  *\n  * If the vectors contains no elements then false is returned.\n  */\n-pure fn any2<T, U>(v0: &[T], v1: &[U],\n+pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n                    f: fn(a: &T, b: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n@@ -904,7 +809,7 @@ pure fn any2<T, U>(v0: &[T], v1: &[U],\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if !f(elem) { return false; } }\n     return true;\n }\n@@ -914,7 +819,7 @@ pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n+pub pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n     for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n     return true;\n }\n@@ -924,7 +829,7 @@ pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n  *\n  * If the vectors are not the same size then false is returned.\n  */\n-pure fn all2<T, U>(v0: &[T], v1: &[U],\n+pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n                    f: fn(t: &T, u: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { return false; }\n@@ -934,13 +839,13 @@ pure fn all2<T, U>(v0: &[T], v1: &[U],\n }\n \n /// Return true if a vector contains an element with the given value\n-pure fn contains<T: Eq>(v: &[T], x: &T) -> bool {\n+pub pure fn contains<T: Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n     return false;\n }\n \n /// Returns the number of elements that are equal to a given value\n-pure fn count<T: Eq>(v: &[T], x: &T) -> uint {\n+pub pure fn count<T: Eq>(v: &[T], x: &T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n     return cnt;\n@@ -953,7 +858,7 @@ pure fn count<T: Eq>(v: &[T], x: &T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn find<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -964,7 +869,7 @@ pure fn find<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n+pub pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n                       f: fn(t: &T) -> bool) -> Option<T> {\n     position_between(v, start, end, f).map(|i| v[*i])\n }\n@@ -976,7 +881,7 @@ pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rfind<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn rfind<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -987,13 +892,13 @@ pure fn rfind<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is return.\n  */\n-pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n+pub pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n                                f: fn(t: &T) -> bool) -> Option<T> {\n     rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n /// Find the first index containing a matching value\n-pure fn position_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n+pub pure fn position_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n     position(v, |y| *x == *y)\n }\n \n@@ -1004,7 +909,7 @@ pure fn position_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n+pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -1015,7 +920,7 @@ pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn position_between<T>(v: &[T], start: uint, end: uint,\n+pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n                             f: fn(t: &T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n@@ -1036,7 +941,7 @@ pure fn rposition_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n+pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -1048,7 +953,7 @@ pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  * containing the index is returned. If `f` matches no elements then none is\n  * returned.\n  */\n-pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n+pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: fn(t: &T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n@@ -1087,7 +992,7 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  * and the i-th element of the second vector contains the second element\n  * of the i-th tuple of the input vector.\n  */\n-pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n+pub pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unsafe {\n         do consume(move v) |_i, p| {\n@@ -1102,7 +1007,7 @@ pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n+pub pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n@@ -1118,7 +1023,7 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n  * Returns a vector of tuples, where the i-th tuple contains contains the\n  * i-th elements from each of the input vectors.\n  */\n-pure fn zip<T, U>(+v: ~[T], +u: ~[U]) -> ~[(T, U)] {\n+pub pure fn zip<T, U>(+v: ~[T], +u: ~[U]) -> ~[(T, U)] {\n     let mut v = move v, u = move u; // FIXME(#3488)\n     let mut i = len(v);\n     assert i == len(u);\n@@ -1140,19 +1045,19 @@ pure fn zip<T, U>(+v: ~[T], +u: ~[U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n-fn swap<T>(v: &[mut T], a: uint, b: uint) {\n+pub fn swap<T>(v: &[mut T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n /// Reverse the order of elements in a vector, in place\n-fn reverse<T>(v: &[mut T]) {\n+pub fn reverse<T>(v: &[mut T]) {\n     let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n /// Returns a vector with the order of elements reversed\n-pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (move rs); } else { i -= 1; }\n@@ -1169,7 +1074,7 @@ pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n+pub pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1193,7 +1098,7 @@ pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n+pub fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1207,7 +1112,7 @@ fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n+pub pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1224,7 +1129,7 @@ pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n+pub pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return; }\n@@ -1238,7 +1143,7 @@ pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n+pub pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n     rev_eachi(v, |_i, v| blk(v))\n }\n \n@@ -1248,7 +1153,7 @@ pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n+pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1266,7 +1171,7 @@ pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n     assert len(v1) == len(v2);\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1309,7 +1214,7 @@ pure fn each_permutation<T: Copy>(+v: &[T], put: fn(ts: &[T]) -> bool) {\n     }\n }\n \n-pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n+pub pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     assert 1u <= nn;\n     for vec::eachi (xx) |ii, _x| {\n@@ -1328,8 +1233,9 @@ pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n  * foreign interop.\n  */\n #[inline(always)]\n-pure fn as_imm_buf<T,U>(s: &[T], /* NB---this CANNOT be const, see below */\n-                        f: fn(*T, uint) -> U) -> U {\n+pub pure fn as_imm_buf<T,U>(s: &[T],\n+                            /* NB---this CANNOT be const, see below */\n+                            f: fn(*T, uint) -> U) -> U {\n \n     // NB---Do not change the type of s to `&[const T]`.  This is\n     // unsound.  The reason is that we are going to create immutable pointers\n@@ -1347,7 +1253,7 @@ pure fn as_imm_buf<T,U>(s: &[T], /* NB---this CANNOT be const, see below */\n \n /// Similar to `as_imm_buf` but passing a `*const T`\n #[inline(always)]\n-pure fn as_const_buf<T,U>(s: &[const T],\n+pub pure fn as_const_buf<T,U>(s: &[const T],\n                           f: fn(*const T, uint) -> U) -> U {\n \n     unsafe {\n@@ -1360,7 +1266,7 @@ pure fn as_const_buf<T,U>(s: &[const T],\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n-pure fn as_mut_buf<T,U>(s: &[mut T],\n+pub pure fn as_mut_buf<T,U>(s: &[mut T],\n                         f: fn(*mut T, uint) -> U) -> U {\n \n     unsafe {\n@@ -1462,8 +1368,7 @@ impl<T: Ord> @[T] : Ord {\n }\n \n #[cfg(notest)]\n-mod traits {\n-    #[legacy_exports];\n+pub mod traits {\n     impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> ~[T] {\n@@ -1480,10 +1385,9 @@ mod traits {\n }\n \n #[cfg(test)]\n-mod traits {\n-    #[legacy_exports];}\n+pub mod traits {}\n \n-trait ConstVector {\n+pub trait ConstVector {\n     pure fn is_empty() -> bool;\n     pure fn is_not_empty() -> bool;\n     pure fn len() -> uint;\n@@ -1502,7 +1406,7 @@ impl<T> &[const T]: ConstVector {\n     pure fn len() -> uint { len(self) }\n }\n \n-trait CopyableVector<T> {\n+pub trait CopyableVector<T> {\n     pure fn head() -> T;\n     pure fn init() -> ~[T];\n     pure fn last() -> T;\n@@ -1529,7 +1433,7 @@ impl<T: Copy> &[const T]: CopyableVector<T> {\n     pure fn tail() -> ~[T] { tail(self) }\n }\n \n-trait ImmutableVector<T> {\n+pub trait ImmutableVector<T> {\n     pure fn view(start: uint, end: uint) -> &self/[T];\n     pure fn foldr<U: Copy>(+z: U, p: fn(t: &T, +u: U) -> U) -> U;\n     pure fn map<U>(f: fn(t: &T) -> U) -> ~[U];\n@@ -1540,7 +1444,7 @@ trait ImmutableVector<T> {\n     pure fn filter_map<U: Copy>(f: fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n-trait ImmutableEqVector<T: Eq> {\n+pub trait ImmutableEqVector<T: Eq> {\n     pure fn position(f: fn(t: &T) -> bool) -> Option<uint>;\n     pure fn position_elem(t: &T) -> Option<uint>;\n     pure fn rposition(f: fn(t: &T) -> bool) -> Option<uint>;\n@@ -1646,7 +1550,7 @@ impl<T: Eq> &[T]: ImmutableEqVector<T> {\n     }\n }\n \n-trait ImmutableCopyableVector<T> {\n+pub trait ImmutableCopyableVector<T> {\n     pure fn filter(f: fn(t: &T) -> bool) -> ~[T];\n \n     pure fn rfind(f: fn(t: &T) -> bool) -> Option<T>;\n@@ -1677,7 +1581,7 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n     pure fn rfind(f: fn(t: &T) -> bool) -> Option<T> { rfind(self, f) }\n }\n \n-trait MutableVector<T> {\n+pub trait MutableVector<T> {\n     fn push(&mut self, +t: T);\n     fn push_all_move(&mut self, +rhs: ~[T]);\n     fn pop(&mut self) -> T;\n@@ -1687,7 +1591,7 @@ trait MutableVector<T> {\n     fn truncate(&mut self, newlen: uint);\n }\n \n-trait MutableCopyableVector<T: Copy> {\n+pub trait MutableCopyableVector<T: Copy> {\n     fn push_all(&mut self, rhs: &[const T]);\n     fn grow(&mut self, n: uint, initval: &T);\n     fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n@@ -1753,24 +1657,23 @@ impl<T: Eq> ~[T]: MutableEqVector<T> {\n }\n \n /// Unsafe operations\n-mod raw {\n-    #[legacy_exports];\n+pub mod raw {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n \n     /// The internal representation of a (boxed) vector\n-    struct VecRepr {\n+    pub struct VecRepr {\n         box_header: box::raw::BoxHeaderRepr,\n         unboxed: UnboxedVecRepr\n     }\n \n     /// The internal 'unboxed' representation of a vector\n-    struct UnboxedVecRepr {\n+    pub struct UnboxedVecRepr {\n         mut fill: uint,\n         mut alloc: uint,\n         data: u8\n     }\n \n-    type SliceRepr = {\n+    pub type SliceRepr = {\n         mut data: *u8,\n         mut len: uint\n     };\n@@ -1784,7 +1687,7 @@ mod raw {\n      * * elts - The number of elements in the buffer\n      */\n     #[inline(always)]\n-    unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n+    pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n         as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n@@ -1799,7 +1702,7 @@ mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline(always)]\n-    unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n+    pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n         let repr: **VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n@@ -1814,21 +1717,21 @@ mod raw {\n      * would also make any pointers to it invalid.\n      */\n     #[inline(always)]\n-    unsafe fn to_ptr<T>(+v: &[T]) -> *T {\n+    pub unsafe fn to_ptr<T>(+v: &[T]) -> *T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    unsafe fn to_const_ptr<T>(+v: &[const T]) -> *const T {\n+    pub unsafe fn to_const_ptr<T>(+v: &[const T]) -> *const T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    unsafe fn to_mut_ptr<T>(+v: &[mut T]) -> *mut T {\n+    pub unsafe fn to_mut_ptr<T>(+v: &[mut T]) -> *mut T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n@@ -1838,7 +1741,8 @@ mod raw {\n      * not bytes).\n      */\n     #[inline(always)]\n-    unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn(v: &[T]) -> U) -> U {\n+    pub unsafe fn form_slice<T,U>(p: *T, len: uint,\n+                                  f: fn(v: &[T]) -> U) -> U {\n         let pair = (p, len * sys::size_of::<T>());\n         let v : *(&blk/[T]) =\n             ::cast::reinterpret_cast(&addr_of(&pair));\n@@ -1849,7 +1753,7 @@ mod raw {\n      * Unchecked vector indexing.\n      */\n     #[inline(always)]\n-    unsafe fn get<T: Copy>(v: &[const T], i: uint) -> T {\n+    pub unsafe fn get<T: Copy>(v: &[const T], i: uint) -> T {\n         as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n     }\n \n@@ -1859,7 +1763,7 @@ mod raw {\n      * is newly allocated.\n      */\n     #[inline(always)]\n-    unsafe fn init_elem<T>(v: &[mut T], i: uint, +val: T) {\n+    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, +val: T) {\n         let mut box = Some(move val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n@@ -1875,7 +1779,7 @@ mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    unsafe fn memcpy<T>(dst: &[mut T], src: &[const T], count: uint) {\n+    pub unsafe fn memcpy<T>(dst: &[mut T], src: &[const T], count: uint) {\n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n                 ptr::memcpy(p_dst, p_src, count)\n@@ -1889,7 +1793,7 @@ mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    unsafe fn memmove<T>(dst: &[mut T], src: &[const T], count: uint) {\n+    pub unsafe fn memmove<T>(dst: &[mut T], src: &[const T], count: uint) {\n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n                 ptr::memmove(p_dst, p_src, count)\n@@ -1899,14 +1803,10 @@ mod raw {\n }\n \n /// Operations on `[u8]`\n-mod bytes {\n-    #[legacy_exports];\n-    export cmp;\n-    export lt, le, eq, ne, ge, gt;\n-    export memcpy, memmove;\n+pub mod bytes {\n \n     /// Bytewise string comparison\n-    pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n+    pub pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = len(*a);\n         let b_len = len(*b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -1927,30 +1827,30 @@ mod bytes {\n     }\n \n     /// Bytewise less than or equal\n-    pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n+    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n+    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n+    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n+    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n+    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n+    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n \n     /**\n       * Copies data from one vector to another.\n       *\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may not overlap.\n       */\n-    fn memcpy(dst: &[mut u8], src: &[const u8], count: uint) {\n+    pub fn memcpy(dst: &[mut u8], src: &[const u8], count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n@@ -1963,7 +1863,7 @@ mod bytes {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    fn memmove(dst: &[mut u8], src: &[const u8], count: uint) {\n+    pub fn memmove(dst: &[mut u8], src: &[const u8], count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n@@ -1978,7 +1878,7 @@ mod bytes {\n // required in the slice.\n \n impl<A> &[A]: iter::BaseIter<A> {\n-    pure fn each(blk: fn(v: &A) -> bool) {\n+    pub pure fn each(blk: fn(v: &A) -> bool) {\n         // FIXME(#2263)---should be able to call each(self, blk)\n         for each(self) |e| {\n             if (!blk(e)) {\n@@ -1990,20 +1890,22 @@ impl<A> &[A]: iter::BaseIter<A> {\n }\n \n impl<A> &[A]: iter::ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(&self, blk) }\n-    pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n-    pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n-    pure fn foldl<B>(+b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn eachi(blk: fn(uint, v: &A) -> bool) {\n+        iter::eachi(&self, blk)\n+    }\n+    pub pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n+    pub pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n+    pub pure fn foldl<B>(+b0: B, blk: fn(&B, &A) -> B) -> B {\n         iter::foldl(&self, move b0, blk)\n     }\n-    pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n+    pub pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n         iter::position(&self, f)\n     }\n }\n \n impl<A: Eq> &[A]: iter::EqIter<A> {\n-    pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n-    pure fn count(x: &A) -> uint { iter::count(&self, x) }\n+    pub pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n+    pub pure fn count(x: &A) -> uint { iter::count(&self, x) }\n }\n \n impl<A: Copy> &[A]: iter::CopyableIter<A> {\n@@ -2020,7 +1922,9 @@ impl<A: Copy> &[A]: iter::CopyableIter<A> {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n-    pure fn find(p: fn(+a: A) -> bool) -> Option<A> { iter::find(&self, p) }\n+    pub pure fn find(p: fn(+a: A) -> bool) -> Option<A> {\n+        iter::find(&self, p)\n+    }\n }\n \n impl<A: Copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n@@ -2031,7 +1935,6 @@ impl<A: Copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     fn square(n: uint) -> uint { return n * n; }\n \n@@ -3430,8 +3333,6 @@ mod tests {\n             fail\n         }\n     }\n-\n-\n }\n \n // Local Variables:"}]}