{"sha": "15ef5f552374e52ca3b578757880938e354b6cc0", "node_id": "C_kwDOAAsO6NoAKDE1ZWY1ZjU1MjM3NGU1MmNhM2I1Nzg3NTc4ODA5MzhlMzU0YjZjYzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-24T19:56:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-24T19:56:43Z"}, "message": "Auto merge of #14641 - lowr:fix/obligation-for-value-path, r=Veykril\n\nRegister obligations during path inference\n\nFixes #14635\n\nWhen we infer path expressions that resolve to some generic item, we need to consider their generic bounds. For example, when we resolve a path `Into::into` to `fn into<?0, ?1>` (note that `?0` is the self type of trait ref), we should register an obligation `?0: Into<?1>` or else their relationship would be lost.\n\nRelevant part in rustc is [`add_required_obligations_with_code()`] that's called in [`instantiate_value_path()`].\n\n[`instantiate_value_path()`]: https://github.com/rust-lang/rust/blob/3462f79e94f466a56ddaccfcdd3a3d44dd1dda9f/compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs#L1052\n[`add_required_obligations_with_code()`]: https://github.com/rust-lang/rust/blob/3462f79e94f466a56ddaccfcdd3a3d44dd1dda9f/compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs#L1411", "tree": {"sha": "0bee996e82440681d68b09e10e303d213f112308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bee996e82440681d68b09e10e303d213f112308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ef5f552374e52ca3b578757880938e354b6cc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ef5f552374e52ca3b578757880938e354b6cc0", "html_url": "https://github.com/rust-lang/rust/commit/15ef5f552374e52ca3b578757880938e354b6cc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ef5f552374e52ca3b578757880938e354b6cc0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65ac9f4602b87e69bf17298f4cd72dc813d5554b", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ac9f4602b87e69bf17298f4cd72dc813d5554b", "html_url": "https://github.com/rust-lang/rust/commit/65ac9f4602b87e69bf17298f4cd72dc813d5554b"}, {"sha": "12ba5cab112a863e63e51d56e0660d999c86b679", "url": "https://api.github.com/repos/rust-lang/rust/commits/12ba5cab112a863e63e51d56e0660d999c86b679", "html_url": "https://github.com/rust-lang/rust/commit/12ba5cab112a863e63e51d56e0660d999c86b679"}], "stats": {"total": 193, "additions": 142, "deletions": 51}, "files": [{"sha": "97924569ccc0dea7a83d2a2f067ebbb020fceb6e", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=15ef5f552374e52ca3b578757880938e354b6cc0", "patch": "@@ -18,7 +18,6 @@ use crate::{\n     consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n     to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, BoundVar, CallableSig,\n     GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n-    ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -362,21 +361,4 @@ impl TyBuilder<Binders<Ty>> {\n     pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n         TyBuilder::subst_for_def(db, def, None).with_data(db.impl_self_ty(def))\n     }\n-\n-    pub fn value_ty(\n-        db: &dyn HirDatabase,\n-        def: ValueTyDefId,\n-        parent_subst: Option<Substitution>,\n-    ) -> TyBuilder<Binders<Ty>> {\n-        let poly_value_ty = db.value_ty(def);\n-        let id = match def.to_generic_def_id() {\n-            Some(id) => id,\n-            None => {\n-                // static items\n-                assert!(parent_subst.is_none());\n-                return TyBuilder::new_empty(poly_value_ty);\n-            }\n-        };\n-        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_value_ty)\n-    }\n }"}, {"sha": "fb7d99711d945845b6d653f16c6cbd32e7ff25bd", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=15ef5f552374e52ca3b578757880938e354b6cc0", "patch": "@@ -803,17 +803,17 @@ pub(crate) fn adt_variance_query(\n     )\n }\n \n+/// Returns instantiated predicates.\n pub(super) fn convert_where_clauses(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n     substs: &Substitution,\n ) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n-    let generic_predicates = db.generic_predicates(def);\n-    let mut result = Vec::with_capacity(generic_predicates.len());\n-    for pred in generic_predicates.iter() {\n-        result.push(pred.clone().substitute(Interner, substs));\n-    }\n-    result\n+    db.generic_predicates(def)\n+        .iter()\n+        .cloned()\n+        .map(|pred| pred.substitute(Interner, substs))\n+        .collect()\n }\n \n pub(super) fn generic_predicate_to_inline_bound("}, {"sha": "4affe7424e1f72f92ebd39dd94a010d5318eb62b", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=15ef5f552374e52ca3b578757880938e354b6cc0", "patch": "@@ -16,7 +16,10 @@\n use std::sync::Arc;\n use std::{convert::identity, ops::Index};\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n+use chalk_ir::{\n+    cast::Cast, fold::TypeFoldable, interner::HasInterner, DebruijnIndex, Mutability, Safety,\n+    Scalar, TypeFlags,\n+};\n use either::Either;\n use hir_def::{\n     body::Body,\n@@ -798,7 +801,10 @@ impl<'a> InferenceContext<'a> {\n         self.table.insert_type_vars_shallow(ty)\n     }\n \n-    fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+    fn insert_type_vars<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         self.table.insert_type_vars(ty)\n     }\n \n@@ -875,7 +881,10 @@ impl<'a> InferenceContext<'a> {\n     /// type annotation (e.g. from a let type annotation, field type or function\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n-    fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+    fn normalize_associated_types_in<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         self.table.normalize_associated_types_in(ty)\n     }\n "}, {"sha": "95a20f983f1b4058d0b4e29a800512b7d7ea18d8", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=15ef5f552374e52ca3b578757880938e354b6cc0", "patch": "@@ -4,7 +4,7 @@ use chalk_ir::cast::Cast;\n use hir_def::{\n     path::{Path, PathSegment},\n     resolver::{ResolveValueResult, TypeNs, ValueNs},\n-    AdtId, AssocItemId, EnumVariantId, ItemContainerId, Lookup,\n+    AdtId, AssocItemId, EnumVariantId, GenericDefId, ItemContainerId, Lookup,\n };\n use hir_expand::name::Name;\n use stdx::never;\n@@ -13,22 +13,33 @@ use crate::{\n     builder::ParamKind,\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n+    to_chalk_trait_id,\n     utils::generics,\n     InferenceDiagnostic, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n     ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n-impl<'a> InferenceContext<'a> {\n+impl InferenceContext<'_> {\n     pub(super) fn infer_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n-        let ty = self.resolve_value_path(path, id)?;\n-        let ty = self.insert_type_vars(ty);\n+        let (value_def, generic_def, substs) = match self.resolve_value_path(path, id)? {\n+            ValuePathResolution::GenericDef(value_def, generic_def, substs) => {\n+                (value_def, generic_def, substs)\n+            }\n+            ValuePathResolution::NonGeneric(ty) => return Some(ty),\n+        };\n+        let substs = self.insert_type_vars(substs);\n+        let substs = self.normalize_associated_types_in(substs);\n+\n+        self.add_required_obligations_for_value_path(generic_def, &substs);\n+\n+        let ty = self.db.value_ty(value_def).substitute(Interner, &substs);\n         let ty = self.normalize_associated_types_in(ty);\n         Some(ty)\n     }\n \n-    fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n+    fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<ValuePathResolution> {\n         let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n             let last = path.segments().last()?;\n \n@@ -56,9 +67,9 @@ impl<'a> InferenceContext<'a> {\n             }\n         };\n \n-        let typable: ValueTyDefId = match value {\n+        let value_def = match value {\n             ValueNs::LocalBinding(pat) => match self.result.type_of_binding.get(pat) {\n-                Some(ty) => return Some(ty.clone()),\n+                Some(ty) => return Some(ValuePathResolution::NonGeneric(ty.clone())),\n                 None => {\n                     never!(\"uninferred pattern?\");\n                     return None;\n@@ -82,36 +93,81 @@ impl<'a> InferenceContext<'a> {\n                 let substs = generics.placeholder_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n                 if let Some((AdtId::StructId(struct_id), substs)) = ty.as_adt() {\n-                    let ty = self.db.value_ty(struct_id.into()).substitute(Interner, &substs);\n-                    return Some(ty);\n+                    return Some(ValuePathResolution::GenericDef(\n+                        struct_id.into(),\n+                        struct_id.into(),\n+                        substs.clone(),\n+                    ));\n                 } else {\n                     // FIXME: report error, invalid Self reference\n                     return None;\n                 }\n             }\n-            ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n+            ValueNs::GenericParam(it) => {\n+                return Some(ValuePathResolution::NonGeneric(self.db.const_param_ty(it)))\n+            }\n         };\n \n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-        let substs = ctx.substs_from_path(path, typable, true);\n+        let substs = ctx.substs_from_path(path, value_def, true);\n         let substs = substs.as_slice(Interner);\n         let parent_substs = self_subst.or_else(|| {\n-            let generics = generics(self.db.upcast(), typable.to_generic_def_id()?);\n+            let generics = generics(self.db.upcast(), value_def.to_generic_def_id()?);\n             let parent_params_len = generics.parent_generics()?.len();\n             let parent_args = &substs[substs.len() - parent_params_len..];\n             Some(Substitution::from_iter(Interner, parent_args))\n         });\n         let parent_substs_len = parent_substs.as_ref().map_or(0, |s| s.len(Interner));\n         let mut it = substs.iter().take(substs.len() - parent_substs_len).cloned();\n-        let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n+\n+        let Some(generic_def) = value_def.to_generic_def_id() else {\n+            // `value_def` is the kind of item that can never be generic (i.e. statics, at least\n+            // currently). We can just skip the binders to get its type.\n+            let (ty, binders) = self.db.value_ty(value_def).into_value_and_skipped_binders();\n+            stdx::always!(\n+                parent_substs.is_none() && binders.is_empty(Interner),\n+                \"non-empty binders for non-generic def\",\n+            );\n+            return Some(ValuePathResolution::NonGeneric(ty));\n+        };\n+        let builder = TyBuilder::subst_for_def(self.db, generic_def, parent_substs);\n+        let substs = builder\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n                     ParamKind::Type => self.result.standard_types.unknown.clone().cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })\n             .build();\n-        Some(ty)\n+\n+        Some(ValuePathResolution::GenericDef(value_def, generic_def, substs))\n+    }\n+\n+    fn add_required_obligations_for_value_path(&mut self, def: GenericDefId, subst: &Substitution) {\n+        let predicates = self.db.generic_predicates(def);\n+        for predicate in predicates.iter() {\n+            let (predicate, binders) =\n+                predicate.clone().substitute(Interner, &subst).into_value_and_skipped_binders();\n+            // Quantified where clauses are not yet handled.\n+            stdx::always!(binders.is_empty(Interner));\n+            self.push_obligation(predicate.cast(Interner));\n+        }\n+\n+        // We need to add `Self: Trait` obligation when `def` is a trait assoc item.\n+        let container = match def {\n+            GenericDefId::FunctionId(id) => id.lookup(self.db.upcast()).container,\n+            GenericDefId::ConstId(id) => id.lookup(self.db.upcast()).container,\n+            _ => return,\n+        };\n+\n+        if let ItemContainerId::TraitId(trait_) = container {\n+            let param_len = generics(self.db.upcast(), def).len_self();\n+            let parent_subst =\n+                Substitution::from_iter(Interner, subst.iter(Interner).skip(param_len));\n+            let trait_ref =\n+                TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: parent_subst };\n+            self.push_obligation(trait_ref.cast(Interner));\n+        }\n     }\n \n     fn resolve_assoc_item(\n@@ -307,3 +363,10 @@ impl<'a> InferenceContext<'a> {\n         Some((ValueNs::EnumVariantId(variant), subst.clone()))\n     }\n }\n+\n+enum ValuePathResolution {\n+    // It's awkward to wrap a single ID in two enums, but we need both and this saves fallible\n+    // conversion between them + `unwrap()`.\n+    GenericDef(ValueTyDefId, GenericDefId, Substitution),\n+    NonGeneric(Ty),\n+}"}, {"sha": "2988c710398c060052ab2108a58736a26b515523", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=15ef5f552374e52ca3b578757880938e354b6cc0", "patch": "@@ -231,7 +231,10 @@ impl<'a> InferenceTable<'a> {\n     /// type annotation (e.g. from a let type annotation, field type or function\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n-    pub(crate) fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+    pub(crate) fn normalize_associated_types_in<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         fold_tys(\n             ty,\n             |ty, _| match ty.kind(Interner) {\n@@ -720,7 +723,10 @@ impl<'a> InferenceTable<'a> {\n         }\n     }\n \n-    pub(super) fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+    pub(super) fn insert_type_vars<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         fold_tys_and_consts(\n             ty,\n             |x, _| match x {"}, {"sha": "9fb7fdcc5fcfbaa5a6984920fc04b2c2daf9d7d9", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=15ef5f552374e52ca3b578757880938e354b6cc0", "patch": "@@ -742,9 +742,8 @@ fn find_matching_impl(\n     actual_trait_ref: TraitRef,\n ) -> Option<(Arc<ImplData>, Substitution)> {\n     let db = table.db;\n-    loop {\n-        let impl_ = impls.next()?;\n-        let r = table.run_in_snapshot(|table| {\n+    impls.find_map(|impl_| {\n+        table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n             let impl_substs =\n                 TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n@@ -762,11 +761,8 @@ fn find_matching_impl(\n                 .map(|b| b.cast(Interner));\n             let goal = crate::Goal::all(Interner, wcs);\n             table.try_obligation(goal).map(|_| (impl_data, table.resolve_completely(impl_substs)))\n-        });\n-        if r.is_some() {\n-            break r;\n-        }\n-    }\n+        })\n+    })\n }\n \n fn is_inherent_impl_coherent("}, {"sha": "829a6ab189ecc1a4a2cb51aeddde5d2d3770cba6", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ef5f552374e52ca3b578757880938e354b6cc0/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=15ef5f552374e52ca3b578757880938e354b6cc0", "patch": "@@ -4375,3 +4375,38 @@ fn derive_macro_bounds() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn trait_obligations_should_be_registered_during_path_inference() {\n+    check_types(\n+        r#\"\n+//- minicore: fn, from\n+struct S<T>(T);\n+fn map<T, U, F: FnOnce(T) -> S<U>>(_: T, _: F) -> U { loop {} }\n+\n+fn test(v: S<i32>) {\n+    let res = map(v, Into::into);\n+      //^^^ i32\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn fn_obligation_should_be_registered_during_path_inference() {\n+    check_types(\n+        r#\"\n+//- minicore: fn, from\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn foo<U: Into<S<T>>>(_: U) -> Self { loop {} }\n+}\n+fn map<T, U, F: FnOnce(T) -> U>(_: T, _: F) -> U { loop {} }\n+\n+fn test(v: S<i32>) {\n+    let res = map(v, S::foo);\n+      //^^^ S<i32>\n+}\n+\"#,\n+    );\n+}"}]}