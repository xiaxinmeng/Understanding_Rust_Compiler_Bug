{"sha": "dc94f3612583c5e960b334761ad0c18d328840ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOTRmMzYxMjU4M2M1ZTk2MGIzMzQ3NjFhZDBjMThkMzI4ODQwZWE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-25T21:00:16Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-25T21:00:16Z"}, "message": "Merge #1040\n\n1040: Trait beginnings r=matklad a=flodiebold\n\nThis adds some very simple trait method resolution, going through traits in scope, looking for methods of the given name, and checking very naively whether there's an impl for the given type and trait.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "c79204bca4912574614eafff8f9e18775d5aa963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c79204bca4912574614eafff8f9e18775d5aa963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc94f3612583c5e960b334761ad0c18d328840ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc94f3612583c5e960b334761ad0c18d328840ea", "html_url": "https://github.com/rust-lang/rust/commit/dc94f3612583c5e960b334761ad0c18d328840ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc94f3612583c5e960b334761ad0c18d328840ea/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bb77bc5c2f6c6b9681d9b3d0a068791db7eec0e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb77bc5c2f6c6b9681d9b3d0a068791db7eec0e2", "html_url": "https://github.com/rust-lang/rust/commit/bb77bc5c2f6c6b9681d9b3d0a068791db7eec0e2"}, {"sha": "99711c1863fc712dc14ca61809055b283415acbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/99711c1863fc712dc14ca61809055b283415acbe", "html_url": "https://github.com/rust-lang/rust/commit/99711c1863fc712dc14ca61809055b283415acbe"}], "stats": {"total": 242, "additions": 208, "deletions": 34}, "files": [{"sha": "88c13566c45002ea1e773c5f9e9c021260207587", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -17,6 +17,7 @@ use crate::{\n     impl_block::ImplBlock,\n     resolve::Resolver,\n     diagnostics::DiagnosticSink,\n+    traits::{TraitItem, TraitData},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -649,6 +650,18 @@ impl Trait {\n     pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n+\n+    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+        self.trait_data(db).name().clone()\n+    }\n+\n+    pub fn items(self, db: &impl DefDatabase) -> Vec<TraitItem> {\n+        self.trait_data(db).items().to_vec()\n+    }\n+\n+    pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n+        db.trait_data(self)\n+    }\n }\n \n impl Docs for Trait {"}, {"sha": "143919cdcf72ee0ca9738db0948909fbbc20c505", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     impl_block::{ModuleImplBlocks, ImplSourceMap},\n     generics::{GenericParams, GenericDef},\n     type_ref::TypeRef,\n+    traits::TraitData, Trait, ty::TraitRef\n };\n \n #[salsa::query_group(DefDatabaseStorage)]\n@@ -27,6 +28,9 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::adt::EnumData::enum_data_query)]\n     fn enum_data(&self, e: Enum) -> Arc<EnumData>;\n \n+    #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n+    fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n+\n     #[salsa::invoke(crate::ids::SourceFileItems::file_items_query)]\n     fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;\n \n@@ -98,6 +102,9 @@ pub trait HirDatabase: DefDatabase {\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n+\n+    #[salsa::invoke(crate::ty::method_resolution::implements)]\n+    fn implements(&self, trait_ref: TraitRef) -> bool;\n }\n \n #[test]"}, {"sha": "974ebd831308b0d718488ea77b50908f3cc31179", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -27,6 +27,7 @@ mod ids;\n mod name;\n mod nameres;\n mod adt;\n+mod traits;\n mod type_alias;\n mod type_ref;\n mod ty;"}, {"sha": "c34aa4b50c1e1f092c134e55bd8c3e15b04e1340", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -62,7 +62,7 @@ use test_utils::tested_by;\n \n use crate::{\n     ModuleDef, Name, Crate, Module,\n-    DefDatabase, Path, PathKind, HirFileId,\n+    DefDatabase, Path, PathKind, HirFileId, Trait,\n     ids::{SourceItemId, SourceFileItemId, MacroCallId},\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n@@ -139,6 +139,12 @@ impl ModuleScope {\n     pub fn get(&self, name: &Name) -> Option<&Resolution> {\n         self.items.get(name)\n     }\n+    pub fn traits<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n+        self.items.values().filter_map(|r| match r.def.take_types() {\n+            Some(ModuleDef::Trait(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Default)]"}, {"sha": "2609585b1f1e98607e30edaa4fdd3589e9ed4050", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId, Body},\n     impl_block::ImplBlock,\n-    path::Path,\n+    path::Path, Trait\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -175,6 +175,21 @@ impl Resolver {\n         names\n     }\n \n+    pub(crate) fn traits_in_scope<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n+        // FIXME prelude\n+        self.scopes\n+            .iter()\n+            .rev()\n+            .flat_map(|scope| {\n+                match scope {\n+                    Scope::ModuleScope(m) => Some(m.crate_def_map[m.module_id].scope.traits()),\n+                    _ => None,\n+                }\n+                .into_iter()\n+            })\n+            .flatten()\n+    }\n+\n     fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),"}, {"sha": "725bdd5cb3b3efc3311effe1be3f5993a5db359e", "filename": "crates/ra_hir/src/traits.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -0,0 +1,52 @@\n+//! HIR for trait definitions.\n+\n+use std::sync::Arc;\n+\n+use ra_syntax::ast::{self, NameOwner};\n+\n+use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationCtx, name::AsName};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    name: Option<Name>,\n+    items: Vec<TraitItem>,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase, tr: Trait) -> Arc<TraitData> {\n+        let (file_id, node) = tr.source(db);\n+        let name = node.name().map(|n| n.as_name());\n+        let module = tr.module(db);\n+        let ctx = LocationCtx::new(db, module, file_id);\n+        let items = if let Some(item_list) = node.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node.kind() {\n+                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(it) }.into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items })\n+    }\n+\n+    pub(crate) fn name(&self) -> &Option<Name> {\n+        &self.name\n+    }\n+\n+    pub(crate) fn items(&self) -> &[TraitItem] {\n+        &self.items\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum TraitItem {\n+    Function(Function),\n+    Const(Const),\n+    TypeAlias(TypeAlias),\n+    // Existential\n+}\n+impl_froms!(TraitItem: Function, Const, TypeAlias);"}, {"sha": "d42c61e9d345757bae3789428c88add9f6b84d79", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -14,7 +14,7 @@ pub(crate) mod display;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait};\n \n pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field, callable_item_sig};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n@@ -91,7 +91,7 @@ pub enum TypeCtor {\n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n /// type like `bool`, a struct, tuple, function pointer, reference or\n /// several other things.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ApplicationTy {\n     pub ctor: TypeCtor,\n     pub parameters: Substs,\n@@ -103,7 +103,7 @@ pub struct ApplicationTy {\n /// the same thing (but in a different way).\n ///\n /// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Ty {\n     /// A nominal type with (maybe 0) type parameters. This might be a primitive\n     /// type like `bool`, a struct, tuple, function pointer, reference or\n@@ -132,7 +132,7 @@ pub enum Ty {\n }\n \n /// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n \n impl Substs {\n@@ -169,6 +169,21 @@ impl Substs {\n     }\n }\n \n+/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n+/// Name to be bikeshedded: TraitBound? TraitImplements?\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    /// FIXME name?\n+    trait_: Trait,\n+    substs: Substs,\n+}\n+\n+impl TraitRef {\n+    pub fn self_ty(&self) -> &Ty {\n+        &self.substs.0[0]\n+    }\n+}\n+\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "5731153216a4f801108e742828bc786f0d26ee8e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -821,7 +821,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n-                let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n+                let resolved =\n+                    receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n                 let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n                     Some((ty, func)) => {\n                         self.write_method_resolution(tgt_expr, func);"}, {"sha": "3ac8dc46b0d747ebb5232f1a5cab6b2f3b9af88e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -8,12 +8,12 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     HirDatabase, Module, Crate, Name, Function, Trait,\n-    ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{Ty, TypeCtor},\n-    nameres::CrateModuleId,\n+    nameres::CrateModuleId, resolve::Resolver, traits::TraitItem\n \n };\n+use super::{ TraitRef, Substs};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -38,7 +38,7 @@ pub struct CrateImplBlocks {\n     /// To make sense of the CrateModuleIds, we need the source root.\n     krate: Crate,\n     impls: FxHashMap<TyFingerprint, Vec<(CrateModuleId, ImplId)>>,\n-    impls_by_trait: FxHashMap<TraitId, Vec<(CrateModuleId, ImplId)>>,\n+    impls_by_trait: FxHashMap<Trait, Vec<(CrateModuleId, ImplId)>>,\n }\n \n impl CrateImplBlocks {\n@@ -56,8 +56,7 @@ impl CrateImplBlocks {\n         &'a self,\n         tr: &Trait,\n     ) -> impl Iterator<Item = ImplBlock> + 'a {\n-        let id = tr.id;\n-        self.impls_by_trait.get(&id).into_iter().flat_map(|i| i.iter()).map(\n+        self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n                 let module = Module { krate: self.krate, module_id: *module_id };\n                 ImplBlock::from_id(module, *impl_id)\n@@ -73,18 +72,18 @@ impl CrateImplBlocks {\n \n             let target_ty = impl_block.target_ty(db);\n \n-            if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                self.impls\n-                    .entry(target_ty_fp)\n-                    .or_insert_with(Vec::new)\n-                    .push((module.module_id, impl_id));\n-            }\n-\n             if let Some(tr) = impl_block.target_trait(db) {\n                 self.impls_by_trait\n-                    .entry(tr.id)\n+                    .entry(tr)\n                     .or_insert_with(Vec::new)\n                     .push((module.module_id, impl_id));\n+            } else {\n+                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                    self.impls\n+                        .entry(target_ty_fp)\n+                        .or_insert_with(Vec::new)\n+                        .push((module.module_id, impl_id));\n+                }\n             }\n         }\n \n@@ -109,6 +108,20 @@ impl CrateImplBlocks {\n     }\n }\n \n+/// Rudimentary check whether an impl exists for a given type and trait; this\n+/// will actually be done by chalk.\n+pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n+    // FIXME use all trait impls in the whole crate graph\n+    let krate = trait_ref.trait_.module(db).krate(db);\n+    let krate = match krate {\n+        Some(krate) => krate,\n+        None => return false,\n+    };\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n+}\n+\n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -120,20 +133,64 @@ fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n }\n \n impl Ty {\n-    // FIXME: cache this as a query?\n-    // - if so, what signature? (TyFingerprint, Name)?\n-    // - or maybe cache all names and def_ids of methods per fingerprint?\n     /// Look up the method with the given name, returning the actual autoderefed\n     /// receiver type (but without autoref applied yet).\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<(Ty, Function)> {\n-        self.iterate_methods(db, |ty, f| {\n+    pub fn lookup_method(\n+        self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+        resolver: &Resolver,\n+    ) -> Option<(Ty, Function)> {\n+        // FIXME: trait methods should be used before autoderefs\n+        let inherent_method = self.clone().iterate_methods(db, |ty, f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n                 Some((ty.clone(), f))\n             } else {\n                 None\n             }\n-        })\n+        });\n+        inherent_method.or_else(|| self.lookup_trait_method(db, name, resolver))\n+    }\n+\n+    fn lookup_trait_method(\n+        self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+        resolver: &Resolver,\n+    ) -> Option<(Ty, Function)> {\n+        let mut candidates = Vec::new();\n+        for t in resolver.traits_in_scope() {\n+            let data = t.trait_data(db);\n+            for item in data.items() {\n+                match item {\n+                    &TraitItem::Function(m) => {\n+                        let sig = m.signature(db);\n+                        if sig.name() == name && sig.has_self_param() {\n+                            candidates.push((t, m));\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        // FIXME:\n+        //  - we might not actually be able to determine fully that the type\n+        //    implements the trait here; it's enough if we (well, Chalk) determine\n+        //    that it's possible.\n+        //  - when the trait method is picked, we need to register an\n+        //    'obligation' somewhere so that we later check that it's really\n+        //    implemented\n+        //  - both points go for additional requirements from where clauses as\n+        //    well (in fact, the 'implements' condition could just be considered a\n+        //    'where Self: Trait' clause)\n+        candidates.retain(|(t, _m)| {\n+            let trait_ref = TraitRef { trait_: *t, substs: Substs::single(self.clone()) };\n+            db.implements(trait_ref)\n+        });\n+        // FIXME if there's multiple candidates here, that's an ambiguity error\n+        let (_chosen_trait, chosen_method) = candidates.first()?;\n+        Some((self.clone(), *chosen_method))\n     }\n \n     // This would be nicer if it just returned an iterator, but that runs into"}, {"sha": "655f3c52237611b2897e2f0895fa1f80d90d8b3d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -1272,8 +1272,8 @@ fn test() {\n [241; 252) 'Struct::FOO': u32\n [262; 263) 'y': u32\n [266; 275) 'Enum::BAR': u32\n-[285; 286) 'z': u32\n-[289; 302) 'TraitTest::ID': u32\"###\n+[285; 286) 'z': {unknown}\n+[289; 302) 'TraitTest::ID': {unknown}\"###\n     );\n }\n \n@@ -1918,9 +1918,9 @@ fn test() {\n [110; 114) 'self': &{unknown}\n [170; 228) '{     ...i128 }': ()\n [176; 178) 'S1': S1\n-[176; 187) 'S1.method()': {unknown}\n+[176; 187) 'S1.method()': u32\n [203; 205) 'S2': S2\n-[203; 214) 'S2.method()': {unknown}\"###\n+[203; 214) 'S2.method()': i128\"###\n     );\n }\n \n@@ -1964,10 +1964,10 @@ mod bar_test {\n [169; 173) 'self': &{unknown}\n [300; 337) '{     ...     }': ()\n [310; 311) 'S': S\n-[310; 320) 'S.method()': {unknown}\n+[310; 320) 'S.method()': u32\n [416; 454) '{     ...     }': ()\n [426; 427) 'S': S\n-[426; 436) 'S.method()': {unknown}\"###\n+[426; 436) 'S.method()': i128\"###\n     );\n }\n "}, {"sha": "47a37e4d19c7475baac8bc99790cb5e79f5fe1a7", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -4061,7 +4061,11 @@ impl ast::NameOwner for TraitDef {}\n impl ast::AttrsOwner for TraitDef {}\n impl ast::DocCommentsOwner for TraitDef {}\n impl ast::TypeParamsOwner for TraitDef {}\n-impl TraitDef {}\n+impl TraitDef {\n+    pub fn item_list(&self) -> Option<&ItemList> {\n+        super::child_opt(self)\n+    }\n+}\n \n // TrueKw\n #[derive(Debug, PartialEq, Eq, Hash)]"}, {"sha": "ad6d74162b94b6f871896d96955d8f306162c2d5", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/dc94f3612583c5e960b334761ad0c18d328840ea/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=dc94f3612583c5e960b334761ad0c18d328840ea", "patch": "@@ -292,7 +292,10 @@ Grammar(\n         ], options: [[\"variant_list\", \"EnumVariantList\"]] ),\n         \"EnumVariantList\": ( collections: [[\"variants\", \"EnumVariant\"]] ),\n         \"EnumVariant\": ( traits: [\"NameOwner\", \"DocCommentsOwner\", \"AttrsOwner\"], options: [\"Expr\"] ),\n-        \"TraitDef\": ( traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\"] ),\n+        \"TraitDef\": (\n+            traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\"],\n+            options: [\"ItemList\"]\n+        ),\n         \"Module\": (\n             traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\" ],\n             options: [ \"ItemList\" ]"}]}