{"sha": "b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzM2U0ZTc4NGU5OTA2YzczMmRjYjNlMGI2ODcyZjY1ZGM4ZjU1OTc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-01-16T08:31:48Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:05Z"}, "message": "Fully use miri in trans", "tree": {"sha": "13e1196b1fb3c26f969d5f6e7e28003bf76e058e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13e1196b1fb3c26f969d5f6e7e28003bf76e058e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg528ACgkQpp+NIls6\n19kiBw/+Kj9BSaDGxb9Qi/tt7K+5cMlBJv8EZBPZPXk8KjrW5ilPL48DZphCvQdo\nUMVWvtV8gliP4jtrQJVssQJj/yPCsN09nlv3egZqdV+f0sYNjJlO+y02Y9XlHTkw\n8jAIxRKO7wI1Qki4AN1nsWe3M395vXTQcVPGNWN1Tv+Pd+o8kTnGysFZ130FG5Xk\nsxgkUaQO5JkbRao84jh8Pn8S97rjexywbG1HoxJhKo6n/c5LCO1YSMIpMTn4hMli\n++P4a0g83zqU0PbPjmzS7dTFqlaI3txFewRdY+DO2OT5ADkqxpv483mTzkwHQrdB\nt8GGZAtWcVqDfmIIa3LR5LiHtqr1GmxPh5IpDBIggUnFXTJi1WemhMmWZYFz6MgA\nmJw+mdZQqLR6zrg45SlgE0EMv/6d5xXnr+N1P5kHHgai05d/lZruE087Njecxipr\nfs8RRm4HwvvtqPTTkNUOrOLy/TZroBjjH5xmJTYdzMPygqI2NNIoMiZyLB6jGSO4\nwKea4yc0w0jon7lvWapeHLNqgEtW/uN6LlNCcPLLAGcYEQKlkZvyBr87nXY+02OQ\nSP4EtHvvnVuO/m3KAI6KMnjTfCU5RcHzWSqs84rumzj5BxKddhMUqzwKtAmBKxO2\noA3CdbgD1Wz3VoWrP/C/bZrZFVaLX7ga/bZ4FOaSZDvC0M/zY90=\n=ZXL+\n-----END PGP SIGNATURE-----", "payload": "tree 13e1196b1fb3c26f969d5f6e7e28003bf76e058e\nparent b2b101befcfe1ca4ea57862675df0de5ca7b15bd\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1516091508 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494445 +0100\n\nFully use miri in trans\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "html_url": "https://github.com/rust-lang/rust/commit/b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2b101befcfe1ca4ea57862675df0de5ca7b15bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b101befcfe1ca4ea57862675df0de5ca7b15bd", "html_url": "https://github.com/rust-lang/rust/commit/b2b101befcfe1ca4ea57862675df0de5ca7b15bd"}], "stats": {"total": 4115, "additions": 1932, "deletions": 2183}, "files": [{"sha": "35c51c0c206b0a1db24a6458ae126f8bb19eeaf4", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -15,9 +15,9 @@ use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n use rustc_const_math::*;\n use mir::interpret::{Value, PrimVal};\n+use errors::DiagnosticBuilder;\n \n use graphviz::IntoCow;\n-use errors::DiagnosticBuilder;\n use serialize;\n use syntax_pos::Span;\n \n@@ -169,6 +169,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n \n             TypeckError => simple!(\"type-checking failed\"),\n             CheckMatchError => simple!(\"match-checking failed\"),\n+            // FIXME: report a full backtrace\n             Miri(ref err) => simple!(\"miri failed: {}\", err),\n         }\n     }\n@@ -186,7 +187,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n             err = i_err;\n         }\n \n-        let mut diag = struct_span_err!(tcx.sess, err.span, E0080, \"constant evaluation error\");\n+        let mut diag = struct_error(tcx, err.span, \"constant evaluation error\");\n         err.note(tcx, primary_span, primary_kind, &mut diag);\n         diag\n     }\n@@ -221,3 +222,11 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         self.struct_error(tcx, primary_span, primary_kind).emit();\n     }\n }\n+\n+pub fn struct_error<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    span: Span,\n+    msg: &str,\n+) -> DiagnosticBuilder<'gcx> {\n+    struct_span_err!(tcx.sess, span, E0080, \"{}\", msg)\n+}"}, {"sha": "977e617968aa4208c47e8759d8c0ed377d4c64ca", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -286,8 +286,8 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n             DeallocatedWrongMemoryKind(ref old, ref new) =>\n                 write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n-            Math(span, ref err) =>\n-                write!(f, \"{:?} at {:?}\", err, span),\n+            Math(_, ref err) =>\n+                write!(f, \"{}\", err.description()),\n             Intrinsic(ref err) =>\n                 write!(f, \"{}\", err),\n             InvalidChar(c) =>"}, {"sha": "394b3d96a4fb6d69c3bf561e75a2ca19b770165e", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -169,6 +169,8 @@ pub struct Allocation {\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n+    /// Whether the allocation should be put into mutable memory when translating via llvm\n+    pub mutable: bool,\n }\n \n impl Allocation {\n@@ -180,6 +182,7 @@ impl Allocation {\n             relocations: BTreeMap::new(),\n             undef_mask,\n             align: Align::from_bytes(1, 1).unwrap(),\n+            mutable: false,\n         }\n     }\n }"}, {"sha": "9e9ba516203385379c9a7e465195714e62c01c83", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -1898,13 +1898,16 @@ fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n                 let alloc = tcx\n                     .interpret_interner\n                     .borrow()\n-                    .get_alloc(ptr.alloc_id)\n-                    .expect(\"miri alloc not found\");\n-                assert_eq!(len as usize as u128, len);\n-                let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n-                let s = ::std::str::from_utf8(slice)\n-                    .expect(\"non utf8 str from miri\");\n-                write!(f, \"{:?}\", s)\n+                    .get_alloc(ptr.alloc_id);\n+                if let Some(alloc) = alloc {\n+                    assert_eq!(len as usize as u128, len);\n+                    let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n+                    let s = ::std::str::from_utf8(slice)\n+                        .expect(\"non utf8 str from miri\");\n+                    write!(f, \"{:?}\", s)\n+                } else {\n+                    write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n+                }\n             })\n         },\n         _ => write!(f, \"{:?}:{}\", value, ty),"}, {"sha": "2e554aff13ee3f1b38ddf6c028fb0ef241c0597f", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -32,7 +32,6 @@ use hir;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n-use middle::const_val;\n use std::fmt;\n use syntax::ast;\n use session::DiagnosticMessageId;\n@@ -776,7 +775,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             ConstEvalFailure(ref err) => {\n-                if let const_val::ErrKind::TypeckError = err.kind {\n+                if let ::middle::const_val::ErrKind::TypeckError = err.kind {\n                     return;\n                 }\n                 err.struct_error(self.tcx, span, \"constant expression\")"}, {"sha": "5c082b0610fe15cb16ae729786bb4d7b470b0cae", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -9,15 +9,14 @@\n // except according to those terms.\n \n use infer::{RegionObligation, InferCtxt};\n-use middle::const_val::ConstEvalErr;\n-use middle::const_val::ErrKind::TypeckError;\n use mir::interpret::GlobalId;\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n use hir::def_id::DefId;\n+use middle::const_val::{ConstEvalErr, ErrKind};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -532,12 +531,12 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                                 match selcx.tcx().at(obligation.cause.span)\n                                                  .const_eval(param_env.and(cid)) {\n                                     Ok(_) => Ok(Some(vec![])),\n-                                    Err(e) => Err(CodeSelectionError(ConstEvalFailure(e)))\n+                                    Err(err) => Err(CodeSelectionError(ConstEvalFailure(err)))\n                                 }\n                             } else {\n                                 Err(CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n-                                    span: selcx.tcx().def_span(def_id),\n-                                    kind: TypeckError,\n+                                    span: obligation.cause.span,\n+                                    kind: ErrKind::UnimplementedConstVal(\"could not resolve\"),\n                                 })))\n                             }\n                         },"}, {"sha": "e0e85600b9036c353f1fda479fb98f33e8fddfc4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -20,8 +20,8 @@ pub use self::ObligationCauseCode::*;\n use hir;\n use hir::def_id::DefId;\n use infer::outlives::env::OutlivesEnvironment;\n-use middle::const_val::ConstEvalErr;\n use middle::region;\n+use middle::const_val::ConstEvalErr;\n use ty::subst::Substs;\n use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};"}, {"sha": "bf75afcfa1a9f94b320b0d78cc5a952218766456", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -907,16 +907,17 @@ pub struct InterpretInterner<'tcx> {\n     alloc_by_id: FxHashMap<interpret::AllocId, &'tcx interpret::Allocation>,\n \n     /// Reverse map of `alloc_cache`\n-    ///\n-    /// Multiple globals may share the same memory\n-    global_cache: FxHashMap<interpret::AllocId, Vec<interpret::GlobalId<'tcx>>>,\n+    global_cache: FxHashMap<interpret::AllocId, DefId>,\n \n     /// The AllocId to assign to the next new regular allocation.\n     /// Always incremented, never gets smaller.\n     next_id: interpret::AllocId,\n \n-    /// Allows checking whether a constant already has an allocation\n-    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::AllocId>,\n+    /// Allows checking whether a static already has an allocation\n+    ///\n+    /// This is only important for detecting statics referring to themselves\n+    // FIXME(oli-obk) move it to the EvalContext?\n+    alloc_cache: FxHashMap<DefId, interpret::AllocId>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n@@ -951,30 +952,27 @@ impl<'tcx> InterpretInterner<'tcx> {\n \n     pub fn get_cached(\n         &self,\n-        global_id: interpret::GlobalId<'tcx>,\n+        static_id: DefId,\n     ) -> Option<interpret::AllocId> {\n-        self.alloc_cache.get(&global_id).cloned()\n+        self.alloc_cache.get(&static_id).cloned()\n     }\n \n     pub fn cache(\n         &mut self,\n-        global_id: interpret::GlobalId<'tcx>,\n+        static_id: DefId,\n         alloc_id: interpret::AllocId,\n     ) {\n-        self.global_cache.entry(alloc_id).or_default().push(global_id);\n-        if let Some(old) = self.alloc_cache.insert(global_id, alloc_id) {\n-            bug!(\"tried to cache {:?}, but was already existing as {:#?}\", global_id, old);\n+        self.global_cache.insert(alloc_id, static_id);\n+        if let Some(old) = self.alloc_cache.insert(static_id, alloc_id) {\n+            bug!(\"tried to cache {:?}, but was already existing as {:#?}\", static_id, old);\n         }\n     }\n \n-    pub fn get_globals(\n+    pub fn get_corresponding_static_def_id(\n         &self,\n         ptr: interpret::AllocId,\n-    ) -> &[interpret::GlobalId<'tcx>] {\n-        match self.global_cache.get(&ptr) {\n-            Some(v) => v,\n-            None => &[],\n-        }\n+    ) -> Option<DefId> {\n+        self.global_cache.get(&ptr).cloned()\n     }\n \n     pub fn intern_at_reserved("}, {"sha": "0ded759fec730c55d86e0ca87de6e24e694d5076", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -16,7 +16,6 @@ use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n use lint;\n use middle::borrowck::BorrowCheckResult;\n-use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n                      ExternBodyNestedBodies};\n use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n@@ -27,6 +26,7 @@ use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n+use middle::const_val::EvalResult;\n use mir::mono::{CodegenUnit, Stats};\n use mir;\n use mir::interpret::{GlobalId};\n@@ -212,7 +212,7 @@ define_maps! { <'tcx>\n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n     [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-        -> const_val::EvalResult<'tcx>,\n+        -> EvalResult<'tcx>,\n \n     [] fn check_match: CheckMatch(DefId)\n         -> Result<(), ErrorReported>,"}, {"sha": "f9071cff78f493fcf84c563e70de2b65f15d891e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -1854,11 +1854,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                                 b, uint_type, tcx.sess.target.usize_ty).unwrap(),\n                         };\n                     }\n-                    err => {\n+                    _ => {\n                         if !expr_did.is_local() {\n                             span_bug!(tcx.def_span(expr_did),\n                                 \"variant discriminant evaluation succeeded \\\n-                                 in its crate but failed locally: {:?}\", err);\n+                                 in its crate but failed locally\");\n                         }\n                     }\n                 }\n@@ -1910,11 +1910,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                             };\n                             break;\n                         }\n-                        err => {\n+                        _ => {\n                             if !expr_did.is_local() {\n                                 span_bug!(tcx.def_span(expr_did),\n                                     \"variant discriminant evaluation succeeded \\\n-                                     in its crate but failed locally: {:?}\", err);\n+                                     in its crate but failed locally\");\n                             }\n                             if explicit_index == 0 {\n                                 break;"}, {"sha": "cdf619a1dfad067c5a5808bc8b50695e4cb3e088", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -691,22 +691,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Check if the node pointed to by def_id is a mutable static item\n-    pub fn is_static_mut(&self, def_id: DefId) -> bool {\n+    /// Return whether the node pointed to by def_id is a static item, and its mutability\n+    pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n         if let Some(node) = self.hir.get_if_local(def_id) {\n             match node {\n                 Node::NodeItem(&hir::Item {\n-                    node: hir::ItemStatic(_, hir::MutMutable, _), ..\n-                }) => true,\n+                    node: hir::ItemStatic(_, mutbl, _), ..\n+                }) => Some(mutbl),\n                 Node::NodeForeignItem(&hir::ForeignItem {\n-                    node: hir::ForeignItemStatic(_, mutbl), ..\n-                }) => mutbl,\n-                _ => false\n+                    node: hir::ForeignItemStatic(_, is_mutbl), ..\n+                }) =>\n+                    Some(if is_mutbl {\n+                        hir::Mutability::MutMutable\n+                    } else {\n+                        hir::Mutability::MutImmutable\n+                    }),\n+                _ => None\n             }\n         } else {\n             match self.describe_def(def_id) {\n-                Some(Def::Static(_, mutbl)) => mutbl,\n-                _ => false\n+                Some(Def::Static(_, is_mutbl)) =>\n+                    Some(if is_mutbl {\n+                        hir::Mutability::MutMutable\n+                    } else {\n+                        hir::Mutability::MutImmutable\n+                    }),\n+                _ => None\n             }\n         }\n     }"}, {"sha": "0ec5700f5f32a44ae88f01011e80c67d24811ec1", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -664,6 +664,16 @@ extern \"C\" {\n     pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n     pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n     pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n+    pub fn LLVMConstGEP(\n+        ConstantVal: ValueRef,\n+        ConstantIndices: *const ValueRef,\n+        NumIndices: c_uint,\n+    ) -> ValueRef;\n+    pub fn LLVMConstInBoundsGEP(\n+        ConstantVal: ValueRef,\n+        ConstantIndices: *const ValueRef,\n+        NumIndices: c_uint,\n+    ) -> ValueRef;\n     pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n     pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;"}, {"sha": "14984e8a6d758fa07e2b429f896d4311ee2fc019", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -298,9 +298,7 @@ impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx\n                 let allocation = self.tcx.unwrap().intern_const_alloc(allocation);\n                 interpret_interner().intern_at_reserved(alloc_id, allocation);\n \n-                let num = usize::decode(self)?;\n-                for _ in 0..num {\n-                    let glob = interpret::GlobalId::decode(self)?;\n+                if let Some(glob) = Option::<DefId>::decode(self)? {\n                     interpret_interner().cache(glob, alloc_id);\n                 }\n "}, {"sha": "71be3f2875928bd929a9c63d5da018c9a278a60e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -210,11 +210,9 @@ impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             usize::max_value().encode(self)?;\n             alloc.encode(self)?;\n-            let globals = interpret_interner.get_globals(*alloc_id);\n-            globals.len().encode(self)?;\n-            for glob in globals {\n-                glob.encode(self)?;\n-            }\n+            interpret_interner\n+                .get_corresponding_static_def_id(*alloc_id)\n+                .encode(self)?;\n         } else if let Some(fn_instance) = interpret_interner.get_fn(*alloc_id) {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n             (usize::max_value() - 1).encode(self)?;"}, {"sha": "028fc337967fa1aa55db33181317b84e91726e03", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -1635,11 +1635,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Mutability::Mut => Ok(()),\n                 }\n             }\n-            Place::Static(ref static_) => if !self.tcx.is_static_mut(static_.def_id) {\n-                Err(place)\n-            } else {\n-                Ok(())\n-            },\n+            Place::Static(ref static_) =>\n+                if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+                    Err(place)\n+                } else {\n+                    Ok(())\n+                },\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n@@ -1792,7 +1793,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if static1.def_id != static2.def_id {\n                     debug!(\"place_element_conflict: DISJOINT-STATIC\");\n                     Overlap::Disjoint\n-                } else if self.tcx.is_static_mut(static1.def_id) {\n+                } else if self.tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n                     // We ignore mutable statics - they can only be unsafe code.\n                     debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n                     Overlap::Disjoint"}, {"sha": "9827dd58cd640417974d0c295ac48b0d3ac9493e", "filename": "src/librustc_mir/const_eval/check.rs", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fcheck.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -11,47 +11,77 @@\n //! Lints statically known runtime failures\n \n use rustc::mir::*;\n+use rustc::hir;\n+use rustc::hir::map::Node;\n use rustc::mir::visit::Visitor;\n use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n use rustc::middle::const_val::{ConstVal, ConstEvalErr, ErrKind};\n+use rustc::hir::def::Def;\n use rustc::traits;\n-use interpret::{eval_body_as_integer, check_body};\n-use rustc::ty::{TyCtxt, ParamEnv, self};\n+use interpret::eval_body_with_mir;\n+use rustc::ty::{TyCtxt, ParamEnv};\n use rustc::ty::Instance;\n use rustc::ty::layout::LayoutOf;\n use rustc::hir::def_id::DefId;\n+use rustc::ty::subst::Substs;\n+\n+fn is_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    if let Some(node) = tcx.hir.get_if_local(def_id) {\n+        match node {\n+            Node::NodeItem(&hir::Item {\n+                node: hir::ItemConst(..), ..\n+            }) => true,\n+            _ => false\n+        }\n+    } else {\n+        match tcx.describe_def(def_id) {\n+            Some(Def::Const(_)) => true,\n+            _ => false\n+        }\n+    }\n+}\n \n pub fn check<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    if tcx.is_closure(def_id) {\n-        return;\n+    let mir = &tcx.optimized_mir(def_id);\n+    let substs = Substs::identity_for_item(tcx, def_id);\n+    let instance = Instance::new(def_id, substs);\n+    let param_env = tcx.param_env(def_id);\n+\n+    if is_const(tcx, def_id) {\n+        let cid = GlobalId {\n+            instance,\n+            promoted: None,\n+        };\n+        eval_body_with_mir(tcx, cid, mir, param_env);\n     }\n-    let generics = tcx.generics_of(def_id);\n+\n+    ConstErrVisitor {\n+        tcx,\n+        mir,\n+    }.visit_mir(mir);\n+    let outer_def_id = if tcx.is_closure(def_id) {\n+        tcx.closure_base_def_id(def_id)\n+    } else {\n+        def_id\n+    };\n+    let generics = tcx.generics_of(outer_def_id);\n     // FIXME: miri should be able to eval stuff that doesn't need info\n     // from the generics\n     if generics.parent_types as usize + generics.types.len() > 0 {\n         return;\n     }\n-    let mir = &tcx.optimized_mir(def_id);\n-    ConstErrVisitor {\n-        tcx,\n-        def_id,\n-        mir,\n-    }.visit_mir(mir);\n-    let param_env = ParamEnv::empty(traits::Reveal::All);\n-    let instance = Instance::mono(tcx, def_id);\n     for i in 0.. mir.promoted.len() {\n         use rustc_data_structures::indexed_vec::Idx;\n         let cid = GlobalId {\n             instance,\n             promoted: Some(Promoted::new(i)),\n         };\n-        check_body(tcx, cid, param_env);\n+        eval_body_with_mir(tcx, cid, mir, param_env);\n     }\n }\n \n struct ConstErrVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n     mir: &'a Mir<'tcx>,\n }\n \n@@ -61,22 +91,13 @@ impl<'a, 'tcx> ConstErrVisitor<'a, 'tcx> {\n             Operand::Constant(ref c) => c,\n             _ => return None,\n         };\n-        let param_env = ParamEnv::empty(traits::Reveal::All);\n-        let val = match op.literal {\n+        match op.literal {\n             Literal::Value { value } => match value.val {\n-                ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => b,\n+                ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => Some(b),\n                 _ => return None,\n             },\n-            Literal::Promoted { index } => {\n-                let instance = Instance::mono(self.tcx, self.def_id);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(index),\n-                };\n-                eval_body_as_integer(self.tcx, cid, param_env).unwrap()\n-            }\n-        };\n-        Some(val)\n+            _ => None,\n+        }\n     }\n }\n \n@@ -87,13 +108,14 @@ impl<'a, 'tcx> Visitor<'tcx> for ConstErrVisitor<'a, 'tcx> {\n                         location: Location) {\n         self.super_terminator(block, terminator, location);\n         match terminator.kind {\n-            TerminatorKind::Assert { cond: Operand::Constant(box Constant {\n-                literal: Literal::Value {\n-                    value: &ty::Const {\n-                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(cond))),\n-                    .. }\n-                }, ..\n-            }), expected, ref msg, .. } if (cond == 1) != expected => {\n+            TerminatorKind::Assert { ref cond, expected, ref msg, .. } => {\n+                let cond = match self.eval_op(cond) {\n+                    Some(val) => val,\n+                    None => return,\n+                };\n+                if (cond == 1) == expected {\n+                    return;\n+                }\n                 assert!(cond <= 1);\n                 // If we know we always panic, and the error message\n                 // is also constant, then we can produce a warning."}, {"sha": "9fbf55396984a6e17e47e5f56218396e7771b81a", "filename": "src/librustc_mir/const_eval/check_match.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fcheck_match.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -138,8 +138,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternError::AssociatedConstInPattern(span) => {\n                     self.span_e0158(span, \"associated consts cannot be referenced in patterns\")\n                 }\n-                PatternError::ConstEval(ref err) => {\n-                    err.report(self.tcx, pat_span, \"pattern\");\n+                PatternError::FloatBug => {\n+                    // FIXME(#31407) this is only necessary because float parsing is buggy\n+                    ::rustc::middle::const_val::struct_error(\n+                        self.tcx, pat_span,\n+                        \"could not evaluate float literal (see issue #31407)\",\n+                    ).emit();\n+                }\n+                PatternError::NonConstPath(span) => {\n+                    ::rustc::middle::const_val::struct_error(\n+                        self.tcx, span,\n+                        \"runtime values cannot be referenced in patterns\",\n+                    ).emit();\n                 }\n             }\n         }"}, {"sha": "25a9e52236773aa02247f9e716330806b95be08b", "filename": "src/librustc_mir/const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use rustc::middle::const_val::ConstVal::*;\n-use rustc::middle::const_val::ErrKind::*;\n-use rustc::middle::const_val::{ConstVal, ErrKind};\n+use rustc::middle::const_val::ConstVal;\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -39,7 +38,7 @@ pub fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           neg: bool)\n-                          -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n+                          -> Result<ConstVal<'tcx>, ()> {\n     use syntax::ast::*;\n \n     use rustc::mir::interpret::*;\n@@ -126,11 +125,8 @@ pub fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n }\n \n fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n-                     -> Result<ConstFloat, ErrKind<'tcx>> {\n-    ConstFloat::from_str(num, fty).map_err(|_| {\n-        // FIXME(#31407) this is only necessary because float parsing is buggy\n-        UnimplementedConstVal(\"could not evaluate float literal (see issue #31407)\")\n-    })\n+                     -> Result<ConstFloat, ()> {\n+    ConstFloat::from_str(num, fty).map_err(|_| ())\n }\n \n pub fn compare_const_vals(a: &ConstVal, b: &ConstVal, ty: Ty) -> Option<Ordering> {"}, {"sha": "4ecf0d6e638e7bf46bb6c39e7fa44a07401cbd14", "filename": "src/librustc_mir/const_eval/pattern.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -10,7 +10,7 @@\n \n use interpret::{const_val_field, const_discr};\n \n-use rustc::middle::const_val::{ConstEvalErr, ErrKind, ConstVal};\n+use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n@@ -28,10 +28,11 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n-pub enum PatternError<'tcx> {\n+pub enum PatternError {\n     AssociatedConstInPattern(Span),\n     StaticInPattern(Span),\n-    ConstEval(ConstEvalErr<'tcx>),\n+    FloatBug,\n+    NonConstPath(Span),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -279,7 +280,7 @@ pub struct PatternContext<'a, 'tcx: 'a> {\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     pub substs: &'tcx Substs<'tcx>,\n-    pub errors: Vec<PatternError<'tcx>>,\n+    pub errors: Vec<PatternError>,\n }\n \n impl<'a, 'tcx> Pattern<'tcx> {\n@@ -650,10 +651,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             _ => {\n-                self.errors.push(PatternError::ConstEval(ConstEvalErr {\n-                    span,\n-                    kind: ErrKind::NonConstPath,\n-                }));\n+                self.errors.push(PatternError::NonConstPath(span));\n                 PatternKind::Wild\n             }\n         }\n@@ -673,24 +671,35 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let substs = self.tables.node_substs(id);\n-                let instance = ty::Instance::resolve(\n+                match ty::Instance::resolve(\n                     self.tcx,\n                     self.param_env,\n                     def_id,\n                     substs,\n-                ).unwrap();\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: None,\n-                };\n-                match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n-                    Ok(value) => {\n-                        return self.const_to_pat(instance, value, id, span)\n+                ) {\n+                    Some(instance) => {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n+                        match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n+                            Ok(value) => {\n+                                return self.const_to_pat(instance, value, id, span)\n+                            },\n+                            Err(err) => {\n+                                err.report(self.tcx, span, \"pattern\");\n+                                PatternKind::Wild\n+                            },\n+                        }\n                     },\n-                    Err(e) => {\n-                        self.errors.push(PatternError::ConstEval(e));\n+                    None => {\n+                        self.errors.push(if is_associated_const {\n+                            PatternError::AssociatedConstInPattern(span)\n+                        } else {\n+                            PatternError::StaticInPattern(span)\n+                        });\n                         PatternKind::Wild\n-                    }\n+                    },\n                 }\n             }\n             _ => self.lower_variant_or_leaf(def, span, ty, vec![]),\n@@ -716,11 +725,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         let cv = self.tcx.mk_const(ty::Const { val, ty });\n                         *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n                     },\n-                    Err(e) => {\n-                        self.errors.push(PatternError::ConstEval(ConstEvalErr {\n-                            span: lit.span,\n-                            kind: e,\n-                        }));\n+                    Err(()) => {\n+                        self.errors.push(PatternError::FloatBug);\n                         PatternKind::Wild\n                     },\n                 }\n@@ -733,17 +739,16 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n                 };\n                 match super::eval::lit_to_const(&lit.node, self.tcx, ty, true) {\n-                    Ok(value) => PatternKind::Constant {\n-                        value: self.tcx.mk_const(ty::Const {\n-                            ty,\n-                            val: value,\n-                        }),\n+                    Ok(val) => {\n+                        let instance = ty::Instance::new(\n+                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n+                            self.substs,\n+                        );\n+                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n+                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n                     },\n-                    Err(e) => {\n-                        self.errors.push(PatternError::ConstEval(ConstEvalErr {\n-                            span: lit.span,\n-                            kind: e,\n-                        }));\n+                    Err(()) => {\n+                        self.errors.push(PatternError::FloatBug);\n                         PatternKind::Wild\n                     },\n                 }"}, {"sha": "a150335a1ae4d7b4107751b5501c569a223fb853", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -783,7 +783,7 @@ fn is_unsafe_place<'a, 'gcx: 'tcx, 'tcx: 'a>(\n \n     match *place {\n         Local(_) => false,\n-        Static(ref static_) => tcx.is_static_mut(static_.def_id),\n+        Static(ref static_) => tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable),\n         Projection(ref proj) => {\n             match proj.elem {\n                 ProjectionElem::Field(..) |"}, {"sha": "db44d870acb019f088138eb29221e35ec8bf510b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -524,7 +524,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and(global_id)) {\n                 Ok(cv) => cv.val.unwrap_usize(cx.tcx),\n-                Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n+                Err(e) => {\n+                    e.report(cx.tcx, cx.tcx.def_span(def_id), \"array length\");\n+                    ConstUsize::new(0, cx.tcx.sess.target.usize_ty).unwrap()\n+                },\n             };\n \n             ExprKind::Repeat {"}, {"sha": "24bf9445d45c02916a3b014816c57a7d6130d553", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -16,7 +16,7 @@\n \n use hair::*;\n \n-use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n+use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -238,17 +238,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                           p)\n     }\n \n-    pub fn fatal_const_eval_err(&mut self,\n-        err: &ConstEvalErr<'tcx>,\n-        primary_span: Span,\n-        primary_kind: &str)\n-        -> !\n-    {\n-        err.report(self.tcx, primary_span, primary_kind);\n-        self.tcx.sess.abort_if_errors();\n-        unreachable!()\n-    }\n-\n     pub fn trait_method(&mut self,\n                         trait_def_id: DefId,\n                         method_name: &str,"}, {"sha": "7d7e6ec9451ed8c288753cafbb03f97721325c77", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmeti\n use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::Float;\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub(super) fn cast_primval(\n         &self,\n         val: PrimVal,"}, {"sha": "2e2246f9ab927c066a92ef1bfa7131b5c326d1e5", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 137, "deletions": 71, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n-use rustc::middle::const_val::ErrKind::{CheckMatchError, TypeckError};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n+use rustc::middle::const_val::ErrKind::{TypeckError, CheckMatchError};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -9,17 +9,37 @@ use rustc::ty::subst::Subst;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal};\n-use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra};\n+use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal, AllocId};\n+use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory};\n \n use std::fmt;\n use std::error::Error;\n \n+pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    mir: &'mir mir::Mir<'tcx>,\n+) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>> {\n+    debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n+    let param_env = tcx.param_env(instance.def_id());\n+    let limits = super::ResourceLimits::default();\n+    let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n+    // insert a stack frame so any queries have the correct substs\n+    ecx.push_stack_frame(\n+        instance,\n+        mir.span,\n+        mir,\n+        Place::undef(),\n+        StackPopCleanup::None,\n+    )?;\n+    Ok(ecx)\n+}\n+\n pub fn mk_eval_cx<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, EvalContext<'a, 'tcx, CompileTimeEvaluator>> {\n+) -> EvalResult<'tcx, EvalContext<'a, 'tcx, 'tcx, CompileTimeEvaluator>> {\n     debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n     let limits = super::ResourceLimits::default();\n     let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n@@ -35,64 +55,95 @@ pub fn mk_eval_cx<'a, 'tcx>(\n     Ok(ecx)\n }\n \n-pub fn eval_body<'a, 'tcx>(\n+pub fn eval_body_with_mir<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n+    mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)> {\n-    eval_body_and_ecx(tcx, cid, param_env).0\n+) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+    let (res, ecx) = eval_body_and_ecx(tcx, cid, Some(mir), param_env);\n+    match res {\n+        Ok(val) => Some(val),\n+        Err(mut err) => {\n+            ecx.report(&mut err, true);\n+            None\n+        }\n+    }\n }\n \n-pub fn check_body<'a, 'tcx>(\n+pub fn eval_body<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) {\n-    let (res, ecx) = eval_body_and_ecx(tcx, cid, param_env);\n-    if let Err(mut err) = res {\n-        ecx.report(&mut err);\n+) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+    let (res, ecx) = eval_body_and_ecx(tcx, cid, None, param_env);\n+    match res {\n+        Ok(val) => Some(val),\n+        Err(mut err) => {\n+            ecx.report(&mut err, true);\n+            None\n+        }\n     }\n }\n \n-fn eval_body_and_ecx<'a, 'tcx>(\n+fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n+    mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)>, EvalContext<'a, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     let limits = super::ResourceLimits::default();\n     let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n     let res = (|| {\n-        let mut mir = ecx.load_mir(cid.instance.def)?;\n+        let mut mir = match mir {\n+            Some(mir) => mir,\n+            None => ecx.load_mir(cid.instance.def)?,\n+        };\n         if let Some(index) = cid.promoted {\n             mir = &mir.promoted[index];\n         }\n         let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n-        if ecx.tcx.has_attr(cid.instance.def_id(), \"linkage\") {\n-            return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n-        }\n-        if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n-            assert!(!layout.is_unsized());\n-            let ptr = ecx.memory.allocate(\n-                layout.size.bytes(),\n-                layout.align,\n-                None,\n-            )?;\n-            tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n-            let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n-            let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n-            trace!(\"const_eval: pushing stack frame for global: {}\", name);\n-            ecx.push_stack_frame(\n-                cid.instance,\n-                mir.span,\n-                mir,\n-                Place::from_ptr(ptr, layout.align),\n-                cleanup.clone(),\n-            )?;\n-\n-            while ecx.step()? {}\n-        }\n-        let alloc = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n+        let alloc = tcx.interpret_interner.borrow().get_cached(cid.instance.def_id());\n+        let alloc = match alloc {\n+            Some(alloc) => {\n+                assert!(cid.promoted.is_none());\n+                assert!(param_env.caller_bounds.is_empty());\n+                alloc\n+            },\n+            None => {\n+                assert!(!layout.is_unsized());\n+                let ptr = ecx.memory.allocate(\n+                    layout.size.bytes(),\n+                    layout.align,\n+                    None,\n+                )?;\n+                if tcx.is_static(cid.instance.def_id()).is_some() {\n+                    tcx.interpret_interner.borrow_mut().cache(cid.instance.def_id(), ptr.alloc_id);\n+                }\n+                let span = tcx.def_span(cid.instance.def_id());\n+                let internally_mutable = !layout.ty.is_freeze(tcx, param_env, span);\n+                let mutability = tcx.is_static(cid.instance.def_id());\n+                let mutability = if mutability == Some(hir::Mutability::MutMutable) || internally_mutable {\n+                    Mutability::Mutable\n+                } else {\n+                    Mutability::Immutable\n+                };\n+                let cleanup = StackPopCleanup::MarkStatic(mutability);\n+                let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n+                trace!(\"const_eval: pushing stack frame for global: {}\", name);\n+                ecx.push_stack_frame(\n+                    cid.instance,\n+                    mir.span,\n+                    mir,\n+                    Place::from_ptr(ptr, layout.align),\n+                    cleanup,\n+                )?;\n+\n+                while ecx.step()? {}\n+                ptr.alloc_id\n+            }\n+        };\n         let ptr = MemoryPointer::new(alloc, 0).into();\n         let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n             Some(val) => val,\n@@ -103,18 +154,6 @@ fn eval_body_and_ecx<'a, 'tcx>(\n     (res, ecx)\n }\n \n-pub fn eval_body_as_integer<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cid: GlobalId<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, u128> {\n-    let (value, _, ty) = eval_body(tcx, cid, param_env)?;\n-    match value {\n-        Value::ByVal(prim) => prim.to_bytes(),\n-        _ => err!(TypeNotPrimitive(ty)),\n-    }\n-}\n-\n pub struct CompileTimeEvaluator;\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n@@ -159,11 +198,11 @@ impl Error for ConstEvalError {\n     }\n }\n \n-impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n+impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     type MemoryData = ();\n     type MemoryKinds = !;\n     fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Place, mir::BasicBlock)>,\n         _args: &[ValTy<'tcx>],\n@@ -204,7 +243,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n \n \n     fn call_intrinsic<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         _args: &[ValTy<'tcx>],\n         dest: Place,\n@@ -246,7 +285,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n     }\n \n     fn try_ptr_op<'a>(\n-        _ecx: &EvalContext<'a, 'tcx, Self>,\n+        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         left: PrimVal,\n         _left_ty: Ty<'tcx>,\n@@ -262,12 +301,16 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n         }\n     }\n \n-    fn mark_static_initialized(m: !) -> EvalResult<'tcx> {\n-        m\n+    fn mark_static_initialized<'a>(\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        _id: AllocId,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx, bool> {\n+        Ok(false)\n     }\n \n     fn box_alloc<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _ty: Ty<'tcx>,\n         _dest: Place,\n     ) -> EvalResult<'tcx> {\n@@ -277,7 +320,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n     }\n \n     fn global_item_with_linkage<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n@@ -374,14 +417,34 @@ pub fn const_eval_provider<'a, 'tcx>(\n     let def_id = cid.instance.def.def_id();\n     let span = tcx.def_span(def_id);\n \n+    if tcx.is_foreign_item(def_id) {\n+        let id = tcx.interpret_interner.borrow().get_cached(def_id);\n+        let id = match id {\n+            // FIXME: due to caches this shouldn't happen, add some assertions\n+            Some(id) => id,\n+            None => {\n+                let id = tcx.interpret_interner.borrow_mut().reserve();\n+                tcx.interpret_interner.borrow_mut().cache(def_id, id);\n+                id\n+            },\n+        };\n+        let ty = tcx.type_of(def_id);\n+        let layout = (tcx, key.param_env).layout_of(ty).unwrap();\n+        let ptr = MemoryPointer::new(id, 0);\n+        return Ok(tcx.mk_const(ty::Const {\n+            val: ConstVal::Value(Value::ByRef(ptr.into(), layout.align)),\n+            ty,\n+        }))\n+    }\n+\n     if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         let tables = tcx.typeck_tables_of(def_id);\n \n         // Do match-check before building MIR\n         if tcx.check_match(def_id).is_err() {\n             return Err(ConstEvalErr {\n-                span,\n                 kind: CheckMatchError,\n+                span,\n             });\n         }\n \n@@ -392,22 +455,25 @@ pub fn const_eval_provider<'a, 'tcx>(\n         // Do not continue into miri if typeck errors occurred; it will fail horribly\n         if tables.tainted_by_errors {\n             return Err(ConstEvalErr {\n+                kind: TypeckError,\n                 span,\n-                kind: TypeckError\n             });\n         }\n     };\n \n-    match ::interpret::eval_body(tcx, cid, key.param_env) {\n-        Ok((miri_value, _, miri_ty)) => Ok(tcx.mk_const(ty::Const {\n+    let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n+    res.map(|(miri_value, _, miri_ty)| {\n+        tcx.mk_const(ty::Const {\n             val: ConstVal::Value(miri_value),\n             ty: miri_ty,\n-        })),\n-        Err(err) => {\n-            Err(ConstEvalErr {\n-                span,\n-                kind: err.into()\n-            })\n+        })\n+    }).map_err(|mut err| {\n+        if tcx.is_static(def_id).is_some() {\n+            ecx.report(&mut err, true);\n         }\n-    }\n+        ConstEvalErr {\n+        kind: err.into(),\n+        span,\n+        }\n+    })\n }"}, {"sha": "7d2b83e9217484490e2e527e1d7bf48c0f4eb9da", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 91, "deletions": 34, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -3,7 +3,7 @@ use std::fmt::Write;\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n-use rustc::middle::const_val::ConstVal;\n+use rustc::middle::const_val::{ConstVal, ErrKind};\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n@@ -21,7 +21,7 @@ use super::{Place, PlaceExtra, Memory,\n             HasMemory, MemoryKind, operator,\n             Machine};\n \n-pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n+pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n@@ -32,10 +32,10 @@ pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     pub param_env: ty::ParamEnv<'tcx>,\n \n     /// The virtual memory system.\n-    pub memory: Memory<'a, 'tcx, M>,\n+    pub memory: Memory<'a, 'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'tcx>>,\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n \n     /// The maximum number of stack frames allowed\n     pub(crate) stack_limit: usize,\n@@ -47,12 +47,12 @@ pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n }\n \n /// A stack frame.\n-pub struct Frame<'tcx> {\n+pub struct Frame<'mir, 'tcx: 'mir> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n     /// The MIR for the function called on this frame.\n-    pub mir: &'tcx mir::Mir<'tcx>,\n+    pub mir: &'mir mir::Mir<'tcx>,\n \n     /// The def_id and substs of the current function\n     pub instance: ty::Instance<'tcx>,\n@@ -131,44 +131,53 @@ pub struct ValTy<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+impl<'tcx> ValTy<'tcx> {\n+    pub fn from(val: &ty::Const<'tcx>) -> Option<Self> {\n+        match val.val {\n+            ConstVal::Value(value) => Some(ValTy { value, ty: val.ty }),\n+            ConstVal::Unevaluated { .. } => None,\n+        }\n+    }\n+}\n+\n impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n     type Target = Value;\n     fn deref(&self) -> &Value {\n         &self.value\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> HasDataLayout for &'a EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> HasDataLayout\n-    for &'c &'b mut EvalContext<'a, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> layout::HasTyCtxt<'tcx>\n-    for &'c &'b mut EvalContext<'a, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>> for &'a EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf<Ty<'tcx>> for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n@@ -177,8 +186,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>> for &'a EvalContext<'a, 'tcx\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>>\n-    for &'c &'b mut EvalContext<'a, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf<Ty<'tcx>>\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n     #[inline]\n@@ -187,7 +196,7 @@ impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>>\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -214,15 +223,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.memory.allocate(size, layout.align, Some(MemoryKind::Stack))\n     }\n \n-    pub fn memory(&self) -> &Memory<'a, 'tcx, M> {\n+    pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n \n-    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n+    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         &mut self.memory\n     }\n \n-    pub fn stack(&self) -> &[Frame<'tcx>] {\n+    pub fn stack(&self) -> &[Frame<'mir, 'tcx>] {\n         &self.stack\n     }\n \n@@ -240,14 +249,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ))\n     }\n \n-    pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn const_to_value(&self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match *const_val {\n             ConstVal::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                Ok(self.read_global_as_value(GlobalId {\n+                self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                }, self.layout_of(ty)?))\n+                }, ty)\n             }\n             ConstVal::Value(val) => Ok(val),\n         }\n@@ -380,14 +389,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         span: codemap::Span,\n-        mir: &'tcx mir::Mir<'tcx>,\n+        mir: &'mir mir::Mir<'tcx>,\n         return_place: Place,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n         /// Return the set of locals that have a storage annotation anywhere\n-        fn collect_storage_annotations<'tcx>(mir: &'tcx mir::Mir<'tcx>) -> HashSet<mir::Local> {\n+        fn collect_storage_annotations<'mir, 'tcx>(mir: &'mir mir::Mir<'tcx>) -> HashSet<mir::Local> {\n             use rustc::mir::StatementKind::*;\n \n             let mut set = HashSet::new();\n@@ -819,7 +828,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         self.read_global_as_value(GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n-                        }, self.layout_of(ty)?)\n+                        }, ty)?\n                     }\n                 };\n \n@@ -931,9 +940,28 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_global_as_value(&self, gid: GlobalId, layout: TyLayout) -> Value {\n-        let alloc = self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\");\n-        Value::ByRef(MemoryPointer::new(alloc, 0).into(), layout.align)\n+    pub fn read_global_as_value(&self, gid: GlobalId<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        if gid.promoted.is_none() {\n+            let cached = self\n+                .tcx\n+                .interpret_interner\n+                .borrow()\n+                .get_cached(gid.instance.def_id());\n+            if let Some(alloc_id) = cached {\n+                let layout = self.layout_of(ty)?;\n+                let ptr = MemoryPointer::new(alloc_id, 0);\n+                return Ok(Value::ByRef(ptr.into(), layout.align))\n+            }\n+        }\n+        let cv = match self.tcx.const_eval(self.param_env.and(gid)) {\n+            Ok(val) => val,\n+            Err(err) => match err.kind {\n+                ErrKind::Miri(miri) => return Err(miri),\n+                ErrKind::TypeckError => return err!(TypeckError),\n+                other => bug!(\"const eval returned {:?}\", other),\n+            },\n+        };\n+        self.const_to_value(&cv.val, ty)\n     }\n \n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n@@ -1326,15 +1354,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(Some(Value::ByVal(val)))\n     }\n \n-    pub fn frame(&self) -> &Frame<'tcx> {\n+    pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n-    pub fn frame_mut(&mut self) -> &mut Frame<'tcx> {\n+    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n-    pub(super) fn mir(&self) -> &'tcx mir::Mir<'tcx> {\n+    pub(super) fn mir(&self) -> &'mir mir::Mir<'tcx> {\n         self.frame().mir\n     }\n \n@@ -1544,7 +1572,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn report(&self, e: &mut EvalError) {\n+    pub fn report(&self, e: &mut EvalError, as_err: bool) {\n+        if let EvalErrorKind::TypeckError = e.kind {\n+            return;\n+        }\n         if let Some(ref mut backtrace) = e.backtrace {\n             let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n             backtrace.resolve();\n@@ -1582,8 +1613,34 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             } else {\n                 block.terminator().source_info.span\n             };\n-            let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n+            let node_id = self\n+                .stack()\n+                .iter()\n+                .rev()\n+                .filter_map(|frame| self.tcx.hir.as_local_node_id(frame.instance.def_id()))\n+                .next()\n+                .expect(\"some part of a failing const eval must be local\");\n+            let mut err = if as_err {\n+                ::rustc::middle::const_val::struct_error(self.tcx, span, \"constant evaluation error\")\n+            } else {\n+                self.tcx.struct_span_lint_node(\n+                    ::rustc::lint::builtin::CONST_ERR,\n+                    node_id,\n+                    span,\n+                    \"constant evaluation error\",\n+                )\n+            };\n+            err.span_label(span, e.to_string());\n+            let mut last_span = None;\n             for &Frame { instance, span, .. } in self.stack().iter().rev() {\n+                // make sure we don't emit frames that are duplicates of the previous\n+                if let Some(last) = last_span {\n+                    if last == span {\n+                        continue;\n+                    }\n+                } else {\n+                    last_span = Some(span);\n+                }\n                 if self.tcx.def_key(instance.def_id()).disambiguated_data.data ==\n                     DefPathData::ClosureExpr\n                 {\n@@ -1599,7 +1656,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n }\n \n-impl<'tcx> Frame<'tcx> {\n+impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n     pub fn get_local(&self, local: mir::Local) -> EvalResult<'tcx, Value> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n         self.locals[local.index() - 1].ok_or(EvalErrorKind::DeadLocal.into())"}, {"sha": "d5e57d3317c55588516e3721ad793d899d8ae26e", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -12,7 +12,7 @@ use syntax::ast::Mutability;\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'tcx>: Sized {\n+pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n     type MemoryData;\n \n@@ -26,7 +26,7 @@ pub trait Machine<'tcx>: Sized {\n     ///\n     /// Returns Ok(false) if a new stack frame was pushed\n     fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n@@ -36,7 +36,7 @@ pub trait Machine<'tcx>: Sized {\n \n     /// directly process an intrinsic without pushing a stack frame.\n     fn call_intrinsic<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[ValTy<'tcx>],\n         dest: Place,\n@@ -51,7 +51,7 @@ pub trait Machine<'tcx>: Sized {\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn try_ptr_op<'a>(\n-        ecx: &EvalContext<'a, 'tcx, Self>,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: PrimVal,\n         left_ty: Ty<'tcx>,\n@@ -60,26 +60,30 @@ pub trait Machine<'tcx>: Sized {\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n \n     /// Called when trying to mark machine defined `MemoryKinds` as static\n-    fn mark_static_initialized(m: Self::MemoryKinds) -> EvalResult<'tcx>;\n+    fn mark_static_initialized<'a>(\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        _id: AllocId,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx, bool>;\n \n     /// Heap allocations via the `box` keyword\n     ///\n     /// Returns a pointer to the allocated memory\n     fn box_alloc<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         ty: Ty<'tcx>,\n         dest: Place,\n     ) -> EvalResult<'tcx>;\n \n     /// Called when trying to access a global declared with a `linkage` attribute\n     fn global_item_with_linkage<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx>;\n \n     fn check_locks<'a>(\n-        _mem: &Memory<'a, 'tcx, Self>,\n+        _mem: &Memory<'a, 'mir, 'tcx, Self>,\n         _ptr: MemoryPointer,\n         _size: u64,\n         _access: AccessKind,\n@@ -88,27 +92,27 @@ pub trait Machine<'tcx>: Sized {\n     }\n \n     fn add_lock<'a>(\n-        _mem: &mut Memory<'a, 'tcx, Self>,\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n         _id: AllocId,\n     ) {}\n \n     fn free_lock<'a>(\n-        _mem: &mut Memory<'a, 'tcx, Self>,\n+        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n         _id: AllocId,\n         _len: u64,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n \n     fn end_region<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _reg: Option<::rustc::middle::region::Scope>,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n \n     fn validation_op<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,\n         _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n     ) -> EvalResult<'tcx> {"}, {"sha": "5ee84e0e02c4124e7c606364ab164d1e5f4c6264", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 49, "deletions": 95, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -1,6 +1,6 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{ptr, mem, io};\n+use std::{ptr, io};\n \n use rustc::ty::{Instance, TyCtxt};\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n@@ -19,8 +19,6 @@ use super::{EvalContext, Machine};\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n-    /// A mutable Static. All the others are interned in the tcx\n-    MutableStatic, // FIXME: move me into the machine, rustc const eval doesn't need them\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     Machine(T),\n }\n@@ -29,7 +27,7 @@ pub enum MemoryKind<T> {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n+pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n \n@@ -56,7 +54,7 @@ pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, max_memory: u64, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n@@ -107,6 +105,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n+            mutable: false,\n         };\n         let id = self.tcx.interpret_interner.borrow_mut().reserve();\n         M::add_lock(self, id);\n@@ -119,7 +118,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             None => {\n                 self.uninitialized_statics.insert(id, alloc);\n             },\n-            Some(MemoryKind::MutableStatic) => bug!(\"don't allocate mutable statics directly\")\n         }\n         Ok(MemoryPointer::new(id, 0))\n     }\n@@ -164,10 +162,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn deallocate_local(&mut self, ptr: MemoryPointer) -> EvalResult<'tcx> {\n         match self.alloc_kind.get(&ptr.alloc_id).cloned() {\n-            // for a constant like `const FOO: &i32 = &1;` the local containing\n-            // the `1` is referred to by the global. We transitively marked everything\n-            // the global refers to as static itself, so we don't free it here\n-            Some(MemoryKind::MutableStatic) => Ok(()),\n             Some(MemoryKind::Stack) => self.deallocate(ptr, None, MemoryKind::Stack),\n             // Happens if the memory was interned into immutable memory\n             None => Ok(()),\n@@ -292,7 +286,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         // normal alloc?\n         match self.alloc_map.get(&id) {\n@@ -376,7 +370,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     Some(a) => (a, match self.alloc_kind[&id] {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n-                        MemoryKind::MutableStatic => \" (static mut)\".to_owned(),\n                     }),\n                     // uninitialized static alloc?\n                     None => match self.uninitialized_statics.get(&id) {\n@@ -388,15 +381,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                                 Some(a) => (a, \"(immutable)\".to_owned()),\n                                 None => if let Some(func) = int.get_fn(id) {\n                                     trace!(\"{} {}\", msg, func);\n-                    continue;\n+                                    continue;\n                                 } else {\n-                            trace!(\"{} (deallocated)\", msg);\n-                            continue;\n+                                    trace!(\"{} (deallocated)\", msg);\n+                                    continue;\n                                 },\n-                }\n+                            }\n                         },\n                     },\n-            };\n+                };\n \n             for i in 0..(alloc.bytes.len() as u64) {\n                 if let Some(&target_id) = alloc.relocations.get(&i) {\n@@ -441,14 +434,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn leak_report(&self) -> usize {\n         trace!(\"### LEAK REPORT ###\");\n-        let kinds = &self.alloc_kind;\n         let leaks: Vec<_> = self.alloc_map\n             .keys()\n-            .filter_map(|key| if kinds[key] != MemoryKind::MutableStatic {\n-                Some(*key)\n-            } else {\n-                None\n-            })\n+            .cloned()\n             .collect();\n         let n = leaks.len();\n         self.dump_allocs(leaks);\n@@ -457,7 +445,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Byte accessors\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_bytes_unchecked(\n         &self,\n         ptr: MemoryPointer,\n@@ -521,18 +509,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Reading and writing\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// mark an allocation pointed to by a static as static and initialized\n     fn mark_inner_allocation_initialized(\n         &mut self,\n         alloc: AllocId,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n         match self.alloc_kind.get(&alloc) {\n-            // do not go into immutable statics\n-            None |\n-            // or mutable statics\n-            Some(&MemoryKind::MutableStatic) => Ok(()),\n+            // do not go into statics\n+            None  => Ok(()),\n             // just locals and machine allocs\n             Some(_) => self.mark_static_initalized(alloc, mutability),\n         }\n@@ -549,60 +535,27 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             alloc_id,\n             mutability\n         );\n-        if mutability == Mutability::Immutable {\n-            let alloc = self.alloc_map.remove(&alloc_id);\n-            let kind = self.alloc_kind.remove(&alloc_id);\n-            assert_ne!(kind, Some(MemoryKind::MutableStatic));\n-            let uninit = self.uninitialized_statics.remove(&alloc_id);\n-            if let Some(alloc) = alloc.or(uninit) {\n-                let alloc = self.tcx.intern_const_alloc(alloc);\n-                self.tcx.interpret_interner.borrow_mut().intern_at_reserved(alloc_id, alloc);\n-                // recurse into inner allocations\n-                for &alloc in alloc.relocations.values() {\n-                    self.mark_inner_allocation_initialized(alloc, mutability)?;\n-                }\n-            }\n-            return Ok(());\n+        // The machine handled it\n+        if M::mark_static_initialized(self, alloc_id, mutability)? {\n+            return Ok(())\n         }\n-        // We are marking the static as initialized, so move it out of the uninit map\n-        if let Some(uninit) = self.uninitialized_statics.remove(&alloc_id) {\n-            self.alloc_map.insert(alloc_id, uninit);\n+        let alloc = self.alloc_map.remove(&alloc_id);\n+        match self.alloc_kind.remove(&alloc_id) {\n+            None => {},\n+            Some(MemoryKind::Machine(_)) => bug!(\"machine didn't handle machine alloc\"),\n+            Some(MemoryKind::Stack) => {},\n         }\n-        // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n-        // sub-element or have circular pointers (e.g. `Rc`-cycles)\n-        let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(&mut Allocation {\n-                     ref mut relocations,\n-                     ..\n-                 }) => {\n-                match self.alloc_kind.get(&alloc_id) {\n-                    // const eval results can refer to \"locals\".\n-                    // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n-                    None |\n-                    Some(&MemoryKind::Stack) => {},\n-                    Some(&MemoryKind::Machine(m)) => M::mark_static_initialized(m)?,\n-                    Some(&MemoryKind::MutableStatic) => {\n-                        trace!(\"mark_static_initalized: skipping already initialized static referred to by static currently being initialized\");\n-                        return Ok(());\n-                    },\n-                }\n-                // overwrite or insert\n-                self.alloc_kind.insert(alloc_id, MemoryKind::MutableStatic);\n-                // take out the relocations vector to free the borrow on self, so we can call\n-                // mark recursively\n-                mem::replace(relocations, Default::default())\n+        let uninit = self.uninitialized_statics.remove(&alloc_id);\n+        if let Some(mut alloc) = alloc.or(uninit) {\n+            // ensure llvm knows not to put this into immutable memroy\n+            alloc.mutable = mutability == Mutability::Mutable;\n+            let alloc = self.tcx.intern_const_alloc(alloc);\n+            self.tcx.interpret_interner.borrow_mut().intern_at_reserved(alloc_id, alloc);\n+            // recurse into inner allocations\n+            for &alloc in alloc.relocations.values() {\n+                self.mark_inner_allocation_initialized(alloc, mutability)?;\n             }\n-            None => return err!(DanglingPointerDeref),\n-        };\n-        // recurse into inner allocations\n-        for &alloc in relocations.values() {\n-            self.mark_inner_allocation_initialized(alloc, mutability)?;\n         }\n-        // put back the relocations\n-        self.alloc_map\n-            .get_mut(&alloc_id)\n-            .expect(\"checked above\")\n-            .relocations = relocations;\n         Ok(())\n     }\n \n@@ -829,7 +782,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Relocations\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn relocations(\n         &self,\n         ptr: MemoryPointer,\n@@ -883,7 +836,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n /// Undefined bytes\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(\n         &mut self,\n@@ -944,7 +897,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n // Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn write_target_uint(\n+pub fn write_target_uint(\n     endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: u128,\n@@ -955,7 +908,8 @@ fn write_target_uint(\n         layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n     }\n }\n-fn write_target_int(\n+\n+pub fn write_target_int(\n     endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: i128,\n@@ -967,14 +921,14 @@ fn write_target_int(\n     }\n }\n \n-fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n+pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n     match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n \n-fn read_target_int(endianness: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n+pub fn read_target_int(endianness: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n     match endianness {\n         layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n@@ -985,9 +939,9 @@ fn read_target_int(endianness: layout::Endian, mut source: &[u8]) -> Result<i128\n // Unaligned accesses\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M>;\n-    fn memory(&self) -> &Memory<'a, 'tcx, M>;\n+pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M>;\n+    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M>;\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n@@ -1051,31 +1005,31 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         self\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n+    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         self\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         &mut self.memory\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n+    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a Memory<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout"}, {"sha": "f23ba90fd4c3ffb0234e3a666e25e86c33c2d9e6", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -18,6 +18,17 @@ pub use self::place::{Place, PlaceExtra};\n \n pub use self::memory::{Memory, MemoryKind, HasMemory};\n \n-pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider, const_val_field, const_discr, check_body};\n+pub use self::const_eval::{\n+    eval_body_with_mir,\n+    mk_borrowck_eval_cx,\n+    eval_body,\n+    CompileTimeEvaluator,\n+    const_eval_provider,\n+    const_val_field,\n+    const_discr,\n+};\n \n pub use self::machine::Machine;\n+\n+pub use self::operator::unary_op;\n+pub use self::memory::{write_target_uint, write_target_int, read_target_uint, read_target_int};"}, {"sha": "bad744194d5e35be354bb7ff9ce611862c2aa3a5", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -8,7 +8,7 @@ use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, bytes_to_f32, bytes_to_f64};\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n@@ -56,6 +56,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n }\n \n macro_rules! overflow {\n+    (overflowing_div, $l:expr, $r:expr) => ({\n+        let (val, overflowed) = if $r == 0 {\n+            ($l, true)\n+        } else {\n+            $l.overflowing_div($r)\n+        };\n+        let primval = PrimVal::Bytes(val as u128);\n+        Ok((primval, overflowed))\n+    });\n+    (overflowing_rem, $l:expr, $r:expr) => ({\n+        let (val, overflowed) = if $r == 0 {\n+            ($l, true)\n+        } else {\n+            $l.overflowing_rem($r)\n+        };\n+        let primval = PrimVal::Bytes(val as u128);\n+        Ok((primval, overflowed))\n+    });\n     ($op:ident, $l:expr, $r:expr) => ({\n         let (val, overflowed) = $l.$op($r);\n         let primval = PrimVal::Bytes(val as u128);\n@@ -105,7 +123,7 @@ macro_rules! int_shift {\n     })\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n         &self,"}, {"sha": "349ac63055992509ee2fcaad2797add4b6c7f60c", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -1,11 +1,13 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::traits;\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{GlobalId, Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n+use rustc::middle::const_val::ErrKind;\n \n #[derive(Copy, Clone, Debug)]\n pub enum Place {\n@@ -90,7 +92,7 @@ impl<'tcx> Place {\n     }\n }\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Reads a value from the place without going through the intermediate step of obtaining\n     /// a `miri::Place`\n     pub fn try_read_place(\n@@ -106,10 +108,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Directly reading a static will always succeed\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                Ok(Some(self.read_global_as_value(GlobalId {\n+                self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                }, self.layout_of(self.place_ty(place))?)))\n+                }, self.place_ty(place)).map(Some)\n             }\n             Projection(ref proj) => self.try_read_place_projection(proj),\n         }\n@@ -199,17 +201,44 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             },\n \n             Static(ref static_) => {\n-                let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                let gid = GlobalId {\n-                    instance,\n-                    promoted: None,\n-                };\n+                let alloc = self\n+                    .tcx\n+                    .interpret_interner\n+                    .borrow()\n+                    .get_cached(static_.def_id);\n                 let layout = self.layout_of(self.place_ty(mir_place))?;\n-                let alloc = self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\");\n-                Place::Ptr {\n-                    ptr: MemoryPointer::new(alloc, 0).into(),\n-                    align: layout.align,\n-                    extra: PlaceExtra::None,\n+                if let Some(alloc) = alloc {\n+                    Place::Ptr {\n+                        ptr: MemoryPointer::new(alloc, 0).into(),\n+                        align: layout.align,\n+                        extra: PlaceExtra::None,\n+                    }\n+                } else {\n+                    let instance = ty::Instance::mono(self.tcx, static_.def_id);\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None\n+                    };\n+                    let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+                    // ensure the static is computed\n+                    if let Err(err) = self.tcx.const_eval(param_env.and(cid)) {\n+                        match err.kind {\n+                            ErrKind::Miri(miri) => return Err(miri),\n+                            ErrKind::TypeckError => return err!(TypeckError),\n+                            other => bug!(\"const eval returned {:?}\", other),\n+                        }\n+                    };\n+                    let alloc = self\n+                        .tcx\n+                        .interpret_interner\n+                        .borrow()\n+                        .get_cached(static_.def_id)\n+                        .expect(\"uncached static\");\n+                    Place::Ptr {\n+                        ptr: MemoryPointer::new(alloc, 0).into(),\n+                        align: layout.align,\n+                        extra: PlaceExtra::None,\n+                    }\n                 }\n             }\n "}, {"sha": "21e81ff668ea58e26badaedfc47fd78339fffbbf", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 234, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -2,21 +2,12 @@\n //!\n //! The main entry point is the `step` method.\n \n-use rustc::hir;\n-use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::mir;\n-use rustc::ty::{self, Instance};\n-use rustc::ty::layout::LayoutOf;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::mir::interpret::GlobalId;\n \n-use rustc::mir::interpret::{EvalResult, EvalErrorKind};\n-use super::{EvalContext, StackPopCleanup, Place, Machine};\n+use rustc::mir::interpret::EvalResult;\n+use super::{EvalContext, Machine};\n \n-use syntax::codemap::Span;\n-use syntax::ast::Mutability;\n-\n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n         self.steps_remaining = self.steps_remaining.saturating_sub(n);\n         if self.steps_remaining > 0 {\n@@ -41,52 +32,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let old_frames = self.cur_frame();\n \n         if let Some(stmt) = basic_block.statements.get(stmt_id) {\n-            let mut new = Ok(false);\n-            ConstantExtractor {\n-                span: stmt.source_info.span,\n-                instance: self.frame().instance,\n-                ecx: self,\n-                mir,\n-                new_constant: &mut new,\n-            }.visit_statement(\n-                block,\n-                stmt,\n-                mir::Location {\n-                    block,\n-                    statement_index: stmt_id,\n-                },\n-            );\n-            // if ConstantExtractor added a new frame, we don't execute anything here\n-            // but await the next call to step\n-            if !new? {\n-                assert_eq!(old_frames, self.cur_frame());\n-                self.statement(stmt)?;\n-            }\n+            assert_eq!(old_frames, self.cur_frame());\n+            self.statement(stmt)?;\n             return Ok(true);\n         }\n \n         let terminator = basic_block.terminator();\n-        let mut new = Ok(false);\n-        ConstantExtractor {\n-            span: terminator.source_info.span,\n-            instance: self.frame().instance,\n-            ecx: self,\n-            mir,\n-            new_constant: &mut new,\n-        }.visit_terminator(\n-            block,\n-            terminator,\n-            mir::Location {\n-                block,\n-                statement_index: stmt_id,\n-            },\n-        );\n-        // if ConstantExtractor added a new frame, we don't execute anything here\n-        // but await the next call to step\n-        if !new? {\n-            assert_eq!(old_frames, self.cur_frame());\n-            self.terminator(terminator)?;\n-        }\n+        assert_eq!(old_frames, self.cur_frame());\n+        self.terminator(terminator)?;\n         Ok(true)\n     }\n \n@@ -152,184 +105,4 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n         Ok(())\n     }\n-\n-    /// returns `true` if a stackframe was pushed\n-    fn global_item(\n-        &mut self,\n-        instance: Instance<'tcx>,\n-        span: Span,\n-        mutability: Mutability,\n-    ) -> EvalResult<'tcx, bool> {\n-        debug!(\"global_item: {:?}\", instance);\n-        let cid = GlobalId {\n-            instance,\n-            promoted: None,\n-        };\n-        if self.tcx.interpret_interner.borrow().get_cached(cid).is_some() {\n-            return Ok(false);\n-        }\n-        if self.tcx.has_attr(instance.def_id(), \"linkage\") {\n-            M::global_item_with_linkage(self, cid.instance, mutability)?;\n-            return Ok(false);\n-        }\n-        let instance_ty = instance.ty(self.tcx);\n-        let layout = self.layout_of(instance_ty)?;\n-        assert!(!layout.is_unsized());\n-        let ptr = self.memory.allocate(\n-            layout.size.bytes(),\n-            layout.align,\n-            None,\n-        )?;\n-        self.tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n-        let internally_mutable = !layout.ty.is_freeze(self.tcx, self.param_env, span);\n-        let mutability = if mutability == Mutability::Mutable || internally_mutable {\n-            Mutability::Mutable\n-        } else {\n-            Mutability::Immutable\n-        };\n-        let cleanup = StackPopCleanup::MarkStatic(mutability);\n-        let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n-        trace!(\"pushing stack frame for global: {}\", name);\n-        let mir = self.load_mir(instance.def)?;\n-        self.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            Place::from_ptr(ptr, layout.align),\n-            cleanup,\n-        )?;\n-        Ok(true)\n-    }\n-}\n-\n-struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b, M: Machine<'tcx> + 'a> {\n-    span: Span,\n-    ecx: &'a mut EvalContext<'b, 'tcx, M>,\n-    mir: &'tcx mir::Mir<'tcx>,\n-    instance: ty::Instance<'tcx>,\n-    // Whether a stackframe for a new constant has been pushed\n-    new_constant: &'a mut EvalResult<'tcx, bool>,\n-}\n-\n-impl<'a, 'b, 'tcx, M: Machine<'tcx>> ConstantExtractor<'a, 'b, 'tcx, M> {\n-    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, bool>>(&mut self, f: F) {\n-        match *self.new_constant {\n-            // already computed a constant, don't do more than one per iteration\n-            Ok(true) => {},\n-            // no constants computed yet\n-            Ok(false) => *self.new_constant = f(self),\n-            // error happened, abort the visitor traversing\n-            Err(_) => {},\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx, M> {\n-    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: mir::Location) {\n-        self.super_constant(constant, location);\n-        self.try(|this| {\n-            match constant.literal {\n-                // already computed by rustc\n-                mir::Literal::Value { value: &ty::Const { val: ConstVal::Unevaluated(def_id, substs), .. } } => {\n-                    debug!(\"global_item: {:?}, {:#?}\", def_id, substs);\n-                    let substs = this.ecx.tcx.trans_apply_param_substs(this.instance.substs, &substs);\n-                    debug!(\"global_item_new_substs: {:#?}\", substs);\n-                    debug!(\"global_item_param_env: {:#?}\", this.ecx.param_env);\n-                    let instance = Instance::resolve(\n-                        this.ecx.tcx,\n-                        this.ecx.param_env,\n-                        def_id,\n-                        substs,\n-                    ).ok_or(EvalErrorKind::TypeckError)?; // turn error prop into a panic to expose associated type in const issue\n-                    this.ecx.global_item(\n-                        instance,\n-                        constant.span,\n-                        Mutability::Immutable,\n-                    )\n-                }\n-                mir::Literal::Value { .. } => Ok(false),\n-                mir::Literal::Promoted { index } => {\n-                    let cid = GlobalId {\n-                        instance: this.instance,\n-                        promoted: Some(index),\n-                    };\n-                    if this.ecx.tcx.interpret_interner.borrow().get_cached(cid).is_some() {\n-                        return Ok(false);\n-                    }\n-                    let mir = &this.mir.promoted[index];\n-                    let ty = this.ecx.monomorphize(mir.return_ty(), this.instance.substs);\n-                    let layout = this.ecx.layout_of(ty)?;\n-                    assert!(!layout.is_unsized());\n-                    let ptr = this.ecx.memory.allocate(\n-                        layout.size.bytes(),\n-                        layout.align,\n-                        None,\n-                    )?;\n-                    this.ecx.tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n-                    trace!(\"pushing stack frame for {:?}\", index);\n-                    this.ecx.push_stack_frame(\n-                        this.instance,\n-                        constant.span,\n-                        mir,\n-                        Place::from_ptr(ptr, layout.align),\n-                        StackPopCleanup::MarkStatic(Mutability::Immutable),\n-                    )?;\n-                    Ok(true)\n-                }\n-            }\n-        });\n-    }\n-\n-    fn visit_place(\n-        &mut self,\n-        place: &mir::Place<'tcx>,\n-        context: PlaceContext<'tcx>,\n-        location: mir::Location,\n-    ) {\n-        self.super_place(place, context, location);\n-        self.try(|this| {\n-            if let mir::Place::Static(ref static_) = *place {\n-                let def_id = static_.def_id;\n-                let span = this.span;\n-                if let Some(node_item) = this.ecx.tcx.hir.get_if_local(def_id) {\n-                    if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n-                        if let hir::ItemStatic(_, m, _) = *node {\n-                            let instance = Instance::mono(this.ecx.tcx, def_id);\n-                            this.ecx.global_item(\n-                                instance,\n-                                span,\n-                                if m == hir::MutMutable {\n-                                    Mutability::Mutable\n-                                } else {\n-                                    Mutability::Immutable\n-                                },\n-                            )\n-                        } else {\n-                            bug!(\"static def id doesn't point to static\");\n-                        }\n-                    } else {\n-                        bug!(\"static def id doesn't point to item\");\n-                    }\n-                } else {\n-                    let def = this.ecx.tcx.describe_def(def_id).expect(\"static not found\");\n-                    if let hir::def::Def::Static(_, mutable) = def {\n-                        let instance = Instance::mono(this.ecx.tcx, def_id);\n-                        this.ecx.global_item(\n-                            instance,\n-                            span,\n-                            if mutable {\n-                                Mutability::Mutable\n-                            } else {\n-                                Mutability::Immutable\n-                            },\n-                        )\n-                    } else {\n-                        bug!(\"static found but isn't a static: {:?}\", def);\n-                    }\n-                }\n-            } else {\n-                Ok(false)\n-            }\n-        });\n-    }\n }"}, {"sha": "fbc0c499e59ded5124946755aa90dec5e52063d0", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -5,7 +5,7 @@ use syntax::codemap::Span;\n use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub(crate) fn drop_place(\n         &mut self,\n         place: Place,"}, {"sha": "b1b5f77a2e6ef276b25c9c77d52ed043dd4a1912", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -13,7 +13,7 @@ use interpret::memory::HasMemory;\n \n mod drop;\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn goto_block(&mut self, target: mir::BasicBlock) {\n         self.frame_mut().block = target;\n         self.frame_mut().stmt = 0;"}, {"sha": "4dc0879c85d5237d0d907ee0a3b41ca902d5d40d", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -6,7 +6,7 @@ use rustc::mir::interpret::{PrimVal, Value, MemoryPointer, EvalResult};\n use super::{EvalContext, eval_context,\n             Machine};\n \n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///\n@@ -54,7 +54,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         self.memory.mark_static_initalized(\n             vtable.alloc_id,\n-            Mutability::Mutable,\n+            Mutability::Immutable,\n         )?;\n \n         Ok(vtable)"}, {"sha": "0a8fd022dd1ac110706dacb78b615f01b9ddb378", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -194,6 +194,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{Value, PrimVal, AllocId, Pointer};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::{Substs, Kind};\n@@ -568,14 +569,26 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n-            let substs = self.tcx.trans_apply_param_substs(self.param_substs,\n-                                                           &substs);\n-            let instance = ty::Instance::resolve(self.tcx,\n-                                                 ty::ParamEnv::empty(traits::Reveal::All),\n-                                                 def_id,\n-                                                 substs).unwrap();\n-            collect_neighbours(self.tcx, instance, true, self.output);\n+        match constant.val {\n+            ConstVal::Unevaluated(def_id, substs) => {\n+                let substs = self.tcx.trans_apply_param_substs(self.param_substs,\n+                                                            &substs);\n+                let instance = ty::Instance::resolve(self.tcx,\n+                                                    ty::ParamEnv::empty(traits::Reveal::All),\n+                                                    def_id,\n+                                                    substs).unwrap();\n+                collect_neighbours(self.tcx, instance, true, self.output);\n+            },\n+            ConstVal::Value(Value::ByValPair(PrimVal::Ptr(a), PrimVal::Ptr(b))) => {\n+                collect_miri(self.tcx, a.alloc_id, self.output);\n+                collect_miri(self.tcx, b.alloc_id, self.output);\n+            }\n+            ConstVal::Value(Value::ByValPair(_, PrimVal::Ptr(ptr))) |\n+            ConstVal::Value(Value::ByValPair(PrimVal::Ptr(ptr), _)) |\n+            ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))) |\n+            ConstVal::Value(Value::ByRef(Pointer { primval: PrimVal::Ptr(ptr) }, _)) =>\n+                collect_miri(self.tcx, ptr.alloc_id, self.output),\n+            _ => {},\n         }\n \n         self.super_const(constant);\n@@ -1098,6 +1111,28 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+/// Scan the miri alloc in order to find function calls, closures, and drop-glue\n+fn collect_miri<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    alloc_id: AllocId,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n+    let interpret_interner = tcx.interpret_interner.borrow();\n+    if let Some(alloc) = interpret_interner.get_alloc(alloc_id) {\n+        trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n+        for &inner in alloc.relocations.values() {\n+            collect_miri(tcx, inner, output);\n+        }\n+    } else if let Some(fn_instance) = interpret_interner.get_fn(alloc_id) {\n+        if should_monomorphize_locally(tcx, &fn_instance) {\n+            trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n+            output.push(create_fn_mono_item(fn_instance));\n+        }\n+    } else {\n+        bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+    }\n+}\n+\n /// Scan the MIR in order to find function calls, closures, and drop-glue\n fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,"}, {"sha": "86d08dec2b9c363621b76bcf73c5e38511d74ad7", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 // locals are safe\n             }\n             &Place::Static(box Static { def_id, ty: _ }) => {\n-                if self.tcx.is_static_mut(def_id) {\n+                if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\");\n                 } else if self.tcx.is_foreign_item(def_id) {\n                     let source_info = self.source_info;"}, {"sha": "e27e7c72473be0f6b6f2e2a7cb6729a4bf503168", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 475, "deletions": 12, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -11,44 +11,52 @@\n //! Performs various peephole optimizations.\n \n use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, ProjectionElem, Rvalue, Local};\n-use rustc::mir::visit::{MutVisitor, Visitor};\n-use rustc::ty::{TyCtxt, TypeVariants};\n+use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock};\n+use rustc::mir::{SourceInfo, ARGUMENT_VISIBILITY_SCOPE, TerminatorKind};\n+use rustc::mir::visit::{MutVisitor, Visitor, TyContext};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{TyCtxt, TypeVariants, self, Instance};\n+use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n+use interpret::{eval_body_with_mir, eval_body, mk_borrowck_eval_cx, unary_op, ValTy};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n+use std::collections::VecDeque;\n use transform::{MirPass, MirSource};\n+use syntax::codemap::{Span, DUMMY_SP};\n+use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use rustc::ty::subst::Substs;\n \n pub struct InstCombine;\n \n impl MirPass for InstCombine {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource,\n+                          source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        // We only run when optimizing MIR (at any level).\n-        if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n-            return\n-        }\n \n         // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`).\n         let optimizations = {\n-            let mut optimization_finder = OptimizationFinder::new(mir, tcx);\n+            let mut optimization_finder = OptimizationFinder::new(mir, tcx, source);\n             optimization_finder.visit_mir(mir);\n             optimization_finder.optimizations\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_mir(&mut InstCombineVisitor { optimizations }, mir);\n+        MutVisitor::visit_mir(&mut InstCombineVisitor { optimizations, tcx }, mir);\n     }\n }\n \n-pub struct InstCombineVisitor<'tcx> {\n+type Const<'tcx> = (Value, ty::Ty<'tcx>, Span);\n+\n+pub struct InstCombineVisitor<'a, 'tcx: 'a> {\n     optimizations: OptimizationList<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n+impl<'a, 'tcx> MutVisitor<'tcx> for InstCombineVisitor<'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"Replacing `&*`: {:?}\", rvalue);\n@@ -67,28 +75,460 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n             *rvalue = Rvalue::Use(Operand::Constant(box constant));\n         }\n \n+        if let Some((value, ty, span)) = self.optimizations.const_prop.remove(&location) {\n+            let value = self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(value),\n+                ty,\n+            });\n+            debug!(\"Replacing `{:?}` with {:?}\", rvalue, value);\n+            let constant = Constant {\n+                ty,\n+                literal: Literal::Value { value },\n+                span,\n+            };\n+            *rvalue = Rvalue::Use(Operand::Constant(box constant));\n+        }\n+\n         self.super_rvalue(rvalue, location)\n     }\n+\n+    fn visit_constant(\n+        &mut self,\n+        constant: &mut Constant<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_constant(constant, location);\n+        if let Some(&(val, ty, _)) = self.optimizations.constants.get(constant) {\n+            constant.literal = Literal::Value {\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Value(val),\n+                    ty,\n+                }),\n+            };\n+        }\n+    }\n+\n+    fn visit_operand(\n+        &mut self,\n+        operand: &mut Operand<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_operand(operand, location);\n+        let new = match operand {\n+            Operand::Move(Place::Local(local)) |\n+            Operand::Copy(Place::Local(local)) => {\n+                trace!(\"trying to read {:?}\", local);\n+                self.optimizations.places.get(&local).cloned()\n+            },\n+            _ => return,\n+        };\n+        if let Some((value, ty, span)) = new {\n+            let value = self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(value),\n+                ty,\n+            });\n+            debug!(\"Replacing `{:?}` with {:?}\", operand, value);\n+            let constant = Constant {\n+                ty,\n+                literal: Literal::Value { value },\n+                span,\n+            };\n+            *operand = Operand::Constant(box constant);\n+        }\n+    }\n+\n+    fn visit_terminator_kind(\n+        &mut self,\n+        block: BasicBlock,\n+        kind: &mut TerminatorKind<'tcx>,\n+        location: Location,\n+    ) {\n+        match kind {\n+            TerminatorKind::SwitchInt { discr: value, .. } |\n+            TerminatorKind::Yield { value, .. } |\n+            TerminatorKind::Assert { cond: value, .. } => {\n+                if let Some((new, ty, span)) = self.optimizations.const_prop.remove(&location) {\n+                    let new = self.tcx.mk_const(ty::Const {\n+                        val: ConstVal::Value(new),\n+                        ty,\n+                    });\n+                    debug!(\"Replacing `{:?}` with {:?}\", value, new);\n+                    let constant = Constant {\n+                        ty,\n+                        literal: Literal::Value { value: new },\n+                        span,\n+                    };\n+                    *value = Operand::Constant(box constant);\n+                }\n+            }\n+            // FIXME: do this optimization for function calls\n+            _ => {},\n+        }\n+        self.super_terminator_kind(block, kind, location)\n+    }\n }\n \n /// Finds optimization opportunities on the MIR.\n struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n     mir: &'b Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: MirSource,\n     optimizations: OptimizationList<'tcx>,\n }\n \n impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n-    fn new(mir: &'b Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'a, 'tcx> {\n+    fn new(\n+        mir: &'b Mir<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        source: MirSource,\n+    ) -> OptimizationFinder<'b, 'a, 'tcx> {\n         OptimizationFinder {\n             mir,\n             tcx,\n+            source,\n             optimizations: OptimizationList::default(),\n         }\n     }\n+\n+    fn eval_constant(&mut self, c: &Constant<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+        if let Some(&val) = self.optimizations.constants.get(c) {\n+            return Some(val);\n+        }\n+        match c.literal {\n+            Literal::Value { value } => match value.val {\n+                ConstVal::Value(v) => Some((v, value.ty, span)),\n+                ConstVal::Unevaluated(did, substs) => {\n+                    let param_env = self.tcx.param_env(self.source.def_id);\n+                    let span = self.tcx.def_span(did);\n+                    let instance = Instance::resolve(\n+                        self.tcx,\n+                        param_env,\n+                        did,\n+                        substs,\n+                    )?;\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    let (value, _, ty) = eval_body(self.tcx, cid, param_env)?;\n+                    let val = (value, ty, span);\n+                    trace!(\"evaluated {:?} to {:?}\", c, val);\n+                    self.optimizations.constants.insert(c.clone(), val);\n+                    Some(val)\n+                },\n+            },\n+            // evaluate the promoted and replace the constant with the evaluated result\n+            Literal::Promoted { index } => {\n+                let generics = self.tcx.generics_of(self.source.def_id);\n+                if generics.parent_types as usize + generics.types.len() > 0 {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: Some(index),\n+                };\n+                let span = self.tcx.def_span(self.source.def_id);\n+                let param_env = self.tcx.param_env(self.source.def_id);\n+                let (value, _, ty) = eval_body_with_mir(self.tcx, cid, self.mir, param_env)?;\n+                let val = (value, ty, span);\n+                trace!(\"evaluated {:?} to {:?}\", c, val);\n+                self.optimizations.constants.insert(c.clone(), val);\n+                Some(val)\n+            }\n+        }\n+    }\n+\n+    fn eval_operand(&mut self, op: &Operand<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+        match *op {\n+            Operand::Constant(ref c) => self.eval_constant(c, span),\n+            Operand::Move(ref place) | Operand::Copy(ref place) => match *place {\n+                Place::Local(loc) => self.optimizations.places.get(&loc).cloned(),\n+                // FIXME(oli-obk): field and index projections\n+                Place::Projection(_) => None,\n+                _ => None,\n+            },\n+        }\n+    }\n+\n+    fn simplify_operand(&mut self, op: &Operand<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+        match *op {\n+            Operand::Constant(ref c) => match c.literal {\n+                Literal::Value { .. } => None,\n+                _ => self.eval_operand(op, span),\n+            },\n+            _ => self.eval_operand(op, span),\n+        }\n+    }\n+\n+    fn const_prop(\n+        &mut self,\n+        rvalue: &Rvalue<'tcx>,\n+        place_ty: ty::Ty<'tcx>,\n+        span: Span,\n+    ) -> Option<Const<'tcx>> {\n+        match *rvalue {\n+            Rvalue::Use(ref op) => self.simplify_operand(op, span),\n+            Rvalue::Repeat(..) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::Aggregate(..) |\n+            Rvalue::NullaryOp(NullOp::Box, _) |\n+            Rvalue::Discriminant(..) => None,\n+            // FIXME(oli-obk): evaluate static/constant slice lengths\n+            Rvalue::Len(_) => None,\n+            Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n+                let param_env = self.tcx.param_env(self.source.def_id);\n+                type_size_of(self.tcx, param_env, ty).map(|n| (\n+                    Value::ByVal(PrimVal::Bytes(n as u128)),\n+                    self.tcx.types.usize,\n+                    span,\n+                ))\n+            }\n+            Rvalue::UnaryOp(op, ref arg) => {\n+                let def_id = if self.tcx.is_closure(self.source.def_id) {\n+                    self.tcx.closure_base_def_id(self.source.def_id)\n+                } else {\n+                    self.source.def_id\n+                };\n+                let generics = self.tcx.generics_of(def_id);\n+                if generics.parent_types as usize + generics.types.len() > 0 {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir).unwrap();\n+\n+                let val = self.eval_operand(arg, span)?;\n+                let prim = ecx.value_to_primval(ValTy { value: val.0, ty: val.1 }).ok()?;\n+                let kind = ecx.ty_to_primval_kind(val.1).ok()?;\n+                match unary_op(op, prim, kind) {\n+                    Ok(val) => Some((Value::ByVal(val), place_ty, span)),\n+                    Err(mut err) => {\n+                        ecx.report(&mut err, false);\n+                        None\n+                    },\n+                }\n+            }\n+            Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n+            Rvalue::BinaryOp(op, ref left, ref right) => {\n+                trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n+                let left = self.eval_operand(left, span)?;\n+                let right = self.eval_operand(right, span)?;\n+                let def_id = if self.tcx.is_closure(self.source.def_id) {\n+                    self.tcx.closure_base_def_id(self.source.def_id)\n+                } else {\n+                    self.source.def_id\n+                };\n+                let generics = self.tcx.generics_of(def_id);\n+                let has_generics = generics.parent_types as usize + generics.types.len() > 0;\n+                if has_generics {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir).unwrap();\n+\n+                let l = ecx.value_to_primval(ValTy { value: left.0, ty: left.1 }).ok()?;\n+                let r = ecx.value_to_primval(ValTy { value: right.0, ty: right.1 }).ok()?;\n+                trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n+                match ecx.binary_op(op, l, left.1, r, right.1) {\n+                    Ok((val, overflow)) => {\n+                        let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n+                            Value::ByValPair(\n+                                val,\n+                                PrimVal::from_bool(overflow),\n+                            )\n+                        } else {\n+                            if overflow {\n+                                use rustc::mir::interpret::EvalError;\n+                                use rustc::mir::interpret::EvalErrorKind;\n+                                let mut err = EvalError {\n+                                    kind: EvalErrorKind::OverflowingMath,\n+                                    backtrace: None,\n+                                };\n+                                ecx.report(&mut err, false);\n+                                return None;\n+                            }\n+                            Value::ByVal(val)\n+                        };\n+                        Some((val, place_ty, span))\n+                    },\n+                    Err(mut err) => {\n+                        ecx.report(&mut err, false);\n+                        None\n+                    },\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: ty::ParamEnv<'tcx>,\n+                          ty: ty::Ty<'tcx>) -> Option<u64> {\n+    use rustc::ty::layout::LayoutOf;\n+    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size.bytes())\n+}\n+\n+struct ConstPropVisitor {\n+    local: Local,\n+    can_const_prop: bool,\n+    // false at the beginning, once set, there are not allowed to be any more assignments\n+    found_assignment: bool,\n+}\n+\n+impl ConstPropVisitor {\n+    /// returns true if `local` can be propagated\n+    fn check<'tcx>(local: Local, mir: &Mir<'tcx>) -> bool {\n+        let mut cpv = ConstPropVisitor {\n+            local,\n+            can_const_prop: true,\n+            found_assignment: false,\n+        };\n+        cpv.visit_mir(mir);\n+        cpv.can_const_prop\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ConstPropVisitor {\n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_statement(block, statement, location);\n+        match statement.kind {\n+            StatementKind::SetDiscriminant { place: Place::Local(local), .. } |\n+            StatementKind::Assign(Place::Local(local), _) => {\n+                if local == self.local {\n+                    if self.found_assignment {\n+                        self.can_const_prop = false;\n+                    } else {\n+                        self.found_assignment = true\n+                    }\n+                }\n+            },\n+            StatementKind::InlineAsm { ref outputs, .. } => {\n+                for place in outputs {\n+                    if let Place::Local(local) = *place {\n+                        if local == self.local {\n+                            if self.found_assignment {\n+                                self.can_const_prop = false;\n+                            } else {\n+                                self.found_assignment = true\n+                            }\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+        if let Rvalue::Ref(_, _, Place::Local(local)) = *rvalue {\n+            if local == self.local {\n+                self.can_const_prop = false;\n+            }\n+        }\n+    }\n }\n \n impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n+    // override to visit basic blocks in execution order\n+    fn super_mir(&mut self, mir: &Mir<'tcx>) {\n+        let mut seen = FxHashSet::default();\n+        seen.insert(mir.start_node());\n+        let mut sorted = Vec::new();\n+        let mut next = VecDeque::new();\n+        sorted.push(mir.start_node());\n+        next.push_back(mir.start_node());\n+        while let Some(current) = next.pop_front() {\n+            for successor in mir.successors(current) {\n+                trace!(\"checking successor of {:?}: {:?}\", current, successor);\n+                trace!(\"{:?}, {:?}\", sorted, next);\n+                if seen.contains(&successor) {\n+                    for &pending in &next {\n+                        // not a back-edge, just a branch merging back into a single execution\n+                        if pending == successor {\n+                            // move to the back of the queue\n+                            let i = sorted.iter().position(|&b| b == successor).unwrap();\n+                            sorted.remove(i);\n+                            sorted.push(successor);\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    seen.insert(successor);\n+                    sorted.push(successor);\n+                    next.push_back(successor);\n+                }\n+            }\n+        }\n+        trace!(\"checking basic blocks: {:?}\", sorted);\n+        for bb in sorted {\n+            self.visit_basic_block_data(bb, &mir[bb]);\n+        }\n+\n+        for scope in &mir.visibility_scopes {\n+            self.visit_visibility_scope_data(scope);\n+        }\n+\n+        self.visit_ty(&mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n+            span: mir.span,\n+            scope: ARGUMENT_VISIBILITY_SCOPE,\n+        }));\n+\n+        for local in mir.local_decls.indices() {\n+            self.visit_local_decl(local, &mir.local_decls[local]);\n+        }\n+\n+        self.visit_span(&mir.span);\n+    }\n+\n+    fn visit_constant(\n+        &mut self,\n+        constant: &Constant<'tcx>,\n+        location: Location,\n+    ) {\n+        trace!(\"visit_constant: {:?}\", constant);\n+        self.super_constant(constant, location);\n+        self.eval_constant(constant, DUMMY_SP);\n+    }\n+\n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+        if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n+            let place_ty = place\n+                .ty(&self.mir.local_decls, self.tcx)\n+                .to_ty(self.tcx);\n+            let span = self.mir.source_info(location).span;\n+            if let Some(value) = self.const_prop(rval, place_ty, span) {\n+                self.optimizations.const_prop.insert(location, value);\n+                if let Place::Local(local) = *place {\n+                    if !self.mir.local_decls[local].is_user_variable\n+                        && ConstPropVisitor::check(local, self.mir) {\n+                        trace!(\"storing {:?} to {:?}\", value, local);\n+                        assert!(self.optimizations.places.insert(local, value).is_none());\n+                    }\n+                }\n+            }\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n@@ -111,10 +551,33 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n         self.super_rvalue(rvalue, location)\n     }\n+\n+    fn visit_terminator_kind(\n+        &mut self,\n+        _block: BasicBlock,\n+        kind: &TerminatorKind<'tcx>,\n+        location: Location,\n+    ) {\n+        let span = self.mir.source_info(location).span;\n+        match kind {\n+            TerminatorKind::SwitchInt { discr: value, .. } |\n+            TerminatorKind::Yield { value, .. } |\n+            TerminatorKind::Assert { cond: value, .. } => {\n+                if let Some(value) = self.simplify_operand(value, span) {\n+                    self.optimizations.const_prop.insert(location, value);\n+                }\n+            }\n+            // FIXME: do this optimization for function calls\n+            _ => {},\n+        }\n+    }\n }\n \n #[derive(Default)]\n struct OptimizationList<'tcx> {\n     and_stars: FxHashSet<Location>,\n     arrays_lengths: FxHashMap<Location, Constant<'tcx>>,\n+    const_prop: FxHashMap<Location, Const<'tcx>>,\n+    places: FxHashMap<Local, Const<'tcx>>,\n+    constants: FxHashMap<Constant<'tcx>, Const<'tcx>>,\n }"}, {"sha": "122b51dbbb778cab5551fbad85d9ea5fec630ef1", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -13,7 +13,6 @@ use llvm::{SetUnnamedAddr};\n use llvm::{ValueRef, True};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n use monomorphize::MonoItem;\n@@ -247,12 +246,15 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                               def_id: DefId,\n                               is_mutable: bool,\n-                              attrs: &[ast::Attribute])\n-                              -> Result<ValueRef, ConstEvalErr<'tcx>> {\n+                              attrs: &[ast::Attribute]) {\n     unsafe {\n         let g = get_static(cx, def_id);\n \n-        let v = ::mir::trans_static_initializer(cx, def_id)?;\n+        let v = match ::mir::trans_static_initializer(cx, def_id) {\n+            Ok(v) => v,\n+            // Error has already been reported\n+            Err(_) => return,\n+        };\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n@@ -316,7 +318,5 @@ pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n             cx.used_statics.borrow_mut().push(cast);\n         }\n-\n-        Ok(g)\n     }\n }"}, {"sha": "6d2f9c6c97fb0e4d76813419afaa00a44e0bb9ed", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -10,7 +10,6 @@\n \n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n-use rustc::middle::const_val::{ConstEvalErr, ErrKind};\n use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::traits;\n@@ -19,7 +18,7 @@ use abi::{Abi, FnType, ArgType, PassMode};\n use base;\n use callee;\n use builder::Builder;\n-use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n+use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_uint_big, C_undef};\n use consts;\n use meth;\n use monomorphize;\n@@ -30,7 +29,6 @@ use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::Const;\n use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n@@ -206,10 +204,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n                                             llblock(self, *otherwise), values.len());\n+                    let switch_llty = bcx.ccx.layout_of(switch_ty).immediate_llvm_type(bcx.ccx);\n                     for (&value, target) in values.iter().zip(targets) {\n-                        let val = Const::from_bytes(bx.cx, value, switch_ty);\n+                        let llval = C_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n-                        bx.add_case(switch, val.llval, llbb)\n+                        bx.add_case(switch, llval, llbb)\n                     }\n                 }\n             }\n@@ -359,10 +358,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n                         let const_err = common::const_to_opt_u128(len, false)\n                             .and_then(|len| common::const_to_opt_u128(index, false)\n-                                .map(|index| ErrKind::IndexOutOfBounds {\n-                                    len: len as u64,\n-                                    index: index as u64\n-                                }));\n+                                .map(|index| format!(\n+                                    \"index out of bounds: the len is {} but the index is {}\",\n+                                    len, index,\n+                                )));\n \n                         let file_line_col = C_struct(bx.cx, &[filename, line, col], false);\n                         let file_line_col = consts::addr_of(bx.cx,\n@@ -385,7 +384,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                                                 \"panic_loc\");\n                         (lang_items::PanicFnLangItem,\n                          vec![msg_file_line_col],\n-                         Some(ErrKind::Math(err.clone())))\n+                         Some(err.description().to_owned()))\n                     }\n                     mir::AssertMessage::GeneratorResumedAfterReturn |\n                     mir::AssertMessage::GeneratorResumedAfterPanic => {\n@@ -413,10 +412,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 // is also constant, then we can produce a warning.\n                 if const_cond == Some(!expected) {\n                     if let Some(err) = const_err {\n-                        let err = ConstEvalErr{ span: span, kind: err };\n                         let mut diag = bx.tcx().sess.struct_span_warn(\n-                            span, \"this expression will panic at run-time\");\n-                        err.note(bx.tcx(), span, \"expression\", &mut diag);\n+                            span, &format!(\n+                                \"this expression will panic at run-time with {:?}\",\n+                                err,\n+                            ));\n                         diag.emit();\n                     }\n                 }\n@@ -530,10 +530,13 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                     span_bug!(span, \"shuffle indices must be constant\");\n                                 }\n                                 mir::Operand::Constant(ref constant) => {\n-                                    let val = self.trans_constant(&bx, constant);\n+                                    let (llval, ty) = self.remove_me_shuffle_indices(\n+                                        &bx,\n+                                        constant,\n+                                    );\n                                     return OperandRef {\n-                                        val: Immediate(val.llval),\n-                                        layout: bx.cx.layout_of(val.ty)\n+                                        val: Immediate(llval),\n+                                        layout: bx.cx.layout_of(ty)\n                                     };\n                                 }\n                             }"}, {"sha": "5050628b024dba5e4e12df1f138407ece9cc0c3c", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 223, "deletions": 1201, "changes": 1424, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -9,966 +9,27 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n-use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n-use rustc_const_math::{ConstInt, ConstMathErr, MAX_F32_PLUS_HALF_ULP};\n+use rustc_const_math::{ConstInt, ConstMathErr};\n+use rustc::middle::const_val::{ConstVal, ConstEvalErr};\n+use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n-use rustc::infer::TransNormalize;\n use rustc::traits;\n use rustc::mir;\n-use rustc::mir::interpret::{Value as MiriValue, PrimVal};\n-use rustc::mir::tcx::PlaceTy;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutOf, Size};\n-use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc_apfloat::{ieee, Float, Status};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc::mir::interpret::{Allocation, GlobalId, MemoryPointer, PrimVal, Value as MiriValue};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar};\n use base;\n-use abi::{self, Abi};\n-use callee;\n use builder::Builder;\n-use common::{self, CodegenCx, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_uint_big, C_u32, C_u64};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, C_fat_ptr};\n+use common::{CodegenCx};\n+use common::{C_bytes, C_struct, C_uint_big, C_undef, C_usize};\n use common::const_to_opt_u128;\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n-use value::Value;\n \n-use syntax_pos::Span;\n-use syntax::ast;\n-use syntax::symbol::Symbol;\n-\n-use std::fmt;\n-use std::ptr;\n-\n-use super::operand::{OperandRef, OperandValue};\n-use super::FunctionCx;\n-\n-/// A sized constant rvalue.\n-/// The LLVM type might not be the same for a single Rust type,\n-/// e.g. each enum variant would have its own LLVM struct type.\n-#[derive(Copy, Clone)]\n-pub struct Const<'tcx> {\n-    pub llval: ValueRef,\n-    pub ty: Ty<'tcx>\n-}\n-\n-impl<'a, 'tcx> Const<'tcx> {\n-    pub fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n-        Const {\n-            llval,\n-            ty,\n-        }\n-    }\n-\n-    pub fn from_bytes(ccx: &CrateContext<'a, 'tcx>, b: u128, ty: Ty<'tcx>) -> Const<'tcx> {\n-        let llval = match ty.sty {\n-            ty::TyInt(ast::IntTy::I128) |\n-            ty::TyUint(ast::UintTy::U128) => C_uint_big(Type::i128(ccx), b),\n-            ty::TyInt(i) => C_int(Type::int_from_ty(ccx, i), b as i128 as i64),\n-            ty::TyUint(u) => C_uint(Type::uint_from_ty(ccx, u), b as u64),\n-            ty::TyBool => {\n-                assert!(b <= 1);\n-                C_bool(ccx, b == 1)\n-            },\n-            ty::TyChar => {\n-                assert_eq!(b as u32 as u128, b);\n-                let c = b as u32;\n-                assert!(::std::char::from_u32(c).is_some());\n-                C_uint(Type::char(ccx), c as u64)\n-            },\n-            ty::TyFloat(fty) => {\n-                let llty = ccx.layout_of(ty).llvm_type(ccx);\n-                let bits = match fty {\n-                    ast::FloatTy::F32 => C_u32(ccx, b as u32),\n-                    ast::FloatTy::F64 => C_u64(ccx, b as u64),\n-                };\n-                consts::bitcast(bits, llty)\n-            },\n-            ty::TyAdt(adt, _) if adt.is_enum() => {\n-                use rustc::ty::util::IntTypeExt;\n-                Const::from_bytes(ccx, b, adt.repr.discr_type().to_ty(ccx.tcx())).llval\n-            },\n-            _ => bug!(\"from_bytes({}, {})\", b, ty),\n-        };\n-        Const { llval, ty }\n-    }\n-\n-    /// Translate ConstVal into a LLVM constant value.\n-    pub fn from_constval(cx: &CodegenCx<'a, 'tcx>,\n-                         cv: &ConstVal,\n-                         ty: Ty<'tcx>)\n-                         -> Const<'tcx> {\n-        let llty = cx.layout_of(ty).llvm_type(cx);\n-        trace!(\"from_constval: {:#?}: {}\", cv, ty);\n-        let val = match *cv {\n-            ConstVal::Unevaluated(..) => unimplemented!(\"const val `{:?}`\", cv),\n-            ConstVal::Value(MiriValue::ByRef(..)) => unimplemented!(\"{:#?}:{}\", cv, ty),\n-            ConstVal::Value(MiriValue::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len))) => {\n-                match ty.sty {\n-                    ty::TyRef(_, ref tam) => match tam.ty.sty {\n-                        ty::TyStr => {},\n-                        _ => unimplemented!(\"non-str fat pointer: {:?}: {:?}\", ptr, ty),\n-                    },\n-                    _ => unimplemented!(\"non-str fat pointer: {:?}: {:?}\", ptr, ty),\n-                }\n-                let alloc = ccx\n-                    .tcx()\n-                    .interpret_interner\n-                    .borrow()\n-                    .get_alloc(ptr.alloc_id)\n-                    .expect(\"miri alloc not found\");\n-                assert_eq!(len as usize as u128, len);\n-                let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n-                let s = ::std::str::from_utf8(slice)\n-                    .expect(\"non utf8 str from miri\");\n-                C_str_slice(ccx, Symbol::intern(s).as_str())\n-            },\n-            ConstVal::Value(MiriValue::ByValPair(..)) => unimplemented!(),\n-            ConstVal::Value(MiriValue::ByVal(PrimVal::Bytes(b))) =>\n-                return Const::from_bytes(ccx, b, ty),\n-            ConstVal::Value(MiriValue::ByVal(PrimVal::Undef)) => C_undef(llty),\n-            ConstVal::Value(MiriValue::ByVal(PrimVal::Ptr(ptr))) => {\n-                let alloc = ccx\n-                    .tcx()\n-                    .interpret_interner\n-                    .borrow()\n-                    .get_alloc(ptr.alloc_id)\n-                    .expect(\"miri alloc not found\");\n-                let data = &alloc.bytes[(ptr.offset as usize)..];\n-                consts::addr_of(ccx, C_bytes(ccx, data), ccx.align_of(ty), \"byte_str\")\n-            }\n-        };\n-\n-        assert!(!ty.has_erasable_regions());\n-\n-        Const::new(val, ty)\n-    }\n-\n-    fn get_field(&self, cx: &CodegenCx<'a, 'tcx>, i: usize) -> ValueRef {\n-        let layout = cx.layout_of(self.ty);\n-        let field = layout.field(cx, i);\n-        if field.is_zst() {\n-            return C_undef(field.immediate_llvm_type(cx));\n-        }\n-        let offset = layout.fields.offset(i);\n-        match layout.abi {\n-            layout::Abi::Scalar(_) |\n-            layout::Abi::ScalarPair(..) |\n-            layout::Abi::Vector { .. }\n-                if offset.bytes() == 0 && field.size == layout.size => self.llval,\n-\n-            layout::Abi::ScalarPair(ref a, ref b) => {\n-                if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(cx));\n-                    const_get_elt(self.llval, 0)\n-                } else {\n-                    assert_eq!(offset, a.value.size(cx)\n-                        .abi_align(b.value.align(cx)));\n-                    assert_eq!(field.size, b.value.size(cx));\n-                    const_get_elt(self.llval, 1)\n-                }\n-            }\n-            _ => {\n-                match layout.fields {\n-                    layout::FieldPlacement::Union(_) => self.llval,\n-                    _ => const_get_elt(self.llval, layout.llvm_field_index(i)),\n-                }\n-            }\n-        }\n-    }\n-\n-    fn get_pair(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n-        (self.get_field(cx, 0), self.get_field(cx, 1))\n-    }\n-\n-    fn get_fat_ptr(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n-        assert_eq!(abi::FAT_PTR_ADDR, 0);\n-        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.get_pair(cx)\n-    }\n-\n-    fn as_place(&self) -> ConstPlace<'tcx> {\n-        ConstPlace {\n-            base: Base::Value(self.llval),\n-            llextra: ptr::null_mut(),\n-            ty: self.ty\n-        }\n-    }\n-\n-    pub fn to_operand(&self, cx: &CodegenCx<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let layout = cx.layout_of(self.ty);\n-        let llty = layout.immediate_llvm_type(cx);\n-        let llvalty = val_ty(self.llval);\n-\n-        let val = if llty == llvalty && layout.is_llvm_scalar_pair() {\n-            OperandValue::Pair(\n-                const_get_elt(self.llval, 0),\n-                const_get_elt(self.llval, 1))\n-        } else if llty == llvalty && layout.is_llvm_immediate() {\n-            // If the types match, we can use the value directly.\n-            OperandValue::Immediate(self.llval)\n-        } else {\n-            // Otherwise, or if the value is not immediate, we create\n-            // a constant LLVM global and cast its address if necessary.\n-            let align = cx.align_of(self.ty);\n-            let ptr = consts::addr_of(cx, self.llval, align, \"const\");\n-            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(cx).ptr_to()),\n-                              layout.align)\n-        };\n-\n-        OperandRef {\n-            val,\n-            layout\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for Const<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Const({:?}: {:?})\", Value(self.llval), self.ty)\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-enum Base {\n-    /// A constant value without an unique address.\n-    Value(ValueRef),\n-\n-    /// String literal base pointer (cast from array).\n-    Str(ValueRef),\n-\n-    /// The address of a static.\n-    Static(ValueRef)\n-}\n-\n-/// A place as seen from a constant.\n-#[derive(Copy, Clone)]\n-struct ConstPlace<'tcx> {\n-    base: Base,\n-    llextra: ValueRef,\n-    ty: Ty<'tcx>\n-}\n-\n-impl<'tcx> ConstPlace<'tcx> {\n-    fn to_const(&self, span: Span) -> Const<'tcx> {\n-        match self.base {\n-            Base::Value(val) => Const::new(val, self.ty),\n-            Base::Str(ptr) => {\n-                span_bug!(span, \"loading from `str` ({:?}) in constant\",\n-                          Value(ptr))\n-            }\n-            Base::Static(val) => {\n-                span_bug!(span, \"loading from `static` ({:?}) in constant\",\n-                          Value(val))\n-            }\n-        }\n-    }\n-\n-    pub fn len<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n-        match self.ty.sty {\n-            ty::TyArray(_, n) => {\n-                C_usize(cx, n.val.unwrap_u64())\n-            }\n-            ty::TySlice(_) | ty::TyStr => {\n-                assert!(self.llextra != ptr::null_mut());\n-                self.llextra\n-            }\n-            _ => bug!(\"unexpected type `{}` in ConstPlace::len\", self.ty)\n-        }\n-    }\n-}\n-\n-/// Machinery for translating a constant's MIR to LLVM values.\n-/// FIXME(eddyb) use miri and lower its allocations to LLVM.\n-struct MirConstContext<'a, 'tcx: 'a> {\n-    cx: &'a CodegenCx<'a, 'tcx>,\n-    mir: &'a mir::Mir<'tcx>,\n-\n-    /// Type parameters for const fn and associated constants.\n-    substs: &'tcx Substs<'tcx>,\n-\n-    /// Values of locals in a constant or const fn.\n-    locals: IndexVec<mir::Local, Option<Result<Const<'tcx>, ConstEvalErr<'tcx>>>>\n-}\n-\n-fn add_err<'tcx, U, V>(failure: &mut Result<U, ConstEvalErr<'tcx>>,\n-                       value: &Result<V, ConstEvalErr<'tcx>>)\n-{\n-    if let &Err(ref err) = value {\n-        if failure.is_ok() {\n-            *failure = Err(err.clone());\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n-    fn new(cx: &'a CodegenCx<'a, 'tcx>,\n-           mir: &'a mir::Mir<'tcx>,\n-           substs: &'tcx Substs<'tcx>,\n-           args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n-           -> MirConstContext<'a, 'tcx> {\n-        let mut context = MirConstContext {\n-            cx,\n-            mir,\n-            substs,\n-            locals: (0..mir.local_decls.len()).map(|_| None).collect(),\n-        };\n-        for (i, arg) in args.into_iter().enumerate() {\n-            // Locals after local 0 are the function arguments\n-            let index = mir::Local::new(i + 1);\n-            context.locals[index] = Some(arg);\n-        }\n-        context\n-    }\n-\n-    fn trans_def(cx: &'a CodegenCx<'a, 'tcx>,\n-                 def_id: DefId,\n-                 substs: &'tcx Substs<'tcx>,\n-                 args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n-                 -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = ty::Instance::resolve(cx.tcx,\n-                                             ty::ParamEnv::empty(traits::Reveal::All),\n-                                             def_id,\n-                                             substs).unwrap();\n-        let mir = cx.tcx.instance_mir(instance.def);\n-        MirConstContext::new(cx, &mir, instance.substs, args).trans()\n-    }\n-\n-    fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        self.cx.tcx.trans_apply_param_substs(self.substs, value)\n-    }\n-\n-    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.cx.tcx;\n-        let mut bb = mir::START_BLOCK;\n-\n-        // Make sure to evaluate all statements to\n-        // report as many errors as we possibly can.\n-        let mut failure = Ok(());\n-\n-        loop {\n-            let data = &self.mir[bb];\n-            for statement in &data.statements {\n-                let span = statement.source_info.span;\n-                match statement.kind {\n-                    mir::StatementKind::Assign(ref dest, ref rvalue) => {\n-                        let ty = dest.ty(self.mir, tcx);\n-                        let ty = self.monomorphize(&ty).to_ty(tcx);\n-                        let value = self.const_rvalue(rvalue, ty, span);\n-                        add_err(&mut failure, &value);\n-                        self.store(dest, value, span);\n-                    }\n-                    mir::StatementKind::StorageLive(_) |\n-                    mir::StatementKind::StorageDead(_) |\n-                    mir::StatementKind::Validate(..) |\n-                    mir::StatementKind::EndRegion(_) |\n-                    mir::StatementKind::Nop => {}\n-                    mir::StatementKind::InlineAsm { .. } |\n-                    mir::StatementKind::SetDiscriminant{ .. } => {\n-                        span_bug!(span, \"{:?} should not appear in constants?\", statement.kind);\n-                    }\n-                }\n-            }\n-\n-            let terminator = data.terminator();\n-            let span = terminator.source_info.span;\n-            bb = match terminator.kind {\n-                mir::TerminatorKind::Drop { target, .. } | // No dropping.\n-                mir::TerminatorKind::Goto { target } => target,\n-                mir::TerminatorKind::Return => {\n-                    failure?;\n-                    return self.locals[mir::RETURN_PLACE].clone().unwrap_or_else(|| {\n-                        span_bug!(span, \"no returned value in constant\");\n-                    });\n-                }\n-\n-                mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, .. } => {\n-                    let cond = self.const_operand(cond, span)?;\n-                    let cond_bool = common::const_to_uint(cond.llval) != 0;\n-                    if cond_bool != expected {\n-                        let err = match *msg {\n-                            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                                let len = self.const_operand(len, span)?;\n-                                let index = self.const_operand(index, span)?;\n-                                ErrKind::IndexOutOfBounds {\n-                                    len: common::const_to_uint(len.llval),\n-                                    index: common::const_to_uint(index.llval)\n-                                }\n-                            }\n-                            mir::AssertMessage::Math(ref err) => {\n-                                ErrKind::Math(err.clone())\n-                            }\n-                            mir::AssertMessage::GeneratorResumedAfterReturn |\n-                            mir::AssertMessage::GeneratorResumedAfterPanic =>\n-                                span_bug!(span, \"{:?} should not appear in constants?\", msg),\n-                        };\n-\n-                        let err = ConstEvalErr { span: span, kind: err };\n-                        err.report(tcx, span, \"expression\");\n-                        failure = Err(err);\n-                    }\n-                    target\n-                }\n-\n-                mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                    let fn_ty = func.ty(self.mir, tcx);\n-                    let fn_ty = self.monomorphize(&fn_ty);\n-                    let (def_id, substs) = match fn_ty.sty {\n-                        ty::TyFnDef(def_id, substs) => (def_id, substs),\n-                        _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n-                                       func, fn_ty)\n-                    };\n-                    trace!(\"trans const fn call {:?}, {:?}, {:#?}\", func, fn_ty, args);\n-\n-                    let mut arg_vals = IndexVec::with_capacity(args.len());\n-                    for arg in args {\n-                        let arg_val = self.const_operand(arg, span);\n-                        add_err(&mut failure, &arg_val);\n-                        arg_vals.push(arg_val);\n-                    }\n-                    if let Some((ref dest, target)) = *destination {\n-                        let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n-                            match &tcx.item_name(def_id)[..] {\n-                                \"size_of\" => {\n-                                    let llval = C_usize(self.cx,\n-                                        self.cx.size_of(substs.type_at(0)).bytes());\n-                                    Ok(Const::new(llval, tcx.types.usize))\n-                                }\n-                                \"min_align_of\" => {\n-                                    let llval = C_usize(self.cx,\n-                                        self.cx.align_of(substs.type_at(0)).abi());\n-                                    Ok(Const::new(llval, tcx.types.usize))\n-                                }\n-                                \"type_id\" => {\n-                                    let llval = C_u64(self.cx,\n-                                        self.cx.tcx.type_id_hash(substs.type_at(0)));\n-                                    Ok(Const::new(llval, tcx.types.u64))\n-                                }\n-                                _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n-                            }\n-                        } else if let Some((op, is_checked)) = tcx.is_binop_lang_item(def_id) {\n-                            (||{\n-                                assert_eq!(arg_vals.len(), 2);\n-                                let rhs = arg_vals.pop().unwrap()?;\n-                                let lhs = arg_vals.pop().unwrap()?;\n-                                if !is_checked {\n-                                    let binop_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                                    let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                                    Ok(Const::new(const_scalar_binop(op, lhs, rhs, binop_ty),\n-                                                  binop_ty))\n-                                } else {\n-                                    let ty = lhs.ty;\n-                                    let val_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                                    let binop_ty = tcx.intern_tup(&[val_ty, tcx.types.bool], false);\n-                                    let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                                    assert!(!ty.is_fp());\n-\n-                                    match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n-                                        Some((llval, of)) => {\n-                                            Ok(trans_const_adt(\n-                                                self.cx,\n-                                                binop_ty,\n-                                                &mir::AggregateKind::Tuple,\n-                                                &[\n-                                                    Const::new(llval, val_ty),\n-                                                    Const::new(C_bool(self.cx, of), tcx.types.bool)\n-                                                ]))\n-                                        }\n-                                        None => {\n-                                            span_bug!(span,\n-                                                \"{:?} got non-integer operands: {:?} and {:?}\",\n-                                                op, Value(lhs), Value(rhs));\n-                                        }\n-                                    }\n-                                }\n-                            })()\n-                        } else {\n-                            MirConstContext::trans_def(self.cx, def_id, substs, arg_vals)\n-                        };\n-                        add_err(&mut failure, &result);\n-                        self.store(dest, result, span);\n-                        target\n-                    } else {\n-                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind);\n-                    }\n-                }\n-                _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n-            };\n-        }\n-    }\n-\n-    fn store(&mut self,\n-             dest: &mir::Place<'tcx>,\n-             value: Result<Const<'tcx>, ConstEvalErr<'tcx>>,\n-             span: Span) {\n-        if let mir::Place::Local(index) = *dest {\n-            self.locals[index] = Some(value);\n-        } else {\n-            span_bug!(span, \"assignment to {:?} in constant\", dest);\n-        }\n-    }\n-\n-    fn const_place(&self, place: &mir::Place<'tcx>, span: Span)\n-                    -> Result<ConstPlace<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.cx.tcx;\n-\n-        if let mir::Place::Local(index) = *place {\n-            return self.locals[index].clone().unwrap_or_else(|| {\n-                span_bug!(span, \"{:?} not initialized\", place)\n-            }).map(|v| v.as_place());\n-        }\n-\n-        let place = match *place {\n-            mir::Place::Local(_)  => bug!(), // handled above\n-            mir::Place::Static(box mir::Static { def_id, ty }) => {\n-                ConstPlace {\n-                    base: Base::Static(consts::get_static(self.cx, def_id)),\n-                    llextra: ptr::null_mut(),\n-                    ty: self.monomorphize(&ty),\n-                }\n-            }\n-            mir::Place::Projection(ref projection) => {\n-                let tr_base = self.const_place(&projection.base, span)?;\n-                let projected_ty = PlaceTy::Ty { ty: tr_base.ty }\n-                    .projection_ty(tcx, &projection.elem);\n-                let base = tr_base.to_const(span);\n-                let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n-                let has_metadata = self.cx.type_has_metadata(projected_ty);\n-\n-                let (projected, llextra) = match projection.elem {\n-                    mir::ProjectionElem::Deref => {\n-                        let (base, extra) = if !has_metadata {\n-                            (base.llval, ptr::null_mut())\n-                        } else {\n-                            base.get_fat_ptr(self.cx)\n-                        };\n-                        if self.cx.statics.borrow().contains_key(&base) {\n-                            (Base::Static(base), extra)\n-                        } else if let ty::TyStr = projected_ty.sty {\n-                            (Base::Str(base), extra)\n-                        } else {\n-                            let v = base;\n-                            let v = self.cx.const_unsized.borrow().get(&v).map_or(v, |&v| v);\n-                            let mut val = unsafe { llvm::LLVMGetInitializer(v) };\n-                            if val.is_null() {\n-                                span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n-                                          Value(base));\n-                            }\n-                            let layout = self.cx.layout_of(projected_ty);\n-                            if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-                                let i1_type = Type::i1(self.cx);\n-                                if scalar.is_bool() && val_ty(val) != i1_type {\n-                                    unsafe {\n-                                        val = llvm::LLVMConstTrunc(val, i1_type.to_ref());\n-                                    }\n-                                }\n-                            }\n-                            (Base::Value(val), extra)\n-                        }\n-                    }\n-                    mir::ProjectionElem::Field(ref field, _) => {\n-                        let llprojected = base.get_field(self.cx, field.index());\n-                        let llextra = if !has_metadata {\n-                            ptr::null_mut()\n-                        } else {\n-                            tr_base.llextra\n-                        };\n-                        (Base::Value(llprojected), llextra)\n-                    }\n-                    mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::Local(index));\n-                        let llindex = self.const_operand(index, span)?.llval;\n-\n-                        let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {\n-                            iv\n-                        } else {\n-                            span_bug!(span, \"index is not an integer-constant expression\")\n-                        };\n-\n-                        // Produce an undef instead of a LLVM assertion on OOB.\n-                        let len = common::const_to_uint(tr_base.len(self.cx));\n-                        let llelem = if iv < len as u128 {\n-                            const_get_elt(base.llval, iv as u64)\n-                        } else {\n-                            C_undef(self.cx.layout_of(projected_ty).llvm_type(self.cx))\n-                        };\n-\n-                        (Base::Value(llelem), ptr::null_mut())\n-                    }\n-                    _ => span_bug!(span, \"{:?} in constant\", projection.elem)\n-                };\n-                ConstPlace {\n-                    base: projected,\n-                    llextra,\n-                    ty: projected_ty\n-                }\n-            }\n-        };\n-        Ok(place)\n-    }\n-\n-    fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n-                     -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        debug!(\"const_operand({:?} @ {:?})\", operand, span);\n-        let result = match *operand {\n-            mir::Operand::Copy(ref place) |\n-            mir::Operand::Move(ref place) => {\n-                Ok(self.const_place(place, span)?.to_const(span))\n-            }\n-\n-            mir::Operand::Constant(ref constant) => {\n-                let ty = self.monomorphize(&constant.ty);\n-                match constant.literal.clone() {\n-                    mir::Literal::Promoted { index } => {\n-                        let mir = &self.mir.promoted[index];\n-                        MirConstContext::new(self.cx, mir, self.substs, IndexVec::new()).trans()\n-                    }\n-                    mir::Literal::Value { value } => {\n-                        if let ConstVal::Unevaluated(def_id, substs) = value.val {\n-                            let substs = self.monomorphize(&substs);\n-                            MirConstContext::trans_def(self.cx, def_id, substs, IndexVec::new())\n-                        } else {\n-                            Ok(Const::from_constval(self.cx, &value.val, ty))\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-        debug!(\"const_operand({:?} @ {:?}) = {:?}\", operand, span,\n-               result.as_ref().ok());\n-        result\n-    }\n-\n-    fn const_array(&self, array_ty: Ty<'tcx>, fields: &[ValueRef])\n-                   -> Const<'tcx>\n-    {\n-        let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n-            bug!(\"bad array type {:?}\", array_ty)\n-        });\n-        let llunitty = self.cx.layout_of(elem_ty).llvm_type(self.cx);\n-        // If the array contains enums, an LLVM array won't work.\n-        let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n-            C_array(llunitty, fields)\n-        } else {\n-            C_struct(self.cx, fields, false)\n-        };\n-        Const::new(val, array_ty)\n-    }\n-\n-    fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n-                    dest_ty: Ty<'tcx>, span: Span)\n-                    -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.cx.tcx;\n-        debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n-        let val = match *rvalue {\n-            mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n-\n-            mir::Rvalue::Repeat(ref elem, count) => {\n-                let elem = self.const_operand(elem, span)?;\n-                let size = count.as_u64();\n-                assert_eq!(size as usize as u64, size);\n-                let fields = vec![elem.llval; size as usize];\n-                self.const_array(dest_ty, &fields)\n-            }\n-\n-            mir::Rvalue::Aggregate(box mir::AggregateKind::Array(_), ref operands) => {\n-                // Make sure to evaluate all operands to\n-                // report as many errors as we possibly can.\n-                let mut fields = Vec::with_capacity(operands.len());\n-                let mut failure = Ok(());\n-                for operand in operands {\n-                    match self.const_operand(operand, span) {\n-                        Ok(val) => fields.push(val.llval),\n-                        Err(err) => if failure.is_ok() { failure = Err(err); }\n-                    }\n-                }\n-                failure?;\n-\n-                self.const_array(dest_ty, &fields)\n-            }\n-\n-            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                // Make sure to evaluate all operands to\n-                // report as many errors as we possibly can.\n-                let mut fields = Vec::with_capacity(operands.len());\n-                let mut failure = Ok(());\n-                for operand in operands {\n-                    match self.const_operand(operand, span) {\n-                        Ok(val) => fields.push(val),\n-                        Err(err) => if failure.is_ok() { failure = Err(err); }\n-                    }\n-                }\n-                failure?;\n-\n-                trans_const_adt(self.cx, dest_ty, kind, &fields)\n-            }\n-\n-            mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n-                let operand = self.const_operand(source, span)?;\n-                let cast_ty = self.monomorphize(&cast_ty);\n-\n-                let val = match *kind {\n-                    mir::CastKind::ReifyFnPointer => {\n-                        match operand.ty.sty {\n-                            ty::TyFnDef(def_id, substs) => {\n-                                if tcx.has_attr(def_id, \"rustc_args_required_const\") {\n-                                    bug!(\"reifying a fn ptr that requires \\\n-                                          const arguments\");\n-                                }\n-                                callee::resolve_and_get_fn(self.cx, def_id, substs)\n-                            }\n-                            _ => {\n-                                span_bug!(span, \"{} cannot be reified to a fn ptr\",\n-                                          operand.ty)\n-                            }\n-                        }\n-                    }\n-                    mir::CastKind::ClosureFnPointer => {\n-                        match operand.ty.sty {\n-                            ty::TyClosure(def_id, substs) => {\n-                                // Get the def_id for FnOnce::call_once\n-                                let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n-                                let call_once = tcx\n-                                    .global_tcx().associated_items(fn_once)\n-                                    .find(|it| it.kind == ty::AssociatedKind::Method)\n-                                    .unwrap().def_id;\n-                                // Now create its substs [Closure, Tuple]\n-                                let input = substs.closure_sig(def_id, tcx).input(0);\n-                                let input = tcx.erase_late_bound_regions_and_normalize(&input);\n-                                let substs = tcx.mk_substs([operand.ty, input]\n-                                    .iter().cloned().map(Kind::from));\n-                                callee::resolve_and_get_fn(self.cx, call_once, substs)\n-                            }\n-                            _ => {\n-                                bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n-                            }\n-                        }\n-                    }\n-                    mir::CastKind::UnsafeFnPointer => {\n-                        // this is a no-op at the LLVM level\n-                        operand.llval\n-                    }\n-                    mir::CastKind::Unsize => {\n-                        let pointee_ty = operand.ty.builtin_deref(true)\n-                            .expect(\"consts: unsizing got non-pointer type\").ty;\n-                        let (base, old_info) = if !self.cx.type_is_sized(pointee_ty) {\n-                            // Normally, the source is a thin pointer and we are\n-                            // adding extra info to make a fat pointer. The exception\n-                            // is when we are upcasting an existing object fat pointer\n-                            // to use a different vtable. In that case, we want to\n-                            // load out the original data pointer so we can repackage\n-                            // it.\n-                            let (base, extra) = operand.get_fat_ptr(self.cx);\n-                            (base, Some(extra))\n-                        } else {\n-                            (operand.llval, None)\n-                        };\n-\n-                        let unsized_ty = cast_ty.builtin_deref(true)\n-                            .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                        let ptr_ty = self.cx.layout_of(unsized_ty).llvm_type(self.cx).ptr_to();\n-                        let base = consts::ptrcast(base, ptr_ty);\n-                        let info = base::unsized_info(self.cx, pointee_ty,\n-                                                      unsized_ty, old_info);\n-\n-                        if old_info.is_none() {\n-                            let prev_const = self.cx.const_unsized.borrow_mut()\n-                                                     .insert(base, operand.llval);\n-                            assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n-                        }\n-                        C_fat_ptr(self.cx, base, info)\n-                    }\n-                    mir::CastKind::Misc if self.cx.layout_of(operand.ty).is_llvm_immediate() => {\n-                        let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n-                        let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let cast_layout = self.cx.layout_of(cast_ty);\n-                        assert!(cast_layout.is_llvm_immediate());\n-                        let ll_t_out = cast_layout.immediate_llvm_type(self.cx);\n-                        let llval = operand.llval;\n-\n-                        let mut signed = false;\n-                        let l = self.cx.layout_of(operand.ty);\n-                        if let layout::Abi::Scalar(ref scalar) = l.abi {\n-                            if let layout::Int(_, true) = scalar.value {\n-                                signed = true;\n-                            }\n-                        }\n-\n-                        unsafe {\n-                            match (r_t_in, r_t_out) {\n-                                (CastTy::Int(_), CastTy::Int(_)) => {\n-                                    let s = signed as llvm::Bool;\n-                                    llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n-                                }\n-                                (CastTy::Int(_), CastTy::Float) => {\n-                                    cast_const_int_to_float(self.cx, llval, signed, ll_t_out)\n-                                }\n-                                (CastTy::Float, CastTy::Float) => {\n-                                    llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n-                                }\n-                                (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                    cast_const_float_to_int(self.cx, &operand,\n-                                                            true, ll_t_out, span)\n-                                }\n-                                (CastTy::Float, CastTy::Int(_)) => {\n-                                    cast_const_float_to_int(self.cx, &operand,\n-                                                            false, ll_t_out, span)\n-                                }\n-                                (CastTy::Ptr(_), CastTy::Ptr(_)) |\n-                                (CastTy::FnPtr, CastTy::Ptr(_)) |\n-                                (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n-                                    consts::ptrcast(llval, ll_t_out)\n-                                }\n-                                (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                    let s = signed as llvm::Bool;\n-                                    let usize_llval = llvm::LLVMConstIntCast(llval,\n-                                        self.cx.isize_ty.to_ref(), s);\n-                                    llvm::LLVMConstIntToPtr(usize_llval, ll_t_out.to_ref())\n-                                }\n-                                (CastTy::Ptr(_), CastTy::Int(_)) |\n-                                (CastTy::FnPtr, CastTy::Int(_)) => {\n-                                    llvm::LLVMConstPtrToInt(llval, ll_t_out.to_ref())\n-                                }\n-                                _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n-                            }\n-                        }\n-                    }\n-                    mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let l = self.cx.layout_of(operand.ty);\n-                        let cast = self.cx.layout_of(cast_ty);\n-                        if l.is_llvm_scalar_pair() {\n-                            let (data_ptr, meta) = operand.get_fat_ptr(self.cx);\n-                            if cast.is_llvm_scalar_pair() {\n-                                let data_cast = consts::ptrcast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(self.cx, 0));\n-                                C_fat_ptr(self.cx, data_cast, meta)\n-                            } else { // cast to thin-ptr\n-                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n-                                // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(self.cx);\n-                                consts::ptrcast(data_ptr, llcast_ty)\n-                            }\n-                        } else {\n-                            bug!(\"Unexpected non-fat-pointer operand\")\n-                        }\n-                    }\n-                };\n-                Const::new(val, cast_ty)\n-            }\n-\n-            mir::Rvalue::Ref(_, bk, ref place) => {\n-                let tr_place = self.const_place(place, span)?;\n-\n-                let ty = tr_place.ty;\n-                let ref_ty = tcx.mk_ref(tcx.types.re_erased,\n-                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() });\n-\n-                let base = match tr_place.base {\n-                    Base::Value(llval) => {\n-                        // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n-                        let align = if self.cx.type_is_sized(ty) {\n-                            self.cx.align_of(ty)\n-                        } else {\n-                            self.cx.tcx.data_layout.pointer_align\n-                        };\n-                        if let mir::BorrowKind::Mut { .. } = bk {\n-                            consts::addr_of_mut(self.cx, llval, align, \"ref_mut\")\n-                        } else {\n-                            consts::addr_of(self.cx, llval, align, \"ref\")\n-                        }\n-                    }\n-                    Base::Str(llval) |\n-                    Base::Static(llval) => llval\n-                };\n-\n-                let ptr = if self.cx.type_is_sized(ty) {\n-                    base\n-                } else {\n-                    C_fat_ptr(self.cx, base, tr_place.llextra)\n-                };\n-                Const::new(ptr, ref_ty)\n-            }\n-\n-            mir::Rvalue::Len(ref place) => {\n-                let tr_place = self.const_place(place, span)?;\n-                Const::new(tr_place.len(self.cx), tcx.types.usize)\n-            }\n-\n-            mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.const_operand(lhs, span)?;\n-                let rhs = self.const_operand(rhs, span)?;\n-                let ty = lhs.ty;\n-                let binop_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                Const::new(const_scalar_binop(op, lhs, rhs, ty), binop_ty)\n-            }\n-\n-            mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.const_operand(lhs, span)?;\n-                let rhs = self.const_operand(rhs, span)?;\n-                let ty = lhs.ty;\n-                let val_ty = op.ty(tcx, lhs.ty, rhs.ty);\n-                let binop_ty = tcx.intern_tup(&[val_ty, tcx.types.bool], false);\n-                let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                assert!(!ty.is_fp());\n-\n-                match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n-                    Some((llval, of)) => {\n-                        trans_const_adt(self.cx, binop_ty, &mir::AggregateKind::Tuple, &[\n-                            Const::new(llval, val_ty),\n-                            Const::new(C_bool(self.cx, of), tcx.types.bool)\n-                        ])\n-                    }\n-                    None => {\n-                        span_bug!(span, \"{:?} got non-integer operands: {:?} and {:?}\",\n-                                  rvalue, Value(lhs), Value(rhs));\n-                    }\n-                }\n-            }\n-\n-            mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.const_operand(operand, span)?;\n-                let lloperand = operand.llval;\n-                let llval = match op {\n-                    mir::UnOp::Not => {\n-                        unsafe {\n-                            llvm::LLVMConstNot(lloperand)\n-                        }\n-                    }\n-                    mir::UnOp::Neg => {\n-                        let is_float = operand.ty.is_fp();\n-                        unsafe {\n-                            if is_float {\n-                                llvm::LLVMConstFNeg(lloperand)\n-                            } else {\n-                                llvm::LLVMConstNeg(lloperand)\n-                            }\n-                        }\n-                    }\n-                };\n-                Const::new(llval, operand.ty)\n-            }\n-\n-            mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(self.cx.type_is_sized(ty));\n-                let llval = C_usize(self.cx, self.cx.size_of(ty).bytes());\n-                Const::new(llval, tcx.types.usize)\n-            }\n-\n-            _ => span_bug!(span, \"{:?} in constant\", rvalue)\n-        };\n-\n-        debug!(\"const_rvalue({:?}: {:?} @ {:?}) = {:?}\", rvalue, dest_ty, span, val);\n-\n-        Ok(val)\n-    }\n-\n-}\n+use super::super::callee;\n+use super::MirContext;\n \n fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n@@ -1074,278 +135,239 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-unsafe fn cast_const_float_to_int(cx: &CodegenCx,\n-                                  operand: &Const,\n-                                  signed: bool,\n-                                  int_ty: Type,\n-                                  span: Span) -> ValueRef {\n-    let llval = operand.llval;\n-    let float_bits = match operand.ty.sty {\n-        ty::TyFloat(fty) => fty.bit_width(),\n-        _ => bug!(\"cast_const_float_to_int: operand not a float\"),\n-    };\n-    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n-    // One way that might happen would be if addresses could be turned into integers in constant\n-    // expressions, but that doesn't appear to be possible?\n-    // In any case, an ICE is better than producing undef.\n-    let llval_bits = consts::bitcast(llval, Type::ix(cx, float_bits as u64));\n-    let bits = const_to_opt_u128(llval_bits, false).unwrap_or_else(|| {\n-        panic!(\"could not get bits of constant float {:?}\",\n-               Value(llval));\n-    });\n-    let int_width = int_ty.int_width() as usize;\n-    // Try to convert, but report an error for overflow and NaN. This matches HIR const eval.\n-    let cast_result = match float_bits {\n-        32 if signed => ieee::Single::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n-        64 if signed => ieee::Double::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n-        32 => ieee::Single::from_bits(bits).to_u128(int_width),\n-        64 => ieee::Double::from_bits(bits).to_u128(int_width),\n-        n => bug!(\"unsupported float width {}\", n),\n-    };\n-    if cast_result.status.contains(Status::INVALID_OP) {\n-        let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n-        err.report(cx.tcx, span, \"expression\");\n-    }\n-    C_uint_big(int_ty, cast_result.value)\n-}\n-\n-unsafe fn cast_const_int_to_float(cx: &CodegenCx,\n-                                  llval: ValueRef,\n-                                  signed: bool,\n-                                  float_ty: Type) -> ValueRef {\n-    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n-    // One way that might happen would be if addresses could be turned into integers in constant\n-    // expressions, but that doesn't appear to be possible?\n-    // In any case, an ICE is better than producing undef.\n-    let value = const_to_opt_u128(llval, signed).unwrap_or_else(|| {\n-        panic!(\"could not get z128 value of constant integer {:?}\",\n-               Value(llval));\n-    });\n-    if signed {\n-        llvm::LLVMConstSIToFP(llval, float_ty.to_ref())\n-    } else if float_ty.float_width() == 32 && value >= MAX_F32_PLUS_HALF_ULP {\n-        // We're casting to f32 and the value is > f32::MAX + 0.5 ULP -> round up to infinity.\n-        let infinity_bits = C_u32(cx, ieee::Single::INFINITY.to_bits() as u32);\n-        consts::bitcast(infinity_bits, float_ty)\n-    } else {\n-        llvm::LLVMConstUIToFP(llval, float_ty.to_ref())\n-    }\n-}\n-\n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    pub fn trans_constant(&mut self,\n-                          bx: &Builder<'a, 'tcx>,\n-                          constant: &mir::Constant<'tcx>)\n-                          -> Const<'tcx>\n-    {\n-        debug!(\"trans_constant({:?})\", constant);\n-        let ty = self.monomorphize(&constant.ty);\n-        let result = match constant.literal.clone() {\n-            mir::Literal::Promoted { index } => {\n-                let mir = &self.mir.promoted[index];\n-                MirConstContext::new(bx.cx, mir, self.param_substs, IndexVec::new()).trans()\n+pub fn primval_to_llvm(ccx: &CrateContext,\n+                       cv: PrimVal,\n+                       scalar: &Scalar,\n+                       llty: Type) -> ValueRef {\n+    let bits = if scalar.is_bool() { 1 } else { scalar.value.size(ccx).bits() };\n+    match cv {\n+        PrimVal::Undef => C_undef(Type::ix(ccx, bits)),\n+        PrimVal::Bytes(b) => {\n+            let llval = C_uint_big(Type::ix(ccx, bits), b);\n+            if scalar.value == layout::Pointer {\n+                unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n+            } else {\n+                consts::bitcast(llval, llty)\n             }\n-            mir::Literal::Value { value } => {\n-                if let ConstVal::Unevaluated(def_id, substs) = value.val {\n-                    let substs = self.monomorphize(&substs);\n-                    MirConstContext::trans_def(bx.cx, def_id, substs, IndexVec::new())\n+        },\n+        PrimVal::Ptr(ptr) => {\n+            let interpret_interner = ccx.tcx().interpret_interner.borrow();\n+            if let Some(fn_instance) = interpret_interner.get_fn(ptr.alloc_id) {\n+                callee::get_fn(ccx, fn_instance)\n+            } else {\n+                let static_ = interpret_interner.get_corresponding_static_def_id(ptr.alloc_id);\n+                let base_addr = if let Some(def_id) = static_ {\n+                    assert!(ccx.tcx().is_static(def_id).is_some());\n+                    consts::get_static(ccx, def_id)\n+                } else if let Some(alloc) = interpret_interner.get_alloc(ptr.alloc_id) {\n+                    let init = global_initializer(ccx, alloc);\n+                    if alloc.mutable {\n+                        consts::addr_of_mut(ccx, init, alloc.align, \"byte_str\")\n+                    } else {\n+                        consts::addr_of(ccx, init, alloc.align, \"byte_str\")\n+                    }\n                 } else {\n-                    Ok(Const::from_constval(bx.cx, &value.val, ty))\n+                    bug!(\"missing allocation {:?}\", ptr.alloc_id);\n+                };\n+\n+                let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                    consts::bitcast(base_addr, Type::i8p(ccx)),\n+                    &C_usize(ccx, ptr.offset),\n+                    1,\n+                ) };\n+                if scalar.value != layout::Pointer {\n+                    unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n+                } else {\n+                    consts::bitcast(llval, llty)\n                 }\n             }\n-        };\n-\n-        let result = result.unwrap_or_else(|_| {\n-            // We've errored, so we don't have to produce working code.\n-            let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n-            Const::new(C_undef(llty), ty)\n-        });\n-\n-        debug!(\"trans_constant({:?}) = {:?}\", constant, result);\n-        result\n+        }\n     }\n }\n \n+pub fn global_initializer(ccx: &CrateContext, alloc: &Allocation) -> ValueRef {\n+    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n+    let layout = ccx.data_layout();\n+    let pointer_size = layout.pointer_size.bytes() as usize;\n+\n+    let mut next_offset = 0;\n+    for (&offset, &alloc_id) in &alloc.relocations {\n+        assert_eq!(offset as usize as u64, offset);\n+        let offset = offset as usize;\n+        if offset > next_offset {\n+            llvals.push(C_bytes(ccx, &alloc.bytes[next_offset..offset]));\n+        }\n+        let ptr_offset = read_target_uint(\n+            layout.endian,\n+            &alloc.bytes[offset..(offset + pointer_size)],\n+        ).expect(\"global_initializer: could not read relocation pointer\") as u64;\n+        llvals.push(primval_to_llvm(\n+            ccx,\n+            PrimVal::Ptr(MemoryPointer { alloc_id, offset: ptr_offset }),\n+            &Scalar {\n+                value: layout::Primitive::Pointer,\n+                valid_range: 0..=!0\n+            },\n+            Type::i8p(ccx)\n+        ));\n+        next_offset = offset + pointer_size;\n+    }\n+    if alloc.bytes.len() >= next_offset {\n+        llvals.push(C_bytes(ccx, &alloc.bytes[next_offset ..]));\n+    }\n+\n+    C_struct(ccx, &llvals, true)\n+}\n \n pub fn trans_static_initializer<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n-    MirConstContext::trans_def(cx, def_id, Substs::empty(), IndexVec::new())\n-        .map(|c| c.llval)\n-}\n-\n-/// Construct a constant value, suitable for initializing a\n-/// GlobalVariable, given a case and constant values for its fields.\n-/// Note that this may have a different LLVM type (and different\n-/// alignment!) from the representation's `type_of`, so it needs a\n-/// pointer cast before use.\n-///\n-/// The LLVM type system does not directly support unions, and only\n-/// pointers can be bitcast, so a constant (and, by extension, the\n-/// GlobalVariable initialized by it) will have a type that can vary\n-/// depending on which case of an enum it is.\n-///\n-/// To understand the alignment situation, consider `enum E { V64(u64),\n-/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n-/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n-/// i32, i32}`, which is 4-byte aligned.\n-///\n-/// Currently the returned value has the same size as the type, but\n-/// this could be changed in the future to avoid allocating unnecessary\n-/// space after values of shorter-than-maximum cases.\n-fn trans_const_adt<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    kind: &mir::AggregateKind,\n-    vals: &[Const<'tcx>]\n-) -> Const<'tcx> {\n-    let l = cx.layout_of(t);\n-    let variant_index = match *kind {\n-        mir::AggregateKind::Adt(_, index, _, _) => index,\n-        _ => 0,\n+    let instance = ty::Instance::mono(ccx.tcx(), def_id);\n+    let cid = GlobalId {\n+        instance,\n+        promoted: None\n     };\n+    let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+    ccx.tcx().const_eval(param_env.and(cid))?;\n+\n+    let alloc_id = ccx\n+        .tcx()\n+        .interpret_interner\n+        .borrow()\n+        .get_cached(def_id)\n+        .expect(\"global not cached\");\n+\n+    let alloc = ccx\n+        .tcx()\n+        .interpret_interner\n+        .borrow()\n+        .get_alloc(alloc_id)\n+        .expect(\"miri allocation never successfully created\");\n+    Ok(global_initializer(ccx, alloc))\n+}\n \n-    if let layout::Abi::Uninhabited = l.abi {\n-        return Const::new(C_undef(l.llvm_type(cx)), t);\n-    }\n-\n-    match l.variants {\n-        layout::Variants::Single { index } => {\n-            assert_eq!(variant_index, index);\n-            if let layout::FieldPlacement::Union(_) = l.fields {\n-                assert_eq!(variant_index, 0);\n-                assert_eq!(vals.len(), 1);\n-                let (field_size, field_align) = cx.size_and_align_of(vals[0].ty);\n-                let contents = [\n-                    vals[0].llval,\n-                    padding(cx, l.size - field_size)\n-                ];\n-\n-                let packed = l.align.abi() < field_align.abi();\n-                Const::new(C_struct(cx, &contents, packed), t)\n-            } else {\n-                if let layout::Abi::Vector { .. } = l.abi {\n-                    if let layout::FieldPlacement::Array { .. } = l.fields {\n-                        return Const::new(C_vector(&vals.iter().map(|x| x.llval)\n-                            .collect::<Vec<_>>()), t);\n-                    }\n-                }\n-                build_const_struct(cx, l, vals, None)\n-            }\n-        }\n-        layout::Variants::Tagged { .. } => {\n-            let discr = match *kind {\n-                mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    adt_def.discriminant_for_variant(cx.tcx, variant_index)\n-                           .to_u128_unchecked() as u64\n-                },\n-                _ => 0,\n-            };\n-            let discr_field = l.field(cx, 0);\n-            let discr = C_int(discr_field.llvm_type(cx), discr as i64);\n-            if let layout::Abi::Scalar(_) = l.abi {\n-                Const::new(discr, t)\n-            } else {\n-                let discr = Const::new(discr, discr_field.ty);\n-                build_const_struct(cx, l.for_variant(cx, variant_index), vals, Some(discr))\n-            }\n-        }\n-        layout::Variants::NicheFilling {\n-            dataful_variant,\n-            ref niche_variants,\n-            niche_start,\n-            ..\n-        } => {\n-            if variant_index == dataful_variant {\n-                build_const_struct(cx, l.for_variant(cx, dataful_variant), vals, None)\n-            } else {\n-                let niche = l.field(cx, 0);\n-                let niche_llty = niche.llvm_type(cx);\n-                let niche_value = ((variant_index - niche_variants.start) as u128)\n-                    .wrapping_add(niche_start);\n-                // FIXME(eddyb) Check the actual primitive type here.\n-                let niche_llval = if niche_value == 0 {\n-                    // HACK(eddyb) Using `C_null` as it works on all types.\n-                    C_null(niche_llty)\n-                } else {\n-                    C_uint_big(niche_llty, niche_value)\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+    fn const_to_miri_value(\n+        &mut self,\n+        bcx: &Builder<'a, 'tcx>,\n+        constant: &'tcx ty::Const<'tcx>,\n+    ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n+        match constant.val {\n+            ConstVal::Unevaluated(def_id, ref substs) => {\n+                let tcx = bcx.tcx();\n+                let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+                let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: None,\n                 };\n-                build_const_struct(cx, l, &[Const::new(niche_llval, niche.ty)], None)\n-            }\n+                let c = tcx.const_eval(param_env.and(cid))?;\n+                self.const_to_miri_value(bcx, c)\n+            },\n+            ConstVal::Value(miri_val) => Ok(miri_val),\n         }\n     }\n-}\n-\n-/// Building structs is a little complicated, because we might need to\n-/// insert padding if a field's value is less aligned than its type.\n-///\n-/// Continuing the example from `trans_const_adt`, a value of type `(u32,\n-/// E)` should have the `E` at offset 8, but if that field's\n-/// initializer is 4-byte aligned then simply translating the tuple as\n-/// a two-element struct will locate it at offset 4, and accesses to it\n-/// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                layout: layout::TyLayout<'tcx>,\n-                                vals: &[Const<'tcx>],\n-                                discr: Option<Const<'tcx>>)\n-                                -> Const<'tcx> {\n-    assert_eq!(vals.len(), layout.fields.count());\n \n-    match layout.abi {\n-        layout::Abi::Scalar(_) |\n-        layout::Abi::ScalarPair(..) |\n-        layout::Abi::Vector { .. } if discr.is_none() => {\n-            let mut non_zst_fields = vals.iter().enumerate().map(|(i, f)| {\n-                (f, layout.fields.offset(i))\n-            }).filter(|&(f, _)| !cx.layout_of(f.ty).is_zst());\n-            match (non_zst_fields.next(), non_zst_fields.next()) {\n-                (Some((x, offset)), None) if offset.bytes() == 0 => {\n-                    return Const::new(x.llval, layout.ty);\n-                }\n-                (Some((a, a_offset)), Some((b, _))) if a_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(cx, &[a.llval, b.llval], false), layout.ty);\n-                }\n-                (Some((a, _)), Some((b, b_offset))) if b_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(cx, &[b.llval, a.llval], false), layout.ty);\n-                }\n-                _ => {}\n+    pub fn mir_constant_to_miri_value(\n+        &mut self,\n+        bcx: &Builder<'a, 'tcx>,\n+        constant: &mir::Constant<'tcx>,\n+    ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n+        match constant.literal {\n+            mir::Literal::Promoted { index } => {\n+                let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+                let cid = mir::interpret::GlobalId {\n+                    instance: self.instance,\n+                    promoted: Some(index),\n+                };\n+                bcx.tcx().const_eval(param_env.and(cid))\n             }\n-        }\n-        _ => {}\n-    }\n-\n-    // offset of current value\n-    let mut packed = false;\n-    let mut offset = Size::from_bytes(0);\n-    let mut cfields = Vec::new();\n-    cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n-\n-    if let Some(discr) = discr {\n-        let (field_size, field_align) = cx.size_and_align_of(discr.ty);\n-        packed |= layout.align.abi() < field_align.abi();\n-        cfields.push(discr.llval);\n-        offset = field_size;\n+            mir::Literal::Value { value } => {\n+                Ok(self.monomorphize(&value))\n+            }\n+        }.and_then(|c| self.const_to_miri_value(bcx, c))\n     }\n \n-    let parts = layout.fields.index_by_increasing_offset().map(|i| {\n-        (vals[i], layout.fields.offset(i))\n-    });\n-    for (val, target_offset) in parts {\n-        let (field_size, field_align) = cx.size_and_align_of(val.ty);\n-        packed |= layout.align.abi() < field_align.abi();\n-        cfields.push(padding(cx, target_offset - offset));\n-        cfields.push(val.llval);\n-        offset = target_offset + field_size;\n+    // Old version of trans_constant now used just for SIMD shuffle\n+    pub fn remove_me_shuffle_indices(&mut self,\n+                                      bcx: &Builder<'a, 'tcx>,\n+                                      constant: &mir::Constant<'tcx>)\n+                                      -> (ValueRef, Ty<'tcx>)\n+    {\n+        let layout = bcx.ccx.layout_of(constant.ty);\n+        self.mir_constant_to_miri_value(bcx, constant)\n+            .and_then(|c| {\n+                let llval = match c {\n+                    MiriValue::ByVal(val) => {\n+                        let scalar = match layout.abi {\n+                            layout::Abi::Scalar(ref x) => x,\n+                            _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n+                        };\n+                        primval_to_llvm(bcx.ccx, val, scalar, layout.immediate_llvm_type(bcx.ccx))\n+                    },\n+                    MiriValue::ByValPair(a_val, b_val) => {\n+                        let (a_scalar, b_scalar) = match layout.abi {\n+                            layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n+                            _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n+                        };\n+                        let a_llval = primval_to_llvm(\n+                            bcx.ccx,\n+                            a_val,\n+                            a_scalar,\n+                            layout.scalar_pair_element_llvm_type(bcx.ccx, 0),\n+                        );\n+                        let b_llval = primval_to_llvm(\n+                            bcx.ccx,\n+                            b_val,\n+                            b_scalar,\n+                            layout.scalar_pair_element_llvm_type(bcx.ccx, 1),\n+                        );\n+                        C_struct(bcx.ccx, &[a_llval, b_llval], false)\n+                    },\n+                    MiriValue::ByRef(..) => {\n+                        let field_ty = constant.ty.builtin_index().unwrap();\n+                        let fields = match constant.ty.sty {\n+                            ty::TyArray(_, n) => n.val.unwrap_u64(),\n+                            ref other => bug!(\"invalid simd shuffle type: {}\", other),\n+                        };\n+                        let values: Result<Vec<ValueRef>, _> = (0..fields).map(|field| {\n+                            let field = const_val_field(\n+                                bcx.tcx(),\n+                                ty::ParamEnv::empty(traits::Reveal::All),\n+                                self.instance,\n+                                None,\n+                                mir::Field::new(field as usize),\n+                                c,\n+                                constant.ty,\n+                            )?;\n+                            match field.val {\n+                                ConstVal::Value(MiriValue::ByVal(prim)) => {\n+                                    let layout = bcx.ccx.layout_of(field_ty);\n+                                    let scalar = match layout.abi {\n+                                        layout::Abi::Scalar(ref x) => x,\n+                                        _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n+                                    };\n+                                    Ok(primval_to_llvm(\n+                                        bcx.ccx, prim, scalar,\n+                                        layout.immediate_llvm_type(bcx.ccx),\n+                                    ))\n+                                },\n+                                other => bug!(\"simd shuffle field {:?}, {}\", other, constant.ty),\n+                            }\n+                        }).collect();\n+                        C_struct(bcx.ccx, &values?, false)\n+                    },\n+                };\n+                Ok((llval, constant.ty))\n+            })\n+            .unwrap_or_else(|e| {\n+                e.report(bcx.tcx(), constant.span, \"shuffle_indices\");\n+                // We've errored, so we don't have to produce working code.\n+                let ty = self.monomorphize(&constant.ty);\n+                let llty = bcx.ccx.layout_of(ty).llvm_type(bcx.ccx);\n+                (C_undef(llty), ty)\n+            })\n     }\n-\n-    // Pad to the size of the whole type, not e.g. the variant.\n-    cfields.push(padding(cx, cx.size_of(layout.ty) - offset));\n-\n-    Const::new(C_struct(cx, &cfields, packed), layout.ty)\n-}\n-\n-fn padding(cx: &CodegenCx, size: Size) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(cx), size.bytes()))\n }"}, {"sha": "a1044ac87e4c550b394a85219ac86f5777ce783b", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -44,6 +44,8 @@ use self::operand::{OperandRef, OperandValue};\n \n /// Master context for translating MIR.\n pub struct FunctionCx<'a, 'tcx:'a> {\n+    instance: Instance<'tcx>,\n+\n     mir: &'a mir::Mir<'tcx>,\n \n     debug_context: debuginfo::FunctionDebugContext,\n@@ -227,6 +229,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let (landing_pads, funclets) = create_funclets(mir, &bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n+        instance,\n         mir,\n         llfn,\n         fn_ty,"}, {"sha": "01cf324124c4fed097297081fc8541f02253f8d5", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 82, "deletions": 10, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -9,12 +9,14 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::middle::const_val::ConstEvalErr;\n use rustc::mir;\n+use rustc::mir::interpret::Value as MiriValue;\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, CodegenCx, C_undef, C_usize};\n+use common::{self, CodegenCx, C_null, C_undef, C_usize};\n use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n@@ -24,6 +26,7 @@ use std::fmt;\n use std::ptr;\n \n use super::{FunctionCx, LocalRef};\n+use super::constant::{primval_to_llvm};\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -89,6 +92,70 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n+    pub fn from_const(bcx: &Builder<'a, 'tcx>,\n+                      miri_val: MiriValue,\n+                      ty: ty::Ty<'tcx>)\n+                      -> Result<OperandRef<'tcx>, ConstEvalErr<'tcx>> {\n+        let layout = bcx.ccx.layout_of(ty);\n+\n+        if layout.is_zst() {\n+            return Ok(OperandRef::new_zst(bcx.ccx, layout));\n+        }\n+\n+        let val = match miri_val {\n+            MiriValue::ByVal(x) => {\n+                let scalar = match layout.abi {\n+                    layout::Abi::Scalar(ref x) => x,\n+                    _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n+                };\n+                let llval = primval_to_llvm(\n+                    bcx.ccx,\n+                    x,\n+                    scalar,\n+                    layout.immediate_llvm_type(bcx.ccx),\n+                );\n+                OperandValue::Immediate(llval)\n+            },\n+            MiriValue::ByValPair(a, b) => {\n+                let (a_scalar, b_scalar) = match layout.abi {\n+                    layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n+                    _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n+                };\n+                let a_llval = primval_to_llvm(\n+                    bcx.ccx,\n+                    a,\n+                    a_scalar,\n+                    layout.scalar_pair_element_llvm_type(bcx.ccx, 0),\n+                );\n+                let b_llval = primval_to_llvm(\n+                    bcx.ccx,\n+                    b,\n+                    b_scalar,\n+                    layout.scalar_pair_element_llvm_type(bcx.ccx, 1),\n+                );\n+                OperandValue::Pair(a_llval, b_llval)\n+            },\n+            MiriValue::ByRef(ptr, align) => {\n+                let scalar = layout::Scalar {\n+                    value: layout::Primitive::Pointer,\n+                    valid_range: 0..=!0\n+                };\n+                let ptr = primval_to_llvm(\n+                    bcx.ccx,\n+                    ptr.into_inner_primval(),\n+                    &scalar,\n+                    layout.llvm_type(bcx.ccx).ptr_to(),\n+                );\n+                return Ok(PlaceRef::new_sized(ptr, layout, align).load(bcx));\n+            },\n+        };\n+\n+        Ok(OperandRef {\n+            val,\n+            layout\n+        })\n+    }\n+\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> ValueRef {\n@@ -327,14 +394,19 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let val = self.trans_constant(&bx, constant);\n-                let operand = val.to_operand(bx.cx);\n-                if let OperandValue::Ref(ptr, align) = operand.val {\n-                    // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    PlaceRef::new_sized(ptr, operand.layout, align).load(bx)\n-                } else {\n-                    operand\n-                }\n+                let ty = self.monomorphize(&constant.ty);\n+                self.mir_constant_to_miri_value(bx, constant)\n+                    .and_then(|c| OperandRef::from_const(bx, c, ty))\n+                    .unwrap_or_else(|err| {\n+                        err.report(bx.tcx(), constant.span, \"const operand\");\n+                        // We've errored, so we don't have to produce working code.\n+                        let layout = bx.cx.layout_of(ty);\n+                        PlaceRef::new_sized(\n+                            C_null(layout.llvm_type(bx.cx).ptr_to()),\n+                            layout,\n+                            layout.align,\n+                        ).load(bx)\n+                    })\n             }\n         }\n     }"}, {"sha": "06d94e8d15569a6be33bdfa1814802642de418e8", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -58,12 +58,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 };\n                 let attrs = tcx.get_attrs(def_id);\n \n-                match consts::trans_static(&cx, def_id, is_mutable, &attrs) {\n-                    Ok(_) => { /* Cool, everything's alright. */ },\n-                    Err(err) => {\n-                        err.report(tcx, tcx.def_span(def_id), \"static\");\n-                    }\n-                };\n+                consts::trans_static(&cx, def_id, is_mutable, &attrs);\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);"}, {"sha": "f5303979f9c32a00a1b65c7a0d554ec12b89b11e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -4013,7 +4013,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let count = tcx.const_eval(param_env.and(global_id));\n \n             if let Err(ref err) = count {\n-               err.report(tcx, tcx.def_span(count_def_id), \"constant expression\");\n+                err.report(tcx, tcx.def_span(count_def_id), \"constant expression\");\n             }\n \n             let uty = match expected {"}, {"sha": "bb41acc54100135bca2431f699991343c4376eff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -535,7 +535,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // so we need to report the real error\n             if let Err(ref err) = result {\n                 err.report(tcx, variant.span, \"enum discriminant\");\n-            }\n+}\n \n             match result {\n                 Ok(&ty::Const {"}, {"sha": "b9e4ce661d0c441d05422e08a87faf2aa759f341", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -2500,7 +2500,11 @@ impl Clean<Type> for hir::Ty {\n                 let def_id = cx.tcx.hir.body_owner_def_id(n);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = Substs::identity_for_item(cx.tcx, def_id);\n-                let n = cx.tcx.const_eval(param_env.and((def_id, substs))).unwrap_or_else(|_| {\n+                let cid = GlobalId {\n+                    instance: ty::Instance::new(def_id, substs),\n+                    promoted: None\n+                };\n+                let n = cx.tcx.const_eval(param_env.and(cid)).unwrap_or_else(|_| {\n                     cx.tcx.mk_const(ty::Const {\n                         val: ConstVal::Unevaluated(def_id, substs),\n                         ty: cx.tcx.types.usize\n@@ -2633,7 +2637,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let mut n = cx.tcx.lift(&n).unwrap();\n                 if let ConstVal::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n-                    if let Ok(new_n) = cx.tcx.const_eval(param_env.and((def_id, substs))) {\n+                    let cid = GlobalId {\n+                        instance: ty::Instance::new(def_id, substs),\n+                        promoted: None\n+                    };\n+                    if let Ok(new_n) = cx.tcx.const_eval(param_env.and(cid)) {\n                         n = new_n;\n                     }\n                 };"}, {"sha": "02264228a6bf6d4ca8c03ba8b4d1f71bb946ec7e", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -15,4 +15,5 @@ fn f(x: usize) -> usize {\n fn main() {\n     let _ = [0; f(2)];\n     //~^ ERROR calls in constants are limited to constant functions\n+    //~| E0080\n }"}, {"sha": "8c2e6233abfe26246b635d726bb35f9eff5cc6c0", "filename": "src/test/compile-fail/const-err-early.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -11,14 +11,15 @@\n #![feature(const_indexing)]\n #![deny(const_err)]\n \n-pub const A: i8 = -std::i8::MIN; //~ ERROR attempt to negate with overflow\n-pub const B: u8 = 200u8 + 200u8; //~ ERROR attempt to add with overflow\n-pub const C: u8 = 200u8 * 4; //~ ERROR attempt to multiply with overflow\n-pub const D: u8 = 42u8 - (42u8 + 1); //~ ERROR attempt to subtract with overflow\n+pub const A: i8 = -std::i8::MIN; //~ ERROR E0080\n+//~^ ERROR attempt to negate with overflow\n+//~| ERROR const_err\n+pub const B: u8 = 200u8 + 200u8; //~ ERROR E0080\n+pub const C: u8 = 200u8 * 4; //~ ERROR E0080\n+pub const D: u8 = 42u8 - (42u8 + 1); //~ ERROR E0080\n pub const E: u8 = [5u8][1];\n-//~^ ERROR index out of bounds: the len is 1 but the index is 1\n+//~^ ERROR E0080\n \n fn main() {\n     let _e = [6u8][1];\n-    //~^ ERROR index out of bounds: the len is 1 but the index is 1\n }"}, {"sha": "668f95f2c8d730035c72c35852ebdf106862aca0", "filename": "src/test/compile-fail/const-err-multi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err-multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err-multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err-multi.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -11,9 +11,14 @@\n #![deny(const_err)]\n \n pub const A: i8 = -std::i8::MIN; //~ ERROR attempt to negate with overflow\n+//~^ ERROR E0080\n+//~| ERROR const_err\n pub const B: i8 = A;\n+//~^ ERROR E0080\n pub const C: u8 = A as u8;\n+//~^ ERROR E0080\n pub const D: i8 = 50 - A;\n+//~^ ERROR E0080\n \n fn main() {\n }"}, {"sha": "8bd759b6d3735fe4cf9d266cd0f02fc6524e651f", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -26,26 +26,5 @@ const FOO: u8 = [5u8][1];\n //~| index out of bounds: the len is 1 but the index is 1\n \n fn main() {\n-    let a = -std::i8::MIN;\n-    //~^ WARN this expression will panic at run-time\n-    //~| attempt to negate with overflow\n-    let b = 200u8 + 200u8 + 200u8;\n-    //~^ WARN this expression will panic at run-time\n-    //~^^ WARN this expression will panic at run-time\n-    //~| attempt to add with overflow\n-    let c = 200u8 * 4;\n-    //~^ WARN this expression will panic at run-time\n-    //~| attempt to multiply with overflow\n-    let d = 42u8 - (42u8 + 1);\n-    //~^ WARN this expression will panic at run-time\n-    //~| attempt to subtract with overflow\n-    let _e = [5u8][1];\n-    //~^ WARN this expression will panic at run-time\n-    //~| index out of bounds: the len is 1 but the index is 1\n-    black_box(a);\n-    black_box(b);\n-    black_box(c);\n-    black_box(d);\n-\n     black_box((FOO, FOO));\n }"}, {"sha": "a0648993aac7421ed318af89a1d827e48ce8fc4e", "filename": "src/test/compile-fail/const-err2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -18,13 +18,11 @@ fn black_box<T>(_: T) {\n \n fn main() {\n     let a = -std::i8::MIN;\n-    //~^ ERROR attempt to negate with overflow\n+    //~^ ERROR const_err\n+    //~| ERROR const_err\n     let b = 200u8 + 200u8 + 200u8;\n-    //~^ ERROR attempt to add with overflow\n     let c = 200u8 * 4;\n-    //~^ ERROR attempt to multiply with overflow\n     let d = 42u8 - (42u8 + 1);\n-    //~^ ERROR attempt to subtract with overflow\n     let _e = [5u8][1];\n     black_box(a);\n     black_box(b);"}, {"sha": "636537d1df25088cada7f0b8d3b02c0e88779dd3", "filename": "src/test/compile-fail/const-err3.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![deny(const_err)]\n+\n+fn black_box<T>(_: T) {\n+    unimplemented!()\n+}\n+\n+fn main() {\n+    let b = 200u8 + 200u8 + 200u8;\n+    //~^ ERROR const_err\n+    //~| ERROR const_err\n+    let c = 200u8 * 4;\n+    let d = 42u8 - (42u8 + 1);\n+    let _e = [5u8][1];\n+    black_box(b);\n+    black_box(c);\n+    black_box(d);\n+}"}, {"sha": "058a8d0a1bd4f5532dde59920b1783be1c71c2b8", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b2b101befcfe1ca4ea57862675df0de5ca7b15bd/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b101befcfe1ca4ea57862675df0de5ca7b15bd/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=b2b101befcfe1ca4ea57862675df0de5ca7b15bd", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unused_imports)]\n-\n-// Note: the relevant lint pass here runs before some of the constant\n-// evaluation below (e.g. that performed by trans and llvm), so if you\n-// change this warn to a deny, then the compiler will exit before\n-// those errors are detected.\n-\n-#![warn(const_err)]\n-\n-use std::fmt;\n-use std::{i8, i16, i32, i64, isize};\n-use std::{u8, u16, u32, u64, usize};\n-\n-const VALS_I8: (i8, i8, i8, i8) =\n-    (-i8::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i8::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i8::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i8::MIN * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_I16: (i16, i16, i16, i16) =\n-    (-i16::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i16::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i16::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i16::MIN * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_I32: (i32, i32, i32, i32) =\n-    (-i32::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i32::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i32::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i32::MIN * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_I64: (i64, i64, i64, i64) =\n-    (-i64::MIN,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to negate with overflow\n-     i64::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     i64::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     i64::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U8: (u8, u8, u8, u8) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u8::MIN as i8) as u8,\n-     u8::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u8::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u8::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U16: (u16, u16, u16, u16) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u16::MIN as i16) as u16,\n-     u16::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u16::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u16::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U32: (u32, u32, u32, u32) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u32::MIN as i32) as u32,\n-     u32::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u32::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u32::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-const VALS_U64: (u64, u64, u64, u64) =\n-    ( //~ WARN constant evaluation error: attempt to subtract with overflow\n-     -(u64::MIN as i64) as u64,\n-     u64::MIN - 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to subtract with overflow\n-     u64::MAX + 1,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to add with overflow\n-     u64::MAX * 2,\n-     //~^ ERROR constant evaluation error\n-     //~| attempt to multiply with overflow\n-     );\n-\n-fn main() {\n-    foo(VALS_I8);\n-    foo(VALS_I16);\n-    foo(VALS_I32);\n-    foo(VALS_I64);\n-\n-    foo(VALS_U8);\n-    foo(VALS_U16);\n-    foo(VALS_U32);\n-    foo(VALS_U64);\n-}\n-\n-fn foo<T:fmt::Debug>(x: T) {\n-    println!(\"{:?}\", x);\n-}"}, {"sha": "61a653589fff9f1cef9d75589d5b10ac10f20207", "filename": "src/test/compile-fail/const-eval-overflow2.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+\n+#![deny(const_err)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8,) =\n+    (\n+     i8::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+const VALS_I16: (i16,) =\n+    (\n+     i16::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+const VALS_I32: (i32,) =\n+    (\n+     i32::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+const VALS_I64: (i64,) =\n+    (\n+     i64::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+const VALS_U8: (u8,) =\n+    (\n+     u8::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+const VALS_U16: (u16,) = (\n+     u16::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+const VALS_U32: (u32,) = (\n+     u32::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+const VALS_U64: (u64,) =\n+    (\n+     u64::MIN - 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to subtract with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T>(_: T) {\n+}"}, {"sha": "b2e84486101bcb8e9964ba55c7bcebd0166b3ceb", "filename": "src/test/compile-fail/const-eval-overflow2b.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2b.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+\n+#![deny(const_err)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8,) =\n+    (\n+     i8::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+const VALS_I16: (i16,) =\n+    (\n+     i16::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+const VALS_I32: (i32,) =\n+    (\n+     i32::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+const VALS_I64: (i64,) =\n+    (\n+     i64::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+const VALS_U8: (u8,) =\n+    (\n+     u8::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+const VALS_U16: (u16,) = (\n+     u16::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+const VALS_U32: (u32,) = (\n+     u32::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+const VALS_U64: (u64,) =\n+    (\n+     u64::MAX + 1,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to add with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T>(_: T) {\n+}"}, {"sha": "c4a8beaf0f0570163cc892bef99c8ed94b89a288", "filename": "src/test/compile-fail/const-eval-overflow2c.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow2c.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+\n+#![deny(const_err)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8,) =\n+    (\n+     i8::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+const VALS_I16: (i16,) =\n+    (\n+     i16::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+const VALS_I32: (i32,) =\n+    (\n+     i32::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+const VALS_I64: (i64,) =\n+    (\n+     i64::MIN * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+const VALS_U8: (u8,) =\n+    (\n+     u8::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+const VALS_U16: (u16,) = (\n+     u16::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+const VALS_U32: (u32,) = (\n+     u32::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+const VALS_U64: (u64,) =\n+    (\n+     u64::MAX * 2,\n+     //~^ ERROR constant evaluation error\n+     //~| attempt to multiply with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T>(_: T) {\n+}"}, {"sha": "3065122af6a94fb334e6015d132c0b6d2aa421ee", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -16,6 +16,7 @@ const X: usize = 42 && 39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR: [i32; X] = [99; 34];\n+//~^ ERROR constant evaluation error\n \n const X1: usize = 42 || 39;\n //~^ ERROR mismatched types\n@@ -25,6 +26,7 @@ const X1: usize = 42 || 39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR1: [i32; X1] = [99; 47];\n+//~^ ERROR constant evaluation error\n \n const X2: usize = -42 || -39;\n //~^ ERROR mismatched types\n@@ -34,6 +36,7 @@ const X2: usize = -42 || -39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR2: [i32; X2] = [99; 18446744073709551607];\n+//~^ ERROR constant evaluation error\n \n const X3: usize = -42 && -39;\n //~^ ERROR mismatched types\n@@ -43,36 +46,43 @@ const X3: usize = -42 && -39;\n //~| ERROR mismatched types\n //~| expected usize, found bool\n const ARR3: [i32; X3] = [99; 6];\n+//~^ ERROR constant evaluation error\n \n const Y: usize = 42.0 == 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR: [i32; Y] = [99; 1];\n+//~^ ERROR constant evaluation error\n \n const Y1: usize = 42.0 >= 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR1: [i32; Y1] = [99; 1];\n+//~^ ERROR constant evaluation error\n \n const Y2: usize = 42.0 <= 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR2: [i32; Y2] = [99; 1];\n+//~^ ERROR constant evaluation error\n \n const Y3: usize = 42.0 > 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR3: [i32; Y3] = [99; 0];\n+//~^ ERROR constant evaluation error\n \n const Y4: usize = 42.0 < 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR4: [i32; Y4] = [99; 0];\n+//~^ ERROR constant evaluation error\n \n const Y5: usize = 42.0 != 42.0;\n //~^ ERROR mismatched types\n //~| expected usize, found bool\n const ARRR5: [i32; Y5] = [99; 0];\n+//~^ ERROR constant evaluation error\n \n fn main() {\n     let _ = ARR;"}, {"sha": "85cc893aa133c543457018af5bbec0c5edfb15be", "filename": "src/test/compile-fail/const-len-underflow-subspans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -16,6 +16,6 @@ const TWO: usize = 2;\n \n fn main() {\n     let a: [i8; ONE - TWO] = unimplemented!();\n-    //~^ ERROR constant evaluation error [E0080]\n+    //~^ ERROR constant evaluation error\n     //~| attempt to subtract with overflow\n }"}, {"sha": "179ea9e853f3ad6bd4a4abc7973ee4fb40e7203d", "filename": "src/test/compile-fail/const-slice-oob.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deny(const_err)]\n+\n const FOO: &'static[u32] = &[1, 2, 3];\n const BAR: u32 = FOO[5];\n //~^ ERROR constant evaluation error [E0080]"}, {"sha": "7596881ef9b9af1e03762dda451dca620cc3b1a3", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -14,6 +14,7 @@ const TUP: (usize,) = 5usize << 64;\n //~^ ERROR mismatched types\n //~| expected tuple, found usize\n const ARR: [i32; TUP.0] = [];\n+//~^ ERROR constant evaluation error\n \n fn main() {\n }"}, {"sha": "49f76c532df54d328f2605e21e6d4a9f5a330b4f", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum test {\n-    div_zero = 1/0, //~ ERROR E0080\n-                    //~| attempt to divide by zero\n-    rem_zero = 1%0,\n-    //~^ ERROR E0080\n-    //~| attempt to calculate the remainder with a divisor of zero\n+enum Test {\n+    DivZero = 1/0,\n+    //~^ attempt to divide by zero\n+    //~| ERROR constant evaluation error\n+    //~| WARN constant evaluation error\n+    RemZero = 1%0,\n+    //~^ attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n+    //~| WARN constant evaluation error\n }\n \n fn main() {}"}, {"sha": "1f07422e21be471a1dd0385174ae360254d45a3d", "filename": "src/test/compile-fail/float-int-invalid-const-cast.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b2b101befcfe1ca4ea57862675df0de5ca7b15bd/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b101befcfe1ca4ea57862675df0de5ca7b15bd/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs?ref=b2b101befcfe1ca4ea57862675df0de5ca7b15bd", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(i128_type)]\n-#![allow(const_err)] // this test is only about hard errors\n-\n-use std::{f32, f64};\n-\n-// Forces evaluation of constants, triggering hard error\n-fn force<T>(_: T) {}\n-\n-fn main() {\n-    { const X: u16 = -1. as u16; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = -100. as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f32::NAN as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = f32::NAN as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u64 = f32::NAN as u64; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f32::NAN as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f32::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u32 = f32::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f32::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f32::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: u8 = f32::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u16 = f32::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n-    { const X: i64 = f32::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f32::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f64::NAN as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = f64::NAN as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u64 = f64::NAN as u64; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f64::NAN as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: i8 = f64::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u32 = f64::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f64::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = f64::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: u8 = f64::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n-    { const X: u16 = f64::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n-    { const X: i64 = f64::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = f64::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n-\n-    { const X: u8 = 256. as u8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i8 = -129. as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i8 = 128. as i8; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = 2147483648. as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: i32 = -2147483904. as i32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u32 = 4294967296. as u32; force(X); } //~ ERROR constant evaluation error\n-    { const X: u128 = 1e40 as u128; force(X); } //~ ERROR constant evaluation error\n-    { const X: i128 = 1e40 as i128; force(X); } //~ ERROR constant evaluation error\n-}"}, {"sha": "be76796c5c465b936404ca001d5cb17f9f2596bb", "filename": "src/test/compile-fail/issue-27895.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -14,8 +14,7 @@ fn main() {\n \n     match i {\n         0...index => println!(\"winner\"),\n-        //~^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n+        //~^ ERROR runtime values cannot be referenced in patterns\n         _ => println!(\"hello\"),\n     }\n }"}, {"sha": "ac85e43cf4f0557e38e826929debb914bf621d05", "filename": "src/test/compile-fail/issue-41255.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -18,33 +18,33 @@\n fn main() {\n     let x = 42.0;\n     match x {\n-        5.0 => {}, //~ ERROR floating-point cannot be used\n+        5.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                    //~| WARNING hard error\n-        5.0f32 => {}, //~ ERROR floating-point cannot be used\n+        5.0f32 => {}, //~ ERROR floating-point types cannot be used in patterns\n                       //~| WARNING hard error\n-        -5.0 => {}, //~ ERROR floating-point cannot be used\n+        -5.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                     //~| WARNING hard error\n-        1.0 .. 33.0 => {}, //~ ERROR floating-point cannot be used\n+        1.0 .. 33.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                            //~| WARNING hard error\n-                           //~| ERROR floating-point cannot be used\n+                           //~| ERROR floating-point types cannot be used in patterns\n                            //~| WARNING hard error\n-        39.0 ... 70.0 => {}, //~ ERROR floating-point cannot be used\n+        39.0 ... 70.0 => {}, //~ ERROR floating-point types cannot be used in patterns\n                              //~| WARNING hard error\n-                             //~| ERROR floating-point cannot be used\n+                             //~| ERROR floating-point types cannot be used in patterns\n                              //~| WARNING hard error\n         _ => {},\n     };\n     let y = 5.0;\n     // Same for tuples\n     match (x, 5) {\n-        (3.14, 1) => {}, //~ ERROR floating-point cannot be used\n+        (3.14, 1) => {}, //~ ERROR floating-point types cannot be used\n                          //~| WARNING hard error\n         _ => {},\n     }\n     // Or structs\n     struct Foo { x: f32 };\n     match (Foo { x }) {\n-        Foo { x: 2.0 } => {}, //~ ERROR floating-point cannot be used\n+        Foo { x: 2.0 } => {}, //~ ERROR floating-point types cannot be used\n                               //~| WARNING hard error\n         _ => {},\n     }"}, {"sha": "9efe3d90a93c5eec1445321dfa9ee9be27624653", "filename": "src/test/compile-fail/issue-44578.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-44578.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-44578.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-44578.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -18,7 +18,7 @@ enum Bar<A, B> {\n }\n \n impl<A: Foo, B: Foo> Foo for Bar<A, B> {\n-    const AMT: usize = [A::AMT][(A::AMT > B::AMT) as usize]; //~ ERROR constant evaluation\n+    const AMT: usize = [A::AMT][(A::AMT > B::AMT) as usize]; //~ E0080\n }\n \n impl Foo for u8 {\n@@ -30,5 +30,5 @@ impl Foo for u16 {\n }\n \n fn main() {\n-    println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n+    println!(\"{}\", <Bar<u16, u8> as Foo>::AMT); //~ E0080\n }"}, {"sha": "9191dfa155c657d9dfc3813556ab36717c9a88a2", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -12,18 +12,21 @@\n \n #![feature(slice_patterns)]\n #![allow(unused)]\n+#![deny(illegal_floating_point_literal_pattern)]\n \n use std::f64::NAN;\n \n fn main() {\n     let x = NAN;\n     match x {\n-        NAN => {}, //~ ERROR floating point constants cannot be used\n+        NAN => {}, //~ ERROR floating-point types cannot be used\n+        //~^ WARN this was previously accepted by the compiler but is being phased out\n         _ => {},\n     };\n \n     match [x, 1.0] {\n-        [NAN, _] => {}, //~ ERROR floating point constants cannot be used\n+        [NAN, _] => {}, //~ ERROR floating-point types cannot be used\n+        //~^ WARN this was previously accepted by the compiler but is being phased out\n         _ => {},\n     };\n }"}, {"sha": "1d59e75a0f0f028874ee69aa71269f949edf13c5", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -16,42 +16,62 @@ use std::thread;\n fn main() {\n     assert!(thread::spawn(move|| { isize::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i8::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i16::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i32::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1isize / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i16 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i32 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    //~| ERROR constant evaluation error\n }"}, {"sha": "2634157c80671bcc00ec6f5a281d80f2d5d19b9c", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -10,7 +10,7 @@\n \n #![deny(exceeding_bitshifts)]\n #![allow(unused_variables)]\n-#![allow(dead_code)]\n+#![allow(dead_code, const_err)]\n #![feature(const_indexing)]\n \n fn main() {\n@@ -54,21 +54,5 @@ fn main() {\n \n       let n = 1u8 << -8; //~ ERROR: bitshift exceeds the type's number of bits\n \n-\n-      let n = 1u8 << (4+3);\n-      let n = 1u8 << (4+4); //~ ERROR: bitshift exceeds the type's number of bits\n-\n-      #[cfg(target_pointer_width = \"32\")]\n-      const BITS: usize = 32;\n-      #[cfg(target_pointer_width = \"64\")]\n-      const BITS: usize = 64;\n-\n-      let n = 1_isize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1_usize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n-\n-\n       let n = 1i8<<(1isize+-1);\n-\n-      let n = 1i64 >> [63][0];\n-      let n = 1i64 >> [64][0]; //~ ERROR: bitshift exceeds the type's number of bits\n }"}, {"sha": "d95e1b370aafd4f64c4b51c48d71118b127a6e22", "filename": "src/test/compile-fail/lint-exceeding-bitshifts2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts2.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(exceeding_bitshifts)]\n+#![allow(unused_variables, const_err)]\n+#![allow(dead_code)]\n+\n+fn main() {\n+      let n = 1u8 << (4+3);\n+      let n = 1u8 << (4+4); //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i64 >> [63][0];\n+      let n = 1i64 >> [64][0]; // should be linting, needs to wait for const propagation\n+\n+      #[cfg(target_pointer_width = \"32\")]\n+      const BITS: usize = 32;\n+      #[cfg(target_pointer_width = \"64\")]\n+      const BITS: usize = 64;\n+      let n = 1_isize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1_usize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n+}"}, {"sha": "9178d8d2f6ed22a2ebc498b32fe7f9267d3c729e", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -17,6 +17,7 @@\n #[rustc_error]\n fn main() { //~ ERROR: compilation successful\n     let x2: i8 = --128; //~ warn: literal out of range for i8\n+    //~^ WARN constant evaluation error\n \n     let x = -3.40282357e+38_f32; //~ warn: literal out of range for f32\n     let x =  3.40282357e+38_f32; //~ warn: literal out of range for f32"}, {"sha": "fe88ab4e11798b39467d7b791895d4fa9924935b", "filename": "src/test/compile-fail/non-constant-in-const-path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -12,7 +12,6 @@ fn main() {\n     let x = 0;\n     match 1 {\n         0 ... x => {}\n-        //~^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n+        //~^ ERROR runtime values cannot be referenced in patterns\n     };\n }"}, {"sha": "ca9af78dd993660991e315ab75ffa6057eaf0c0e", "filename": "src/test/compile-fail/rfc1445/match-forbidden-without-eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -28,7 +28,7 @@ fn main() {\n     let x = 0.0;\n     match x {\n         f32::INFINITY => { }\n-        //~^ WARNING floating-point cannot be used in patterns\n+        //~^ WARNING floating-point types cannot be used in patterns\n         //~| WARNING will become a hard error in a future release\n         _ => { }\n     }"}, {"sha": "2e60634d15eed190f7db09d106677ef35cbf9b67", "filename": "src/test/run-pass/const-index-feature-gate.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Frun-pass%2Fconst-index-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Frun-pass%2Fconst-index-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-index-feature-gate.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n const ARR: [usize; 1] = [2];\n-const ARR2: [i32; ARR[0]] = [5, 6]; //~ ERROR E0080\n-                                    //~| unstable\n+const ARR2: [i32; ARR[0]] = [5, 6];\n \n fn main() {\n }", "previous_filename": "src/test/compile-fail/const-index-feature-gate.rs"}, {"sha": "80ab12482cbb7821c77e4dd5817a2eda40dfa326", "filename": "src/test/run-pass/float-int-invalid-const-cast.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Frun-pass%2Ffloat-int-invalid-const-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Frun-pass%2Ffloat-int-invalid-const-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-int-invalid-const-cast.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(i128_type)]\n+#![deny(const_err)]\n+\n+use std::{f32, f64};\n+\n+// Forces evaluation of constants, triggering hard error\n+fn force<T>(_: T) {}\n+\n+fn main() {\n+    { const X: u16 = -1. as u16; force(X); }\n+    { const X: u128 = -100. as u128; force(X); }\n+\n+    { const X: i8 = f32::NAN as i8; force(X); }\n+    { const X: i32 = f32::NAN as i32; force(X); }\n+    { const X: u64 = f32::NAN as u64; force(X); }\n+    { const X: u128 = f32::NAN as u128; force(X); }\n+\n+    { const X: i8 = f32::INFINITY as i8; force(X); }\n+    { const X: u32 = f32::INFINITY as u32; force(X); }\n+    { const X: i128 = f32::INFINITY as i128; force(X); }\n+    { const X: u128 = f32::INFINITY as u128; force(X); }\n+\n+    { const X: u8 = f32::NEG_INFINITY as u8; force(X); }\n+    { const X: u16 = f32::NEG_INFINITY as u16; force(X); }\n+    { const X: i64 = f32::NEG_INFINITY as i64; force(X); }\n+    { const X: i128 = f32::NEG_INFINITY as i128; force(X); }\n+\n+    { const X: i8 = f64::NAN as i8; force(X); }\n+    { const X: i32 = f64::NAN as i32; force(X); }\n+    { const X: u64 = f64::NAN as u64; force(X); }\n+    { const X: u128 = f64::NAN as u128; force(X); }\n+\n+    { const X: i8 = f64::INFINITY as i8; force(X); }\n+    { const X: u32 = f64::INFINITY as u32; force(X); }\n+    { const X: i128 = f64::INFINITY as i128; force(X); }\n+    { const X: u128 = f64::INFINITY as u128; force(X); }\n+\n+    { const X: u8 = f64::NEG_INFINITY as u8; force(X); }\n+    { const X: u16 = f64::NEG_INFINITY as u16; force(X); }\n+    { const X: i64 = f64::NEG_INFINITY as i64; force(X); }\n+    { const X: i128 = f64::NEG_INFINITY as i128; force(X); }\n+\n+    { const X: u8 = 256. as u8; force(X); }\n+    { const X: i8 = -129. as i8; force(X); }\n+    { const X: i8 = 128. as i8; force(X); }\n+    { const X: i32 = 2147483648. as i32; force(X); }\n+    { const X: i32 = -2147483904. as i32; force(X); }\n+    { const X: u32 = 4294967296. as u32; force(X); }\n+    { const X: u128 = 1e40 as u128; force(X); }\n+    { const X: i128 = 1e40 as i128; force(X); }\n+}"}, {"sha": "e87b2caa49f9024a9c49e03db95d8ab5f2410b1a", "filename": "src/test/ui/const-eval/issue-43197.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -18,4 +18,6 @@ fn main() {\n     const X: u32 = 0-1; //~ ERROR constant evaluation error\n     const Y: u32 = foo(0-1); //~ ERROR constant evaluation error\n     println!(\"{} {}\", X, Y);\n+    //~^ ERROR constant evaluation error\n+    //~| ERROR constant evaluation error\n }"}, {"sha": "35e3ba9ce0945dd42abcfde4b74722e0d297ceb7", "filename": "src/test/ui/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -15,6 +15,7 @@\n const ONE: usize = 1;\n const TWO: usize = 2;\n const LEN: usize = ONE - TWO;\n+//~^ ERROR E0080\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();"}, {"sha": "896dd2599bf53bdaaacb58bd229baabfe4e2c3cc", "filename": "src/test/ui/error-codes/E0030.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Ferror-codes%2FE0030.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Ferror-codes%2FE0030.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0030.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -10,7 +10,7 @@\n \n \n fn main() {\n-    match 5u32 {\n+    match 5u32 { //~ ERROR non-exhaustive patterns\n         1000 ... 5 => {}\n         //~^ ERROR lower range bound must be less than or equal to upper\n     }"}, {"sha": "6e525d4ea9ec79eb98127e257c0296d6a31483a7", "filename": "src/test/ui/error-codes/E0080.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e4e784e9906c732dcb3e0b6872f65dc8f5597/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0080.rs?ref=b33e4e784e9906c732dcb3e0b6872f65dc8f5597", "patch": "@@ -10,9 +10,10 @@\n \n enum Enum {\n     X = (1 << 500), //~ ERROR E0080\n-    //~| WARNING shift left with overflow\n+    //~| shift left with overflow\n     Y = (1 / 0) //~ ERROR E0080\n-    //~| WARNING divide by zero\n+    //~| const_err\n+    //~| divide by zero\n }\n \n fn main() {"}]}