{"sha": "911cbf8e46f0f3b044c87fc5cbca922878db757b", "node_id": "C_kwDOAAsO6NoAKDkxMWNiZjhlNDZmMGYzYjA0NGM4N2ZjNWNiY2E5MjI4NzhkYjc1N2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-20T12:57:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-20T12:57:48Z"}, "message": "Auto merge of #104617 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nr? `@thomcc` for the lib changes (removing a `cfg(miri)` that is no longer needed)", "tree": {"sha": "caf694c41a68b061249617e457bed1600dda075c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caf694c41a68b061249617e457bed1600dda075c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/911cbf8e46f0f3b044c87fc5cbca922878db757b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/911cbf8e46f0f3b044c87fc5cbca922878db757b", "html_url": "https://github.com/rust-lang/rust/commit/911cbf8e46f0f3b044c87fc5cbca922878db757b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/911cbf8e46f0f3b044c87fc5cbca922878db757b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cdfe03b0601d5328406746a7923a8a4eaa0cf3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cdfe03b0601d5328406746a7923a8a4eaa0cf3c", "html_url": "https://github.com/rust-lang/rust/commit/9cdfe03b0601d5328406746a7923a8a4eaa0cf3c"}, {"sha": "c043a0e7d6f347f9b2c7f08c5b3a179470e0f0c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c043a0e7d6f347f9b2c7f08c5b3a179470e0f0c5", "html_url": "https://github.com/rust-lang/rust/commit/c043a0e7d6f347f9b2c7f08c5b3a179470e0f0c5"}], "stats": {"total": 271, "additions": 154, "deletions": 117}, "files": [{"sha": "267fa69485cf3226a9c18896d3d27e6963e278bc", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -2330,7 +2330,6 @@ dependencies = [\n  \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n- \"shell-escape\",\n  \"smallvec\",\n  \"ui_test\",\n ]"}, {"sha": "d5abd9b581c65b67adf203f4e8a5c345e5897de8", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -150,7 +150,7 @@ impl From<libc::timespec> for Timespec {\n }\n \n #[cfg(any(\n-    all(target_os = \"macos\", any(not(target_arch = \"aarch64\"), miri)),\n+    all(target_os = \"macos\", any(not(target_arch = \"aarch64\"))),\n     target_os = \"ios\",\n     target_os = \"watchos\"\n ))]\n@@ -270,7 +270,7 @@ mod inner {\n }\n \n #[cfg(not(any(\n-    all(target_os = \"macos\", any(not(target_arch = \"aarch64\"), miri)),\n+    all(target_os = \"macos\", any(not(target_arch = \"aarch64\"))),\n     target_os = \"ios\",\n     target_os = \"watchos\"\n )))]"}, {"sha": "15fc89b86818ac6cbb72e3d954c2c899e3c09fe1", "filename": "src/tools/miri/Cargo.lock", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.lock?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -383,7 +383,6 @@ dependencies = [\n  \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n- \"shell-escape\",\n  \"smallvec\",\n  \"ui_test\",\n ]\n@@ -632,12 +631,6 @@ dependencies = [\n  \"lazy_static\",\n ]\n \n-[[package]]\n-name = \"shell-escape\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45bb67a18fa91266cc7807181f62f9178a6873bfad7dc788c42e6430db40184f\"\n-\n [[package]]\n name = \"smallvec\"\n version = \"1.9.0\""}, {"sha": "0f69a0baef4fb29fae46fbe6348129515b294a66", "filename": "src/tools/miri/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.toml?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -21,7 +21,6 @@ doctest = false # and no doc tests\n getrandom = { version = \"0.2\", features = [\"std\"] }\n env_logger = \"0.9\"\n log = \"0.4\"\n-shell-escape = \"0.1.4\"\n rand = \"0.8\"\n smallvec = \"1.7\"\n "}, {"sha": "dac0a9820b90e35350de14929acdc6449feb4da2", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -1,10 +1,5 @@\n # Miri\n \n-[![Actions build status][actions-badge]][actions-url]\n-\n-[actions-badge]: https://github.com/rust-lang/miri/workflows/CI/badge.svg?branch=master\n-[actions-url]: https://github.com/rust-lang/miri/actions\n-\n An experimental interpreter for [Rust][rust]'s\n [mid-level intermediate representation][mir] (MIR). It can run binaries and\n test suites of cargo projects and detect certain classes of\n@@ -200,7 +195,7 @@ randomness that is used to determine allocation base addresses. The following\n snippet calls Miri in a loop with different values for the seed:\n \n ```\n-for SEED in $({ echo obase=16; seq 0 255; } | bc); do\n+for SEED in $(seq 0 255); do\n   echo \"Trying seed: $SEED\"\n   MIRIFLAGS=-Zmiri-seed=$SEED cargo miri test || { echo \"Failing seed: $SEED\"; break; };\n done\n@@ -308,7 +303,7 @@ environment variable. We first document the most relevant and most commonly used\n   tell what it is doing when a program just keeps running. You can customize how frequently the\n   report is printed via `-Zmiri-report-progress=<blocks>`, which prints the report every N basic\n   blocks.\n-* `-Zmiri-seed=<hex>` configures the seed of the RNG that Miri uses to resolve non-determinism. This\n+* `-Zmiri-seed=<num>` configures the seed of the RNG that Miri uses to resolve non-determinism. This\n   RNG is used to pick base addresses for allocations, to determine preemption and failure of\n   `compare_exchange_weak`, and to control store buffering for weak memory emulation. When isolation\n   is enabled (the default), this is also used to emulate system entropy. The default seed is 0. You"}, {"sha": "38d36898768e18c12f185a9e6966dcd86b55dd7f", "filename": "src/tools/miri/miri", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -48,10 +48,10 @@ Update and activate the rustup toolchain 'miri' to the commit given in the\n `rustup-toolchain-install-master` must be installed for this to work. Any extra\n flags are passed to `rustup-toolchain-install-master`.\n \n-./miri rustc-pull:\n-Pull and merge Miri changes from the rustc repo. The fetched commit is stored in\n-the `rust-version` file, so the next `./miri toolchain` will install the rustc\n-we just pulled.\n+./miri rustc-pull <commit>:\n+Pull and merge Miri changes from the rustc repo. Defaults to fetching the latest\n+rustc commit. The fetched commit is stored in the `rust-version` file, so the\n+next `./miri toolchain` will install the rustc that just got pulled.\n \n ./miri rustc-push <github user> <branch>:\n Push Miri changes back to the rustc repo. This will pull a copy of the rustc\n@@ -113,18 +113,17 @@ toolchain)\n     ;;\n rustc-pull)\n     cd \"$MIRIDIR\"\n-    FETCH_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n-    # We can't pull from a commit with josh\n-    # (https://github.com/josh-project/josh/issues/1034), so we just hope that\n-    # nothing gets merged into rustc *during* this pull.\n-    git fetch http://localhost:8000/rust-lang/rust.git$JOSH_FILTER.git master\n-    # Just verify that `master` didn't move.\n-    if [[ $FETCH_COMMIT != $(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1) ]]; then\n-        echo \"Looks like something got merged into Rust *while we were pulling*. Aborting. Please try again.\"\n+    FETCH_COMMIT=\"$1\"\n+    if [ -z \"$FETCH_COMMIT\" ]; then\n+        FETCH_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n     fi\n-    echo \"$FETCH_COMMIT\" > rust-version # do this *before* merging as merging will fail in case of conflicts\n+    # Update rust-version file. As a separate commit, since making it part of\n+    # the merge has confused the heck out of josh in the past.\n+    echo \"$FETCH_COMMIT\" > rust-version\n+    git commit rust-version -m \"Preparing for merge from rustc\"\n+    # Fetch given rustc commit and note down which one that was\n+    git fetch http://localhost:8000/rust-lang/rust.git@$FETCH_COMMIT$JOSH_FILTER.git\n     git merge FETCH_HEAD --no-ff -m \"Merge from rustc\"\n-    git commit rust-version --amend -m \"Merge from rustc\"\n     exit 0\n     ;;\n rustc-push)\n@@ -157,16 +156,27 @@ rustc-push)\n     fi\n     git fetch https://github.com/rust-lang/rust $BASE\n     git push https://github.com/$USER/rust $BASE:refs/heads/$BRANCH -f\n+    echo\n     # Do the actual push.\n     cd \"$MIRIDIR\"\n     echo \"Pushing Miri changes...\"\n     git push http://localhost:8000/$USER/rust.git$JOSH_FILTER.git HEAD:$BRANCH\n-    exit 0\n+    # Do a round-trip check to make sure the push worked as expected.\n+    echo\n+    git fetch http://localhost:8000/$USER/rust.git@$JOSH_FILTER.git $BRANCH &>/dev/null\n+    if [[ $(git rev-parse HEAD) != $(git rev-parse FETCH_HEAD) ]]; then\n+        echo \"ERROR: Josh created a non-roundtrip push! Do NOT merge this into rustc!\"\n+        exit 1\n+    else\n+        echo \"Confirmed that the push round-trips back to Miri properly. Please create a rustc PR:\"\n+        echo \"    https://github.com/$USER/rust/pull/new/$BRANCH\"\n+        exit 0\n+    fi\n     ;;\n many-seeds)\n-    for SEED in $({ echo obase=16; seq 0 255; } | bc); do\n+    for SEED in $(seq 0 255); do\n         echo \"Trying seed: $SEED\"\n-        MIRIFLAGS=\"$MIRIFLAGS -Zmiri-seed=$SEED\" $@ || { echo \"Failing seed: $SEED\"; break; }\n+        MIRIFLAGS=\"$MIRIFLAGS -Zlayout-seed=$SEED -Zmiri-seed=$SEED\" $@ || { echo \"Failing seed: $SEED\"; break; }\n     done\n     exit 0\n     ;;"}, {"sha": "d007f952a67a175717311a644e95bb7461ed84d0", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -1 +1 @@\n-101e1822c3e54e63996c8aaa014d55716f3937eb\n+7477c1f4f7d6bef037d523099b240d22aa1b63a0"}, {"sha": "ffe89921d98665219644fab5baa94bedb051c23b", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -394,10 +394,9 @@ fn main() {\n             if miri_config.seed.is_some() {\n                 show_error!(\"Cannot specify -Zmiri-seed multiple times!\");\n             }\n-            let seed = u64::from_str_radix(param, 16)\n-                        .unwrap_or_else(|_| show_error!(\n-                            \"-Zmiri-seed should only contain valid hex digits [0-9a-fA-F] and must fit into a u64 (max 16 characters)\"\n-                        ));\n+            let seed = param.parse::<u64>().unwrap_or_else(|_| {\n+                show_error!(\"-Zmiri-seed must be an integer that fits into u64\")\n+            });\n             miri_config.seed = Some(seed);\n         } else if let Some(_param) = arg.strip_prefix(\"-Zmiri-env-exclude=\") {\n             show_error!("}, {"sha": "b6efad6b5ee0803c8cb111a1298e07bf85b9e11c", "filename": "src/tools/miri/src/shims/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -89,6 +89,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         let ptr = this.read_pointer(ptr_op)?;\n+        // If this carries no provenance, treat it like an integer.\n+        if ptr.provenance.is_none() {\n+            // Use actual implementation.\n+            return Ok(false);\n+        }\n+\n         if let Ok((alloc_id, _offset, _)) = this.ptr_try_get_alloc_id(ptr) {\n             // Only do anything if we can identify the allocation this goes to.\n             let (_size, cur_align, _kind) = this.get_alloc_info(alloc_id);"}, {"sha": "bc0b71fbc2096438dce1d725341353ef06d516ad", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -22,28 +22,52 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let this = self.eval_context_mut();\n \n-        this.assert_target_os(\"linux\", \"clock_gettime\");\n+        this.assert_target_os_is_unix(\"clock_gettime\");\n \n         let clk_id = this.read_scalar(clk_id_op)?.to_i32()?;\n \n-        // Linux has two main kinds of clocks. REALTIME clocks return the actual time since the\n-        // Unix epoch, including effects which may cause time to move backwards such as NTP.\n-        // Linux further distinguishes regular and \"coarse\" clocks, but the \"coarse\" version\n-        // is just specified to be \"faster and less precise\", so we implement both the same way.\n-        let absolute_clocks =\n-            [this.eval_libc_i32(\"CLOCK_REALTIME\")?, this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\")?];\n-        // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n-        // never allowed to go backwards. We don't need to do any additonal monotonicity\n-        // enforcement because std::time::Instant already guarantees that it is monotonic.\n-        let relative_clocks =\n-            [this.eval_libc_i32(\"CLOCK_MONOTONIC\")?, this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\")?];\n+        let absolute_clocks;\n+        let mut relative_clocks;\n+\n+        match this.tcx.sess.target.os.as_ref() {\n+            \"linux\" => {\n+                // Linux has two main kinds of clocks. REALTIME clocks return the actual time since the\n+                // Unix epoch, including effects which may cause time to move backwards such as NTP.\n+                // Linux further distinguishes regular and \"coarse\" clocks, but the \"coarse\" version\n+                // is just specified to be \"faster and less precise\", so we implement both the same way.\n+                absolute_clocks = vec![\n+                    this.eval_libc_i32(\"CLOCK_REALTIME\")?,\n+                    this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\")?,\n+                ];\n+                // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n+                // never allowed to go backwards. We don't need to do any additonal monotonicity\n+                // enforcement because std::time::Instant already guarantees that it is monotonic.\n+                relative_clocks = vec![\n+                    this.eval_libc_i32(\"CLOCK_MONOTONIC\")?,\n+                    this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\")?,\n+                ];\n+            }\n+            \"macos\" => {\n+                absolute_clocks = vec![this.eval_libc_i32(\"CLOCK_REALTIME\")?];\n+                relative_clocks = vec![this.eval_libc_i32(\"CLOCK_MONOTONIC\")?];\n+                // Some clocks only seem to exist in the aarch64 version of the target.\n+                if this.tcx.sess.target.arch == \"aarch64\" {\n+                    // `CLOCK_UPTIME_RAW` supposed to not increment while the system is asleep... but\n+                    // that's not really something a program running inside Miri can tell, anyway.\n+                    // We need to support it because std uses it.\n+                    relative_clocks.push(this.eval_libc_i32(\"CLOCK_UPTIME_RAW\")?);\n+                }\n+            }\n+            target => throw_unsup_format!(\"`clock_gettime` is not supported on target OS {target}\"),\n+        }\n \n         let duration = if absolute_clocks.contains(&clk_id) {\n             this.check_no_isolation(\"`clock_gettime` with `REALTIME` clocks\")?;\n             system_time_to_duration(&SystemTime::now())?\n         } else if relative_clocks.contains(&clk_id) {\n             this.machine.clock.now().duration_since(this.machine.clock.anchor())\n         } else {\n+            // Unsupported clock.\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i32(-1));"}, {"sha": "d746f9df90ac300fdec3d0a33a4e0a4f50d525c2", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -180,6 +180,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n+            \"clock_gettime\" => {\n+                let [clk_id, tp] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.clock_gettime(clk_id, tp)?;\n+                this.write_scalar(result, dest)?;\n+            }\n \n             // Allocation\n             \"posix_memalign\" => {"}, {"sha": "34076e842d55b51226df6ddfcf1ce6f1dc3f450b", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -43,15 +43,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.write_scalar(result, dest)?;\n             }\n \n-            // Time related shims\n-            \"clock_gettime\" => {\n-                // This is a POSIX function but it has only been tested on linux.\n-                let [clk_id, tp] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let result = this.clock_gettime(clk_id, tp)?;\n-                this.write_scalar(result, dest)?;\n-            }\n-\n             // Threading\n             \"pthread_condattr_setclock\" => {\n                 let [attr, clock_id] ="}, {"sha": "f2e2df5ad08004c1711256d94d7d5ebe09c4f6d0", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -14,7 +14,6 @@ use rustc_middle::mir::RetagKind;\n use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n-    Ty,\n };\n use rustc_target::abi::Abi;\n use rustc_target::abi::Size;\n@@ -983,28 +982,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let mut visitor = RetagVisitor { ecx: this, kind, retag_cause, retag_fields };\n         return visitor.visit_value(place);\n \n-        // Determine mutability and whether to add a protector.\n-        // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n-        // making it useless.\n-        fn qualify(ty: Ty<'_>, kind: RetagKind) -> Option<(RefKind, bool)> {\n-            match ty.kind() {\n-                // References are simple.\n-                ty::Ref(_, _, Mutability::Mut) =>\n-                    Some((\n-                        RefKind::Unique { two_phase: kind == RetagKind::TwoPhase },\n-                        kind == RetagKind::FnEntry,\n-                    )),\n-                ty::Ref(_, _, Mutability::Not) =>\n-                    Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n-                // Raw pointers need to be enabled.\n-                ty::RawPtr(tym) if kind == RetagKind::Raw =>\n-                    Some((RefKind::Raw { mutable: tym.mutbl == Mutability::Mut }, false)),\n-                // Boxes are handled separately due to that allocator situation,\n-                // see the visitor below.\n-                _ => None,\n-            }\n-        }\n-\n         // The actual visitor.\n         struct RetagVisitor<'ecx, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriInterpCx<'mir, 'tcx>,\n@@ -1057,34 +1034,58 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     return Ok(());\n                 }\n \n-                let recurse_for_fields = || {\n-                    match self.retag_fields {\n-                        RetagFields::No => false,\n-                        RetagFields::Yes => true,\n-                        RetagFields::OnlyScalar => {\n-                            // Matching `ArgAbi::new` at the time of writing, only fields of\n-                            // `Scalar` and `ScalarPair` ABI are considered.\n-                            matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                // Check the type of this value to see what to do with it (retag, or recurse).\n+                match place.layout.ty.kind() {\n+                    ty::Ref(_, _, mutbl) => {\n+                        let ref_kind = match mutbl {\n+                            Mutability::Mut =>\n+                                RefKind::Unique { two_phase: self.kind == RetagKind::TwoPhase },\n+                            Mutability::Not => RefKind::Shared,\n+                        };\n+                        self.retag_place(\n+                            place,\n+                            ref_kind,\n+                            self.retag_cause,\n+                            /*protector*/ self.kind == RetagKind::FnEntry,\n+                        )?;\n+                    }\n+                    ty::RawPtr(tym) => {\n+                        // We definitely do *not* want to recurse into raw pointers -- wide raw\n+                        // pointers have fields, and for dyn Trait pointees those can have reference\n+                        // type!\n+                        if self.kind == RetagKind::Raw {\n+                            // Raw pointers need to be enabled.\n+                            self.retag_place(\n+                                place,\n+                                RefKind::Raw { mutable: tym.mutbl == Mutability::Mut },\n+                                self.retag_cause,\n+                                /*protector*/ false,\n+                            )?;\n+                        }\n+                    }\n+                    _ if place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box()) => {\n+                        // Recurse for boxes, they require some tricky handling and will end up in `visit_box` above.\n+                        // (Yes this means we technically also recursively retag the allocator itself\n+                        // even if field retagging is not enabled. *shrug*)\n+                        self.walk_value(place)?;\n+                    }\n+                    _ => {\n+                        // Not a reference/pointer/box. Only recurse if configured appropriately.\n+                        let recurse = match self.retag_fields {\n+                            RetagFields::No => false,\n+                            RetagFields::Yes => true,\n+                            RetagFields::OnlyScalar => {\n+                                // Matching `ArgAbi::new` at the time of writing, only fields of\n+                                // `Scalar` and `ScalarPair` ABI are considered.\n+                                matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                            }\n+                        };\n+                        if recurse {\n+                            self.walk_value(place)?;\n                         }\n                     }\n-                };\n-\n-                if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n-                    self.retag_place(place, ref_kind, self.retag_cause, protector)?;\n-                } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n-                    // Wide raw pointers *do* have fields and their types are strange.\n-                    // vtables have a type like `&[*const (); 3]` or so!\n-                    // Do *not* recurse into them.\n-                    // (No need to worry about wide references, those always \"qualify\". And Boxes\n-                    // are handles specially by the visitor anyway.)\n-                } else if recurse_for_fields()\n-                    || place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n-                {\n-                    // Recurse deeper. Need to always recurse for `Box` to even hit `visit_box`.\n-                    // (Yes this means we technically also recursively retag the allocator itself\n-                    // even if field retagging is not enabled. *shrug*)\n-                    self.walk_value(place)?;\n                 }\n+\n                 Ok(())\n             }\n         }"}, {"sha": "46b3afa70e5b0fd0e3fd89f5f7d47cd358a9fdbf", "filename": "src/tools/miri/test-cargo-miri/run-test.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Frun-test.py?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -133,7 +133,7 @@ def test_cargo_miri_test():\n     test(\"`cargo miri test`\",\n         cargo_miri(\"test\"),\n         default_ref, \"test.stderr-empty.ref\",\n-        env={'MIRIFLAGS': \"-Zmiri-permissive-provenance -Zmiri-seed=feed\"},\n+        env={'MIRIFLAGS': \"-Zmiri-permissive-provenance -Zmiri-seed=4242\"},\n     )\n     test(\"`cargo miri test` (no isolation, no doctests)\",\n         cargo_miri(\"test\") + [\"--bins\", \"--tests\"], # no `--lib`, we disabled that in `Cargo.toml`"}, {"sha": "2a4300fcd049ec2d2669d77800b8631cc9e7d90c", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -181,17 +181,25 @@ fn test_thread_local_errno() {\n }\n \n /// Tests whether clock support exists at all\n-#[cfg(target_os = \"linux\")]\n fn test_clocks() {\n     let mut tp = std::mem::MaybeUninit::<libc::timespec>::uninit();\n     let is_error = unsafe { libc::clock_gettime(libc::CLOCK_REALTIME, tp.as_mut_ptr()) };\n     assert_eq!(is_error, 0);\n-    let is_error = unsafe { libc::clock_gettime(libc::CLOCK_REALTIME_COARSE, tp.as_mut_ptr()) };\n-    assert_eq!(is_error, 0);\n     let is_error = unsafe { libc::clock_gettime(libc::CLOCK_MONOTONIC, tp.as_mut_ptr()) };\n     assert_eq!(is_error, 0);\n-    let is_error = unsafe { libc::clock_gettime(libc::CLOCK_MONOTONIC_COARSE, tp.as_mut_ptr()) };\n-    assert_eq!(is_error, 0);\n+    #[cfg(target_os = \"linux\")]\n+    {\n+        let is_error = unsafe { libc::clock_gettime(libc::CLOCK_REALTIME_COARSE, tp.as_mut_ptr()) };\n+        assert_eq!(is_error, 0);\n+        let is_error =\n+            unsafe { libc::clock_gettime(libc::CLOCK_MONOTONIC_COARSE, tp.as_mut_ptr()) };\n+        assert_eq!(is_error, 0);\n+    }\n+    #[cfg(all(target_os = \"macos\", target_arch = \"aarch64\"))]\n+    {\n+        let is_error = unsafe { libc::clock_gettime(libc::CLOCK_UPTIME_RAW, tp.as_mut_ptr()) };\n+        assert_eq!(is_error, 0);\n+    }\n }\n \n fn test_posix_gettimeofday() {\n@@ -293,11 +301,11 @@ fn main() {\n     test_thread_local_errno();\n \n     test_isatty();\n+    test_clocks();\n \n     #[cfg(target_os = \"linux\")]\n     {\n         test_posix_fadvise();\n         test_sync_file_range();\n-        test_clocks();\n     }\n }"}, {"sha": "4e1584b838714c415c70e8d2133d287fcedb6f0b", "filename": "src/tools/miri/tests/pass/align_offset_symbolic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Falign_offset_symbolic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Falign_offset_symbolic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Falign_offset_symbolic.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -1,4 +1,7 @@\n //@compile-flags: -Zmiri-symbolic-alignment-check\n+#![feature(strict_provenance)]\n+\n+use std::ptr;\n \n fn test_align_offset() {\n     let d = Box::new([0u32; 4]);\n@@ -16,6 +19,9 @@ fn test_align_offset() {\n     assert_eq!(raw.wrapping_offset(2).align_offset(2), 0);\n     assert_eq!(raw.wrapping_offset(2).align_offset(4), 2);\n     assert_eq!(raw.wrapping_offset(2).align_offset(8), usize::MAX); // requested alignment higher than allocation alignment\n+\n+    let p = ptr::invalid::<()>(1);\n+    assert_eq!(p.align_offset(1), 0);\n }\n \n fn test_align_to() {"}, {"sha": "5d57df4e52bfabec0eff2ebbaeb223bd435182c4", "filename": "src/tools/miri/tests/pass/panic/catch_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911cbf8e46f0f3b044c87fc5cbca922878db757b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fcatch_panic.rs?ref=911cbf8e46f0f3b044c87fc5cbca922878db757b", "patch": "@@ -69,7 +69,7 @@ fn main() {\n     });\n \n     test(Some(\"align_offset: align is not a power-of-two\"), |_old_val| {\n-        (0usize as *const u8).align_offset(3);\n+        let _ = (0usize as *const u8).align_offset(3);\n         loop {}\n     });\n "}]}