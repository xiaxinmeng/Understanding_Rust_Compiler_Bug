{"sha": "e542f4fa59a2d1ae33bebcd1e11149f7644db5da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NDJmNGZhNTlhMmQxYWUzM2JlYmNkMWUxMTE0OWY3NjQ0ZGI1ZGE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2020-04-14T13:47:03Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2020-04-14T13:47:03Z"}, "message": "If an LLVM module's exports change, cannot reuse its post-LTO object file in\nincremental compilation.\n\nThis is symmetric to PR #67020, which handled the case where the LLVM module's\n*imports* changed. This commit builds upon the infrastructure added there; the\nexport map is just the inverse of the import map, so we can build the export map\nat the same time that we load the serialized import map.\n\nFix #69798", "tree": {"sha": "3b5b072be37c51aa705237979044109ea26a0116", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b5b072be37c51aa705237979044109ea26a0116"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e542f4fa59a2d1ae33bebcd1e11149f7644db5da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e542f4fa59a2d1ae33bebcd1e11149f7644db5da", "html_url": "https://github.com/rust-lang/rust/commit/e542f4fa59a2d1ae33bebcd1e11149f7644db5da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e542f4fa59a2d1ae33bebcd1e11149f7644db5da/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5179ebe2064e15196c5be1f8df950736140b8fdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5179ebe2064e15196c5be1f8df950736140b8fdd", "html_url": "https://github.com/rust-lang/rust/commit/5179ebe2064e15196c5be1f8df950736140b8fdd"}], "stats": {"total": 37, "additions": 33, "deletions": 4}, "files": [{"sha": "c97e108b0f53cd1ee445a92b35ac03a0989fccb9", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e542f4fa59a2d1ae33bebcd1e11149f7644db5da/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e542f4fa59a2d1ae33bebcd1e11149f7644db5da/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=e542f4fa59a2d1ae33bebcd1e11149f7644db5da", "patch": "@@ -517,11 +517,20 @@ fn thin_lto(\n \n                 let prev_imports = prev_import_map.modules_imported_by(module_name);\n                 let curr_imports = curr_import_map.modules_imported_by(module_name);\n+                let prev_exports = prev_import_map.modules_exported_by(module_name);\n+                let curr_exports = curr_import_map.modules_exported_by(module_name);\n                 let imports_all_green = curr_imports\n                     .iter()\n                     .all(|imported_module| green_modules.contains_key(imported_module));\n+                let exports_all_green = curr_exports\n+                    .iter()\n+                    .all(|exported_module| green_modules.contains_key(exported_module));\n \n-                if imports_all_green && equivalent_as_sets(prev_imports, curr_imports) {\n+                if imports_all_green\n+                    && equivalent_as_sets(prev_imports, curr_imports)\n+                    && exports_all_green\n+                    && equivalent_as_sets(prev_exports, curr_exports)\n+                {\n                     let work_product = green_modules[module_name].clone();\n                     copy_jobs.push(work_product);\n                     info!(\" - {}: re-used\", module_name);\n@@ -885,13 +894,19 @@ pub unsafe fn optimize_thin_module(\n pub struct ThinLTOImports {\n     // key = llvm name of importing module, value = list of modules it imports from\n     imports: FxHashMap<String, Vec<String>>,\n+    // key = llvm name of exporting module, value = list of modules it exports to\n+    exports: FxHashMap<String, Vec<String>>,\n }\n \n impl ThinLTOImports {\n     fn modules_imported_by(&self, llvm_module_name: &str) -> &[String] {\n         self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n     }\n \n+    fn modules_exported_by(&self, llvm_module_name: &str) -> &[String] {\n+        self.exports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n+    }\n+\n     fn save_to_file(&self, path: &Path) -> io::Result<()> {\n         use std::io::Write;\n         let file = File::create(path)?;\n@@ -909,13 +924,17 @@ impl ThinLTOImports {\n     fn load_from_file(path: &Path) -> io::Result<ThinLTOImports> {\n         use std::io::BufRead;\n         let mut imports = FxHashMap::default();\n-        let mut current_module = None;\n-        let mut current_imports = vec![];\n+        let mut exports: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+        let mut current_module: Option<String> = None;\n+        let mut current_imports: Vec<String> = vec![];\n         let file = File::open(path)?;\n         for line in io::BufReader::new(file).lines() {\n             let line = line?;\n             if line.is_empty() {\n                 let importing_module = current_module.take().expect(\"Importing module not set\");\n+                for imported in &current_imports {\n+                    exports.entry(imported.clone()).or_default().push(importing_module.clone());\n+                }\n                 imports.insert(importing_module, mem::replace(&mut current_imports, vec![]));\n             } else if line.starts_with(' ') {\n                 // Space marks an imported module\n@@ -927,7 +946,7 @@ impl ThinLTOImports {\n                 current_module = Some(line.trim().to_string());\n             }\n         }\n-        Ok(ThinLTOImports { imports })\n+        Ok(ThinLTOImports { imports, exports })\n     }\n \n     /// Loads the ThinLTO import map from ThinLTOData.\n@@ -951,7 +970,17 @@ impl ThinLTOImports {\n                 .get_mut(importing_module_name)\n                 .unwrap()\n                 .push(imported_module_name.to_owned());\n+\n+            if !map.exports.contains_key(imported_module_name) {\n+                map.exports.insert(imported_module_name.to_owned(), vec![]);\n+            }\n+\n+            map.exports\n+                .get_mut(imported_module_name)\n+                .unwrap()\n+                .push(importing_module_name.to_owned());\n         }\n+\n         let mut map = ThinLTOImports::default();\n         llvm::LLVMRustGetThinLTOModuleImports(\n             data,"}]}